/**
 * @license
 * Copyright (c) 2014, 2024, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('ojtranslations/nls/localeElements',{root:{supplemental:{defaultRegion:{ar:"001",as:"IN",be:"BY",bg:"BG",bn:"BD",bo:"CN",brx:"IN",bs:"BA",ca:"ES",cs:"CZ",da:"DK",de:"DE",el:"GR",en:"US",es:"ES",et:"EE",fi:"FI",fr:"FR",ga:"IE",gu:"IN",he:"IL",hi:"IN",hr:"HR",hu:"HU",id:"ID",is:"IS",it:"IT",ja:"JP",kn:"IN",ko:"KR",kok:"IN",ks:"IN","ks-Arab":"IN",lt:"LT",lv:"LV",mk:"MK",ml:"IN",mr:"IN",ms:"MY",mt:"MT",nb:"NO",ne:"NP",nl:"NL",nn:"NO",no:"NO",or:"IN",pa:"IN","pa-Guru":"IN","pa-Arab":"PK",pl:"PL",pt:"BR",ro:"RO",ru:"RU",sk:"SK",sl:"SI",sq:"AL",sr:"RS","sr-Cyrl":"RS","sr-Latn":"RS",sv:"SE",ta:"IN",te:"IN",th:"TH",tr:"TR",uk:"UA",ur:"PK",vi:"VN",zh:"CN","zh-Hans":"CN","zh-Hant":"TW"},weekData:{firstDay:{"001":1,AE:6,BH:6,BR:0,DZ:6,EG:6,IQ:6,JO:6,KW:6,LB:1,LY:6,MA:6,OM:6,QA:6,SA:0,SD:6,SY:6,TN:0,YE:0,BY:1,BG:1,ES:1,CZ:1,DK:1,AT:1,CH:1,DE:1,LU:1,CY:1,GR:1,AU:0,CA:0,GB:1,IE:0,IN:0,MT:0,NZ:0,PH:0,SG:0,US:0,ZA:0,AR:0,CL:1,CO:0,CR:1,DO:0,EC:1,GT:0,HN:0,MX:0,NI:0,PA:0,PE:0,PR:0,PY:0,SV:0,UY:1,VE:0,EE:1,FI:1,BE:1,FR:1,IL:0,HR:1,HU:1,ID:0,IS:1,IT:1,JP:0,KR:0,LT:1,LV:1,MK:1,MY:1,NO:1,NL:1,PL:1,PT:1,RO:1,RU:1,SK:1,SI:1,AL:1,BA:1,ME:1,RS:1,SE:1,TH:0,TR:1,UA:1,VN:1,CN:0,HK:0,MO:0,TW:0},weekendStart:{"001":6,AE:5,BH:5,DZ:5,EG:5,IQ:5,JO:5,KW:5,LY:5,MA:5,OM:5,QA:5,SA:5,SD:5,SY:5,TN:5,YE:5,IN:0,IL:5},weekendEnd:{"001":0,AE:6,BH:6,DZ:6,EG:6,IQ:6,JO:6,KW:6,LY:6,MA:6,OM:6,QA:6,SA:6,SD:6,SY:6,TN:6,YE:6,IL:6}},prefferedHours:{"001":"H",AE:"h",BH:"h",DZ:"h",EG:"h",IQ:"h",JO:"h",KW:"h",LB:"h",LY:"h",MA:"H",OM:"h",QA:"h",SA:"h",SD:"h",SY:"h",TN:"h",YE:"h",BG:"H",ES:"H",CZ:"H",DK:"H",AT:"H",CH:"H",DE:"H",LU:"H",CY:"h",GR:"h",AU:"h",CA:"h",GB:"H",IE:"H",IN:"h",NZ:"h",PH:"h",SG:"h",US:"h",ZA:"h",AR:"H",BO:"H",CL:"H",CO:"h",CR:"H",CU:"H",DO:"h",EC:"H",GT:"H",HN:"H",MX:"H",NI:"H",PA:"h",PE:"H",PR:"h",SV:"H",UY:"H",VE:"h",EE:"H",FI:"H",BE:"H",FR:"H",IL:"H",HR:"H",ID:"H",IS:"H",IT:"H",JP:"H",KR:"h",LT:"H",LV:"H",MK:"H",MY:"h",NL:"H",PT:"H",RO:"H",RU:"H",SK:"H",SI:"H",AL:"h",BA:"H",ME:"H",RS:"H",SE:"H",TR:"H",UA:"H",CN:"h",HK:"h",MO:"h",TW:"h"},currencyData:{fractions:{IDR:{_digits:"0"},JPY:{_digits:"0"},KRW:{_digits:"0"},AFN:{_digits:"0"},ADP:{_digits:"0"},BHD:{_digits:"3"},BYR:{_digits:"0"},BIF:{_digits:"0"},XOF:{_digits:"0"},XAF:{_digits:"0"},XPF:{_digits:"0"},CLP:{_digits:"0"},KMF:{_digits:"0"},DJF:{_digits:"0"},STD:{_digits:"0"},PYG:{_digits:"0"},GNF:{_digits:"0"},ISK:{_digits:"0"},IQD:{_digits:"0"},ITL:{_digits:"0"},LAK:{_digits:"0"},KWD:{_digits:"3"},MMK:{_digits:"0"},LBP:{_digits:"0"},ALL:{_digits:"0"},SLL:{_digits:"0"},LUF:{_digits:"0"},LYD:{_digits:"3"},MGF:{_digits:"0"},TMM:{_digits:"0"},KPW:{_digits:"0"},MRO:{_digits:"0"},IDR:{_digits:"2"},RWF:{_digits:"0"},RSD:{_digits:"0"},SOS:{_digits:"0"},ESP:{_digits:"0"},SYP:{_digits:"0"},TND:{_digits:"3"},TRL:{_digits:"0"},UYW:{_digits:"4"},CLF:{_digits:"4"},UYI:{_digits:"0"},VUV:{_digits:"0"},YER:{_digits:"0"},ZMK:{_digits:"0"},ZWD:{_digits:"0"},VND:{_digits:"0"}}}}},ar:1,"ar-AE":1,"ar-BH":1,"ar-DZ":1,"ar-EG":1,"ar-IQ":1,"ar-JO":1,"ar-KW":1,"ar-LB":1,"ar-LY":1,"ar-MA":1,"ar-OM":1,"ar-QA":1,"ar-SA":1,"ar-SD":1,"ar-SY":1,"ar-TN":1,"ar-YE":1,as:1,be:1,"be-BY":1,bg:1,"bg-BG":1,bn:1,bo:1,"bo-IN":1,brx:1,bs:1,"bs-Cyrl":1,"bs-Cyrl-BA":1,"bs-Latn":1,"bs-Latn-BA":1,ca:1,"ca-ES":1,cs:1,"cs-CZ":1,da:1,"da-DK":1,de:1,"de-AT":1,"de-CH":1,"de-DE":1,"de-LU":1,el:1,"el-CY":1,"el-GR":1,en:1,"en-AU":1,"en-CA":1,"en-GB":1,"en-IE":1,"en-IN":1,"en-MT":1,"en-NZ":1,"en-PH":1,"en-SG":1,"en-US":1,"en-ZA":1,es:1,"es-AR":1,"es-BO":1,"es-CL":1,"es-CO":1,"es-CR":1,"es-CU":1,"es-DO":1,"es-EC":1,"es-ES":1,"es-GT":1,"es-HN":1,"es-MX":1,"es-NI":1,"es-PA":1,"es-PE":1,"es-PR":1,"es-PY":1,"es-SV":1,"es-US":1,"es-UY":1,"es-VE":1,et:1,"et-EE":1,fi:1,"fi-FI":1,fr:1,"fr-BE":1,"fr-CA":1,"fr-CH":1,"fr-FR":1,"fr-LU":1,ga:1,"ga-IE":1,gu:1,he:1,"he-IL":1,hi:1,"hi-IN":1,hr:1,"hr-HR":1,hu:1,"hu-HU":1,id:1,"id-ID":1,is:1,"is-IS":1,it:1,"it-CH":1,"it-IT":1,ja:1,"ja-JP":1,kn:1,ko:1,"ko-KR":1,kok:1,ks:1,lt:1,"lt-LT":1,lv:1,"lv-LV":1,mk:1,"mk-MK":1,ml:1,mr:1,ms:1,"ms-MY":1,mt:1,"mt-MT":1,nb:1,"nb-NO":1,ne:1,"ne-IN":1,nl:1,"nl-BE":1,"nl-NL":1,nn:1,"nn-NO":1,no:1,"no-NO":1,or:1,pa:1,pl:1,"pl-PL":1,pt:1,"pt-BR":1,"pt-PT":1,ro:1,"ro-RO":1,ru:1,"ru-RU":1,sk:1,"sk-SK":1,sl:1,"sl-SI":1,sq:1,"sq-AL":1,sr:1,"sr-Cyrl":1,"sr-Cyrl-BA":1,"sr-Cyrl-ME":1,"sr-Cyrl-RS":1,"sr-Latn":1,"sr-Latn-BA":1,"sr-Latn-ME":1,"sr-Latn-RS":1,sv:1,"sv-SE":1,ta:1,te:1,th:1,"th-TH":1,tr:1,"tr-TR":1,uk:1,"uk-UA":1,ur:1,"ur-IN":1,vi:1,"vi-VN":1,zh:1,"zh-Hans":1,"zh-Hans-CN":1,"zh-Hans-SG":1,"zh-Hant":1,"zh-Hant-HK":1,"zh-Hant-MO":1,"zh-Hant-TW":1,__noOverlay:!0,__defaultNoOverlayLocale:"en-US"});


define('ojs/ojcalendarutils',['exports', '@oracle/oraclejet-preact/UNSAFE_IntlDateTime'], function (exports, UNSAFE_IntlDateTime) { 'use strict';



	Object.defineProperty(exports, 'CalendarUtils', {
		enumerable: true,
		get: function () {
			return UNSAFE_IntlDateTime.CalendarUtils;
		}
	});

	Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojlocaledata',['exports', 'ojs/ojcore-base', 'ojs/ojconfig', 'ojL10n!ojtranslations/nls/localeElements', 'ojs/ojcalendarutils'], function (exports, oj, Config, ojldimport, ojcalendarutils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  ojldimport = ojldimport && Object.prototype.hasOwnProperty.call(ojldimport, 'default') ? ojldimport['default'] : ojldimport;

  var ojld = ojldimport;

  /**
   * @namespace oj.LocaleData
   * @classdesc Locale Data Services
   * @export
   * @since 0.6.0
   * @ojtsmodule
   * @hideconstructor
   */
  const LocaleData = {};

  oj._registerLegacyNamespaceProp('LocaleData', LocaleData);

  /**
   * Sets the Locale Elements bundle used by JET
   * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
   * a Locale Elements for JET.
   * This method may also be used by an application that wants to completely replace the Locale Elements bundle that is automatically
   * fetched by an AMD loader.
   * @param {Object} bundle resource bundle that should be used by the framework
   * @return {void}
   * @export
   * @method setBundle
   * @memberof oj.LocaleData
   */
  LocaleData.setBundle = function (bundle) {
    LocaleData._bundle = bundle;
  };

  /**
   * Retrieves the first day of week for the current locale's region
   * @return {number} a numeric representation of the first week day of the week:
   * 0 for Sunday, 1 for Monday, etc.
   * @export
   * @method getFirstDayOfWeek
   * @memberof oj.LocaleData
   */
  LocaleData.getFirstDayOfWeek = function () {
    return LocaleData._getWeekData('firstDay');
  };

  /**
   * Retrieves the first weekend day for the current locale's region
   * @return {number} a numeric representation of the first weekend day:
   * 0 for Sunday, 1 for Monday, etc.
   * @export
   * @method getWeekendStart
   * @memberof oj.LocaleData
   */
  LocaleData.getWeekendStart = function () {
    return LocaleData._getWeekData('weekendStart');
  };

  /**
   * Retrieves the last weekend day for the current locale's region
   * @return {number} a numeric representation of the last weekend day:
   * 0 for Sunday, 1 for Monday, etc.
   * @export
   * @method getWeekendEnd
   * @memberof oj.LocaleData
   */
  LocaleData.getWeekendEnd = function () {
    return LocaleData._getWeekData('weekendEnd');
  };

  /**
   * Retrieves locale-specific names of the days of the week
   * @return {Array.<string>} names of the days from Sunday through Sturday
   * @param {string} [type] - the type of the name. Currently, "abbreviated", "narrow" and "wide" are supported
   * @ojsignature { target:"Type", for: "type", value: "'abbreviated'|'narrow'|'wide'"}
   * @export
   * @method getDayNames
   * @memberof oj.LocaleData
   */
  LocaleData.getDayNames = function (type) {
    if (type == null || (type !== 'abbreviated' && type !== 'narrow')) {
      // eslint-disable-next-line no-param-reassign
      type = 'wide';
    }
    var days = LocaleData._getCalendarData().days['stand-alone'][type];

    return [days.sun, days.mon, days.tue, days.wed, days.thu, days.fri, days.sat];
  };

  /**
   * Retrieves locale-specific names of months
   * @return {Array.<string>} names of months from January through December
   * @param {string} [type] - the type of the name. Currently, "abbreviated", "narrow" and "wide" are supported
   * @ojsignature { target:"Type", for: "type", value: "'abbreviated'|'narrow'|'wide'"}
   * @export
   * @method getMonthNames
   * @memberof oj.LocaleData
   */
  LocaleData.getMonthNames = function (type) {
    if (type == null || (type !== 'abbreviated' && type !== 'narrow')) {
      // eslint-disable-next-line no-param-reassign
      type = 'wide';
    }
    var months = LocaleData._getCalendarData().months['stand-alone'][type];

    return [
      months['1'],
      months['2'],
      months['3'],
      months['4'],
      months['5'],
      months['6'],
      months['7'],
      months['8'],
      months['9'],
      months['10'],
      months['11'],
      months['12']
    ];
  };

  /**
   * Retrieves whether month is displayed prior to year
   * @return {boolean} whether month is prior to year
   * @export
   * @method isMonthPriorToYear
   * @memberof oj.LocaleData
   * @ojdeprecated [{since: "11.0.0", description: "This is used internally by the oj-date-picker component,
   *  and should not be called by application code. If the functionality is needed, use Intl.DateTimeFormat.formatToParts
   *  instead which returns the formatted pieces in order."}]
   */
  LocaleData.isMonthPriorToYear = function () {
    var options = { dateStyle: 'long' };
    var locale = Config.getLocale();
    var d = new Date();
    var intlFormatter = new Intl.DateTimeFormat(locale, options);
    var parts = intlFormatter.formatToParts(d);
    var monthIndex = parts.findIndex((obj) => obj.type === 'month');
    var yearIndex = parts.findIndex((obj) => obj.type === 'year');
    return monthIndex < yearIndex;
  };

  /**
   * @hidden
   * @private
   */
  LocaleData._getWeekData = function (key) {
    var b = LocaleData.__getBundle();
    var defRegion = '001';
    var region = LocaleData._getRegion() || defRegion;

    var data = b.supplemental.weekData[key];

    var val = data[region];

    if (val === undefined) {
      val = data[defRegion];
    }

    return val;
  };

  /**
   * @hidden
   * @private
   */
  LocaleData._getCalendarData = function () {
    var locale = Config.getLocale();
    var cal = ojcalendarutils.CalendarUtils.getCalendar(locale, 'gregory');
    return cal;
  };

  /**
   * @hidden
   * @private
   */
  LocaleData._getRegion = function () {
    var locale = Config.getLocale();
    if (locale) {
      var tokens = locale.toUpperCase().split(/-|_/);
      if (tokens.length >= 2) {
        var tag = tokens[1];
        if (tag.length === 4) {
          // this is a script tag
          if (tokens.length >= 3) {
            return tokens[2];
          }
        } else {
          return tag;
        }
      }
    }
    // try default region
    var b = LocaleData.__getBundle();
    var regions = b.supplemental.defaultRegion;
    return regions[locale];
  };

  /**
   * @hidden
   * @private
   */
  LocaleData.__getBundle = function () {
    var b = LocaleData._bundle;
    if (b) {
      return b;
    }
    return ojld;
  };

  /**
   * Called from oj.Config after AMD loader fetches LocaleElements for the new locale.
   *
   * @hidden
   * @private
   *
   */
  LocaleData.__updateBundle = function (bundle) {
    ojld = bundle;
  };

  const getDayNames = LocaleData.getDayNames;
  const getFirstDayOfWeek = LocaleData.getFirstDayOfWeek;
  const getMonthNames = LocaleData.getMonthNames;
  const getWeekendEnd = LocaleData.getWeekendEnd;
  const getWeekendStart = LocaleData.getWeekendStart;
  const isMonthPriorToYear = LocaleData.isMonthPriorToYear;
  const setBundle = LocaleData.setBundle;
  const __getBundle = LocaleData.__getBundle;
  const _getCalendarData = LocaleData._getCalendarData;

  exports.__getBundle = __getBundle;
  exports._getCalendarData = _getCalendarData;
  exports.getDayNames = getDayNames;
  exports.getFirstDayOfWeek = getFirstDayOfWeek;
  exports.getMonthNames = getMonthNames;
  exports.getWeekendEnd = getWeekendEnd;
  exports.getWeekendStart = getWeekendStart;
  exports.isMonthPriorToYear = isMonthPriorToYear;
  exports.setBundle = setBundle;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojconverterutils',['ojs/ojcore-base', 'ojs/ojlogger'], function (oj, Logger) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    class ConverterUtils {
    }
    ConverterUtils.getConverterInstance = function (converterOption) {
        let cTypeStr = '';
        let cOptions = {};
        let converterInstance = null;
        if (converterOption) {
            if (typeof converterOption === 'object') {
                if ((converterOption.parse && typeof converterOption.parse === 'function') ||
                    (converterOption.format && typeof converterOption.format === 'function')) {
                    converterInstance = converterOption;
                }
                else {
                    cTypeStr = converterOption.type;
                    cOptions = converterOption.options || {};
                }
            }
            if (!converterInstance) {
                cTypeStr = cTypeStr || converterOption;
                if (cTypeStr && typeof cTypeStr === 'string') {
                    if (oj.Validation && oj.Validation.converterFactory) {
                        var cf = oj.Validation.converterFactory(cTypeStr);
                        return cf.createConverter(cOptions);
                    }
                    else {
                        Logger.error('oj.Validation.converterFactory is not available and it is needed to support the deprecated json format for the converters property. Please include the backward compatibility "ojvalidation-base" module.');
                    }
                }
            }
        }
        return converterInstance;
    };

    return ConverterUtils;

});


define('ojs/ojvalidator',['ojs/ojcore'], function (oj) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * Validator Contract
   * @ignore
   */

  /**
   *  @example <caption>Create a Validator and implement its methods.</caption>
   *
   *  //Validator to ensure that the selected time is a multiple of 15 minute interval.
   *  //This converter takes in a converter option which will be used to format the hint/error
   *  //message shown to the user. It is mandatory to pass the converter option.
   *  var TimeIncrementValidator = function (options) {
   *    if(options && options.converter){
   *      this._converter = options.converter;
   *    }
   *  };
   *  //Need to be a subclass of Validator
   *  oj.Object.createSubclass(TimeIncrementValidator, Validator, "TimeIncrementValidator");
   *
   *  // Validates if the passed in value is a multiple of 15 minute interval.
   *  // Throws an error if the validation fails.
   *  TimeIncrementValidator.prototype.validate = function (value)
   *  {
   *    if (value)
   *    {
   *      var currentTime = oj.IntlConverterUtils.isoToLocalDate(value);
   *      var previousValidValue, nextValidValue, sampleMinutes;
   *      var minutes = currentTime.getMinutes();
   *      //Check if the minute is in increment of 15 by taking a modulo
   *      if ((minutes % 15) !== 0)
   *      {
   *        sampleMinute = Math.floor((minutes / 15))*15;
   *        currentTime.setMinutes(sampleMinute);
   *        previousValidValue = oj.IntlConverterUtils.dateToLocalIso(currentTime);
   *        sampleMinute = sampleMinute+ 15;
   *        if(sampleMinute >= 60){
   *          sampleMinute = 0;
   *          currentTime.setTime(currentTime.getTime() + (60*60*1000));
   *        }
   *        currentTime.setMinutes(sampleMinute);
   *        nextValidValue = oj.IntlConverterUtils.dateToLocalIso(currentTime);
   *        throw new ValidatorError("Only multiples of 15 minute intervals are allowed.", "For example, " + this._converter.format(previousValidValue) +
   *                                     " or "+ this._converter.format(nextValidValue));
   *      }
   *    }
   *  };
   *
   *  //Generates a hint message with 4 different samples of valid values.
   *  TimeIncrementValidator.prototype.getHint = function ()
   *  {
   *    var currentTime = new Date();
   *    var hintMessage = "Only 15 minute intervals accepted, for example";
   *    //generate 4 sample values
   *    for (var i = 0; i < 4; i++) {
   *      currentTime.setMinutes(i * 15);
   *      hintMessage = hintMessage + ", " + this._converter.format(oj.IntlConverterUtils.dateToLocalIso(currentTime));
   *    }
   *    return hintMessage;
   *  };
   * @example <caption>Create a Validator and implement its methods. Bind it to the
   * JET form component which will call this 'validate' to validate the user's input.</caption>
   *  // Validator that ensures endDate is never less than start date
   *  self.endDateValidator = {
   *    'validate' : function(value)
   *    {
   *      var value =  oj.IntlConverterUtils.isoToLocalDate(value);
   *      var start = oj.IntlConverterUtils.isoToLocalDate(self.startDate());
   *      if (value && !(value.getFullYear() > start.getFullYear() ||
   *      {
   *        throw new ValidatorError('End Date cannot be less than Start Date');
   *      }
   *    },
   *    'getHint' : function() { return "End Date needs to be greater than Start Date");}
   *  };
   *  -- HTML --
   *  &lt;oj-input-date id="nextday" value="{{endDate}}"
   *  validators="{{[weekendDateValidator, endDateValidator]}}">&lt;/oj-input-date>
   * @interface
   * @name oj.Validator
   * @param {Object=} options An object which contains the options for the validator
   * @ojsignature {target: "Type", value: "interface Validator<V>", genericParameters: [{"name": "V", "description": "Type of value to be validated"}]}
   * @ojtsmodule
   * @export
   * @since 0.6.0
   *
   */
  const Validator = function (options) {
    this.Init(options);
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(Validator, oj.Object, 'oj.Validator');

  /**
   * Initializes validator instance with the set options
   * @export
   * @ignore
   */
  // eslint-disable-next-line no-unused-vars
  Validator.prototype.Init = function (options) {
    Validator.superclass.Init.call(this);
  };

  /**
   * Validates the value.
   * The function typically returns if the validation passes and throws an error if it fails.
   *
   * @example <caption>Create a Validator and implement the validate method. Bind it to the
   * JET form component which will call this 'validate' to validate the user's input.</caption>
   *  // Validator that ensures endDate is never less than start date
   *  self.endDateValidator = {
   *    'validate' : function(value)
   *    {
   *      var value =  oj.IntlConverterUtils.isoToLocalDate(value);
   *      var start = oj.IntlConverterUtils.isoToLocalDate(self.startDate());
   *      if (value && !(value.getFullYear() > start.getFullYear() ||
   *      {
   *        throw new ValidatorError('End Date cannot be less than Start Date');
   *      }
   *    },
   *    'getHint' : function() { return "End Date needs to be greater than Start Date");}
   *  };
   *  -- HTML --
   *  &lt;oj-input-date id="nextday" value="{{endDate}}"
   *  validators="{{[weekendDateValidator, endDateValidator]}}">&lt;/oj-input-date>
   * @param {any} value to be validated
   * @return {void}
   * @throws {Error} if validation fails
   * @method validate
   * @ojsignature [{target: "Type",
   *                value: "V",
   *                for: "value"},
   *                {target: "Type",
   *                value: "void",
   *                for: "returns"}]
   * @memberof oj.Validator
   * @instance
   */

  /**
   * Returns a hint that describes the validator rule.
   * @example <caption>Create a Validator and implement the getHint method. Bind it to the
   * JET form component which will show the hint.</caption>
   *  // Validator that ensures endDate is never less than start date
   *  self.endDateValidator = {
   *    'validate' : function(value)
   *    {
   *      ...
   *    },
   *    'getHint' : function() { return "End Date needs to be greater than Start Date");}
   *  };
   *  -- HTML --
   *  &lt;oj-input-date id="nextday" value="{{endDate}}"
   *  validators="{{[weekendDateValidator, endDateValidator]}}">&lt;/oj-input-date>
   * @returns {string|null} a hint string or null
   * @method getHint
   * @memberof oj.Validator
   * @ojsignature {target: "Type", value: "?(): string|null"}
   * @instance
   */

  return Validator;

});


define('ojs/ojvalidation-error',['exports', 'ojs/ojcore', 'ojs/ojmessaging'], function (exports, oj, Message) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Message = Message && Object.prototype.hasOwnProperty.call(Message, 'default') ? Message['default'] : Message;

  // ValidatorError

  /**
   * Constructs a ValidatorError instance from a summary and detail
   *
   * @param {string} summary a localized String that provides a summary of the error
   * @param {string} detail a localized String that provides a detail of the error
   * @example <caption>throw new oj.ValidationError from custom validator's validate method</caption>
   *  // A custom validator whose validate method ensures that the value is not 'junk'.
   *  self.noJunkValidator = {
   *  'validate' : function (value)
   *  {
   *    value = value + "";
   *    if (value && value.toLowerCase()  === "junk")
   *    {
   *      throw new ValidatorError("Invalid value", "You cannot enter a value that is 'junk'!!");
   *    }
   *    return;
   *    }
   *  };
   * @constructor
   * @final
   * @ojtsnoexport
   * @ojtsexportastype
   * @ojtsimport {module: "ojmessaging", type: "AMD", importName: "Message"}
   * @since 0.6.0
   * @export
   */
  const ValidatorError = function (summary, detail) {
    var message = {
      summary: summary,
      detail: detail,
      severity: Message.SEVERITY_LEVEL.ERROR
    };
    this.Init(message);
  };

  ValidatorError.prototype = new Error();

  oj._registerLegacyNamespaceProp('ValidatorError', ValidatorError);

  /**
   * Initializes the instance.
   * @param {Object} message an Object that duck-types oj.Message which is an
   * Object with summary, detail, and severity keys. The severity is
   * oj.Message.SEVERITY_LEVEL['ERROR'].
   * @export
   * @ignore
   */
  ValidatorError.prototype.Init = function (message) {
    var detail = message.detail;
    var summary = message.summary;
    this._message = message;

    // so browser can get to e.name and e.message
    this.name = 'Validator Error';
    this.message = detail || summary;
  };

  /**
   * Returns an Object that duck-types oj.Message which is an
   * Object with summary, detail, and severity properties. The severity is
   * oj.Message.SEVERITY_LEVEL['ERROR']
   *
   * @example <caption>get the oj.ValidationError that was thrown and get the message</caption>
   * var ojmessage = valError.getMessage();
   * var severity = ojmessage['severity'] || oj.Message.SEVERITY_LEVEL['ERROR'];
   * var summary = ojmessage['summary'];
   * var detail = ojmessage['detail'];
   * @returns {Object} an Object that duck-types oj.Message which is an
   * Object with summary, detail, and severity properties.
   * The severity is
   * oj.Message.SEVERITY_LEVEL['ERROR']
   * @ojsignature {target: "Type", value: "oj.Message", for: "returns"}
   * @export
   */
  ValidatorError.prototype.getMessage = function () {
    return this._message;
  };

  // ConverterError

  /**
   * Constructs a ConverterError instance from a summary and detail
   *
   * @param {string} summary a localized String that provides a summary of the error
   * @param {string} detail a localized String that provides a detail of the error
   * @constructor
   * @final
   * @ojtsnoexport
   * @ojtsexportastype
   * @since 0.6.0
   * @export
   */
  const ConverterError = function (summary, detail) {
    var message = {
      summary: summary,
      detail: detail,
      severity: Message.SEVERITY_LEVEL.ERROR
    };
    this.Init(message);
  };

  ConverterError.prototype = new Error();

  oj._registerLegacyNamespaceProp('ConverterError', ConverterError);

  /**
   * Initializes the instance.
   * @param {Object} message an Object that duck-types oj.Message which is an
   * Object with summary, detail, and severity properties.
   * @export
   * @ignore
   */
  ConverterError.prototype.Init = function (message) {
    var detail = message.detail;
    var summary = message.summary;
    this._message = message;

    // so browser can get to e.name and e.message
    this.name = 'Converter Error';
    this.message = detail || summary;
  };

  /**
   * Returns an Object that duck-types oj.Message which is an
   * Object with summary, detail, and severity properties.
   *
   * @return {Object} an Object that duck-types oj.Message which is an
   * Object with summary, detail, and severity properties.
   * @ojsignature {target: "Type", value: "oj.Message", for: "returns"}
   * @export
   */
  ConverterError.prototype.getMessage = function () {
    return this._message;
  };

  exports.ConverterError = ConverterError;
  exports.ValidatorError = ValidatorError;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojvalidator-required',['ojs/ojcore', 'ojs/ojtranslation', 'ojs/ojvalidator', 'ojs/ojvalidation-error'], function (oj, Translations, Validator, ojvalidationError) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Validator = Validator && Object.prototype.hasOwnProperty.call(Validator, 'default') ? Validator['default'] : Validator;

  /**
   * Constructs a RequiredValidator that ensures that the value provided is not empty.
   * @param {Object=} options an object literal used to provide an optional hint and error message.<p>
   *
   * @export
   * @constructor
   * @final
   * @augments oj.Validator
   * @name oj.RequiredValidator
   * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
   * @ojtsmodule
   * @ojsignature [{target: "Type", value: "class RequiredValidator implements Validator<object|string|number>"},
   *               {target: "Type", value: "oj.RequiredValidator.ValidatorOptions", for: "options", jsdocOverride: true}]
   * @since 0.6.0
   * @see oj.AsyncRequiredValidator
   *
   */
  const RequiredValidator = function (options) {
    this.Init(options);
  };

  // Subclass from oj.Object or oj.Validator. It does not matter
  oj.Object.createSubclass(RequiredValidator, Validator, 'oj.RequiredValidator');

  // key to access required validator specific resources in the bundle
  RequiredValidator._BUNDLE_KEY_DETAIL = 'oj-validator.required.detail';
  RequiredValidator._BUNDLE_KEY_SUMMARY = 'oj-validator.required.summary';

  /**
   * @typedef {object} oj.RequiredValidator.ValidatorOptions
   * @property {string=} hint an optional hint text. There is no default hint provided by this
   * validator.
   * @property {string=} label - an optional label text used when the {label} token is passed
   * into messageSummary or messageDetail.
   * @property {string=} messageSummary - an optional custom error message summarizing the
   * error. When not present, the default message summary is the resource defined with the key
   * <code class="prettyprint">oj-validator.required.summary</code>.<p>
   * <p>The messageSummary string is passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * Tokens: {label} - this token can be used to substitute the label of the component at runtime. </p>
   * <p>
   * Example:<br/>
   * "'{label}' Required"<br/>
   * </p>
   * @property {(string|function(Object):string)=} messageDetail - an optional custom error message used for creating the detail part
   * of the message, when the value provided is empty. When not present, the default message detail is the
   * resource defined with the key <code class="prettyprint">oj-validator.required.detail</code>.
   * <p>If messageDetail is a string, the messageDetail string is passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * <p>Tokens: {label} - this token can be used to substitute the label of the component at runtime.</p>
   * <p>
   * Example:<br/>
   * "A value is required for the field '{label}'."<br/>
   * </p>
   * <p>If messageDetail is a function, the messageDetail function is called with the {label} parameter.
   * <p>
   * Example:<br/>
   * messageDetail: (p: {label}) => `A value is required for the field '${p.label}'.`<br/>
   * </p>
   * @ojsignature {
   *   target: "Type",
   *   value: "?(string|(({label: string}) => string))",
   *   for: "messageDetail",
   *   jsdocOverride: true
   * }
   */
  /**
   * Initializes validator instance with the set options
   * @param {Object=} options
   * @memberof oj.RequiredValidator
   * @instance
   * @ignore
   */
  RequiredValidator.prototype.Init = function (options) {
    RequiredValidator.superclass.Init.call(this);
    this._options = options;
  };

  /**
   * Validates value to be non-empty
   *
   * @param {any} value value that is being validated
   * @returns {void}
   * @throws {Error} when fails required-ness check
   * @ojsignature {target: "Type", for: "returns",
   *                value: "void"}
   * @memberof oj.RequiredValidator
   * @instance
   * @export
   * @method validate
   */
  RequiredValidator.prototype.validate = function (value) {
    var detail;
    var label = '';
    var localizedDetail;
    var localizedSummary;
    var summary;
    var params = {};

    // checks for empty arrays and String. Objects are considered non-null.
    if (
      value !== undefined &&
      value !== null &&
      !((typeof value === 'string' || value instanceof Array) && value.length === 0)
    ) {
      return;
    }

    if (this._options) {
      // we have deprecated support for message param and instead use messageDetail.
      detail = this._options.messageDetail || this._options.message || null;
      summary = this._options.messageSummary || null;
      label = this._options.label || '';
    }
    params = { label: label };
    localizedSummary = summary
      ? Translations.applyParameters(summary, params)
      : Translations.getTranslatedString(this._getSummaryKey(), params);
    if (detail === null || detail === undefined || typeof detail === 'string') {
      localizedDetail = detail
        ? Translations.applyParameters(detail, params)
        : Translations.getTranslatedString(this._getDetailKey(), params);
    } else if (typeof detail === 'function') {
      // function, so pass in parameters.
      localizedDetail = detail(params);
    }

    throw new ojvalidationError.ValidatorError(localizedSummary, localizedDetail);
  };

  /**
   * A message to be used as hint, when giving a hint on the expected pattern. There is no default
   * hint for this property.
   *
   * @returns {string|null} a hint message or null if no hint is available in the options
   * @memberof oj.RequiredValidator
   * @instance
   * @export
   * @method getHint
   */
  RequiredValidator.prototype.getHint = function () {
    var hint = '';
    if (this._options && this._options.hint) {
      hint = Translations.getTranslatedString(this._options.hint);
    }

    return hint;
  };

  RequiredValidator.prototype._getSummaryKey = function () {
    return RequiredValidator._BUNDLE_KEY_SUMMARY;
  };

  RequiredValidator.prototype._getDetailKey = function () {
    return RequiredValidator._BUNDLE_KEY_DETAIL;
  };

  return RequiredValidator;

});


define('ojs/ojeditablevalue',['exports', 'ojs/ojcore-base', 'ojs/ojcomponentcore', 'jquery', 'ojs/ojlabel', 'ojs/ojthemeutils', 'ojs/ojfocusutils', 'ojs/ojcontext', 'ojs/ojlogger', 'ojs/ojvalidator-required', 'ojs/ojlabelledbyutils', 'ojs/ojtranslation', 'ojs/ojmessaging', 'ojs/ojconverterutils', 'ojs/ojvalidation-error', 'ojs/ojpopup', 'hammerjs', 'ojs/ojjquery-hammer', 'ojs/ojdomutils', 'ojs/ojanimation'], function (exports, oj, Components, $, ojlabel, ojthemeutils, FocusUtils, Context, Logger, RequiredValidator, LabelledByUtils, Translations, Message, ConverterUtils, ojvalidationError, ojpopup, Hammer, ojjqueryHammer, DomUtils, AnimationUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  RequiredValidator = RequiredValidator && Object.prototype.hasOwnProperty.call(RequiredValidator, 'default') ? RequiredValidator['default'] : RequiredValidator;
  LabelledByUtils = LabelledByUtils && Object.prototype.hasOwnProperty.call(LabelledByUtils, 'default') ? LabelledByUtils['default'] : LabelledByUtils;
  Message = Message && Object.prototype.hasOwnProperty.call(Message, 'default') ? Message['default'] : Message;
  ConverterUtils = ConverterUtils && Object.prototype.hasOwnProperty.call(ConverterUtils, 'default') ? ConverterUtils['default'] : ConverterUtils;

  /**
   * Base class for rendering the 'inside' labels. This is so InsideLabelStrategy
   * and InsideFormControlLabelStrategy can share code.
   * Extends the MessagingStrategy which does more now than messages. It now
   * is also for rendering the form component's label in one of many positions.
   *
   * @extends {oj.MessagingStrategy}
   * @protected
   * @constructor
   * @since 8.0.0
   * @class BaseInsideLabelStrategy
   * @ignore
   * @ojtsignore
   * @param {Array.<string>} options an array of messaging artifacts that are
   * displayed as an inside label for non-text field form controls.
   * For LabelStrategies this is always only labelEdge.
   */
  const BaseInsideLabelStrategy = function (options) {
    this.Init(options);
  };

  // Subclass from oj.MessagingStrategy
  oj.Object.createSubclass(BaseInsideLabelStrategy, oj.MessagingStrategy, 'BaseInsideLabelStrategy');

  /**
   * Adds a hook for subclass to use its own styleclass on root dom element.
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @protected
   */
  BaseInsideLabelStrategy.prototype._GetFormControlLabelStyleClass = function () {
    return 'oj-form-control-label-inside';
  };

  /**
   * Creates the label adding associated event listeners for applying
   * marker selectors to the root and responding to label-hint
   * and other component property changes.
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @protected
   */
  BaseInsideLabelStrategy.prototype._CreateLabel = function () {
    var component = this.GetComponent();
    var container = this._GetContainer(component); // could be overwritten. InsideLabelStrategy.
    if (!container) return;

    var options = component.options;
    var element = component._getRootElement();
    // could be overwritten ,e.g., _getBaseLabelSelector
    var labelStyleClass = this._GetFormControlLabelStyleClass();
    element.classList.add(labelStyleClass);
    this.GenerateIdIfNeeded(element);

    this._showUserAssistanceNotInline = component._showUserAssistanceNotInline();
    let renderRequiredIcon = options.required && this._showUserAssistanceNotInline;
    // for 'inside labels' we do not show help on the label.
    this._createOjLabelElement(
      element,
      component,
      container,
      options.labelHint,
      renderRequiredIcon,
      options.helpHints,
      this._showUserAssistanceNotInline
    );
  };

  /**
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @private
   * @param {Element} label oj-label element
   * @param {CustomEvent} event requiredChanged event
   */
  BaseInsideLabelStrategy.prototype._createOjLabelElement = function (
    element,
    component,
    container,
    labelHint,
    showRequired,
    helpHintsAttrValue,
    showUserAssistanceOnLabel
  ) {
    var ojlabel = document.createElement('oj-label');
    ojlabel.id = BaseInsideLabelStrategy._getLabelId(element);
    ojlabel.setAttribute('data-oj-binding-provider', 'none');
    ojlabel.setAttribute('data-oj-internal', '');

    // associate with form component
    ojlabel.setAttribute('for', element.id);
    var defaultLabelStyleClass = [component._GetDefaultStyleClass(), 'label'].join('-');
    ojlabel.classList.add(defaultLabelStyleClass);
    if (showRequired) {
      ojlabel.setAttribute('show-required', showRequired);
    }
    if (showUserAssistanceOnLabel && helpHintsAttrValue) {
      ojlabel.help = helpHintsAttrValue;
    }

    // add labelHint
    var span = document.createElement('span');
    span.id = [element.id, '|hint'].join('');
    span.textContent = labelHint;

    // add to dom and create event handlers
    ojlabel.appendChild(span);
    this._InsertOjLabel(ojlabel, container, component);
    this._CreateEventHandlers(span, element, ojlabel, component);
  };

  /**
   * Gets the form component's container. Could be overwritten to have more
   * logic to get the container.
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @protected
   */
  BaseInsideLabelStrategy.prototype._GetContainer = function (component) {
    return component._GetFormControlContainer();
  };

  /**
   * Creates event handlers
   * Override if there are more event listeners to create
   * Components with label-hint and label-edge of none or inside create
   * their own labels in this strategy, and when they do we listen for
   * attribute changes so we can deal with them and update the label accordingly.
   * If the oj-form-layout creates the label (top/start), then similar event listeners
   * are created there in ojformlayout.
   * @param {Element} span span around the label where we use innerText to set the labelHint
   * @param {Element} element root custom element
   * @param {Element} ojlabel ojlabel custom element
   * @param {Element} component form component
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @protected
   */
  BaseInsideLabelStrategy.prototype._CreateEventHandlers = function (
    span,
    element,
    ojlabel,
    component
  ) {
    this._labelHintChangedCallback = BaseInsideLabelStrategy._labelHintChangedHandler.bind(
      this,
      span
    );
    element.addEventListener('labelHintChanged', this._labelHintChangedCallback);
    this._requiredChangedCallback = BaseInsideLabelStrategy._requiredChangedHandler.bind(
      this,
      ojlabel,
      component
    );
    element.addEventListener('requiredChanged', this._requiredChangedCallback);
    this._helpHintsChangedCallback = BaseInsideLabelStrategy._helpHintsChangedHandler.bind(
      this,
      ojlabel,
      component
    );
    element.addEventListener('helpHintsChanged', this._helpHintsChangedCallback);
  };

  /**
   * Removes the fixed label unregistering associated event listeners.
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @private
   */
  BaseInsideLabelStrategy.prototype._DestroyLabel = function () {
    var component = this.GetComponent();
    var options = component.options;
    var element = component._getRootElement();
    var labelStyleClass = this._GetFormControlLabelStyleClass(); // override
    element.classList.remove(labelStyleClass);

    var labelId = BaseInsideLabelStrategy._getLabelId(element); // no need to override
    // find inside label. inside labels are rendered inside the form element, so
    // start the query there. We were using document.getElementById to find the label,
    // but in the case where we toggle from top to inside, we find the top label
    // that has not yet been destroyed by the oj-form-layout at this point.
    const ojlabel = element.querySelector(`[id='${labelId}']`);
    if (ojlabel) {
      ojlabel.for = ''; // Triggers code to unlink the oj-label from its form component
      ojlabel.parentElement.removeChild(ojlabel);
    }
    options.labelledBy = undefined;
    this._DeleteEventHandlers(element);
  };

  /**
   * Removes the event handlers
   * Override if there are more event handlers to delete
   * @param {Element} element root custom element
   * @memberof BaseInsideLabelStrategy
   * @instance
   * @protected
   */
  BaseInsideLabelStrategy.prototype._DeleteEventHandlers = function (element) {
    element.removeEventListener('labelHintChanged', this._labelHintChangedCallback);
    element.removeEventListener('requiredChanged', this._requiredChangedCallback);
    element.removeEventListener('helpHintsChanged', this._helpHintsChangedCallback);
    delete this._helpHintsChangedCallback;
    delete this._labelHintChangedCallback;
    delete this._requiredChangedCallback;
  };

  /**
   * @static
   * @private
   * @param {Element} element root custom element
   * @return {string} fixed label id
   */
  BaseInsideLabelStrategy._getLabelId = function (element) {
    return [element.id, '-labelled-by'].join('');
  };

  /**
   * @static
   * @private
   * @param {Element} span holding label text
   * @param {CustomEvent} event labelChanged event
   */
  BaseInsideLabelStrategy._labelHintChangedHandler = function (span, event) {
    // eslint-disable-next-line no-param-reassign
    span.textContent = event.detail.value;
  };

  /**
   * @static
   * @private
   * @param {Element} label oj-label element
   * @param {CustomEvent} event requiredChanged event
   */
  BaseInsideLabelStrategy._requiredChangedHandler = function (label, component, event) {
    // we show required on label if compact and not when inline, for example.
    // get it here and cache it if it doesn't exist.
    if (this._showUserAssistanceNotInline == null) {
      this._showUserAssistanceNotInline = component._showUserAssistanceNotInline();
    }
    // eslint-disable-next-line no-param-reassign
    label.showRequired = event.detail.value && this._showUserAssistanceNotInline;
  };

  /**
   * helpHints attribute changed on form component, so update help icon on label if it is there.
   * (it could be inline to the component and not on label, if so, see InlineHelpHintsStrategy)
   * @static
   * @private
   * @param {Element} label oj-label element
   * @param {CustomEvent} event helpHintsChanged event
   */
  BaseInsideLabelStrategy._helpHintsChangedHandler = function (label, component, event) {
    this._showUserAssistanceNotInline = component._showUserAssistanceNotInline();
    if (this._showUserAssistanceNotInline) {
      // eslint-disable-next-line no-param-reassign
      label.help = event.detail.value;
    }
  };

  /**
   * @class oj.EditableValueUtils
   * @classdesc JET Editable Component Utils
   * @export
   * @since 0.6.0
   * @hideconstructor
   * @ignore
   *
   */
  const EditableValueUtils = {};

  // S T A T I C    V A R S
  /**
   * The various contexts under which validation can be run by component.
   * @ignore
   */
  EditableValueUtils.validationContext = {
    COMPONENT_CREATE: 1,
    CONVERTER_OPTION_CHANGE: 2,
    DISABLED_OPTION_CHANGE: 3,
    READONLY_OPTION_CHANGE: 4,
    REFRESH_METHOD: 5,
    REQUIRED_OPTION_CHANGE: 6,
    RESET_METHOD: 7,
    USER_ACTION: 8,
    VALIDATE_METHOD: 9,
    VALIDATORS_OPTION_CHANGE: 10,
    VALUE_OPTION_CHANGE: 11
  };

  /**
   * Default validation options used by validate method.
   * @ignore
   */
  EditableValueUtils.validateMethodOptions = {
    doValueChangeCheck: false,
    validationContext: EditableValueUtils.validationContext.VALIDATE_METHOD
  };

  /**
   * Default validation options used when converter option changes
   * @ignore
   */
  EditableValueUtils.converterOptionOptions = {
    doValueChangeCheck: false,
    doNotClearMessages: true,
    validationContext: EditableValueUtils.validationContext.CONVERTER_OPTION_CHANGE
  };

  /**
   * Default validation options used when disabled option changes
   * @ignore
   */
  EditableValueUtils.disabledOptionOptions = {
    doValueChangeCheck: false,
    doNotClearMessages: true,
    validationContext: EditableValueUtils.validationContext.DISABLED_OPTION_CHANGE
  };

  /**
   * Default validation options used when required option changes
   * @ignore
   */
  EditableValueUtils.requiredOptionOptions = {
    doValueChangeCheck: false,
    doNotClearMessages: true,
    validationContext: EditableValueUtils.validationContext.REQUIRED_OPTION_CHANGE
  };

  /**
   * Default validation options used when readOnly option changes
   * @ignore
   */
  EditableValueUtils.readOnlyOptionOptions = {
    doValueChangeCheck: false,
    doNotClearMessages: true,
    validationContext: EditableValueUtils.validationContext.READONLY_OPTION_CHANGE
  };

  /**
   * Default validation options used when refresh method is called.
   * @ignore
   */
  EditableValueUtils.refreshMethodOptions = {
    doValueChangeCheck: false,
    doNotClearMessages: true,
    validationContext: EditableValueUtils.validationContext.REFRESH_METHOD
  };
  /**
   * Default validation options used when validators option changes
   * @ignore
   *  */
  EditableValueUtils.validatorsOptionOptions = {
    doValueChangeCheck: false,
    doNotClearMessages: true,
    validationContext: EditableValueUtils.validationContext.VALIDATORS_OPTION_CHANGE
  };

  /**
   * String used in the id on the span that surrounds the help icon.
   * @const
   * @private
   * @ignore
   * @type {string}
   */
  var _REQUIRED_ICON_ID = '_requiredIcon';

  /**
   * Enum for validate() return values
   * @const
   * @ignore
   */
  EditableValueUtils.VALIDATE_VALUES = {
    VALID: 'valid',
    INVALID: 'invalid'
  };

  /**
   * This method is called during _InitOptions() to initialize a component option value from DOM. This
   * uusally is the case when the option value is undefined,
   * i.e., this.options.optionName === undefined.
   * <br/>
   * Returns the attribute value for the given attribute on the element appropriately converted, or
   * the default, if the attribute isn't set on the element.<br/>
   *
   * @param {Object} element the element the component is initialized with.
   * @param {string} attribute the name of the element's attribtue. Example, value, disabled etc.
   *
   * @returns {Object} a JSON object containing the following properties - <br/>
   * <ul>
   * <li><b>fromDom</b> - whether the option value was initialized from DOM. When true the option's
   * value is written back (to observable).</li>
   * <li><b>value</b> - the option value. the attribute value or the default if the attribute isn't
   * set on the element.</li>
   * </ul>
   *
   * @private
   */
  EditableValueUtils.getAttributeValue = function (element, attribute) {
    var result;
    var returnVal = {};

    if (element && attribute) {
      var elem = element[0];
      switch (attribute) {
        case 'disabled':
          result = elem.hasAttribute('disabled') ? !!elem.disabled : undefined;
          break;

        case 'pattern':
          result = elem.pattern || undefined;
          break;

        case 'placeholder':
          result = elem.placeholder || undefined;
          break;

        case 'readonly':
          result = elem.hasAttribute('readonly') ? !!elem.readOnly : undefined;
          break;

        case 'required':
          // If attribute is present
          //   - if the required property is undefined then return true since the attribute is set.
          //   - Otherwise set to !!propVal
          if (elem.hasAttribute('required')) {
            var propVal = elem.required;
            if (propVal !== undefined) {
              result = !!propVal;
            } else {
              result = true; // any attribute value indicates true, even required='false'
            }
          } else {
            result = undefined;
          }
          break;

        case 'title':
          result = elem.hasAttribute('title') ? elem.title : undefined;
          break;

        case 'value':
          // element attribute may not be set, in which case default to null
          result = element.val() || undefined;
          break;

        case 'min':
        case 'max':
        default:
          // same logic for min + max as in default
          result = elem.getAttribute(attribute) || undefined;
          break;
      }
    }

    if (result !== undefined) {
      returnVal.fromDom = true;
      returnVal.value = result;
    } else {
      returnVal.fromDom = false;
      // returnVal.value = defaultValue;
    }
    return returnVal;
  };

  /**
   * NOTE: This is unnecessary to call for custom elements.
   * Called from component._InitOptions() with an array of options
   * that the component might need to initialize from DOM (e.g.,
   * disabled, required, title, etc). This function loops through each of these and if the
   * constructorOptions[option] is undefined, it tries to get the option from DOM.
   * The constructorOptions hold the options that the page author sets on the component, usually via
   * knockout bindings, and that takes precedence over DOM.
   * e.g., <input id="id" type="text" required data-bind="ojComponent: {component: 'ojInputText',
                                    value: value}"/>
   * value is a constructorOption and required is a DOM option in this example. If you have:
   * e.g., <input id="id" type="text" required data-bind="ojComponent: {component: 'ojInputText',
                                    value: value, required: false}"/>
   * required is both a constructorOption of false and a DOM of true. The constructorOption takes
   * precedence.
   * <p>
   * IMPORTANT: Do not call this method after component has been created, since option values are
   * mutated directly after that point.</p>
   *
   * The 'final' value an option uses/initializes from, can come from these places (in order of least
   * to most likely) - <br/>
   * <ol>
   * <li>component default - this is the widget default </li><br/>
   * <li>app default - this is what a page author defines for the value in the page/app</li> <br/>
   * <li>dom value - if your option also has a dom attribute, this is the value set on element for
   * component. </li> <br/>
   * <li>constructor value - this is the value page author sets on the component binding </li><br/>
   * </ol>
   *
   * At the time _InitOptions is called, (1), (2) and (4) are merged, but this may not be the value a
   * component wants for the option, especially when (4) is undefined. For example, if these values
   * were set for a component - <br/>
   * (1) - 'foo'<br/>
   * (2) - 'bar'<br/>
   * (3) - 'lucy'<br/>
   * (4) - undefined<br/>
   * <p>
   * at the time _InitOptions is called, this.options.option is set to 'bar'. But because DOM value
   * wins over app default or component default, the component needs to check if the constructor value was
   * undefined and if so, set option to the dom value which is 'lucy' in this example. This is what
   * this function does.<br/>
   * This method always defaults the value to be - this.options.option -
   * because we think if neither (3) nor (4) is set, then the value from (2) should win. <br/>
   * </p>
   *
   * @param {Object} props Array holding Object-literal that a component provides
   * with the following properties that helps determine the final value for one or more options.
   *
   * @property {string} props.attribute - name of DOM attribute
   * @property {string|undefined} props.option - name of the option if different from attribute name.
   *
   * @property {Function|boolean|undefined} props.coerceDomValue - if the DOM value is set and
   * coercing the dom value is needed, then either set to boolean true, which uses the default
   * coercion rules for common attributes (a), or provide a custom callback (b). <p>
   * E.g., 'value' option for input number, input date etc. have special rules for coercing the value,
   *  so thse provide a custom callback. For common attributes like required and disabled, set the
   *  value to true so the default oj.EditableValueUtils#coerceDomValueForOption method gets used.
   *
   * @property {boolean|undefined} props.validateOption - if set to true, then it calls
   * EditableValueUtils.validateValueForOption method to validate the option.
   *
   * @param {Object} constructorOptions the options set on the component instance, often using
   * component binding. (this is the value page author sets on the component binding)
   * @param {Object} comp component instance.
   * @param {Function=} postprocessCallback - optional callback that will receive a map of initialized
   * options for post-processing
   * @ignore
   * @public
   */
  EditableValueUtils.initializeOptionsFromDom = function (
    props,
    constructorOptions,
    comp,
    postprocessCallback
  ) {
    var initializedOptions = {};

    // Loop through props to initialize option
    for (var i = 0; i < props.length; i++) {
      var finalValue;
      var result;
      var prop = props[i];
      var attribute = prop.attribute;
      var option = prop.option || attribute;
      var coerceDomValue = prop.coerceDomValue;
      var validateOption = prop.validateOption;
      var element = comp.element;
      var previousValue = comp.options[option];

      /* The precedence for the value that an option uses is as follows from lowest to highest -
       *
       * (1) component default - this is the widget default, already merged in to comp.options
       * (2) app default - this is what a page author defines for the value in the page / app,
       * already merged in to comp.options
       * (3) dom value - if your option also has a dom attribute, this is the value set on element.
       * (4) constructor value - this is the value page author sets on the component binding, already
       * merged in to comp.options.
       *
       * When (4) is undefined then attempt to default from (3).
       */

      // Step 1: use DOM value
      if (constructorOptions[option] === undefined) {
        previousValue = comp.options[option];
        result = EditableValueUtils.getAttributeValue(element, attribute);

        // if we are using domValue then coerce the dom value before writing to options and trigegr
        // option change so the value is written back (to ko)
        if (result.fromDom) {
          finalValue = result.value;

          // only required needs coercing so not bad
          if (coerceDomValue) {
            if (typeof coerceDomValue === 'boolean') {
              finalValue = EditableValueUtils.coerceDomValueForOption(option, finalValue);
            } else if (typeof coerceDomValue === 'function') {
              finalValue = coerceDomValue.call(comp, finalValue);
            }
          }
          initializedOptions[option] = finalValue;
        }
      }

      var valueToValidate = option in initializedOptions ? initializedOptions[option] : previousValue;

      // Step 2: validate the option value if needed
      if (validateOption) {
        if (typeof validateOption === 'boolean') {
          EditableValueUtils.validateValueForOption(option, valueToValidate);
        }
      }
    }

    if (postprocessCallback != null) {
      postprocessCallback(initializedOptions);
    }

    comp.option(initializedOptions, { _context: { writeback: true, internalSet: true } });
  };

  /**
   * Validates value set for the option and throws error if invalid.
   *
   * @param {string} option name of the option. Validates options common to all edtiableValue
   * holders.
   * @param {string|Object|boolean|number|undefined} value of the option that is validated
   *
   * @throws {Error} if option value is invalid
   * @public
   * @ignore
   */
  EditableValueUtils.validateValueForOption = function (option, value) {
    var error = false;

    switch (option) {
      case 'required':
        if (value !== null && typeof value !== 'boolean') {
          error = true;
        }
        break;

      case 'readOnly':
      case 'disabled':
        if (value !== null && typeof value !== 'boolean') {
          error = true;
        }
        break;
      default:
        break;
    }

    if (error) {
      throw new Error("Option '" + option + "' has invalid value set: " + value);
    }
  };

  /**
   * Coerces the dom value being used for the option, and throws error if invalid.
   *
   * @param {string} option name of the option.
   * @param {string|Object|boolean|number|null} domValue dom value that is being coerced to the
   * option value
   * @throws {Error} if domValue cannot be coerced appropriately
   * @public
   * @ignore
   */
  EditableValueUtils.coerceDomValueForOption = function (option, domValue) {
    var coerced = domValue;
    switch (option) {
      case 'required':
        coerced = !!domValue;
        break;
      default:
        break;
    }

    return coerced;
  };

  /**
   * set pickerAttributes on a popup picker
   *
   * @param {jQuery} picker popup picker
   * @param {Object} pickerAttributes supported attributes are class and style, which are appended to the picker class and style, if any.
   *
   * @ignore
   */
  EditableValueUtils.setPickerAttributes = function (picker, pickerAttributes) {
    //  - let the popup picker accept the custom css class name from the component
    if (picker && pickerAttributes) {
      var classValue = pickerAttributes.class;
      if (classValue) {
        var classes = classValue.split(' ');
        // IE11 doesn't support destructured parameters so we need to iterate across the list
        // of classes
        for (var i = 0, len = classes.length; i < len; ++i) {
          picker[0].classList.add(classes[i]);
        }
      }

      var styleValue = pickerAttributes.style;
      if (styleValue) {
        Logger.error(`picker-attributes.style attribute violates the recommended
        Content Security Policy which disallows inline styles and is therefore ignored.
        Use the picker-attributes.class attribute instead.`);
      }
    }
  };

  /**
   * Helper to see if a special property was set to indicate we definitely have no label.
   * This is a performance enhancement for the corner case where input components are rendered in a
   * ojTable. Input components rendered in an ojTable have no label so we don't need to waste time
   * looking for labels.
   * @param {jQuery} widget The component widget.
   * @return {boolean}
   * @ignore
   * @private
   */
  EditableValueUtils.hasNoLabelFlag = function (widget) {
    return widget[0].hasAttribute('data-oj-no-labelledby');
  };

  /**
   * Given the labelledBy (e.g., this.options.labelledBy), use this to
   * get the oj-label's label element's id when there is a for/id relationship
   * between the oj-label and the form component, but the form component wants to
   * write aria-labelledby on a div instead of using the for/id relationship in dom.
   * Some components need this information to
   * use as their aria-labelledby on their dom element(s) that takes focus. An example
   * is oj-switch and oj-slider which put display:none on its input and uses aria-labelledby
   * on its thumb.
   * This is the preferred way rather than using a 'for' attribute search to find the oj-label.
   * @param labelledBy
   * @param defaultLabelId
   * @return {string|null} return the string to use as the aria-labelledby on the form component's
   * focusable element. If oj-label doesn't exist, this will return null.
   * @ignore
   * @private
   */
  EditableValueUtils._getOjLabelAriaLabelledBy = function (labelledBy, defaultLabelId) {
    var ariaLabelledBy;
    var ojlabels = EditableValueUtils._getCustomOjLabelElements(labelledBy);
    if (ojlabels) {
      ariaLabelledBy = '';
      for (var j = 0; j < ojlabels.length; j++) {
        var ojlabel = ojlabels[j];
        var oneLabelElementId = ojlabel.getAttribute('label-id');
        if (!oneLabelElementId) {
          var labelElement = ojlabel.querySelector('label');
          if (labelElement) {
            oneLabelElementId = labelElement.getAttribute('id');
          } else {
            // this is the case where the form component has
            // labelled-by pointing to oj-label that hasn't been
            // upgraded yet and doesn't have label-id on it.
            // this isn't the way the form component and its label
            // should be linked, but it is possible.
            ojlabel.setAttribute('label-id', defaultLabelId);
            oneLabelElementId = defaultLabelId;
          }
        }
        ariaLabelledBy += oneLabelElementId;
        if (j + 1 < ojlabels.length) {
          ariaLabelledBy += ' ';
        }
      }
    }
    return ariaLabelledBy;
  };

  /**
   * @ignore
   * @private
   */
  EditableValueUtils._getCustomOjLabelElements = function (labelledBy) {
    var labelElements = [];

    if (labelledBy) {
      // split into individual ids
      var split = labelledBy.split(/\s+/);
      for (var i = 0; i < split.length; i++) {
        var labelId = split[i];
        var labelElement = document.getElementById(labelId);
        // don't push any null elements. it's possible labelled-by element can't be found.
        if (labelElement) {
          labelElements.push(labelElement);
        } else {
          Logger.info('Cannot find oj-label with id ' + labelElement);
        }
      }
    }
    return labelElements;
  };

  /**
   * Called during component initialization for Custom form components so that
   * they will be associated with their oj-label element correctly.
   * It links oj-label and form control for accessibility reasons.
   *
   * Background of how oj-label and 'input' components are linked together for accessibility:
   * --------------------------------------------------------------------------------------
   * An application developer links oj-label with a 'form' component like this:
   * <oj-label id='foo' for='myinput'> to <oj-input-text id='myinput'>
   *
   * We render the aria and data-oj- attributes on the correct dom like this:
   * <oj-label id='foo' for='myinput' data-oj-input-id='myinput|input'>
   * <span id="foo|label_helpIcon"<label id='foo|label' for='myinput|input'>
   * <oj-input-text id='myinput' labelled-by='foo' described-by='foo|label_helpIcon'>
   * <input aria-describedby='foo|label_helpIcon'>
   * ---------------------------------------------------------------------------------------
   * Note: See also _labelledByUpdatedForInputComp. We need both this function
   * and that one because
   * we cannot guarantee the upgrade order of the oj-label and form component.
   * If oj-label is not upgraded at the time the form component is, then it is
   * possible that the labels cannot be found. If that's the case, then the oj-label will
   * write labelledBy on the form component, and the  _labelledByUpdatedForInputComp
   * will get called which calls _setDataOjInputIdAttrOnLabel.
   * @ignore
   * @private
   */
  EditableValueUtils._initInputIdLabelForConnection = function (
    contentElement,
    componentId,
    labelledBy
  ) {
    if (componentId) {
      contentElement.setAttribute('id', componentId + '|input');
      if (labelledBy) {
        this._linkLabelForInputComp(labelledBy, contentElement.id);
      }
    }
    if (labelledBy) {
      this._setReadonlyDivLabelledBy(labelledBy);
    }
  };

  /**
   * This function is called when labelledBy option is changed
   * on the form components with inputs, like
   * oj-input-text. It links oj-label's internal for and input form control's id
   * without relying on property dom searches.
   * Note: See also _initInputIdLabelForConnection. We need both this function
   * and that one because
   * we cannot guarantee the upgrade order of the oj-label and form component.
   * @ignore
   * @private
   */
  EditableValueUtils._labelledByUpdatedForInputComp = function (labelledBy, contentElementId) {
    if (labelledBy) {
      if (contentElementId) {
        this._linkLabelForInputComp(labelledBy, contentElementId);
      }
      this._setReadonlyDivLabelledBy(labelledBy);
    }
    // update the required translation text since it could use label text
    // and if labelledBy changes, label text would have changed.
    if (this._IsRequired() && this.options.translations.required) {
      this._implicitReqValidator = null;
      this._getImplicitRequiredValidator();
    }
  };

  /**
   * @ignore
   * @private
   */
  EditableValueUtils._linkLabelForInputComp = function (labelledBy, contentElementId) {
    var ojlabels = EditableValueUtils._getCustomOjLabelElements(labelledBy);
    if (ojlabels) {
      EditableValueUtils._setDataOjInputIdAttrOnLabel(contentElementId, ojlabels);
    }
  };

  /**
   * This function is called when labelledBy option is changed
   * on the form components with inputs, like
   * oj-input-text, and during component init, to set aria-labelledby
   * on the readonly div, if the component has a readonly div.
   * @ignore
   * @private
   */
  EditableValueUtils._setReadonlyDivLabelledBy = function (labelledBy) {
    // don't call this function if labelledBy doesn't have a value.
    oj.Assert.assert(labelledBy);
    let readonlyElem = this._getReadonlyDiv();
    if (readonlyElem) {
      readonlyElem.setAttribute('aria-labelledby', labelledBy + '|label');
    }
  };

  /**
   * This function is called when readonly option changes from false to true
   * for readonly input components, or when the component is created.
   * @ignore
   * @private
   */
  EditableValueUtils._createOrUpdateReadonlyDiv = function (input, createConditions = true) {
    // create readonly div if it doesn't exist.
    let readonlyElem = this._getReadonlyDiv();
    if (!readonlyElem && createConditions) {
      readonlyElem = this._createReadonlyDiv(input);
      if (!readonlyElem) {
        return;
      }
      if (this.options.labelledBy) {
        this._setReadonlyDivLabelledBy(this.options.labelledBy);
      }
      this._setAriaLabelFromLabelHint();
    }

    if (readonlyElem) {
      readonlyElem.textContent = this._GetDisplayValue();
      EditableValueUtils._setTabIndex(input, readonlyElem);
    }
  };

  /**
   * @ignore
   * @private
   */
  EditableValueUtils._setTabIndex = function (input, readonlyElem) {
    let tabIndex = input.tabIndex;
    let readonlyElemToSet = readonlyElem;
    if (tabIndex !== null) {
      readonlyElemToSet.tabIndex = tabIndex;
    }
  };

  /**
   * @ignore
   * @private
   */
  EditableValueUtils._setDataOjInputIdAttrOnLabel = function (contentElementId, ojlabels) {
    if (ojlabels) {
      for (var i = 0; i < ojlabels.length; i++) {
        var ojlabel = ojlabels[i];
        // setting this will cause ojlabel to set its internal label element's for to this id.
        ojlabel.setAttribute('data-oj-input-id', contentElementId);
      }
    }
  };

  /**
   * Validates the component's display value using the converter and all validators registered on
   * the component and updates the <code class="prettyprint">value</code> option by performing the
   * following steps.
   *
   * <p>
   * <ol>
   * <li>All messages are cleared, including custom messages added by the app. </li>
   * <li>If no converter is present then processing continues to next step. If a converter is
   * present, the UI value is first converted (i.e., parsed). If there is a parse error then
   * messages are shown.</li>
   * <li>If there are no validators setup for the component the <code class="prettyprint">value</code>
   * option is updated using the display value. Otherwise all
   * validators are run in sequence using the parsed value from the previous step. The implicit
   * required validator is run first if the component is marked required. When a validation error is
   * encountered it is remembered and the next validator in the sequence is run. </li>
   * <li>At the end of validation if there are errors, the messages are shown.
   * If there were no errors, then the
   * <code class="prettyprint">value</code> option is updated.</li>
   * </ol>
   *
   * @example <caption>Validate component using its current value.</caption>
   * myComp.validate();
   *
   * @example <caption>Validate component and use the Promise's resolved state.</caption>
   * myComp.validate().then(
   *  function(result) {
   *    if(result === "valid")
   *    {
   *      submitForm();
   *    }
   *  });
   *
   *
   * @return {Promise} Promise resolves to "valid" if there were no converter parse errors and
   * the component passed all validations.
   * The Promise resolves to "invalid" if there were converter parse errors or
   * if there were validation errors.
   *
   * @ignore
   * @private
   */
  EditableValueUtils.validate = function () {
    var returnValue;

    // clear all messages; run full validation on display value
    // _SetValue returns boolean or Promise that resolves to a Boolean.
    returnValue = this._SetValue(this._GetDisplayValue(), null, this._VALIDATE_METHOD_OPTIONS);

    if (returnValue === false && !this._CanSetValue()) {
      // FIX JET-45885, validate() returns 'invalid' for readonly or disabled on valid value.
      // In _SetValue/_AsyncValidate, validation is skipped when !this._CanSetValue(), and _SetValue returns false.
      // We want validate() to return 'valid' when validation is skipped.
      returnValue = true;
    }

    if (this._IsCustomElement()) {
      if (!(returnValue instanceof Promise)) {
        returnValue = Promise.resolve(returnValue ? 'valid' : 'invalid');
      } else {
        // convert true to 'valid' and false to 'invalid'
        return returnValue.then(function (booleanSetValueReturn) {
          return Promise.resolve(booleanSetValueReturn ? 'valid' : 'invalid');
        });
      }
    } else if (returnValue instanceof Promise) {
      return returnValue.then(function (booleanSetValueReturn) {
        return Promise.resolve(booleanSetValueReturn ? 'valid' : 'invalid');
      });
    }
    return returnValue;
  };

  /**
   * Refresh everything that needs refreshing when the required option is toggled:
   * refreshes theming, aria-required, label.
   *
   * Used by EditableValue components that support the required option.
   * The component links to this function like this:
   *   _refreshRequired : EditableValueUtils._refreshRequired,
   * @param {Object=} value the current value of the required option
   * @private
   * @ignore
   */
  EditableValueUtils._refreshRequired = function (value) {
    var id;
    var contentNode;
    var ariaValue;
    var ariaRequiredUnsupported = this._AriaRequiredUnsupported();

    this._refreshTheming('required', value);
    // refresh aria-required
    // Most inputs/selects need aria-required on the input element (aka 'content')
    // But it is not legal to have aria-required on radio/checkboxes.
    if (!ariaRequiredUnsupported) {
      contentNode = this._GetContentElement();

      ariaValue = value; // (value == "required") ? true : false;
      if (ariaValue && contentNode) {
        contentNode[0].setAttribute('aria-required', ariaValue);
      } else {
        contentNode[0].removeAttribute('aria-required');
      }
    }

    if (!this._IsCustomElement()) {
      if (!this.$label) {
        this._createOjLabel();
      }

      // need to keep the label's required in sync with the input's required
      if (this.$label) {
        this.$label.ojLabel('option', 'showRequired', value);
        // in most cases aria-required is supported and that is what we do to get JAWS to say
        // "Required" on focus of the input. But in the case of a 'set' of items where one is required,
        // say radioset/checkboxset, what do we do? aria-required doesn't make sense (nor is it valid
        // as it fails validation in some accessibility validators) on each input, when really it is
        // one in the set that is required, not each one. This is what we are doing from v1 on: we
        // put aria-describedby to point to the required icon text.
        if (ariaRequiredUnsupported) {
          // if aria-labelledby is set,
          // add/remove aria-describedby to the inputs pointing to
          // the label+"_requiredIcon".
          var ariaLabelledByElem = this._getAriaLabelledByElement(this.element);
          if (ariaLabelledByElem !== null && ariaLabelledByElem.length !== 0) {
            id = ariaLabelledByElem[0].getAttribute('id');
          }

          if (id) {
            let ariaId = id + _REQUIRED_ICON_ID;
            if (value) {
              // adds
              this._describedByUpdated(null, ariaId);
            } else {
              // removes
              this._describedByUpdated(ariaId, null);
            }
          }
        }
      }
    }
  };

  /**
   * Performs post processing after required option is set by taking the following steps.
   *
   * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
   * run full validation with UI value (we don't know if the UI error is from a required validator
   * or something else);<br/>
   * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
   * updated<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to optionChange(value) to clear custom errors.<br/>
   *
   * - if component is invalid and has messagesHidden -> required: false -> clear component
   * errors; no deferred validation is run.<br/>
   * - if component has no error -> required: true -> run deferred validation (we don't want to flag
   * errors unnecessarily)<br/>
   * - messagesCustom is never cleared<br/>
   *
   * @param {string} option
   *
   * @private
   * @ignore
   */
  // eslint-disable-next-line no-unused-vars
  EditableValueUtils._AfterSetOptionRequired = function (option) {
    // refresh hints, theming and aria to reflect new state
    this._refreshRequired(this._IsRequired());
    this._runMixedValidationAfterSetOption(EditableValueUtils.requiredOptionOptions);
  };

  /**
   * When validators option changes, take the following steps.
   *
   * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
   * - if component is valid -> validators changes -> no change<br/>
   * - if component is invalid has messagesShown -> validators changes -> clear all component
   * messages and re-run full validation on displayValue. if there are no errors push value to
   * model;<br/>
   * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
   * the required-ness of component <br/>
   * - messagesCustom is not cleared.<br/>
   *
   * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern,
   * etc. Components can call this method when these options change.
   *
   * @returns {undefined}
   * @private
   * @ignore
   */
  EditableValueUtils._AfterSetOptionValidators = function () {
    var displayValue;
    // resets all validators and pushes new hints to messaging
    this._ResetAllValidators();

    if (this._hasInvalidMessagesShowing()) {
      this._clearComponentMessages();
      displayValue = this._GetDisplayValue();
      // runs full validation on the display value. May be async
      this._SetValue(displayValue, null, EditableValueUtils.validatorsOptionOptions);
    }
  };

  /**
   * When async-validators property changes, take the following steps.
   *
   * - Clear the cached normalized list of all async and sync validator instances.
   *  push new hints to messaging.<br/>
   * - if component is valid -> validators changes -> no change<br/>
   * - if component is invalid has messagesShown -> validators changes -> clear all component
   * messages and re-run full validation on displayValue. if there are no errors push value to
   * model;<br/>
   * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
   * the required-ness of component <br/>
   * - messagesCustom is not cleared.<br/>
   *
   *
   * @returns {undefined}
   * @private
   * @ignore
   */
  EditableValueUtils._AfterSetOptionAsyncValidators = function () {
    // resets validators and pushes new hints to messaging
    this._AfterSetOptionValidators();
  };

  /**
   * Performs post processing after converter option changes by taking the following steps.
   *
   * - always push new converter hint to messaging <br/>
   * - if component has no errors -> refresh UI value<br/>
   * - if component is invalid has messagesShown -> clear all component errors and run full
   * validation using display value. <br/>
   * &nbsp;&nbsp;- if there are validation errors, value is not pushed to model; messagesShown is
   * updated.<br/>
   * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
   * listen to optionChange(value) to clear custom errors.<br/>
   * - if component is invalid has messagesHidden -> refresh UI value. no need to run deferred
   * validations. <br/>
   * - messagesCustom is never cleared<br/>
   *
   * @param {String} option
   *
   * @returns {undefined}
   * @private
   * @ignore
   */
  // called when 'converter' option changed, usually from option/setOption calls
  EditableValueUtils._AfterSetOptionConverter = function () {
    // clear the cached converter instance and push new hint to messaging
    this._converter = null;
    this._converterChangedCounter += 1;

    var converter = this._GetConverter();
    if (converter instanceof Promise) {
      var self = this;
      this._setBusyStateAsyncConverterLoading();
      var converterCounter = this._converterChangedCounter;
      this._loadingConverter(converter).then(function () {
        if (converterCounter === self._converterChangedCounter) {
          self._ResetConverter();
        }
        self._clearBusyStateAsyncConverterLoading();
      });
    } else {
      this._ResetConverter();
    }
  };

  /**
   * Performs post processing after we have the loaded converter
   * during component initialization.
   *
   * @returns {undefined}
   * @private
   * @ignore
   */
  EditableValueUtils._AfterCreateConverterCached = function () {
    // we do this here for a couple reasons
    // 1. because here we have the final value; an empty placeholder
    // shows up if data changed after first binding. 
    // 2. we do not want the placeholder displayed while the loading
    // indication is showing.
    if (this._HasPlaceholderSet()) {
      // update element placeholder
      this._SetPlaceholder(this.options.placeholder);
      this._customPlaceholderSet = true;
    }
    // can't show validator hints or converter hints until we have the converter
    // because some validators have the converter as an option.
    this._initComponentMessaging(this._MESSAGING_CONTENT_UPDATE_TYPE.ALL);
    // need a converter to format the value
    this._Refresh('value', this.options.value, false);
    // trigger messagesShownChanged for messagesShown if it's non-empty.
    // this.options['messagesShown'] would have been
    // updated in _ComponentCreate if messagesCustom was non-empty. Because we are setting
    // the 'changed' flag to true, the messagesShownChanged event will be fired, and that's what we want.
    if (this.options.messagesShown.length > 0) {
      this._setMessagesOption('messagesShown', this.options.messagesShown, null, true);
    }
  };
  /**
   * Called when converter option changes and we have the new converter.
   *
   * @private
   * @ignore
   */
  EditableValueUtils._ResetConverter = function () {
    var displayValue;

    this._getComponentMessaging().update(
      this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT)
    );

    if (this._hasInvalidMessagesShowing()) {
      this._clearComponentMessages();
      displayValue = this._GetDisplayValue();
      // runs full validation on the display value. May be async
      this._SetValue(displayValue, null, EditableValueUtils.converterOptionOptions);
    } else {
      // refresh UI display value when there was no need to run full validation
      this._Refresh('converter', this.options.converter, true);
    }
  };

  /**
   * Returns an array of all validators built by merging the validators option set on the component
   * and the implicit validators setup by the component. <br/>
   * This does not include the implicit required validator. Components can override to add to this
   * array of validators.
   *
   * @return {Array} of validators
   *
   * @private
   * @ignore
   */
  EditableValueUtils._GetNormalizedValidatorsFromOption = function () {
    var i;
    var isValidatorInstance = true;
    var normalizedValidators = [];
    var validator;
    var validatorsOption;
    var vOptions;
    var vType;
    var vTypeStr;

    validatorsOption = this.options.validators;

    if (validatorsOption) {
      // Normalize validators
      for (i = 0; i < validatorsOption.length; i++) {
        validator = validatorsOption[i];
        if (typeof validator === 'object') {
          // check if we have an actual validator instance that implements the validate() method
          // oj.Validation.__doImplementsCheck(validator, oj.Validator);
          if (!(validator.validate && typeof validator.validate === 'function')) {
            isValidatorInstance = false;
          }

          if (!isValidatorInstance) {
            // we maybe dealing with an object literal
            // {'type': 'numberRange', 'options': { 'min': 100, 'max': 1000,
            //                                    'hint': {'min': 'some hint about min'}}}
            vTypeStr = validator.type;
            if (vTypeStr && typeof vTypeStr === 'string') {
              if (oj.Validation && oj.Validation.validatorFactory) {
                vType = oj.Validation.validatorFactory(vTypeStr);
              } else {
                Logger.error(
                  'oj.Validation.validatorFactory is not available and it is needed to support the deprecated json format for validators property. Please include the backward compatibility "ojvalidation-base" module.'
                );
              }
              if (vType) {
                vOptions = oj.CollectionUtils.copyInto({}, validator.options) || {};
                // we push converter into the options if not provided explicitly. This is to allow
                // validators to format values shown in the hint and messages
                vOptions.converter = vOptions.converter || this._GetConverter();
                vOptions.label = vOptions.label || this._getLabelText();
                validator = vType.createValidator(vOptions);
              }
            }
          }

          normalizedValidators.push(validator);
        } else {
          Logger.error('Unable to parse the validator provided:' + validator);
        }
      }
    }
    return normalizedValidators;
  };
  /**
   * Returns an array of all async validators built by the async-validators attribute
   * set on the component. In this release, Objects that have validate method (
   * and also they could have a hint property) are considered AsyncValidators and
   * AsyncValidator Objects. In future releases we will allow Objects with types, like
   * {'type': 'numberRange',
   * 'options': { 'min': 100, 'max': 1000, 'hint': {'min': 'some hint about min'}}}
   *
   * @return {Array} of async validators
   *
   * @private
   * @ignore
   */
  EditableValueUtils._GetNormalizedAsyncValidatorsFromOption = function () {
    var i;
    var normalizedValidators = [];
    var validator;
    var validatorsOption;

    validatorsOption = this.options.asyncValidators;

    // Normalize validators
    for (i = 0; i < validatorsOption.length; i++) {
      validator = validatorsOption[i];
      if (typeof validator === 'object') {
        // check if we have an actual asyncvalidator object that implements the validate() method
        if (validator.validate && typeof validator.validate === 'function') {
          normalizedValidators.push(validator);
        }
      } else {
        Logger.error('Unable to parse the validator provided:' + validator);
      }
    }

    return normalizedValidators;
  };
  /**
   * Returns the normalized converter instance.
   * This could return a Promise during component initialization or when changing the
   * component's converter property.
   *
   * @return {Object|null|Promise<Object>|Promise<null>} a converter instance or null
   * or a Promise to a converter instance or null.
   *
   * @private
   * @ignore
   */
  EditableValueUtils._GetConverter = function () {
    var converterOption;
    var converterInstanceReturn;
    var self = this;
    var converterPromise;

    // this._converter holds the instance
    if (!this._converter) {
      converterOption = this.options.converter;
      if (converterOption instanceof Promise) {
        converterPromise = converterOption;
      } else {
        converterInstanceReturn = ConverterUtils.getConverterInstance(converterOption);
      }

      if (converterPromise) {
        return converterPromise.then(function (ci) {
          self._converter = ci;
          return self._converter || null;
        });
      }
      this._converter = converterInstanceReturn;
    }

    return this._converter || null;
  };

  /**
   * Set busy state for component for async validators for the displayValue.
   * We want to clear busy state for the same displayValue, not for a different displayValue.
   * I suppose if they type in 111, then 222, then 111, we may clear for second 111 before first,
   * but that seems incredibly unlikely.
   * @param {string} displayValue the displayValue busystate we want to set
   *
   * @private
   * @ignore
   */
  EditableValueUtils._SetBusyState = function (displayValue) {
    if (this._resolveBusyStateAsyncMap === undefined) {
      // eslint-disable-next-line no-undef
      this._resolveBusyStateAsyncMap = new Map();
    }

    var resolveBusyStateAsync = this._resolveBusyStateAsyncMap.get(displayValue);

    // Set a page-level busy state if not already set for this displayValue
    if (!resolveBusyStateAsync) {
      var domElem = this.element[0];
      var busyContext = Context.getContext(domElem).getBusyContext();
      var description = 'The page is waiting for async validators for displayValue ' + displayValue;

      if (domElem && domElem.id) {
        description += ' for "' + domElem.id + '" ';
      }
      description += 'to finish.';

      resolveBusyStateAsync = busyContext.addBusyState({ description: description });
      this._resolveBusyStateAsyncMap.set(displayValue, resolveBusyStateAsync);
    }
  };

  /**
   * Clear busy state for async validators for the displayValue.
   * @param {string} displayValue the displayValue busystate we want to clear
   * @private
   * @ignore
   */
  EditableValueUtils._ClearBusyState = function (displayValue) {
    var resolveBusyStateAsync;
    if (this._resolveBusyStateAsyncMap !== undefined) {
      resolveBusyStateAsync = this._resolveBusyStateAsyncMap.get(displayValue);
      if (resolveBusyStateAsync) {
        resolveBusyStateAsync();
        this._resolveBusyStateAsyncMap.delete(displayValue);
      }
    }
  };

  /**
   * Set busy state for component for async validators hint.
   * We want to clear busy state for the same hint not for a different hint.
   * I use a counter here.
   * @param {number} counter the counter for the busystate we want to set
   *
   * @private
   * @ignore
   */
  EditableValueUtils._SetBusyStateAsyncValidatorHint = function (counter) {
    if (this._resolveBusyStateAsyncValidatorHintMap === undefined) {
      // eslint-disable-next-line no-undef
      this._resolveBusyStateAsyncValidatorHintMap = new Map();
    }

    var resolveBusyStateAsyncHint = this._resolveBusyStateAsyncValidatorHintMap.get(counter);

    // Set a page-level busy state if not already set for this counter
    if (!resolveBusyStateAsyncHint) {
      var domElem = this.element[0];
      var busyContext = Context.getContext(domElem).getBusyContext();
      var description = 'The page is waiting for async validator hint for counter ' + counter;

      if (domElem && domElem.id) {
        description += ' for "' + domElem.id + '" ';
      }
      description += 'to finish.';

      resolveBusyStateAsyncHint = busyContext.addBusyState({ description: description });
      this._resolveBusyStateAsyncValidatorHintMap.set(counter, resolveBusyStateAsyncHint);
    }
  };

  /**
   * Clear busy state for async validators hint for the counter
   * @param {number} counter the counter for the busystate we want to clear
   * @private
   * @ignore
   */
  EditableValueUtils._ClearBusyStateAsyncValidatorHint = function (counter) {
    var resolveBusyStateAsyncHint;
    if (this._resolveBusyStateAsyncValidatorHintMap !== undefined) {
      resolveBusyStateAsyncHint = this._resolveBusyStateAsyncValidatorHintMap.get(counter);
      if (resolveBusyStateAsyncHint) {
        resolveBusyStateAsyncHint();
        this._resolveBusyStateAsyncValidatorHintMap.delete(counter);
      }
    }
  };

  /**
   * Set busy state for component for async converter loading.
   *
   * @private
   * @ignore
   */
  EditableValueUtils._SetBusyStateAsyncConverterLoading = function () {
    // Set a page-level busy state if not already set for async converter loading
    if (!this._resolveBusyStateAsyncConverterLoading) {
      var domElem = this.element[0];
      var busyContext = Context.getContext(domElem).getBusyContext();
      var description = 'The page is waiting for async converter loading ';

      if (domElem && domElem.id) {
        description += 'for "' + domElem.id + '" ';
      }
      description += 'to finish.';

      this._resolveBusyStateAsyncConverterLoading = busyContext.addBusyState({
        description: description
      });
    }
  };

  /**
   * Clear busy state for async converter loading
   * @private
   * @ignore
   */
  EditableValueUtils._ClearBusyStateAsyncConverterLoading = function () {
    if (this._resolveBusyStateAsyncConverterLoading !== undefined) {
      this._resolveBusyStateAsyncConverterLoading();
      delete this._resolveBusyStateAsyncConverterLoading;
    }
  };

  /**
   * Retrieve the delay before showing status
   * @return {number} the delay in ms
   * @private
   * @ignore
   */
  EditableValueUtils._getShowLoadingDelay = function () {
    if (this._defaultOptions == null) {
      this._defaultOptions = ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults');
    }
    var delay = parseInt(this._defaultOptions.showIndicatorDelay, 10);

    return isNaN(delay) ? 0 : delay;
  };

  /**
   * Set the type of the input element based on virtualKeyboard option.
   *
   * @param {Array.<string>} allowedTypes an array of allowed types
   *
   * @protected
   * @ignore
   */
  EditableValueUtils._SetInputType = function (allowedTypes) {
    // Default input type is text
    var inputType = 'text';
    var agentInfo = oj.AgentUtils.getAgentInfo();

    // Only change the type on mobile browsers
    if (
      agentInfo.os === oj.AgentUtils.OS.ANDROID ||
      agentInfo.os === oj.AgentUtils.OS.IOS ||
      agentInfo.os === oj.AgentUtils.OS.WINDOWSPHONE
    ) {
      // Get input type from component's virtualKeyboard option
      if (allowedTypes.indexOf(this.options.virtualKeyboard) >= 0) {
        inputType = this.options.virtualKeyboard;
      } else {
        // Get input type from converter's virtualKeyboardHint option
        var converter = this._GetConverter();
        if (converter && converter.resolvedOptions) {
          var resOptions = converter.resolvedOptions();
          if (allowedTypes.indexOf(resOptions.virtualKeyboardHint) >= 0) {
            inputType = resOptions.virtualKeyboardHint;
          }
        }
      }
    }

    if (inputType == null) {
      this.element[0].removeAttribute('type');
    } else {
      this.element[0].setAttribute('type', inputType);
    }
  };

  /**
   * Draw a readonly div. When readonly, this div is shown and
   * the input has display:none on it through theming, and vice versa.
   * We set the textContent in _SetDisplayValue() if readonly
   * @param {HTMLElement} pass in this.element[0]
   * @return {HTMLElement|null} the readonlyDivElem or null if we don't want
   * to use a readonly div.
   * @private
   * @ignore
   */
  EditableValueUtils._createReadonlyDiv = function (element) {
    if (this._UseReadonlyDiv()) {
      var readonlyElem = document.createElement('div');
      readonlyElem.classList.add('oj-text-field-readonly-div');

      // create this inner element that holds the text.  This is needed
      // so that we can put flexbox styles on the oj-text-field-readonly-div
      // to have the text vertically centered in the div.
      var readonlyInnerElem = document.createElement('div');
      readonlyInnerElem.classList.add('oj-text-field-readonly');
      readonlyInnerElem.setAttribute('role', 'textbox');
      readonlyInnerElem.setAttribute('aria-readonly', true);

      readonlyElem.appendChild(readonlyInnerElem);

      element.parentNode.insertBefore(readonlyElem, element); // @HTMLUpdateOK
      // return the element that we need to set textContent, aria-labelledby, etc.
      return readonlyInnerElem;
    }
    return null;
  };

  /**
   * Returns the inner readonly div HTMLElement that we need to set textContent,
   * aria-labelledby, etc.
   * @private
   * @ignore
   */
  EditableValueUtils._getReadonlyDiv = function () {
    return this.widget()[0].querySelector('.oj-text-field-readonly');
  };

  /**
   * The various validation modes
   * @ignore
   */

  var _sValidationMode = {
    FULL: 1,
    VALIDATORS_ONLY: 2,
    REQUIRED_VALIDATOR_ONLY: 3
  };

  /**
   * The displayOptions property default options when theme is Redwood
   * @ignore
   */
  var _sDisplayOptionsRedwoodDefaults = {
    MESSAGES: 'display',
    VALIDATOR_HINT: 'display',
    CONVERTER_HINT: 'display'
  };

  /**
   * The displayOptions property default options when theme is Alta
   * As of v9.0, the Alta theme is deprecated.
   * @ignore
   */
  var _sDisplayOptionsAltaDefaults = {
    MESSAGES: ['inline'],
    VALIDATOR_HINT: ['notewindow'],
    CONVERTER_HINT: ['placeholder', 'notewindow']
  };

  /**
   * String used in the id on the span that surrounds the help icon.
   * @const
   * @private
   * @type {string}
   */
  var _HELP_ICON_ID = '_helpIcon';

  /**
   * valid state constants
   * @const
   * @private
   * @type {string}
   */
  var _VALID = 'valid';

  /**
   * valid state constants
   * @const
   * @private
   * @type {string}
   */
  var _INVALID_HIDDEN = 'invalidHidden';

  /**
   * valid state constants
   * @const
   * @private
   * @type {string}
   */
  var _INVALID_SHOWN = 'invalidShown';

  /**
   * valid state constants
   * @const
   * @private
   * @type {string}
   */
  var _PENDING = 'pending';

  // E D I T A B L E V A L U E    A B S T R A C T   W I D G E T
  /**
   * @ojcomponent oj.editableValue
   * @augments oj.baseComponent
   * @ojsignature [{
   *                target: "Type",
   *                value: "abstract class editableValue<V, SP extends editableValueSettableProperties<V, SV, RV>, SV= V, RV= V> extends baseComponent<SP>"
   *               },
   *               {
   *                target: "Type",
   *                value: "editableValueSettableProperties<V, SV=V, RV=V> extends baseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @ojtsimport {module: "ojmessaging", type:"AMD", importName: "Message"}
   * @abstract
   * @since 0.6.0
   * @ojshortdesc Abstract EditableValue element
   * @ojrole input
   * @hideconstructor
   *
   * @classdesc
   * Abstract base class for all editable components that are value holders and that require
   * validation and messaging capabilities. <br/>
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *  * <p>
   * Note: The <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>,
   * <code class="prettyprint">converter</code> properties and the <code class="prettyprint">validate</code>
   * method are not on all EditableValue components so they are not on the EditableValue class.
   * See the EditableValue subclasses for which ones have which of these properties. For example,
   * oj-switch, oj-slider, oj-color-palette, and oj-color-spectrum do not have the
   * <code class="prettyprint">validate</code> method nor do they have the
   * <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>,
   * <code class="prettyprint">converter</code> properties since the components
   * wouldn't do anything with these properties anyway. A user can't type into these components and there
   * is no visual representation for 'nothing is set' on these components. Whereas InputBase, inputNumber,
   * inputSearch and combobox do have these properties since a user can type into the field (so you may
   * need to convert it and validate it) and also blank it out (so you may need to mark it required and
   * run the required validator).
   * </p>

   * <p>
   * <h3 id="declarative-binding-section">
   * Declarative Binding
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#declarative-binding-section"></a>
   * </h3>
   * When the component's <code class="prettyprint">value</code> property is bound to a Knockout
   * observable and when the value changes, whether the observable is updated or not, and whether a
   * 'writeback' to the observable happens or not, depends on the action that caused the value to
   * change.
   * <ul>
   * <li>when the value changes as a result of user interaction </li>
   * <li>when the value changes because normal validation was run as a result of these properties
   * being changed by the app - <code class="prettyprint">converter</code>, <code class="prettyprint">disabled</code>,
   * <code class="prettyprint">required</code>, <code class="prettyprint">validators</code>, then the
   * value is written to the observable. See the specific property docs for details.</li>
   * <li>when the value changes because normal validation was run as a result of these methods being
   * called by the app -
   * <code class="prettyprint">refresh</code>, <code class="prettyprint">validate</code>,
   * then the value is written to the observable. See the specific method docs for details.</li>
   * <li>when the value changes due to programmatic intervention by app then the value is not written
   * back to observable. This is based on the assumption that the app has mutated the observable
   * already. In this case updating the component's <code class="prettyprint">value</code> property
   * alone will not propagate the change automatically to the observable. Updating the observable is
   * recommended as this will propagate the change automatically to the component.
   * </li>
   * </ul>
   * </p>
   *
   * @example <caption>Initialize component</caption>
   * &lt;oj-input-text id="foo" value="abc"/&gt;
   * @example <caption>Initialize component value using two way data binding</caption>
   * &lt;oj-input-text id="foo" value="{{salary}}"/&gt;
   * &lt;script&gt;
   * &nbsp;&nbsp;var salary = ko.observable('abc');
   * &lt;/script&gt;
   */
  oj.__registerWidget(
    'oj.editableValue',
    $.oj.baseComponent,
    {
      widgetEventPrefix: 'oj',

      options: {
        /**
         * The oj-label sets the described-by attribute programmatically on the form component.
         * This attribute is not meant to be set by an application developer directly.
         * The described-by is copied to the aria-describedby
         * attribute on the component's inner dom element, and it is needed
         * for accessibility.
         * @example <caption>Initialize component with the <code class="prettyprint">described-by</code> attribute specified:</caption>
         * &lt;oj-some-element described-by="someId">&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">describedBy</code> property after initialization:</caption>
         * // getter
         * var descById = myComp.describedBy;
         *
         * // setter
         * myComp.describedBy = "someId";
         *
         * @ojshortdesc The form component's oj-label automatically sets described-by
         * to make it accessible. It is not meant to be set by application developer.
         * @expose
         * @type {?string}
         * @public
         * @instance
         * @memberof oj.editableValue
         * @since 4.0.0
         */
        describedBy: null,
        /**
         * Whether the component is disabled. The default is false.
         *
         * <p>
         * When the <code class="prettyprint">disabled</code> property changes due to programmatic
         * intervention, the component may clear messages and run validation in some cases. </br>
         * <ul>
         * <li>when a required component is initialized as disabled
         * <code class="prettyprint">value="{{currentValue}}" required disabled</code>,
         * deferred validation is skipped.</li>
         * <li>when a disabled component is enabled,
         *  <ul>
         *  <li>if component is invalid and showing messages then all component messages are cleared,
         *  and full validation run using the display value.
         *   <ul>
         *    <li>if there are validation errors, they are shown.</li>
         *    <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *    property is updated. Page authors can listen to the <code class="prettyprint">valueChanged</code>
         *    event to clear custom errors.</li>
         *   </ul>
         *  </li>
         *
         *  <li>if component is valid and has no errors then deferred validation is run.
         *    <ul>
         *    <li>if there is a deferred validation error, then the valid property is updated. </li>
         *    </ul>
         *  </li>
         *  <li>if component is invalid and deferred errors then component messages are cleared and
         *  deferred validation re-run.
         *    <ul>
         *    <li>if there is a deferred validation error, then the valid property is updated.</li>
         *    </ul>
         *  </li>
         *  </ul>
         * </li>
         * <li>when enabled component is disabled then no validation is run and the component appears
         * disabled.</li>
         * </ul>
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">disabled</code> attribute:</caption>
         * &lt;oj-some-element disabled>&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabled = myComp.disabled;
         *
         * // setter
         * myComp.disabled = false;
         *
         * @ojshortdesc Specifies whether the component is disabled. The default is false.
         * @expose
         * @type {boolean}
         * @default false
         * @public
         * @instance
         * @memberof oj.editableValue
         * @since 0.7.0
         */
        disabled: false,
        displayOptions: {},
        /**
         * Form component help information.
         * @expose
         * @memberof oj.editableValue
         * @instance
         * @public
         * @type {Object}
         * @since 0.7.0
         */
        help: undefined,
        /**
         * <p>help definition text.  See the top-level <code class="prettyprint">help</code> option for details.
         *
         * @expose
         * @name help.definition
         * @memberof! oj.editableValue
         * @instance
         * @type {?string}
         * @ignore
         * @default null
         *
         * @example <caption>Get or set the <code class="prettyprint">help.definition</code> sub-option, after initialization:</caption>
         * // getter
         * var definitionText = myInputComp.help.definition;
         *
         * // setter:
         * myInputComp.help.definition = "Enter your name";
         */
        /**
         * <p>help source url.  See the top-level <code class="prettyprint">help</code> option for details.
         *
         * @expose
         * @name help.source
         * @memberof! oj.editableValue
         * @instance
         * @ignore
         * @type {?string}
         * @default null
         *
         * @example <caption>Get or set the <code class="prettyprint">help.source</code> sub-option, after initialization:</caption>
         * // getter
         * var helpSource = myInputComp.help.source;
         *
         * // setter:
         * myInputComp.help.source = "www.abc.com";
         */
        /**
         * <p>
         * The helpHints object contains a definition property and a source property.
         * </p>
         * <ul>
         * <li><code class="prettyprint">definition</code> - hint for help definition text.</li>
         * <li><code class="prettyprint">source</code> - hint for help source URL.</li>
         * </ul>
         *
         * @example <caption>Initialize the component with help hints:</caption>
         * &lt;!-- Using dot notation -->
         * &lt;oj-some-element help-hints.definition='some value' help-hints.source='some-url'>&lt;/oj-some-element>
         *
         * &lt;!-- Using JSON notation -->
         * &lt;oj-some-element help-hints='{"definition":"some value", "source":"some-url"}'>&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">helpHints</code> property after
         * initialization:</caption>
         *
         * // Get one
         * var value = myComponent.helpHints.definition;
         *
         * // Set one, leaving the others intact. Always use the setProperty API for
         * // subproperties rather than setting a subproperty directly.
         * myComponent.setProperty('helpHints.definition', 'some new value');
         *
         * // Get all
         * var values = myComponent.helpHints;
         *
         * // Set all.  Must list every subproperty, as those not listed are lost.
         * myComponent.helpHints = {
         *     definition: 'some new value',
         *     source: 'some-new-url'
         * };
         *
         * @ojshortdesc Represents hints for an oj-form-layout element to render help information on the label of the editable component.
         * @expose
         * @access public
         * @memberof oj.editableValue
         * @ojtranslatable
         * @instance
         * @type {Object}
         * @since 4.1.0
         */
        helpHints: {
          /**
           * A type of user assistance text. User assistance text is used to provide
           * guidance to help the user understand what data to enter or select. help-hints could
           * come from a help system.
           * <p>In the Redwood theme for clarity only one user assistance text shows to the user.
           * The precedence rules are:
           * <ul>
           * <li>help.instruction shows;</li>
           * <li>if no help.instruction, then validator hint shows;</li>
           * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
           * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
           * <li>help-hints.source always shows along side the above.</li>
           * </ul>
           * </p>
           * <p>
           * In the Redwood theme, by default all user assistance text shows inline.
           * For input components, it shows when the field takes focus. In other components it
           * shows all the time. See the user-assistance-density property for other ways the user
           * assistance text can render.
           * </p>
           * <p>No formatted text is available for help definition attribute.</p>
           *
           * <p>See the <a href="#helpHints">help-hints</a> attribute for usage examples.</p>
           *
           * @ojshortdesc Hint for help definition text associated with the label.
           * @expose
           * @name helpHints.definition
           * @memberof! oj.editableValue
           * @instance
           * @type {string}
           * @ojsignature {target:"Type", value: "?"}
           * @default ""
           * @since 4.1.0
           */
          definition: '',
          /**
           * Help source URL associated with the component.
           * <p>In the Redwood theme, the help-hints.source will show as a link inline to the field.
           * For input components, it shows when the field takes focus. For other components,
           * it shows all the time.
           * </p>
           * <p>
           * For security reasons we only support urls with protocol 'http:' or 'https:'.
           * If the url doesn't comply we ignore it and throw an error.
           * Pass in an encoded URL since we do not encode the URL.</p>
           *
           * <p>See the <a href="#helpHints">help-hints</a> attribute for usage examples.</p>
           *
           * @ojshortdesc Help source URL associated with the component.
           * @expose
           * @name helpHints.source
           * @memberof! oj.editableValue
           * @instance
           * @type {string}
           * @ojsignature {target:"Type", value: "?"}
           * @default ""
           * @since 4.1.0
           */
          source: ''
        },
        /**
         * Represents a hint for rendering a label on the component.
         * <p>This is used in combination with the <a href="#labelEdge">label-edge</a> attribute to control how the label should be rendered.</p>
         *
         * <p>
         * When label-edge is "provided", it gives a hint to oj-form-layout parent element to create an oj-label element for the component.
         * When the <code class="prettyprint">label-hint</code> attribute changes, oj-form-layout element refreshes to
         * display the updated label information.
         * </p>
         * <p>
         * When label-edge is "inside", it gives a hint to the component itself to render a label.
         * </p>
         * <p>
         * When label-edge is "none", and if the component has no labelled-by, aria-label, or aria-labelledby attribute, the label-hint value will be used as the aria-label.
         * </p>
         *
         * @example <caption>Add the component as a direct child of oj-form-layout. Initialize the component with the <code class="prettyprint">label-hint</code> attribute specified.</caption>
         * &lt;oj-form-layout id= 'someId'>
         * &lt;/oj-some-element label-hint='input label'>&lt;/oj-some-element>
         * &lt;/oj-form-layout>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelHint</code> property after
         * initialization:</caption>
         *
         * // getter
         * var value = myComponent.labelHint;
         *
         * // setter
         * myComponent.labelHint = 'some new value'
         *
         * @ojshortdesc Represents a hint for oj-form-layout element to render a label on the editable component.
         * @expose
         * @access public
         * @instance
         * @name labelHint
         * @ojtranslatable
         * @default ""
         * @memberof oj.editableValue
         * @type {string}
         * @since 4.1.0
         */
        labelHint: '',

        /**
         * Specifies how the label of the component is created when the <code class="prettyprint">label-hint</code> attribute is set on the component.
         * <p>The default value varies by theme, and it works well for the theme in most cases.
         *  If the component is in an oj-form-layout, the label-edge attribute could come from the oj-form-layout's label-edge attribute.
         * The oj-form-layout component uses the <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide and uses the <a href="MetadataTypes.html#ProvideProperty">MetadataTypes.ProvideProperty</a>
         * <code class="prettyprint">transform</code> property to transform its <code class="prettyprint">label-edge</code>
         * attribute to any descendent components that are configured to consume it.
         * For example, if the oj-form-layout's label-edge attribute is set to "top" or "start", and a descendent form component does
         * not have its label-edge attribute set, the form component's label-edge will be the transformed value "provided".</p>
         * @ojshortdesc Defines how the label of a component is created. See the Help documentation for more information.
         * @access public
         * @expose
         * @name labelEdge
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "'inside'|'none'|'provided'",  jsdocOverride: true}
         * @memberof! oj.editableValue
         * @ojvalue {string} "inside" The component creates the label using the <code class="prettyprint">label-hint</code> attribute.
         * <p>For text input components (such as oj-input-text), the label floats over the input element but moves up on focus or when the component has a value.</p>
         * <p>For non-text input components (such as oj-checkboxset), the label is created at the top of the component and doesn't move.</p>
         * @ojvalue {string} "none" The component will not have a label, regardless of whether it's in an oj-form-layout or not.
         * <p>If the component has a <code class="prettyprint">label-hint</code> attribute but no labelled-by, aria-label, or aria-labelledby attribute, the label-hint value will be used as the aria-label.</p>
         * <p>Note that if the component already has an external label, "none" should not be specified and "provided" should be used instead.
         * Otherwise it may end up with conflicting label information.</p>
         * @ojvalue {string} "provided" Label is provided by the parent if the parent is an oj-form-layout.
         * <p>oj-form-layout provides the label using the label-hint from the form control and the <a href="oj.ojFormLayout.html#labelEdge">label-edge</a> from oj-form-layout.</p>
         * <p>If there is no oj-form-layout, use an oj-label.</p>
         * @since 8.0.0
         */
        labelEdge: undefined,

        /**
         * List of messages an app would add to the component when it has business/custom validation
         * errors that it wants the component to show. This allows the app to perform further validation
         * before sending data to the server. When this option is set the message shows to the
         * user right away. To clear the custom message, set <code class="prettyprint">messagesCustom</code>
         * back to an empty array.<br/>
         * <p>Each message in the array is an object that duck types oj.Message.
         * See {@link Message} for details.
         * message detail text can include formatted HTML text, whereas
         * hints and message summary text cannot. If you use formatted text, it should be accessible
         * and make sense to the user if formatting wasn't there.
         * The allowed html tags are: span, b, i, em, br, hr, li, ol, ul, p, small, pre.
         * To format the message detail, you could do this:
         * <pre class="prettyprint"><code>&lt;html>Enter &lt;b>at least&lt;/b> 6 characters&lt;/html></code></pre>
         * </p>
         * <p>
         * See the <a href="#validation-section">Validation and Messages</a> section
         * for details on when the component clears <code class="prettyprint">messagesCustom</code>;
         * for example, when full validation is run.
         * </p>
         * <p>In the Redwood theme, the Message summary is not displayed to the user, so make sure to have a Message detail
         * set in your Message object.
         * </p>
         *
         *
         * @example <caption>Get or set the <code class="prettyprint">messagesCustom</code> property after initialization:</caption>
         * // getter
         * var customMsgs = myComp.messagesCustom;
         *
         * // setter
         * myComp.messagesCustom = [{summary:"hello", detail:"detail", severity:Message.SEVERITY_LEVEL.INFO}];
         *
         * @example <caption>Set messagesCustom when there are cross-validation errors:</caption>
         * --- HTML ---
         * &lt;oj-some-element messages-custom='{{messagesCustom}}'>&lt;/oj-some-element>
         *
         * --- ViewModel code ---
         * self.messagesCustom = ko.observableArray([]);
         *
         * // the app's function that gets called when the user presses the submit button
         * if (!myValidateCrossValidationFields())
         * {
         *   // the app adds a custom messages to the component and it is displayed right away
         *   var msgs = [];
         *   msgs.push({'summary':'Cross field error', 'detail':'Field 1 needs to be less than Field 2'});
         *   self.messagesCustom(msgs);
         * }
         * else
         * {
         *   // submit data to the server
         * }
         *
         * @ojshortdesc A list of messages added by an application to the component. See the Help documentation for more information.
         * @expose
         * @access public
         * @instance
         * @memberof oj.editableValue
         * @default []
         * @type {Array.<Object>}
         * @ojsignature {target: "Type", value: "Array<oj.Message>"}
         * @since 0.7.0
         * @ojwriteback
         */
        messagesCustom: [],

        /**
         * List of messages currently hidden on component, these are added by component when it runs
         * deferred validation. Each message in the array is an object that duck types oj.Message.
         * See {@link Message} for
         * details. <br/>
         *
         * <p>
         * This is a read-only option so page authors cannot set or change it directly.
         * </p>
         *
         * <p>
         * These messages are not shown to the end-user by default, but page author
         * can show hidden messages using the {@link showMessages} method.
         * </p>
         *
         * @example <caption>Get <code class="prettyprint">messagesShown</code> for the component:</caption>
         * // Foo is InputText, InputNumber, Select, etc.
         * var messages = myInputComp.messagesShown;
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.editableValue
         * @default []
         * @type {Array.<Object>|undefined}
         * @since 0.7.0
         * @see #showMessages
         * @readonly
         * @ignore
         * @ojwriteback
         */
        messagesHidden: undefined,

        /**
         * List of messages currently shown on component, these include messages generated both by the
         * component and ones provided by app using <code class="prettyprint">messagesCustom</code>.
         * Each message in the array is an object that duck types oj.Message.
         * See {@link Message} for details. <br/>
         *
         * <p>
         * This is a read-only option so page authors cannot set or change it directly.
         * </p>
         *
         * <p>
         * Messages retrieved using the <code class="prettyprint">messagesShown</code> option are by
         * default shown inline, but this can be controlled using the 'messages' property of
         * the <code class="prettyprint">displayOptions</code> option.
         * </p>
         *
         * @example <caption>Get <code class="prettyprint">messagesShown</code> for the component:</caption>
         * // Foo is InputText, InputNumber, Select, etc.
         * var messages = myInputComp.messagesShown;
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.editableValue
         * @default []
         * @type {Array.<Object>|undefined}
         * @since 0.7.0
         * @readonly
         * @ignore
         * @ojwriteback
         */
        messagesShown: undefined,
        /**
         * A type of user assistance text. User assistance text is used to provide
         * guidance to help the user understand what data to enter or select.
         * <p> In the Redwood theme for clarity only one user assistance text shows to the user.
         *  The precedence rules are:
         * <ul>
         * <li>help.instruction shows;</li>
         * <li>if no help.instruction, then validator hint shows;</li>
         * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
         * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
         * <li>help-hints.source always shows along side the above.</li>
         * </ul>
         * </p>
         * <p>In the Redwood theme, by default all user assistance text shows inline.
         * For input components, it shows when the field takes focus. In other components
         * it shows all the time. See the user-assistance-density property for other ways
         * the user assistance text can render.
         * <p>
         *  How is help.instruction better than the html 'title' attribute?
         * The html 'title' attribute only shows up as a tooltip on mouse over, not on keyboard and not in a mobile
         * device. So the html 'title' would only be for text that is not important enough to show all users, or
         * for text that you show the users in another way as well, like in the label.
         * Also you cannot theme the native browser's title window like you can the JET
         * notewindow, so low vision users may have a hard time seeing the 'title' window.
         * For these reasons, the JET EditableValue components do not use the HTML's 'title'
         * attribute and instead use the help.instruction attribute.
         * </p>
         *
         * <p>
         * To include formatted text in the help.instruction, format the string using html tags.
         * The allowed html tags are: span, b, i, em, br, hr, li, ol, ul, p, small, pre.
         * For example the
         * help.instruction might look like:
         * <pre class="prettyprint"><code>&lt;oj-some-element help.instruction="&lt;html>Enter &lt;b>at least&lt;/b> 6 characters&lt;/html>">&lt;/oj-some-element></code></pre>
         * If you use formatted text, it should be accessible
         * and make sense to the user if formatting wasn't there.
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">help.instruction</code> sub-attribute:</caption>
         * &lt;oj-some-element help.instruction="some tooltip">&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">help.instruction</code> property after initialization:</caption>
         * // Get one subproperty
         * var instr = myComp.help.instruction;
         *
         * // Set one subproperty, leaving the others intact. Use the setProperty API for
         * // subproperties so that a property change event is fired.
         * myComponent.setProperty('help.instruction', 'some new value');
         *
         * // Get all
         * var values = myComponent.help;
         *
         * // Set all.  Must list every resource key, as those not listed are lost.
         * myComponent.help = {
         *   instruction: 'some new value'
         * };
         *
         * @ojshortdesc Represents advisory information for the component, such as would be appropriate for a tooltip.
         * @expose
         * @access public
         * @instance
         * @name help.instruction
         * @ojtranslatable
         * @default ""
         * @memberof! oj.editableValue
         * @type {string=}
         * @since 4.0.0
         */
        title: '',
        /**
         * <p>
         * Specifies the density of the form component's user assistance presentation.
         * It can be shown inline with reserved rows to prevent reflow if
         * a user assistance text shows up, inline without reserved rows that would reflow if
         * a user assistance text shows up,
         * or it can be shown compactly in a popup instead.</p>
         * <p>
         * The default value is 'reflow' when the form component is not a descendent of an oj-form-layout
         * component. When the form component is a descendent of an oj-form-layout, the default value comes from the
         * oj-form-layout's <code class="prettyprint">user-assistance-density</code> attribute value.
         * </p>
         * <p>
         * The oj-form-layout component uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">user-assistance-density</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the
         * <code class="prettyprint">user-assistance-density</code> property if an
         * ancestor provides it and it is not explicitly set on the form component.
         * Example, oj-form-layout defaults user-assistance-density='efficient', so all its
         * form components descendents will have user-assistance-density='efficient' by default.
         * </p>
         * @ojshortdesc Specifies the density of the form component's user assistance presentation.
         * @access public
         * @expose
         * @name userAssistanceDensity
         * @ojunsupportedthemes ["Alta"]
         * @default "reflow"
         * @instance
         * @type {string}
         * @ojsignature {target: "Type", value: "'reflow'|'efficient'|'compact'",  jsdocOverride: true}
         * @memberof oj.editableValue
         * @ojvalue {string} "reflow" Messages, help, hints, and required are all shown inline under the field with no reserved space.
         * @ojvalue {string} "efficient" Messages, help, hints, and required are all shown inline under the field with reserved space.
         * @ojvalue {string} "compact" Messages, help, hints, and required will not be shown inline; they will show in a mode that keeps the screen more compact, like
         * a popup for the messages, and a required icon to indicate Required.
         * @since 9.0.0
         */
        userAssistanceDensity: 'reflow',
        /**
         * <p>
         * The current valid state of the component. It is evaluated on initial render.
         * It is re-evaluated
         * <ul>
         *   <li>after each validator (validators or async-validators) is run (full or deferred)</li>
         *   <li>when messagesCustom is updated,
         *   since messagesCustom can be added by the app developer any time.</li>
         *   <li>when showMessages() is called. Since showMessages() moves the
         *   hidden messages into messages shown,
         *   if the valid state was "invalidHidden" then it would become "invalidShown".</li>
         *   <li>when the required property has changed. If a component is empty and has required
         *   set, the valid state may be "invalidHidden" (if no invalid messages are being shown as well).
         *   If required property is removed, the valid state would change to "valid".</li>
         * </ul>
         * </p>
         * <p>
         *  Note: New valid states may be added to the list of valid values in future releases.
         *  Any new values will start with "invalid"
         *  if it is an invalid state, "pending" if it is pending state,
         *  and "valid" if it is a valid state.
         * </p>
         * @example <caption>Get <code class="prettyprint">valid</code> attribute, after initialization:</caption>
         * // Getter:
         * var valid = myComp.valid;
         * @example <caption>Set the <code class="prettyprint">on-valid-changed</code>
         *  listener so you can do work in the ViewModel based on the
         *  <code class="prettyprint">valid</code> property:</caption>
         * &lt;oj-some-element id='username' on-valid-changed='[[validChangedListener]]'>
         * &lt;/oj-some-element>
         * &lt;oj-some-element id='password' on-valid-changed='[[validChangedListener]]'>
         * &lt;/oj-some-element>
         * &lt;oj-button disabled='[[componentDisabled]]' on-click='[[submit]]'>Submit&lt;/oj-button>
         * -- ViewModel --
         * self.validChangedListener = function (event) {
         *   var enableButton;
         *   var usernameValidState;
         *   var passwordValidState;
         *
         *   // update the button's disabled state.
         *   usernameValidState = document.getElementById("username").valid;
         *   passwordValidState = document.getElementById("password").valid;
         *
         *   // this updates the Submit button's disabled property's observable based
         *   // on the valid state of two components, username and password.
         *   // It is up to the application how it wants to handle the “pending�? state
         *   // but we think that in general buttons don’t need to be
         *   // enabled / disabled based on the "pending" state.
         *   enableButton =
         *    (usernameValidState !== "invalidShown") &&
         *    (passwordValidState !== "invalidShown");
         *   self.componentDisabled(!enableButton);;
         * };
         *
         * @ojshortdesc The validity state of the component
         * @expose
         * @access public
         * @instance
         * @type {string}
         * @ojvalue {string} "valid" The component is valid
         * @ojvalue {string} "pending" The component is waiting for the validation state to be determined.
         * The "pending" state is set at the start of the convert/validate process.
         * @ojvalue {string} "invalidHidden" The component has invalid messages hidden
         *    and no invalid messages showing. An invalid message is one with severity "error" or higher.
         * @ojvalue {string} "invalidShown" The component has invalid messages showing.
         *  An invalid message is one with severity "error" or higher.
         * @ojwriteback
         * @readonly
         * @memberof oj.editableValue
         * @since 4.2.0
         *
         */
        valid: undefined,

        /**
         * The value of the component.
         *
         * <p>
         * When <code class="prettyprint">value</code> property changes due to programmatic
         * intervention, the component always clears all messages
         * including <code class="prettyprint">messagesCustom</code>, runs deferred validation, and
         * always refreshes UI display value.</br>
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>component always runs deferred validation; the
         * <code class="prettyprint">valid</code> property is updated with the result.</li>
         * </ul>
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">value</code> attribute specified:</caption>
         * &lt;oj-some-element value='10'>&lt;/oj-some-element>
         * @example <caption>Get or set <code class="prettyprint">value</code> attribute, after initialization:</caption>
         * // Getter: returns '10'
         * var val = myComp.value;
         * // Setter: sets '20'
         * myComp.value = '20';
         *
         * @ojshortdesc The value of the component.
         * @expose
         * @access public
         * @instance
         * @default null
         * @ojwriteback
         * @ojeventgroup common
         * @memberof oj.editableValue
         * @since 0.6.0
         * @type {any}
         * @ojsignature {
         *                 target: "Accessor",
         *                 value: {
         *                          GetterType: "V|null",
         *                          SetterType: "SV|null"}
         *              }
         */
        value: undefined,

        // Events
        /**
         * Triggered when a default animation is about to start on an element owned by the component.
         *
         * <p>The default animation can be cancelled by calling <code class="prettyprint">event.preventDefault</code>, followed by
         * a call to <code class="prettyprint">event.detail.endCallback</code>.  <code class="prettyprint">event.detail.endCallback</code> should be
         * called immediately after <code class="prettyprint">event.preventDefault</code> if the application merely wants to cancel animation,
         * or it should be called when the custom animation ends if the application is invoking another animation function.  Failure to
         * call <code class="prettyprint">event.detail.endCallback</code> may prevent the component from working properly.</p>
         * <p>For more information on customizing animations, see the documentation of
         * <a href="AnimationUtils.html">AnimationUtils</a>.</p>
         *
         * <caption>The default animations are controlled via the theme:</caption>
         * <pre class="prettyprint"><code>
         * // default animations for notewindow help and hints and messages
         * $popupTailOpenAnimation: (effect: "zoomIn", transformOrigin: "#myPosition") !default;
         * $popupTailCloseAnimation: (effect: "none") !default;
         *
         * // default animations for Redwood's inline messages shown when userAssistanceDensity
         * // is reflow or efficient.
         * $messageComponentInlineOpenAnimation: (effect: "fadeIn", duration: "100ms", timingFunction: "linear") !default;
         * $messageComponentInlineCloseAnimation: (effect: "fadeOut", duration: "100ms", timingFunction: "linear") !default;
         *
         * </code></pre>
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @ojshortdesc Triggered when a default animation is about to start, such as when the component is being opened/closed or a child item is being added/removed.
         *
         * @expose
         * @event
         * @memberof oj.editableValue
         * @since 4.0.0
         * @ojbubbles
         * @ojcancelable
         * @instance
         * @property {string} action The action that triggers the animation.</br></br>
         *                           Supported values are:
         *                              <ul>
         *                                <li>"inline-hints-open" - when an inline helphints container opens</li>
         *                                <li>"inline-hints-close" - when an inline helphints container closes</li>
         *                                <li>"inline-open" - when an inline message container opens or increases in size</li>
         *                                <li>"inline-close" - when an inline message container closes or decreases in size</li>
         *                                <li>"notewindow-open" - when a note window opens</li>
         *                                <li>"notewindow-close" - when a note window closes</li>
         *                              </ul>
         * @property {Element} element The element being animated.
         * @property {function():void} endCallback If the event listener calls event.preventDefault to
         *            cancel the default animation, it must call the endCallback function when it
         *            finishes its own animation handling and any custom animation has ended.
         *
         * @example <caption>Define an event listener for the
         *          <code class="prettyprint">ojAnimateStart</code> event to override the default
         *          "inline-open" animation:</caption>
         * var listener = function( event )
         *   {
         *     // Change the "inline-open" animation for inline message
         *     if (event.detail.action == "inline-open") {
         *       // Cancel default animation
         *       event.preventDefault();
         *       // Invoke new animation and call endCallback when the animation ends
         *       oj.AnimationUtils.fadeIn(event.detail.element).then(event.detail.endCallback);
         *     }
         *   };
         *
         * @example <caption>Define an event listener for the
         *          <code class="prettyprint">ojAnimateStart</code> event to cancel the default
         *          "notewindow-close" animation:</caption>
         * var listener = function( event )
         *   {
         *     // Change the "notewindow-close" animation for note window
         *     if (ui.action == "notewindow-close") {
         *       // Cancel default animation
         *       event.preventDefault();
         *       // Call endCallback immediately to indicate no more animation
         *       event.detail.endCallback();
         *     }
         *   };
         */
        animateStart: null,
        /**
         * Triggered when a default animation has ended.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @ojbubbles
         * @ojcancelable
         * @memberof oj.editableValue
         * @since 4.0.0
         * @instance
         * @property {string} action The action that triggered the animation.</br></br>
         *                           Supported values are:
         *                              <ul>
         *                                <li>"inline-open" - when an inline message container opens or increases in size</li>
         *                                <li>"inline-close" - when an inline message container closes or decreases in size</li>
         *                                <li>"notewindow-open" - when a note window opens</li>
         *                                <li>"notewindow-close" - when a note window closes</li>
         *                              </ul>
         * @property {Element} element The element being animated.
         * @example <caption>Define an event listener for the
         *          <code class="prettyprint">ojAnimateEnd</code> event to add any processing after the end of
         *          "inline-open" animation:</caption>
         * var listener = function( event )
         * {
         *   // Check if this is the end of "inline-open" animation for inline message
         *   if (event.detail.action == "inline-open") {
         *     // Add any processing here
         *   }
         * };
         */
        animateEnd: null
      },

      // P U B L I C    M E T H O D S

      // @inheritdoc
      getNodeBySubId: function (locator) {
        var node;
        var subId;

        node = this._super(locator);

        // this subId is only for non-custom element components so skip if custom element
        if (!node && !this._IsCustomElement()) {
          subId = locator.subId;

          if (subId === 'oj-label-help-icon') {
            var label = this._GetLabelElement();

            if (label) {
              node = label.parent().find('.oj-label-help-icon');
            }
          }
        }
        // Non-null locators have to be handled by the component subclasses
        return node || null;
      },

      getSubIdByNode: function (elem) {
        var $node;
        var anchor;
        var div;
        var label;
        var subId = null;

        if (elem != null) {
          $node = $(elem);
          anchor = $node.closest('a.oj-label-help-icon');

          if (anchor != null) {
            // Go up to the top level element of the label
            div = anchor.closest('.oj-label');

            if (div != null) {
              // Now find the actual label
              label = div.find('label')[0];

              if (label) {
                // Make sure the label is the one associated with this component
                if (label === this._GetLabelElement()[0]) {
                  subId = { subId: 'oj-label-help-icon' };
                }
              }
            }
          }
        }

        return subId;
      },
      /**
       * whether the component is currently valid.  It is valid if it doesn't have any errors.
       * This method is final; do not override.
       * Currently this is for the widget components and not custom elements.
       * @example <caption>Check whether the component is valid:</caption>
       * var valid = myInputElement.isValid();
       * @returns {boolean}
       * @access public
       * @instance
       * @expose
       * @memberof oj.editableValue
       * @final
       * @ignore
       */
      isValid: function () {
        if (this._valid === undefined) {
          this._valid = !this._hasInvalidMessages();
        }

        return this._valid;
      },

      /**
       * Called when the DOM underneath the component changes requiring a re-render of the component. An
       * example is when the <code class="prettyprint">id</code> for the input changes. <br/>
       * <p>
       * Another time when refresh might be called is when the locale for the page changes. When it
       * changes, attributes used by its converter and validator that are locale specific, its hints,
       * messages and translations will be updated.
       * </p>
       *
       * <p>
       * When <code class="prettyprint">refresh</code> method is called, the component may take various
       * steps such as clearing messages, running validation etc., based on the state it is in. </br>
       *
       * <h4>Steps Performed Always</h4>
       * <ul>
       * <li>The converter and validators used by the component are reset, and new converter and
       * validator hints is pushed to messaging. E.g., notewindow displays the new hint(s).
       * </li>
       * </ul>
       *
       * <h4>Running Validation</h4>
       * <ul>
       * <li>if component is valid when refresh() is called, the display value is refreshed if component
       * has a converter set.</li>
       * <li>if component is invalid and is showing messages when
       * <code class="prettyprint">refresh()</code> is called, then all component messages are cleared
       * and full validation run using the display value on the component.
       * <ul>
       *   <li>if there are validation errors, then <code class="prettyprint">value</code>
       *   attribute is not updated and the error is shown.
       *   </li>
       *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
       *   attribute is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
       *   event to clear custom errors.</li>
       * </ul>
       * </li>
       * <li>if component is invalid and has deferred messages when <code class="prettyprint">refresh()</code>
       * is called, then all component messages are cleared and deferred validation is run.</li>
       * </ul>
       * </p>
       *
       * <h4>Clearing Messages</h4>
       * <ul>
       * <li>If clearing messages only those created by the component are cleared.
       * <li><code class="prettyprint">messagesCustom</code> attribute is not cleared.</li>
       * </ul>
       * </p>
       *
       * @example <caption>Redraw the component element.</caption>
       * myComp.refresh();
       *
       * @access public
       * @instance
       * @expose
       * @return {void}
       * @memberof oj.editableValue
       * @ojshortdesc Called when the DOM underneath the component changes, requiring a re-render of the component.
       * @since 0.7.0
       */
      refresh: function () {
        this._super();
        // doRefresh refreshes value and disabled
        this._doRefresh();
      },

      /**
       * Resets the component by clearing all messages and messages attributes -
       * <code class="prettyprint">messagesCustom</code> -
       * and updates the component's display value using the attribute value. User entered values will be
       * erased when this method is called.
       *
       * @example <caption>Reset component</caption>
       * myComp.reset(); <br/>
       *
       * @access public
       * @instance
       * @expose
       * @return {void}
       * @memberof oj.editableValue
       * @ojshortdesc Resets the component by clearing all messages and messages attributes, and updates the component's display value using the attribute value.
       * @since 0.7.0
       */
      reset: function () {
        this._clearAllMessages();
        // since we are pushing component value to UI, only deferred validation need to be run; this is
        // same as setting value option.
        this._runDeferredValidation(this._VALIDATION_CONTEXT.RESET_METHOD);
        this._refreshComponentDisplayValue(this.options.value, true);
      },

      /**
       * Takes all deferred messages and shows them.
       * It then updates the valid property; e.g.,
       * if the valid state was "invalidHidden"
       * before showMessages(), the valid state will become "invalidShown" after showMessages().
       * <p>
       * If there were no deferred messages this method simply returns.
       * </p>
       *
       *
       * @example <caption>Display all messages including deferred ones.</caption>
       * myComp.showMessages();
       * @access public
       * @instance
       * @return {void}
       * @expose
       * @memberof oj.editableValue
       * @ojshortdesc Takes all deferred messages and shows them.
       * @since 0.7.0
       */
      showMessages: function () {
        var clonedMsgs = [];
        var i;
        var msgHidden;
        var msgsHidden = this.options.messagesHidden;
        var hasMessagesHidden = msgsHidden.length > 0;
        var clonedMsg;

        // showMessages() copies messagesHidden into clonedMsgs,
        // then clears messagesHidden, and updates messagesShown with the clonedMsgs.
        // It then updates the valid property; e.g.,
        // if the valid state was "invalidHidden"
        // before showMessages(), the valid state will become "invalidShown" after showMessages().
        for (i = 0; i < msgsHidden.length; i++) {
          msgHidden = msgsHidden[i];

          // The Message and ComponentMessage distinction is important in a few places in
          // the EV code. For example, when messagesCustom property changes, we keep existing
          // messagesShown only if they are ComponentMessage added by component.
          // if (msg instanceof ComponentMessage && msg._isMessageAddedByComponent())
          if (msgHidden instanceof Message.ComponentMessage) {
            // change ComponentMessage's display state to ComponentMessage.DISPLAY.SHOWN
            msgHidden._forceDisplayToShown();

            //
            // .clone() clones the message and the options that were passed in when the message
            // was originally created.
            clonedMsg = msgHidden.clone();
          } else {
            // NOTE: Message is a public class and ComponentMessage is private.
            // Message's .clone is deprecated, so we purposely don't call it here.
            clonedMsg = new Message(msgHidden.summary, msgHidden.detail, msgHidden.severity);
          }

          clonedMsgs.push(clonedMsg);
        }

        if (hasMessagesHidden) {
          this._clearMessages('messagesHidden');

          this._updateMessagesOption('messagesShown', clonedMsgs);

          this._setValidOption(_INVALID_SHOWN, null);
        }
      },

      // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

      // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********

      /**
       * Validation mode specifying the kind of validation that gets run.
       * <ul>
       *   <li>FULL - the default and runs both the converter and all validators. </li>
       *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
       *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
       * </ul>
       * @protected
       * @const
       * @type {Object}
       * @memberof oj.editableValue
       */
      _VALIDATION_MODE: _sValidationMode,

      /**
       * The context the component can be in when validation is run.
       * <ul>
       * <li>COMPONENT_CREATE - when component is created and we run validators. usually messages are
       * not displayed right away, i.e, are 'deferred'. </li>
       * <li>VALUE_OPTION_CHANGE - when component's value is updated programmatically. messages are
       * deferred.</li>
       * <li>REQUIRED_OPTION_CHANGE - when component's required option is updated programmatically. messages are
       * deferred.</li>
       * <li>USER_ACTION - when component runs validation as a result of user interating with component.
       * messages are displayed immediately.</li>
       * <li>VALIDATE_METHOD - when component's validate() method is called explicitly. messages are
       * displayed immediately.</li>
       * </ul>
       *
       * @protected
       * @const
       * @type {Object}
       * @memberof oj.editableValue
       *
       */
      _VALIDATION_CONTEXT: EditableValueUtils.validationContext,

      /**
       * Default options used by validate method.
       *
       * @protected
       * @const
       * @type {Object}
       * @memberof oj.editableValue
       * @see #validate
       */
      _VALIDATE_METHOD_OPTIONS: EditableValueUtils.validateMethodOptions,

      /**
       * Called at component create time primarily to initialize options, often using DOM values. This
       * method is called before _ComponentCreate is called, so components that override this method
       * should be aware that the component has not been rendered yet. The element DOM is available and
       * can be relied on to retrieve any default values. <p>
       *
       * This method sets defaults for its options that have a DOM namesake. E.g., value, required,
       * disabled etc. Subclasses can override this method to set their own defaults for these options.
       * Example, the value option is often not set on this.element for components like radioset, which
       * walk the sub-tree to determine the value.
       *
       * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors
       * @param {?Object} constructorOptions - options passed into the wiget constructor
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        this._super(originalDefaults, constructorOptions);
      },

      /**
       * Initializes options defined by this base class.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _ComponentCreate: function () {
        // remove attributes that trigger html5 validation + inline bubble
        var attrsToRemove = ['required', 'title', 'pattern'];
        var node = this.element;
        var savedAttributes = this._GetSavedAttributes(node);

        this._super();

        this.options.messagesCustom = this.options.messagesCustom || [];
        this.options.messagesHidden = [];
        this.options.messagesShown =
          this.options.messagesCustom.length > 0
            ? this._cloneMessagesBeforeSet(this.options.messagesCustom)
            : [];

        // update element DOM for disabled. TODO: say why
        this._SetDisabledDom(node);

        // remove html5 validation attributes; it's safe to remove these here because components should
        // have already initialized options based on DOM in _InitOptions().
        // Only need to do for <input> elements
        // custom elements create their input/textarea dom, so no need to do that for them.
        if (savedAttributes && !this._IsCustomElement()) {
          var tagName = node[0].tagName.toLowerCase();
          if (tagName === 'input' || tagName === 'textarea') {
            attrsToRemove.forEach(function (value) {
              if (value in savedAttributes) {
                node.removeAttr(value);
              }
            });
          }
        }
      },

      /**
       * The value option alone is initialized here since it requires the component to be fully
       * created. Calling this.options.value before this method does not guarantee the correct
       * value to be returned.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _AfterCreate: function () {
        var describedBy;
        var self = this;

        this._super();

        this._refreshTheming('disabled', this.options.disabled);
        this.widget()[0].classList.add('oj-form-control');
        if (this._IsTextFieldComponent()) {
          if (this._IsCustomElement()) {
            this._getRootElement().classList.add('oj-text-field');
          } else {
            this.widget()[0].classList.add('oj-text-field');
          }
        }
        this._toggleOjHasNoValueClass(this.options.value);
        // We need to make sure the form component has an id since oj-form-layout
        // creates the label and associates them via for/id. Adding an id from ojformlayout
        // after the component is created does not create the form component's internal id.
        this.widget().uniqueId();

        // create an ojLabel only if this isn't a custom element. For example, ojInputText will
        // create an ojLabel, but <oj-input-text> will not. Instead the app dev uses <oj-label>.
        if (!this._IsCustomElement()) {
          this._createOjLabel();
        } else if (this.options.labelledBy) {
          this._labelledByUpdated(this.options.labelledBy);
        } else {
          this._setAriaLabelFromLabelHint();
        }

        // set describedby on the element as aria-describedby
        describedBy = this.options.describedBy;
        if (describedBy) {
          this._describedByUpdated(null, describedBy);
        }

        // run deferred validation
        this._runDeferredValidation(this._VALIDATION_CONTEXT.COMPONENT_CREATE);

        // Validators can have a dependency on the converter, so don't do anything with a validator
        // until the converter is loaded. That includes don't show a validator hint.
        var converter = this._GetConverter();
        this._converterChangedCounter = 0;
        if (converter instanceof Promise) {
          this._setBusyStateAsyncConverterLoading();
          // generally, the label edge is derived during the component messaging initialization.
          // but, in this case we are delaying the messaging init.
          // this will be a problem when we deal with deriving the label edge from a form layout.
          // because converter could resolve while the form layout is reparenting the children and
          // look up of parent might not work as expected. So we should just call the label edge
          // derivation logic here. That method internally caches the derived label-edge and we should be
          // fine delaying the label creation until the component is ready.
          this._ResolveLabelEdgeStrategyType();
          this._loadingConverter(converter).then(function () {
            self._AfterCreateConverterCached();
            self._clearBusyStateAsyncConverterLoading();
          });
        } else {
          // this code gets called if you have a synchronous converter
          // or no converter at all.
          this._AfterCreateConverterCached();
          this._setValidOption(this._determineValidFromMessagesOptions(), null);
        }
      },

      /**
       * Override to release resources held by this component.
       * It is important to unregister Hammer events
       * since they live outside of the component's DOM and would cause Detached Dom nodes
       * when the component is removed.
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _ReleaseResources: function () {
        this._super();
        if (this._IsCustomElement()) {
          // componentMessaging#releaseResources removes any resources that would
          // otherwise cause a memory leak, like Hammer.
          // We do not deactivate component messaging because that is a bigger change, and
          // more risky to backport.
          this._getComponentMessaging().releaseResources();
          this._hammerIsUnregistered = true;
        }
      },
      /**
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _SetupResources: function () {
        this._super();
        // Since initComponentMessaging gets called during component creation, and that activates
        // all the component strategies which in turn sets up listeners, we only want to
        // re-set up resources and when we have
        // released them in ReleaseResources.
        if (this._IsCustomElement() && this._hammerIsUnregistered) {
          const messaging = this._getComponentMessaging();
          messaging.setupResources();
          this._hammerIsUnregistered = false;
        }
      },

      /**
       * If we have asynchronous converter loading, the input is readonly and a loading indicator
       * is shown to the user.
       * When the converter is 100% loaded, then the field is set back to how it was.
       * That is when we do the tasks that either need a converter or need the field to be enabled,
       * like showing messagesCustom. Those tasks are done in this method.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */

      /**
       * <p>Saves all the element's attributes. In _destroy all attributes will be restored.
       * </p>
       *
       * @param {Object} element - jQuery selection to save attributes for
       * @protected
       * @memberof oj.editableValue
       * @instance
       * @override
       */
      _SaveAttributes: function (element) {
        if (!this._IsCustomElement()) {
          this._SaveAllAttributes(element);
        }
      },

      /**
       * @protected
       * @memberof oj.editableValue
       * @instance
       * @override
       */
      _RestoreAttributes: function (element) {
        if (!this._IsCustomElement()) {
          this._RestoreAllAttributes(element);
        }
      },

      /**
       * Performs post processing after _SetOption() calls _superApply(). Different options, when changed, perform
       * different tasks.
       *
       * @param {string} option
       * @param {Object=} flags
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _AfterSetOption: function (option, flags) {
        switch (option) {
          case 'disabled':
            this._AfterSetOptionDisabledReadOnly(option, EditableValueUtils.disabledOptionOptions);
            break;

          case 'displayOptions':
            // clear the cached merged options; the getter setup for this.options['displayOptions']
            // will merge the new value with the defaults
            this._initComponentMessaging();
            break;

          case 'labelEdge':
            // if the labelEdge of the component changed, we need to recreate or move the label
            this._initComponentMessaging();
            this._setAriaLabelFromLabelHint();
            break;

          case 'labelHint':
            this._setAriaLabelFromLabelHint();
            this._getComponentMessaging().update(
              this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.LABEL)
            );
            break;

          case 'help':
            if (!this._IsCustomElement()) {
              // For non custom element components, help has definition and source, and if those
              // change, the component needs to be refreshed.
              this._Refresh(option, this.options[option]);
            } else {
              // For custom element components, when the help option changes, we have to assume that
              // help.instruction changed. When help.instruction changes push new value to messaging.
              this._getComponentMessaging().update(
                this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE)
              );
            }

            break;

          case 'messagesCustom':
            this._messagesCustomOptionChanged(flags);
            this._setValidOption(this._determineValidFromMessagesOptions(), null);
            break;

          case 'placeholder':
            this._SetPlaceholder(this.options.placeholder);
            this._placeholderOptionChanged(flags);
            break;

          case 'readOnly':
            if (this._retainFocusOnReadonlyChange) {
              // This setTimeout call is needed to allow the dom to update before we
              // get the focus element (or the element will still be hidden).
              setTimeout(() => {
                this.GetFocusElement().focus();
                if (this._resolveBusyStateFocusRestore) {
                  this._resolveBusyStateFocusRestore();
                  delete this._resolveBusyStateFocusRestore;
                }
              }, 0);
            }
            break;

          case 'title':
            // Ignore title attribute for custom element components.
            if (!this._IsCustomElement()) {
              // no reason to refresh component when title changes just push new value to messaging.
              this._getComponentMessaging().update(
                this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE)
              );
            }
            break;

          case 'translations':
            this.refresh();
            break;

          case 'userAssistanceDensity':
            // if the userAssistanceDensity of the component changed,
            // we need to create or remove the user assistance display strategy.
            this._initComponentMessaging();
            break;

          case 'value':
            this._AfterSetOptionValue(option, flags);
            break;

          default:
            break;
        }
      },

      /**
       * Performs post processing after disabled or readOnly option changes by taking the following
       * steps. (Steps are same for readOnly option).
       * <p>
       * if disabled component is enabled then, <br/>
       * - if there are no errors, run deferred validation. component could have been initialized with
       * empty value and disabled.<br/>
       * - if component is invalid and showing messages clear component error, grab UI value and run
       * full validation.<br/>
       * - if component is invalid and has hidden messages; do nothing. <br/>
       * </p>
       * <p>
       * if enabled component is disabled no validation is run.<br/>
       * </p>
       *
       * @param {String} option
       * @param {Object} validationOptions
       *
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _AfterSetOptionDisabledReadOnly: function (option, validationOptions) {
        var isEnabled = !(this.options[option] || false);

        // always refresh
        this._Refresh(option, this.options[option]);
        if (isEnabled) {
          this._runMixedValidationAfterSetOption(validationOptions);
        }
      },

      /**
       * Performs post processing after value option changes by taking the following steps.
       *
       * - triggers a valueChanged event and does writeback if required.<br/>
       * - if setOption was from programmatic intervention, <br/>
       * &nbsp;&nbsp;- clear custom messages and component messages; <br/>
       * &nbsp;&nbsp;- run deferred validation. if there is an error, updates messagesHidden. <br/>
       * - always refreshes UI display by formatting the value option<br/>
       *
       * @param {string} option
       * @param {Object=} flags
       *
       * @protected
       * @memberof oj.editableValue
       * @instance
       *
       */
      _AfterSetOptionValue: function (option, flags) {
        var context = flags ? flags._context : null;
        var doNotClearMessages;
        var isUIValueChange = false;

        if (context) {
          isUIValueChange = !!context.originalEvent;
          doNotClearMessages = context.doNotClearMessages || false;
        }

        if (!isUIValueChange) {
          // value option can be updated directly (i.e., programmatically or through user interaction)
          // or updated indirectly as a result of some other option changing - e.g., converter,
          // validators, required etc.
          // When value changes directly due to programatic intervention (usually page author does this)
          // then clear all messages and run deferred validation.
          // If value changes indirectly do not clear custom messages (component messages are already
          // cleared) and run deferred validation.
          if (!doNotClearMessages) {
            this._clearAllMessages(null);
          }
          this._runDeferredValidation(this._VALIDATION_CONTEXT.VALUE_OPTION_CHANGE);
        }

        // refresh UI display value
        this._Refresh(option, this.options[option], true);
      },

      /**
       * Whether the a value can be set on the component. For example, if the component is
       * disabled then setting value on component is a no-op.
       *
       * @see #_SetValue
       * @return {boolean}
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _CanSetValue: function () {
        var disabled = this.options.disabled || false;

        return !disabled;
      },

      /**
       * Override to do the delay connect/disconnect
       * This should improve performance when a lot of editable value components are in an
       * oj-form-layout component, which does a lot of reparenting of elements which would
       * trigger multiple (and unneeded) _ReleaseResources/_SetupResources calls.
       * @memberof oj.editableValue
       * @override
       * @protected
       */
      _VerifyConnectedForSetup: function () {
        return true;
      },

      /**
       * Detaches the widget from the element and restores element exactly like it was before the widget
       * was attached.
       * @protected
       * @expose
       * @memberof oj.editableValue
       * @instance
       *
       */
      _destroy: function () {
        var labelIndex;
        var labelLength;
        var ret = this._super();

        this._clearAllMessages(null, true);
        this.widget().removeUniqueId();
        if (this._getComponentMessaging()._isActive()) {
          this._getComponentMessaging().deactivate();
        }

        // make sure the label is still "alive". Otherwise we could get error when we try to
        // destroy it if the dom was removed first and ojLabel was destroyed directly.
        // also make sure to check if there is more than one label and destroy them individually.
        if (this.$label) {
          labelLength = this.$label.length;
          for (labelIndex = 0; labelIndex < labelLength; labelIndex++) {
            if (
              this.$label[labelIndex] &&
              Components.__GetWidgetConstructor(this.$label[labelIndex]) != null
            ) {
              $(this.$label[labelIndex]).ojLabel('destroy');
            }
          }
        }

        return ret;
      },

      /**
       * JET-48463 - If we are in readonly mode, we call _GetReadonlyFocusElement, and fall back to
       * _GetContentElement()[0] if _GetReadonlyFocusElement happens to return null.
       * If not readonly, we just return _GetContentElement()[0]
       * @memberof oj.editableValue
       * @instance
       * @override
       * @protected
       * @since 5.0.0
       */
      GetFocusElement: function () {
        return this.options.readOnly === true
          ? this._GetReadonlyFocusElement() || this._GetContentElement()[0]
          : this._GetContentElement()[0];
      },

      /**
       * Returns the readonly focus element if there is a readonly specific element, otherwise null
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {Element|null}
       */
      _GetReadonlyFocusElement: function () {
        return this._getReadonlyDiv();
      },

      /**
       * Called (by the widget factory) when the option changes, this method responds to the change
       * by refreshing the component if needed. This method is not called for the options passed in
       * during the creation of the widget.
       *
       * @param {string} name of the option
       * @param {Object|string} value
       * @param {Object?} flags - optional flags. The following flags are currently supported:
       * <ul>
       *  <li>changed - true if the caller wants to indicate the value has changed, so no comparison is necessary</li>
       * </ul>
       *
       * @expose
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _setOption: function (name, value, flags) {
        var retVal;
        var skipSetOption = false;
        var oldValue;
        var newValue;

        switch (name) {
          case 'messagesHidden':
            // this option can never be set programmatically by page author
            skipSetOption = true;
            break;

          case 'messagesShown':
            // this option can never be set programmatically by page author
            skipSetOption = true;
            break;

          case 'rawValue':
            // rawValue is readOnly, so throw an error here.
            skipSetOption = true;
            break;

          case 'describedBy':
            // This sets the aria-describedby on the correct dom node
            oldValue = this.options.describedBy;
            newValue = value;
            this._describedByUpdated(oldValue, newValue);
            break;
          case 'labelledBy':
            if (value) {
              this._labelledByUpdated(value);
            }
            break;
          case 'readOnly':
            this._retainFocusOnReadonlyChange = FocusUtils.containsFocus(this.widget()[0]);
            if (this._retainFocusOnReadonlyChange) {
              if (!this._resolveBusyStateFocusRestore) {
                var domElem = this.element[0];
                var busyContext = Context.getContext(domElem).getBusyContext();
                var description = 'Waiting for focus on the component ';

                if (domElem && domElem.id) {
                  description += `with id="${domElem.id}" `;
                }
                description += 'to be restored.';
                this._resolveBusyStateFocusRestore = busyContext.addBusyState({
                  description: description
                });
              }
            }
            this._addRemoveOjReadOnlyClassOnLabel(
              document.getElementById(this.options.labelledBy),
              value
            );
            break;
          case 'displayOptions':
            // since the displayOptions defaults are theme-dependent
            // (except for displayOptions.helpInstruction), we
            // need to set the defaults ourselves when displayOptions
            // or any of its subproperties is set to undefined.
            // For displayOptions we never want to blow away any of the sub-properties,
            // so for the case where the app dev doesn't set all the sub-properties, we
            // default the others. e.g., formComponent.displayOptions = {messages:'none'}
            // Also, in Redwood theme, we use 'display' and 'none'. Anything that isn't 'none'
            // works the same as 'display'.
            // In Alta, it must be one of the accepted options that Alta supports.
            // Setting to null doesn't reset.
            var displayOptions = value;
            var resetNeeded =
              value !== null &&
              (value.validatorHint === undefined ||
                value.converterHint === undefined ||
                value.messages === undefined);
            if (resetNeeded) {
              // this will change any of the sub-properties not set back to the defaults,
              // and when super is called at the end of the method, the displayOptions option will
              // be set with defaults if necessary.
              let useUserAssistanceDensity =
                (ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults') || {})
                  .useUserAssistanceOptionDefault === 'use';
              const displayOptionsDefaults = useUserAssistanceDensity
                ? _sDisplayOptionsRedwoodDefaults
                : _sDisplayOptionsAltaDefaults;
              if (value.validatorHint === undefined) {
                displayOptions.validatorHint = displayOptionsDefaults.VALIDATOR_HINT;
              }
              if (value.converterHint === undefined) {
                displayOptions.converterHint = displayOptionsDefaults.CONVERTER_HINT;
              }
              if (value.messages === undefined) {
                displayOptions.messages = displayOptionsDefaults.MESSAGES;
              }
            }

            break;
          default:
            break;
        }

        if (skipSetOption) {
          Logger.error(name + ' option cannot be set');
          return this;
        }

        // Step 2: Update option value
        retVal = this._superApply(arguments);

        // Step 3: Do post processing like triggering events, refreshing component DOM etc.
        this._AfterSetOption(name, flags);

        return retVal;
      },

      // *********** END WIDGET FACTORY METHODS **********

      /**
       * Returns a jquery object of the element(s) representing the content node. This could be a jQuery
       * object of the element the widget was invoked on - typically this is an input or select or
       * textarea element for which a value can be set. It could be more than one dom node.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {jQuery} the jquery element that represents the editable content. E.g., an input
       */
      _GetContentElement: function () {
        return this.element;
      },

      /**
       * Returns a jquery object of the element(s) representing the label node(s) for the input
       * component.
       * First we look for the aria-labelledby attribute on the input.
       * If that's not found, we look for the label with 'for' attribute
       * pointing to input.
       * If that's not found, we walk up the dom looking for aria-labelledby.
       * Note: multiple labels for one input is legal in html-5.
       * This is called for widget components, not custom components.
       * We check as well inside this function and return if a custom component.
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {Object} the jquery element that represents the input component's label.
       *  return null if it can't find anything.
       */
      _GetLabelElement: function () {
        if (this._IsCustomElement()) {
          return null;
        }
        var ariaElement;
        var labelQuery;

        if (this.$label) {
          return this.$label;
        }

        if (EditableValueUtils.hasNoLabelFlag(this.widget())) {
          return null;
        }

        // If input has aria-labelledby set, then look for label it is referring to.
        var queryResult = this._getAriaLabelledByElement(this.element);
        if (queryResult !== null && queryResult.length !== 0) {
          return queryResult;
        }

        // if no aria-labelledby is on the input, then look for a label with 'for'
        // set.
        var id = this.element[0].id;
        if (id !== undefined) {
          labelQuery = "label[for='" + id + "']";
          queryResult = $(labelQuery);
          if (queryResult.length !== 0) {
            return queryResult;
          }
        }

        // if no aria-labelledby on input and no label with 'for' pointing to input,
        // then as a final step we walk up the dom to see if aria-labelledby is set.
        // If so, then we find the label it is referring to.
        // This would be the case when you have multiple inputs grouped in a div
        // <label id="grouplabel">Address</label>
        // <div aria-labelledby="grouplabel"><input/><input/><input/></div>
        ariaElement = this.element.closest('[aria-labelledby]');
        if (ariaElement.length !== 0) {
          // Element has aria-labelledby set, so look for label it is referring to.
          queryResult = this._getAriaLabelledByElement(ariaElement);
          if (queryResult !== null && queryResult.length !== 0) {
            return queryResult;
          }
        }
        return null;
      },

      /**
       * Returns the element's value. Normally, this is a call to this.element.val(), but for some
       * components, it could be something else. E.g., for ojRadioset the element's value is really the
       * value of the selected radio in the set.
       *
       * @override
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetElementValue: function () {
        return this.element.val();
      },

      /**
       * Returns a jquery object of the element that triggers messaging behavior. The trigger element
       * is usually an input or select or textarea element for which a value can be set/retrieved and
       * validated.
       *
       * @return {jQuery} jquery object
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetMessagingLauncherElement: function () {
        return this._GetContentElement();
      },
      /**
       * Returns the dom element that should be used for positioning popup messages.
       *
       * @return {HTMLElement}
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetMessagingPositionElement: function () {
        let formCtrl = this._GetFormControlContainer();
        // if this component has a text field container, return that element
        if (formCtrl) {
          return formCtrl;
        }
        // otherwise, return the content element.
        return this._GetMessagingLauncherElement()[0];
      },

      /**
       * Returns the normalized converter instance. Since EditableValue does not have a converter
       * option, this returns null.
       *
       * @return {Object} null
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetConverter: function () {
        return null;
      },

      /**
       * Returns an array of implicit validators setup by component. This list contains validators for
       * the internal use of the component and are not a part of this.options.validators. <br/>
       * E.g., if the pattern attribute or option is set, a RegExpValidator instance is automatically
       * created and added to this list. <br/>
       * RequiredValidator is tracked separately from the default validators.
       *
       * @return {Object} a map of string name to the validator instance.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetImplicitValidators: function () {
        if (!this._implicitSyncValidators) {
          this._implicitSyncValidators = {};
        }

        return this._implicitSyncValidators;
      },

      /**
       * Returns the display value that is ready to be passed to the converter.
       *
       * @param {Object} value the stored value if available that needs to be formatted for display
       * @return {string} usually a string display value
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      _GetDisplayValue: function (value) {
        return this._GetContentElement().val();
      },

      /**
       * For components that have the 'validators' option,
       * this returns an array of all validators
       * normalized from the validators option set on the component. <br/>
       * Since EditableValue does not include the 'validators' option, this returns [].
       *
       * @return {Array} of validators.
       * Since EditableValue does not include the 'validators' option, this returns [].
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetNormalizedValidatorsFromOption: function () {
        return [];
      },
      /**
       * For components that have the 'async-validators' attribute,
       * this returns an array of all validators
       * normalized from the async-validators property set on the component. <br/>
       * Since EditableValue does not include the 'validators' option, this returns [].
       *
       * @return {Array} of validators.
       * Since EditableValue does not include the 'validators' option, this returns [].
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetNormalizedAsyncValidatorsFromOption: function () {
        return [];
      },

      /**
       * Returns an array of all validators built by merging the validators
       * option set on the component and the implicit validators
       * setup by the component. As of v8.0, these can be async or sync.<br/>
       * This does not include the implicit required validator.
       * Components can override to add to this
       * array of validators.
       *
       * @return {Array} of validators
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetAllValidatorsFromValidatorsOptionAndImplicit: function () {
        var allValidators = [];
        var idx;
        var implicitValidatorMap;
        var implicitValidators;
        var normalizedValidators;
        // this flag helps us only get or create the validators once, not every time
        // we want to get a hint or validate.
        if (!this._allValidators) {
          implicitValidatorMap = this._GetImplicitValidators();
          implicitValidators = [];

          // combine public and implicit validators to get the combined list
          var keys = Object.keys(implicitValidatorMap);
          var valType;
          var len = keys.length;
          if (len > 0) {
            for (idx = 0; idx < len; idx++) {
              valType = keys[idx];
              implicitValidators.push(implicitValidatorMap[valType]);
            }
            allValidators = allValidators.concat(implicitValidators);
          }

          normalizedValidators = this._GetNormalizedValidatorsFromOption();
          if (normalizedValidators.length > 0) {
            // Add normalize validators
            normalizedValidators.forEach(function (normalizedValidator) {
              allValidators.push(normalizedValidator);
            });
          }
          this._allValidators = allValidators;
        }
        return this._allValidators;
      },

      /**
       * This method also updates the messaging strategies as hints associated with validators could
       * have changed.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _ResetAllValidators: function () {
        if (this._allValidators) {
          this._allValidators.length = 0;
        }
        this._allValidators = null;

        if (this._IsCustomElement()) {
          // This gets sync and async validator hints.
          // nothing should be waiting on this, so no need to return a Promise.
          this._updateValidatorMessagingHint();
        } else {
          // update messagingstrategy as hints associated with validators could have changed
          this._getComponentMessaging().update(this._getValidatorHintsMC());
        }
      },

      /**
       * Return the element on which aria-label can be found.
       * Usually this is the root element, but some components have aria-label as a transfer attribute,
       * and aria-label set on the root element is transferred to the inner element.
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _GetAriaLabelElement: function () {
        return this._getRootElement();
      },

      /**
       * Sets or removes oj-read-only class on element based on readonly value.
       *
       *
       * @param {HTMLElement|undefined} element
       * @param {boolean|undefined} readonly Could be undefined in component does not have readonly
       * option at all.
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _addRemoveOjReadOnlyClassOnLabel: function (element, readonly) {
        if (element && readonly !== undefined) {
          const readonlystyleclass = 'oj-read-only';
          if (readonly) {
            element.classList.add(readonlystyleclass);
          } else {
            element.classList.remove(readonlystyleclass);
          }
        }
      },

      /**
       * This is used to set the aria label from the label hint, and also
       * updates the readonly div from aria-label if specified.
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _setAriaLabelFromLabelHint: function () {
        if (this._IsCustomElement()) {
          var ariaLabelElem = this._GetAriaLabelElement();
          var ariaLabel = ariaLabelElem.getAttribute('aria-label');
          let readonlyDiv = this._getReadonlyDiv();

          if (
            !this.options.labelledBy &&
            this.options.labelHint &&
            this.options.labelEdge === 'none' &&
            (!ariaLabel || ariaLabel === this._ariaLabelFromHint) &&
            !this._getRootElement().getAttribute('aria-labelledby')
          ) {
            // Set aria-label if all of the followings are true:
            // 1. This is a custom element.
            // 2. There is no labelledBy option.
            // 3. There is a labelHint option.
            // 4. labelEdge option is set to 'none' (this will only be set by app)
            // 5. There is no aria-label attribute or the aria-label was set by us.
            // 6. There is no aria-labelledby attribute.
            ariaLabelElem.setAttribute('aria-label', this.options.labelHint);
            // Set on the readonly div if it exists as well.
            if (readonlyDiv) {
              readonlyDiv.setAttribute('aria-label', this.options.labelHint);
            }

            // Remember what we set aria-label to
            this._ariaLabelFromHint = this.options.labelHint;
          } else if (this._ariaLabelFromHint && this._ariaLabelFromHint === ariaLabel) {
            // If we have set aria-label previously and no one has changed it, remove it
            // if the current condition no longer need to set aria-label.
            ariaLabelElem.removeAttribute('aria-label');
            // remove from the readonly div as well.
            if (readonlyDiv) {
              readonlyDiv.removeAttribute('aria-label');
            }
          } else if (ariaLabel) {
            // The app dev specified 'aria-label' explicitly.
            if (readonlyDiv) {
              readonlyDiv.setAttribute('aria-label', ariaLabel);
            }
          } else if (readonlyDiv) {
            // No ariaLabel, so remove it from the readonly div
            readonlyDiv.removeAttribute('aria-label');
          }
        }
      },

      /**
       * Returns an array of all validators with a hint property. We
       * look on the attributes validators and async-validators as well
       * as in the implicit validators.
       * Having a 'hint' property means they are async validators since
       * the AsyncValidator interface has  an optional 'hint' property
       * whereas the Validator interface has an optional getHint function.
       *
       * @return {Array} of async validators that have hints, [] if none
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _getAllAsyncValidatorsWithHint: function () {
        var allAsyncValidators = this._GetNormalizedAsyncValidatorsFromOption();
        var allAsyncValidatorsWithHints = [];
        var i;
        var validator;

        if (this._IsRequired()) {
          // get the hint for the default required validator and push into array
          validator = this._getImplicitRequiredValidator();
          if ('hint' in validator) {
            allAsyncValidatorsWithHints.push(validator);
          }
        }

        if (allAsyncValidators.length > 0) {
          for (i = 0; i < allAsyncValidators.length; i++) {
            validator = allAsyncValidators[i];
            if ('hint' in validator) {
              allAsyncValidatorsWithHints.push(validator);
            }
          }
        }
        // gets implicit validators and all validators from the validators option.
        var allValidators = this._GetAllValidatorsFromValidatorsOptionAndImplicit();
        if (allValidators.length > 0) {
          for (i = 0; i < allValidators.length; i++) {
            validator = allValidators[i];
            if ('hint' in validator) {
              allAsyncValidatorsWithHints.push(validator);
            }
          }
        }

        return allAsyncValidatorsWithHints;
      },

      /**
       * Initialize async validator messaging hints, if any.
       * This is called from the ComponentMessaging, not during component
       * initialization.
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _initAsyncValidatorMessagingHint: function () {
        var allAsyncValidatorsWithHint = this._getAllAsyncValidatorsWithHint();
        var currentCounter;
        var syncValidatorHintMC;
        var self = this;

        this._asyncValidatorHintCounter = 0;

        if (allAsyncValidatorsWithHint.length > 0) {
          // get the sync validators hints  we are already showing so we can show it with
          // the async validators hints
          syncValidatorHintMC = this._getValidatorHintsMC();
          // we use a counter to keep track of the busycontext
          // if we get a more recent update async validators hint requests
          // i.e., asyncValidators property is changed, and we want to ignore any previous
          // hints Promise results. See _updateValidatorMessagingHint.
          currentCounter = this._asyncValidatorHintCounter;
          this._setBusyStateAsyncValidatorHint(currentCounter);
          // get the async validators hints and show them as well as they resolve
          this._addAsyncValidatorsHintsMessagingContent(
            allAsyncValidatorsWithHint,
            syncValidatorHintMC
          ).then(function () {
            self._clearBusyStateAsyncValidatorHint(currentCounter);
          });
        }
      },

      /*
      Called from ComponentMessaging as well.
      * @memberof oj.editableValue
      * @instance
      * @private
      */
      _getValidatorHintsMC: function () {
        return this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS);
      },

      /**
       * This gets all asyncValidators that have hints,
       * asynchronously updates the component messaging validator hints with BOTH
       * synchronous and async validators' hints.
       * If there are no asyncValidators with hints, it updates validator hints with sync hints.
       * This is called when asyncValidators property changes or when validators property changes.
       * See #_ResetAllValidators. Not called now from ResetAllValidators.
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _updateValidatorMessagingHint: function () {
        var allAsyncValidatorsWithHint = this._getAllAsyncValidatorsWithHint();
        var compMessagings = this._getComponentMessaging();
        var currentCounter;
        var self = this;

        // this gets all validators with getHint (these are sync validators)
        var syncValidatorHintMC = this._getValidatorHintsMC();

        if (allAsyncValidatorsWithHint.length > 0) {
          // we use a counter to keep track of the busycontext
          // if we get a more recent update async validators hint requests
          // i.e., asyncValidators property is changed.
          this._asyncValidatorHintCounter += 1;
          currentCounter = this._asyncValidatorHintCounter;
          this._setBusyStateAsyncValidatorHint(currentCounter);
          this._addAsyncValidatorsHintsMessagingContent(
            allAsyncValidatorsWithHint,
            syncValidatorHintMC
          ).then(function () {
            self._clearBusyStateAsyncValidatorHint(currentCounter);
          });
        } else {
          // if this is [], this causes the notewindow to close if it was open.
          // and we don't want to close/reopen if possible, so don't do this before
          // updating async validator hints. Do it in updating async validator hints.
          compMessagings.update(syncValidatorHintMC);
        }
      },

      /**
       * This is called when we have async validators and we want to add
       * their hints, if any, to the componentMessaging. It also adds
       * the sync validator hints as well.
       * This function will also return a Promise that will resolve when we have updated
       * the componentMessaging with all the hints, async and sync.
       *
       * @param {Array} asyncValidatorsWithHints
       *  Array of asyncValidators that are in the async-validators attribute and have hints
       * @param {string} syncValidatorHintMC
       *  hint messaging content from sync validators.
       * @return {Promise} Promise that when resolves will have the hints
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _addAsyncValidatorsHintsMessagingContent: function (
        asyncValidatorsWithHint,
        syncValidatorHintMC
      ) {
        var i;
        // use counter to ignore if we get a more recent update async validators hint requests
        // i.e., asyncValidators property is changed.
        var asyncValidatorHintCounter = this._asyncValidatorHintCounter;
        var compMessagings = this._getComponentMessaging();
        var hintArray = [];
        var self = this;

        // We kick off all the async validators.hint simultaneously. When they all resolve/reject,
        // then we can move on.
        var promiseArray = [];
        for (i = 0; i < asyncValidatorsWithHint.length; i++) {
          promiseArray.push(asyncValidatorsWithHint[i].hint);
        }

        function reflect(promise) {
          return promise.then(
            function (v) {
              var status;

              var validatorHintMessagingContent = {};

              // update hint as we get it
              // use counter to ignore if we get a more recent update async validators hint requests
              // i.e., asyncValidators property is changed.
              if (self._asyncValidatorHintCounter === asyncValidatorHintCounter) {
                if (v !== null) {
                  hintArray.push(v);
                  validatorHintMessagingContent.validatorHint =
                    syncValidatorHintMC.validatorHint.concat(hintArray);
                  compMessagings.update(validatorHintMessagingContent);
                }
                status = 'resolved';
              } else {
                status = 'ignore';
              }
              return { v: v, status: status };
            },
            function (e) {
              // we don't update the hintArray when the hint Promise rejects.
              // No need to check the counter in this case because there is nothing
              // to 'ignore'.
              return { e: e, status: 'rejected' };
            }
          );
        }
        return new Promise(function (resolve) {
          // Promise.all will end as soon as it gets its first rejection. We don't want that.
          // We want to wait until all promises either resolve or reject. Then we can resolve this
          // outer promise. We do this using the reflect function defined above.
          Promise.all(promiseArray.map(reflect)).then(function () {
            resolve(hintArray);
          });
        });
      },

      /**
       * Whether the component is required. EditableValue doesn't support the required option,
       * so return false.  This allows us to keep some of the required code in EditableValue.
       *
       * @return {boolean} true if required; false
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _IsRequired: function () {
        return false;
      },

      /**
       * Convenience handler for the DOM 'change' event. Subclasses are expected to wire up event
       * handlers for DOM events that they wish to handle.<br/>
       *
       * The implementation retrieves the display value for the component by calling _GetDisplayValue()
       * and calls _SetValue(), with full validation.
       *
       * @param {Event} event DOM event
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _HandleChangeEvent: function (event) {
        var submittedValue = this._GetDisplayValue();
        // run full validation
        this._SetValue(submittedValue, event);
      },
      /**
       * Convenience function to set the rawValue option. Called by subclasses
       *
       * @param {String} val value to set rawValue to
       * @param {Event} event DOM event
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _SetRawValue: function (val, event) {
        var flags = {};
        flags._context = { originalEvent: event, writeback: true, internalSet: true, readOnly: true };

        if (!this._CompareOptionValues('rawValue', this.options.rawValue, val)) {
          this.option('rawValue', val, flags);
        }
      },

      /**
       * This method takes a value from a value change listener
       * and determines if it is 'empty'. This is used to toggle a
       * 'oj-has-no-value' style class.
       * This method is generic enough to be used by all EditableValue components,
       * but can be overridden by component if needed.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _IsValueEmpty: function (value) {
        if (value === undefined || value === null) {
          return true;
        } else if (typeof value === 'string') {
          return oj.StringUtils.isEmptyOrUndefined(value);
        } else if (typeof value === 'number') {
          return isNaN(value);
        } else if (Array.isArray(value)) {
          // oj-select-many setting observable(undefined) returns an array with
          // an undefined value versus an undefined value
          return (
            value.length === 0 ||
            (value.length === 1 && (value[0] === null || value[0] === undefined))
          );
        }
        return false;
      },
      /**
       * This method toggles a 'oj-has-no-value' style class as needed.
       * The styleclass is used to position the inside label.
       * This method also updates component messaging (specifically InlineRequiredStrategy),
       * because the Required dom is created when the component is required and
       * there is no value displayed to the user and the Required dom is removed
       * when there is a value, as per the Redwood UX spec.
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _toggleOjHasNoValueClass: function (value) {
        let element = this._getRootElement();
        const ojHasNoValueClass = 'oj-has-no-value';
        const hasOjHasNoValueClass = element.classList.contains(ojHasNoValueClass);
        const isValueEmpty = this._IsValueEmpty(value);
        const addClass = isValueEmpty && !hasOjHasNoValueClass;
        const removeClass = !isValueEmpty && hasOjHasNoValueClass;

        if (addClass) {
          element.classList.add(ojHasNoValueClass);
        } else if (removeClass) {
          element.classList.remove(ojHasNoValueClass);
        }
        // only bother to do this if required option is true and the class was added or removed,
        // since this is only used in the InlineRequiredStrategy right now.
        if (this.options.required && (addClass || removeClass)) {
          this._getComponentMessaging().update({ hasNoValueToggled: true });
        }
      },

      /**
       * Called in response to a change in the options set for this component, this method refreshes the
       * component display value. Subclasses can override to provide custom refresh behavior.
       *
       * @param {String=} name the name of the option that was changed
       * @param {Object=} value the current value of the option
       * @param {boolean=} forceDisplayValueRefresh
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _Refresh: function (name, value, forceDisplayValueRefresh) {
        var helpDef;
        var helpSource;

        switch (name) {
          case 'converter':
            var _value = this.options.value;
            this._refreshComponentDisplayValue(_value, forceDisplayValueRefresh);
            break;

          case 'disabled':
            this._refreshTheming('disabled', this.options.disabled);
            break;

          case 'help':
            if (!this._IsCustomElement()) {
              // refresh the help - need to keep the label in sync with the input.
              if (this.$label) {
                helpDef = this.options.help.definition;
                helpSource = this.options.help.source;
                this.$label.ojLabel('option', 'help', { definition: helpDef, source: helpSource });
                var label = this.$label[0];
                if (label) {
                  let labelId = label.id;
                  if (labelId) {
                    let ariaId = labelId + _HELP_ICON_ID;
                    if (helpSource != null || helpDef != null) {
                      this._describedByUpdated(null, ariaId);
                    } else {
                      this._describedByUpdated(ariaId, null);
                    }
                  }
                }
              }
            }
            break;

          case 'value':
            this._refreshComponentDisplayValue(value, forceDisplayValueRefresh);
            break;

          default:
            break;
        }
      },

      /**
       * <p>Notifies the component that its subtree has been made hidden programmatically
       * after the component has been created.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _NotifyHidden: function () {
        this._superApply(arguments);
        this._getComponentMessaging().close();
      },
      /**
       * <p>Notifies the component that its subtree has been removed from the
       * document programmatically after the component has
       * been created.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _NotifyDetached: function () {
        this._superApply(arguments);
        this._getComponentMessaging().close();
      },
      /**
       * Called anytime the label DOM changes requiring a reset of any dependent feature that caches the
       * label, including all validators.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _ResetComponentState: function () {
        // the DOM for the label and its text could have changed.
        if (this.$label) {
          this.$label.ojLabel('refresh');
        }

        // reset all validators when label changes
        this._implicitReqValidator = null;
        this._converter = null;
        this._ResetAllValidators();
      },

      /**
       * Called when the display value on the element needs to be updated. This method updates the
       * (content) element value. Widgets can override this method to update the element appropriately.
       *
       * @param {String} displayValue of the new string to be displayed
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _SetDisplayValue: function (displayValue) {
        var contentElem = this._GetContentElement();
        if (contentElem.val() !== displayValue) {
          contentElem.val(displayValue);
        }
      },
      /**
       * Sets the disabled option onto the dom.
       * Component subclasses can override this method to not do this in cases where it is invalid,
       * like on a div (e.g., radioset's root dom element is a div).
       * @param {Object} node - dom node
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @since 1.0.0
       */
      _SetDisabledDom: function (node) {
        if (typeof this.options.disabled === 'boolean') {
          node[0].disabled = this.options.disabled; // eslint-disable-line no-param-reassign
        }
      },

      /**
       * Sets the placeholder text on the content element by default. It sets the placeholder attribute
       * on the element. Component subclasses can override this method to control where placeholder text
       * gets set.
       * @param {string} value
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _SetPlaceholder: function (value) {
        var contentElem = this._GetContentElement()[0];
        if (contentElem) {
          if (value == null) {
            contentElem.removeAttribute('placeholder');
          } else {
            contentElem.setAttribute('placeholder', value);
          }
        }
      },

      /**
       * Sets the placeholder option with the value.
       *
       * @param {string} value
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _SetPlaceholderOption: function (value) {
        this.options.placeholder = value;
      },

      /**
       * whether the placeholder option is set
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _HasPlaceholderSet: function () {
        //  - an empty placeholder shows up if data changed after first binding
        return this.options.placeholder;
      },

      /**
       * Clear the placeholder option
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _ClearPlaceholder: function () {
        //  - an empty placeholder shows up if data changed after first binding
        this._SetPlaceholderOption('');
        this._SetPlaceholder('');
      },
      /**
       * Runs full validation on the newValue (usually the display value) and sets the parsed value on
       * the component if value passes basic checks and there are no validation errors. <br/>
       * If the newValue is undefined or if it is the same as the last saved displayValue this method
       * skips validation and does not set value (same as ADF). It also updates messages shown
       * if there are errors, and it updates the 'valid' property on the component.<br/>
       * This method returns a Promise if there are async validators
       *  on the component (introduced in v5.2 for custom elements), so if you call this method,
       * and you do work after this method returns that cares about
       * what the value option is, if there are error messages showing, or what the 'valid' state is,
       * then you need to see if the return value is an instanceof Promise,
       * and if so, then you need to wait until it resolves before moving on.
       *
       * @param {string|Object} newValue the ui value that needs to be parsed before it's set.
       * @param {Object=} event an optional event if this was a result of ui interaction. For user
       * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
       * causes a 'blur' event.
       * @param {Object=} options - an Object literal that callers pass in to determine how validation
       * gets run.
       * @param {boolean=} options.doValueChangeCheck - if set to true compare newValue with last
       * displayValue before running validation; if false, always run validation. E.g., set to false
       * when validate() is called.
       * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This
       * is provided for callers that may want to clear only some of the messages. E.g., when required
       * option changes, it clears only component messages, not custom.
       * @param {Array<string>=} options.targetOptions - if specified, only the options specified in
       * this array will be set. If not specified, the "value" option will be set.
       * @param {number=} options.validationMode - accepted values (defined in _VALIDATION_MODE) are:
       * <ul>
       *   <li>FULL - the default and runs both the converter and all validators. </li>
       *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
       *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
       * </ul>
       * @return {Promise|boolean} Promise that resolves to false
       * if value was not set due to validation error,
       * else true, or for widget code or components that do not have async validators or
       * converters, boolean false if value was not set, true otherwise.
       * @example  <caption>Widget subclasses can use this convention to run full validation</caption>
       * this._SetValue(value, event);
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       *
       */
      _SetValue: function (newValue, event, options) {
        var clearBusyStateKey;
        var doValueChangeCheck =
          options && typeof options.doValueChangeCheck === 'boolean'
            ? options.doValueChangeCheck
            : true;
        var self = this;
        var resolvedState = false;
        var validateReturn;
        var fulfilledNewValue;

        // we want to add/remove the oj-has-no-value styleclass so we can style based on
        // if there is something in the field.
        // this is where we validate what the user has typed in, so it is a good place
        // to check this styleclass.
        this._toggleOjHasNoValueClass(newValue);

        // disallow setting a value of undefined by widgets
        if (newValue === undefined) {
          Logger.warn('Attempt to set a value of undefined');
          return false;
        }

        if (!doValueChangeCheck || newValue !== self._getLastDisplayValue()) {
          // AsyncValidate returns a promise if the component has async validators
          // that will be resolved to the successfully parsed value
          // if successful or undefined if not successful or was ignored because a newer _AsyncValidate
          // came in.
          // for non-async, it returns the parsed value or undefined if validation failed or
          // was ignored.
          clearBusyStateKey = '' + newValue + '_' + (this._asyncValidatorValidateCounter + 1);
          validateReturn = this._AsyncValidate(newValue, event, options, clearBusyStateKey);

          if (!(validateReturn instanceof Promise)) {
            // Synchronous validation only.
            this._afterAsyncValidateUpdateValue(validateReturn, event, options);
            resolvedState = validateReturn !== undefined;
          } else {
            resolvedState = validateReturn
              .then(function (fnv) {
                fulfilledNewValue = fnv;
                return self._afterAsyncValidateUpdateValue(fnv, event, options);
              })
              .then(function () {
                self._clearBusyState(clearBusyStateKey);
                return fulfilledNewValue !== undefined;
              });
          }
        }
        return resolvedState;
      },

      /**
       * Parses the value and shows an error, if any.
       * </p>
       *
       * @param {string|Object} newValue the value to parse. Usually this is the string display value
       * @param {Object=} event an optional event if this was a result of ui interaction. For user
       * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
       * causes a 'blur' event.
       *
       * @return {Object|string|undefined} the parsed value or undefined if parse failed.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _ParseValueShowErrors: function (newValue, event) {
        var newMsgs;
        var parsedValueReturn;
        var self = this;

        this._clearAllMessages(event);
        try {
          // Step1: Parse value using converter.

          parsedValueReturn = this._parseValue(newValue, event);
          // It's the successfully parsed value from
          // a synchronous converter.
          return parsedValueReturn;
        } catch (ve) {
          // _parseValue failed
          // turn this into Array of ComponentMessage instances.
          // This is what we set on 'messagesShown'
          newMsgs = self._processValidationErrors(ve);
          self._updateMessagesOption('messagesShown', newMsgs, event);
          self._setValidOption(_INVALID_SHOWN, event);
        }
        return undefined;
      },

      /**
       * Runs full validation on the value. If value fails basic checks
       * (see <a href="#_CanSetValue">_CanSetValue</a>, or if value failed validation, this method
       * returns undefined. Otherwise it returns the successfully parsed value. If validation
       * is async, this returns a Promise that resolves to the successfully parsed and
       * validated value, or undefined if unsuccessful or ignored. As soon as we know that something
       * has failed, we set valid to INVALID_SHOWN, when all pass we set valid to VALID.
       * <p>
       * Components should call this method if they know UI value has changed and want to set the
       * new component value.
       * </p>
       * <p>
       * This method works with any combination of synchronous and asynchronous validators.
       * <p>
       *
       * @param {string|Object} newValue the actual value to be set. Usually this is the string display value
       * @param {Object=} event an optional event if this was a result of ui interaction. For user
       * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
       * causes a 'blur' event.
       * @param {{doNotClearMessages:boolean,validationContext:number,validationMode:number}=} options
       * an Object literal that callers pass in to determine how validation gets run.
       * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This
       * is provided for callers that may want to clear only some of the messages. E.g., when required
       * option changes, it clears only component messages, not custom.
       * @param {number=} options.validationContext - the context this method was called. When not set it
       * defaults to _VALIDATION_CONTEXT.USER_ACTION.
       * @param {number=} options.validationMode - accepted values defined in _VALIDATION_MODE
       * @param {string=} busyStateKey key used to set the busy context. The calling function will
       * clear it.
       *
       * @return {Promise.<Object|string|undefined>|Object|string|undefined}
       * A promise if the component has async validators
       * that will be resolved to the successfully parsed value
       * if successful or undefined if not successful or to be ignored due to a newer validation
       * request coming in.
       * the parsed value or undefined if validation failed.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _AsyncValidate: function (newValue, event, options, busyStateKey) {
        var mode =
          options && options.validationMode ? options.validationMode : this._VALIDATION_MODE.FULL;
        var context =
          options && options.validationContext
            ? options.validationContext
            : this._VALIDATION_CONTEXT.USER_ACTION;
        var doNotClearMessages = (options && options.doNotClearMessages) || false;
        var newMsgs;
        var successfullyParsedValue;
        var self = this;
        var validateReturn;

        // disallow setting a value of undefined by widgets
        if (newValue === undefined) {
          Logger.warn('Attempt to set a value of undefined');
          return undefined;
        } else if (this._CanSetValue()) {
          if (!doNotClearMessages) {
            this._clearAllMessages(event);
          }
          // Stores the newValue we are validating. This is consulted to decide whether or
          // not we skip _SetValue
          // if newValue !== self._getLastDisplayValue()
          try {
            // update the validate counter here, before we call _asyncValidateValue,
            // because we refer to it there to know if we need to ignore a validation result if a new
            // async one came in after.
            this._asyncValidatorValidateCounter += 1;

            // Step 1: only when "full" validation is requested converters get run
            if (mode === self._VALIDATION_MODE.FULL) {
              this._setLastDisplayValue(newValue);
              // Step1: Parse value using converter. set valid state to pending in here.
              successfullyParsedValue = this._parseValue(newValue, event, true);
            } else {
              successfullyParsedValue = newValue;
            }

            // Step 2: Parse didn't throw an error.
            // Run validators and set valid state
            // asyncValidateValue will return a Promise if the component has async validators,
            // otherwise it returns the value if successful or undefined if not.
            validateReturn = self._asyncValidateValue(successfullyParsedValue, event, context);
            if (!(validateReturn instanceof Promise)) {
              return validateReturn;
            }
            // validateReturn Promise resolves to 'valid' if all validators pass.
            // Resolves to 'invalidShown' if any validator fails.
            // Resolves to 'ignoreValidation' if we are to ignore validation results.
            self._setBusyState(busyStateKey);
            return validateReturn.then(function (valid) {
              if (valid === _VALID) {
                return successfullyParsedValue;
              }
              return undefined;
            });
          } catch (ve) {
            // SYNCHRONOUS _parseValue failed
            // turn this into Array of ComponentMessage instances.
            // This is what we set on 'messagesShown'
            newMsgs = self._processValidationErrors(ve, context);
            self._updateMessagesOption('messagesShown', newMsgs, event);
            self._setValidOption(_INVALID_SHOWN, event);
          }
        }
        return validateReturn;
      },

      /**
       * After _AsyncValidate, we normally update the value option and format the value to display
       * it, if no errors are showing.
       * This method does nothing if fulfilledNewValue is undefined. It returns false.
       *
       * @param {string|Object} fulfilledNewValue the parsed value. If undefined, this method returns
       * false.
       * @param {Object=} event an optional event if this was a result of ui interaction. For user
       * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
       * causes a 'blur' event.
       * @param {Object=} options - an Object literal that callers pass in to determine how validation
       * gets run.
       * @param {boolean=} options.doValueChangeCheck - if set to true compare newValue with last
       * displayValue before running validation; if false, always run validation. E.g., set to false
       * when validate() is called.
       * @param {boolean=} options.doNotClearMessages - if set method will not clear all messages. This
       * is provided for callers that may want to clear only some of the messages. E.g., when required
       * option changes, it clears only component messages, not custom.
       * @param {number=} options.validationMode - accepted values (defined in _VALIDATION_MODE) are:
       * <ul>
       *   <li>FULL - the default and runs both the converter and all validators. </li>
       *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
       *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
       * </ul>
       * @return {boolean} true if value was updated, false otherwise.
       *  This method returns false if fulfilledNewValue is undefined.
       * @example  <caption>Widget subclasses can use this convention to run full validation</caption>
       * this._SetValue(value, event);
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       *
       */
      _afterAsyncValidateUpdateValue: function (fulfilledNewValue, event, options) {
        var resolvedState = false;
        var updateContext;
        var doUpdateValueOption;

        if (fulfilledNewValue !== undefined) {
          if (options && options.doNotClearMessages === true) {
            doUpdateValueOption = this.isValid() || !this._hasInvalidComponentMessagesShowing();
          } else {
            doUpdateValueOption = this.isValid();
          }
          if (doUpdateValueOption) {
            if (options && options._context) {
              updateContext = options._context;
            }
            // update value option and then format the value and update display value.
            this._updateValueOption(
              fulfilledNewValue,
              event,
              options && options.validationContext,
              updateContext,
              options
            );
            resolvedState = true;
          }
        }
        return resolvedState;
      },

      _CompareOptionValues: function (option, value1, value2) {
        if (option === 'value' || option === 'rawValue') {
          return oj.Object.compareValues(value1, value2);
        } else if (option.indexOf('messages') === 0) {
          return this._messagesEquals(value1, value2);
        }

        return this._superApply(arguments);
      },

      /**
       * Returns the default styleclass for the component. All input components must override.
       *
       * @return {string}
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @abstract
       */
      _GetDefaultStyleClass: function () {
        oj.Assert.failedInAbstractFunction();
        return '';
      },

      // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S
      // Subclasses should not override or call these methods

      /**
       * Types of messaging content to update.
       * <ul>
       * <li>'INIT' - builds all messaging content needed for component initialization</li>
       * <li>'VALIDITY_STATE' - updates only validityState every time validation runs and there are
       * new messages or when the messages option changes.</li>
       * <li>'CONVERTER_HINT' - updates only converter hints, this is used when converter option
       * changes</li>
       * <li>'VALIDATOR_HINTS' - updates only validator hints, this is used when validators option
       * changes or when validator hints are first shown the the user.</li>
       * <li>'TITLE' - updates only title, when the title property changes</li>
       * <li>'LABEL' - updates only label, when the labelHint property changes</li>
       * </ul>
       * @private
       * @memberof oj.editableValue
       */
      _MESSAGING_CONTENT_UPDATE_TYPE: {
        INIT: 1,
        VALIDITY_STATE: 2,
        CONVERTER_HINT: 3,
        VALIDATOR_HINTS: 4,
        TITLE: 5,
        LABEL: 6
      },

      /**
       * when below listed options are passed to the component, corresponding CSS will be toggled
       * @private
       * @const
       * @type {Object}
       * @memberof oj.editableValue
       */
      _OPTION_TO_CSS_MAPPING: {
        disabled: 'oj-disabled',
        required: 'oj-required'
      },

      /**
       * Clears all messages for this component. Today this only happens when <br/>
       *  - the component's value changes as a result of user interaction, <br/>
       *  - the reset method is called, <br/>
       *  - component is destroyed.<br/>
       *
       * @param {Event=} event the original event (for user initiated actions that trigger a DOM event,
       * like blur) or undefined.
       * @param {boolean=} doNotSetOption default value is false; a true value clears the option
       * directly without using the public option method, causing no events to be fired.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _clearAllMessages: function (event, doNotSetOption) {
        if (!doNotSetOption) {
          this._clearMessages('messagesHidden', event);
          this._clearMessages('messagesShown', event);
          this._clearMessages('messagesCustom', event);
        } else {
          this.options.messagesHidden = [];
          this.options.messagesShown = [];
          this.options.messagesCustom = [];
        }
      },

      /**
       * Clears all messages that were added by component. These includes all messages in messagesHidden
       * option and all messages except custom in messagesShown.
       *
       * Called when these options change - validators, disabled, readonly, required, and methods -
       * refresh are called.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _clearComponentMessages: function () {
        var beforeLen;
        var msg;
        var shownMsgs = this.options.messagesShown;

        beforeLen = shownMsgs.length;
        this._clearMessages('messagesHidden');

        // remove component messages in messagesShown. Custom messges are kept intact.
        for (var i = beforeLen - 1; i >= 0; i--) {
          // NOTE: shownMsgs is this.options['messagesShown']
          // so we are modifying this.options['messagesShown'] here.
          msg = shownMsgs[i];
          if (msg instanceof Message.ComponentMessage) {
            shownMsgs.splice(i, 1);
          }
        }

        if (shownMsgs.length !== beforeLen) {
          // Setting 'changed' flag to true means that although we have already
          // updated this.options['messagesShown'], we still want to fire a messagesShownChanged event.
          this._setMessagesOption('messagesShown', shownMsgs, null, true);
        }
      },

      /**
       * Sets the messages option with the new value.
       * Setting 'changed' flag to true means we want to fire a property changed event
       * without checking that the option value to what you are setting it to. Useful
       * if the option is an array or we have already updated the option directly.
       *
       * This method updates the option directly without invoking setOption() method. This is done by
       * setting the following property in flags parameter of the option() method -
       * <code class="prettyprint">{'_context': {internalSet: true}}</code>
       *
       * @param {string} key
       * @param {Array} value
       * @param {Event=} event the event like the user blurred to trigger a messages option change
       * or undefined.
       * @param {Boolean=} changed when this is true, then we set the 'changed' flag to true, and having
       * the changed flag be true will guarantee that the property changed event is fired even if the
       * the property value is equal to what you are setting it to.
       * @private
       * @memberof oj.editableValue
       */
      _setMessagesOption: function (key, value, event, changed) {
        var flags = {};

        // Optimize for the common 'clear' operation
        var bothEmpty = value.length === 0 && this.options[key].length === 0;

        if (changed || !bothEmpty) {
          // 'messagesCustom' is not read-only, but 'messagesShown' and 'messagesHidden' are
          flags._context = { originalEvent: event, writeback: true, internalSet: true };
          if (key !== 'messagesCustom') {
            flags._context.readOnly = true;
          }

          flags.changed = changed || !bothEmpty;

          this._resetValid();

          this.option(key, value, flags);

          this._updateMessagingContent();
        }
      },

      /**
       * Sets the valid option with the new value.
       *
       * This method updates the option directly without invoking setOption() method. This is done by
       * setting the following property in flags parameter of the option() method -
       * <code class="prettyprint">{'_context': {internalSet: true}}</code>
       *
       * @param {string} newValidState The new valid state to set on the valid option
       *   e.g., "pending", "valid", "invalidShown", "invalidHidden"
       * @param {Event=} event the original event (for user initiated actions that trigger a DOM event,
       * like blur) or undefined. The custom element bridge creates a CustomEvent out of this when
       * it sends the property changed event.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _setValidOption: function (newValidState, event) {
        var flags = {};

        // We do not want to set valid state to PENDING if we are already showing messages, e.g., messages-custom.
        if (!(newValidState === _PENDING && this._determineValidFromMessagesOptions() !== _VALID)) {
          // do not set if it is already set to that
          if (newValidState !== this.options.valid) {
            // 'valid' is read-only
            flags._context = {
              originalEvent: event,
              writeback: true,
              internalSet: true,
              readOnly: true
            };

            this.option('valid', newValidState, flags);
          }
        }
      },

      /**
       * Clears the messages and message options - <code class="prettyprint">messagesHidden</code>,
       * <code class="prettyprint">messagesShown</code>, <code class="prettyprint">messagesCustom</code>.
       *
       * @param {String} option messages option that is being cleared.
       * @param {Event=} event the original event (for user initiated actions that trigger a DOM event,
       * like blur) or undefined.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _clearMessages: function (option, event) {
        this._setMessagesOption(option, [], event);
      },

      /**
       * Clones messages before it's set. <br/>
       *
       * @param {Array=} value
       * @returns {Array} of cloned messages
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _cloneMessagesBeforeSet: function (value) {
        var i;
        var msg;
        var msgsClone = [];
        var val;

        // we want all messages to be an instance of Message. So clone array
        if (value && value.length > 0) {
          for (i = 0; i < value.length; i++) {
            val = value[i];
            msg = new Message(val.summary, val.detail, val.severity);
            msg = Object.freeze ? Object.freeze(msg) : msg;
            msgsClone.push(msg);
          }
        }

        return msgsClone;
      },

      /**
       * Create the ojLabel component with help (required is done in the components that support
       * required) see EditableValueUtils._refreshRequired.
       * This is not supported for custom elements. For pages with custom elements, the app dev
       * uses the public &lt;oj-label> component.
       * @private
       * @memberof oj.editableValue
       * @instance
       *
       */
      _createOjLabel: function () {
        var helpDef;
        var helpSource;

        if (this._IsCustomElement()) {
          return;
        }

        this.$label = this._GetLabelElement();
        if (this.$label) {
          helpDef = this.options.help.definition;
          helpSource = this.options.help.source;

          // create the ojLabel component
          this.$label.ojLabel({
            rootAttributes: { class: this._GetDefaultStyleClass() + '-label' },
            help: { definition: helpDef, source: helpSource }
          });
          this._createDescribedByForLabel();
        }
      },
      /**
       * Refreshes the aria-describedby for label element's helpIcon
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _createDescribedByForLabel: function () {
        var helpDef = this.options.help.definition;
        var helpSource = this.options.help.source;
        var labelId;

        if (helpSource != null || helpDef != null) {
          var label = this.$label[0];

          // get label's helpIconSpan get the id and add it here.
          if (label) {
            labelId = label.id;
          }

          if (labelId) {
            this._describedByUpdated(null, labelId + _HELP_ICON_ID);
          }
        }
      },

      /**
       * Refreshes the component to respond to DOM changes, in which case fullRefresh=true.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _doRefresh: function () {
        var runFullValidation = false;
        var displayValue;

        // reset state and re-initialize component messaging, since refresh() can be called when
        // locale changes, requiring component to show messaging artifactsthis._ for current locale.
        this._ResetComponentState();
        this._initComponentMessaging();
        this._Refresh('disabled', this.options.disabled);

        // runFullValidation, if needed, does a full validation
        // which in turn updates value option and converted display value
        if (this._hasInvalidMessagesShowing()) {
          runFullValidation = true;
        }

        this._clearComponentMessages();

        if (runFullValidation) {
          // this may return a Promise
          displayValue = this._GetDisplayValue();
          // runs full validation on the display value. May be async
          this._SetValue(displayValue, null, EditableValueUtils.refreshMethodOptions);
        } else {
          // run deferred validation if comp is either showing a deferred error or has no errors.
          // But only when required is true.
          if (this._IsRequired()) {
            this._runDeferredValidation(EditableValueUtils.refreshMethodOptions.validationContext);
          }
          // refresh UI display value when there are no errors or where there are only deferred errors
          this._Refresh('value', this.options.value, true);
        }
      },

      /**
       * Gets the last stored model value
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getLastModelValue: function () {
        return this._oj_lastModelValue;
      },

      /**
       * Gets the last display value
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getLastDisplayValue: function () {
        // initially, _oj_lastElementValue is undefined. But the browser returns "" for the
        // displayValue.
        if (this._oj_lastElementValue === undefined) {
          this._oj_lastElementValue = '';
        }
        return this._oj_lastElementValue;
      },
      /**
       * Get the element whose id matches the elem's aria-labelledby value, if any.
       * @param {Object} elem the dom element from which you want to get the
       * aria-labelledby property value
       * @return {jQuery|null} if element does not have aria-labelledby defined, then
       *    returns null. If it  does, then return a new jQuery object with the
       *    label with an id equal to the aria-labelledby value. If no match, then
       *    the jQuery object will be empty.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getAriaLabelledByElement: function (elem) {
        // this is the widget way of doing things, so return if custom element.
        if (this._IsCustomElement()) {
          return null;
        }
        // look for a label with an id equal to the value of aria-labelledby.
        // .prop does not work for aria-labelledby. Need to use .attr to find
        // aria-labelledby.
        var ariaId = elem[0].getAttribute('aria-labelledby');
        var labelQuery;

        if (ariaId !== undefined) {
          labelQuery = "label[id='" + ariaId + "']";
          return $(labelQuery);
        }
        return null;
      },

      /**
       * Returns a concat of messagesShown and messagesHidden.
       *
       * @returns {Array}
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getMessages: function () {
        var messages = [];
        // messagesShown and messagesHidden could be undefined
        if (this.options.messagesShown) {
          messages = messages.concat(this.options.messagesShown);
        }
        if (this.options.messagesHidden) {
          messages = messages.concat(this.options.messagesHidden);
        }
        return messages; // todo: revisit
      },
      /**
       * Helper method to retrieve the label text. Needed for required translation.
       * Returns the form component's label or oj-label's textContent, if the label was found.
       *
       * @return {string|null}
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getLabelText: function () {
        if (this.$label) {
          return this.$label[0].textContent;
        }

        var ojlabels = EditableValueUtils._getCustomOjLabelElements(this.options.labelledBy);
        var labelTextContent = null;
        if (ojlabels) {
          for (var i = 0; i < ojlabels.length; i++) {
            if (i > 0) {
              labelTextContent += ' ';
            }
            var ojlabel = ojlabels[i];
            labelTextContent = ojlabel.textContent;
          }
        }
        return labelTextContent;
      },

      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getValidityState: function () {
        if (this._validityState) {
          return this._validityState;
        }

        this._validityState = new oj.ComponentValidity(this.isValid(), this._getMessages());

        return this._validityState;
      },

      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _hasValidityState: function () {
        if (this._validityState) {
          return true;
        }
        return false;
      },

      /**
       * Whether component has invalid messages.
       *
       * @return {boolean} true if invalid; false otherwise
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _hasInvalidMessages: function () {
        return !Message.isValid(this._getMessages());
      },

      /**
       * Whether there are invalid messages, that are currently showing.
       *
       * @return {boolean}
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _hasInvalidMessagesShowing: function () {
        return !this.isValid() && this.options.messagesShown.length > 0;
      },

      /**
       * Whether component has invalid messages added by component, that are currently showing.
       *
       * @return {boolean}
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _hasInvalidComponentMessagesShowing: function () {
        var compMsgs;
        var msg;
        var shown = this.options.messagesShown;

        for (var i = 0; i < shown.length; i++) {
          msg = shown[i];
          if (msg instanceof Message.ComponentMessage && msg._isMessageAddedByComponent()) {
            compMsgs = compMsgs || [];
            compMsgs.push(msg);
          }
        }

        return compMsgs === undefined ? false : !Message.isValid(compMsgs);
      },

      /**
       * Initializes component messaging both when component is initialized or when displayOptions is
       * set/changed. Call this only when you know the converter has resolved.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _initComponentMessaging: function () {
        var compMessaging = this._getComponentMessaging();
        var messagingLauncher = this._GetMessagingLauncherElement();
        var compContentElement = this._GetContentElement();
        var messagingContent = this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.INIT);

        // if default placeholder is currently set then it needs to be cleared here. This is needed for
        // the following reasons
        // i. a component is reinitialized when the locale changed, requiring the converter hint for
        // new locale to be set as placeholder.
        // ii. or a component's placeholder option or displayOptions option, could have changed
        // requiring the placeholder to be reset if it's currently set to the default.
        if (!this._customPlaceholderSet) {
          this._ClearPlaceholder();
        }

        // this sets all messaging content other than messaging content not needed until the user
        // does something to see them. e.g, validator hints are shown until focus on the field.
        // we do this to help initial render performance.
        compMessaging.activate(messagingLauncher, compContentElement, messagingContent);

        // Async validators hints are retrieved only when they are needed to be shown to the user.
        // See PopupComponentMessaging.js
        // initialize this counter when we initialize the component.
        // It is used to decide whether or not to ignore async validate resolutions.
        this._asyncValidatorValidateCounter = 0;
      },

      /**
       * Called after messagesCustom option changed. This method pushes custom messages to the
       * messagesShown option.
       *
       * @param {Object} flags
       * @returns {undefined}
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _messagesCustomOptionChanged: function (flags) {
        var context = flags ? flags._context : null;
        var customMsgs = this.options.messagesCustom;
        var i;
        var msg;
        var previousShown = this.options.messagesShown;
        var shownMsgs = [];

        // remove old custom messages from messagesShown array
        for (i = 0; i < previousShown.length; i++) {
          msg = previousShown[i];
          if (msg instanceof Message.ComponentMessage && msg._isMessageAddedByComponent()) {
            shownMsgs.push(msg);
          }
        }

        // add new customMsgs to messagesShown
        for (i = 0; i < customMsgs.length; i++) {
          shownMsgs.push(customMsgs[i]);
        }

        // set 'messagesShown' option as an internal set
        this._setMessagesOption(
          'messagesShown',
          shownMsgs,
          context ? context.originalEvent : null,
          flags && flags.changed
        );
      },
      /**
       * This is only needed when we use the
       * deprecated display-options.converter-hint=['placeholder','notewindow'] api that is used
       * in the Alta theme and not the Redwood theme.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _placeholderOptionChanged: function (flags) {
        if (this._getResolvedUserAssistance() !== 'displayOptions') {
          return;
        }
        var context = (flags && flags._context) || {};
        var refreshMessagingOptions =
          //  internalMessagingSet indicates whether the current change is from the messaging module.
          // see ComponentMessaging for details
          !context.internalMessagingSet;
        if (refreshMessagingOptions) {
          // if placeholder was set and it's not from messaging code, then the messaging display options
          // may need to re-evaluated. E.g., the default display for
          // converterHint: ['placeholder', 'notewindow'] is 'placeholder', but if user were to set a
          // custom placeholder, this changes the default display for convererHint from 'placeholder'
          // to 'notewindow'.
          this._customPlaceholderSet = true;
          if (this._GetConverter()) {
            this._initComponentMessaging();
          }
        } else {
          this._customPlaceholderSet = false;
        }
      },
      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _setLastModelValue: function (value) {
        this._oj_lastModelValue = value;
      },
      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _setLastDisplayValue: function (value) {
        this._oj_lastElementValue = value;
      },

      /**
       * Adds messages to the option specified - <code class="prettyprint">messagesShown</code> or
       * <code class="prettyprint">messagesHidden</code>.
       *
       * @param {String} option name of the option
       * @param {Object|Array} newMsgs an Array of one or more Message object.
       * @param {Event=} event - the event like the user blurred to trigger a messages option change
       * or undefined.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _updateMessagesOption: function (option, newMsgs, event) {
        var i;
        var len;
        var msgs;

        if (typeof newMsgs === 'object' && Array.isArray(newMsgs)) {
          // update this.options[option] directly by pushing any new messages into it.
          msgs = this.options[option];

          len = newMsgs.length;
          for (i = 0; i < len; i++) {
            msgs.push(newMsgs[i]);
          }
        }
        // Setting 'changed' flag to true means that although we have already
        // updated this.options[option], we still want to fire a property changed event.
        this._setMessagesOption(option, msgs, event, true);
      },

      /**
       * Called after the messages* option (messagesShown, etc)
       * has changed to update messaging content
       * display.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _updateMessagingContent: function () {
        // update component messaging
        this._getComponentMessaging().update(
          this._getMessagingContent(this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE)
        );
      },

      /**
       * Writes the value into the option by calling the option method.
       *
       * @param {Object|string} newValue the new value to be written to option
       * @param {Object=} event the original event that triggered this
       * @param {number=} validationContext the context in which validation was run that resulted in
       * value being updated.
       * @param {Object=} updateContext the context for updating the value option.
       * @param {Object=} options options for updating the value.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       * @see #_setOption
       * @see #_AfterSetOptionValue
       */
      _updateValueOption: function (newValue, event, validationContext, updateContext, options) {
        var context = updateContext || {};

        // set dom event
        if (event) {
          context.originalEvent = event;
        }

        // set writeback flag that determines whether value is written back.
        switch (validationContext) {
          // value is written back outside of normal UI interaction in the following cases.
          case this._VALIDATION_CONTEXT.CONVERTER_OPTION_CHANGE:
          case this._VALIDATION_CONTEXT.DISABLED_OPTION_CHANGE:
          case this._VALIDATION_CONTEXT.READONLY_OPTION_CHANGE:
          case this._VALIDATION_CONTEXT.REFRESH_METHOD:
          case this._VALIDATION_CONTEXT.REQUIRED_OPTION_CHANGE:
          case this._VALIDATION_CONTEXT.VALIDATE_METHOD:
          case this._VALIDATION_CONTEXT.VALIDATORS_OPTION_CHANGE:
            context.writeback = true;

            // when the above options change or methods are called, and full validation is run the
            // current display value is parsed, and set on the value option if all validations pass.
            // Typically when the value option changes - either programmatically or user changes it, we
            // end up clearing all 3 messages options.
            // But when value changes indirectly as a result of the above cases, then we do not clear
            // custom messages. So a special flag is set so _AfterSetOptionValue can do the right
            // thing. Component messages are already cleared when this method is called.
            context.doNotClearMessages = true;
            break;

          default:
            break;
        }

        context.internalSet = true;

        var valueMap;
        var isValueChanged;
        if (options && options.targetOptions) {
          // If targetOptions is specified, update all options in the array
          valueMap = {};
          isValueChanged = false;
          for (var i = 0; i < options.targetOptions.length; i++) {
            valueMap[options.targetOptions[i]] = newValue;
            isValueChanged = isValueChanged || options.targetOptions[i] === 'value';
          }
        } else {
          // If no targetOptions is specified, just update the "value" option
          valueMap = { value: newValue };
          isValueChanged = true;
        }
        this.option(valueMap, { _context: context });

        if (isValueChanged) {
          // When internalSet is true _setOption->_AfterSetOptionValue->_Refresh isn't called.
          // We still need the converter to run and the displayValue to be refreshed, so we
          // call this._AfterSetOptionValue ourselves
          this._AfterSetOptionValue('value', { _context: context });
        }
      },

      /**
       * Resets the internal property so that the next call to this.isValid() re-evaluates the correct
       * value.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _resetValid: function () {
        this._valid = undefined;
      },

      /**
       * Determines the validity of component based on current value of the messages* options.
       * This is what the 'valid' property should be set to.
       *
       * Now when we start the lifecycle we clearAllMessages, then we continue with validation, etc.
       * But we don't want to update the valid property on clearAllMessages and again when validation
       * has failed. We want to update it only once.
       * @return {string} "valid", "invalidShown", "invalidHidden"
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _determineValidFromMessagesOptions: function () {
        var msgsHidden = this.options.messagesHidden;
        var msgsShown = this.options.messagesShown;

        var valid = _VALID;

        // When new messages are written update the valid property
        if (msgsShown && msgsShown.length !== 0 && !Message.isValid(msgsShown)) {
          valid = _INVALID_SHOWN;
        } else if (msgsHidden && msgsHidden.length !== 0 && !Message.isValid(msgsHidden)) {
          valid = _INVALID_HIDDEN;
        }

        return valid;
      },

      /**
       * Formats the value for display, based on the converter options. If no converter is set then
       * returns the value as is.
       *
       * @param {string} value value to be formatted
       *
       * @return {string} formatted value
       * @throws {Error} when an error occurs during formatting
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _formatValue: function (value) {
        var formattedValue = value;
        var converter = this._GetConverter();

        // don't clear messages here because we clear messages only when direct user interaction with
        // component changes value. All other usecases we expect page authors to clear messages.

        if (converter) {
          // Check if we have a converter instance
          if (typeof converter === 'object') {
            if (converter.format && typeof converter.format === 'function') {
              formattedValue = converter.format(value);
            }
          }
        }

        return formattedValue;
      },

      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getComponentMessaging: function () {
        if (!this._componentMessaging) {
          this._componentMessaging = new oj.ComponentMessaging(this);
        }

        return this._componentMessaging;
      },

      /**
       * Returns an array of validator hints from any validator with getHint() function.
       * @param {Array} allValidators these are from the validators option
       * and from the GetImplicitValidators function.
       * These can be sync validators only since async validators api does not have getHint(),
       * it has .hint property.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getHintsFromAllValidatorsWithGetHintFunction: function (allValidators) {
        var i;
        var validator;
        var validatorHints = [];
        var vHint = '';

        if (this._IsRequired()) {
          // get the hint for the default required validator and push into array if it's not already
          // present in the validators array
          validator = this._getImplicitRequiredValidator();
          if (validator.getHint && typeof validator.getHint === 'function') {
            vHint = validator.getHint();
            if (vHint) {
              validatorHints.push(vHint);
            }
          }
        }

        // loop through all remaining validators to gather hints.
        // this will get sync validators only since sync validators have getHint() api
        // and async validators have .hint property.
        for (i = 0; i < allValidators.length; i++) {
          validator = allValidators[i];
          vHint = '';
          if (typeof validator === 'object') {
            if (validator.getHint && typeof validator.getHint === 'function') {
              vHint = validator.getHint();
              if (vHint) {
                validatorHints.push(vHint);
              }
            }
          }
        }

        return validatorHints;
      },

      /**
       * Returns the required validator instance or creates it if needed and caches it.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getImplicitRequiredValidator: function () {
        var reqTrans = {};
        var reqValOptions;

        if (this._implicitReqValidator == null) {
          // falsey check
          reqTrans = this.options.translations ? this.options.translations.required || {} : {};

          // TODO: cache required validator; purged when its options change, i.e., translations or label
          // DOM changes
          reqValOptions = {
            hint: reqTrans.hint || null,
            label: this._getLabelText(),
            messageSummary: reqTrans.messageSummary || null,
            messageDetail: reqTrans.messageDetail || null
          };
          this._implicitReqValidator = new RequiredValidator(reqValOptions);
        }
        return this._implicitReqValidator;
      },

      /**
       * In the Alta theme, we want to continue to use the display-options properties to decide
       * where to render help-instruction, messages, validation-hint, etc. For example, if
       * display-options.messages = 'notewindow' then the messages will show up in a popup on focus.
       *
       * In the Redwood theme, we instead use the user-assistance attribute set on the component
       * to decide whether to show the user assistance (this includes Required)
       * inline or in compact mode which is where the user assistance is shown via a popup,
       * like in the ? icon on the label or a (x) icon in the field.
       * We need a way to say 'use' the user-assistance-density attribute or 'ignore'
       * the user-assistance-density attribute and instead use the 'old' way
       * of doing things based on the theme.
       * And if you are 'using' the user-assistance-density attribute what is it,
       * reflow or efficient or compact?
       * @return {'reflow'|'efficient'|'compact'|'displayOptions'} If 'displayOptions' it uses
       * the 'old' way of doing things which is to look at all the displayOptions for where to display
       * things. If 'efficient' or 'reflow' it renders all the user assistance inline,
       * and if compact it renders everything in the 'compact' ux design which is in notewindows.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getResolvedUserAssistance: function () {
        // ThemeUtils caches the result so no need to do it here.
        let defaultOptions = ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults');

        // this will return 'use' or 'ignore'. This tells us whether we should use the
        // user-assistance-density attribute or ignore it. If we ignore it, we will
        // use the displayOptions attribute.
        if (defaultOptions) {
          let useUserAssistanceOption = defaultOptions.useUserAssistanceOptionDefault;
          return useUserAssistanceOption === 'use'
            ? this.options.userAssistanceDensity
            : 'displayOptions';
        }
        // if no theme return displayOptions for bw compatibility.
        return 'displayOptions';
      },
      /**
       * In the Alta theme, we show required on the label with an * icon,
       * and help on label with a ? icon.
       * In the Redwood theme, we show 'Required'/help as text inline if
       * user-assistance-density attribute is not 'compact',
       * else we show it as an * on the icon.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _showUserAssistanceNotInline: function () {
        let resolvedUserAssistance = this._getResolvedUserAssistance();

        return resolvedUserAssistance === 'compact' || resolvedUserAssistance === 'displayOptions';
      },

      /**
       * Returns content that will be used by messaging strategies.
       *
       * @param {number} updateType of messaging content to update. Accepted values are defined by
       * this._MESSAGING_CONTENT_UPDATE_TYPE.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getMessagingContent: function (updateType) {
        var messagingContent = {};

        var allValidators;
        var converter;
        var converterHint = '';

        // eslint-disable-next-line no-param-reassign
        updateType = updateType || this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE;

        // Add validityState which includes messages, valid and severity.
        // These are shown to the user right away on initialization if they are there.
        if (
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT ||
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE
        ) {
          // get messages from messagesShown and messagesHidden
          messagingContent.validityState = this._getMessagingContentValidityState();
        }

        if (
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT ||
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT
        ) {
          converter = this._GetConverter();
          if (converter) {
            if (typeof converter === 'object') {
              if (converter.getHint && typeof converter.getHint === 'function') {
                converterHint = converter.getHint() || '';
              }
            }
          }
          messagingContent.converterHint = converterHint;
        }

        // Do not get validator hints on component initialization. Instead we get them
        // when the user first needs them, like when they focus in the input.
        // We do this to help initial render performance.
        if (updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS) {
          // gets implicit validators and all validators from the validators option.
          allValidators = this._GetAllValidatorsFromValidatorsOptionAndImplicit();
          // sync validators have getHint() function.
          // async validators do not; they have hint property.
          // so this will get sync validators' hints
          let syncValidatorHints =
            this._getHintsFromAllValidatorsWithGetHintFunction(allValidators) || [];
          messagingContent.validatorHint = syncValidatorHints;
        }

        if (
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT ||
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.TITLE
        ) {
          // For custom element components, we use help.instruction option value for the
          // messageContent title, otherwise, use the title option value.  help.instruction
          // is used by custom element components, and title is used by non-custom element components.
          var title;

          if (this._IsCustomElement()) {
            var help = this.options.help;

            if (help != null) {
              title = help.instruction;
            }
          } else {
            title = this.options.title;
          }

          messagingContent.title = title || '';
        }

        if (
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.INIT ||
          updateType === this._MESSAGING_CONTENT_UPDATE_TYPE.LABEL
        ) {
          if (this._IsCustomElement()) {
            messagingContent.label = this.options.labelHint;
          }
        }

        return messagingContent;
      },

      /**
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _getMessagingContentValidityState: function () {
        let validityState;
        if (!this._hasValidityState()) {
          // this will create the validity state.
          validityState = this._getValidityState();
        } else {
          // update validityState before packaging it
          validityState = this._getValidityState();
          validityState.update(this.isValid(), this._getMessages());
        }
        return validityState;
      },

      /**
       * Compares the messages arrays for equality.
       *
       * @param {Array} pm previous messages
       * @param {Array} m new messages
       * @returns {boolean} true if equal false otherwise
       * @private
       * @memberof oj.editableValue
       * @instance
       *
       */
      _messagesEquals: function (pm, m) {
        var match = -1;
        var pmo;
        var passed = true;
        // $.extend merges the contents of two or more objects together into the first object
        var previousMsgs = $.extend([], pm);
        var msgs = $.extend([], m);

        if (previousMsgs.length !== msgs.length) {
          return false;
        }

        // one way it gets here is if there is one messages-custom message on initialization and
        // after the busyContext is complete meaning the page is rendered, we set a different
        // messages-custom message.
        previousMsgs.forEach(function (pMsg) {
          if (!(pMsg instanceof Message)) {
            // freeze message instance once its created
            pmo = new Message(pMsg.summary, pMsg.detail, pMsg.severity);
            pmo = Object.freeze ? Object.freeze(pmo) : pmo;
          } else {
            pmo = pMsg;
          }

          match = -1;
          msgs.forEach(function (msg, j) {
            if (
              Message.getSeverityLevel(pmo.severity) === Message.getSeverityLevel(msg.severity) &&
              pmo.summary === msg.summary &&
              pmo.detail === msg.detail
            ) {
              match = j;
              // found a match, so break out of loop
            }
          });

          // remove entry at 'match' index from msgs
          if (match > -1) {
            msgs.splice(match, 1);
          } else {
            // we found no match so no need to loop
            passed = false;
          }
        });

        return passed;
      },

      /**
       * Parses the value using the converter set and returns the parsed value. If parsing fails the
       * error is written into the element. This function sets the valid state to PENDING before it tries
       * to parse.
       *
       * @param {string=} submittedValue to parse
       * @param {Object=} event an optional event if this was a result of ui interaction. For user
       * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action
       * causes a 'blur' event.
       * @param {boolean?} setValid true if you want to set the valid state to pending->invalid
       * @return {Object} parsed value
       * @throws {Error} an Object with message
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _parseValue: function (submittedValue, event, setValid) {
        var converter = this._GetConverter();
        var parsedValue = submittedValue;

        if (converter) {
          if (typeof converter === 'object') {
            if (converter.parse && typeof converter.parse === 'function') {
              try {
                // we are dealing with a converter instance
                if (setValid) {
                  this._setValidOption(_PENDING, event);
                }
                parsedValue = converter.parse(submittedValue);
                // caller will set valid option, since usually we go on to call validators after
                // converters and don't want to set pending->valid->pending again.
              } catch (error) {
                throw error;
              }
            }
          }
        }

        return parsedValue;
      },
      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _addValidationError: function (e, msgs) {
        var detail;
        var severity;
        var ojmessage;
        var summary;

        if (e instanceof ojvalidationError.ConverterError || e instanceof ojvalidationError.ValidatorError) {
          ojmessage = e.getMessage();

          severity = ojmessage.severity || Message.SEVERITY_LEVEL.ERROR;
          summary = ojmessage.summary || Translations.getTranslatedString('oj-message.error');
          detail = ojmessage.detail || Translations.getTranslatedString('oj-converter.detail');
        } else if (e.summary || e.detail) {
          severity = Message.SEVERITY_LEVEL.ERROR;
          summary = e.summary || Translations.getTranslatedString('oj-message.error');
          detail = e.detail || Translations.getTranslatedString('oj-converter.detail');
        } else {
          // TODO: is this error message generic enough to use for both converter and validator errors?
          severity = Message.SEVERITY_LEVEL.ERROR;
          summary = Translations.getTranslatedString('oj-message.error');
          detail = e.message || Translations.getTranslatedString('oj-converter.detail');
        }

        msgs.push({ summary: summary, detail: detail, severity: severity });
      },

      /**
       * Processes the error information for one or more errors and returns an Array of
       * ComponentMessage instances.
       *
       * @param {Error} e instance of Error
       * @param {number=} context the context in which the validation error was thrown
       * @param {String=} display whether message is shown or hidden
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _processValidationErrors: function (e, context, display) {
        var componentMsgs = [];
        var msg;
        var msgs = e._messages || [];
        var options = {};

        options.context = context || 0;
        options.display = display || Message.ComponentMessage.DISPLAY.SHOWN;

        if (msgs.length === 0) {
          this._addValidationError(e, msgs);
        }

        for (var i = 0; i < msgs.length; i++) {
          msg = msgs[i];
          componentMsgs.push(
            this._createComponentMessage(msg.summary, msg.detail, msg.severity, options)
          );
        }

        return componentMsgs || null;
      },
      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _createComponentMessage: function (summary, detail, severity, options) {
        var cMsg;
        // new properties can't be added but existing properties can be changed
        cMsg = new Message.ComponentMessage(summary, detail, severity, options);
        cMsg = Object.seal ? Object.seal(cMsg) : cMsg;
        return cMsg;
      },

      /**
       * Formats and refreshes the component display value,
       * only when the current value is different from the last
       * saved value, unless asked to always refresh the display value.
       *
       * @param {Object|undefined} value the changed value that needs to be updated on UI
       * @param {boolean=} fullRefresh false is the default; true means always refresh component
       * display value using the current option value. This overwrites any UI value, the user may have
       * entered.
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _refreshComponentDisplayValue: function (value, fullRefresh) {
        var displayValueReturn;

        // when we change the display value via value change we want to
        // update the 'oj-has-no-value' class.
        this._toggleOjHasNoValueClass(value);

        // We set the last model value after the format, so this is saying,
        // has the value about to be formatted different than the one we last formatted?
        if (fullRefresh || value !== this._getLastModelValue()) {
          // this formats the value and displays it.
          displayValueReturn = this._UpdateElementDisplayValue(value);
        }
        return displayValueReturn;
      },

      /**
       * Toggles css selector on the widget. E.g., when required option changes, the oj-required
       * selector needs to be toggled.
       * @param {string} option
       * @param {Object|string} value
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _refreshTheming: function (option, value) {
        if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) !== -1) {
          if (value) {
            this.widget()[0].classList.add(this._OPTION_TO_CSS_MAPPING[option]);
          } else {
            this.widget()[0].classList.remove(this._OPTION_TO_CSS_MAPPING[option]);
          }
        }
      },

      /**
       * Runs validators in deferred mode using the option value. Any validation error thrown is
       * deferred, or hidden by component, until explicitly asked to show them (see showMessages()).
       * Deferred error is pushed to <code class="prettyprint">messagesHidden</code> option.
       *
       * @param {number} context in which validation was run.
       * @see #showMessages
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _runDeferredValidation: function (context) {
        var self = this;

        if (this._CanSetValue()) {
          if (!this._resolveBusyStateDeferredValidation) {
            var domElem = this.element[0];
            var busyContext = Context.getContext(domElem).getBusyContext();
            var description = 'The page is waiting for async deferred validation ';

            if (domElem && domElem.id) {
              description += 'for "' + domElem.id + '" ';
            }
            description += 'to finish.';
            this._resolveBusyStateDeferredValidation = busyContext.addBusyState({
              description: description
            });
          }
          var resultPromise = this._validateValueForRequiredOnly(this.options.value, context);
          if (resultPromise instanceof Promise) {
            resultPromise.then(function () {
              if (self._resolveBusyStateDeferredValidation) {
                self._resolveBusyStateDeferredValidation();
                delete self._resolveBusyStateDeferredValidation;
              }
              self._setValidOption(self._determineValidFromMessagesOptions(), null);
            });
          } else {
            this._setValidOption(this._determineValidFromMessagesOptions(), null);
            if (this._resolveBusyStateDeferredValidation) {
              this._resolveBusyStateDeferredValidation();
              delete this._resolveBusyStateDeferredValidation;
            }
            return;
          }
        }
        this._setValidOption(this._determineValidFromMessagesOptions(), null);
      },

      /**
       * Runs either deferred or normal validation based on the state component is in. This method is
       * called when certain options change - required, disabled etc.
       *
       * <p>
       * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
       * run full validation with UI value (we don't know if the UI error is from a required validator
       * or something else);<br/>
       * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
       * updated<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to valueChanged to clear custom errors.<br/>
       *
       * - if component is invalid and has messagesHidden -> required: false -> clear component
       * errors; no deferred validation is run.<br/>
       * - if component has no error -> required: true -> run deferred validation (we don't want to flag
       * errors unnecessarily)<br/>
       * - messagesCustom is never cleared<br/>
       * </p>
       *
       * @param {Object} validationOptions
       *
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _runMixedValidationAfterSetOption: function (validationOptions) {
        var runFullValidation = false;
        var displayValue;

        // runFullValidation, if needed, does a full validation
        // which in turn updates value option and converted display value

        if (this._hasInvalidMessagesShowing()) {
          runFullValidation = true;
        }

        this._clearComponentMessages();

        if (runFullValidation) {
          // this may return a Promise
          displayValue = this._GetDisplayValue();
          // runs full validation on the display value. May be async
          this._SetValue(displayValue, null, validationOptions);
        }

        if (!runFullValidation && this._IsRequired()) {
          // run deferred validation if we didn't run full validation
          // (e.g., comp is either showing a deferred error or has no errors.)
          // But only when required is true do
          // we update the valid option within _runDeferredValidation
          this._runDeferredValidation(validationOptions.validationContext);
        } else {
          this._setValidOption(this._determineValidFromMessagesOptions(), null);
        }
      },

      /**
       * Formats the modelValue and updates the display value.
       * @param modelValue
       * @param ignoreAfterError boolean defaults to false.
       * If true, do not do anything after format error, like
       * do not show messages, do not change valid state.
       * @return {undefined|string} if formatting threw an error, return undefined.
       * if formatting was successful and no other errors occur, return formatted
       * value.
       * @throw {Error} converter.format error if the converter is synchronous.
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _UpdateElementDisplayValue: function (modelValue, ignoreAfterError) {
        var displayValue;
        var parsedReturnValue;

        displayValue = modelValue;

        try {
          // returns the converter formatted value, and if there is no converter, it returns
          // the value as is.
          displayValue = this._formatValue(modelValue);
          // synchronous converter's format succeeded or no converter
          try {
            this._setLastModelValue(modelValue);
            this._afterConverterFormat(displayValue);
          } catch (e) {
            // rethrow error in case _SetDisplayValue() threw an error. See ojcheckboxset,
            // it throws error if it isn't an array or if it is null.
            throw e;
          }
          parsedReturnValue = displayValue;
        } catch (e) {
          if (!ignoreAfterError) {
            this._afterConverterFormatFailure(e);
          }
          this._setLastModelValue(modelValue);
          // displayValue is modelValue if we get here.
          this._afterConverterFormat(displayValue);
          parsedReturnValue = undefined;
        }
        return parsedReturnValue;
      },

      /**
       * This gets called while the converter module is loading asynchronously
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _SetLoading: function () {
        var widgetElem = this.widget()[0];
        var focusElem = this.GetFocusElement();
        widgetElem.classList.add('oj-loading');
        this._saveAriaLabel = focusElem.getAttribute('aria-label');
        var loadingText = Translations.getTranslatedString('oj-ojEditableValue.loading');
        focusElem.setAttribute('aria-label', loadingText);
      },

      /**
       * This gets called when the converter was loading asynchronously
       * and now it is loaded.
       * @protected
       * @memberof oj.editableValue
       * @instance
       */
      _ClearLoading: function () {
        var widgetElem = this.widget()[0];
        var focusElem = this.GetFocusElement();
        widgetElem.classList.remove('oj-loading');
        if (this._saveAriaLabel) {
          focusElem.setAttribute('aria-label', this._saveAriaLabel);
        } else {
          focusElem.removeAttribute('aria-label');
        }
      },

      /**
       * @ignore
       * @protected
       * @memberof oj.editableValue
       * @return {boolean}
       */
      _UseReadonlyDiv: function () {
        // ThemeUtils caches the result so no need to do it here.
        let defaultOptions = ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults');
        return defaultOptions.readonlyElem === 'div';
      },

      /**
       * This is called from InlineHelpHintsStrategy to determine if the
       * component should show help hints on focus or always. Set
       * components show it always.
       * @ignore
       * @protected
       * @memberof oj.editableValue
       * @return {'focus'|'always'}
       */
      _ShowHelpHints: function () {
        return this._IsTextFieldComponent() ? 'focus' : 'always';
      },
      /**
       * This is called from InlineHelpHintsStrategy to determine
       * the location of the inline help hints, above the component
       * or below inline.
       * @ignore
       * @protected
       * @memberof oj.editableValue
       * @return {'above'|'inline'}
       */
      _ShowHelpHintsLocation: function () {
        return 'inline';
      },

      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _afterConverterFormat: function (displayValue) {
        var actualDisplayValue;

        this._SetDisplayValue(displayValue);
        // getting the display value right after we set it is probably not necessary,  but just in
        // case a subclass did something to it, we do.
        actualDisplayValue = this._GetDisplayValue();
        this._setLastDisplayValue(actualDisplayValue);
        // update rawValue option to keep it in sync with the display value
        this._SetRawValue(actualDisplayValue, null);
      },

      /**
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _afterConverterFormatFailure: function (e) {
        var newMsgs;

        // Turn this into Array of ComponentMessage instances.
        // This is what we set on 'messagesShown'
        newMsgs = this._processValidationErrors(e);
        this._updateMessagesOption('messagesShown', newMsgs);
        // update valid option to INVALID_SHOWN
        this._setValidOption(_INVALID_SHOWN, null);
      },

      /**
       * When we are asynchronously loading a converter we show a loading indication
       * and make the input (not the component) readonly.
       * @param converterPromise {Promise<Converter>}
       * @return {Promise<Object|null>} a Promise to a converter instance or null
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _loadingConverter: function (converterPromise) {
        var self = this;
        var showLoadingIndicatorDelay = EditableValueUtils._getShowLoadingDelay();
        var converterCounter = this._converterChangedCounter;
        var loadingTimeout = setTimeout(function () {
          // _converterChangedCounter is incremented if we get a change of converter option.
          if (converterCounter === self._converterChangedCounter) {
            self._SetLoading();
          }
        }, showLoadingIndicatorDelay);

        return converterPromise.then(function (ci) {
          self._ClearLoading();
          clearTimeout(loadingTimeout);
          return ci;
        });
      },
      /**
       * @param {Object|undefined} value
       * @param {number} context in which validation was run.
       * @return {Promise<null> | null} a Promise to indicate validation has finished or null if sync
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _validateValueForRequiredOnly: function (value, context) {
        var newMsgs;
        var validator;
        var self = this;

        // run required validation if component is required
        // SYNCHRONOUS OR ASYNCHRONOUS
        if (this._IsRequired()) {
          validator = this._getImplicitRequiredValidator();
          try {
            // check if trimmed value is empty. See AdfUIEditableValue.prototype.ValidateValue
            this._setValidOption(_PENDING, null);
            var validateReturned = validator.validate(oj.StringUtils.trim(value));
            if (validateReturned instanceof Promise) {
              return validateReturned.then(
                function () {},
                function (e) {
                  newMsgs = self._processValidationErrors(
                    e,
                    context,
                    Message.ComponentMessage.DISPLAY.HIDDEN
                  );
                  if (newMsgs) {
                    self._updateMessagesOption('messagesHidden', newMsgs);
                  }
                }
              );
            }
          } catch (e) {
            // this is a messagesHidden message
            // turn this into Array of ComponentMessage instances. This is what we set on 'messagesHidden'
            newMsgs = this._processValidationErrors(
              e,
              context,
              Message.ComponentMessage.DISPLAY.HIDDEN
            );
            if (newMsgs) {
              this._updateMessagesOption('messagesHidden', newMsgs);
            }
          }
        }
        return null;
      },

      /**
       * This is called from both _SetValue and when we need to re-validate due to
       * property changes, like converters, required, etc.
       * This validates the value by running through the list of all registered validators and
       * async-validators. The algorithm is as follows -
       * 1. if isRequired, run required validator.
       * 2. get all the rest of the validators and validate in sequence.
       * 3. get async-validators and kick them all off simultaneously, and show errors as we get them.
       * 4. update valid state immediately if it turns for the worse.
       * 5. will ignore validation results if we get a new call to this method with a different value
       *  before we get back the async validate results from a previous value.
       * results.
       *
       * Callers can rely on the 'valid' options property to determine the validity state of the
       * component after calling this method
       *
       * @param {Object|string} value to be validated
       * @param {Event?} event the original event (for user initiated actions that trigger a DOM event,
       * like blur) or undefined. The custom element bridge creates a CustomEvent out of this when
       * it sends the property changed event.
       * @param {number=} context determines when validation is being run. Used when creating Messages
       * @return {Promise|Object|string|undefined}
       * Promise resolves to 'valid' if all validators pass. Resolves to 'invalidShown'
       * if any validator fails. Resolves to 'ignoreValidation' if we are to ignore validation results.
       * If no async validators are on the component, it returns the value we validated if
       * validation passed or undefined if validation failed.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _asyncValidateValue: function (value, event, context) {
        // we get validators from async-validators option. This is not cached, but
        // it is fast to get. TODO cache.
        var normalizedAsyncValidators = this._GetNormalizedAsyncValidatorsFromOption();
        // gets implicit validators and validators from validators option.
        // these can be sync or async validators. This is cached.
        var normalizedValidators = this._GetAllValidatorsFromValidatorsOptionAndImplicit();
        var i;
        var isInvalidShownSet = false;
        var finalValidState;
        var newMsgs;
        var self = this;
        var implicitRequiredValidator;
        var valMsgs = [];

        // this to be used to decide whether or not to ignore async validate resolutions.
        // if we use the value to decide whether or not to ignore async validate resolutions, it
        // would not work if the user types in an invalid value, then another value, then the
        // invalid value again. He would see two identical error messages if the async validators
        // are slow. We talked about using a queue, and decided a counter would work just as well.
        var asyncValidatorValidateCounter = this._asyncValidatorValidateCounter;
        var promiseArray = [];
        // run required validator first, push to promiseArray if it is a Promise
        var isRequired = this._IsRequired();
        if (isRequired) {
          implicitRequiredValidator = this._getImplicitRequiredValidator();
        }
        if (isRequired || normalizedAsyncValidators.length > 0 || normalizedValidators.length > 0) {
          this._setValidOption(_PENDING, event);
        }
        if (implicitRequiredValidator) {
          try {
            var requiredValidatorPromise = implicitRequiredValidator.validate(
              oj.StringUtils.trim(value)
            );
            if (requiredValidatorPromise) {
              promiseArray.push(requiredValidatorPromise);
            }
          } catch (e) {
            // save all validation errors
            this._addValidationError(e, valMsgs);
            this._setValidOption(_INVALID_SHOWN, event);
            isInvalidShownSet = true;
          }
        }

        var result;
        for (i = 0; i < normalizedAsyncValidators.length; i++) {
          try {
            result = normalizedAsyncValidators[i].validate(value);
          } catch (e) {
            // async validators should not throw errors, they should just reject
            // so we should treat this as a reject
            result = Promise.reject(e);
          }
          if (!(result instanceof Promise)) {
            result = Promise.resolve(result);
          }
          promiseArray.push(result);
        }

        // run through all validators on the validators option + implicit ones.
        // could be sync or async
        for (i = 0; i < normalizedValidators.length; i++) {
          try {
            result = normalizedValidators[i].validate(value);
            if (result instanceof Promise) {
              promiseArray.push(result);
            }
          } catch (e) {
            // save all validation errors
            this._addValidationError(e, valMsgs);
            this._setValidOption(_INVALID_SHOWN, event);
            isInvalidShownSet = true;
          }
        }

        // show sync validator messages, if any
        if (valMsgs.length > 0) {
          let ve = new Error();
          ve._messages = valMsgs;
          newMsgs = this._processValidationErrors(ve, context);
          // turn this into Array of ComponentMessage instances.
          // This is what we set on 'messagesShown'
          this._updateMessagesOption('messagesShown', newMsgs, event);
        }

        // when a promise resolves or errors out, we return an Object with the value or error state,
        // and the status.
        // We want to show error messages right away, as we get them.
        // We also want to ignore any error messages or valid state changes if we get
        // a new value to validate while the current async validate methods haven't returned yet.
        // This could happen if we kick off a slow validator and the user types into the field
        // and blurs to cause a new _SetValue->validation before this one returns.
        function reflect(promise) {
          return promise.then(
            function (v) {
              var status;

              // Ignore validate Promise results if it is for a value that isn't the most current value
              // we are validating. The only con is if they are in the process of typing in the field,
              // errors might show up for value when they last pressed Enter|Blur.
              // We decided this is fine, and we will show the value in the error message in our demos
              // so the user won't get confused, and we'll doc that this is what the app dev should do.
              if (self._asyncValidatorValidateCounter === asyncValidatorValidateCounter) {
                status = 'resolved';
              } else {
                status = 'ignore';
              }
              return { v: v, status: status };
            },
            function (e) {
              var status;
              if (self._asyncValidatorValidateCounter === asyncValidatorValidateCounter) {
                // turn this into Array of ComponentMessage instances.
                // This is what we set on 'messagesShown'
                newMsgs = self._processValidationErrors(e, context);
                self._updateMessagesOption('messagesShown', newMsgs, event);
                if (!isInvalidShownSet) {
                  self._setValidOption(_INVALID_SHOWN, event);
                  isInvalidShownSet = true;
                }
                status = 'rejected';
              } else {
                status = 'ignore';
              }
              return { e: e, status: status };
            }
          );
        }

        if (promiseArray.length > 0) {
          return new Promise(function (resolve) {
            // Promise.all will end as soon as it gets its first rejection. We don't want that.
            // We want to wait until all promises either resolve or reject. Then we can resolve this
            // outer promise. We do this using the reflect function defined above.
            Promise.all(promiseArray.map(reflect)).then(function (results) {
              var ignoreList = results.filter(function (x) {
                return x.status === 'ignore';
              });
              if (ignoreList.length > 0) {
                finalValidState = 'ignoreValidation';
              } else {
                finalValidState = !isInvalidShownSet ? _VALID : _INVALID_SHOWN;
                // we could be showing messages, like 'messagesCustom'. If so, valid is invalidShown,
                // even if all validators passed.
                self._setValidOption(self._determineValidFromMessagesOptions(), event);
              }
              resolve(finalValidState);
            });
          });
        }

        // only sync validators were found
        if (valMsgs.length === 0) {
          // we could be showing messages, like 'messagesCustom'. If so, valid is invalidShown,
          // even if all validators passed.
          this._setValidOption(self._determineValidFromMessagesOptions(), event);
        }
        // if no error messages returned from validating the value, return newValue
        return valMsgs.length === 0 ? value : undefined;
      },

      /**
       * This is called when we have a labelledBy attribute during component initialization
       * or the attribute updates.
       *
       * @param {string} labelledBy The labelledBy attribute value. Can be a space delimited value.
       * @private
       * @memberof oj.editableValue
       * @instance
       */
      _labelledByUpdated: function (labelledBy) {
        var ojlabels = EditableValueUtils._getCustomOjLabelElements(labelledBy);
        if (ojlabels) {
          for (let i = 0; i < ojlabels.length; i++) {
            var ojlabel = ojlabels[i];
            ojlabel.classList.add(this._GetDefaultStyleClass() + '-label');
            if (
              this.widget().attr('data-oj-internal') === undefined &&
              this.options.readOnly !== undefined
            ) {
              this._addRemoveOjReadOnlyClassOnLabel(ojlabel, this.options.readOnly);
            }
          }
        }
      },

      /**
       * propogate described-by to aria-describedby
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _describedByUpdated: LabelledByUtils._describedByUpdated,
      /**
       * Set busy state for async validators
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _setBusyState: EditableValueUtils._SetBusyState,
      /**
       * Clear  busy state for async validators
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _clearBusyState: EditableValueUtils._ClearBusyState,
      /**
       * Set busy state for async validators hint
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _setBusyStateAsyncValidatorHint: EditableValueUtils._SetBusyStateAsyncValidatorHint,
      /**
       * Clear  busy state for async validators hint
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _clearBusyStateAsyncValidatorHint: EditableValueUtils._ClearBusyStateAsyncValidatorHint,
      /**
       * Set busy state for async converter loading
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _setBusyStateAsyncConverterLoading: EditableValueUtils._SetBusyStateAsyncConverterLoading,
      /**
       * Clear  busy state for async converter loading
       *
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _clearBusyStateAsyncConverterLoading: EditableValueUtils._ClearBusyStateAsyncConverterLoading,
      /**
       * If we have asynchronous converter loading, the input is readonly and a loading indicator
       * is shown to the user.
       * When the converter is 100% loaded, then the field is set back to how it was.
       * That is when we do the tasks that either need a converter or need the field to be enabled,
       * like showing messagesCustom. Those tasks are done in this method.
       *
       * @memberof oj.editableValue
       * @instance
       * @protected
       */
      _AfterCreateConverterCached: EditableValueUtils._AfterCreateConverterCached,

      /**
       * Returns the readonly div HTMLElement.
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _getReadonlyDiv: EditableValueUtils._getReadonlyDiv,

      /**
       * Creates or updates the readonly div. This is called when the
       * component is initially enabled and becomes readonly.
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _createOrUpdateReadonlyDiv: EditableValueUtils._createOrUpdateReadonlyDiv,

      /**
       * Creates the readonly div. This is called when the
       * component is initially enabled and becomes readonly.
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _createReadonlyDiv: EditableValueUtils._createReadonlyDiv,

      /**
       * @memberof oj.editableValue
       * @instance
       * @private
       */
      _setReadonlyDivLabelledBy: EditableValueUtils._setReadonlyDivLabelledBy,

      /**
       * Returns the associated input container needed for component managed labels.  Subclasses can
       * override if the container is not marked with the '.oj-text-field-container' or
       * '.oj-form-control-container' selector. The
       * input elements are children of the container and a sibling to the inline messages container.
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {Element|undefined}
       */
      _GetFormControlContainer: function () {
        if (this._IsCustomElement()) {
          var selector =
            '.' + [this._GetComponentManagedBaseLabelStyleClass(), 'container'].join('-');
          return this._getRootElement().querySelector(selector);
        }
        return undefined;
      },

      /**
       * Returns if the element is a text field element or not.
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {string}
       */
      _IsTextFieldComponent: function () {
        return false;
      },

      /**
       * Returns the base selector name used to define the input container.
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {string}
       */
      _GetComponentManagedBaseLabelStyleClass: function () {
        if (this._IsTextFieldComponent()) {
          return 'oj-text-field';
        }
        return 'oj-form-control';
      },

      /**
       * For components like input number/ input date etc, where we have some icon or button beside the input text:
       * Previously, we set flex =1 on the input and the input's width will autogrow based on buttons width.
       * But in case of an inside label, the label also should grow and shrink exactly as the input
       * We can make this to work only by wrapping the input (and label in case of inside) in to a div and
       * set the flex for the div to 1.
       * Now the button or icon becomes a sibling of this div and not the input.
       *
       * @protected
       * @instance
       * @ignore
       * @return {Element}
       */
      _CreateMiddleWrapper: function () {
        // For the inside label to be assigned with the same width as input,
        // We need to put the label and the input together in a div and set flex=1 for the div.
        // This way, they both will occupy the same space as avialble after the buttons.
        var innerDivElem = document.createElement('div');
        innerDivElem.className = 'oj-text-field-middle';
        return innerDivElem;
      },

      /**
       * Resolves the labelEdge strategy type from the labelEdge property.
       * Called from the ComponentMessaging
       * class which picks which label strategy to use. For example,
       * oj-radioset with label-edge='inside' uses the InsideFormControlLabelStrategy
       * which has type 'insideformcontrol'.
       * whereas the oj-input-text with label-edige='inside' uses the InsideLabelStrategy
       * which has type 'inside'.
       * @memberof oj.editableValue
       * @instance
       * @protected
       * @return {string}
       */
      _ResolveLabelEdgeStrategyType: function () {
        var labelEdge = this.options.labelEdge;
        if (this._IsCustomElement()) {
          if (labelEdge === 'inside') {
            // Resolve the 'inside' labelEdge to 'insideformcontrol' for
            // non-text fields.
            // An 'insideformcontrol' label renders on top of the component with
            // the smaller font that matches a text-field's 'inside' label.
            if (!this._IsTextFieldComponent()) {
              labelEdge = oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL;
            }
          }
        }
        return labelEdge;
      }
    },
    true
  );

  Components.setDefaultOptions({
    // properties for all editableValue components
    editableValue: {
      displayOptions: Components.createDynamicPropertyGetter(function (context) {
        // displayOptions defaults are theme dependent
        // See also _setOption when displayOptions is changed. Need to handle
        // defaulting there as well.
        let useUserAssistanceDensity =
          (ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults') || {})
            .useUserAssistanceOptionDefault === 'use';
        var displayOptions;
        if (useUserAssistanceDensity) {
          displayOptions = {
            messages: _sDisplayOptionsRedwoodDefaults.MESSAGES,
            converterHint: _sDisplayOptionsRedwoodDefaults.CONVERTER_HINT,
            validatorHint: _sDisplayOptionsRedwoodDefaults.VALIDATOR_HINT
          };
        } else {
          displayOptions = {
            messages:
              context.containers.indexOf('ojDataGrid') >= 0 ||
              context.containers.indexOf('ojTable') >= 0
                ? ['notewindow']
                : _sDisplayOptionsAltaDefaults.MESSAGES,
            converterHint: _sDisplayOptionsAltaDefaults.CONVERTER_HINT,
            validatorHint: _sDisplayOptionsAltaDefaults.VALIDATOR_HINT
          };
        }
        displayOptions[context.isCustomElement ? 'helpInstruction' : 'title'] = ['notewindow'];
        return displayOptions;
      }),
      help: Components.createDynamicPropertyGetter(function (context) {
        // Conditionally set the defaults for custom element vs widget syntax since we expose different APIs
        if (context.isCustomElement) {
          return { instruction: '' };
        }
        return { definition: null, source: null };
      }),
      labelEdge: Components.createDynamicPropertyGetter(function (context) {
        // update the labelEdge value to theme based.
        if (context.isCustomElement) {
          return (ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults') || {}).labelEdge;
        }
        return undefined;
      }),
      userAssistanceDensity: Components.createDynamicPropertyGetter(function (context) {
        var userAssistanceDensityVar =
          context.containers.indexOf('ojDataGrid') >= 0 || context.containers.indexOf('ojTable') >= 0
            ? 'compact'
            : 'reflow';
        return userAssistanceDensityVar;
      })
    }
  });

  // ////////////////     SUB-IDS     //////////////////
  /**
   * <p>Sub-ID for the help icon element used by EditableValue components.</p>
   *
   * @ojsubid oj-label-help-icon
   * @memberof oj.editableValue
   * @ignore
   *
   * @example <caption>Get the help icon element associated with an editable value component:</caption>
   * var node = myComp.getNodeBySubId("oj-label-help-icon");
   */

  // ////////////// fragments /////////////////
  /**
   * <p>
   * <h3 id="validation-section">
   * Validation and Messaging
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
   * </h3>
   * An editable component runs validation (normal or deferred) based on the action performed on it
   * (either by end-user or page author), and the state it was in when the action occurred. Examples
   * of actions are - creating a component, user changing the value of the component by interacting
   * with it, the app setting a value programmatically, the app calling the validate() method etc. At
   * the time the action occurs, the component could already be showing errors, or can have a deferred
   * error or have no errors.
   * <p>
   * These factors also determine whether validation errors/messages get shown to the user immediately
   * or get deferred. The following sections highlight the kinds of validation that are run and how
   * messages get handled.
   * </p>
   * <h4 id="normal-validation-section">Normal Validation
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a></h4>
   * Normal validation is run in the following cases on the display value, using the converter and
   * validators (this includes async-validators) set on the component,
   * and validation errors are reported to user immediately.
   * <ul>
   * <li>When value changes as a result of user interaction all messages are cleared, including custom
   * messages added by the app, and full validation is run on the UI value. The steps performed are
   * outlined below.
   * <ol>
   * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
   * <li>If no converter is present then processing continues to next step. If a converter is
   * present, the UI value is first converted (i.e., parsed). If there is a parse error then
   * the messages are shown and processing returns.</li>
   * <li>If there are no validators setup for the component then the value is set on the component.
   * Otherwise all validators are run in sequence using the parsed value from the previous step. The
   * implicit required is run first if the component is marked required. When a validation error is
   * encountered it is remembered and the next validator in the sequence is run.
   * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
   * </li>
   * <li>At the end of the validation run if there are errors, the messages are shown
   * and processing returns. If there are async-validators, those errors are shown as soon as they
   * come in, and not until all validators, sync and async validators, are complete, does processing
   * return, that is, value and valid are updated. If there are no errors, then the
   * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
   * UI.</li>
   * </ol>
   * </li>
   * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
   * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
   * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
   * data passed from the server; this should be caught on the server.</li>
   * <li>When certain properties change through programmatic intervention by app, the component
   * determines whether it needs to run normal validation based on the state the component is in.
   * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
   * </ul>
   *
   * <h4 id="deferred-validation-section">Deferred Validation
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
   * </h4>
   * Deferred validation is run in the following cases on the component value using the implicit
   * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
   * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
   * understand how deferred messages can be shown.
   * <ul>
   *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
   *  prior to running validation.
   *  Refer to the <a href="#deferred-validators-section">Validators
   *  Participating in Deferred Validation</a> section for details.</li>
   *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
   *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
   *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
   *   after all messages and messagesCustom property are cleared.</li>
   *  <li>When certain properties change through programmatic intervention by app, the component
   *  determines whether it needs to run deferred validation based on the state the component is in.
   *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
   * </ul>
   *
   * <h4 id="mixed-validation-section">Mixed Validation
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
   * </h4>
   * Either deferred or normal validation is run in the following cases based on the state the
   * component is in and any validation errors encountered are either hidden or shown to user.
   * <ul>
   *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
   *  <li>when refresh method is called. See <a href="#refresh">refresh</a> method for details.</li>
   *  <li>when converter property changes. Not all EditableValue components have the converter property. See
   *  the sub-classes that have the converter property for details, e.g., {@link oj.ojInputText#converter}.</li>
   *  <li>when required property changes. Not all EditableValue components have the required property. See
   *  the sub-classes that have the required property for details, e.g., {@link oj.inputBase#required}.</li>
   *  <li>when validators property changes. Not all EditableValue components have the validators property. See
   *  the sub-classes that have the validators property for details, e.g., {@link oj.inputBase#validators}.</li>
   *  <li>when asyncValidators property changes. Not all EditableValue components have the asyncValidators property. See
   *  the sub-classes that have the asyncValidators property for details, e.g., {@link oj.inputBase#asyncValidators}.</li>
   *
   * </ul>
   * </p>
   *
   * <p>
   * <h3 id="deferred-messages-section">
   * Showing Deferred Messages
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
   * </h3>
   * Deferred validation messages are displayed only when page author requests for it explicitly in
   * one of the following ways:
   * <ul>
   * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
   * </ul>
   * </p>
   *
   * <p>
   * <h3 id="deferred-validators-section">
   * Validators Participating in Deferred Validation
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
   * </h3>
   * The required validator is the only validator type that participates in deferred validation.
   * The required property needs to be set to true for the required validator to run.
   * </p>
   * <p>
   * <h3 id="user-assistance-text-section">
   * User Assistance Text
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
   * </h3>
   * <p>
   * User assistive text provides guidance to help the user understand what data to enter or select.
   * </p>
   * <p>In the Redwood theme, by default all user assistance text shows inline.
   * For input components, it shows when the field takes focus. In other components
   * it shows all the time. See the user-assistance-density property for other ways
   * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
   * which when clicked will show the user assistance text in a notewindow.
   * <p>
   * <p>The JET form component properties that are used for user assistance text are help.instruction,
   * validator and converter hints, and help-hints.
   * In the Redwood theme for clarity only one user assistance text shows to the user.
   * The precedence rules are:
   * <ul>
   * <li>help.instruction shows;</li>
   * <li>if no help.instruction, then validator hint shows;</li>
   * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
   * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
   * <li>help-hints.source always shows along side the above.</li>
   * </ul>
   * </p>
   * <p>Sometimes a validator or converter hints shows that you do not want. To not show it,
   *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
   * </p>
   * <p>required and placeholder properties also can be used to guide the user.
   * In Redwood, a required field shows the word Required under the field
   * when the field is empty and does not have focus.
   * Placeholder is shown when the field is empty and has focus.
   * </p>
   * @ojfragment validationAndMessagingDoc - Used in the general section of classdesc
   * @memberof oj.editableValue
   */
  /**
   * <p>
   * For accessibility, set label-hint or associate an oj-label with the form component.
   * If there is no visible label, then to make this accessible to screen reader users,
   * set the label-hint and label-edge='none'
   * which renders an aria-label with the label-hint text.
   * If using an oj-label instead of the <code class="prettyprint">label-hint</code> attribute, then
   * put an <code>id</code> on the form component element, and set the oj-label's
   * <code>for</code> attribute to be the form component's id.
   * </p>
   *
   * @ojfragment accessibilityLabelEditableValue
   * @memberof oj.editableValue
   * @instance
   */
  /**
   * <p>
   * For accessibility, set label-hint or associate an oj-label with the form component.
   * If there is no visible label, then to make this accessible to screen reader users,
   * set the label-hint and label-edge='none' which renders an aria-label with the label-hint text.
   * If using an oj-label instead of the <code class="prettyprint">label-hint</code> attribute,
   * then put an <code>id</code> on the oj-label component element, and set the form component's
   * <code>labelled-by</code> attribute to be the oj-label component's id.
   * </p>
   *
   * @ojfragment accessibilitySetLabelEditableValue
   * @memberof oj.editableValue
   * @instance
   */
  /**
   * <p>Disabled content: JET supports an accessible luminosity contrast ratio,
   * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
   * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
   * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
   * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
   * required of enabled content, it cannot be used to convey meaningful information.<p>
   *
   * @ojfragment accessibilityDisabledEditableValue
   * @memberof oj.editableValue
   * @instance
   */
  /**
   * <p>The placeholder text is not read reliably by the screen reader. For accessibility reasons, you need to associate the text to its
   * JET form component using aria-describedby.
   * <p>
   *
   * @ojfragment accessibilityPlaceholderEditableValue
   * @memberof oj.editableValue
   * @instance
   */

  /**
   * A messaging strategy that uses an instance of ojPopup component to show and hide messaging content.
   *
   * @param {Array.<string>} displayOptions an array of messaging artifacts displayed in the popup. e.g,
   * 'messages', 'converterHints', 'validationHints', 'title'.
   * @constructor
   * @extends {oj.MessagingStrategy}
   * @private
   */
  const PopupMessagingStrategy = function (displayOptions) {
    this.Init(displayOptions);
  };

  // Classes defined here to avoid ESLint no-use-before-define requirement
  /**
   * @ignore
   */
  const PopupMessagingStrategyPoolUtils = {};

  /**
   * @ignore
   */
  const PopupMessagingStrategyUtils = {};

  /**
   * Registers the PopupMessagingStrategy constructor function with ComponentMessaging.
   *
   * @private
   */
  oj.ComponentMessaging.registerMessagingStrategy(
    oj.ComponentMessaging._STRATEGY_TYPE.NOTEWINDOW,
    PopupMessagingStrategy
  );

  // Subclass from MessagingStrategy
  oj.Object.createSubclass(PopupMessagingStrategy, oj.MessagingStrategy, 'oj.PopupMessagingStrategy');

  /**
   * Messaging popup defaults for components, by component type. A special 'default' type defines the
   * defaults for most editableValue components.
   * The following properties are available -
   * 'events' - these specify the on handlers for events that are setup to open and close popups
   * 'position' - specifies the type of element the popup is positioned against.
   * @private
   */
  PopupMessagingStrategy._DEFAULTS_BY_COMPONENT = {
    // mouseenter and mouseleave is what you want instead of mouseover/mouseout when the launcher
    // isn't a simple input. In the case of radioset and checkboxset, the launcher is the widget
    // which is the div that contains all the rows, inputs and labels. If we use mouseover/mouseout
    // in this case we are constantly opening and closing the popup (not really visible to the user,
    // but still not good for performance I'm sure) if the user moves the mouse around the different
    // dom elements within the widget.
    //
    // on touch devices: the "press" event name maps to Hammer's press event, so a touch and hold
    // will open the popup.
    ojRadioset: {
      position: 'launcher',
      // when press opens popup, the user taps elsewhere to dismiss popup
      events: { open: 'focusin mouseenter press', close: 'mouseleave' }
    },
    ojCheckboxset: {
      position: 'launcher',
      // when press opens popup, the user taps elsewhere to dismiss popup
      events: { open: 'focusin mouseenter press', close: 'mouseleave' }
    },
    // Since we now add extra dom on the input components for inline messages, we don't want to
    // position on the tip of the component root. Instead we want to position on the main part of the
    // component, which is in a lot of cases the launcher. In the case of inputDate/Time/Number,
    // it's the launcher's parent (inputDate/Time/Number wrap input and buttons with a parent).
    ojInputText: {
      position: 'launcher',
      events: { open: 'focusin' }
    },
    ojTextArea: {
      position: 'launcher',
      events: { open: 'focusin' }
    },
    ojInputPassword: {
      position: 'launcher',
      events: { open: 'focusin' }
    },
    ojSwitch: {
      position: 'launcher',
      events: { open: 'focusin mouseenter', close: 'mouseleave' }
    },
    ojSlider: {
      position: 'launcher',
      events: { open: 'focusin mouseenter', close: 'mouseleave' }
    },
    ojColorSpectrum: {
      position: 'launcher',
      events: { open: 'focusin mouseenter', close: 'mouseleave' }
    },
    ojColorPalette: {
      position: 'launcher',
      events: { open: 'focusin mouseenter', close: 'mouseleave' }
    },
    default: {
      position: 'launcher-wrapper',
      events: { open: 'focusin' }
    }
  };

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT = 'oj-form-control-hint';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_CONVERTER = 'oj-form-control-hint-converter';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_VALIDATOR = 'oj-form-control-hint-validator';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_TITLE = 'oj-form-control-hint-title';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategy._OPEN_NAMESPACE = '.ojPopupMessagingOpen';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategy._CLOSE_NAMESPACE = '.ojPopupMessagingClose';

  /**
   * Sets up a tooltip for the component instance using the messaging content provided.
   *
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @override
   * @instance
   */
  PopupMessagingStrategy.prototype.activate = function (cm) {
    PopupMessagingStrategy.superclass.activate.call(this, cm);
    this._initMessagingPopup();
  };

  /**
   * Reinitializes with the new display options and updates component messaging using the new content.
   *
   * @param {Array.<string>} newDisplayOptions
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   * @override
   */
  PopupMessagingStrategy.prototype.reactivate = function (newDisplayOptions) {
    PopupMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);
    this._updatePopupIfOpenOrComponentHasFocus();
  };

  PopupMessagingStrategy.prototype.update = function () {
    PopupMessagingStrategy.superclass.update.call(this);
    this._updatePopupIfOpenOrComponentHasFocus();
  };

  /**
   * Cleans up messages on the component and destroys any widgets it created.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   * @override
   */
  PopupMessagingStrategy.prototype.deactivate = function () {
    this._unregisterLauncherEvents();
    this._destroyTooltip();
    PopupMessagingStrategy.superclass.deactivate.call(this);
  };
  /**
   * Close the popup if it is open. EditableValue calls this from _NotifyHidden and _NotifyDetached
   * so that we don't have an open popup if the app dev hides a subtree the component is within.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype.close = function () {
    this._closePopup();
  };

  /**
   * Closes the associated notewindow popup
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._closePopup = function () {
    function doClose(resolve) {
      if (this._isPopupInitialized()) {
        if (resolve) {
          // Add an event listener to resolve the promise
          this._setActionResolver(this.$messagingContentRoot, 'close', resolve);
        }

        this.$messagingContentRoot.ojPopup('close');

        // Just return if we call ojPopup close.  The promise will be resolved
        // by the ojclose event listener.
        return;
      }

      if (resolve) {
        // Resolve the promise immediately if we didn't call ojPopup close
        resolve(true);
      }
    }

    this._queueAction(doClose.bind(this));
  };

  /**
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._initMessagingPopup = function () {
    if (!this._openPopupCallback) {
      this._registerLauncherEvents();
    }
  };

  /**
   * Add listeners for animation events.
   * We use this to delegate animation events to the editableValue component since
   * the original events are triggered on the popup, which is created internally
   * and the application cannot bind listeners to it.  By delegating the events,
   * application can bind the listeners to the component.
   *
   * @param {jQuery} messagingContentRoot - The jQuery object for the messaging root node
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._addAnimateEventListeners = function (messagingContentRoot) {
    var delegateEvent = function (newEventType, event, ui) {
      var component = this.GetComponent();
      if (component && component._trigger) {
        // always stop propagation if we have a component to delegate to
        event.stopPropagation();

        // prevent default only if the component handler says so, as indicated by
        // a return value of false.
        if (!component._trigger(newEventType, null, ui)) {
          event.preventDefault();
        }
      }
    };

    // Add animation event listeners to delegate the events to the component
    messagingContentRoot.on('ojanimatestart.notewindow', delegateEvent.bind(this, 'animateStart'));
    messagingContentRoot.on('ojanimateend.notewindow', delegateEvent.bind(this, 'animateEnd'));
  };

  /**
   * Remove listeners for animation events.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._removeAnimateEventListeners = function (messagingContentRoot) {
    messagingContentRoot.off('ojanimatestart.notewindow');
    messagingContentRoot.off('ojanimateend.notewindow');
  };

  /**
   * Set busy state on the component that invokes the notewindow.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._setBusyState = function (eventType) {
    var component = this.GetComponent();
    var jElem = component ? component.element : null;
    var domElem = jElem ? jElem[0] : null;
    var busyContext = Context.getContext(domElem).getBusyContext();
    var description = 'The page is waiting for note window ';

    if (domElem && domElem.id) {
      description += 'for "' + domElem.id + '" ';
    }
    description += 'to ' + eventType;

    return busyContext.addBusyState({ description: description });
  };

  /**
   * Set an event listener to resolve promise when popup open/close action ends.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._setActionResolver = function (
    messagingContentRoot,
    eventType,
    resolvePromise
  ) {
    var animationOption;

    // Disable animation if there are other queued actions.  Otherwise we will end
    // up with too many animation since the messaging framework keeps clearing and
    // updating the message display during validation, etc.
    if (this._actionCount > 1) {
      // Remember the original animation so that we can restore it later
      animationOption = messagingContentRoot.ojPopup('option', 'animation');
      messagingContentRoot.ojPopup('option', 'animation', null);
    }

    // Add a busy state for the component.  Even though ojpopup add busy state,
    // it is in the scope of the popup element.
    var resolveBusyState = this._setBusyState(eventType);

    // Add an one-time listener to resolve the promise
    messagingContentRoot.one('oj' + eventType, function () {
      // Restore any saved animation option
      if (animationOption) {
        messagingContentRoot.ojPopup('option', 'animation', animationOption);
      }

      resolveBusyState();
      resolvePromise(true);
    });
  };

  /**
   * Queue up popup open and close actions so that they are executed in the
   * correct order.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._queueAction = function (task) {
    if (this.GetComponent()._IsCustomElement()) {
      // Queue up the action for custom elements to avoid animation overlapping each other
      var self = this;

      var createActionPromise = function (_task) {
        var promise = new Promise(_task);
        promise.then(function () {
          self._actionCount -= 1;
        });
        return promise;
      };

      if (!this._actionCount) {
        // If there is no action in progress, create a new promise directly instead
        // of chaining to any resolved promise to avoid an extra wait state.
        this._actionCount = 1;
        this._actionPromise = createActionPromise(task);
      } else {
        this._actionCount += 1;
        this._actionPromise = this._actionPromise.then(function () {
          return createActionPromise(task);
        });
      }
    } else {
      // Invoke the action immediately for legacy components since there is no animation
      task(null);
    }
  };

  /**
   * Opens a popup. This handler is called in the context of the launcher usually the this.element or
   * some relevant node the messaging popup is associated to.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._openPopup = function (event) {
    function doOpen(resolve) {
      var domNode;
      var latestContent;
      var $launcher;

      if (this._canOpenPopup()) {
        latestContent = this._buildPopupHtml();
        if (!oj.StringUtils.isEmptyOrUndefined(latestContent)) {
          var messagingContentRoot = this._getPopupElement();
          var isPopupOpen = messagingContentRoot.ojPopup('isOpen');

          // replace popup messaging content with new content
          domNode = PopupMessagingStrategyPoolUtils.getPopupContentNode(messagingContentRoot);

          // latestContent is includes content that may come from app. It is scrubbed for illegal tags
          // before setting to innerHTML
          domNode.innerHTML = ''; // @HTMLUpdateOK
          domNode.innerHTML = latestContent; // @HTMLUpdateOK

          if (!isPopupOpen) {
            $launcher = this.GetLauncher();
            const $position = $(this.GetComponent()._GetMessagingPositionElement());
            if (event && event.type === 'press') {
              this._openPopupOnPressEvent($launcher);
            }

            if (resolve) {
              // Add an event listener to resolve the promise
              this._setActionResolver(messagingContentRoot, 'open', resolve);
            }

            messagingContentRoot.ojPopup('open', $launcher, { of: $position });

            // Just return if we call ojPopup open.  The promise will be resolved
            // by the ojopen event listener.
            return;
          } else if (isPopupOpen) {
            messagingContentRoot.ojPopup('refresh');
          }
        }
      }

      if (resolve) {
        // Resolve the promise immediately if we didn't call ojPopup open
        resolve(true);
      }
    }

    this._queueAction(doOpen.bind(this));
  };

  /**
   * This is called to open the popup on the 'press' event. E.g., ojCheckboxset and ojRadioset
   * use press to open the popup.
   * @param {Object|null} jqLauncher
   */
  PopupMessagingStrategy.prototype._openPopupOnPressEvent = function (jqLauncher) {
    this._inPressEvent = true;

    // We add these event listeners when we open the popup as a result of the 'press' event
    // and we are going to remove them when we close the popup, as well as when we unregister
    // launcher events to make doubly sure they aren't lying around.
    // / Use capture phase to make sure we cancel it before any regular bubble listeners hear it.
    jqLauncher[0].addEventListener('click', this._eatChangeAndClickOnPress, true);
    // need to eat 'change' as well. Otherwise the dialog will close on press up, and the input
    // stays unchecked.
    // This is because when the input  gets the 'change' event, it calls validate,
    // which then updates messages, and if there is no message,
    // then calls _updatePopupIfOpen, contentToShow = "", then it closes the popup.
    jqLauncher[0].addEventListener('change', this._eatChangeAndClickOnPress, true);

    // touchend/mousedown/change/click happen in fast succession on tap or press.
    // Android never fires a click event on press up, so after 50ms we clear the inPressEvent flag
    // since the _eatChangeAndClickOnPress callback never gets called for Android.
    jqLauncher.one('touchend', function () {
      // 50ms.  Make as small as possible to prevent unwanted side effects.
      setTimeout(function () {
        this._inPressEvent = false;
      }, 50);
    });
  };

  /**
   * The pressHold gesture fires a click and change event on ios after touchend.  Prevent that here.
   * @private
   */
  PopupMessagingStrategy.prototype._eatChangeAndClickOnPress = function (event) {
    // on ios:
    // if I tap quickly on an input, I get on div: touchstart/touchend/mousedown/change/click
    // if I tap and hold on an input, I get: touchstart
    // when I let up, I get: touchend/mousedown/change/click
    // on android:
    // if I tap quickly on an input, I get touchstart touchend mousedown click change
    // if I tap and hold on an input, I get touchstart/mousedown
    // when I let up, I get touchend. (no change or click like I do for ios)

    // After 'press' release of a radio or checkbox if we do not eat the the click and change events,
    // the dialog closes.
    if (this._inPressEvent) {
      // For Mobile Safari capture phase at least,
      // returning false doesn't work; must use pD() and sP() explicitly.
      event.preventDefault();
      event.stopPropagation();
      // the event order is first change, then click.
      // so when we get the click, clear the inPressEvent flag.
      if (event.type === 'click') {
        this._inPressEvent = false;
      }
    }
  };

  /**
   * Determines whether the messaging popup can be opened.
   * @return {boolean}
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._canOpenPopup = function () {
    var options = this.GetComponent().options;
    var isDisabled = options.disabled || false;
    var isReadOnly = options.readOnly || false;

    return !(isDisabled || isReadOnly);
  };

  /**
   * If the popup is already open or if component has focus,
   * its contents need to updated when update() or reactivate() is called.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._updatePopupIfOpenOrComponentHasFocus = function () {
    var contentToShow;
    var domNode;
    var isLauncherActiveElement;
    var isPopupOpen = false;
    var launcher;
    var messagingContentRoot;

    launcher = this.GetLauncher();
    if (launcher == null) {
      return;
    }
    // See if launcher contains activeElement
    isLauncherActiveElement = this.GetLauncher()[0].contains(document.activeElement);
    if (this._isPopupInitialized()) {
      messagingContentRoot = this._getPopupElement();
      isPopupOpen = messagingContentRoot.ojPopup('isOpen');
      if (isPopupOpen) {
        contentToShow = this._buildPopupHtml();
        if (contentToShow) {
          // push new content into popup
          domNode = PopupMessagingStrategyPoolUtils.getPopupContentNode(messagingContentRoot);

          // contentToShow is includes content that may come from app. It is scrubbed for illegal tags
          // before setting to innerHTML
          domNode.innerHTML = ''; // @HTMLUpdateOK
          domNode.innerHTML = contentToShow; // @HTMLUpdateOK
          messagingContentRoot.ojPopup('refresh');
        } else {
          // if there is no content to show and popup is currently open, close it.
          messagingContentRoot.ojPopup('close');
        }
      }
    } else if (isLauncherActiveElement) {
      contentToShow = this._buildPopupHtml();
      if (contentToShow) {
        // if popup is closed but focus is on activeElement re-open it
        this._openPopup(undefined);
      }
    }
  };

  /**
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._unregisterLauncherEvents = function () {
    var jqLauncher = this.GetLauncher();

    // Remove event handlers setup on launcher
    jqLauncher.off(PopupMessagingStrategy._OPEN_NAMESPACE);
    jqLauncher.off(PopupMessagingStrategy._CLOSE_NAMESPACE);
    jqLauncher[0].removeEventListener('click', this._eatChangeAndClickOnPress, true);
    jqLauncher[0].removeEventListener('change', this._eatChangeAndClickOnPress, true);

    if (DomUtils.isTouchSupported()) {
      this.releaseResources();
      jqLauncher.off('contextmenu', this._eatContextMenuOnOpenPopupListener);
      this._eatContextMenuOnOpenPopupListener = null;
      this._inPressEvent = null;
    }
    this._openPopupCallback = null;
    this._closePopupCallback = null;
  };

  /**
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._registerLauncherEvents = function () {
    var closeEvents;
    var closePopupCallback;
    var jqLauncher = this.GetLauncher();
    var nonPressOpenEvents;

    const events = this._getPopupEventNamesToRegisterForComp();

    // 1. associate the ojPopup component to wrapper <div> for popup content
    // 2. wire up on() event handlers for registered events that open and close popup. E.g., focusin.
    // 3. autoDismissal happens automatically when focus leaves component. For other events like
    // mouseover it's required to call off()
    if (events.open) {
      if (!this._openPopupCallback) {
        this._openPopupCallback = this._openPopup.bind(this);
      }

      // separate out press event, namespace the events string, and attach event handler
      const needsPressEvent = this._needsPressEvent(events);
      nonPressOpenEvents = this._getNamespacedEvents(
        events.open.replace('press', ''),
        PopupMessagingStrategy._OPEN_NAMESPACE
      );
      jqLauncher.on(nonPressOpenEvents, this._openPopupCallback);

      // The pressHold gesture also fires a contextmenu event on Windows 10 touch.
      // Prevent that here for components that use 'press' for popup messaging as
      // the context menu causes the popup message window to close. Note that this
      // means the context menu will be disabled for these components.
      if (DomUtils.isTouchSupported() && needsPressEvent) {
        this._eatContextMenuOnOpenPopupListener = function () {
          return false;
        };

        jqLauncher.on('contextmenu', this._eatContextMenuOnOpenPopupListener);

        this.registerHammerOpenCallbackOnLauncher();
      }
    }

    if (events.close) {
      closePopupCallback = this._closePopupCallback;
      if (!closePopupCallback) {
        closePopupCallback = this._closePopup.bind(this);
        this._closePopupCallback = closePopupCallback;
      }

      closeEvents = this._getNamespacedEvents(events.close, PopupMessagingStrategy._CLOSE_NAMESPACE);
      jqLauncher.on(closeEvents, closePopupCallback);
    }
  };

  /**
   * Symmetrical method to releaseResources. Sets up resources that get
   * removed in releaseResources.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype.setupResources = function () {
    const events = this._getPopupEventNamesToRegisterForComp();
    const needsPressEvent = this._needsPressEvent(events);
    if (DomUtils.isTouchSupported() && needsPressEvent) {
      this.registerHammerOpenCallbackOnLauncher();
    }
  };

  /**
   * Register Hammer Press Event. Make sure you are on touch and you
   * need the press event before calling this function.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype.registerHammerOpenCallbackOnLauncher = function () {
    const jqLauncher = this.GetLauncher();
    if (jqLauncher == null) {
      return;
    }
    // for radios and checkboxes, on ios, press hold brings up popup, but release closes it
    // and checks it, so in this case we have to eat the click/change events. this happens
    // in the openPopupCallback
    const hammerOptions = {
      recognizers: [[Hammer.Press, { time: 750 }]]
    };
    jqLauncher.ojHammer(hammerOptions).on('press', this._openPopupCallback);
  };

  /**
   * Releases resources that would otherwise leak memory if they were not released
   * when the component's dom is removed.
   * For example, Hammer events are put on the document and will result in
   * detached dom memory leak if not removed.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype.releaseResources = function () {
    PopupMessagingStrategy.superclass.update.call(this);
    const events = this._getPopupEventNamesToRegisterForComp();
    const needsPressEvent = this._needsPressEvent(events);
    if (DomUtils.isTouchSupported() && needsPressEvent) {
      const jqLauncher = this.GetLauncher();
      jqLauncher.off('press').ojHammer('destroy');
    }
  };

  /**
   * Turn the events string into an array, add namespace, and turn it back into a string.
   * @param {string} events e.g., "focusin mousedown"
   * @param {string} namespace the namespace that starts with a dot
   * @return {string|null} the events string that is namespaced.
   * e.g., "focusin.ojPopupMessagingOpen mousedown.ojPopupMessagingOpen"
   * @private
   */
  PopupMessagingStrategy.prototype._getNamespacedEvents = function (events, namespace) {
    var eventsArray;
    var namespacedEventsArray;
    var length;

    if (events === '' || namespace === '') {
      return events;
    }

    eventsArray = events.split(' ');
    length = eventsArray.length;
    namespacedEventsArray = [];

    for (var i = 0; i < length; i++) {
      // ignore ""
      if (eventsArray[i]) {
        namespacedEventsArray.push(eventsArray[i] + namespace);
      }
    }

    return namespacedEventsArray.join(' ');
  };

  /**
   * Returns the popup position options.
   * Components like radio and checkboxset use the launcher, which is the inputs.
   * Since we now add extra dom for inline messages, we don't want to position
   * on the tip of the component root. Instead we want to position on the main part of the component,
   * which is in a lot of cases the launcher. In the case of inputDate/Time/Number, it's the launcher's
   * parent.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._getPopupPosition = function () {
    var compDefaultPosition;
    var compDefaults;
    var launcher;
    var popupPositionOptions;

    compDefaults = PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName];
    compDefaultPosition = compDefaults
      ? compDefaults.position
      : PopupMessagingStrategy._DEFAULTS_BY_COMPONENT.default.position;

    if (compDefaultPosition) {
      if (compDefaultPosition === 'launcher') {
        launcher = this.GetLauncher();
      } else if (compDefaultPosition === 'launcher-wrapper') {
        launcher = this.GetLauncher().parent();
      }
    }
    // should never get here since the _DEFAULTS_BY_COMPONENTS["default"] should cover it.
    if (!launcher) {
      launcher = this.GetComponent().widget();
    }

    popupPositionOptions = {
      my: 'start bottom',
      at: 'end top',
      collision: 'flipcenter',
      of: launcher
    };
    return popupPositionOptions;
  };

  /**
   * Returns the events
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._getPopupEventNamesToRegisterForComp = function () {
    const compDefaults =
      PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName];
    return compDefaults
      ? compDefaults.events
      : PopupMessagingStrategy._DEFAULTS_BY_COMPONENT.default.events;
  };

  /**
   * Returns true if it needs a press event.
   *
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._needsPressEvent = function (events) {
    if (events && events.open) {
      return events.open.indexOf('press') !== -1;
    }
    return false;
  };

  /**
   * Returns a jquery element that a messaging popup is bound to.
   *
   * @return {jQuery!} messaging popup pool container
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._getPopupElement = function () {
    var popup;
    var position;

    if (this.$messagingContentRoot) {
      return this.$messagingContentRoot;
    }

    popup = PopupMessagingStrategyPoolUtils.getNextFreePopup();
    position = this._getPopupPosition();
    popup.ojPopup('option', 'position', position);
    popup.ojPopup('option', 'beforeClose', this._popupBeforeCloseCallback.bind(this));
    popup.ojPopup('option', 'close', this._popupCloseCallback.bind(this));
    popup.ojPopup('option', 'open', this._popupOpenCallback.bind(this));

    // Use default animation only for custom elements
    if (this.GetComponent()._IsCustomElement()) {
      // Get the default animation
      var defaultAnimations = (ojthemeutils.parseJSONFromFontFamily('oj-messaging-popup-option-defaults') || {})
        .animation;
      defaultAnimations.actionPrefix = 'notewindow';
      popup.ojPopup('option', 'animation', defaultAnimations);

      this._addAnimateEventListeners(popup);
    } else {
      popup.ojPopup('option', 'animation', null);
    }

    this.$messagingContentRoot = popup;
    return this.$messagingContentRoot;
  };

  /**
   * Popup open event listener that changes the popups autoDismiss to focusLoss
   * in a timeout of 10ms.  This timeout period gives the browser time to fire
   * events that might follow a click such as a focus event.  This is to allow
   * validation by a button versus a component instance.
   *
   * @param {jQuery.event=} event
   * @memberof! oj.PopupMessagingStrategy
   * @private
   */
  PopupMessagingStrategy.prototype._popupOpenCallback = function (event) {
    var target = $(event.target);
    var self = this;
    window.setTimeout(function () {
      if (Components.isComponentInitialized(target, 'ojPopup')) {
        target.ojPopup('option', 'autoDismiss', 'focusLoss');
      } else {
        delete self.$messagingContentRoot;
      }
    }, 10);
  };

  /**
   * Popup beforeClose event listener that will add busy state to the component
   * @param {jQuery.event=} event
   * @memberof! oj.PopupMessagingStrategy
   * @private
   */
  PopupMessagingStrategy.prototype._popupBeforeCloseCallback = function () {
    this._resolveBusyState = this._setBusyState('close');
  };

  /**
   * Popup closed event listener that will reset the popups state and free it into the
   * pool of available messaging popups.
   * @param {jQuery.event=} event
   * @memberof! oj.PopupMessagingStrategy
   * @private
   */
  PopupMessagingStrategy.prototype._popupCloseCallback = function (event) {
    var jqLauncher = this.GetLauncher();
    var target = $(event.target);

    this._removeAnimateEventListeners(target);

    if (Components.isComponentInitialized(target, 'ojPopup')) {
      target.ojPopup('option', 'autoDismiss', 'none');
      target.ojPopup('option', 'open', null);
      target.ojPopup('option', 'close', null);
      target.ojPopup('option', 'beforeClose', null);
    }

    // Check that the launcher is still there when removing listeners
    if (jqLauncher && jqLauncher[0]) {
      jqLauncher[0].removeEventListener('click', this._eatChangeAndClickOnPress, true);
      jqLauncher[0].removeEventListener('change', this._eatChangeAndClickOnPress, true);
    }

    this.$messagingContentRoot = null;
    this._inPressEvent = null;

    var popupContent = PopupMessagingStrategyPoolUtils.getPopupContentNode(target);
    popupContent.innerHTML = ''; // @HTMLUpdateOK

    if (this._resolveBusyState) {
      this._resolveBusyState();
      this._resolveBusyState = null;
    }
  };

  /**
   * @memberof! oj.PopupMessagingStrategy
   * @private
   * @instance
   */
  PopupMessagingStrategy.prototype._destroyTooltip = function () {
    this._closePopup();
    PopupMessagingStrategyPoolUtils.destroyFreePopup();
  };

  /**
   * Returns the content to show inside popup.
   * @private
   * @return {String|string} content
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._buildPopupHtml = function () {
    var addSeparator = false;
    var document = this.GetComponent().document[0];
    var nwContent = [];
    var nwHtml = '';

    if (this.ShowMessages()) {
      nwContent.push(this._buildMessagesHtml(document));
    }

    if (this.ShowConverterHint() || this.ShowValidatorHint() || this.ShowTitle()) {
      nwContent.push(this._buildHintsHtml(document));
    }

    nwContent.forEach(function (content) {
      if (content) {
        if (addSeparator) {
          nwHtml = nwHtml.concat(PopupMessagingStrategyUtils.getSeparatorHtml(document));
        } else {
          addSeparator = true;
        }

        nwHtml = nwHtml.concat(content);
      }
    });

    return nwHtml;
  };

  /**
   * Returns the messages html (e.g., error messages, confirmation messages), not hints
   * @param {Document} document
   * @return {string} content
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._buildMessagesHtml = function (document) {
    var content = '';
    var componentLabel;
    var maxSeverity = this.GetMaxSeverity();
    var messages;
    var renderSeveritySelectors = false;

    if (this.HasMessages()) {
      messages = this.GetMessages();
      componentLabel = this._getMessagingContent().label;
      content = PopupMessagingStrategyUtils.buildMessagesHtml(
        document,
        messages,
        maxSeverity,
        renderSeveritySelectors,
        componentLabel
      );
    }
    return content;
  };

  /**
   * All hints including title
   * @param {Document} document
   * @return {string} html content for all hints.
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._buildHintsHtml = function (document) {
    var hint;
    var hints = [];
    var hintsHtml = '';
    var i;

    if (this.ShowConverterHint()) {
      hints = this.GetConverterHint();
      hint = hints.length ? hints[0] : '';
      hintsHtml += PopupMessagingStrategyUtils.buildHintHtml(
        document,
        PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_CONVERTER,
        hint,
        false,
        PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT
      );
    }

    if (this.ShowValidatorHint()) {
      hints = this.GetValidatorHints();
      for (i = 0; i < hints.length; i++) {
        hintsHtml += PopupMessagingStrategyUtils.buildHintHtml(
          document,
          PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_VALIDATOR,
          hints[i],
          false,
          PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT
        );
      }
    }

    if (this.ShowTitle()) {
      hintsHtml += PopupMessagingStrategyUtils.buildHintHtml(
        document,
        PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT_TITLE,
        this.GetTitle(),
        true,
        PopupMessagingStrategy._SELECTOR_FORMCONTROL_HINT
      );
    }

    return hintsHtml ? "<div class='oj-form-control-hints'>" + hintsHtml + '</div>' : '';
  };

  /**
   * Determines if there is a message popup currently associated with the component
   * strategy.
   * @return {boolean}
   * @private
   * @memberof oj.PopupMessagingStrategy
   * @instance
   */
  PopupMessagingStrategy.prototype._isPopupInitialized = function () {
    // is(":oj-popup") finds the popup component if it exists
    return this.$messagingContentRoot
      ? Components.isComponentInitialized(this.$messagingContentRoot, 'ojPopup')
      : false;
  };

  /**
   * Renders the html content for a single hint.
   * @param {Document} document
   * @param {string} selector
   * @param {string} hintText
   * @param {boolean} htmlAllowed
   * @param {string} formControlSelectors
   *
   * @return {string} html content for a single hint.
   * @public
   */
  PopupMessagingStrategyUtils.buildHintHtml = function (
    document,
    selector,
    hintText,
    htmlAllowed,
    formControlSelectors
  ) {
    var titleDom;

    if (hintText) {
      titleDom = document.createElement('div');
      var selectors = formControlSelectors.split(' ');

      for (var i = 0, len = selectors.length; i < len; ++i) {
        titleDom.classList.add(selectors[i]);
      }

      titleDom.classList.add(selector);
      PopupMessagingStrategyUtils._appendTextDom(
        titleDom,
        PopupMessagingStrategyUtils.GetTextDom(document, hintText, htmlAllowed)
      );
    }

    return titleDom ? titleDom.outerHTML : ''; // @HTMLUpdateOK
  };

  /**
   * @param {number} severity
   * @returns (string} translated string for the severity
   * @public
   */
  PopupMessagingStrategyUtils.getSeverityTranslatedString = function (severity) {
    var sevTypeStr;
    // get the translated string for the severity
    switch (severity) {
      case Message.SEVERITY_LEVEL.FATAL:
        sevTypeStr = Translations.getTranslatedString('oj-message.fatal');
        break;
      case Message.SEVERITY_LEVEL.ERROR:
        sevTypeStr = Translations.getTranslatedString('oj-message.error');
        break;
      case Message.SEVERITY_LEVEL.WARNING:
        sevTypeStr = Translations.getTranslatedString('oj-message.warning');
        break;
      case Message.SEVERITY_LEVEL.INFO:
        sevTypeStr = Translations.getTranslatedString('oj-message.info');
        break;
      case Message.SEVERITY_LEVEL.CONFIRMATION:
        sevTypeStr = Translations.getTranslatedString('oj-message.confirmation');
        break;
      default:
        break;
    }

    return sevTypeStr;
  };

  /**
   * @param {Document} document
   * @returns {string}
   * @public
   */
  PopupMessagingStrategyUtils.getSeparatorHtml = function (document) {
    var jSeparatorDom;
    jSeparatorDom = $(document.createElement('hr'));

    return jSeparatorDom ? jSeparatorDom.get(0).outerHTML : ''; // @HTMLUpdateOK
  };

  /**
   * Returns the messages html (e.g., error messages, confirmation messages), not hints
   * @param {Document} document
   * @param {Array} messages
   * @param {number} maxSeverity
   * @param {boolean} renderSeveritySelectors
   * @param {string} componentLabel
   * @return {string} content
   * @private
   * @memberof oj.PopupMessagingStrategyUtils
   * @instance
   */
  PopupMessagingStrategyUtils.buildMessagesHtml = function (
    document,
    messages,
    maxSeverity,
    renderSeveritySelectors,
    componentLabel
  ) {
    var content = '';
    var detail;
    var i;
    var j;
    var message;
    var messagesByType = [];
    var messagesByTypes = {};
    var messageObj;
    var severityLevel;
    var severityStr;
    var summary;

    // Step1: build an indexed array of messages by severity level.
    for (i = 0; i < messages.length; i++) {
      message = messages[i];

      if (!(message instanceof Message)) {
        messageObj = new Message(message.summary, message.detail, message.severity);
      } else {
        messageObj = message;
      }

      severityLevel = Message.getSeverityLevel(messageObj.severity);
      if (!messagesByTypes[severityLevel]) {
        messagesByTypes[severityLevel] = [];
      }

      messagesByTypes[severityLevel].push(messageObj);
    }

    // Step 2: starting with maxSeverity level build messages with decreasing severity
    for (i = maxSeverity; i >= Message.SEVERITY_LEVEL.CONFIRMATION; i--) {
      messagesByType = messagesByTypes[i] || [];

      for (j = 0; j < messagesByType.length; j++) {
        message = messagesByType[j];

        severityLevel = Message.getSeverityLevel(message.severity);
        severityStr = PopupMessagingStrategyUtils.getSeverityTranslatedString(severityLevel);
        summary = message.summary || severityStr;

        // if detail is empty we don't care to duplicate summary. also detail if present can be
        // formatted html content (ADF feature)
        detail = message.detail || '';
        content = content.concat(
          PopupMessagingStrategyUtils.buildMessageHtml(
            document,
            summary,
            detail,
            severityLevel,
            renderSeveritySelectors,
            componentLabel
          )
        );
      }
    }
    return content;
  };

  /**
   * Builds the HTML content for a single message
   * @param {Document} document
   * @param {string} summary
   * @param {string} detail
   * @param {number} severityLevel
   * @param {boolean} addSeverityClass
   * @param {string} componentLabel
   * @returns {string}
   * @public
   */
  PopupMessagingStrategyUtils.buildMessageHtml = function (
    document,
    summary,
    detail,
    severityLevel,
    addSeverityClass,
    componentLabel
  ) {
    var msgContent;
    var msgDetail;
    var msgDom;
    var msgIcon;
    var msgSummary;
    var msgComponentLabel;
    var severityStr = PopupMessagingStrategyUtils.getSeverityTranslatedString(severityLevel);

    // build message
    // (hidden-accessible) <Component Label>
    // (x) <Summary Text>
    // <Detail Text>
    msgDom = document.createElement('div');
    msgDom.classList.add(PopupMessagingStrategyUtils._SELECTOR_MESSAGE);

    if (addSeverityClass) {
      var severityClasses =
        PopupMessagingStrategyUtils._getSeveritySelector(severityLevel).split(' ');

      for (var i = 0, slen = severityClasses.length; i < slen; ++i) {
        msgDom.classList.add(severityClasses[i]);
      }
    }

    // build hidden accessible component label if a label is provided
    if (componentLabel) {
      msgComponentLabel = document.createElement('span');
      msgComponentLabel.classList.add('oj-helper-hidden-accessible');
      msgComponentLabel.textContent = componentLabel;
      msgDom.appendChild(msgComponentLabel); // @HTMLUpdateOK
    }

    // build msg icon
    msgIcon = document.createElement('span');
    var severityIconClasses =
      PopupMessagingStrategyUtils._getSeverityIconSelector(severityLevel).split(' ');

    for (var j = 0, silen = severityIconClasses.length; j < silen; ++j) {
      msgIcon.classList.add(severityIconClasses[j]);
    }

    if (severityStr == null) {
      msgIcon.removeAttribute('title');
    } else {
      msgIcon.setAttribute('title', severityStr);
    }

    msgIcon.setAttribute('role', 'img');

    msgDom.appendChild(msgIcon); // @HTMLUpdateOK

    // build msg content which includes summary and detail
    msgContent = document.createElement('span');
    msgContent.classList.add(PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONTENT);

    if (
      (ojthemeutils.parseJSONFromFontFamily('oj-messaging-popup-option-defaults') || {})
        .messageSummaryOptionDefault === 'header'
    ) {
      msgSummary = document.createElement('div');
      msgSummary.classList.add(PopupMessagingStrategyUtils._SELECTOR_MESSAGE_SUMMARY);
      msgSummary.textContent = summary;

      msgContent.appendChild(msgSummary); // @HTMLUpdateOK
    }

    if (detail) {
      // detail text allows html content. So scrub it before setting it.
      var detailDom = PopupMessagingStrategyUtils.GetTextDom(document, detail, true);
      msgDetail = document.createElement('div');

      msgDetail.classList.add(PopupMessagingStrategyUtils._SELECTOR_MESSAGE_DETAIL);
      PopupMessagingStrategyUtils._appendTextDom(msgDetail, detailDom);
      msgContent.appendChild(msgDetail); // @HTMLUpdateOK
    }

    msgDom.appendChild(msgContent); // @HTMLUpdateOK

    return msgDom.outerHTML; // @HTMLUpdateOK
  };

  /**
   * @param {number} severity
   * @return {string} the icon selector for the severity
   * @private
   */
  PopupMessagingStrategyUtils._getSeverityIconSelector = function (severity) {
    var sevIconStr;
    // get the icon selector for the severity
    switch (severity) {
      case Message.SEVERITY_LEVEL.FATAL:
        sevIconStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR_ICON;
        break;
      case Message.SEVERITY_LEVEL.ERROR:
        sevIconStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR_ICON;
        break;
      case Message.SEVERITY_LEVEL.WARNING:
        sevIconStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING_ICON;
        break;
      case Message.SEVERITY_LEVEL.INFO:
        sevIconStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO_ICON;
        break;
      case Message.SEVERITY_LEVEL.CONFIRMATION:
        sevIconStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION_ICON;
        break;
      default:
        break;
    }

    return PopupMessagingStrategyUtils._DEFAULT_STATUS_ICON_SELECTORS + sevIconStr;
  };

  /**
   * @param {number} severity
   * @return {string} the style selector for the severity
   * @private
   */
  PopupMessagingStrategyUtils._getSeveritySelector = function (severity) {
    var sevSelectorStr;
    // get the icon selector for the severity
    switch (severity) {
      case Message.SEVERITY_LEVEL.FATAL:
        sevSelectorStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR;
        break;
      case Message.SEVERITY_LEVEL.ERROR:
        sevSelectorStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR;
        break;
      case Message.SEVERITY_LEVEL.WARNING:
        sevSelectorStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING;
        break;
      case Message.SEVERITY_LEVEL.INFO:
        sevSelectorStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO;
        break;
      case Message.SEVERITY_LEVEL.CONFIRMATION:
      default:
        sevSelectorStr = PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION;
        break;
    }

    return sevSelectorStr;
  };

  /**
   *  if content is html clean html by allowing only legal tags before returning, to safeguard from
   *  script injection errors.
   *
   * @param {Document} document
   * @param {string} value
   * @param {boolean=} htmlAllowed if value can have html content
   *
   * @return {Element} dom node containing the scrubbed hint
   * @public
   */
  PopupMessagingStrategyUtils.GetTextDom = function (document, value, htmlAllowed) {
    var textDom = null;

    if (oj.StringUtils.isString(value)) {
      if (htmlAllowed && DomUtils.isHTMLContent(value)) {
        // strip out html start/end tags
        textDom = DomUtils.cleanHtml(value.substring(6, value.length - 7));
      } else {
        textDom = document.createElement('span');
        textDom.textContent = value;
      }
    }

    return textDom;
  };

  /**
   * This function can append dom elements or HTML text, similar to how jquery append() works.  It assumes that the html
   * has already been cleaned.
   * @param {Element} parentElement The parent dom element that the dom element or html text is appended to.
   * @param {String|Element} textDom The dom element or HTML text to append
   * @private
   */
  PopupMessagingStrategyUtils._appendTextDom = function (parentElement, textDom) {
    if (oj.StringUtils.isString(textDom)) {
      // eslint-disable-next-line no-param-reassign
      parentElement.innerHTML = textDom; // @HTMLUpdateOK
    } else {
      parentElement.appendChild(textDom);
    }
  };

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._DEFAULT_STATUS_ICON_SELECTORS =
    'oj-component-icon oj-message-status-icon ';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE = 'oj-message';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_SUMMARY = 'oj-message-summary';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_DETAIL = 'oj-message-detail';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONTENT = 'oj-message-content';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR_ICON = 'oj-message-error-icon';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING_ICON = 'oj-message-warning-icon';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO_ICON = 'oj-message-info-icon';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION_ICON = 'oj-message-confirmation-icon';

  // new theming keys so that we can style the different types of messages differently. Like,
  // the background-color can be light red for error. This style will go on the same dom node
  // as the oj-message selector.
  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_ERROR = 'oj-message-error';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_WARNING = 'oj-message-warning';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_INFO = 'oj-message-info';

  /**
   * @private
   * @const
   * @type {string}
   */
  PopupMessagingStrategyUtils._SELECTOR_MESSAGE_CONFIRMATION = 'oj-message-confirmation';

  /**
   * @public
   * @returns {jQuery} popup taken or created from the free pool
   */
  PopupMessagingStrategyPoolUtils.getNextFreePopup = function () {
    var pool = PopupMessagingStrategyPoolUtils._getPool();
    var popups = pool.find('.' + PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING);
    var popup;

    if (popups.length === 0) {
      popup = $(PopupMessagingStrategyPoolUtils._getPopupContentHtml());
      popup[0].style.display = 'none';
      // popup is an empty div
      popup.appendTo(pool); // @HTMLUpdateOK
      var popupOptions = {
        initialFocus: 'none',
        tail: 'simple',
        autoDismiss: 'none',
        modality: 'modeless',
        animation: { open: null, close: null }
      };
      popup.ojPopup(popupOptions);
    } else {
      popup = $(popups[0]);
    }

    return popup;
  };

  /**
   * Passed in the root dom element of the message popup and returns the content element.
   *
   * @param {jQuery} popup root element
   * @returns {Element} content element of message popup
   */
  PopupMessagingStrategyPoolUtils.getPopupContentNode = function (popup) {
    return popup.find('.' + PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING_CONTAINER)[0];
  };

  /**
   * @public
   */
  PopupMessagingStrategyPoolUtils.destroyFreePopup = function () {
    var popup;
    if (PopupMessagingStrategyPoolUtils._getFreePoolCount() > 0) {
      // if the message popup is open, remove it.
      // if there is at least one popup in the pool, remove it.
      popup = PopupMessagingStrategyPoolUtils.getNextFreePopup();
      var el = popup[0];
      popup.ojPopup('destroy');
      el.parentNode.removeChild(el);
    }
  };

  /**
   * Returns a div appended to the body that is a common pool of notewindow popups
   * used internally by editable value holders.
   *
   * @return {jQuery!} messaging popup pool container
   * @private
   */
  PopupMessagingStrategyPoolUtils._getPool = function () {
    /** @type {jQuery!} */
    var pool = $('#' + PopupMessagingStrategyPoolUtils._MESSAGING_POPUP_POOL_ID);
    if (pool.length > 0) {
      return pool;
    }

    pool = $('<div>');
    var poolElem = pool[0];
    poolElem.setAttribute('id', PopupMessagingStrategyPoolUtils._MESSAGING_POPUP_POOL_ID);
    poolElem.setAttribute('role', 'presentation');
    document.body.appendChild(poolElem); // @HTMLUpdateOK

    return pool;
  };

  /**
   * @return {number} number of unused popup in the pool
   * @private
   */
  PopupMessagingStrategyPoolUtils._getFreePoolCount = function () {
    var pool = PopupMessagingStrategyPoolUtils._getPool();
    var popups = pool.find('.' + PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING);
    return popups.length;
  };

  /**
   * @return {string} messaging popup html
   * @private
   */
  PopupMessagingStrategyPoolUtils._getPopupContentHtml = function () {
    return (
      '<div class="' +
      PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING +
      '">' +
      '<div class="' +
      PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING_CONTAINER +
      '"></div>' +
      '</div>'
    );
  };

  /**
   * @const
   * @private
   * @type {string}
   */
  PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING_CONTAINER = 'oj-messaging-popup-container';

  /**
   * @const
   * @private
   * @type {string}
   */
  PopupMessagingStrategyPoolUtils._SELECTOR_MESSAGING = 'oj-messaging-popup';

  /**
   * @const
   * @private
   * @type {string}
   */
  PopupMessagingStrategyPoolUtils._MESSAGING_POPUP_POOL_ID = '__oj_messaging_popup_pool';

  /**
   * Adapter for handling inline Help and Hints text.
   * Extends the MessagingStrategy which does more now than messages.
   *
   * @extends {oj.MessagingStrategy}
   * @protected
   * @constructor
   * @since 9.0.0
   * @class InlineHelpHintsStrategy
   * @ignore
   * @ojtsignore
   * @param {Array.<string>} displayOptions an array of messaging artifacts that are
   * displayed as an inside label for text fields.
   * For LabelStrategies this is always only labelEdge.
   */
  const InlineHelpHintsStrategy = function (displayOptions, parentElement) {
    this.Init(displayOptions);
    this._userAssistanceDivElement = parentElement;
  };

  const OJ_HAS_HELPHINTS_STYLECLASS = 'oj-has-helphints';

  /**
   * Registers the InlineHelpHintsStrategy constructor function with ComponentMessaging.
   * No need to register since we are not creating this strategy on from ComponentMessaging.
   * InlineUserAssistanceStrategy creates it.
   * @private
   */
  // ComponentMessaging
  //    .registerMessagingStrategy('inlinehelphints',
  //     InlineHelpHintsStrategy);

  // Subclass from MessagingStrategy
  oj.Object.createSubclass(InlineHelpHintsStrategy, oj.MessagingStrategy, 'InlineHelpHintsStrategy');

  /**
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @public
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @override
   */
  InlineHelpHintsStrategy.prototype.activate = function (cm) {
    InlineHelpHintsStrategy.superclass.activate.call(this, cm);
    this._createInlineHelpHints();
  };

  /**
   * This gets called when display-options changes. It may be that they set
   * display-options.validator-hints='none', so then if validator hints were
   * showing they won't show anymore.
   * @param {Array.<string>} newOptions
   * @public
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @override
   */
  InlineHelpHintsStrategy.prototype.reactivate = function (newOptions, parentElement) {
    InlineHelpHintsStrategy.superclass.reactivate.call(this, newOptions);
    this._userAssistanceDivElement = parentElement;
    // sets up dom and focusin handlers
    var containerRootExists = this._isContainerRootDomInDocument();
    if (!containerRootExists) {
      this._createInlineHelpHints();
    }
  };

  /**
   * @param {Object=} content the messaging content object. If it contains validityState, then
   * this means the component has messaging content.
   * @return {boolean}
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @oublic
   * @override
   */
  // eslint-disable-next-line no-unused-vars
  InlineHelpHintsStrategy.prototype.shouldUpdate = function (content) {
    // EditableValue updates messaging when help.instruction (aka title), validator hint,
    // and converter hint are changed.
    // for help-hints, we have set a helpHintsChanged listener, see
    // InlineHelpHintsStrategy.prototype._createHelpHintsAttributeEventHandlers
    let updateTitle = !!(content && content.title !== undefined);
    let updateValidatorHint = !!(content && content.validatorHint !== undefined);
    let updateConverterHint = !!(content && content.converterHint !== undefined);
    return updateTitle || updateValidatorHint || updateConverterHint;
  };

  /**
   * Updates component with instance using the content provided. One condition when this gets called
   * is when we fetch the async validator hint to show it, but since it is async, it doesn't come back
   * serially, so instead update is called when it is ready. Go ahead and update the inline help hints
   * right away since you could already be in the focusinhandler at that point.
   * this also gets called from EditableValue when help.instruction attribute changes.
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @public
   * @override
   */
  InlineHelpHintsStrategy.prototype.update = function () {
    InlineHelpHintsStrategy.superclass.update.call(this);
    this._updateInlineHelpHints();
  };

  /**
   * Cleans up dom on the component and removes any event listeners it created.
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @public
   * @override
   */
  InlineHelpHintsStrategy.prototype.deactivate = function () {
    var component = this.GetComponent();
    var element = component._getRootElement();
    this._removeHelpHintsContainerAndContent();

    // if we created a event handler then we know we have to delete them here.
    if (this._focusinCallback) {
      this._deleteFocusEventHandlers(element);
    }

    this._deleteHelpHintsAttributeEventHandlers(element);

    InlineHelpHintsStrategy.superclass.deactivate.call(this);
  };

  /**
   * Creates the dom if showHelpHints is 'always' (like for radioset)
   * and adds focus/helpHints attributes event listeners on the component.
   * Focus in will create the dom and focus out will remove the dom.
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @private
   */
  InlineHelpHintsStrategy.prototype._createInlineHelpHints = function () {
    var component = this.GetComponent();

    let showHelpHints = component._ShowHelpHints();
    // always is for form comps like radioset/checkboxset, focus is for
    // inputtext, etc.
    if (showHelpHints === 'always') {
      // if showHelpHints is 'focus', then we create the content on the first focusin so that
      // we can delay getting validation hints.
      // otherwise add content now.
      // It is possible there is no content to show.
      this._addHelpHintsContent(component);
    }

    if (showHelpHints === 'focus') {
      // the help container gets created in focusin and removed in focusout
      this._createFocusEventHandlers(component);
    }
    this._createHelpHintsAttributeEventHandlers(component);
  };

  /**
   * Creates the focusevent handlers.
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @private
   */
  InlineHelpHintsStrategy.prototype._createFocusEventHandlers = function (component) {
    var element = component._getRootElement();
    this._focusinCallback = InlineHelpHintsStrategy._focusinHandler.bind(this, component);
    element.addEventListener('focusin', this._focusinCallback);
    this._focusoutCallback = InlineHelpHintsStrategy._focusoutHandler.bind(this);
    element.addEventListener('focusout', this._focusoutCallback);
  };

  InlineHelpHintsStrategy.prototype._deleteFocusEventHandlers = function (element) {
    element.removeEventListener('focusin', this._focusinCallback);
    delete this._focusinCallback;
    element.removeEventListener('focusout', this._focusoutCallback);
    delete this._focusoutCallback;
  };

  /**
   * Creates the helpHints handlers for help-hints.definition and help-hints.source changes
   * @param {Object} component form component
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @private
   */
  InlineHelpHintsStrategy.prototype._createHelpHintsAttributeEventHandlers = function (component) {
    var element = component._getRootElement();
    this._helpHintsChangedCallback = InlineHelpHintsStrategy._helpHintsChangedHandler.bind(this);
    element.addEventListener('helpHintsChanged', this._helpHintsChangedCallback);
  };

  InlineHelpHintsStrategy.prototype._deleteHelpHintsAttributeEventHandlers = function (element) {
    element.removeEventListener('helpHintsChanged', this._helpHintsChangedCallback);
    delete this._helpHintsChangedCallback;
  };

  /**
   * @return {Element} help hints inline container dom element, if it exists,
   * null otherwise. It is the oj-helphints-inline-container dom element.
   * This may be a child of the user assistance dom element or not because
   * radioset/checkboxset it is not since it is under the label, so start
   * with root
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @private
   */
  InlineHelpHintsStrategy.prototype._getHelpHintsInlineContainer = function (rootElem) {
    return rootElem.querySelector('.oj-helphints-inline-container');
  };

  /**
   * Returns true if the div exists. This is needed
   * because it is possible that components delete their dom, including
   * the inline dom, which means the this.containerRoot is not
   * null.
   * @return {boolean} true if this.containerRoot exists in the dom
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   */
  InlineHelpHintsStrategy.prototype._isContainerRootDomInDocument = function () {
    let containerRootExistsInDocument = false;
    if (this.containerRoot) {
      let id = this.containerRoot.id;
      containerRootExistsInDocument = document.getElementById(id);
    }
    return containerRootExistsInDocument !== null;
  };

  /**
   * @static
   * @private
   * @param {CustomEvent} event helpChanged event
   */
  // eslint-disable-next-line no-unused-vars
  InlineHelpHintsStrategy._helpHintsChangedHandler = function (event) {
    this._updateInlineHelpHints();
  };

  /**
   * Removes the helphints container and its content.
   * @param {Object} component the form component
   * @return {boolean} Returns true if content was added
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @private
   */
  InlineHelpHintsStrategy.prototype._removeHelpHintsContainerAndContent = function () {
    var component = this.GetComponent();
    var element = component._getRootElement();
    var container = this._getHelpHintsInlineContainer(element);
    if (container) {
      this.RemoveAriaDescribedByForInlineMessaging(container);
      container.parentElement.removeChild(container);
      if (this._userAssistanceDivElement) {
        this._userAssistanceDivElement.classList.remove(OJ_HAS_HELPHINTS_STYLECLASS);
        this.containerRoot = null;
      }
    }
  };

  /**
   * Creates the content, if any.
   * @param {Object} component the form component
   * @return {boolean} Returns true if content was added
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @private
   */
  InlineHelpHintsStrategy.prototype._addHelpHintsContent = function (component) {
    let hintsHtml;
    let helpOptions = component.options.help;
    let helpInstruction = helpOptions ? helpOptions.instruction : null;
    let helpHints = component.options.helpHints;

    if (helpInstruction) {
      let helpInstructionDom = PopupMessagingStrategyUtils.GetTextDom(
        document,
        helpInstruction,
        true
      );
      // turn it into a string
      let helpInstructionDomString = helpInstructionDom ? helpInstructionDom.outerHTML : ''; // @HTMLUpdateOK
      hintsHtml = helpInstructionDomString;
    }
    if (!hintsHtml && this.ShowValidatorHint()) {
      // helpInstruction takes priority. If it is not set, check validator hints.
      // This involves loading the validators if they are not set.
      // ShowValidatorHint may be null if the display-options.validatorHint = 'none',
      // otherwise we show the validator hint.
      // no helpInstruction, so try to get validation hint
      // we do the same thing that we do in PopupComponentMessages
      let hints = this.GetValidatorHints();
      if (hints.length > 0) {
        hintsHtml = hints.join('<br/>');
      }
    }
    if (!hintsHtml) {
      // try to get help definition
      // We get notified of changes to help-hints in
      // InlineHelpHintsStrategy.prototype._createHelpHintsAttributeEventHandlers
      let definition = helpHints ? helpHints.definition : null;
      if (definition) {
        hintsHtml = definition;
      }
    }
    // try to get the converterHint
    if (!hintsHtml && this.ShowConverterHint()) {
      let hints = this.GetConverterHint();
      if (hints.length > 0) {
        hintsHtml = hints.join('<br/>');
      }
    }

    let source = helpHints ? helpHints.source : null;
    let helpSourceDom;
    if (source) {
      helpSourceDom = this._getHelpSourceDom(source);
    }

    // create container if needed
    if ((hintsHtml || helpSourceDom) && !this.containerRoot) {
      this.containerRoot = document.createElement('div');
      this.containerRoot.classList.add('oj-helphints-inline-container');
      $(this.containerRoot).uniqueId();
      this.AddAriaDescribedByForInlineMessaging(this.containerRoot);
      let showHelpHintsLocation = component._ShowHelpHintsLocation();
      if (showHelpHintsLocation === 'inline') {
        this._userAssistanceDivElement.appendChild(this.containerRoot);
      } else {
        let formControlContainerDom = component._GetFormControlContainer();
        formControlContainerDom.parentElement.insertBefore(
          this.containerRoot,
          formControlContainerDom
        );
      }
    }
    // Now we have created the container root, we can add the hintsHtml
    // This function is also called when updateHelpHintsContent, so it is possible
    // that there is no more help and hintsHtml is '',
    // in which case we want to clear out textContent.
    if (this.containerRoot) {
      if (hintsHtml) {
        hintsHtml = '<div>' + hintsHtml + '</div>';
        this.containerRoot.innerHTML = hintsHtml; // @HTMLUpdateOK
      }
      if (helpSourceDom) {
        this.containerRoot.appendChild(helpSourceDom);
      }
      if (!(hintsHtml || helpSourceDom)) {
        this.containerRoot.innerHTML = ''; // @HTMLUpdateOK
      }
    }

    // only when the help/required/messages are all inline does the styleclass matter.
    const showInline = component._ShowHelpHintsLocation() === 'inline';
    if (this._userAssistanceDivElement && showInline) {
      // add this selector the first time we have hints. then use
      // theming to hide/show it or hide/show required dom according to UX rules.
      if (hintsHtml || helpSourceDom) {
        this._userAssistanceDivElement.classList.add(OJ_HAS_HELPHINTS_STYLECLASS);
      } else {
        this._userAssistanceDivElement.classList.remove(OJ_HAS_HELPHINTS_STYLECLASS);
      }
    }
    return hintsHtml || helpSourceDom;
  };

  /**
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @param {String} source
   */
  InlineHelpHintsStrategy.prototype._getHelpSourceDom = function (source) {
    oj.Assert.assertString(source);
    let helpAnchorDiv = document.createElement('div');
    let helpSourceAnchor = document.createElement('a');
    helpSourceAnchor.classList.add('oj-helphints-anchor');

    helpSourceAnchor.setAttribute('tabindex', '0');
    helpSourceAnchor.setAttribute('target', '_blank');
    try {
      DomUtils.validateURL(source);
      helpSourceAnchor.setAttribute('href', source);
    } catch (e) {
      throw new Error(e + '. The source option (' + source + ') is invalid.');
    }
    // add Learn more... text on the link
    let helpSourceText = Translations.getTranslatedString('oj-ojEditableValue.helpSourceText');
    helpSourceAnchor.textContent = helpSourceText;
    helpAnchorDiv.appendChild(helpSourceAnchor);
    DomUtils.makeFocusable({
      element: helpSourceAnchor,
      applyHighlight: true,
      component: this.GetComponent()
    });
    return helpAnchorDiv;
  };

  /**
   * This gets called when a component property changes that will affect the
   * inline help hints content or when mc.update is called
   * // (like when an async validator hint resolves)
   * This also gets called from EditableValue when help.instruction attribute changes.
   * Help Hints are only shown on focus for some components, and always for others.
   * This won't change the content unless it is in focus or we always want to show the hints.
   * @param {boolean} showRightAway true if we need to add the content right away
   * which is the case when the update method is called.
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   */
  InlineHelpHintsStrategy.prototype._updateInlineHelpHints = function () {
    const component = this.GetComponent();

    if (this.containerRoot) {
      // clear out the containerRoot's innerHTML since we need to create the content
      // again.
      this.containerRoot.innerHTML = ''; // @HTMLUpdateOK
    }
    let showHelpHints = component._ShowHelpHints();
    // if the component is one that always shows the help hints, like oj-checkboxset, or
    // if it is one that shows on focus and it has focus, then add help hints content.
    // if the component already has focus when an update occurs, add the help content
    if (showHelpHints === 'always' || this._focusIn) {
      // if showHelpHints is 'focus', then we create the content on the first focusin so that
      // we can delay getting validation hints.
      // otherwise add content now.
      let hasContent = this._addHelpHintsContent(component);
      if (!hasContent) {
        this._removeHelpHintsContainerAndContent();
      }
    }
  };

  /**
   * Show the help hint message on focus. We remove it on focusout.
   * We show helpInstruction and if that's not there validaton hint and
   * if that is not there help definition. And on whichever of these, we show
   * Learn more... for help.source if that is there.
   * @static
   * @private
   * @param {Object} component form component root element
   * @param {CustomEvent} event focus event
   */
  // eslint-disable-next-line no-unused-vars
  InlineHelpHintsStrategy._focusinHandler = function (component, event) {
    let rootElem = event.currentTarget;
    // if we are focusing in from already within the component, return
    // e.g., when we tab from the input to the help source anchor;
    // relatedTarget would be the input in this case.
    let relatedTarget = event.relatedTarget;
    if (relatedTarget && rootElem.contains(relatedTarget)) {
      return;
    }

    if (this.containerRoot) {
      // clear out the containerRoot's innerHTML since need to create the content
      // again.
      this.containerRoot.innerHTML = ''; // @HTMLUpdateOK
    }

    // flag needed to know if we are back in focusin in the focusout
    // handler during the animation promise resolution.
    this._focusIn = true;

    let hasContent = this._addHelpHintsContent(component);
    if (hasContent) {
      this._animateOpen();
    } else {
      // it is possible that when the component has focus, something is changed,
      // that causes the help to no longer hae content, like the app dev
      // removes the help property from the component.
      // if that's the case, then remove it.
      this._removeHelpHintsContainerAndContent();
    }
  };

  /**
   * @static
   * @private
   * @param {Object} component the form component
   * @param {CustomEvent} event focus event
   */
  InlineHelpHintsStrategy._focusoutHandler = function (event) {
    // make this focusout since focusout bubbles and blur does not.
    // This way you can put the event handler on the component's root
    // element and if any child element that can get focus loses focus,
    // this handler will be called. But we need to check if we are still
    // within the element or not. This way the inline hint won't disappear
    // if we focus on the help source Learn more... link.
    // The currentTarget read-only property of the Event interface identifies
    // the current target for the event, as the event traverses the DOM.
    // It always refers to the element to which the event handler has been attached.
    let rootElem = event.currentTarget;
    let relatedTarget = event.relatedTarget;
    if (relatedTarget && rootElem.contains(relatedTarget)) {
      return;
    }
    this._focusIn = false;

    // if we have helphint content, then animate it closed on focusout.
    if (this.containerRoot && this.containerRoot.hasChildNodes()) {
      // animate it closed.
      let action = 'close';
      let defaults = this._getDefaultAnimation();
      let effect = defaults.close; // e.g., {effect: 'fadeOut', duration: '200ms'}
      this._setBusyState();
      let self = this;
      AnimationUtils.startAnimation(
        this.containerRoot,
        'inline-hints-' + action,
        effect,
        this.GetComponent()
      ).then(() => {
        // As of v12.0.0 we are removing the dom instead of using css.
        this._removeHelpHintsContainerAndContent();
        self._clearBusyState();
      });
    }
  };

  /**
   * Get the default animation.
   * To save from sending unnecessary theming variables to the client, we hardcode.
   *
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   * @return {Object} Object with open and close key for the default animation.
   */
  InlineHelpHintsStrategy.prototype._getDefaultAnimation = function () {
    // Load the default animation once per page scope
    if (!InlineHelpHintsStrategy._defaultAnimation) {
      InlineHelpHintsStrategy._defaultAnimation = {
        open: {
          effect: 'fadeIn',
          duration: '200ms',
          timingFunction: 'cubic-bezier(0.4,0,0.2,1)'
        },
        close: {
          effect: 'fadeOut',
          duration: '200ms',
          timingFunction: 'cubic-bezier(0.4,0,0.2,1)'
        }
      };
    }

    return InlineHelpHintsStrategy._defaultAnimation;
  };

  /**
   * Animate the help hints container open
   *
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   */
  InlineHelpHintsStrategy.prototype._animateOpen = function () {
    if (this.containerRoot && this.containerRoot.hasChildNodes()) {
      // animate it in.
      let defaults = this._getDefaultAnimation();
      let effect = defaults.open; // e.g., {effect: 'fadeIn', duration: '200ms'}
      let action = 'open';
      AnimationUtils.startAnimation(
        this.containerRoot,
        'inline-hints-' + action,
        effect,
        this.GetComponent()
      );
    }
  };

  /**
   * Set busy state before opening or closing inline message.
   *
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   */
  InlineHelpHintsStrategy.prototype._setBusyState = function () {
    // Set a page-level busy state if not already set
    if (!this._resolveBusyState) {
      let component = this.GetComponent();
      let domElem = component._getRootElement();
      let busyContext = Context.getContext(domElem).getBusyContext();
      let description = 'The page is waiting for inline help hints ';

      if (domElem && domElem.id) {
        description += 'for "' + domElem.id + '" ';
      }
      description += 'to open/close';

      this._resolveBusyState = busyContext.addBusyState({ description: description });
    }
  };

  /**
   * Clear busy state after opening or closing inline helphints.
   *
   * @private
   * @memberof InlineHelpHintsStrategy
   * @instance
   */
  InlineHelpHintsStrategy.prototype._clearBusyState = function () {
    if (this._resolveBusyState) {
      this._resolveBusyState();
      this._resolveBusyState = null;
    }
  };

  /**
   * A messaging strategy that places the messaging content inline (underneath) the editableValue
   * component.
   *
   * @param {Array.<string>} displayOptions an array of messaging artifacts displayed inline. e.g,
   * 'messages' (for now only 'messages' are supported inline, not converterHints, and others)
   * @constructor
   * @extends {oj.MessagingStrategy}
   * @private
   */
  const InlineMessagingStrategy = function (displayOptions, parentElement) {
    this.Init(displayOptions);
    this._parentElement = parentElement;
  };

  /**
   * Registers the InlineMessagingStrategy constructor function with ComponentMessaging.
   *
   * @private
   */
  oj.ComponentMessaging.registerMessagingStrategy(
    oj.ComponentMessaging._STRATEGY_TYPE.INLINE,
    InlineMessagingStrategy
  );

  // Subclass from MessagingStrategy
  oj.Object.createSubclass(
    InlineMessagingStrategy,
    oj.MessagingStrategy,
    'oj.InlineMessagingStrategy'
  );

  /**
   * Does nothing; We do not create the inline messaging dom until we get messages to show.
   *
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content. * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   * @override
   *
   */
  InlineMessagingStrategy.prototype.activate = function (cm) {
    InlineMessagingStrategy.superclass.activate.call(this, cm);
    // We do not create the inline messaging dom until we get messages to show.
  };

  /**
   * Reinitializes with the new display options and updates component messaging using the new content.
   *
   * @param {Array.<string>} newDisplayOptions
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   * @override
   *
   */
  InlineMessagingStrategy.prototype.reactivate = function (newDisplayOptions, parentElement) {
    InlineMessagingStrategy.superclass.reactivate.call(this, newDisplayOptions);
    this._parentElement = parentElement;
    this._updateInlineMessage();
  };

  /**
   * Returns true if the messaging content should update. This method is an
   * optimization because the update() method is called too often and any time any content changes.
   * The only time InlineMessagingStrategy#update needs to execute is when the ComponentValidity
   * object is in the content because we don't add this unless there are messages.
   *
   * @param {Object=} content the messaging content object. If it contains validityState, then
   * this means the component has messaging content.
   * @return {boolean}
   * @memberof oj.InlineMessagingStrategy
   * @instance
   * @private
   * @override
   */
  InlineMessagingStrategy.prototype.shouldUpdate = function (content) {
    // content is messaging content, and in EditableValue we add a validityState for
    // messages, valid, and severity, so if validityState is there, we know messages are there.
    return !!(content && content.validityState !== undefined);
  };

  /**
   * Updates component with instance using the content provided.
   * @memberof oj.InlineMessagingStrategy
   * @instance
   * @private
   * @override
   */
  InlineMessagingStrategy.prototype.update = function () {
    InlineMessagingStrategy.superclass.update.call(this);
    this._updateInlineMessage();
  };

  /**
   * Cleans up messages on the component and destroys any widgets it created.
   *
   * @memberof oj.InlineMessagingStrategy
   * @instance
   * @private
   * @override
   */
  InlineMessagingStrategy.prototype.deactivate = function () {
    this._removeMessagingContentRootDom();
    InlineMessagingStrategy.superclass.deactivate.call(this);
  };

  /**
   * Get the default animation.
   *
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._getDefaultAnimation = function () {
    // Load the default animation once per page scope
    if (!InlineMessagingStrategy._defaultAnimation) {
      var animation = (ojthemeutils.parseJSONFromFontFamily('oj-messaging-inline-option-defaults') || {})
        .animation;
      animation = animation || {};
      InlineMessagingStrategy._defaultAnimation = animation;
    }

    return InlineMessagingStrategy._defaultAnimation;
  };

  /**
   * Replace animation options with runtime values, such as oldHeight and
   * newHeight, which are specified as placeholders in the default animations
   * but their values are not known until runtime.
   *
   * @param {string|Object|Array} effects - The animation options.
   * @param {Object} map - An object containing the runtime property key-value map.
   * @return {string|Object|Array} The resolved animation effects
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._replaceAnimationOptions = function (effects, map) {
    var effectsAsString;
    var isEffectsTypeofString;

    if (!oj.StringUtils.isString(effects)) {
      isEffectsTypeofString = false;
      effectsAsString = JSON.stringify(effects);
    } else {
      isEffectsTypeofString = true;
      effectsAsString = effects + ''; // append "" to get around a closure compiler warning
    }

    var keys = Object.keys(map);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      effectsAsString = effectsAsString.replace(new RegExp(key, 'g'), map[key]);
    }

    var _effects = isEffectsTypeofString
      ? effectsAsString
      : /** @type {Object} */ (JSON.parse(effectsAsString));

    return _effects;
  };

  /**
   * Determine the animation for displaying new messaging content.
   * returns 'open' if the inline message is getting bigger with the new content
   * returns 'close' if the inline message is getting smaller with the new content
   * else returns 'noanimation' if the inline message size is the same
   *
   * @param {jQuery} rootElem - The root element for inline message.
   * @param {string} newContent - The new content to display.
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._determineAnimation = function (rootElem, newContent) {
    var action;
    var effect;
    var parsedEffect;
    var defaults = this._getDefaultAnimation();
    if (defaults) {
      var el = rootElem[0];
      var oldContent = el.innerHTML; // @HTMLUpdateOK
      var oldHeight = el.offsetHeight;
      var newHeight;

      el.innerHTML = newContent; // @HTMLUpdateOK
      newHeight = el.offsetHeight;
      el.innerHTML = oldContent; // @HTMLUpdateOK

      if (newHeight > oldHeight) {
        action = 'open';
      } else if (newHeight < oldHeight) {
        action = 'close';
      } else {
        action = 'noanimation';
      }

      if (action !== 'noanimation') {
        effect = defaults[action];
        // An example of effect is 'fadeIn' or 'expand',
        // and not all effects take oldHeight and newHeight
        if (effect) {
          parsedEffect = this._replaceAnimationOptions(effect, {
            '#oldHeight': oldHeight + 'px',
            '#newHeight': newHeight + 'px'
          });
        }
      }
    }

    return { action: action, effect: parsedEffect };
  };

  /**
   * Set busy state before opening or closing inline message.
   *
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._setBusyState = function () {
    // Set a page-level busy state if not already set
    if (!this._resolveBusyState) {
      var component = this.GetComponent();
      var jElem = component ? component.element : null;
      var domElem = jElem ? jElem[0] : null;
      var busyContext = Context.getContext(domElem).getBusyContext();
      var description = 'The page is waiting for inline message ';

      if (domElem && domElem.id) {
        description += 'for "' + domElem.id + '" ';
      }
      description += 'to open/close';

      this._resolveBusyState = busyContext.addBusyState({ description: description });
    }
  };

  /**
   * Clear busy state after opening or closing inline message.
   *
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._clearBusyState = function () {
    if (this._resolveBusyState) {
      this._resolveBusyState();
      this._resolveBusyState = null;
    }
  };

  /**
   * Queue up inline messaging open/close actions so that it only animate once
   * for multiple updates within the same tick.
   *
   * @param {string} contentToShow - The messaging content to show.
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._queueAction = function (contentToShow) {
    var self = this;
    var rootElem = this.$messagingContentRoot;

    // Return if we are animating. This flag is set right before we
    // start animating. When animation is done, it will call _queueAction
    // again with this._currentContentToShow. That way we only show the latest content.
    // Otherwise we may start a new animation or we may swap content
    //  while we are still animating a previous contentToShow.
    if (self._inInlineMessagingAnimation) {
      this._currentContentToShow = contentToShow;
      return;
    }
    this._currentContentToShow = null;
    this._setBusyState();

    // add styleclass as soon as we start animating open so that
    // if there are inline help-hints, they are hidden with the
    // oj-helphints.oj-has-messages {display:none} selector.
    if (contentToShow !== '') {
      this._addRemoveOjHasMessagesClass(contentToShow);
    }

    // If there is a pending timeout, clear it and set a new one so that only the
    // last animation queued within the same tick will be run.  Otherwise we will
    // end up with too many animation since the messaging framework keeps clearing
    // and updating the message display during validation, etc.
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }

    // JET-46567 - JAWS is reading out error message even after selecting correct value
    // allow a component to opt-in to receive notification before and after the timer fires
    // so that it can wait until after messages have been updated to finish processing,
    // for example to change focus after screen reader text has been updated
    var component = this.GetComponent();
    if (component && component._NotifyMessagingStrategyQueueAction) {
      if (!this._notifyQueueActionPromise) {
        var promiseResolve;
        this._notifyQueueActionPromise = new Promise(function (resolve) {
          promiseResolve = resolve;
        });
        this._notifyQueueActionPromiseResolve = function () {
          this._notifyQueueActionPromise = null;
          this._notifyQueueActionPromiseResolve = null;
          promiseResolve();
        }.bind(this);
      }
      component._NotifyMessagingStrategyQueueAction(this._notifyQueueActionPromise);
    }

    this._timeoutId = setTimeout(function () {
      self._timeoutId = null;

      // Make sure $messagingContentRoot is still there.  It could have been
      // removed by the time the timeout function is run.
      if (rootElem && rootElem[0]) {
        // Parse and substitute runtime values in animation options
        var actionEffect = self._determineAnimation(rootElem, contentToShow);
        // action 'close' means the message container is getting smaller
        // (may be a new, smaller message), if it is 'open' it is
        // getting larger. If it is 'noanimation' the size hasn't changed and
        // we don't animate in this case.
        var action = actionEffect.action;
        var effect = actionEffect.effect;

        if (action === 'noanimation') {
          rootElem[0].innerHTML = contentToShow; // @HTMLUpdateOK
          self._addRemoveOjHasMessagesClass(contentToShow);
          self._clearBusyState();

          if (self._notifyQueueActionPromiseResolve) {
            self._notifyQueueActionPromiseResolve();
          }
        } else {
          // aria-live polite is needed so a screen reader will read the inline message without the
          // user needing to set focus to the input field. aria-live: 'off' is needed before
          // content animates otherwise JAWS will re-read the message.
          // We think JAWS re-reads when the dom changes, even if that is with css.
          // This still doesn't work in Chrome because Chrome or JAWS on Chrome
          // seem to buffer the aria-live: polite and not read the aria-live: off.
          // The accessibility team agrees that because it works in
          // Firefox this is either a JAWS or Chrome bug, not a JET bug.
          if (action === 'close') {
            rootElem[0].setAttribute('aria-live', 'off');
          } else {
            rootElem[0].setAttribute('aria-live', 'polite');
          }

          // Set the new content first if we're opening.
          if (action === 'open') {
            rootElem[0].innerHTML = contentToShow; // @HTMLUpdateOK
          }
          // Invoke animation
          self._inInlineMessagingAnimation = true;
          AnimationUtils.startAnimation(
            rootElem[0],
            'inline-' + action,
            effect,
            self.GetComponent()
          ).then(function () {
            var afterAnimateContentToShow;
            self._inInlineMessagingAnimation = false;

            // Set the new content last if we're closing; in other words,
            // if we are closing we are animating
            // the old content before we switch in the new content, and to prevent a JAWS re-read,
            // we set aria-live to 'off' above. Now that we are done animating set it to
            // polite so JAWS will read the new message.
            if (action === 'close') {
              rootElem[0].setAttribute('aria-live', 'polite');
              rootElem[0].innerHTML = contentToShow; // @HTMLUpdateOK
            }
            // Clear busy state when animation ends. If _queueAction was called
            // while we were animating the previous _queueAction request,
            // we saved the _currentContentToShow and returned. Now go
            // ahead a call _queueAction with that new content now that the
            // animation from the previous contentToShow has ended.
            if (self._currentContentToShow !== null) {
              afterAnimateContentToShow = self._currentContentToShow;
              self._currentContentToShow = null;
              self._queueAction(afterAnimateContentToShow);
            } else {
              if (contentToShow === '') {
                self._addRemoveOjHasMessagesClass(contentToShow);
              }
              self._clearBusyState();

              if (self._notifyQueueActionPromiseResolve) {
                self._notifyQueueActionPromiseResolve();
              }
            }
          });
        }
      } else {
        // Just clear the busy state if $messagingContentRoot no longer exists
        self._addRemoveOjHasMessagesClass('');
        self._clearBusyState();

        if (self._notifyQueueActionPromiseResolve) {
          self._notifyQueueActionPromiseResolve();
        }
      }
    }, 0);
  };

  /**
   * Adds oj-has-messages styleclass if there is contentToShow otherwise
   * removes oj-has-messages and removes messaging dom.
   *  add/remove oj-has-messages on this._parentElement if it exists;
   * if the animation is opening, add 'oj-has-messages' right away.
   * if the animation is closing, then don't remove 'oj-has-messages' until the messages is
   * closed completely. The help-hints that are also inline only displays when 'oj-has-messages' is
   * not there. So if we remove oj-has-messages too fast, both will show at the same time.
   * This is why this is method called in the AnimationUtils.startAnimation callback.
   *
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._addRemoveOjHasMessagesClass = function (contentToShow) {
    if (this._parentElement) {
      if (contentToShow) {
        this._parentElement.classList.add('oj-has-messages');
      } else {
        this._parentElement.classList.remove('oj-has-messages');
        this._removeMessagingContentRootDom();
      }
    }
  };

  /**
   * If the inline message is already open its contents need to updated when update() or
   * reactivate() is called.
   *
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._updateInlineMessage = function () {
    var contentToShow;
    var domNode;

    // contentToShow will be "" (a falsey) if there are no messages to show.
    contentToShow = this._buildInlineHtml();

    // create the inline messaging dom if there is content to show and the dom hasn't been created.
    // We do not create the inline messaging dom until the first content is shown.
    var messagingRootExists = this._isMessagingContentRootDomInDocument();
    if (contentToShow && !messagingRootExists) {
      this._createInlineMessage();
    }

    if (this.$messagingContentRoot && this.$messagingContentRoot[0]) {
      // Only enable default animation for custom elements so that automated tests
      // for legacy components are not affected
      if (this.GetComponent()._IsCustomElement()) {
        // This may be called multiple times within the same event cycle because the
        // old message is cleared before validation and the message is
        // reconstructed.  Since we now have animation for inline message, we don't
        // want to update the DOM every single time.  Instead we queue up the
        // updates and will only show the last one within the same event cyle.
        this._queueAction(contentToShow);
      } else {
        // Legacy components don't have animation so just update the DOM
        // push new content into inline message dom
        domNode = this.$messagingContentRoot[0];

        // contentToShow includes content that may come from app. It is scrubbed for illegal tags
        // before setting to innerHTML
        domNode.innerHTML = contentToShow; // @HTMLUpdateOK
      }
    }
  };

  InlineMessagingStrategy.prototype._createInlineMessage = function () {
    var widget;

    this.$messagingContentRoot = $(this._getInlineContentHtml());
    this.AddAriaDescribedByForInlineMessaging(this.$messagingContentRoot[0]);
    this._addAriaLive(this.$messagingContentRoot);
    // append content that goes in inline messaging div

    if (this._parentElement) {
      this._parentElement.appendChild(this.$messagingContentRoot[0]); // @HTMLUpdateOK
    } else {
      // make it the very LAST child of the widget.
      widget = this.GetComponent().widget();
      widget[0].appendChild(this.$messagingContentRoot[0]); // @HTMLUpdateOK
    }
  };

  /**
   * Returns the dom for the messaging-inline-container.
   *
   * @return {string}
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._getInlineContentHtml = function () {
    return "<div class='oj-messaging-inline-container'></div>";
  };

  /**
   * Removes the messaging content root dom and anything else that was adding during the
   * creation of the messaging content root dom.
   *
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._removeMessagingContentRootDom = function () {
    var messagingRootExists = this._isMessagingContentRootDomInDocument();
    if (messagingRootExists) {
      this.RemoveAriaDescribedByForInlineMessaging(this.$messagingContentRoot[0]);
      let parentNode = this.$messagingContentRoot[0].parentNode;
      if (parentNode) {
        parentNode.removeChild(this.$messagingContentRoot[0]);
      }
    }
    this.$messagingContentRoot = null;
  };

  /**
   * aria-live: polite
   * This is needed so a screen reader will read the inline message without the user needing to
   * set focus to the input field.
   * @param {jQuery} messagingRoot
   * @memberof oj.InlineMessagingStrategy
   * @instance
   * @private
   */
  InlineMessagingStrategy.prototype._addAriaLive = function (messagingRoot) {
    oj.Assert.assertPrototype(messagingRoot, $);
    messagingRoot[0].setAttribute('aria-live', 'polite');
  };

  /**
   * Returns the content to show inside the inline message html.
   * @return {string} content to show, else "". "" is a falsey.
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._buildInlineHtml = function () {
    var document;

    // For now anyway, ShowMessages is always true since the inlineMessaging case is for messaging.
    if (this.ShowMessages()) {
      document = this.GetComponent().document[0];
      // returns messages or "" if there are none
      return this._buildMessagesHtml(document);
    }
    return '';
  };

  /**
   * Returns the content to show inside messages (not hints)
   * @param {Document} document
   * @return {string} content if there are messages, else "". "" is a falsey.
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._buildMessagesHtml = function (document) {
    var content = '';
    var componentLabel;
    var maxSeverity;
    var messages;
    var renderSeveritySelectors = true;

    if (this.HasMessages()) {
      messages = this.GetMessages();
      maxSeverity = this.GetMaxSeverity();
      componentLabel = this._getMessagingContent().label;
      content = PopupMessagingStrategyUtils.buildMessagesHtml(
        document,
        messages,
        maxSeverity,
        renderSeveritySelectors,
        componentLabel
      );
    }
    return content;
  };

  /**
   * Returns true if the inline messaging div exists. This is needed
   * because it is possible that components delete their dom, including
   * the inline message dom, which means the this.$messagingContentRoot is not
   * null.
   * @return {boolean} true if this.$messagingContentRoot exists in the dom
   * @private
   * @memberof oj.InlineMessagingStrategy
   * @instance
   */
  InlineMessagingStrategy.prototype._isMessagingContentRootDomInDocument = function () {
    var messagingRootExistsInDocument = false;
    if (this.$messagingContentRoot) {
      let id = this.$messagingContentRoot[0].id;
      messagingRootExistsInDocument = document.getElementById(id);
    } else {
      return false;
    }
    return messagingRootExistsInDocument !== null;
  };

  /**
   * Adapter for handling inline Required text.
   * Extends the MessagingStrategy which does more now than messages.
   *
   * @extends {oj.MessagingStrategy}
   * @protected
   * @constructor
   * @since 9.0.0
   * @class InlineRequiredStrategy
   * @ignore
   * @ojtsignore
   * @param {Array.<string>} displayOptions an array of messaging artifacts that are
   * displayed as an inside label for text fields.
   * For LabelStrategies this is always only labelEdge.
   */
  const InlineRequiredStrategy = function (displayOptions, parentElement) {
    this.Init(displayOptions);
    this._parentElement = parentElement;
  };

  /**
   * Registers the InlineRequiredStrategy constructor function with ComponentMessaging.
   * No need to register since we are not creating this strategy on from ComponentMessaging.
   * InlineUserAssistanceStrategy creates it.
   * @private
   */
  // ComponentMessaging
  //    .registerMessagingStrategy('required',
  //     InlineRequiredStrategy);

  // Subclass from MessagingStrategy
  oj.Object.createSubclass(InlineRequiredStrategy, oj.MessagingStrategy, 'InlineRequiredStrategy');

  /**
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @public
   * @memberof InlineRequiredStrategy
   * @instance
   * @override
   */
  InlineRequiredStrategy.prototype.activate = function (cm) {
    InlineRequiredStrategy.superclass.activate.call(this, cm);
    if (this.containerRoot == null) {
      this._createOrUpdateInlineRequired();
    }
  };

  /**
   * @param {Array.<string>} newOptions
   * @public
   * @memberof InlineRequiredStrategy
   * @instance
   * @override
   */
  InlineRequiredStrategy.prototype.reactivate = function (newOptions, parentElement) {
    InlineRequiredStrategy.superclass.reactivate.call(this, newOptions);
    this._parentElement = parentElement;
    // select/combobox on refresh destroys all its contents, including
    // the oj-required-inline-container, and then reactivate is called.
    var containerRootExists = this._isContainerRootDomInDocument();
    if (!containerRootExists) {
      this._createOrUpdateInlineRequired();
    }
  };

  /**
   * @param {Object=} content the messaging content object. If it contains hasNoValueToggled, then
   * this means the component's oj-has-no-value styleclass was toggled. And the Redwood UX Required
   * rule is, if the field has no value, show the inline Required dom. Else, do not show it.
   * @return {boolean}
   * @memberof InlineRequiredStrategy
   * @instance
   * @oublic
   * @override
   */
  // eslint-disable-next-line no-unused-vars
  InlineRequiredStrategy.prototype.shouldUpdate = function (content) {
    // This gets sent from EditableValue when oj-has-no-value styleclass
    // is toggled. This is how we know we need to add or remove the Required dom.
    if (content && 'hasNoValueToggled' in content) {
      return true;
    }
    // We are registering a requiredChanged listener that
    // will cause an update when the required prop changes, so that is why this returns false.
    return false;
  };

  /**
   * Updates component with instance using the content provided.
   * @memberof InlineRequiredStrategy
   * @instance
   * @public
   * @override
   */
  InlineRequiredStrategy.prototype.update = function () {
    this._createOrUpdateInlineRequired();
    InlineRequiredStrategy.superclass.update.call(this);
  };

  /**
   * Cleans up dom on the component and removes any event listeners it created.
   * @memberof InlineRequiredStrategy
   * @instance
   * @public
   * @override
   */
  InlineRequiredStrategy.prototype.deactivate = function () {
    this._removeInlineRequired();
    var component = this.GetComponent();
    var element = component._getRootElement();
    element.removeEventListener('requiredChanged', this._requiredChangedCallback);
    delete this._requiredChangedCallback;
    element.removeEventListener('focusout', this._focusoutCallback);
    delete this._focusoutCallback;
    this._parentElement = null;
    InlineRequiredStrategy.superclass.deactivate.call(this);
  };

  /**
   * @memberof InlineRequiredStrategy
   * @instance
   * @private
   */
  InlineRequiredStrategy.prototype._createOrUpdateInlineRequired = function () {
    var component = this.GetComponent();

    const options = component.options;
    const element = component._getRootElement();

    const hasNoValue = element.classList.contains('oj-has-no-value');
    const container = this._getRequiredInlineContainer();
    if (options.required && hasNoValue && !container) {
      this.containerRoot = document.createElement('div');
      this.containerRoot.classList.add('oj-required-inline-container');
      let requiredText = Translations.getTranslatedString('oj-ojEditableValue.requiredText');
      this.containerRoot.textContent = requiredText;
      $(this.containerRoot).uniqueId();
      this._parentElement.appendChild(this.containerRoot);
      if (component._AriaRequiredUnsupported()) {
        this.AddDescribedByToElement(element, this.containerRoot.id);
      }
      // focusout will check if there is a value and if so remove required dom
      this._focusoutCallback = this._focusoutHandler.bind(this, component);
      element.addEventListener('focusout', this._focusoutCallback);
    }

    // if value was programmatically changed to have a value, will need to remove
    if (options.required && !hasNoValue && container) {
      this._removeInlineRequired();
    }

    if (!this._requiredChangedCallback) {
      // whether or not we create the required dom we need to add an event listener so if required attribute
      // changes on the component, we create the required dom.
      // if required changed, we will remove or add the required dom
      this._requiredChangedCallback = this._requiredChangedHandler.bind(this, component);
      element.addEventListener('requiredChanged', this._requiredChangedCallback);
    }
  };

  /**
   * Removes the Required dom. Keeps the associated event listeners
   * which respond to required property changes.
   * @memberof InlineRequiredStrategy
   * @instance
   * @private
   */
  InlineRequiredStrategy.prototype._removeInlineRequired = function () {
    const component = this.GetComponent();
    let container = this._getRequiredInlineContainer();
    if (container && component._AriaRequiredUnsupported()) {
      this.RemoveDescribedByFromElement(component._getRootElement(), container.id);
    }
    if (container && this._parentElement) {
      this._parentElement.removeChild(container);
      this.containerRoot = null;
    }
  };

  /**
   * @memberof InlineRequiredStrategy
   * @instance
   * @private
   */
  InlineRequiredStrategy.prototype._getRequiredInlineContainer = function () {
    return this._parentElement.querySelector('.oj-required-inline-container');
  };

  /**
   * This is where we delete the required dom if required changes from true to false.
   * Remove anything else we may have added, like aria-described by.
   * @memberof InlineRequiredStrategy
   * @instance
   * @private
   * @param {Component} the component
   * @param {CustomEvent} event requiredChanged event
   */
  InlineRequiredStrategy.prototype._requiredChangedHandler = function (component, event) {
    let requiredOptionValue = event.detail.value;
    let container = this._getRequiredInlineContainer();
    const element = component._getRootElement();
    const hasNoValue = element.classList.contains('oj-has-no-value');
    if (requiredOptionValue && hasNoValue && container === null) {
      this._createOrUpdateInlineRequired();
    } else if (!requiredOptionValue && container !== null) {
      // not required
      // remove the dom if it is there
      this._removeInlineRequired();
    }
  };

  /**
   * Required text is shown on initial render if the field doesn't have a value.
   * When the user focuses out of the field, check if the comp is required
   * and the field has a value, and in that case, remove the inline required text (animate out first).
   * messages take precedence in the css.
   * @memberof InlineRequiredStrategy
   * @instance
   * @private
   * @param {Component} the component
   */
  InlineRequiredStrategy.prototype._focusoutHandler = function (component) {
    const container = this._getRequiredInlineContainer();
    const element = component._getRootElement();
    const requiredOptionValue = component.options.required;

    const hasNoValue = element.classList.contains('oj-has-no-value');
    if (requiredOptionValue && !hasNoValue && container !== null) {
      // if we have required content, then animate it closed on focusout.
      let action = 'close';
      let defaults = this._getDefaultAnimation();
      let effect = defaults.close; // e.g., {effect: 'fadeOut', duration: '200ms'}
      this._setBusyState();
      let self = this;
      AnimationUtils.startAnimation(
        this.containerRoot,
        'inline-required-' + action,
        effect,
        this.GetComponent()
      ).then(() => {
        // As of v12.0.0 we are removing the dom
        this._removeInlineRequired();
        self._clearBusyState();
      });
    }
  };

  /**
   * Returns true if the div exists. This is needed
   * because it is possible that components delete their dom, including
   * the inline dom, which means the this.containerRoot is not
   * null.
   * @return {boolean} true if this.containerRoot exists in the dom
   * @private
   * @memberof InlineRequiredStrategy
   * @instance
   */
  InlineRequiredStrategy.prototype._isContainerRootDomInDocument = function () {
    let containerRootExistsInDocument = false;
    if (this.containerRoot) {
      let id = this.containerRoot.id;
      containerRootExistsInDocument = document.getElementById(id);
    }
    return containerRootExistsInDocument !== null;
  };

  /**
   * Get the default animation.
   * To save from sending unnecessary theming variables to the client, we hardcode.
   * @private
   * @memberof InlineRequiredStrategy
   * @instance
   * @return {Object} Object with open and close key for the default animation.
   */
  InlineRequiredStrategy.prototype._getDefaultAnimation = function () {
    // Load the default animation once per page scope
    if (!InlineRequiredStrategy._defaultAnimation) {
      InlineRequiredStrategy._defaultAnimation = {
        open: {
          effect: 'fadeIn',
          duration: '200ms',
          timingFunction: 'cubic-bezier(0.4,0,0.2,1)'
        },
        close: {
          effect: 'fadeOut',
          duration: '200ms',
          timingFunction: 'cubic-bezier(0.4,0,0.2,1)'
        }
      };
    }

    return InlineRequiredStrategy._defaultAnimation;
  };

  /**
   * Set busy state before opening or closing inline message.
   *
   * @private
   * @memberof InlineRequiredStrategy
   * @instance
   */
  InlineRequiredStrategy.prototype._setBusyState = function () {
    // Set a page-level busy state if not already set
    if (!this._resolveBusyState) {
      let component = this.GetComponent();
      let domElem = component._getRootElement();
      let busyContext = Context.getContext(domElem).getBusyContext();
      let description = 'The page is waiting for inline required ';

      if (domElem && domElem.id) {
        description += 'for "' + domElem.id + '" ';
      }
      description += 'to open/close';

      this._resolveBusyState = busyContext.addBusyState({ description: description });
    }
  };

  /**
   * Clear busy state after opening or closing inline required.
   *
   * @private
   * @memberof InlineRequiredStrategy
   * @instance
   */
  InlineRequiredStrategy.prototype._clearBusyState = function () {
    if (this._resolveBusyState) {
      this._resolveBusyState();
      this._resolveBusyState = null;
    }
  };

  /**
   * Redwood wants messages to always show up inline, nowhere else.
   * A user assistance strategy that places the user assistance content inline (underneath) the editableValue
   * component. This does not look at displayOptions, but passes it on to its contained strategies.
   * For example if display-options.validatorHint='none', we do not want to show it.
   * Note: This is confusing because displayOptions is what is displayed in each strategy.
   * But for Redwood we want displayOptions to be ['messages', 'validationHint', 'required', 'title']
   * @since 9.0.0
   * @constructor
   * @extends {oj.MessagingStrategy}
   * @private
   */
  var InlineUserAssistanceStrategy = function (displayOptions) {
    this.Init(displayOptions);
    this._displayOptions = displayOptions;
  };

  /**
   * Registers the InlineUserAssistanceStrategy constructor function with ComponentMessaging.
   *
   * @private
   */
  oj.ComponentMessaging.registerMessagingStrategy(
    oj.ComponentMessaging._STRATEGY_TYPE.USER_ASSISTANCE_INLINE,
    InlineUserAssistanceStrategy
  );

  // Subclass from MessagingStrategy
  oj.Object.createSubclass(
    InlineUserAssistanceStrategy,
    oj.MessagingStrategy,
    'InlineUserAssistanceStrategy'
  );

  /**
   * Activate by writing an empty div and by activating the sub-strategies
   *
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @private
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @override
   *
   */
  InlineUserAssistanceStrategy.prototype.activate = function (cm) {
    InlineUserAssistanceStrategy.superclass.activate.call(this, cm);

    this._componentMessaging = cm;
    const component = this.GetComponent();
    const options = component.options;
    const element = component._getRootElement();

    // set readonly and disabled event listeners
    this._readonlyChangedCallback = this._readonlyChangedHandler.bind(this, component);
    element.addEventListener('readonlyChanged', this._readonlyChangedCallback);
    this._disabledChangedCallback = this._disabledChangedHandler.bind(this, component);
    element.addEventListener('disabledChanged', this._disabledChangedCallback);

    // set userAssistanceDensity event listener to change styleclass
    this._userAssistanceDensityChangedCallback = this._userAssistanceDensityChangedHandler.bind(
      this,
      component
    );
    element.addEventListener(
      'userAssistanceDensityChanged',
      this._userAssistanceDensityChangedCallback
    );

    // create the user assistance dom. It is needed in readonly, disabled and enabled modes
    // so that in form layout mixed mode the fields all have this dom with a min-height
    // to keep the fields lined up.
    if (this.containerRoot == null) {
      this._createInlineContainer();
    }

    // Do not create any dom for sub-dom if readonly or disabled is true
    // since we do not want to show Required, Inline messages, nor help hints in
    // readonly or disabled modes.
    if (this._isDisabledOrReadonly()) {
      return;
    }

    this._activateContainerStrategies(cm, options);
  };

  /**
   * Reinitializes with the new display options and updates component messaging using the new content.
   * newDisplayOptions are the strategies for InlineUserAssistanceStrategy.
   * During Init we save the original displayOptions.
   *
   * @param {Array.<string>} newDisplayOptions
   * @private
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @override
   *
   */
  InlineUserAssistanceStrategy.prototype.reactivate = function (newDisplayOptions) {
    InlineUserAssistanceStrategy.superclass.reactivate.call(this, newDisplayOptions);
    const options = this.GetComponent().options;
    if (this._isDisabledOrReadonly(options)) {
      return;
    }

    // select/combobox on refresh destroys all its contents, including
    // the inline containers, and then reactivate is called.
    var containerRootExists = this._isContainerRootDomInDocument();
    if (!containerRootExists) {
      this._createInlineContainer();
    }

    // if we have already activated our sub-strategies,
    // this._inlineMessagingStrategy will not be undefined
    if (this._inlineMessagingStrategy) {
      // delegate to contained strategies.
      this._inlineMessagingStrategy.reactivate(newDisplayOptions, this.containerRoot);
      if (this._inlineRequiredStrategy) {
        this._inlineRequiredStrategy.reactivate(newDisplayOptions, this.containerRoot);
      }
      if (this._inlineHelpHintsStrategy) {
        this._inlineHelpHintsStrategy.reactivate(newDisplayOptions, this.containerRoot);
      }
    } else {
      // we haven't activated the sub-strategies yet, so do it now.
      this._activateContainerStrategies(this._componentMessaging, options);
    }
  };

  /**
   * Returns true if the messaging content should update. This method is an
   * optimization because the update() method is called too often and any time any content changes.
   * The only time InlineUserAssistanceStrategy#update needs to execute is when the ComponentValidity
   * object is in the content because we don't add this unless there are messages.
   *
   * @param {Object=} content the messaging content object. If it contains validityState, then
   * this means the component has messaging content.
   * @return {boolean}
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   * @override
   */
  InlineUserAssistanceStrategy.prototype.shouldUpdate = function (content) {
    if (this._isDisabledOrReadonly()) {
      return false;
    }
    // return true and check in update per strategy we are delegating to.
    this._shouldUpdateContent = content;
    return true;
  };

  /**
   * Updates component with instance using the content provided.
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   * @override
   */
  InlineUserAssistanceStrategy.prototype.update = function () {
    InlineUserAssistanceStrategy.superclass.update.call(this);

    if (!this._inlineMessagingStrategy) {
      // if we haven't created the sub-strategies yet, return.
      return;
    }

    // if readonly or disabled, return
    if (this._isDisabledOrReadonly()) {
      return;
    }

    if (this._inlineMessagingStrategy.shouldUpdate(this._shouldUpdateContent)) {
      this._inlineMessagingStrategy.update();
    }
    if (
      this._inlineRequiredStrategy &&
      this._inlineRequiredStrategy.shouldUpdate(this._shouldUpdateContent)
    ) {
      this._inlineRequiredStrategy.update();
    }
    if (
      this._inlineHelpHintsStrategy &&
      this._inlineHelpHintsStrategy.shouldUpdate(this._shouldUpdateContent)
    ) {
      this._inlineHelpHintsStrategy.update();
    }
  };

  /**
   * Cleans up messages on the component and destroys any widgets it created.
   *
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   * @override
   */
  InlineUserAssistanceStrategy.prototype.deactivate = function () {
    this._inlineMessagingStrategy.deactivate();
    if (this._inlineRequiredStrategy) {
      this._inlineRequiredStrategy.deactivate();
    }
    if (this._inlineHelpHintsStrategy) {
      this._inlineHelpHintsStrategy.deactivate();
    }
    this._removeContainerRootDom();

    delete this._inlineMessagingStrategy;
    delete this._inlineRequiredStrategy;
    delete this._inlineHelpHintsStrategy;

    // Remove event handlers
    const component = this.GetComponent();
    const element = component._getRootElement();
    element.removeEventListener('readonlyChanged', this._readonlyChangedCallback);
    delete this._readonlyChangedCallback;
    element.removeEventListener('disabledChanged', this._disabledChangedCallback);
    delete this._disabledChangedCallback;
    element.removeEventListener(
      'userAssistanceDensityChanged',
      this._userAssistanceDensityChangedCallback
    );
    delete this._userAssistanceDensityChangedCallback;

    InlineUserAssistanceStrategy.superclass.deactivate.call(this);
  };

  InlineUserAssistanceStrategy.prototype._createInlineContainer = function () {
    this.containerRoot = document.createElement('div');
    this.containerRoot.classList.add('oj-user-assistance-inline-container');

    // this will be oj-efficient or oj-reflow and will be used in theming to
    // either reserve space with min-height or not reserve space.
    const component = this.GetComponent();
    const userAssistanceOptionValue = component.options.userAssistanceDensity;
    if (userAssistanceOptionValue === 'efficient') {
      this.containerRoot.classList.add('oj-efficient');
    } else if (userAssistanceOptionValue === 'reflow') {
      this.containerRoot.classList.add('oj-reflow');
    }

    $(this.containerRoot).uniqueId();

    // append content that goes in inline user assistance div
    // make it the very LAST child of the widget.
    component.widget()[0].appendChild(this.containerRoot); // @HTMLUpdateOK
  };

  /**
   * Removes the messaging content root dom and anything else that was adding during the
   * creation of the messaging content root dom.
   *
   * @private
   * @memberof InlineUserAssistanceStrategy
   * @instance
   */
  InlineUserAssistanceStrategy.prototype._removeContainerRootDom = function () {
    if (this._isContainerRootDomInDocument()) {
      let parentNode = this.containerRoot.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.containerRoot);
      }
    }
    this.containerRoot = null;
  };

  /**
   * Returns true if the inline div exists. This is needed
   * because it is possible that components delete their dom, including
   * the inline dom, which means the this.containerRoot is not
   * null.
   * @return {boolean} true if this.containerRoot exists in the dom
   * @private
   * @memberof InlineUserAssistanceStrategy
   * @instance
   */
  InlineUserAssistanceStrategy.prototype._isContainerRootDomInDocument = function () {
    var containerRootExistsInDocument = false;
    if (this.containerRoot) {
      let id = this.containerRoot.id;
      containerRootExistsInDocument = document.getElementById(id);
    }
    return containerRootExistsInDocument !== null;
  };

  /**
   * activate the Container Strategies if they have not already been activated.
   *
   * @private
   * @memberof InlineUserAssistanceStrategy
   * @instance
   */
  InlineUserAssistanceStrategy.prototype._activateContainerStrategies = function (cm, options) {
    // instantiate and activate the strategy objects this strategy delegates to
    // we wait until this function to instantiate because we want to have the containerRoot
    // created, and we wait until activate to do that in our strategies.
    if (this._inlineMessagingStrategy === undefined) {
      this._inlineMessagingStrategy = new InlineMessagingStrategy(
        this._displayOptions,
        this.containerRoot
      );
      this._inlineMessagingStrategy.activate(cm);
    }

    // Set up the strategy if the component has a required attribute. It doesn't have to be
    // set to required, but it needs to have a required attribute in its api.
    if (options.required !== undefined && this._inlineRequiredStrategy === undefined) {
      this._inlineRequiredStrategy = new InlineRequiredStrategy(
        this._displayOptions,
        this.containerRoot
      );
      this._inlineRequiredStrategy.activate(cm);
    }
    if (this._inlineHelpHintsStrategy === undefined) {
      // setup InlineHelpHintsStrategy
      this._inlineHelpHintsStrategy = new InlineHelpHintsStrategy(
        this._displayOptions,
        this.containerRoot
      );
      this._inlineHelpHintsStrategy.activate(cm);
    }
  };

  /**
   * If user-assistance-density property is changed
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   * @param {Component} the component
   * @param {CustomEvent} event readonlyChanged event
   */
  InlineUserAssistanceStrategy.prototype._userAssistanceDensityChangedHandler = function (
    component,
    event
  ) {
    let userAssistanceOptionValue = event.detail.value;

    const _OJ_REFLOW = 'oj-reflow';
    const _OJ_EFFICIENT = 'oj-efficient';

    if (userAssistanceOptionValue === 'efficient') {
      this.containerRoot.classList.add(_OJ_EFFICIENT);
      this.containerRoot.classList.remove(_OJ_REFLOW);
    } else if (userAssistanceOptionValue === 'reflow') {
      this.containerRoot.classList.add(_OJ_REFLOW);
      this.containerRoot.classList.remove(_OJ_EFFICIENT);
    } else {
      this.containerRoot.classList.remove(_OJ_EFFICIENT);
      this.containerRoot.classList.remove(_OJ_REFLOW);
    }
  };

  /**
   * If readonly is true, then delete the user-assistance-display dom
   * and deactivate all the sub-strategies, otherwise activate them.
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   * @param {Component} the component
   * @param {CustomEvent} event readonlyChanged event
   */
  InlineUserAssistanceStrategy.prototype._readonlyChangedHandler = function (component, event) {
    let readonlyOptionValue = event.detail.value;

    if (readonlyOptionValue) {
      this._deactivateContainerStrategies();
    } else {
      const options = component.options;
      this._activateContainerStrategies(this._componentMessaging, options);
    }
  };

  /**
   * If disabled is true, then delete the user-assistance-display dom
   * and deactivate all the sub-strategies, otherwise activate them.
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   * @param {Component} the component
   * @param {CustomEvent} event disabledChanged event
   */
  InlineUserAssistanceStrategy.prototype._disabledChangedHandler = function (component, event) {
    let disabledOptionValue = event.detail.value;

    if (disabledOptionValue) {
      this._deactivateContainerStrategies();
    } else {
      const options = component.options;
      this._activateContainerStrategies(this._componentMessaging, options);
    }
  };

  /**
   * Deactivate all the sub-strategies.
   * @memberof InlineUserAssistanceStrategy
   * @instance
   * @private
   */
  InlineUserAssistanceStrategy.prototype._deactivateContainerStrategies = function () {
    if (this._inlineMessagingStrategy) {
      this._inlineMessagingStrategy.deactivate();
    }
    if (this._inlineRequiredStrategy) {
      this._inlineRequiredStrategy.deactivate();
    }
    if (this._inlineHelpHintsStrategy) {
      this._inlineHelpHintsStrategy.deactivate();
    }

    delete this._inlineMessagingStrategy;
    delete this._inlineRequiredStrategy;
    delete this._inlineHelpHintsStrategy;
  };

  /**
   * If component readOnly or disabled.
   * @return {boolean}
   * @private
   * @memberof InlineUserAssistanceStrategy
   * @instance
   */
  InlineUserAssistanceStrategy.prototype._isDisabledOrReadonly = function (
    options = this.GetComponent().options
  ) {
    var isDisabled = options.disabled || false;
    var isReadOnly = options.readOnly || false;

    return isDisabled || isReadOnly;
  };

  /**
   * Adapter for rendering fixed labels within the form component's root dom node as the first
   * child of the root dom element,
   * and smaller to match a text field's 'inside' label.
   * This is used for non-text-field components like
   * radioset/checkboxset/slider/switch/datepicker/colorpicker, etc.
   *
   * @extends BaseInsideLabelStrategy
   * @protected
   * @constructor
   * @since 8.0.0
   * @class InsideFormControlLabelStrategy
   * @ignore
   * @ojtsignore
   * @param {Array.<string>} options an array of messaging artifacts that are
   * displayed as an inside label for non-text field form controls.
   * For LabelStrategies this is always only labelEdge.
   */
  const InsideFormControlLabelStrategy = function (options) {
    this.Init(options);
  };

  /**
   * Registers the LabelStrategy constructor function with ComponentMessaging.
   *
   * @private
   */
  oj.ComponentMessaging.registerMessagingStrategy(
    oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE_FORM_CNTRL,
    InsideFormControlLabelStrategy
  );

  // Subclass from BaseInsideLabelStrategy
  oj.Object.createSubclass(
    InsideFormControlLabelStrategy,
    BaseInsideLabelStrategy,
    'InsideFormControlLabelStrategy'
  );

  /**
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @public
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @override
   */
  InsideFormControlLabelStrategy.prototype.activate = function (cm) {
    InsideFormControlLabelStrategy.superclass.activate.call(this, cm);
    this._CreateLabel();
  };

  /**
   * @param {Array.<string>} newOptions
   * @public
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @override
   */
  InsideFormControlLabelStrategy.prototype.reactivate = function (newOptions) {
    InsideFormControlLabelStrategy.superclass.reactivate.call(this, newOptions);
    this._DestroyLabel();
    this._CreateLabel();
  };

  /**
   * @param {Object=} content the messaging content object. If it contains validityState, then
   * this means the component has messaging content.
   * @return {boolean}
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @oublic
   * @override
   */
  InsideFormControlLabelStrategy.prototype.shouldUpdate = function () {
    return false;
  };

  /**
   * Updates component with instance using the content provided.
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @public
   * @override
   */
  InsideFormControlLabelStrategy.prototype.update = function () {
    InsideFormControlLabelStrategy.superclass.update.call(this);
  };

  /**
   * Cleans up messages on the component and destroys any widgets it created.
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @public
   * @override
   */
  InsideFormControlLabelStrategy.prototype.deactivate = function () {
    this._DestroyLabel();
    InsideFormControlLabelStrategy.superclass.deactivate.call(this);
  };

  /**
   * Adds a hook for subclass to use its own styleclass on root dom element.
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @protected
   */
  InsideFormControlLabelStrategy.prototype._GetFormControlLabelStyleClass = function () {
    return 'oj-form-control-label-inside';
  };

  /**
   * Insert the ojLabel
   * @memberof InsideFormControlLabelStrategy
   * @protected
   * @override
   * @param {Element} ojlabel
   * @param {Element} container
   * @param {Object} component
   * @return {string}
   */
  InsideFormControlLabelStrategy.prototype._InsertOjLabel = function (
    ojlabel,
    _container,
    component
  ) {
    // node.insertBefore(newnode, existingnode);
    // insert the new ojlabel element as first child of the root
    let root = component._getRootElement();
    root.insertBefore(ojlabel, root.firstElementChild);
  };

  /**
   * Creates event handlers
   * Override to add helpHints.
   * @param {Element} span span around the label where we use innerText to set the labelHint
   * @param {Element} element root custom element
   * @param {Element} ojlabel ojlabel custom element
   * @param {Element} component form component
   * @memberof InsideFormControlLabelStrategy
   * @instance
   * @protected
   * @override
   */
  InsideFormControlLabelStrategy.prototype._CreateEventHandlers = function (
    span,
    element,
    ojlabel,
    component
  ) {
    InsideFormControlLabelStrategy.superclass._CreateEventHandlers.call(
      this,
      span,
      element,
      ojlabel,
      component
    );
  };

  /**
   * @static
   * @private
   * @param {Element} span holding label text
   * @param {CustomEvent} event labelChanged event
   */
  InsideFormControlLabelStrategy._labelHintChangedHandler = function (span, event) {
    // eslint-disable-next-line no-param-reassign
    span.textContent = event.detail.value;
  };

  /**
   * Adapter for handling dynamically setting the inputs placeholder attribute
   *
   * @extends {oj.MessagingStrategy}
   * @protected
   * @constructor
   * @since 8.0.0
   * @class oj.InsideLabelPlaceholderStrategy
   * @ignore
   * @ojtsignore
   * @param {Array.<string>} options an array of messaging artifacts displayed inline. e.g,
   */
  const InsideLabelPlaceholderStrategy = function (options) {
    this.Init(options);
  };

  // Subclass from MessagingStrategy
  oj.Object.createSubclass(
    InsideLabelPlaceholderStrategy,
    oj.MessagingStrategy,
    'oj.InsideLabelPlaceholderStrategy'
  );

  /**
   * Sets up a placeholder for the component instance using the converter hint.
   *
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @public
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   * @override
   */
  InsideLabelPlaceholderStrategy.prototype.activate = function (cm) {
    InsideLabelPlaceholderStrategy.superclass.activate.call(this, cm);
    this._createPlaceholderToggle();
  };

  /**
   * @param {Array.<string>} newOptions
   * @public
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   * @override
   */
  InsideLabelPlaceholderStrategy.prototype.reactivate = function (newOptions) {
    InsideLabelPlaceholderStrategy.superclass.reactivate.call(this, newOptions);
    this._destroyPlaceholderToggle();
    this._createPlaceholderToggle();
  };

  /**
   * @public
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   * @override
   */
  InsideLabelPlaceholderStrategy.prototype.deactivate = function () {
    this._destroyPlaceholderToggle();
    InsideLabelPlaceholderStrategy.superclass.deactivate.call(this);
  };

  /**
   *
   * @param {Object=} content the messaging content that is being updated
   * @return {boolean}
   * @public
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   * @override
   */
  InsideLabelPlaceholderStrategy.prototype.shouldUpdate = function (content) {
    return (
      (content && content.converterHint !== undefined) || this.GetComponent().options.placeholder
    );
  };

  /**
   * @public
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   * @override
   */
  InsideLabelPlaceholderStrategy.prototype.update = function () {
    InsideLabelPlaceholderStrategy.superclass.update.call(this);
    this._placeholderChanged();
  };

  /**
   * @private
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   */
  InsideLabelPlaceholderStrategy.prototype._destroyPlaceholderToggle = function () {
    var component = this.GetComponent();
    var element = component._GetContentElement()[0];
    var rootElement = component._getRootElement();

    this._blurCallback();
    element.removeEventListener('focusout', this._blurCallback, false);
    delete this._blurCallback;

    element.removeEventListener('focusin', this._focusCallback, false);
    delete this._focusCallback;

    rootElement.removeEventListener('placeholderChanged', this._placeholderChangedCallback, false);
    delete this._placeholderChangedCallback;

    if (component._HasPlaceholderSet()) {
      component._SetPlaceholder(component.options.placeholder);
      component._customPlaceholderSet = true;
    }
  };

  /**
   * @private
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   */
  InsideLabelPlaceholderStrategy.prototype._createPlaceholderToggle = function () {
    var component = this.GetComponent();
    var element = component._GetContentElement()[0];
    var rootElement = component._getRootElement();

    component._customPlaceholderSet = true;
    this._blurCallback = InsideLabelPlaceholderStrategy._blurHandler.bind(this, element);
    element.addEventListener('focusout', this._blurCallback, false);

    this._focusCallback = InsideLabelPlaceholderStrategy._focusHandler.bind(this);
    element.addEventListener('focusin', this._focusCallback, false);

    this._placeholderChangedCallback = this._placeholderChanged.bind(this);
    rootElement.addEventListener('placeholderChanged', this._placeholderChangedCallback, false);

    this._placeholderChanged();
  };

  /**
   * @private
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @instance
   */
  InsideLabelPlaceholderStrategy.prototype._placeholderChanged = function () {
    var component = this.GetComponent();
    var element = component._GetContentElement()[0];

    var callback;
    if (FocusUtils.containsFocus(element)) {
      callback = this._focusCallback;
    } else {
      callback = this._blurCallback;
    }
    // Allow the component to complete default processing. setPlaceholder will
    // following after the value changed from _AfterSetOption - invoke micro next-tick.
    Promise.resolve(true).then(function () {
      callback();
    });
  };

  /**
   * Returns true if the converter hint should be shown in the placeholder area.
   * If displayOptions are to be ignored, like in Redwood theme, then this returns false.
   * If displayOptions.converter-hint is 'none', then this returns false;
   * @public
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @param {Object} component
   * @return {boolean}
   * @static
   */
  InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder = function (component) {
    var displayOptions = component.options.displayOptions;
    if (!displayOptions || component._getResolvedUserAssistance() !== 'displayOptions') {
      return false;
    }
    var converterHint = displayOptions.converterHint;
    if (converterHint instanceof Array) {
      return converterHint[0] === 'placeholder';
    }
    return converterHint === 'placeholder';
  };

  /**
   * @private
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @static
   */
  InsideLabelPlaceholderStrategy._focusHandler = function () {
    var component = this.GetComponent();

    var placeholder;
    if (InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder(component)) {
      var hints = this.GetConverterHint();
      placeholder = hints.length > 0 ? hints[0] : null;
    }
    if (!placeholder) {
      placeholder = component.options.placeholder;
    }

    component._SetPlaceholder(placeholder);
  };

  /**
   * @private
   * @memberof oj.InsideLabelPlaceholderStrategy
   * @static
   */
  InsideLabelPlaceholderStrategy._blurHandler = function (element) {
    if (element.hasAttribute('aria-haspopup')) {
      // ignore blur handling if the component has a popup and the popup has focus
      var popupId = element.getAttribute('aria-owns');
      var popupDom = document.getElementById(popupId);
      if (FocusUtils.containsFocus(popupDom)) {
        return;
      }
    }

    var placeholder;
    var component = this.GetComponent();
    if (InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder(component)) {
      var hints = this.GetConverterHint();
      placeholder = hints.length > 0 ? hints[0] : null;
    }
    if (!placeholder) {
      placeholder = component.options.placeholder;
    }

    // if the component legally has a placeholder we cant set it to null.
    // if we do that, select components will choke. Because they rely on placeholder
    // to decide if it should render a empty option etc.
    // So if there is a legal placeholder, we will just set its value to empty on blur.
    if (placeholder === null || placeholder === undefined) {
      component._SetPlaceholder(null);
    } else {
      component._SetPlaceholder('');
    }
  };

  /**
   * Adapter for handling aspects of floating labels.
   * Extends the MessagingStrategy which does more now than messages. It now
   * is also for rendering the form component's label in one of many positions.
   *
   * @extends BaseInsideLabelStrategy
   * @protected
   * @constructor
   * @since 7.0.0
   * @class oj.InsideLabelStrategy
   * @ignore
   * @ojtsignore
   * @param {Array.<string>} displayOptions an array of messaging artifacts that are
   * displayed as an inside label for text fields.
   * For LabelStrategies this is always only labelEdge.
   */
  const InsideLabelStrategy = function (displayOptions) {
    this.Init(displayOptions);
    this._displayOptions = displayOptions;
  };

  /**
   * Registers the LabelStrategy constructor function with ComponentMessaging.
   *
   * @private
   */
  oj.ComponentMessaging.registerMessagingStrategy(
    oj.ComponentMessaging._STRATEGY_TYPE.LABEL_EDGE_INSIDE,
    InsideLabelStrategy
  );

  // Subclass from BaseInsideLabelStrategy
  oj.Object.createSubclass(InsideLabelStrategy, BaseInsideLabelStrategy, 'oj.InsideLabelStrategy');

  /**
   * @param {Object} cm a reference to an instance of ComponentMessaging that provides access to
   * the latest messaging content.
   * @public
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @override
   */
  InsideLabelStrategy.prototype.activate = function (cm) {
    InsideLabelStrategy.superclass.activate.call(this, cm);
    this._componentMessaging = cm;

    const component = this.GetComponent();
    const element = component._getRootElement();
    this._placeholderChangedCallback = this._placeholderChangedHandler.bind(this);
    element.addEventListener('placeholderChanged', this._placeholderChangedCallback);
    this._activatePlaceholderStrategyIfNeeded(cm);
    this._CreateLabel();
  };

  /**
   * @param {Array.<string>} newOptions
   * @public
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @override
   */
  InsideLabelStrategy.prototype.reactivate = function (newDisplayOptions) {
    InsideLabelStrategy.superclass.reactivate.call(this, newDisplayOptions);

    this._DestroyLabel();
    this._CreateLabel();
    if (this._placeholderStrategy) {
      this._placeholderStrategy.reactivate(newDisplayOptions);
    } else {
      // we haven't activated the placeholder yet, so do it now.
      this._activatePlaceholderStrategyIfNeeded(this._componentMessaging);
    }
  };

  /**
   * @param {Object=} content the messaging content object. If it contains validityState, then
   * this means the component has messaging content.
   * @return {boolean}
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @oublic
   * @override
   */
  InsideLabelStrategy.prototype.shouldUpdate = function (content) {
    if (this._placeholderStrategy) {
      return this._placeholderStrategy.shouldUpdate(content);
    }
    return false;
  };

  /**
   * Updates component with instance using the content provided.
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @public
   * @override
   */
  InsideLabelStrategy.prototype.update = function () {
    if (this._placeholderStrategy) {
      this._placeholderStrategy.update();
    }
  };

  /**
   * Cleans up messages on the component and destroys any widgets it created.
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @public
   * @override
   */
  InsideLabelStrategy.prototype.deactivate = function () {
    if (this._placeholderStrategy) {
      this._placeholderStrategy.deactivate();
      delete this._placeholderStrategy;
    }
    // Remove event handlers
    const component = this.GetComponent();
    const element = component._getRootElement();
    element.removeEventListener('placeholderChanged', this._placeholderChangedCallback);
    delete this._placeholderChangedCallback;
    this._DestroyLabel();
    InsideLabelStrategy.superclass.deactivate.call(this);
  };

  /**
   * activate the PlaceholderStrategy if they have not already been activated.
   *
   * @private
   * @memberof oj.InsideLabelStrategy
   * @instance
   */
  InsideLabelStrategy.prototype._activatePlaceholderStrategyIfNeeded = function (cm) {
    if (this._placeholderStrategy === undefined) {
      let createInsideLabelPlaceholderStrategy = () => {
        let Callback = InsideLabelPlaceholderStrategy;
        this._placeholderStrategy = new Callback(this._displayOptions);
        this._placeholderStrategy.activate(cm);
      };
      const component = this.GetComponent();
      const compOptions = component.options;
      // If the component has a placeholder or if it uses displayOptions+
      // has it set so that converter is shown as a placeholder.
      // Note: the Redwood theme does not use displayOptions.
      let needsInsidePlaceholder =
        compOptions.placeholder ||
        (component._getResolvedUserAssistance() === 'displayOptions' &&
          InsideLabelPlaceholderStrategy.ShowConverterHintAsPlaceholder(component));
      if (needsInsidePlaceholder) {
        createInsideLabelPlaceholderStrategy();
      }
    }
  };

  /**
   * If placeholder has a value, then activate the sub-strategy if it isn't
   * yet activated.
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @private
   */
  InsideLabelStrategy.prototype._placeholderChangedHandler = function () {
    this._activatePlaceholderStrategyIfNeeded(this._componentMessaging);
  };

  /**
   * Gets the form component's container.
   * @memberof oj.InsideLabelStrategy
   * @instance
   * @protected
   * @override
   */
  InsideLabelStrategy.prototype._GetContainer = function (component) {
    let container = component._GetFormControlContainer();
    if (!container) {
      return null;
    }

    // look for a component container override
    let fname = '_GetContentWrapper';
    if (component[fname]) {
      container = component[fname]();
    }
    return container;
  };
  /**
   * @memberof oj.InsideLabelStrategy
   * @protected
   * @override
   * @param {string} labelEdgeValue
   * @return {string}
   */
  InsideLabelStrategy.prototype._GetFormControlLabelStyleClass = function () {
    let labelEdgeValue = 'inside';
    return [InsideLabelStrategy._BASE_STYLE_CLASS, 'label', labelEdgeValue.toLowerCase()].join('-');
  };

  /**
   * @memberof oj.InsideLabelStrategy
   * @protected
   * @override
   * @param {Element} ojlabel
   * @param {Element} container
   * @param {Object} component
   * @return {string}
   */
  // eslint-disable-next-line no-unused-vars
  InsideLabelStrategy.prototype._InsertOjLabel = function (ojlabel, container) {
    // node.insertBefore(newnode, existingnode);
    // insert the new ojlabel element before the existing firstChildElement.
    container.insertBefore(ojlabel, container.firstElementChild);
  };

  /**
   * Base selector (prefix) for styling floating labels
   * @const
   * @private
   * @type {string}
   */
  InsideLabelStrategy._BASE_STYLE_CLASS = 'oj-text-field';

  exports.EditableValueUtils = EditableValueUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojconverter',['ojs/ojcore-base', 'jquery'], function (oj, $) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * Constructs an immutable instance of Converter.
   * @param {Object=} options an object literal used to provide an optional information to
   * initialize the converter.<p>
   * @export
   * @ojsignature {target: "Type", value: "interface Converter<V>",
   *               genericParameters: [{"name": "V", "description": "Type of value to be converted. Parse will
   *                 convert string to this type and format will format this type to string"}]}
   * @ojtsmodule
   * @name oj.Converter
   * @interface
   * @since 0.6.0
   */
  const Converter = function (options) {
    this.Init(options);
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(Converter, oj.Object, 'oj.Converter');

  /**
   * Initializes converter instance with the set options
   * @param {Object=} options an object literal used to provide an optional information to
   * initialize the converter.<p>
   * @export
   * @ignore
   * @memberof oj.Converter
   */
  Converter.prototype.Init = function (options) {
    Converter.superclass.Init.call(this);
    // should we make options truly immutable? non-configurable, non-enumerable, non-writable
    // Object.defineProperty(oj.Converter.prototype, "_options", {value: options});
    this._options = options;
  };

  /**
   * Returns a hint that describes the converter format expected.
   * @method getHint
   * @return {string|null} a hint describing the format the value is expected to be in.
   * @memberof oj.Converter
   * @ojsignature {target: "Type", value: "?(): string|null"}
   * @instance
   */

  /**
   * Returns the options called with converter initialization.
   * @method getOptions
   * @return {Object} an object of options.
   * @ojsignature {target: "Type", value: "?(): object"}
   * @memberof oj.Converter
   * @instance
   * @export
   */
  Converter.prototype.getOptions = function () {
    return this._options || {};
  };

  /**
   * Parses a String value using the options provided.
   * @method parse
   * @param {string} value to parse
   * @return {any} the parsed value.
   * @ojsignature [
   *                {target: "Type", value: "V|null", for: "returns"}
   *              ]
   * @throws {Error} if parsing fails
   * @memberof oj.Converter
   * @instance
   */

  /**
   * Formats the value using the options provided.
   *
   * @param {any} value the value to be formatted for display
   * @return {(string|null)} the localized and formatted value suitable for display
   * @throws {Error} if formatting fails.
   * @method format
   * @ojsignature {target: "Type", value: "V", for: "value"}
   * @memberof oj.Converter
   * @instance
   */

  /**
   * Returns an object literal with locale and formatting options computed during initialization of
   * the object. If options was not provided at the time of initialization, the properties will be
   * derived from the locale defaults.
   * @return {Object} an object of resolved options.
   * @ojsignature {target: "Type", value: "?(): object"}
   * @export
   * @memberof oj.Converter
   * @instance
   * @method resolvedOptions
   */
  Converter.prototype.resolvedOptions = function () {
    var resolved = {};
    // returns a clone of this._options
    $.extend(resolved, this._options);

    return resolved;
  };

  return Converter;

});


define('ojs/ojvalidator-async',[],function () { 'use strict';

	/* devel:true*/

	/**
	 * Validator Contract
	 * @ignore
	 */

	/**
	 * The AsyncValidator interface is a duck-typing interface for creating
	 * asynchronous validators that can be set on the EditableValue (aka JET form) components
	 * that have the <code class="prettyprint">async-validators</code> attribute.
	 * @example <caption>Create an Object that duck-types the AsyncValidator interface.
	 * Bind the Object to the JET form component's async-validators attribute. The
	 * validator's 'validate' method will be called when the user changes the input.</caption>
	 *  self.asyncValidator1 = {
	 *    // required validate method
	 *    'validate': function(value) {
	 *      return new Promise(function(resolve, reject) {
	 *        var successful = someBackendMethod();
	 *        if (successful) {
	 *          resolve();
	 *        } else {
	 *          reject(new Error('The amount of purchase is too high. It is ' + value));
	 *        }
	 *      });
	 *    },
	 *    // optional hint attribute. hint shows up when user sets focus to input.
	 *    'hint': new Promise(function (resolve, reject) {
	 *      var formattedMaxPurchase = getSomeBackendFormattedMaxPurchase();
	 *      resolve(maxPurchase + " is the maximum.");
	 *    });
	 *  };
	 *  -- HTML --
	 *  &lt;oj-input-text value="{{value1}}"
	 *  async-validators="[[[asyncValidator1]]]">&lt;/oj-input-text>
	 * @interface oj.AsyncValidator
	 * @ojtsmodule
	 * @ojsignature {target: "Type", value: "interface AsyncValidator<V>",
	 *               genericParameters: [{"name": "V", "description": "Type of value to be validated"}]}
	 * @export
	 * @since 5.2.0
	 *
	 *
	 */

	/**
	 * <p>A method that validates the value.
	 * The function returns a Promise that resolves to void
	 * if the validation passes or a Promise that rejects with an error if it fails. The error will
	 * be shown on the component.
	 * </p>
	 * <p>
	 * It is recommended that you show the value you are validating in the error message
	 * because if the async operation takes a while, the user could be typing in a new
	 * value when the error message comes back and might be confused what value the error is for.
	 * </p>
	 * <p>If you need to format the value for the error message, you
	 * can use e.g. for number
	 * <code class="prettyprint">new NumberConverter.IntlNumberConverter(converterOption)</code> to get the
	 * converter instance, then call converter.format(value);
	 * </p>
	 *
	 * @example <caption>Create an asynchronous validator and use it on an EditableValue
	 * component. First, create an Object with 'validate' method that returns a Promise.
	 * Then, bind it to the JET form component's async-validators attribute.</caption>
	 *  self.asyncValidator1 = {
	 *    'validate': function(value) {
	 *      return new Promise(function(resolve, reject) {
	 *        var successful = someBackendMethod();
	 *        if (successful) {
	 *          resolve();
	 *        } else {
	 *          //NOTE: if you need to format the value using a converter, you can call
	 *          // e.g. for number
	 *          // new NumberConverter.IntlNumberConverter(converterOption); to get the
	 *          // converter instance, then call converter.format(value);
	 *          reject(new Error('The amount of purchase ('+value+') is too high.'));
	 *        }
	 *      });
	 *    }
	 *  };
	 *  -- HTML --
	 *  &lt;oj-input-text value="{{value}}"
	 *  async-validators="[[[asyncValidator1]]]">&lt;/oj-input-text>
	 * @param {any} value to be validated
	 * @return {Promise<void>} A Promise that resolves to nothing if validation passes or
	 *  rejects with an Error if validation fails.
	 * @method validate
	 * @export
	 * @expose
	 * @ojsignature { target: "Type", value: "(value: V): Promise<void>" }
	 * @memberof oj.AsyncValidator
	 * @instance
	 *
	 */

	/**
	 * hint is an optional attribute. It is a Promise that resolves to the hint string or null.
	 * @example <caption>Create an Object that duck-types the oj.AsyncValidator interface.
	 * Bind the Object to the JET form component's async-validators attribute. The
	 * validator's 'hint'  will be called when the user focuses on the input and it
	 * shows up as a notewindow giving the user a hint to what the validator will do.</caption>
	 *  self.asyncValidator1 = {
	 *    // required validate method
	 *    'validate': function(value) {
	 *      return new Promise(function(resolve, reject) {
	 *        var successful = someBackendMethod();
	 *        if (successful) {
	 *          resolve();
	 *        } else {
	 *          reject(new Error('The amount of purchase ' + value +' is too high.'));
	 *        }
	 *      });
	 *    },
	 *    // optional hint attribute. hint shows up when user tabs to input.
	 *    'hint': new Promise(function (resolve, reject) {
	 *      // resolve the credit score REST call, and figure out what
	 *      // is the maximum purchase dollar amount.
	 *      var formattedMaxPurchase = getFormattedMaxPurchase();
	 *      resolve('Your max purchase amount is ' + formattedMaxPurchase);
	 *    });
	 *  };
	 *  -- HTML --
	 *  &lt;oj-input-text value="{{value}}"
	 *  async-validators="[[[asyncValidator1]]]">&lt;/oj-input-text>
	 * @export
	 * @expose
	 * @memberof oj.AsyncValidator
	 * @instance
	 * @name hint
	 * @type {Promise<string|null>=}
	 *
	 */

	// end of jsdoc

});


define('ojs/ojconverterutils-i18n',['exports', 'ojs/ojcore-base', 'ojs/ojtranslation', 'jquery', '@oracle/oraclejet-preact/UNSAFE_IntlDateTime', 'ojs/ojconverterutils', 'ojs/ojvalidation-error'], function (exports, oj, Translations, $, UNSAFE_IntlDateTime, ConverterUtils, ojvalidationError) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  ConverterUtils = ConverterUtils && Object.prototype.hasOwnProperty.call(ConverterUtils, 'default') ? ConverterUtils['default'] : ConverterUtils;

  /*
   DESCRIPTION
   OraI18nUtils provides helper functions for converter objects.

   PRIVATE CLASSES
   <list of private classes defined - with one-line descriptions>

   NOTES
   <other useful comments, qualifications, etc.>

   * @namespace oj.OraI18nUtils
   * @classdesc Helper functions for converter objects
   * @ignore
   * @export
   * @since 0.6.0
   * @ojtsnoexport
   */

  const OraI18nUtils = {};
  // supported numbering systems
  OraI18nUtils.numeringSystems = {
    latn: '\u0030\u0031\u0032\u0033\u0034\u0035\u0036\u0037\u0038\u0039',
    arab: '\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669',
    thai: '\u0e50\u0e51\u0e52\u0e53\u0e54\u0e55\u0e56\u0e57\u0e58\u0e59'
  };

  OraI18nUtils.regexTrim = /^\s+|\s+$|\u200f|\u200e/g;
  OraI18nUtils.regexTrimNumber = /\s+|\u200f|\u200e/g;
  OraI18nUtils.regexTrimRightZeros = /0+$/g;
  OraI18nUtils.zeros = ['0', '00', '000'];
  // ISO 8601 string accepted values:
  // -date only: YYYY or YYYY-MM or YYYY-MM-dd
  // -time only without timezone: Thh:mm or Thh:mm:ss or Thh:mm:ss.SSS
  // -time only with timezone: any of the time values above followed by any of the following:
  // Z or +/-hh:mm or +/-hhmm or +/-hh
  // -date time: any of the date values followed by any of the time values
  OraI18nUtils._ISO_DATE_REGEXP = UNSAFE_IntlDateTime.DateTimeUtils._ISO_DATE_REGEXP;
  /**
   * Returns the timezone offset between UTC and the local time in Etc/GMT[+-]h syntax.
   * <p>
   * The offset is positive if the local timezone is behind UTC and negative if
   * it is ahead. The offset range is between Etc/GMT-14 and Etc/GMT+12 (UTC-12 and UTC+14)
   * Examples:
   * 1- The local time is UTC-7 (Pacific Daylight Time):
   * OraI18nUtils. getLocalTimeZoneOffset() will return the string "Etc/GMT+7"
   * 2- The local time is UTC+1 (Central European Standard Time):
   * OraI18nUtils. getLocalTimeZoneOffset() will return the string "Etc/GMT-1"
   * </p>
   * <p>
   * NOTE: Since JET v12.0.0, the IntlDateTimeConverter will fallback to the local system time zone
   * if no timeZone is in the options.
   * So instead of using this API to get a local timezone offset to pass the converter,
   * you should not set any timeZone in the converter options.
   * </p>
   * @param {Date=} date optional Date object. If not present return the local time zone
   * offset of the current date, otherwise return the local time zone offset at the
   * particular date.
   * @returns {string}
   * @memberof oj.OraI18nUtils
   * @method getLocalTimeZoneOffset
   */
  OraI18nUtils.getLocalTimeZoneOffset = function (date) {
    var d = date || new Date();
    var offset = d.getTimezoneOffset();

    // getTimeStringFromOffset recently changed to return 'z' for offset 0, and we don't want to return that from this method.
    // this code will still work if getTimeStringFromOffset decides not to return 'z' for offset 0.
    return offset !== 0
      ? OraI18nUtils.getTimeStringFromOffset('Etc/GMT', offset, false, false)
      : 'Etc/GMT+0';
  };

  /*
   * Will return timezone if it exists.
   */
  // This private method is not called, commenting out for now to remove it from code coverage calculations
  // OraI18nUtils._getTimeZone = function (isoString)
  // {
  //  if (!isoString || typeof isoString !== "string")
  //  {
  //    return null;
  //  }
  //  var match = OraI18nUtils._ISO_DATE_REGEXP.exec(isoString);
  //  //make sure it is iso string
  //  if (match === null)
  //  {
  //    OraI18nUtils._throwInvalidISOString(isoString);
  //  }
  //  if (match[1] !== undefined)
  //    return match[1];
  //  return null;
  // };

  /**
   * <p>Returns a local ISO string provided a Date object.
   * This method can be used to convert a moment in time or a local ISO string into
   * a local ISO string. It can also be used to convert any Date object into local ISO
   * string.</p>
   * Examples below are where the local (user's system) time zone is UTC-06:00<br>
   * dateToLocalIso(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03T22:00:00'<br>
   * dateToLocalIso(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03T20:30:00'<br>
   * In this example the input ISO string is local, the output is the same:<br>
   * dateToLocalIso(new Date('2021-06-04T02:30:00')); -->'2021-06-04T02:30:00'<br>
   * In this example we just want to convert a Date object:<br>
   * dateToLocalIso(new Date());<br>
   *
   * @param {Date} _date
   * @returns {string} isoString
   * @export
   * @since 0.7.0
   * @memberof oj.OraI18nUtils
   * @method dateToLocalIso
   */
  OraI18nUtils.dateToLocalIso = function (_date) {
    var date = _date;
    if (typeof date === 'number') {
      date = new Date(date);
    }
    var isoStr =
      OraI18nUtils.padZeros(date.getFullYear(), 4) +
      '-' +
      OraI18nUtils.padZeros(date.getMonth() + 1, 2) +
      '-' +
      OraI18nUtils.padZeros(date.getDate(), 2) +
      'T' +
      OraI18nUtils.padZeros(date.getHours(), 2) +
      ':' +
      OraI18nUtils.padZeros(date.getMinutes(), 2) +
      ':' +
      OraI18nUtils.padZeros(date.getSeconds(), 2);
    if (date.getMilliseconds() > 0) {
      isoStr += '.' + OraI18nUtils.trimRightZeros(OraI18nUtils.padZeros(date.getMilliseconds(), 3));
    }
    return isoStr;
  };

  /**
   * <p>Returns the date only portion of a local ISO string provided a Date object.
   * This method can be used to convert a moment in time ISO string into a local
   * ISO string and get the date part of it. This method is useful if you are storing
   * your dates as a moment in time and you want to use it in a date only component,
   * like oj-input-date, that shows the date in the timezone of the user's local system.</p>
   * Examples where local time zone offset is UTC-06:00<br>
   * dateToLocalIsoDateString(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03'<br>
   * dateToLocalIsoDateString(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03'<br>
   *
   * @param {Date} date
   * @returns {string} date portion only of the ISO String
   * @export
   * @since 12.0.0
   * @memberof oj.OraI18nUtils
   * @method dateToLocalIsoDateString
   */
  OraI18nUtils.dateToLocalIsoDateString = function (date) {
    var isoStr = OraI18nUtils.dateToLocalIso(date);
    var parts = isoStr.split('T');
    return parts[0];
  };

  /**
   * @memberof oj.OraI18nUtils
   * @method partsToIsoString
   */
  OraI18nUtils.partsToIsoString = function (parts) {
    var isoStr =
      OraI18nUtils.padZeros(parts[0], 4) +
      '-' +
      OraI18nUtils.padZeros(parts[1], 2) +
      '-' +
      OraI18nUtils.padZeros(parts[2], 2) +
      'T' +
      OraI18nUtils.padZeros(parts[3], 2) +
      ':' +
      OraI18nUtils.padZeros(parts[4], 2) +
      ':' +
      OraI18nUtils.padZeros(parts[5], 2);
    if (parts[6] > 0) {
      isoStr += '.' + OraI18nUtils.trimRightZeros(OraI18nUtils.padZeros(parts[6], 3));
    }
    return isoStr;
  };

  /**
   * Returns a local Date object from a local ISO string. This method is only meant
   * to work with local ISO strings. If the input ISO string contain Z or offset,
   * they will be ignored.
   * @param {string} isoString
   * @memberof oj.OraI18nUtils
   * @method isoToLocalDate
   */
  OraI18nUtils.isoToLocalDate = function (isoString) {
    if (!isoString || typeof isoString !== 'string') {
      return null;
    }
    return this._isoToLocalDateIgnoreTimezone(isoString);
  };

  OraI18nUtils._isoToLocalDateIgnoreTimezone = function (isoString) {
    var datetime = OraI18nUtils._IsoStrParts(isoString);
    var date = new Date(
      datetime[0],
      datetime[1] - 1,
      datetime[2],
      datetime[3],
      datetime[4],
      datetime[5],
      datetime[6]
    );
    // As per the documentation:
    // new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);
    // year - Integer value representing the year and
    // values from 0 to 99 map to the years 1900 to 1999; all other values are the actual year.
    // Use Date.prototype.setFullYear to create dates between the years 0 and 99.
    date.setFullYear(datetime[0]);
    return date;
  };

  OraI18nUtils._IsoStrParts = function (isoString) {
    var tst = OraI18nUtils._ISO_DATE_REGEXP.test(isoString);
    if (tst === false) {
      OraI18nUtils._throwInvalidISOStringSyntax(isoString);
    }
    var splitted = isoString.split('T');
    var tIndex = isoString.indexOf('T');
    var today = new Date();
    var i;
    var isBC = false;
    var datetime = [today.getFullYear(), today.getMonth() + 1, today.getDate(), 0, 0, 0, 0];

    if (splitted[0] !== '') {
      // contains date portion
      // test if date is BC, year is negative
      if (OraI18nUtils.startsWith(splitted[0], '-')) {
        splitted[0] = splitted[0].substr(1);
        isBC = true;
      }
      var dateSplitted = splitted[0].split('-');
      for (i = 0; i < dateSplitted.length; i++) {
        var val = parseInt(dateSplitted[i], 10);
        // validate month
        if (i === 1) {
          if (val < 1 || val > 12) {
            OraI18nUtils._throwInvalidISOStringRange(isoString, 'month', val, 1, 12);
          }
        }
        // validate day
        if (i === 2) {
          var nbDays = OraI18nUtils._getDaysInMonth(datetime[0], datetime[1] - 1);
          if (val < 1 || val > nbDays) {
            OraI18nUtils._throwInvalidISOStringRange(isoString, 'day', val, 1, nbDays);
          }
        }
        datetime[i] = val;
      }
      if (isBC) {
        datetime[0] = -datetime[0];
      }
    }

    if (tIndex !== -1) {
      var milliSecSplitted = splitted[1].split('.'); // contain millseconds
      var timeSplitted = milliSecSplitted[0].split(':'); // contain hours, minutes, seconds

      for (i = 0; i < timeSplitted.length; i++) {
        var tVal = parseInt(timeSplitted[i], 10);
        // validate hour
        if (i === 0) {
          if (tVal < 0 || tVal > 24) {
            OraI18nUtils._throwInvalidISOStringRange(isoString, 'hour', tVal, 0, 24);
          }
        }
        // validate minute
        if (i === 1) {
          if (tVal < 0 || tVal > 59) {
            OraI18nUtils._throwInvalidISOStringRange(isoString, 'minute', tVal, 0, 59);
          }
        }
        // validate second
        if (i === 2) {
          if (tVal < 0 || tVal > 59) {
            OraI18nUtils._throwInvalidISOStringRange(isoString, 'second', tVal, 0, 59);
          }
        }
        datetime[3 + i] = tVal;
      }

      if (milliSecSplitted.length === 2 && milliSecSplitted[1]) {
        datetime[6] = parseInt(OraI18nUtils.zeroPad(milliSecSplitted[1], 3, false), 10);
      }
    }
    return datetime;
  };

  /**
   * @memberof oj.OraI18nUtils
   * @method getISOStrFormatInfo
   */
  OraI18nUtils.getISOStrFormatInfo = function (isoStr) {
    var res = {
      format: null,
      dateTime: null,
      timeZone: '',
      isoStrParts: null
    };
    var exe = OraI18nUtils._ISO_DATE_REGEXP.exec(isoStr);

    if (exe === null) {
      OraI18nUtils._throwInvalidISOStringSyntax(isoStr);
    }
    if (exe && exe[1] === undefined && exe[2] === undefined) {
      res.format = 'local';
      res.dateTime = isoStr;
      res.isoStrParts = OraI18nUtils._IsoStrParts(res.dateTime);
      return res;
    }
    res.timeZone = exe[1] !== undefined ? exe[1] : exe[2];
    if (res.timeZone === 'Z') {
      res.format = 'zulu';
    } else {
      res.format = 'offset';
    }
    var isoStrLen = isoStr.length;
    var timeZoneLen = res.timeZone.length;
    res.dateTime = isoStr.substring(0, isoStrLen - timeZoneLen);
    res.isoStrParts = OraI18nUtils._IsoStrParts(res.dateTime);
    return res;
  };

  /**
   * Returns the format type of the isoStr: 'local', 'zulu' or 'offset',
   * or throw invalidISOStringSytax error
   * @param {string} isoStr isoString
   * @returns {'local'|'zulu'|'offset'} isoString format: 'local', 'zulu', or 'offset'
   * @throws Error
   * @memberof oj.OraI18nUtils
   * @method getISOStrFormatType
   */
  OraI18nUtils.getISOStrFormatType = function (isoStr) {
    let format;
    const exe = OraI18nUtils._ISO_DATE_REGEXP.exec(isoStr);

    if (exe === null) {
      OraI18nUtils._throwInvalidISOStringSyntax(isoStr);
    }
    if (exe && exe[1] === undefined && exe[2] === undefined) {
      format = 'local';
      return format;
    }
    let timeZone = exe[1] !== undefined ? exe[1] : exe[2];
    if (timeZone === 'Z') {
      format = 'zulu';
    } else {
      format = 'offset';
    }
    return format;
  };

  // This private method is not called, commenting out for now to remove it from code coverage calculations
  // OraI18nUtils._throwTimeZoneNotSupported = function () {
  //  var msg, error, errorInfo;
  //  msg = "time zone is not supported";
  //  error = new Error(msg);
  //  errorInfo = {
  //    'errorCode': 'timeZoneNotSupported'
  //  };
  //  error['errorInfo'] = errorInfo;
  //  throw error;
  // };

  OraI18nUtils._isLeapYear = function (y) {
    if (y % 400 === 0) {
      return true;
    } else if (y % 100 === 0) {
      return false;
    } else if (y % 4 === 0) {
      return true;
    }
    return false;
  };

  // Get days in month depending on month and leap year
  OraI18nUtils._getDaysInMonth = function (y, m) {
    switch (m) {
      case 0:
      case 2:
      case 4:
      case 6:
      case 7:
      case 9:
      case 11:
        return 31;
      case 1:
        if (OraI18nUtils._isLeapYear(y)) {
          return 29;
        }
        return 28;
      default:
        return 30;
    }
  };

  // throws RangeError(message: string, options?: {cause?: {code?:string, parameterMap?: Record<string, string>}})
  OraI18nUtils._throwInvalidISOStringRange = function (
    isoStr,
    name,
    displayValue,
    displayLow,
    displayHigh
  ) {
    var msg =
      'The string ' +
      isoStr +
      ' is not a valid ISO 8601 string: ' +
      displayValue +
      ' is out of range.  Enter a value between ' +
      displayLow +
      ' and ' +
      displayHigh +
      ' for ' +
      name;
    const errorInfo = {
      cause: {
        code: 'isoStringOutOfRange',
        parameterMap: {
          isoStr: isoStr,
          value: displayValue,
          minValue: displayLow,
          maxValue: displayHigh,
          propertyName: name
        }
      }
    };
    const rangeError = new RangeError(msg, errorInfo);
    throw rangeError;
  };

  // throws Error(message: string, options?: {cause?: {code?:string, parameterMap?: Record<string, string>}})
  OraI18nUtils._throwInvalidISOStringSyntax = function (str) {
    var msg = 'The string ' + str + ' is not a valid ISO 8601 string syntax.';
    const e = new Error(msg, { cause: { code: 'invalidISOString', parameterMap: { isoStr: str } } });
    throw e;
  };

  OraI18nUtils.trim = function (value) {
    return (value + '').replace(OraI18nUtils.regexTrim, '');
  };

  OraI18nUtils.trimRightZeros = function (value) {
    return (value + '').replace(OraI18nUtils.regexTrimRightZeros, '');
  };

  OraI18nUtils.trimNumber = function (value) {
    var s = (value + '').replace(OraI18nUtils.regexTrimNumber, '');
    return s;
  };

  OraI18nUtils.startsWith = function (value, pattern) {
    return value.indexOf(pattern) === 0;
  };

  OraI18nUtils.toUpper = function (value) {
    // "he-IL" has non-breaking space in weekday names.
    return value.split('\u00A0').join(' ').toUpperCase();
  };

  OraI18nUtils.padZeros = function (num, c) {
    var s = num + '';
    var isNegative = false;
    if (num < 0) {
      s = s.substr(1);
      isNegative = true;
    }
    if (c > 1 && s.length < c) {
      s = OraI18nUtils.zeros[c - 2] + s;
      s = s.substr(s.length - c, c);
    }
    if (isNegative) {
      s = '-' + s;
    }
    return s;
  };

  OraI18nUtils.zeroPad = function (str, count, left) {
    var result = '' + str;

    for (var l = result.length; l < count; l += 1) {
      result = left ? '0' + result : result + '0';
    }
    return result;
  };

  /**
   * @memberof oj.OraI18nUtils
   * @method getTimeStringFromOffset
   */
  OraI18nUtils.getTimeStringFromOffset = function (prefix, offset, reverseSign, alwaysMinutes) {
    var isNegative = reverseSign ? offset > 0 : offset < 0;
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    var sign = isNegative ? '-' : '+';

    if (alwaysMinutes) {
      hours = OraI18nUtils.zeroPad(hours, 2, true);
    }
    var str = prefix + sign + hours;
    if (minutes > 0 || alwaysMinutes) {
      str += ':' + OraI18nUtils.zeroPad(minutes, 2, true);
    }
    return str;
  };

  /**
   * get the numbering system key from the locale's unicode extension.
   * Verify that the locale data has a numbers entry for it, if not return latn as default.
   * @memberof oj.OraI18nUtils
   * @method getNumberingSystemKey
   */
  OraI18nUtils.getNumberingSystemKey = function (localeElements, locale) {
    if (locale === undefined) {
      return 'latn';
    }
    var numberingSystemKey = OraI18nUtils.getNumberingExtension(locale);
    var symbols = 'symbols-numberSystem-' + numberingSystemKey;
    if (localeElements.numbers[symbols] === undefined) {
      numberingSystemKey = 'latn';
    }
    return numberingSystemKey;
  };

  /**
   * return the language part
   * @memberof oj.OraI18nUtils
   * @method getBCP47Lang
   */
  OraI18nUtils.getBCP47Lang = function (tag) {
    var arr = tag.split('-');
    return arr[0];
  };

  // return the region part. tag is lang or lang-region or lang-script or
  // lang-script-region
  OraI18nUtils.getBCP47Region = function (tag) {
    var arr = tag.split('-');
    if (arr.length === 3) {
      return arr[2];
    }
    if (arr.length === 2) {
      if (arr[1].length === 2) {
        return arr[1];
      }
    }
    return '001';
  };

  // get the unicode numbering system extension.
  OraI18nUtils.getNumberingExtension = function (_locale) {
    var locale = _locale || 'en-US';
    var idx = locale.indexOf('-u-nu-');
    var numbering = 'latn';
    if (idx !== -1) {
      numbering = locale.substr(idx + 6, 4);
    }
    return numbering;
  };

  OraI18nUtils.haveSamePropertiesLength = function (obj) {
    return Object.keys(obj).length;
  };

  // cldr locale data start with "main" node.
  // return the subnode under main.
  OraI18nUtils.getLocaleElementsMainNode = function (bundle) {
    var mainNode = bundle.main;
    var keys = Object.keys(mainNode);
    return mainNode[keys[0]];
  };

  // get the locale which is a subnode of "main".
  OraI18nUtils.getLocaleElementsMainNodeKey = function (bundle) {
    var mainNode = bundle.main;
    var keys = Object.keys(mainNode);
    return keys[0];
  };

  OraI18nUtils._toBoolean = function (value) {
    if (typeof value === 'string') {
      var s = value.toLowerCase().trim();
      switch (s) {
        case 'true':
        case '1':
          return true;
        case 'false':
        case '0':
          return false;
        default:
          return value;
      }
    }
    return value;
  };
  // Return a function getOption.
  // The getOption function extracts the value of the property named
  // property from the provided options object, converts it to the required type,
  // checks whether it is one of a List of allowed values, and fills in a
  // fallback value if necessary.
  OraI18nUtils.getGetOption = function (options, getOptionCaller) {
    if (options === undefined) {
      throw new Error('Internal ' + getOptionCaller + ' error. Default options missing.');
    }

    var getOption = function (property, type, values, defaultValue) {
      if (options[property] !== undefined) {
        var value = options[property];
        switch (type) {
          case 'boolean':
            value = OraI18nUtils._toBoolean(value);
            break;
          case 'string':
            value = String(value);
            break;
          case 'number':
            value = Number(value);
            break;
          default:
            throw new Error('Internal error. Wrong value type.');
        }
        if (values !== undefined && values.indexOf(value) === -1) {
          var expectedValues = [];
          for (var i = 0; i < values.length; i++) {
            expectedValues.push(values[i]);
          }
          var msg =
            "The value '" +
            options[property] +
            "' is out of range for '" +
            getOptionCaller +
            "' options property '" +
            property +
            "'. Valid values: " +
            expectedValues;
          var rangeError = new RangeError(msg);
          var errorInfo = {
            errorCode: 'optionOutOfRange',
            parameterMap: {
              propertyName: property,
              propertyValue: options[property],
              propertyValueValid: expectedValues,
              caller: getOptionCaller
            }
          };
          rangeError.errorInfo = errorInfo;
          throw rangeError;
        }

        return value;
      }
      return defaultValue;
    };

    return getOption;
  };

  /**
   * matches a string to a reference string and returns the start and end indexes
   * of the match in the referensed string. The locale and options arguments let
   * applications specify the language whose sort order should be used and customize
   * the behavior of the function.
   *
   * @param {string} str the reference string
   * @param {string} pat The string against which the reference string is compared
   * @param {string} locale a BCP 47 language tag
   * @param {Object=} options Optional. An object with the following property:
   * sensitivity:
   *   Which differences in the strings should lead to non-zero result values. Possible values are:
   *   "base": Only strings that differ in base letters compare as unequal. Examples: a ? b,  a = A.
   *   "accent": Only strings that differ in base letters or accents and other diacritic marks compare as unequal. Examples: a ? b, , a = A.
   *   "case": Only strings that differ in base letters or case compare as unequal. Examples: a ? b, a ? A.
   *   "variant": Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
   *   The default is base.
   * @return {Array|null} an array containing the start and end indexes of the match or null if there is no match.
   */
  OraI18nUtils.matchString = function (str, pat, locale, options) {
    if (options === undefined) {
      // eslint-disable-next-line no-param-reassign
      options = { sensitivity: 'base', usage: 'sort' };
    }
    var getOption = OraI18nUtils.getGetOption(options, 'OraI18nUtils.matchString');
    // eslint-disable-next-line no-param-reassign
    options.usage = getOption('usage', 'string', ['sort', 'search'], 'sort');
    // eslint-disable-next-line no-param-reassign
    options.sensitivity = getOption(
      'sensitivity',
      'string',
      ['base', 'accent', 'case', 'variant'],
      'base'
    );
    var len = str.length;
    var patLen = pat.length - 1;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < 3; j++) {
        var len2 = len - i;
        len2 = Math.min(len2, patLen + j);
        var str2 = str.substr(i, len2);
        var res = str2.localeCompare(pat, locale, options);
        if (res === 0) {
          var end = i + (len2 - 1);
          var ret = [i, end];
          return ret;
        }
      }
    }
    return null;
  };

  var _DEFAULT_TIME_PORTION = 'T00:00:00.000';
  var _DATE_TIME_KEYS = {
    fullYear: { pos: 0, pad: 4 },
    month: { pos: 1, pad: 2 },
    date: { pos: 2, pad: 2 },
    hours: { pos: 3, pad: 2 },
    minutes: { pos: 4, pad: 2 },
    seconds: { pos: 5, pad: 2 },
    milliseconds: { pos: 6, pad: 3 },
    timeZone: { pos: 7 }
  };

  /**
   * Parses the isoString and returns a JavaScript Date object
   *
   * @param {string} isoString isoString to parse and to return Date of
   * @return {Date} the parsed JavaScript Date Object
   * @method isoToDate
   * @ignore
   */
  OraI18nUtils.isoToDate = function (isoString) {
    // note new Date w/ isoString in IE fails so need to use parsing from momentjs support
    return new Date(this._normalizeIsoString(isoString));
  };

  /**
   * Will return an updated toIsoString using the timePortion from the fromIsoString or from the default
   * OraI18nUtils.DEFAULT_TIME_PORTION
   *
   * @private
   * @param {string} fromIsoString isoString that may not be a complete isoString
   * @param {string} toIsoString isoString that may not be a complete isoString
   * @returns {string} modified toIsoString with original date portion and the time portion from the fromIsoString
   * @since 1.1
   * @method _copyTimeOver
   */
  OraI18nUtils._copyTimeOver = function (fromIsoString, toIsoString) {
    if (!fromIsoString || !toIsoString) {
      throw new Error('Provided invalid arguments');
    }

    // need to only normalize toIsoString, since copying only time from fromIsoString
    var normalizedToIsoString = this._normalizeIsoString(toIsoString);

    var fromTimeIndex = fromIsoString.indexOf('T');
    var toTimeIndex = normalizedToIsoString.indexOf('T');
    var toDatePortion = normalizedToIsoString.substring(0, toTimeIndex);
    var fromTimePortion =
      fromTimeIndex !== -1 ? fromIsoString.substring(fromTimeIndex) : _DEFAULT_TIME_PORTION;

    return toDatePortion + fromTimePortion;
  };

  /**
   * Clears the time portion of the isoString
   *
   * @private
   * @param {string} isoString isoString that may not be a complete isoString
   * @returns {string} an updated isoString
   * @since 1.1
   * @method _clearTime
   */
  OraI18nUtils._clearTime = function (isoString) {
    return this._dateTime(isoString, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  };

  /**
   * Will accept an isoString and perform a get operation or a set operation depending on whether param is an Array
   * or a JSON
   *
   * The keys for the get and set operation are defined in _DATE_TIME_KEYS.
   *
   * Note the handling of month starting with 0 in Date object and being 1 based in isoString will be handled by the function
   * with the usage of doParseValue. Meaning when you doParseValue and you are getting the value it will automatically
   * decrement the value and when you are setting the param it will check if the value is of number and if so will
   * increment it.
   *
   * @private
   * @param {string} isoString isoString that may not be a complete isoString
   * @param {Array|Object} actionParam if an Array will be a get operation, if a JSON will be a set operation
   * @param {boolean=} doParseValue whether one should parseInt the value during the get request
   * @returns {Object|string} an Object when a get operation and a string when a set operation
   * @since 1.1
   * @method _dateTime
   */
  OraI18nUtils._dateTime = function (isoString, actionParam, doParseValue) {
    if (!isoString || !actionParam) {
      throw new Error('Invalid argument invocation');
    }

    var pos;
    var value;
    var retVal = null;
    var dateTimeKeys = _DATE_TIME_KEYS;
    var oraUtilsPadZero = this.padZeros;
    var isoStringNormalized = this._normalizeIsoString(isoString); // note intentionally normalizing
    var captured = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):?(\d{2})?\.?(\d{3})?(.*)?/.exec(
      isoStringNormalized
    );

    if (!captured) {
      throw new Error('Unable to capture anything');
    }

    captured = captured.slice(1);

    if (Array.isArray(actionParam)) {
      retVal = {};

      // means an array so perform a get operation
      for (var i = 0, len = actionParam.length; i < len; i++) {
        var key = actionParam[i];

        if (key in dateTimeKeys) {
          pos = dateTimeKeys[key].pos;
          value = captured[pos];

          if (doParseValue && key === 'timeZone') {
            throw new Error('Dude you tried to ask timezone to be parsed');
          }

          if (doParseValue) {
            var parsed = parseInt(value, 10);
            retVal[key] = pos === 1 ? parsed - 1 : parsed; // since month is 0 based, though about having a callback but month only special
          } else {
            retVal[key] = value;
          }
        }
      }
    } else if ($.isPlainObject(actionParam)) {
      var objKeys = Object.keys(actionParam);
      for (var k = 0; k < objKeys.length; k++) {
        var objKey = objKeys[k];
        var dtKey = dateTimeKeys[objKey];
        pos = dtKey.pos;
        value = actionParam[objKey];

        // special case for month again, 0 based so check if number and if so increment it
        if (pos === 1 && typeof value === 'number') {
          value += 1;
        }
        captured[pos] = dtKey.pad ? oraUtilsPadZero(value, dtKey.pad) : value;
      }
      // "2015-02-02T21:12:30.255Z"
      retVal =
        captured[0] +
        '-' +
        captured[1] +
        '-' +
        captured[2] +
        'T' +
        captured[3] +
        ':' +
        captured[4] +
        ':' +
        captured[5] +
        (captured.length > 6 && captured[6]
          ? '.' + captured[6] + (captured.length === 8 && captured[7] ? captured[7] : '')
          : '');
    }

    return retVal;
  };

  /**
   * So the problem is Jet uses incomplete isoString which causes issues in different browsers.
   *
   * For instance for a new Date().toISOString() => 2015-02-02T18:00:37.007Z
   * ojInputDate stores 2015-02-02
   * ojInputTime stores T18:00:37.007Z
   *
   * yet constructing new Date(val) on above causes different results or errors in different browsers, so
   * this function is to normalize them. Note it is assumed that the point is creating the Date object from the
   * normalized isoString. Meaning if both contain only the time portion today's date will appended to it.
   *
   * Here are the use cases
   *
   * @private
   * @param {string} isoString isoString that may not be a complete isoString
   * @returns {string} a normalized isoString
   * @since 1.1
   * @method _normalizeIsoString
   */
  OraI18nUtils._normalizeIsoString = function (isoString) {
    if (!isoString) {
      throw new Error('Provided invalid arguments');
    }

    var checkTime = function (timeValue) {
      var splitted = timeValue.split(':');
      if (splitted.length > 1) {
        return timeValue;
      }
      // need at least hour + minute for proper parsing on browser except IE
      return timeValue + ':00';
    };

    var todayIsoString = new Date().toISOString();
    var todayDatePortion = todayIsoString.substring(0, todayIsoString.indexOf('T'));
    var timeIndex = isoString.indexOf('T');
    var datePortion = timeIndex === -1 ? isoString : isoString.substring(0, timeIndex);
    var timePortion =
      timeIndex !== -1 ? checkTime(isoString.substring(timeIndex)) : _DEFAULT_TIME_PORTION;

    datePortion = datePortion || todayDatePortion;

    return datePortion + timePortion;
  };

  /**
   * formats a parameterized string
   *
   * @param {string} str string to be formatted. EX: "{0} bytes"
   * @param {Array} params array of parameters to be substituted in the string
   * @returns {string} The formatted string
   * @since 4.0.0
   */
  OraI18nUtils.formatString = function (str, params) {
    var len = params.length;
    var result = str;

    for (var i = 0; i < len; i++) {
      var token = '{' + i + '}';
      result = result.replace(token, params[i]);
    }
    return result;
  };

  /**
   * converts an ISO string based on isoStrFormat and local system's time zone.
   * if isoStrFormat is offset, it appends the local system's offset to the iso string.
   * If isoStrFormat is zulu, it converts the ISO string to UTC and appends 'Z' to it.
   * if isoStrFormat is local, it returns as is.
   * For example if local system's timezone is America/Los_Angeles
   * convertISOString('2021-01-01T13:00:00', 'offset') -->  2021-01-01T13:00:00-08:00
   * convertISOString('2021-06-01T13:00:00', 'offset') -->  2021-06-01T13:00:00-07:00
   * convertISOString('2021-01-01T13:00:00', 'zulu') -->  2021-01-01T21:00:00Z
   * convertISOString('2021-06-01T13:00:00', 'zulu') -->  2021-06-01T20:00:00Z
   * @param {string} iso  string to be formatted.
   * @param {string} isoStrFormat, possible values: 'offset', 'zulu' or 'local'
   * @returns {string} The formatted iso string
   * @since 12.0.0
   */
  OraI18nUtils.convertISOString = function (isoStr, isoStrFormat) {
    var formattedIsoStr = isoStr;
    if (isoStrFormat === 'offset') {
      var localOffset;
      if (isoStr.startsWith('T')) {
        localOffset = new Date().getTimezoneOffset();
      } else {
        localOffset = new Date(isoStr).getTimezoneOffset();
      }
      localOffset = OraI18nUtils.getTimeStringFromOffset('', localOffset, true, true);
      formattedIsoStr += localOffset;
    } else if (isoStrFormat === 'zulu') {
      var parts = OraI18nUtils._IsoStrParts(isoStr);
      var date = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5], parts[6]);
      formattedIsoStr =
        OraI18nUtils.padZeros(date.getUTCFullYear(), 4) +
        '-' +
        OraI18nUtils.padZeros(date.getUTCMonth() + 1, 2) +
        '-' +
        OraI18nUtils.padZeros(date.getUTCDate(), 2) +
        'T' +
        OraI18nUtils.padZeros(date.getUTCHours(), 2) +
        ':' +
        OraI18nUtils.padZeros(date.getUTCMinutes(), 2) +
        ':' +
        OraI18nUtils.padZeros(date.getUTCSeconds(), 2);
      if (date.getMilliseconds() > 0) {
        formattedIsoStr +=
          '.' + OraI18nUtils.trimRightZeros(OraI18nUtils.padZeros(date.getUTCMilliseconds(), 3));
      }
      formattedIsoStr += 'Z';
    }
    return formattedIsoStr;
  };

  /**
   * Returns a person's initials
   *
   * @param {string=} firstName first name
   * @param {string=} lastName last name or surname
   * @returns {string|undefined} uppercase concatenation of first letter of first name and first letter
   * of last name.
   * There are the following special cases:
   * - If the name is Arabic characters, it returns empty string.
   * - If the name is Hindi characters, it returns the first letter of the first name.
   * - If the name is Thai characters, it returns the first letter of the first name.
   * - If the name is Korean characters, it returns the first name.
   * - If the name is Japanese or Chinese characters, it returns the last name.
   *
   * @since 4.0.0
   * @method getInitials
   * @ignore
   */
  OraI18nUtils.getInitials = function (firstName, lastName) {
    // We assume the names are valid. We test the first character only.
    var c = 0;
    var c1 = 0;
    var u;
    if (firstName !== undefined && firstName.length > 0) {
      c = firstName.charCodeAt(0);
    }

    // Arabic characters. Return empty string
    if (c >= 0x0600 && c <= 0x06ff) {
      return '';
    }

    // Hindi characters. Return first letter of the first name
    if (c >= 0x0900 && c <= 0x097f) {
      return firstName.charAt(0);
    }

    // Thai characters. Return first letter of the first name
    if (c >= 0x0e00 && c <= 0x0e7f) {
      return firstName.charAt(0);
    }

    // Korean characters. Return first name
    if (
      (c >= 0x1100 && c <= 0x11ff) ||
      (c >= 0x3130 && c <= 0x318f) ||
      (c >= 0xa960 && c <= 0xa97f) ||
      (c >= 0xac00 && c <= 0xd7ff)
    ) {
      return firstName;
    }

    // Japanese and Chinese characters. Return last name
    if (lastName !== undefined && lastName.length > 0) {
      c = lastName.charCodeAt(0);
    }
    if (
      (c >= 0x2e80 && c <= 0x2fdf) ||
      (c >= 0x3000 && c <= 0x312f) ||
      (c >= 0x3190 && c <= 0x31ff) ||
      (c >= 0x3300 && c <= 0x4dbf) ||
      (c >= 0x4e00 && c <= 0x9fff) ||
      (c >= 0xf900 && c <= 0xfaff)
    ) {
      return lastName;
    }

    // Handle surrogate characters for Japanese and Chinese characters.
    if (c >= 0xd800 && c <= 0xdbff) {
      if (lastName && lastName.length < 2) {
        return '';
      }
      c1 = lastName.charCodeAt(1);
      // c1 must be in DC00-DFFF range
      if (c1 < 0xdc00 || c1 > 0xdfff) {
        return '';
      }
      // Convert high and low surrogates into unicode scalar.
      u = (c - 0xd800) * 0x400 + (c1 - 0xdc00) + 0x10000;
      // test the blocks
      if (
        (u >= 0x1b000 && u <= 0x1b0ff) ||
        (u >= 0x1f200 && u <= 0x1f2ff) ||
        (u >= 0x20000 && u <= 0x2a6df) ||
        (u >= 0x2a700 && u <= 0x2b73f) ||
        (u >= 0x2b740 && u <= 0x2b81f) ||
        (u >= 0x2b820 && u <= 0x2ceaf) ||
        (u >= 0x2f800 && u <= 0x2fa1f)
      ) {
        return lastName;
      }
    }

    // return default
    c = '';
    c1 = '';
    if (firstName !== undefined && firstName.length > 0) {
      c = firstName.charAt(0).toUpperCase();
    }
    if (lastName !== undefined && lastName.length > 0) {
      c1 = lastName.charAt(0).toUpperCase();
    }
    return c + c1;
  };

  /**
   * @export
   * @classdesc Utility function for converters
   * @hideconstructor
   * @since 0.7.0
   * @namespace oj.IntlConverterUtils
   * @ojtsimport {module: "ojconverter", type:"AMD", importName: "Converter"}
   * @ojtsimport {module: "ojvalidationfactory-base", type: "AMD", imported:["Validation"]}
   */
  const IntlConverterUtils = {};

  /**
   * Parses the isoString and returns a JavaScript Date object
   *
   * @export
   * @param {string} isoString isoString to parse and to return Date of
   * @return {Date} the parsed JavaScript Date Object
   * @memberof oj.IntlConverterUtils
   * @method isoToDate
   */
  IntlConverterUtils.isoToDate = function (isoString) {
    return OraI18nUtils.isoToDate(isoString);
  };

  /**
   * Returns a local Date object from a local ISO string. This method is only meant
   * to work with local ISO strings. If the input ISO string contain Z or offset,
   * they will be ignored.
   *
   * @param {string} isoString an ISO 8601 string
   * @returns {Date} localDate
   * @export
   * @since 0.7.0
   * @memberof oj.IntlConverterUtils
   * @method isoToLocalDate
   */
  IntlConverterUtils.isoToLocalDate = function (isoString) {
    return OraI18nUtils.isoToLocalDate(isoString);
  };

  /**
   * <p>Returns a local ISO string provided a Date object.
   * This method can be used to convert a moment in time or a local ISO string into
   * a local ISO string. It can also be used to convert any Date object into local ISO
   * string.</p>
   * Examples below are where the local (user's system) time zone is UTC-06:00<br>
   * dateToLocalIso(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03T22:00:00'<br>
   * dateToLocalIso(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03T20:30:00'<br>
   * In this example the input ISO string is local, the output is the same:<br>
   * dateToLocalIso(new Date('2021-06-04T02:30:00')); -->'2021-06-04T02:30:00'<br>
   * In this example we just want to convert a Date object:<br>
   * dateToLocalIso(new Date());<br>
   *
   * @param {Date} date
   * @returns {string} isoString
   * @export
   * @since 0.7.0
   * @memberof oj.IntlConverterUtils
   * @method dateToLocalIso
   */
  IntlConverterUtils.dateToLocalIso = function (date) {
    return OraI18nUtils.dateToLocalIso(date);
  };

  /**
   * <p>Returns the date only portion of a local ISO string provided a Date object.
   * This method can be used to convert a moment in time ISO string into a local
   * ISO string and get the date part of it. This method is useful if you are storing
   * your dates as a moment in time and you want to use it in a date only component,
   * like oj-input-date, that shows the date in the timezone of the user's local system.</p>
   * Examples where local time zone offset is UTC-06:00<br>
   * dateToLocalIsoDateString(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03'<br>
   * dateToLocalIsoDateString(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03'<br>
   *
   * @param {Date} date
   * @returns {string} date portion only of the ISO String
   * @export
   * @since 12.0.0
   * @memberof oj.IntlConverterUtils
   * @method dateToLocalIsoDateString
   */
  IntlConverterUtils.dateToLocalIsoDateString = function (date) {
    return OraI18nUtils.dateToLocalIsoDateString(date);
  };

  // This private method is not called, commenting out for now to remove it from code coverage calculations
  // oj.IntlConverterUtils._getTimeZone = function(isoString)
  // {
  //  return OraI18nUtils._getTimeZone(isoString);
  // };

  /**
   * Returns the timezone offset between UTC and the local time in Etc/GMT[+-]h syntax.
   * The offset is positive if the local timezone is behind UTC and negative if
   * it is ahead. The offset range is between Etc/GMT-14 and Etc/GMT+12 (UTC-12 and UTC+14)
   *
   * @example <caption>The local time is UTC-7 (Pacific Daylight Time)</caption>
   * oj.IntlConverterUtils.getLocalTimeZoneOffset() will return the string "Etc/GMT+7"
   *
   * @example <caption>The local time is UTC+1 (Central European Standard Time)</caption>
   * oj.IntlConverterUtils.getLocalTimeZoneOffset() will return the string "Etc/GMT-1"
   * <p>
   * NOTE: Since JET v12.0.0, the IntlDateTimeConverter will fallback to the local system time zone
   * if no timeZone is in the options.
   * So instead of using this API to get a local timezone offset to pass the converter,
   * you should not set any timeZone in the converter options.
   * </p>
   * @export
   * @param {Date=} date If date is undefined, it returns the local timezone offset of the current
   * date, otherwise it returns the local timezone offset at that given date.
   * @returns {string}
   * @memberof oj.IntlConverterUtils
   * @method getLocalTimeZoneOffset
   */
  IntlConverterUtils.getLocalTimeZoneOffset = function (date) {
    return OraI18nUtils.getLocalTimeZoneOffset(date);
  };

  /**
   * Given either an Object literal representing a 'converter' option (used in components) or a
   * converter instance of type Converter, this method returns the converter instance.
   * You can also pass in a string. In this case, it will return you an instance of a converter
   * registered with that type.
   * @ojdeprecated {since: '8.0.0', description: 'Create a converter using its constructor.'}
   * @param {string| Object} converterOption
   * @returns {Object|null} converterInstance or null if a converter cannot be determined
   * @ojsignature {
   *        target: "Type", value: "<T>(converterOption: string|Validation.RegisteredConverter|Converter<T>): Converter<T>|null"}
   * @export
   * @since 0.6.0

   * @memberof oj.IntlConverterUtils
   * @method getConverterInstance
   */
  IntlConverterUtils.getConverterInstance = function (converterOption) {
    return ConverterUtils.getConverterInstance(converterOption);
  };

  /**
   * So the requirement is if min or max lacks date portion and value contains it, then min + max should use
   * value's date portion
   *
   * @param {string} minMax date in isoString format
   * @param {string} value date in isoString format
   * @returns {string} merged date in isoString format
   * @export
   * @ignore
   * @since 1.2
   * @memberof oj.IntlConverterUtils
   * @method _minMaxIsoString
   */
  IntlConverterUtils._minMaxIsoString = function (minMax, value) {
    if (minMax) {
      // eslint-disable-next-line no-param-reassign
      value = value || this.dateToLocalIso(new Date());

      var vTindex = value.indexOf('T');

      if (minMax.indexOf('T') === 0 && vTindex > 0) {
        // meaning only time exists for minMax and value contains date
        // eslint-disable-next-line no-param-reassign
        minMax = value.substring(0, vTindex) + minMax;
      }
    }

    return minMax;
  };

  // PACKAGE PRIVATE
  /**
   * Returns the format type of the isoStr: 'local', 'zulu' or 'offset'.
   *
   * @param {string} isoStr isoString
   * @returns {'local'|'zulu'|'offset'} isoString format: 'local', 'zulu', or 'offset'
   * @throws Error
   * @export
   * @ignore
   * @since 11.0.0
   * @memberof oj.IntlConverterUtils
   * @method _getISOStrFormatType
   * @private
   */
  IntlConverterUtils._getISOStrFormatType = function (isoStr) {
    return OraI18nUtils.getISOStrFormatType(isoStr);
  };

  /**
   * Checks that min and max and value are parseable isoStrings,
   * Logs a warning if value, min, max are not all iso strings.
   *
   * @throws {Error} if value, min, max are not all iso strings, or are not of the same type.
   * @param {string} value
   * @param {string} min
   * @param {string} max
   * @export
   * @ignore
   * @since 11.0.0
   * @memberof oj.IntlConverterUtils
   * @method _verifyValueMinMax
   * @private
   */
  IntlConverterUtils._verifyValueMinMax = function (value, min, max) {
    // If value or min or max is not an iso string (say 'abc' or '2021/03/03'),
    // the datepicker renders, but you see an inline converter error meant only for an application
    // developer under the field, 'Please provide valid ISO 8601 string'.
    // This is inconsistent with other component attributes** that are not set to the correct type
    // ** e.g., set oj-input-number value='abc' and an error is thrown in the console.
    // In v11 we logged the warning and monitored FA tests for this warning. After six months or so
    // we saw no warnings and so now in v12 we will throw an error.

    Object.entries({ value, min, max }).forEach(([k, v]) => {
      if (v) {
        try {
          IntlConverterUtils._getISOStrFormatType(v);
        } catch (e) {
          // We weren't checking this in pre-v11.
          throw new Error(`${k} must be an iso string: ${e}`);
        }
      }
    });
  };

  /**
   * Returns the current date on the browser's local system in iso string format. E.g., '2021-10-13'
   * @return {str} isoStr
   * @export
   * @ignore
   * @since 12.0.0
   * @memberof oj.IntlConverterUtils
   * @method _getTodaysDateIsoStr
   * @private
   */
  IntlConverterUtils._getTodaysDateIsoStr = function () {
    const now = new Date();
    const localDateIsoStr =
      OraI18nUtils.padZeros(now.getFullYear(), 4) +
      '-' +
      OraI18nUtils.padZeros(now.getMonth() + 1, 2) +
      '-' +
      OraI18nUtils.padZeros(now.getDate(), 2);
    return localDateIsoStr;
  };

  /**
   * Takes two iso strings and returns two iso strings that can be passed
   * into new Date() so they can be compared.
   * This function makes sure they are both in a date or date+time
   * format. new Date does not accept time only, like T00:00:00.
   * @param {string} isoStr1 first iso string
   * @param {string} isoStr2 second iso string
   * @returns {Array.<string>} an array with two iso strings that can be compared with Date.
   * @export
   * @ignore
   * @since 12.0.0
   * @memberof oj.IntlConverterUtils
   * @method _makeIsoDateStringsDateComparable
   * @private
   */
  IntlConverterUtils._makeIsoDateStringsDateComparable = function (isoStr1, isoStr2) {
    const isoStr1TimeOnly = isoStr1.startsWith('T'); // e.g., T02:00:20
    const isoStr2TimeOnly = isoStr2.startsWith('T');
    const isoStr1ContainsDateOnly = !isoStr1.includes('T');
    const isoStr2ContainsDateOnly = !isoStr2.includes('T');
    let comparableIsoStr1 = isoStr1;
    let comparableIsoStr2 = isoStr2;

    // We may have time-only iso strings which new Date() does not like.
    // So check for that and convert.
    if (isoStr1TimeOnly || isoStr2TimeOnly) {
      const datePart = IntlConverterUtils._getTodaysDateIsoStr();
      if (isoStr1TimeOnly) {
        comparableIsoStr1 = datePart + isoStr1;
      }
      if (isoStr2TimeOnly) {
        comparableIsoStr2 = datePart + isoStr2;
      }
    }

    // at this point comparableIsoStrs will contain date-only or date+time.
    // if one has date-only, add a time piece.
    if (!(isoStr1ContainsDateOnly && isoStr2ContainsDateOnly)) {
      if (isoStr1ContainsDateOnly) {
        comparableIsoStr1 = `${isoStr1}T00:00:00`;
      }
      if (isoStr2ContainsDateOnly) {
        comparableIsoStr2 = `${isoStr2}T00:00:00`;
      }
    }
    return [comparableIsoStr1, comparableIsoStr2];
  };

  /**
   * Compares 2 ISO 8601 strings, returning the time difference between the two.
   * The two values MUST be valid iso strings, and in the same format:
   * local, zulu, or offset before calling this method.
   * They should be in the same date/time format like time only or date only, etc., when used
   * in JET's date/time components.
   * For backward compatibility we coerce to the same date/time if they are not.
   * This is an replacement for the deprecated IntlDateTimeConverter.compareISODates.
   * @param {string} isoStr1 first iso string
   * @param {string} isoStr2 second iso string
   * @return {number} the time difference between isoStr and isoStr2 in ms.
   * @export
   * @ignore
   * @since 12.0.0
   * @memberof oj.IntlConverterUtils
   * @method _compareISODates
   * @private
   */
  IntlConverterUtils._compareISODates = function (isoStr1, isoStr2) {
    // Sometimes people use oj-input-date with min/max that contain date and time, which is not advised,
    // but is currently allowed. It should only accept dates, no time.
    // This method needs to handle if one of the strings is date only, and the other is date/time;
    // if one is time only and the other is datetime, etc.
    const comparableIsoStrings = IntlConverterUtils._makeIsoDateStringsDateComparable(
      isoStr1,
      isoStr2
    );

    return new Date(comparableIsoStrings[0]) - new Date(comparableIsoStrings[1]);
  };

  /**
   * Processes an converter option error and returns a oj.ConverterERror instance.
   * @param {string} errorCode
   * @param {Object} parameterMap
   * @return {Object} an ConverterError instance
   * @private
   * @memberof oj.IntlConverterUtils
   */
  IntlConverterUtils.__getConverterOptionError = function (errorCode, parameterMap) {
    oj.Assert.assertObject(parameterMap);
    var summary = '';
    var detail = '';
    var propName = parameterMap.propertyName;
    var propValueValid;

    if (errorCode === 'optionTypesMismatch') {
      var reqPropName = parameterMap.requiredPropertyName;
      propValueValid = parameterMap.requiredPropertyValueValid;
      // Summary: A value for the property '{requiredPropertyName}' is required when the property
      // '{propertyName}' is set to '{propertyValue}'.
      summary = Translations.getTranslatedString('oj-converter.optionTypesMismatch.summary', {
        propertyName: propName,
        propertyValue: parameterMap.propertyValue,
        requiredPropertyName: reqPropName
      });

      detail = IntlConverterUtils._getOptionValueDetailMessage(reqPropName, propValueValid);
    } else if (errorCode === 'optionTypeInvalid') {
      // Summary: A value of the expected type was not provided for '{propertyName}'.
      propName = parameterMap.propertyName;
      propValueValid = parameterMap.propertyValueValid;
      summary = Translations.getTranslatedString('oj-converter.optionTypeInvalid.summary', {
        propertyName: propName
      });

      detail = IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
    } else if (errorCode === 'optionOutOfRange') {
      // The value {propertyValue} is out of range for the option '{propertyName}'.
      summary = Translations.getTranslatedString('oj-converter.optionOutOfRange.summary', {
        propertyName: propName,
        propertyValue: parameterMap.propertyValue
      });

      propValueValid = parameterMap.propertyValueValid;
      detail = IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
    } else if (errorCode === 'optionValueInvalid') {
      // An invalid value '{propertyValue}' was specified for the option '{propertyName}'..
      summary = Translations.getTranslatedString('oj-converter.optionValueInvalid.summary', {
        propertyName: propName,
        propertyValue: parameterMap.propertyValue
      });

      propValueValid = parameterMap.propertyValueHint;
      detail = IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
    }

    return new ojvalidationError.ConverterError(summary, detail);
  };

  /**
   * Returns a oj.ConverterERror instance.
   * @param {string} summary
   * @param {string} detail
   * @return {Object} an ConverterError instance
   * @private
   * @memberof oj.IntlConverterUtils
   */
  IntlConverterUtils.__getConverterError = function (summary, detail) {
    return new ojvalidationError.ConverterError(summary, detail);
  };

  /**
   * Builds the detail message for possible converter option values. Only applicable when errorInfo is
   * returned from JET converter implementation.
   *
   * @param {string} propName name of the property
   * @param {Array|string} propValueValid valid value or values expected.
   *
   * @return {string} the localized message
   * @private
   * @memberof oj.IntlConverterUtils
   */
  IntlConverterUtils._getOptionValueDetailMessage = function (propName, propValueValid) {
    // Detail: An accepted value for '{propertyName}' is '{propertyValueValid}'. or
    // Accepted values for '{propertyName}' are '{propertyValueValid}'.
    var resourceKey;

    if (propValueValid) {
      if (typeof propValueValid === 'string') {
        resourceKey = 'oj-converter.optionHint.detail';
      } else {
        // we have an array of values
        resourceKey = 'oj-converter.optionHint.detail-plural';
        // eslint-disable-next-line no-param-reassign
        propValueValid = propValueValid.join(
          Translations.getTranslatedString('oj-converter.plural-separator')
        );
      }
      return Translations.getTranslatedString(resourceKey, {
        propertyName: propName,
        propertyValueValid: propValueValid
      });
    }

    return '';
  };

  /**
   * Will return an updated toIsoString using the timePortion from the fromIsoString or from the default
   * oj.OraI18nUtils.DEFAULT_TIME_PORTION
   *
   * @private
   * @expose
   * @param {string} fromIsoString isoString that may not be a complete isoString
   * @param {string} toIsoString isoString that may not be a complete isoString
   * @returns {string} modified toIsoString with original date portion and the time portion from the fromIsoString
   * @since 1.1
   * @memberof oj.IntlConverterUtils
   * @method _copyTimeOver
   */
  IntlConverterUtils._copyTimeOver = function (fromIsoString, toIsoString) {
    return OraI18nUtils._copyTimeOver(fromIsoString, toIsoString);
  };

  /**
   * Clears the time portion of the isoString
   *
   * @private
   * @expose
   * @param {string} isoString isoString that may not be a complete isoString
   * @returns {string} an updated isoString
   * @since 1.1
   * @memberof oj.IntlConverterUtils
   * @method _clearTime
   */
  IntlConverterUtils._clearTime = function (isoString) {
    return OraI18nUtils._clearTime(isoString);
  };

  /**
   * Will accept an isoString and perform a get operation or a set operation depending on whether param is an Array
   * or a JSON
   *
   * The keys for the get and set operation are defined in OraI18nUtils's _DATE_TIME_KEYS.
   *
   * Note the handling of month starting with 0 in Date object and being 1 based in isoString will be handled by the function
   * with the usage of doParseValue. Meaning when you doParseValue and you are getting the value it will automatically
   * decrement the value and when you are setting the param it will check if the value is of number and if so will
   * increment it.
   *
   * @private
   * @expose
   * @param {string} isoString isoString that may not be a complete isoString
   * @param {Array|Object} actionParam if an Array will be a get operation, if a JSON will be a set operation
   * @param {boolean=} doParseValue whether one should parseInt the value during the get request
   * @returns {Object|string} an Object when a get operation and a string when a set operation
   * @since 1.1
   * @memberof oj.IntlConverterUtils
   * @method _dateTime
   */
  IntlConverterUtils._dateTime = function (isoString, actionParam, doParseValue) {
    return OraI18nUtils._dateTime(isoString, actionParam, doParseValue);
  };

  /**
   * So the problem is Jet uses incomplete isoString which causes issues in different browsers.
   *
   * For instance for a new Date().toISOString() => 2015-02-02T18:00:37.007Z
   * ojInputDate stores 2015-02-02
   * ojInputTime stores T18:00:37.007Z
   *
   * yet constructing new Date(val) on above causes different results or errors in different browsers, so
   * this function is to normalize them. Note it is assumed that the point is creating the Date object from the
   * normalized isoString. Meaning if both contain only the time portion today's date will appended to it.
   *
   * @private
   * @expose
   * @param {string} isoString isoString that may not be a complete isoString
   * @returns {string} a normalized isoString
   * @since 1.1
   * @memberof oj.IntlConverterUtils
   * @method _normalizeIsoString
   */
  IntlConverterUtils._normalizeIsoString = function (isoString) {
    return OraI18nUtils._normalizeIsoString(isoString);
  };

  /**
   * Returns a person's initials
   *
   * @param {string=} firstName first name
   * @param {string=} lastName last name
   * @returns {string|undefined} uppercase concatenation of first letter of first name and first letter
   * of last name.
   * There are the following special cases:
   * - If the name is Arabic characters, it returns empty string.
   * - If the name is Hindi characters, it returns the first letter of the first name.
   * - If the name is Thai characters, it returns the first letter of the first name.
   * - If the name is Korean characters, it returns the first name.
   * - If the name is Japanese or Chinese characters, it returns the last name.
   *
   * @export
   * @since 4.0.0
   * @memberof oj.IntlConverterUtils
   * @method getInitials
   */
  IntlConverterUtils.getInitials = function (firstName, lastName) {
    return OraI18nUtils.getInitials(firstName, lastName);
  };

  exports.IntlConverterUtils = IntlConverterUtils;
  exports.OraI18nUtils = OraI18nUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojconverter-number',['exports', 'ojs/ojlogger', 'ojs/ojconverterutils-i18n', 'ojs/ojlocaledata', 'ojs/ojconverter', 'ojs/ojtranslation', 'ojs/ojconfig', 'ojs/ojcore-base', 'ojs/ojvalidation-error', 'ojs/ojconverter-preferences'], function (exports, Logger, __ConverterUtilsI18n, LocaleData, Converter, Translations, Config, oj$1, ojvalidationError, ojconverterPreferences) { 'use strict';

  Converter = Converter && Object.prototype.hasOwnProperty.call(Converter, 'default') ? Converter['default'] : Converter;
  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;

  /* xeslint-disable no-param-reassign */
  /**
   * @constructor
   *
   * @classdesc OraNumberConverter object implements number parsing and formatting for
   * decimal, currency, percent and perMill types. It supports ECMA-402 options
   * and user defined pattern. The user defined pattern is parsed in order to
   * derive the options that can be specified as ECMA options.
   * There are several ways to use the converter.
   * <p>
   * <ul>
   * <li>Using options defined by the ECMA 402 Specification, these would be the properties style,
   * currency, currencyDisplay, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits,
   * useGrouping. NOTE: minimumSignificantDigits and maximumSignificantDigits are not supported.</li>
   * <li>Using a custom decimal, currency or percent format pattern. specified using the 'pattern' property</li>
   * <li>Using the decimalFormat option to define a compact pattern, such as "1M" and "1 million".</li>
   * <li>Using the currencyFormat option to define a compact pattern, such as "$1M" and "$1 million".</li>
   * <li>Using the roundingMode and roundDuringParse options to round the number UP, DOWN, CEILING, FLOOR, HALF_UP, HALF_DOWN or HALF_EVEN.</li>
   * </ul>
   * <p>
   *
   * The converter provides leniency when parsing user input value to a number in the following ways:<br/>
   *
   * <ul>
   * <li>Prefix and suffix that do not match the pattern, are removed. E.g., when pattern is
   * "#,##0.00%" (suffix is the % character), a value of "abc-123.45xyz", will be leniently parsed to
   * -123.45</li>
   * <li>When a value includes a symbol but the pattern doesn't require it.  E.g., the options are
   * {pattern: "###", currency: 'USD'}, then values ($123), (123) and -123 will be leniently parsed as
   * -123.</li>
   * </ul>
   * <p>
   * Lenient parse can be disabled by setting the property lenientParse to "none". In which case the user input must
   * be an exact match of the expected pattern and all the leniency described above will be disabled.
   * <p>
   * @property {Object=} options - an object literal used to provide optional information to
   * initialize the converter.
   * @property {string=} options.style - sets the style of number formatting. Allowed values are "decimal"
   * (the default), "currency", "percent" or "unit". When a number is formatted as a decimal, the decimal
   * character is replaced with the most appropriate symbol for the locale. In English this is a
   * decimal point ("."), while in many locales it is a decimal comma (","). If grouping is enabled the
   * locale dependent grouping separator is also used. These symbols are also used for numbers
   * formatted as currency or a percentage, where appropriate.
   * @property {string=} options.currency - specifies the currency that will be used when formatting the
   * number. The value should be a ISO 4217 alphabetic currency code. If the style is set to currency,
   * it's required that the currency property also be specified. This is because there is no default
   * currency associated with the current locale. The user must always specify the currency code
   * to be shown, otherwise an error will be thrown. The current page locale
   * (returned by oj.Config.getLocale()) determines the formatting elements of the number
   * like grouping separator and decimal separator. The currency code tells us which currency to
   * display in current page locale. JET has translations for currency names.
   * <p>
   * As an example if we want to format 1000.35 EURO and the page locale is "en-US",
   * we pass {style:'currency', currency:'EUR', currencyDisplay:'symbol'} and we will get "€1,000.35"
   * If the page locale is "fr-FR", with the same options, we will get: "1 000,35 €"
   * </p>
   * @property {string=} options.unit - Mandatory when style is "unit". Allowed values:
   * "byte" or "bit". It is used for formatting only. It can not be used for parsing.
   * <p>
   * It is used to format digital units like 10Mb for bit unit or 10MB for byte unit.
   * There is no need to specify the scale of the unit. We automatically detect it.
   * For example 1024 is formatted as 1KB and 1048576 as 1MB.
   * The user can also specify 'minimumFractionDigits' and  'maximumFractionDigits' to be displayed,
   * otherwise we use the locale's default max and min fraction digits.
   * </p>
   * @property {string=} options.currencyDisplay - if the number is using currency formatting, specifies
   * if the currency will be displayed using its "code" (as an ISO 4217 alphabetic currency code),
   * "symbol" (a localized currency symbol (e.g. $ for US dollars, £ for Great British pounds, and so
   * on), or "name" (a localized currency name. Allowed values are "code", "symbol" and "name".
   * The default is "symbol".
   * @property {string=} options.decimalFormat -
   * specifies the decimal format length to use when style is set to "decimal".
   * Allowed values are : "standard"(default), "short" and "long". "standard" is equivalent to not
   * specifying the 'decimalFormat' attribute, in that case the locale's default decimal pattern
   * is used for formatting.
   * <p>
   * The user can also specify 'minimumFractionDigits' and  'maximumFractionDigits' to display.
   * When not present we use the locale's default max and min fraction digits.
   * </p>
   * <p>
   * There is no need to specify the scale; we automatically detect greatest scale that is less or
   * equal than the input number. For example  1000000 is formatted as "1M" or "1 million" and
   * 1234 is formatted, with zero fractional digits, as "1K" or " 1 thousand" for
   * short and long formats respectively. The pattern for the short and long number is locale dependent
   * and uses plural rules for the particular locale.
   * </p>
   * <p>
   * NOTE: Currently this option formats a value (e.g., 2000 -> 2K), but it does not parse a value
   * (e.g., 2K -> 2000), so it can only be used
   * in a readOnly EditableValue because readOnly EditableValue components do not call
   * the converter's parse function.
   * </p>
   * @property {string=} options.currencyFormat -
   * specifies the currency format length to use when style is set to "currency".
   * Allowed values are : "standard"(default), "short" and "long". 'standard' is equivalent to not
   * specifying the 'currencyFormat' attribute, in that case the locale's default currency pattern
   * is used for formatting.
   * Similar to decimalFormat, currencyFormat can only be used for formatting. It can not be used for parsing.
   * <p>
   * The user can also specify 'minimumFractionDigits' and  'maximumFractionDigits' to display.
   * When not present we use the locale's default max and min fraction digits.
   * </p>
   * <p>
   * There is no need to specify the scale; we automatically detect greatest scale that is less or
   * equal than the input number. For example  1000000 is formatted as "$1M" or "1 million dollar" and
   * 1000 is formatted as "$1K" or " 1 thousand dollar" for short and long formats respectively.
   * The pattern for the short and long number is locale dependent and uses plural rules for the particular locale.
   * </p>
   * @property {number=} options.minimumIntegerDigits - sets the minimum number of digits before the
   * decimal place (known as integer digits). The number is padded with leading zeros if it would not
   * otherwise have enough digits. The value must be an integer between 1 and 21.
   * @property {number=} options.minimumFractionDigits - similar to 'minimumIntegerDigits', except it
   * deals with the digits after the decimal place (fractional digits). It must be an integer between
   * 0 and 20. The fractional digits will be padded with trailing zeros if they are less than the minimum.
   * @property {number=} options.maximumFractionDigits - follows the same rules as 'minimumFractionDigits',
   * but sets the maximum number of fractional digits that are allowed. The value will be rounded if
   * there are more digits than the maximum specified.
   * @property {boolean=} options.useGrouping - when the value is truthy, the locale dependent grouping
   * separator is used when formatting the number. This is often known as the thousands separator,
   * although it is up to the locale where it is placed. The 'useGrouping' is set to true by default.
   * @property {string=} options.pattern an optional localized pattern, where the characters used in
   * pattern are as defined in the Unicode CLDR for numbers, percent or currency formats. When present
   * this will override the other "options". <p>
   *
   * &nbsp;&nbsp;- When the pattern represents a currency style the 'currency' property is required to
   * be set, as not setting this will throw an error. The 'currencyDisplay' is optional. <br/>Example:
   * {pattern: '¤#,##0', currency: 'USD'}. <p>
   *
   * &nbsp;&nbsp;- It's not mandatory for the pattern to have the special character '¤' (currency sign)
   * be present. When not present, values are treated as a currency value, but are not formatted to
   * show the currency symbol. <br/>Example: {pattern: '#,##0', currency: 'USD'} <p>
   *
   * &nbsp;&nbsp;- When the pattern represents a percent style, the percent special character ('%') needs to be
   * explicitly specified in the pattern, e.g., {pattern: "#,##0%"}. If the pattern does not contain
   * the percent character it's treated as a decimal pattern, unless the style is set to percent,
   * in which case the value is treated as a percent value, but not formatted to show the percent symbol.
   * <br/>Example: {style: 'percent', pattern: "#,##0"}. <p>
   *
   * &nbsp;&nbsp;- A decimal pattern or exponent pattern is specified in the pattern using the CLDR
   * conventions. <br/>Example: {pattern: "#,##0.00"} or {pattern: "0.##E0"}. <p>
   *
   * NOTE: 'pattern' is provided for backwards compatibility with existing apps that may want the
   * convenience of specifying an explicit format mask. Setting a pattern will override the default
   * locale specific format. <br/>
   *
   * @property {string=} options.roundingMode - specifies the rounding behavior.
   * We support the options: UP, DOWN, CEILING, FLOOR, HALF_UP, HALF_DOWN and HALF_EVEN.
   * The rounding modes can be used in conjunction with decimal (including short format), currency and percent styles.
   * We follow the Java.Math.RoundingMode behavior : https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html
   *
   * @property {boolean=} options.roundDuringParse - Specifies whether or not to round during
   * parse. Defaults to false; the number converter rounds during format but not during parse.
   *
   * @property {Object=} options.separators - An object with 2 fields: 'decimal' and 'group'.
   * It allows the user to override the locale's default decimal and grouping separators. It is accepted for both
   * format and parse methods.
   * <br/>
   *
   * @property {string=} options.lenientParse - The lenientParse property can be used to enable or disable leninet parsing.
   *  Allowed values: "full" (default), "none".
   * <p style='padding-left: 5px;'>
   * By default the lenient parse is enabled and the leniency rules descibed above will be used. When lenientParse is
   * set to "none" the lenient parse is disabled and the user input must match the expected input otherwise an exception will
   * be thrown.<br/><br/>
   *
   * @example <caption>Create a number converter for currencies</caption>
   * var converter = OraNumberConveter.getInstance();
   * var options = {style: "currency", currency: "USD", minimumIntegerDigits: 2};
   * var localeElements;
   * var nb = 9;
   * converter.format(nb, localeElements, options); --> "$09.00" if page locale is 'en-US'
   * converter.format(nb, localeElements, options); --> "09,00 $US" if page locale is 'fr-FR'<br/>
   *
   * TODO @example <caption>Options for percent values using a custom (CLDR) pattern</caption>
   * var options = {pattern: '#,##0%'};
   * converter = converterFactory.createConverter(options);<br/>
   *
   * @example <caption>To parse a value as percent but format it without displaying the percent character</caption>
   * var options = {style: 'percent', pattern: '#,##0'};<br/>
   *
   * @example <caption>To parse a value as currency using a custom (CLDR) pattern</caption>
   * var options = {pattern: '¤#,##0', currency: 'USD'};
   *
   * @example <caption>To format a value as digital bit unit</caption>
   * var options = {style:'unit', unit:'bit'};
   * var nb = 1024;
   * converter.format(nb, localeElements, options);--> 1Kb<br/>
   *
   * @example <caption>To format a value as digital byte unit</caption>
   * var options = {style:'unit', unit:'byte'};
   * var nb = 1024;
   * converter.format(nb, localeElements, options);--> 1KB<br/>
   *
   * @example <caption>The following decimalFormat examples are in en locale.
   * To format a value as short (default for fraction digits is based on the locale)</caption>
   * var options = {style:'decimal', decimalFormat:'short'};
   * var nb = 12345
   * converter.format(nb, localeElements, options);--> 12.354K<br/>
   *
   * @example <caption>To format a value as long (default for fraction digits is based on the locale):</caption>
   * var options = {style:'decimal', decimalFormat:'long'};
   * var nb = 12345;
   * converter.format(nb, localeElements, options);--> 12.345 thousand<br/>
   *
   * @example <caption>To format a value as short with minimum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'short', minimumFractionDigits:4};
   * var nb = 1234;
   * converter.format(nb, localeElements, options);--> 1.2340K<br/>
   *
   * @example <caption>To format a value as short with maximum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'short', maximumFractionDigits:0};
   *  var nb = 1234;
   * converter.format(nb, localeElements, options);--> 12K<br/>
   *
   * @example <caption>To format a value as long with minimum and maximum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'long',
   * minimumFractionDigits:2, maximumFractionDigits:4};
   * var nb = 12000;
   * converter.format(nb, localeElements, options);--> 12.00 thousand<br/>
   *
   * @example <caption>To format a value as short with minimum and maximum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'long',
   * minimumFractionDigits:2, maximumFractionDigits:4};
   * var nb = 12345678;
   * converter.format(nb, localeElements, options);--> 12.345 million<br/>
   *
   * @example <caption>decimal style default is standard:</caption>
   * options = { style:'decimal', decimalFormat:'standard'};
   * var nb = 12345;
   * converter.format(nb, localeElements, options);--> 12,345<br/>
   *
   * @example <caption>decimal round UP:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'UP'};
   * var nb = 0.221;
   * converter.format(nb, localeElements, options);--> 0.23
   * var str = "0.221";
   * converter.parse(str, localeElements, options);-->0.221 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round DOWN:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'DOWN'};
   * var nb = 0.229;
   * converter.format(nb, localeElements, options);--> 0.22
   * var str = "0.229";
   * converter.parse(str, localeElements, options);-->0.229 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round CEILING:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'CEILING'};
   * var nb = 0.221;
   * converter.format(nb, localeElements, options);--> 0.23
   * var str = "0.221";
   * converter.parse(str, localeElements, options);-->0.221 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round FLOOR:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'FLOOR'};
   * var nb = 0.228;
   * converter.format(nb, localeElements, options);--> 0.22
   * var str = "0.228";
   * converter.parse(str, localeElements, options);-->0.228 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round HALF_DOWN:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'HALF_DOWN'};
   * var nb = 0.225;
   * converter.format(nb, localeElements, options);--> 0.22
   * var str = "0.225";
   * converter.parse(str, localeElements, options);-->0.225 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round HALF_UP:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'HALF_UP'};
   * var nb = 0.225;
   * converter.format(nb, localeElements, options);--> 0.23
   * var str = "0.225";
   * converter.parse(str, localeElements, options);--> 0.225 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round HALF_EVEN:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'HALF_EVEN'};
   * converter.format(0.225, localeElements, options);--> 0.22
   * converter.format(0.235, localeElements, options);--> 0.24
   * converter.parse("0.225", localeElements, options);--> 0.225 //doesn't round during parse by default
   * converter.parse("0.235", localeElements, options);--> 0.235 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round UP and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'UP', roundDuringParse: true};
   * var nb = 0.221;
   * converter.format(nb, localeElements, options);--> 0.23
   * var str = "0.221";
   * converter.parse(str, localeElements, options);-->0.23<br/>
   *
   * @example <caption>decimal round DOWN and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'DOWN', roundDuringParse: true};
   * var nb = 0.229;
   * converter.format(nb, localeElements, options);--> 0.22
   * var str = "0.229";
   * converter.parse(str, localeElements, options);-->0.22<br/>
   *
   * @example <caption>decimal round CEILING and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'CEILING', roundDuringParse: true};
   * var nb = 0.221;
   * converter.format(nb, localeElements, options);--> 0.23
   * var str = "0.221";
   * converter.parse(str, localeElements, options);-->0.23<br/>
   *
   * @example <caption>decimal round FLOOR and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'FLOOR', roundDuringParse: true};
   * var nb = 0.228;
   * converter.format(nb, localeElements, options);--> 0.22
   * var str = "0.228";
   * converter.parse(str, localeElements, options);-->0.22<br/>
   *
   * @example <caption>decimal round HALF_DOWN and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'HALF_DOWN', roundDuringParse: true};
   * var nb = 0.225;
   * converter.format(nb, localeElements, options);--> 0.22
   * var str = "0.225";
   * converter.parse(str, localeElements, options);-->0.22<br/>
   *
   * @example <caption>decimal round HALF_UP and roundDuringParse:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2,
   *             roundingMode:'HALF_UP', roundDuringParse: true};
   * var nb = 0.225;
   * converter.format(nb, localeElements, options);--> 0.23
   * var str = "0.225";
   * converter.parse(str, localeElements, options);--> 0.23<br/>
   *
   * @example <caption>decimal round HALF_EVEN and roundDuringParse:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2,
   *             roundingMode:'HALF_EVEN', roundDuringParse: true};
   * converter.format(0.225, localeElements, options);--> 0.22
   * converter.format(0.235, localeElements, options);--> 0.24
   * converter.parse("0.225", localeElements, options);--> 0.22
   * converter.parse("0.235", localeElements, options);--> 0.24<br/>
   *
   * @example <caption>Override locale's decimal and grouping separators:</caption>
   * in en-US locale, the decimal separator is '.' and grouping separator is ','. In this example we will swap them.
   * options = { style:'decimal', separators: {decimal: ',',  group: '.'}};
   * var nb = 1234567.89;
   * converter.format(nb, localeElements, options);--> 1.234.567,89
   * converter.parse("1.234.567,89", localeElements, options);--> 1234567.89
   * <br/>
   *
   * @example <caption>Disable lenient parse:</caption>
   * options = { style:'decimal',  lenientParse: 'none'};
   * converter.parse("abc-123.45xyz", localeElements, options);--> Error: Unparsable number abc-123.45xyz The expected number pattern is #,##0.###
   * <br/>
   *
   * @name OraNumberConverter
   * @ignore
   */

  /**
   * @ignore
   */

  // eslint-disable-next-line no-unused-vars
  const OraNumberConverter = (function () {
    var instance;

    var _REGEX_INFINITY = /^[+-]?infinity$/i;
    var _REGEX_PARSE_FLOAT = /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/;
    var _LENIENT_REGEX_PARSE_FLOAT = /([^+-.0-9]*)([+-]?\d*\.?\d*(E[+-]?\d+)?).*$/;
    // eslint-disable-next-line no-useless-escape
    var _ESCAPE_REGEXP = /([\^$.*+?|\[\](){}])/g;
    var _REGEX_TRIM_ZEROS = /(^0\.0*)([^0].*$)/;
    var _REGEX_ONLY_ZEROS = /^0+$/;

    var _decimalTypeValues = {
      trillion: [100000000000000, 10000000000000, 1000000000000],
      billion: [100000000000, 10000000000, 1000000000],
      million: [100000000, 10000000, 1000000],
      thousand: [100000, 10000, 1000]
    };

    var _decimalTypeValuesMap = {
      trillion: 1000000000000,
      billion: 1000000000,
      million: 1000000,
      thousand: 1000
    };

    // maps roundingMode attributes to Math rounding modes.
    var _roundingModeMap = {
      HALF_UP: 'ceil',
      CEILING: 'ceil',
      UP: 'ceil',
      HALF_DOWN: 'floor',
      FLOOR: 'floor',
      DOWN: 'floor',
      DEFAULT: 'round'
    };

    var _DIGITAL_KILO = 1024;
    var _DIGITAL_MEGA = 1024 * 1024;
    var _DIGITAL_GIGA = 1024 * 1024 * 1024;
    var _DIGITAL_TERA = 1024 * 1024 * 1024 * 1024;

    // prepend or append count zeros to a string.
    function _zeroPad(str, count, left) {
      var l;
      for (l = str.length; l < count; l += 1) {
        // eslint-disable-next-line no-param-reassign
        str = left ? '0' + str : str + '0';
      }
      return str;
    }

    function _throwNumberOutOfRange(value, minimum, maximum, property) {
      var msg =
        value +
        ' is out of range.  Enter a value between ' +
        minimum +
        ' and ' +
        maximum +
        ' for ' +
        property;
      var rangeError = new RangeError(msg);
      var errorInfo = {
        errorCode: 'numberOptionOutOfRange',
        parameterMap: {
          value: value,
          minValue: minimum,
          maxValue: maximum,
          propertyName: property
        }
      };
      rangeError.errorInfo = errorInfo;
      throw rangeError;
    }

    function _getNumberOption(options, property, minimum, maximum, fallback) {
      var value = options[property];
      if (value !== undefined) {
        value = Number(value);
        if (isNaN(value) || value < minimum || value > maximum) {
          _throwNumberOutOfRange(value, minimum, maximum, property);
        }
        return Math.floor(value);
      }

      return fallback;
    }

    // get the numbering system key from the locale's unicode extension.
    // Verify that the locale data has a numbers entry for it, if not return latn as default.
    function _getNumberingSystemKey(localeElements, locale) {
      if (locale === undefined) {
        return 'latn';
      }
      var numberingSystemKey = _getNumberingExtension(locale);
      var symbols = 'symbols-numberSystem-' + numberingSystemKey;
      if (localeElements.numbers[symbols] === undefined) {
        numberingSystemKey = 'latn';
      }
      return numberingSystemKey;
    }

    // return the language part
    function _getBCP47Lang(tag) {
      var arr = tag.split('-');
      return arr[0];
    }

    // get the unicode numbering system extension.
    function _getNumberingExtension(locale) {
      var _locale = locale || 'en-US';
      var idx = _locale.indexOf('-u-nu-');
      var numbering = 'latn';
      if (idx !== -1) {
        numbering = _locale.substr(idx + 6, 4);
      }
      return numbering;
    }

    /* return the properties for a number such as minimum and maximum fraction
     *digits, decimal separator, grouping separator.
     *-If no user defined pattern is provided, get the pattern from the locale
     *  data and parse it to extrcat the number properties. If ecma options are
     *  present, override the corresponding default properties.
     *-If a user defined pattern is provided, parse it and extrcat the number
     *  properties. Ignore ecma ptions if present.
     */

    function _getNumberSettings(localeElements, _numberSettings, options, locale) {
      var numberSettings = _numberSettings;
      var pat;
      var localeElementsMainNode =
        __ConverterUtilsI18n.OraI18nUtils.getLocaleElementsMainNode(localeElements);
      var numberingSystemKey = _getNumberingSystemKey(localeElementsMainNode, locale);
      numberSettings.numberingSystemKey = numberingSystemKey;
      numberSettings.numberingSystem = 'symbols-numberSystem-' + numberingSystemKey;
      var lenient = options.lenientParse;
      numberSettings.lenientParse = lenient || 'full';
      numberSettings.style = options.style;
      // pattern passed in options
      if (options.pattern !== undefined && options.pattern.length > 0) {
        pat = options.pattern;
      } else {
        var key;
        switch (numberSettings.style) {
          case 'decimal':
            key = 'decimalFormats-numberSystem-';
            break;
          case 'currency':
            key = 'currencyFormats-numberSystem-';
            break;
          case 'percent':
            key = 'percentFormats-numberSystem-';
            break;
          default:
            key = 'decimalFormats-numberSystem-';
            break;
        }
        key += numberSettings.numberingSystemKey;
        pat = localeElementsMainNode.numbers[key].standard;
      }
      // check if decimalFormat is set
      var decFormatLength = options.decimalFormat;
      // if not, check for currencyFormat
      if (decFormatLength === undefined) {
        decFormatLength = options.currencyFormat;
      }
      // if either decimalFormat or currencyFormat is set, save it in number settings
      if (
        decFormatLength !== undefined &&
        (numberSettings.style === 'decimal' || numberSettings.style === 'currency')
      ) {
        numberSettings.shortDecimalFormat =
          localeElementsMainNode.numbers['decimalFormats-numberSystem-latn'][
            decFormatLength
          ].decimalFormat;
      }
      var decimalSeparator = localeElementsMainNode.numbers[numberSettings.numberingSystem].decimal;
      var groupSeparator = localeElementsMainNode.numbers[numberSettings.numberingSystem].group;
      var separators = options.separators;
      if (separators !== undefined) {
        numberSettings.separators = separators;
        var dec = separators.decimal;
        var grp = separators.group;
        if (dec !== undefined && dec !== '') {
          decimalSeparator = separators.decimal;
        }
        if (grp !== undefined) {
          groupSeparator = separators.group;
        }
      }
      var mainNodeKey =
        __ConverterUtilsI18n.OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
      var lang = _getBCP47Lang(mainNodeKey);
      numberSettings.lang = lang;
      numberSettings.pat = pat;
      numberSettings.minusSign =
        localeElementsMainNode.numbers[numberSettings.numberingSystem].minusSign;
      numberSettings.decimalSeparator = decimalSeparator;
      numberSettings.exponential =
        localeElementsMainNode.numbers[numberSettings.numberingSystem].exponential;
      numberSettings.groupingSeparator = groupSeparator;
      numberSettings.currencyDisplay = options.currencyDisplay;
      if (options.currency !== undefined) {
        numberSettings.currencyCode = options.currency.toUpperCase();
      }
      if (options.unit !== undefined) {
        numberSettings.unit = options.unit.toLowerCase();
      }
      _applyPatternImpl(options, pat, localeElementsMainNode, numberSettings);
      if (options.pattern === undefined) {
        numberSettings.minimumIntegerDigits = _getNumberOption(
          options,
          'minimumIntegerDigits',
          1,
          21,
          numberSettings.minimumIntegerDigits
        );
        if (options.maximumFractionDigits !== undefined) {
          numberSettings.maximumFractionDigits = _getNumberOption(
            options,
            'maximumFractionDigits',
            0,
            20,
            numberSettings.maximumFractionDigits
          );
          if (numberSettings.maximumFractionDigits < numberSettings.minimumFractionDigits) {
            numberSettings.minimumFractionDigits = numberSettings.maximumFractionDigits;
          }
        }
        if (options.minimumFractionDigits !== undefined) {
          numberSettings.minimumFractionDigits = _getNumberOption(
            options,
            'minimumFractionDigits',
            0,
            20,
            numberSettings.minimumFractionDigits
          );
        }
        if (numberSettings.maximumFractionDigits < numberSettings.minimumFractionDigits) {
          numberSettings.maximumFractionDigits = numberSettings.minimumFractionDigits;
          Logger.info(
            'maximumFractionDigits is less than minimumFractionDigits, so maximumFractionDigits will be set to minimumFractionDigits'
          );
        }
        // set currency fractions based on currencyData in root bundle. Do not apply
        // it for short and long currencyFormats
        if (
          numberSettings.style === 'currency' &&
          options.minimumFractionDigits === undefined &&
          options.maximumFractionDigits === undefined &&
          (decFormatLength === undefined || decFormatLength === 'standard')
        ) {
          var currencyFractions = localeElements.supplemental.currencyData.fractions;
          var specialCurrency = currencyFractions[options.currency];
          if (specialCurrency !== undefined) {
            var fractionDigits = parseInt(specialCurrency._digits, 10);
            numberSettings.minimumFractionDigits = fractionDigits;
            numberSettings.maximumFractionDigits = fractionDigits;
          }
        }
      }
    }

    function _throwMissingCurrency(prop) {
      var typeError = new TypeError(
        'The property "currency" is required when' +
          ' the property "' +
          prop +
          '" is "currency". An accepted value is a ' +
          'three-letter ISO 4217 currency code.'
      );
      var errorInfo = {
        errorCode: 'optionTypesMismatch',
        parameterMap: {
          propertyName: prop, // the driving property
          propertyValue: 'currency', // the driving property's value
          requiredPropertyName: 'currency', // the required property name
          requiredPropertyValueValid: 'a three-letter ISO 4217 currency code'
        }
      };
      typeError.errorInfo = errorInfo;
      throw typeError;
    }

    function _throwMissingUnit(prop) {
      var typeError = new TypeError(
        'The property "unit" is required when' +
          ' the property "' +
          prop +
          '" is "unit". An accepted value is "byte" or "bit".'
      );
      var errorInfo = {
        errorCode: 'optionTypesMismatch',
        parameterMap: {
          propertyName: prop, // the driving property
          propertyValue: 'unit', // the driving property's value
          requiredPropertyName: 'unit', // the required property name
          requiredPropertyValueValid: 'byte or bit'
        }
      };
      typeError.errorInfo = errorInfo;
      throw typeError;
    }

    function _throwUnsupportedParseOption(val) {
      var code = 'unsupportedParseFormat';
      var msg = 'long and short ' + val + ' are not supported for parsing';
      var error = new Error(msg);
      var errorInfo = {
        errorCode: code,
        parameterMap: {
          shortFormats: val
        }
      };
      error.errorInfo = errorInfo;
      throw error;
    }

    // If the user specifies currency as a style, currency option must also be
    // provided. parse does not support short and long decimalFormat.
    function _validateNumberOptions(options, caller) {
      var getOption = __ConverterUtilsI18n.OraI18nUtils.getGetOption(options, caller);
      var s = getOption(
        'style',
        'string',
        ['currency', 'decimal', 'percent', 'unit', 'perMill'],
        'decimal'
      );
      if (s === 'decimal' || s === 'currency') {
        var fmt = s === 'decimal' ? 'decimalFormat' : 'currencyFormat';
        s = getOption(fmt, 'string', ['standard', 'short', 'long']);
        if (caller === 'OraNumberConverter.parse' && s !== undefined && s !== 'standard') {
          _throwUnsupportedParseOption(fmt);
        }
      }
      var c = getOption('currency', 'string');
      if (s === 'currency' && c === undefined) {
        _throwMissingCurrency('style');
      }

      c = getOption('unit', 'string');
      if (s === 'unit' && c === undefined) {
        _throwMissingUnit('style');
      }
      s = getOption('roundingMode', 'string', [
        'UP',
        'DOWN',
        'FLOOR',
        'CEILING',
        'HALF_UP',
        'HALF_DOWN',
        'HALF_EVEN'
      ]);
    }

    // _toDigitalByte does compact formatting like 300MB, 300Mb
    function _toDigitalByte(number, options, numberSettings, localeElements) {
      var scale;
      var count;
      var absVal = Math.abs(number);
      if (absVal >= _DIGITAL_TERA) {
        scale = 'digital-tera';
        count = absVal / _DIGITAL_TERA;
      } else if (absVal >= _DIGITAL_GIGA) {
        scale = 'digital-giga';
        count = absVal / _DIGITAL_GIGA;
      } else if (absVal >= _DIGITAL_MEGA) {
        scale = 'digital-mega';
        count = absVal / _DIGITAL_MEGA;
      } else if (absVal >= _DIGITAL_KILO) {
        scale = 'digital-kilo';
        count = absVal / _DIGITAL_KILO;
      } else {
        scale = 'digital-';
        count = absVal;
      }
      // Find the corresponding entry in resource budle under units section
      // scale -> 'digital-kilo-bit' or 'digital-kilo-byte'
      scale += numberSettings.unit;
      var lang = numberSettings.lang;
      // get plural rule: one, many, etc..
      var plural = new Intl.PluralRules(lang).select(count);
      // plural -> 'unitPattern-count-one' or 'unitPattern-count-many'
      plural = 'unitPattern-count-' + plural;
      // format the number
      if (number < 0) {
        count = -count;
      }
      var fmt = _toRawFixed(count, options, numberSettings);
      // format the number based on plural rule: "{0} Gb", etc..
      var entry = localeElements.units.narrow[scale][plural];
      fmt = __ConverterUtilsI18n.OraI18nUtils.formatString(entry, [fmt]);
      return fmt;
    }

    // _toCompactNumber does compact formatting like 3000->3K for short
    // and "3 thousand" for long
    function _toCompactNumber(number, options, numberSettings) {
      function _getZerosInPattern(s) {
        var i = 0;
        var n = 0;
        var idx = 0;
        var prefix = '';
        if (s[0] !== '0') {
          while (s[i] !== '0' && i < s.length) {
            i += 1;
          }
          prefix = s.substr(0, i);
          idx = i;
        }
        for (i = idx; i < s.length; i++) {
          if (s[i] === '0') {
            n += 1;
          } else {
            break;
          }
        }
        return [prefix, n];
      }

      /* To format a number N, the greatest type less than or equal to N is used, with
       * the appropriate plural category. N is divided by the type, after removing the
       * number of zeros in the pattern, less 1.
       * APIs supporting this format should provide control over the number of
       * significant or fraction digits.
       *Thus N=12345 matches <pattern type="10000" count="other">00 K</pattern>.
       *N is divided by 1000 (obtained from 10000 after removing "00" and restoring
       *one "0". The result is formatted according to the normal decimal pattern.
       *With no fractional digits, that yields "12 K".
       */
      function _matchTypeValue(n) {
        var decimalTypeKeys = Object.keys(_decimalTypeValues);
        for (var i = 0; i < decimalTypeKeys.length; i++) {
          var decimalTypeKey = decimalTypeKeys[i];
          var len = _decimalTypeValues[decimalTypeKey].length;
          for (var j = 0; j < len; j++) {
            if (_decimalTypeValues[decimalTypeKey][j] <= n) {
              return [decimalTypeKey, _decimalTypeValues[decimalTypeKey][j]];
            }
          }
        }
        return [n, null];
      }
      var absVal = Math.abs(number);
      var typeVal = _matchTypeValue(absVal);
      var prefix = '';
      var decimalFormatType;
      var tokens;
      var zeros;
      if (typeVal[1] !== null) {
        var lang = numberSettings.lang;
        var plural = new Intl.PluralRules(lang).select(
          Math.floor(absVal / _decimalTypeValuesMap[typeVal[0]])
        );
        decimalFormatType = '' + typeVal[1] + '-count-' + plural;
        decimalFormatType = numberSettings.shortDecimalFormat[decimalFormatType];
        if (decimalFormatType === undefined) {
          plural = 'other';
          decimalFormatType = '' + typeVal[1] + '-count-' + plural;
          decimalFormatType = numberSettings.shortDecimalFormat[decimalFormatType];
        }
        tokens = _getZerosInPattern(decimalFormatType);
        zeros = tokens[1];
        prefix = tokens[0];
        if (zeros < decimalFormatType.length) {
          var i = 1 * Math.pow(10, zeros);
          i = (typeVal[1] / i) * 10;
          // eslint-disable-next-line no-param-reassign
          absVal /= i;
        }
      }
      var s = '';
      var fmt;
      if (decimalFormatType !== undefined) {
        s = decimalFormatType.substr(zeros + tokens[0].length);
      }
      if (number < 0) {
        absVal = -absVal;
      }
      fmt = _toRawFixed(absVal, options, numberSettings);
      var regExp = /'\.'/g;
      s = s.replace(regExp, '.');
      s = prefix + fmt + s;
      return s;
    }

    // _toExponentialPrecision does the formatting when the pattern contain E,
    // for example #.#E0
    function _toExponentialPrecision(number, numberSettings) {
      var numStr0 = number + '';
      var trimExp = 0;
      var split = numStr0.split(/e/i);
      var numStr = split[0];
      _REGEX_TRIM_ZEROS.lastIndex = 0;
      var match = _REGEX_TRIM_ZEROS.exec(numStr);
      if (match !== null) {
        trimExp = match[1].length - 1;
        numStr = match[2];
      } else {
        numStr = numStr.replace('.', '');
      }
      var exponent = split.length > 1 ? parseInt(split[1], 10) : 0;
      var numStr1 = parseInt(numStr, 10);
      var len = numberSettings.minimumIntegerDigits + numberSettings.maximumFractionDigits;
      if (numStr.length > len) {
        len -= numStr.length;
        var factor = Math.pow(10, len);
        numStr1 = Math.round(numStr1 * factor);
      }
      var padLen = numberSettings.minimumIntegerDigits + numberSettings.minimumFractionDigits;
      numStr1 += '';
      numStr1 = _zeroPad(numStr1, padLen, false);
      if (numStr0.indexOf('.') !== -1) {
        exponent -= numberSettings.minimumIntegerDigits - numStr0.indexOf('.') + trimExp;
      } else {
        exponent -= padLen - numStr.length - numberSettings.minimumFractionDigits;
      }
      var posExp = Math.abs(exponent);
      posExp = _zeroPad(posExp + '', numberSettings.minExponentDigits, true);
      if (exponent < 0) {
        posExp = numberSettings.minusSign + posExp;
      }
      var str1 = numStr1.slice(0, numberSettings.minimumIntegerDigits);
      var str2 = numStr1.slice(numberSettings.minimumIntegerDigits);
      if (str2.length > 0) {
        str1 +=
          numberSettings.decimalSeparator +
          numStr1.slice(numberSettings.minimumIntegerDigits) +
          numberSettings.exponential +
          posExp;
      } else {
        str1 += numberSettings.exponential + posExp;
      }
      return str1;
    }

    // _toRawFixed does the formatting based on
    // minimumFractionDigits and maximumFractionDigits.
    function _toRawFixed(number, options, numberSettings) {
      var curSize = numberSettings.groupingSize;
      var curSize0 = numberSettings.groupingSize0;
      var decimalSeparator = numberSettings.decimalSeparator;
      // First round the number based on maximumFractionDigits
      var numberString = number + '';
      var split = numberString.split(/e/i);
      var exponent = split.length > 1 ? parseInt(split[1], 10) : 0;
      numberString = split[0];
      split = numberString.split('.');
      var right = split.length > 1 ? split[1] : '';
      var precision = Math.min(numberSettings.maximumFractionDigits, right.length - exponent);
      // round the number only if it has decimal points
      if (split.length > 1 && right.length > exponent) {
        var mode = options.roundingMode || 'DEFAULT';
        // eslint-disable-next-line no-param-reassign
        number = _roundNumber(number, precision, mode);
      }
      // split the number into integer, fraction and exponent parts.
      numberString = Math.abs(number) + '';
      split = numberString.split(/e/i);
      exponent = split.length > 1 ? parseInt(split[1], 10) : 0;
      numberString = split[0];
      split = numberString.split('.');
      numberString = split[0];
      right = split.length > 1 ? split[1] : '';
      // pad zeros based on the exponent value and minimumFractionDigits
      if (exponent > 0) {
        right = _zeroPad(right, exponent, false);
        numberString += right.slice(0, exponent);
        right = right.substr(exponent);
      } else if (exponent < 0) {
        exponent = -exponent;
        numberString = _zeroPad(numberString, exponent + 1, true);
        right = numberString.slice(-exponent, numberString.length) + right;
        numberString = numberString.slice(0, -exponent);
      }
      if (precision > 0 && right.length > 0) {
        right =
          right.length > precision ? right.slice(0, precision) : _zeroPad(right, precision, false);
        // if right is only zeros, truncate it to minimumFractionDigits
        if (_REGEX_ONLY_ZEROS.test(right) === true) {
          right = right.slice(0, numberSettings.minimumFractionDigits);
        }
        right = decimalSeparator + right;
      } else if (numberSettings.minimumFractionDigits > 0) {
        right = decimalSeparator;
      } else {
        right = '';
      }
      // trim trailing zeros from right
      right = __ConverterUtilsI18n.OraI18nUtils.trimRightZeros(right);
      // insert grouping separator in the integer part based on groupingSize
      var padLen = decimalSeparator.length + numberSettings.minimumFractionDigits;
      right = _zeroPad(right, padLen, false);
      var sep = numberSettings.groupingSeparator;
      var ret = '';
      if (options.useGrouping === false && options.pattern === undefined) {
        sep = '';
      }
      numberString = _zeroPad(numberString, numberSettings.minimumIntegerDigits, true);
      var stringIndex = numberString.length - 1;
      right = right.length > 1 ? right : '';
      var rets;
      while (stringIndex >= 0) {
        if (curSize === 0 || curSize > stringIndex) {
          rets = numberString.slice(0, stringIndex + 1) + (ret.length ? sep + ret + right : right);
          return rets;
        }
        ret =
          numberString.slice(stringIndex - curSize + 1, stringIndex + 1) +
          (ret.length ? sep + ret : '');
        stringIndex -= curSize;
        if (curSize0 > 0) {
          curSize = curSize0;
        }
      }
      rets = numberString.slice(0, stringIndex + 1) + sep + ret + right;
      return rets;
    }

    function _expandExponent(n) {
      var str = n.toString();
      str = str.replace('E', 'e');
      var isNegative = false;
      if (str.charAt(0) === '-') {
        isNegative = true;
        str = str.substring(1);
      }
      var parts = str.split('e');
      var part1 = parts[0];
      var part2 = Number(parts[1]);
      if (part2 > 0) {
        str = part1.substr(0, 1) + part1.substr(2);
        if (str.length - 1 < part2) {
          var e = part2 + 1 - str.length;
          while (e > 0) {
            str += '0';
            e -= 1;
          }
        } else if (str.length - 1 > part2) {
          str = str.substr(0, part2 + 1) + '.' + str.substr(part2 + 1);
        }
      } else if (part2 < 0) {
        var digits = part1.substr(0, 1) + part1.substr(2);
        str = '0.';
        for (var i = part2; i < -1; i++) {
          str += '0';
        }
        str += digits;
      }
      if (isNegative) {
        str = '-' + str;
      }
      return str;
    }

    /* rounds the number based on the following rules:
     * CEILING: Rounding mode to round towards positive infinity.
     * DOWN: Rounding mode to round towards zero.
     * FLOOR: Rounding mode to round towards negative infinity.
     * HALF_DOWN: Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round down.
     * HALF_EVEN: Rounding mode to round towards the "nearest neighbor" unless both neighbors are equidistant, in which case, round towards the even neighbor.
     * HALF_UP: Rounding mode to round towards "nearest neighbor" unless both neighbors are equidistant, in which case round up.
     * UP: Rounding mode to round away from zero.
     */
    function _roundNumber(value, scale, mode) {
      var rounded;
      var adjustedMode = mode;
      var parts = _expandExponent(value);
      parts = parts.split('.');
      if (parts[1] === undefined) {
        return Math.abs(value);
      }
      if (mode !== 'DEFAULT') {
        // HALF_DOWN behaves as HALF_UP if the discarded fraction is > 0.5
        if (mode === 'HALF_UP' || mode === 'HALF_EVEN' || mode === 'HALF_DOWN') {
          if (parts[1][scale] === '5') {
            var n = parts[1].substr(scale);
            n = parseInt(n, 10);
            if (n > 5) {
              adjustedMode = 'HALF_UP';
            }
          } else {
            adjustedMode = 'DEFAULT';
          }
          // eslint-disable-next-line no-param-reassign
          value = Math.abs(value);
        }
        adjustedMode = _getRoundingMode(parts, adjustedMode, scale, value);
        rounded = _decimalAdjust(value, -scale, adjustedMode);
      } else {
        var factor = Math.pow(10, scale);
        rounded = Math.round(value * factor) / factor;
        if (!isFinite(rounded)) {
          return value;
        }
      }
      return Math.abs(rounded);
    }

    function _getRoundingMode(parts, rMode, scale, value) {
      var mode = _roundingModeMap[rMode];
      if (rMode === 'HALF_EVEN') {
        var c;
        if (scale === 0) {
          var len = parts[0].length;
          c = parseInt(parts[0][len - 1], 10);
        } else {
          c = parseInt(parts[1][scale - 1], 10);
        }
        if (c % 2 === 0) {
          mode = _roundingModeMap.HALF_DOWN;
        } else {
          mode = _roundingModeMap.HALF_UP;
        }
      } else if (rMode === 'UP' && value < 0) {
        mode = _roundingModeMap.DOWN;
      } else if (rMode === 'DOWN' && value < 0) {
        mode = _roundingModeMap.UP;
      }
      return mode;
    }

    /**
     * This function does the actual rounding of the number based on the rounding
     * mode:
     * value is the number to be rounded.
     * scale is the maximumFractionDigits.
     * mode is the rounding mode: ceil, floor, round.
     */
    function _decimalAdjust(value, scale, mode) {
      if (scale === 0) {
        return Math[mode](value);
      }
      var strValue = value.toString().split('e');
      var v0 = strValue[0];
      var v1 = strValue[1];
      // shift the decimal point based on the scale so that we can apply ceil or floor
      // scale is a number, no need to parse it, just parse v1.
      var s = v0 + 'e' + (v1 ? parseInt(v1, 10) - scale : -scale);
      var num = parseFloat(s);
      var _value = Math[mode](num);
      strValue = _value.toString().split('e');
      // need to extract v0 and v1 again because value has changed after applying Math[mode].
      v0 = strValue[0];
      v1 = strValue[1];
      // shift the decimal point back to its original position
      s = v0 + 'e' + (v1 ? parseInt(v1, 10) + scale : scale);
      num = parseFloat(s);
      return num;
    }

    // first call _toRawFixed then add prefixes and suffixes. Display the
    // number using native digits based on the numbering system
    function _formatNumberImpl(value, options, localeElements, numberSettings, locale) {
      var localeElementsMainNode =
        __ConverterUtilsI18n.OraI18nUtils.getLocaleElementsMainNode(localeElements);
      if (!isFinite(value)) {
        if (value === Infinity) {
          return localeElementsMainNode.numbers[numberSettings.numberingSystem].infinity;
        }
        if (value === -Infinity) {
          return localeElementsMainNode.numbers[numberSettings.numberingSystem].infinity;
        }
        // return localeElementsMainNode.numbers[numberSettings.numberingSystem].nan;
        // return a non-localized NaN so the IntlNumberConverter can throw
        // an error based on it.
        return 'NaN';
      }
      var number = value;
      if (numberSettings.isPercent === true || numberSettings.style === 'percent') {
        number *= 100;
      } else if (numberSettings.isPerMill === true) {
        number *= 1000;
      }
      // expand the number
      var formatType = options.decimalFormat;
      if (formatType === undefined) {
        formatType = options.currencyFormat;
      }
      var optStyle = numberSettings.style;
      if (
        (optStyle === 'decimal' || optStyle === 'currency') &&
        formatType !== undefined &&
        formatType !== 'standard'
      ) {
        number = _toCompactNumber(number, options, numberSettings);
      } else if (numberSettings.useExponentialNotation === true) {
        number = _toExponentialPrecision(number, numberSettings);
      } else if (optStyle === 'unit') {
        number = _toDigitalByte(number, options, numberSettings, localeElementsMainNode);
      } else {
        number = _toRawFixed(number, options, numberSettings);
      }

      var ret = '';
      // add negative prefix and suffix if number is negative
      // and the new formatted value isn't zero
      if (value < 0 && number - 0 !== 0) {
        ret += numberSettings.negativePrefix + number + numberSettings.negativeSuffix;
      } else {
        // add positive prefix and suffix if number is positive
        ret += numberSettings.positivePrefix + number + numberSettings.positiveSuffix;
      }
      // display the digits based on the numbering system
      var numberingSystemKey = _getNumberingExtension(locale);
      if (__ConverterUtilsI18n.OraI18nUtils.numeringSystems[numberingSystemKey] === undefined) {
        numberingSystemKey = 'latn';
      }
      if (numberingSystemKey !== 'latn') {
        var idx;
        var nativeRet = [];
        for (idx = 0; idx < ret.length; idx++) {
          if (ret[idx] >= '0' && ret[idx] <= '9') {
            nativeRet.push(
              __ConverterUtilsI18n.OraI18nUtils.numeringSystems[numberingSystemKey][ret[idx]]
            );
          } else {
            nativeRet.push(ret[idx]);
          }
        }
        return nativeRet.join('');
      }
      return ret;
    }

    // remove prefix and suffix, return a sign and value. First try to extract
    // a number using exact match. If it fails try lenient parsing.
    function _parseNegativePattern(value, options, numberSettings, localeElements) {
      var ret;
      var num = __ConverterUtilsI18n.OraI18nUtils.trimNumber(value);
      var sign = '';
      var exactMatch = false;
      var posSign = localeElements.numbers[numberSettings.numberingSystem].plusSign;
      var posSignRegExp = new RegExp('^' + posSign.replace(_ESCAPE_REGEXP, '\\$1'));
      num = num.replace(posSignRegExp, '');
      // The pattern of a number may contain positive prefix (nbSettingPosPrefix),
      // positive suffix (nbSettingPosSuffix),
      // negative prefix (nbSettingNegPrefix) ,
      // negative suffix (nbSettingNegSuffix).
      // We first try exact match of these prefix/suffix to determine the sign of
      // the number. If the number pattern pattern contain these prefix/suffix
      // and no exact match is found, we go to lenient parse.
      var nbSettingPosPrefix = __ConverterUtilsI18n.OraI18nUtils.trimNumber(
        numberSettings.positivePrefix
      );
      var nbSettingPosSuffix = __ConverterUtilsI18n.OraI18nUtils.trimNumber(
        numberSettings.positiveSuffix
      );
      var nbSettingNegPrefix = __ConverterUtilsI18n.OraI18nUtils.trimNumber(
        numberSettings.negativePrefix
      );
      var nbSettingNegSuffix = __ConverterUtilsI18n.OraI18nUtils.trimNumber(
        numberSettings.negativeSuffix
      );
      // Create regular expressions for the prefixes and suffixes in order to
      // match them with the input number. We need to escape the special
      // characters in them by using _ESCAPE_REGEXP. For example if the prefix
      // conatain '$' it need to be escaped to '\\$'
      // positive prefix regular expression
      var posPrefRegexp = new RegExp(
        '^' + (nbSettingPosPrefix || '').replace(_ESCAPE_REGEXP, '\\$1')
      );
      // positive suffix regular expression
      var posSuffRegexp = new RegExp(
        (nbSettingPosSuffix || '').replace(_ESCAPE_REGEXP, '\\$1') + '$'
      );
      // negative prefix regular expression
      var negPrefRegexp = new RegExp(
        '^' + (nbSettingNegPrefix || '').replace(_ESCAPE_REGEXP, '\\$1')
      );
      // negative suffix regular expression
      var negSuffRegexp = new RegExp(
        (nbSettingNegSuffix || '').replace(_ESCAPE_REGEXP, '\\$1') + '$'
      );
      // try exact match of negative prefix and suffix
      if (negPrefRegexp.test(num) === true && negSuffRegexp.test(num) === true) {
        num = num.replace(negPrefRegexp, '');
        num = num.replace(negSuffRegexp, '');
        sign = '-';
        exactMatch = true;
      } else if (posPrefRegexp.test(num) === true && posSuffRegexp.test(num) === true) {
        // try exact match of positive prefix and suffix
        num = num.replace(posPrefRegexp, '');
        num = num.replace(posSuffRegexp, '');
        sign = '+';
        exactMatch = true;
      } else if (numberSettings.style === 'currency') {
        // if style is currency, remove currency symbol from prefix and suffix
        // and try a match
        var code = numberSettings.currencyCode;
        var symbol = code;
        var repStr;
        if (localeElements.numbers.currencies[code] !== undefined) {
          symbol = localeElements.numbers.currencies[code].symbol;
        }
        if (
          numberSettings.currencyDisplay === undefined ||
          numberSettings.currencyDisplay === 'symbol'
        ) {
          repStr = symbol;
        } else if (numberSettings.currencyDisplay === 'code') {
          repStr = code;
        }
        if (repStr !== undefined) {
          // Remove the currency code/symbol from the prefix/suffix
          var posPrefix = (nbSettingPosPrefix || '').replace(repStr, '');
          var posSuffix = (nbSettingPosSuffix || '').replace(repStr, '');
          var negPrefix = (nbSettingNegPrefix || '').replace(repStr, '');
          var negSuffix = (nbSettingNegSuffix || '').replace(repStr, '');
          // positive prefix regular expression without currency code/symbol
          posPrefRegexp = new RegExp('^' + posPrefix.replace(_ESCAPE_REGEXP, '\\$1'));
          // positive suffix regular expression without currency code/symbol
          posSuffRegexp = new RegExp(posSuffix.replace(_ESCAPE_REGEXP, '\\$1') + '$');
          // negative prefix regular expression without currency code/symbol
          negPrefRegexp = new RegExp('^' + negPrefix.replace(_ESCAPE_REGEXP, '\\$1'));
          // negative suffix regular expression without currency code/symbol
          negSuffRegexp = new RegExp(negSuffix.replace(_ESCAPE_REGEXP, '\\$1') + '$');

          // try  match of positive prefix and suffix without currency code/symbol
          if (negPrefRegexp.test(num) === true && negSuffRegexp.test(num) === true) {
            num = num.replace(negPrefRegexp, '');
            num = num.replace(negSuffRegexp, '');
            sign = '-';
            exactMatch = true;
          } else if (posPrefRegexp.test(num) === true && posSuffRegexp.test(num) === true) {
            // try exact match of positive prefix and suffix
            num = num.replace(posPrefRegexp, '');
            num = num.replace(posSuffRegexp, '');
            sign = '+';
            exactMatch = true;
          }
        }
      }
      if (!exactMatch) {
        if (numberSettings.lenientParse === 'full') {
          ret = _lenientParseNumber(num, numberSettings);
          ret[2] = true;
        } else {
          _throwNaNException(numberSettings.style, numberSettings, value);
        }
      } else {
        ret = [sign, num];
      }
      return ret;
    }

    function _lenientParseNumber(_num, numberSettings) {
      // Try to extract the number accoring to the following pattern:
      // optional +- followed by one or many digits followed by optional
      // fraction part followed by optional exponential.
      // use localized +, -, decimal separator, exponential
      // [+-]?\d+(?:\.\d+)?(?:E[+-]?\d+)?/;
      // remove grouping deparator from string
      var groupingSeparator = numberSettings.groupingSeparator;
      var decimalSeparator = numberSettings.decimalSeparator;
      var localeMinusSign = numberSettings.minusSign;
      var plusSign = '+';
      var minusSign = '-';
      var sign = '';
      var dot = '';
      var exponential = __ConverterUtilsI18n.OraI18nUtils.toUpper(numberSettings.exponential);
      var num = __ConverterUtilsI18n.OraI18nUtils.toUpper(_num);
      num = num.split(exponential).join('E');
      // remove grouping separator from string
      var groupSep = groupingSeparator;
      num = num.split(groupSep).join('');
      var altGroupSep = groupSep.replace(/\u00A0/g, ' ');
      if (groupSep !== altGroupSep) {
        num = num.split(altGroupSep).join('');
      }
      num = num.split(decimalSeparator).join('.');
      if (num.charAt(0) === '.') {
        num = num.substr(1);
        dot = '.';
      }
      // replace localized minus with minus
      num = num.replace(localeMinusSign, minusSign);
      var match = _LENIENT_REGEX_PARSE_FLOAT.exec(num);
      var resNum = dot + match[2];
      if (__ConverterUtilsI18n.OraI18nUtils.startsWith(resNum, minusSign)) {
        resNum = resNum.substr(minusSign.length);
        sign = '-';
      } else if (__ConverterUtilsI18n.OraI18nUtils.startsWith(num, plusSign)) {
        resNum = resNum.substr(plusSign.length);
        sign = '+';
      }
      return [sign, resNum];
    }

    // parse the exponent part of a number
    function _parseNegativeExponent(_value, numberSettings) {
      var neg = numberSettings.minusSign;
      var pos = numberSettings.plusSign;
      var ret;
      var value = __ConverterUtilsI18n.OraI18nUtils.trimNumber(_value);
      neg = __ConverterUtilsI18n.OraI18nUtils.trimNumber(neg);
      pos = __ConverterUtilsI18n.OraI18nUtils.trimNumber(pos);
      if (__ConverterUtilsI18n.OraI18nUtils.startsWith(value, neg)) {
        ret = ['-', value.substr(neg.length)];
      } else if (
        __ConverterUtilsI18n.OraI18nUtils.startsWith(
          value,
          __ConverterUtilsI18n.OraI18nUtils.trimNumber(pos)
        )
      ) {
        ret = ['+', value.substr(pos.length)];
      }
      return ret || ['', value];
    }

    function _getLatnDigits(str, locale) {
      var numberingSystemKey = _getNumberingExtension(locale);
      if (__ConverterUtilsI18n.OraI18nUtils.numeringSystems[numberingSystemKey] === undefined) {
        return str;
      }
      var idx;
      var latnStr = [];
      for (idx = 0; idx < str.length; idx++) {
        var pos = __ConverterUtilsI18n.OraI18nUtils.numeringSystems[numberingSystemKey].indexOf(
          str[idx]
        );
        if (pos !== -1) {
          latnStr.push(pos);
        } else {
          latnStr.push(str[idx]);
        }
      }
      var ret = latnStr.join('');
      return ret;
    }

    // split the number into integer, fraction and exponential parts
    function _getNumberParts(_num, numberSettings) {
      var parts = {};
      var decimalSeparator = numberSettings.decimalSeparator;
      var groupSep = numberSettings.groupingSeparator;
      var num = _num.replace(/ /g, '');
      // determine exponent and number
      var exponentSymbol = numberSettings.exponential;
      var integer;
      var intAndFraction;
      var exponentPos = num.indexOf(exponentSymbol.toLowerCase());
      if (exponentPos < 0) {
        exponentPos = num.indexOf(__ConverterUtilsI18n.OraI18nUtils.toUpper(exponentSymbol));
      }
      if (exponentPos < 0) {
        intAndFraction = num;
        parts.exponent = null;
      } else {
        intAndFraction = num.substr(0, exponentPos);
        parts.exponent = num.substr(exponentPos + exponentSymbol.length);
      }
      // determine decimal position
      var decSep = decimalSeparator;
      var decimalPos = intAndFraction.indexOf(decSep);
      if (decimalPos < 0) {
        integer = intAndFraction;
        parts.fraction = null;
      } else {
        integer = intAndFraction.substr(0, decimalPos);
        parts.fraction = intAndFraction.substr(decimalPos + decSep.length);
      }
      // handle groups (e.g. 1,000,000)
      integer = integer.split(groupSep).join('');
      var altGroupSep = groupSep.replace(/\u00A0/g, ' ');
      if (groupSep !== altGroupSep) {
        integer = integer.split(altGroupSep).join('');
      }
      parts.integer = integer;
      return parts;
    }

    function _getParsedValue(ret, options, numberSettings, errStr) {
      if (isNaN(ret)) {
        _throwNaNException(numberSettings.style, numberSettings, errStr);
      }
      if (numberSettings.isPercent === true || numberSettings.style === 'percent') {
        // eslint-disable-next-line no-param-reassign
        ret /= 100;
      } else if (numberSettings.isPerMill === true) {
        // eslint-disable-next-line no-param-reassign
        ret /= 1000;
      }
      var getOption = __ConverterUtilsI18n.OraI18nUtils.getGetOption(
        options,
        'OraNumberConverter.parse'
      );
      var roundDuringParse = getOption('roundDuringParse', 'boolean', [true, false], false);
      if (roundDuringParse) {
        // eslint-disable-next-line no-param-reassign
        ret = _getRoundedNumber(ret, numberSettings, options);
      }
      return ret;
    }

    function _throwNaNException(style, numberSettings, errStr) {
      var code;
      var msg = 'Enter a number in this format:' + numberSettings.pat;
      switch (style) {
        case 'decimal':
          code = 'decimalFormatMismatch';
          break;
        case 'currency':
          code = 'currencyFormatMismatch';
          break;
        case 'percent':
          code = 'percentFormatMismatch';
          break;
        default:
          break;
      }
      var error = new Error(msg);
      var errorInfo = {
        errorCode: code,
        parameterMap: {
          value: errStr,
          format: numberSettings.pat
        }
      };
      error.errorInfo = errorInfo;
      throw error;
    }

    function _parseNumberImpl(str, localeElements, options, locale) {
      var localeElementsMainNode =
        __ConverterUtilsI18n.OraI18nUtils.getLocaleElementsMainNode(localeElements);
      var numberSettings = {};
      var numStr = _getLatnDigits(str, locale);
      _getNumberSettings(localeElements, numberSettings, options, locale);
      var ret = NaN;
      var value1 = numStr.replace(/ /g, '');
      // allow infinity or hexidecimal
      if (_REGEX_INFINITY.test(value1)) {
        ret = parseFloat(numStr);
        return ret;
      }
      var signInfo = _parseNegativePattern(numStr, options, numberSettings, localeElementsMainNode);
      var sign = signInfo[0];
      var num = signInfo[1];
      sign = sign || '+';
      if (signInfo[2]) {
        ret = parseFloat(sign + num);
        return _getParsedValue(ret, options, numberSettings, str);
      }

      var parts = _getNumberParts(num, numberSettings);
      var integer = parts.integer;
      var fraction = parts.fraction;
      var exponent = parts.exponent;

      // build a natively parsable number string
      var p = sign + integer;
      if (fraction !== null) {
        p += '.' + fraction;
      }
      if (exponent !== null) {
        // exponent itself may have a number pattern
        var expSignInfo = _parseNegativeExponent(exponent, numberSettings);
        p += 'e' + (expSignInfo[0] || '+') + expSignInfo[1];
      }
      if (_REGEX_PARSE_FLOAT.test(p)) {
        ret = parseFloat(p);
      } else if (numberSettings.lenientParse === 'full') {
        p = _lenientParseNumber(numStr, numberSettings);
        ret = parseFloat(p[0] + p[1]);
      } else {
        _throwNaNException(numberSettings.style, numberSettings, str);
      }
      return _getParsedValue(ret, options, numberSettings, str);
    }

    /* This module handles the  parsing of a number pattern.
     * It sets prefix, suffix, minimum and maximum farcation digits,
     * miimum  integer digits and grouping size.
     */

    var _ZERO_DIGIT = '0';
    var _GROUPING_SEPARATOR = ',';
    var _DECIMAL_SEPARATOR = '.';
    var _PERCENT = '%';
    var _PER_MILL = '\u2030';
    var _DIGIT = '#';
    var _SEPARATOR = ';';
    var _EXPONENT = 'E';
    var _MINUS = '-';
    var _QUOT = "'";
    var _CURRENCY = '\u00A4';

    var posPrefixPattern;
    var posSuffixPattern;
    var negPrefixPattern;
    var negSuffixPattern;

    var _MAXIMUM_INTEGER_DIGITS = 0x7fffffff;
    var _MAXIMUM_FRACTION_DIGITS = 0x7fffffff;

    function _throwSyntaxError(pattern) {
      var samplePattern = '#,##0.###';
      var msg =
        'Unexpected character(s) encountered in the pattern "' +
        pattern +
        ' An example of a valid pattern is "' +
        samplePattern +
        '".';
      var syntaxError = new SyntaxError(msg);
      var errorInfo = {
        errorCode: 'optionValueInvalid',
        parameterMap: {
          propertyName: 'pattern',
          propertyValue: pattern,
          propertyValueHint: samplePattern
        }
      };
      syntaxError.errorInfo = errorInfo;
      throw syntaxError;
    }

    function _regionMatches(str1, offset1, str2) {
      var sub1 = str1.substr(offset1, str2.length);
      var regExp = new RegExp(str2, 'i');
      return regExp.exec(sub1) !== null;
    }

    function _expandAffixes(localeElements, _numberSettings) {
      var numberSettings = _numberSettings;
      var curDisplay = {};
      if (posPrefixPattern !== null) {
        numberSettings.positivePrefix = _expandAffix(
          posPrefixPattern,
          localeElements,
          numberSettings,
          curDisplay
        );
      }
      if (posSuffixPattern !== null) {
        numberSettings.positiveSuffix = _expandAffix(
          posSuffixPattern,
          localeElements,
          numberSettings,
          curDisplay
        );
      }
      if (negPrefixPattern !== null) {
        numberSettings.negativePrefix = _expandAffix(
          negPrefixPattern,
          localeElements,
          numberSettings,
          curDisplay
        );
      }
      if (negSuffixPattern !== null) {
        numberSettings.negativeSuffix = _expandAffix(
          negSuffixPattern,
          localeElements,
          numberSettings,
          curDisplay
        );
      }
      if (curDisplay.name !== undefined) {
        numberSettings.positiveSuffix = '\u00a0' + curDisplay.name;
        numberSettings.positivePrefix = '';
        if (numberSettings.lang === 'ar') {
          numberSettings.negativeSuffix =
            localeElements.numbers[numberSettings.numberingSystem].minusSign +
            '\u00a0' +
            curDisplay.name;
          numberSettings.negativePrefix = '';
        } else {
          numberSettings.negativeSuffix = '\u00a0' + curDisplay.name;
          numberSettings.negativePrefix =
            localeElements.numbers[numberSettings.numberingSystem].minusSign;
        }
      }
    }

    function _expandAffix(pattern, localeElements, numberSettings, currencyDisplay) {
      var buffer = '';
      for (var i = 0; i < pattern.length; ) {
        var c = pattern.charAt(i);
        i += 1;
        if (c !== _QUOT) {
          // c = pattern.charAt(i++);
          switch (c) {
            case _CURRENCY:
              var code = numberSettings.currencyCode;
              var name = code;
              var symbol = code;

              if (localeElements.numbers.currencies[code] !== undefined) {
                name = localeElements.numbers.currencies[code].displayName;
                symbol = localeElements.numbers.currencies[code].symbol;
              }
              if (
                numberSettings.currencyDisplay === undefined ||
                numberSettings.currencyDisplay === 'symbol'
              ) {
                c = symbol;
              } else if (numberSettings.currencyDisplay === 'code') {
                // Currency code need to be followed by a space character
                c = code + ' ';
              } else {
                c = name;
                // eslint-disable-next-line no-param-reassign
                currencyDisplay.name = c;
              }
              break;
            case _PERCENT:
              c = localeElements.numbers[numberSettings.numberingSystem].percentSign;
              break;
            case _PER_MILL:
              c = localeElements.numbers[numberSettings.numberingSystem].perMille;
              break;
            case _MINUS:
              c = localeElements.numbers[numberSettings.numberingSystem].minusSign;
              break;
            default:
              break;
          }
          buffer = buffer.concat(c);
        }
      }
      return buffer;
    }

    function _applyPatternImpl(options, pattern, localeElements, _numberSettings) {
      var numberSettings = _numberSettings;
      var gotNegative = false;
      var useExponentialNotation = false;
      var phaseOneLength = 0;
      var start = 0;
      var isPrefix = true;
      var minExponentDigits;

      for (var j = 1; j >= 0 && start < pattern.length; --j) {
        var inQuote = false;
        var prefix = '';
        var suffix = '';
        var decimalPos = -1;
        var multiplier = 1;
        var digitLeftCount = 0;
        var zeroDigitCount = 0;
        var digitRightCount = 0;
        var groupingCount = -1;
        var groupingCount0 = -1;
        var phase = 0;

        /* eslint-disable no-continue */
        isPrefix = true;
        for (var pos = start; pos < pattern.length; ++pos) {
          var ch = pattern.charAt(pos);
          switch (phase) {
            case 0:
            case 2:
              // Process the prefix / suffix characters
              if (inQuote) {
                if (ch === _QUOT) {
                  if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === _QUOT) {
                    pos += 1;
                    if (isPrefix) {
                      prefix = prefix.concat("''");
                    } else {
                      suffix = suffix.concat("''");
                    }
                  } else {
                    inQuote = false; // 'do'
                  }
                  continue;
                }
              } else if (
                ch === _DIGIT ||
                ch === _ZERO_DIGIT ||
                ch === _GROUPING_SEPARATOR ||
                ch === _DECIMAL_SEPARATOR
              ) {
                // Process unquoted characters seen in prefix or suffix phase.
                phase = 1;
                pos -= 1; // Reprocess this character
                continue;
              } else if (ch === _CURRENCY) {
                if (options.currency === undefined) {
                  _throwMissingCurrency('style');
                }
                // Use lookahead to determine if the currency sign
                // is doubled or not.
                numberSettings.style = 'currency';
                var doubled = pos + 1 < pattern.length && pattern.charAt(pos + 1) === _CURRENCY;
                if (doubled) {
                  // Skip over the doubled character
                  pos += 1;
                }
                if (isPrefix) {
                  prefix = prefix.concat(doubled ? "'\u00A4\u00A4" : "'\u00A4");
                } else {
                  suffix = suffix.concat(doubled ? "'\u00A4\u00A4" : "'\u00A4");
                }
                continue;
              } else if (ch === _QUOT) {
                if (ch === _QUOT) {
                  if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === _QUOT) {
                    pos += 1;
                    if (isPrefix) {
                      prefix = prefix.concat("''"); // o''clock
                    } else {
                      suffix = suffix.concat("''");
                    }
                  } else {
                    inQuote = true; // 'do'
                  }
                  continue;
                }
              } else if (ch === _SEPARATOR) {
                if (phase === 0 || j === 0) {
                  _throwSyntaxError(pattern);
                }
                start = pos + 1;
                pos = pattern.length;
                continue;
              } else if (ch === _PERCENT) {
                // Next handle characters which are appended directly.
                numberSettings.style = 'percent';
                if (multiplier !== 1) {
                  _throwSyntaxError(pattern);
                }
                numberSettings.isPercent = true;
                multiplier = 100;
                if (isPrefix) {
                  prefix = prefix.concat("'%");
                } else {
                  suffix = suffix.concat("'%");
                }
                continue;
              } else if (ch === _PER_MILL) {
                if (multiplier !== 1) {
                  _throwSyntaxError(pattern);
                }
                numberSettings.style = 'perMill';
                numberSettings.isPerMill = true;
                multiplier = 1000;
                if (isPrefix) {
                  prefix = prefix.concat("'\u2030");
                } else {
                  suffix = suffix.concat("'\u2030");
                }
                continue;
              } else if (ch === _MINUS) {
                if (isPrefix) {
                  prefix = prefix.concat("'-");
                } else {
                  suffix = suffix.concat("'-");
                }
                continue;
              }
              if (isPrefix) {
                prefix = prefix.concat(ch);
              } else {
                suffix = suffix.concat(ch);
              }
              break;

            case 1:
              if (j === 1) {
                phaseOneLength += 1;
              } else {
                phaseOneLength -= 1;
                if (phaseOneLength === 0) {
                  phase = 2;
                  isPrefix = false;
                }
                continue;
              }

              if (ch === _DIGIT) {
                if (zeroDigitCount > 0) {
                  digitRightCount += 1;
                } else {
                  digitLeftCount += 1;
                }
                if (groupingCount >= 0 && decimalPos < 0) {
                  groupingCount += 1;
                }
              } else if (ch === _ZERO_DIGIT) {
                if (digitRightCount > 0) {
                  _throwSyntaxError(pattern);
                }
                zeroDigitCount += 1;
                if (groupingCount >= 0 && decimalPos < 0) {
                  groupingCount += 1;
                }
              } else if (ch === _GROUPING_SEPARATOR) {
                groupingCount0 = groupingCount;
                groupingCount = 0;
              } else if (ch === _DECIMAL_SEPARATOR) {
                if (decimalPos >= 0) {
                  _throwSyntaxError(pattern);
                }
                decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;
              } else if (_regionMatches(pattern, pos, _EXPONENT)) {
                if (useExponentialNotation) {
                  _throwSyntaxError(pattern);
                }
                useExponentialNotation = true;
                minExponentDigits = 0;
                pos += _EXPONENT.length;
                while (pos < pattern.length && pattern.charAt(pos) === _ZERO_DIGIT) {
                  minExponentDigits += 1;
                  phaseOneLength += 1;
                  pos += 1;
                }

                if (digitLeftCount + zeroDigitCount < 1 || minExponentDigits < 1) {
                  _throwSyntaxError(pattern);
                }
                phase = 2;
                isPrefix = false;
                pos -= 1;
                continue;
              } else {
                phase = 2;
                isPrefix = false;
                pos -= 1;
                phaseOneLength -= 1;
                continue;
              }
              break;
            default:
              break;
          }
        }
        /* eslint-enable no-continue */

        if (zeroDigitCount === 0 && digitLeftCount > 0 && decimalPos >= 0) {
          // Handle "###.###" and "###." and ".###"
          var n = decimalPos;
          if (n === 0) {
            // Handle ".###"
            n += 1;
          }
          digitRightCount = digitLeftCount - n;
          digitLeftCount = n - 1;
          zeroDigitCount = 1;
        }

        // Do syntax checking on the digits.
        if (
          (decimalPos < 0 && digitRightCount > 0) ||
          (decimalPos >= 0 &&
            (decimalPos < digitLeftCount || decimalPos > digitLeftCount + zeroDigitCount)) ||
          groupingCount === 0 ||
          inQuote
        ) {
          _throwSyntaxError(pattern);
        }

        if (j === 1) {
          posPrefixPattern = prefix;
          posSuffixPattern = suffix;
          negPrefixPattern = posPrefixPattern;
          negSuffixPattern = posSuffixPattern;
          var digitTotalCount = digitLeftCount + zeroDigitCount + digitRightCount;
          // The effectiveDecimalPos is the position the decimal is at or
          // would be at if there is no decimal. Note that if decimalPos<0,
          // then digitTotalCount == digitLeftCount + zeroDigitCount.
          var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : digitTotalCount;
          numberSettings.minimumIntegerDigits = effectiveDecimalPos - digitLeftCount;
          numberSettings.maximumIntegerDigits = useExponentialNotation
            ? digitLeftCount + numberSettings.minimumIntegerDigits
            : _MAXIMUM_INTEGER_DIGITS;
          numberSettings.maximumFractionDigits = decimalPos >= 0 ? digitTotalCount - decimalPos : 0;
          numberSettings.minimumFractionDigits =
            decimalPos >= 0 ? digitLeftCount + zeroDigitCount - decimalPos : 0;
          numberSettings.groupingSize = groupingCount > 0 ? groupingCount : 0;
          numberSettings.groupingSize0 = groupingCount0;
        } else {
          negPrefixPattern = prefix;
          negSuffixPattern = suffix;
          gotNegative = true;
        }
      }

      if (pattern.length === 0) {
        posPrefixPattern = '';
        posSuffixPattern = '';
        numberSettings.minimumIntegerDigits = 0;
        numberSettings.maximumIntegerDigits = _MAXIMUM_INTEGER_DIGITS;
        numberSettings.minimumFractionDigits = 0;
        numberSettings.maximumFractionDigits = _MAXIMUM_FRACTION_DIGITS;
      }
      numberSettings.useExponentialNotation = useExponentialNotation;
      numberSettings.minExponentDigits = minExponentDigits;
      // If there was no negative pattern, or if the negative pattern is
      // identical to the positive pattern, then prepend the minus sign to
      // the positive pattern to form the negative pattern.
      if (
        !gotNegative ||
        (negPrefixPattern.localeCompare(posPrefixPattern) === 0 &&
          negSuffixPattern.localeCompare(posSuffixPattern) === 0)
      ) {
        if (numberSettings.style === 'currency' && numberSettings.lang === 'ar') {
          negSuffixPattern = posSuffixPattern + "'\u200f-";
          negPrefixPattern = posPrefixPattern;
        } else {
          negSuffixPattern = posSuffixPattern;
          negPrefixPattern = "'-" + posPrefixPattern;
        }
      }
      _expandAffixes(localeElements, numberSettings);
    }

    function _getRoundedNumber(ret, numberSettings, options) {
      var precision = numberSettings.maximumFractionDigits;
      var isNegative = ret < 0;
      var mode = options.roundingMode || 'DEFAULT';
      var roundedNumber = _roundNumber(ret, precision, mode);
      return isNegative ? -roundedNumber : roundedNumber;
    }

    function _resolveNumberSettings(localeElements, options, locale) {
      var numberSettings = {};
      _validateNumberOptions(options, 'OraNumberConverter.resolvedOptions');
      _getNumberSettings(localeElements, numberSettings, options, locale);
      numberSettings.numberingSystemKey = _getNumberingExtension(locale);
      if (
        __ConverterUtilsI18n.OraI18nUtils.numeringSystems[numberSettings.numberingSystemKey] ===
        undefined
      ) {
        numberSettings.numberingSystemKey = 'latn';
      }
      return numberSettings;
    }

    function _resolveOptions(numberSettings, options, locale) {
      var resOptions = {
        locale: locale,
        style: numberSettings.style === undefined ? 'decimal' : numberSettings.style,
        useGrouping: options.useGrouping === undefined ? true : options.useGrouping,
        numberingSystem: numberSettings.numberingSystemKey
      };
      resOptions.minimumIntegerDigits = numberSettings.minimumIntegerDigits;
      resOptions.minimumFractionDigits = numberSettings.minimumFractionDigits;
      resOptions.maximumFractionDigits = numberSettings.maximumFractionDigits;
      if (numberSettings.style === 'decimal' && options.decimalFormat !== undefined) {
        resOptions.decimalFormat = options.decimalFormat;
      }
      if (numberSettings.style === 'currency' && options.currencyFormat !== undefined) {
        resOptions.currencyFormat = options.currencyFormat;
      }
      if (numberSettings.style === 'currency') {
        resOptions.currency = options.currency;
        resOptions.currencyDisplay =
          options.currencyDisplay === undefined ? 'symbol' : options.currencyDisplay;
      }
      if (options.unit !== undefined) {
        resOptions.unit = options.unit;
      }
      if (options.pattern !== undefined) {
        resOptions.pattern = options.pattern;
      }
      var roundingMode = options.roundingMode;
      var roundDuringParse = options.roundDuringParse;
      if (roundingMode !== undefined) {
        resOptions.roundingMode = roundingMode;
      }
      if (roundDuringParse !== undefined) {
        resOptions.roundDuringParse = roundDuringParse;
      }
      var leneint = numberSettings.lenientParse;
      if (leneint !== undefined) {
        resOptions.lenientParse = leneint;
      }
      var sep = numberSettings.separators;
      if (sep !== undefined) {
        resOptions.separators = sep;
      }
      resOptions.virtualKeyboardHint = _getVirtualKeyboardHint(numberSettings, options);
      return resOptions;
    }

    /*
     * Checks through the converter options.
     * Based on the options the appropriate virtualKeyboardHint is returned.
     * @return {string} virtual keyboard hint type - 'number' or 'text'
     */
    function _getVirtualKeyboardHint(numberSettings, options) {
      var virtualKeyboardHint = 'text';
      var converterStyle = options.style;
      switch (converterStyle) {
        case 'unit':
          virtualKeyboardHint = 'text';
          break;

        case 'currency':
        case 'percent':
          if (options.pattern === undefined) {
            virtualKeyboardHint = 'text';
          } else {
            virtualKeyboardHint = _parsePatternOption(numberSettings, options);
          }
          break;

        default:
          if (options.pattern === undefined) {
            if (options.decimalFormat === 'short' || options.decimalFormat === 'long') {
              virtualKeyboardHint = 'text';
            } else {
              virtualKeyboardHint = _parseUseGrouping(numberSettings, options);
            }
          } else {
            virtualKeyboardHint = _parsePatternOption(numberSettings, options);
          }
          break;
      }

      return virtualKeyboardHint;
    }

    /*
     * Based on converter's options.useGrouping the virtualKeyboardHint is decided.
     * @return {string} virtualKeyboardHint value
     */
    function _parseUseGrouping(numberSettings, options) {
      if (options.useGrouping === undefined || options.useGrouping) {
        if (numberSettings.decimalSeparator === '.' && numberSettings.groupingSeparator === '') {
          return 'number';
        }
      } else if (numberSettings.decimalSeparator === '.') {
        return 'number';
      }
      return 'text';
    }

    /*
     * Based on converter's options.pattern the virtualKeyboardHint is decided.
     * @return {string} virtualKeyboardHint value
     */
    function _parsePatternOption(numberSettings, options) {
      var patternHasNonNumericChar = _checkPatternForNonNumericChar(options.pattern);
      if (patternHasNonNumericChar) {
        return 'text';
      }

      var patternHasGroupSeparator = _checkPatternForGroupSeparator(options.pattern);
      var patternHasDecimalSeparator = _checkPatternForDecimalSeparator(options.pattern);

      if (patternHasGroupSeparator && patternHasDecimalSeparator) {
        if (numberSettings.groupingSeparator !== '' || numberSettings.decimalSeparator !== '.') {
          return 'text';
        } else if (numberSettings.groupingSeparator === numberSettings.decimalSeparator) {
          return 'text';
        }
      }

      if (patternHasDecimalSeparator && !patternHasGroupSeparator) {
        if (numberSettings.decimalSeparator !== '.') {
          return 'text';
        }
      }

      if (!patternHasDecimalSeparator && patternHasGroupSeparator) {
        if (numberSettings.groupingSeparator !== '') {
          return 'text';
        }
      }
      return 'number';
    }

    /*
     * Checks if the converter's options.pattern has non-numeric characters
     * that cannot be rendered by input type 'number'.
     * @return {boolean} indicates whether pattern has non-numeric characters or not.
     */

    function _checkPatternForNonNumericChar(pattern) {
      var nonNumericPattern = /[^0-9.#]/i;
      return nonNumericPattern.test(pattern);
    }

    /*
     * Checks if the converter's options.pattern has group separator symbol
     * that cannot be rendered by input type 'number'.
     * @return {boolean} indicates whether pattern has group separator symbol or not.
     */
    function _checkPatternForGroupSeparator(pattern) {
      if (pattern.indexOf(',') !== -1) {
        return true;
      }
      return false;
    }

    /*
     * Checks if the converter's options.pattern has decimal separator symbol
     * that cannot be rendered by input type 'number'.
     * @return {boolean} indicates whether pattern has
     *  decimal separator symbol or not.
     */
    function _checkPatternForDecimalSeparator(pattern) {
      if (pattern.indexOf('.') !== -1) {
        return true;
      }
      return false;
    }

    function _init() {
      return {
        /**
         * Format a number.
         * @memberof OraNumberConverter
         * @param {number} value - Number object to be formatted.
         * @param {Object} localeElements - the instance of LocaleElements
         * bundle
         * @param {Object=} options - Containing the following properties:<br>
         * - <b>style.</b>  is one of the String values "decimal", "currency",
         * "percent" or "unit". The default is "decimal".<br>
         * - <b>decimalFormat.</b> is used in conjuction with "decimal" style.
         * It can have one of the string values "short", "long", "standard". "standard"
         * is the default. It is used for compact number formatting. For example 3000 is displayed
         *  as 3K for "short" and 3 thousand for "long". We take into consideration
         *  the locale's plural rules for the compact pattern.<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory
         *  when style is "currency".<br>
         * - <b>unit.</b> Mandatory when style is "unit". Allowed values are "byte" or "bit".<br>
         * - <b>currencyFormat.</b> is used in conjuction with "currency" style.
         * It can have one of the string values "short", "long", "standard". "standard"
         * is the default. It is used for compact currency formatting. For example $3000 is displayed
         *  as $3K for "short" and 3 thousand US Dollar for "long".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code",
         * "symbol", or "name", specifying whether to display the currency as
         * an ISO 4217 alphabetic currency code,
         * a localized currency symbol, or a localized currency name if
         * formatting with the "currency" style. It is only present when style
         * has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value
         * indicating the minimum integer digits to be used. Numbers will be
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value
         * indicating the minimum fraction digits to be used. Numbers will be
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value
         * indicating the maximum fraction digits to be used. Numbers will be
         * rounded if necessary.<br>
         * - <b>roundingMode.</b> specifies the rounding behavior. This follows the
         *  Java.Math.RoundingMode behavior. Currently we support the options :
         *  HALF_UP, HALF_DOWN, and HALF_EVEN<br>
         * - <b>useGrouping.</b> is a Boolean value indicating whether a
         * grouping separator should be used. The default is true.<br>
         * - <b>separators.</b> - An object with 2 fields: 'decimal' and 'group'.
         * It allows the user to override the locale's default decimal and grouping separators.<br>
         * - <b>pattern.</b> custom pattern. Will override above options
         * when present.
         * @param {string=} locale - A BCP47 compliant language tag. it is only
         * used to extract the unicode extension keys.
         * @return {string} formatted number.
         * @throws {RangeError} If a property value of the options parameter is
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is
         * missing.
         * @throws {SyntaxError} If an unexpected character is encountered in
         * the pattern.
         */
        format: function (value, localeElements, options, locale) {
          if (arguments.length <= 2 || options === undefined) {
            // eslint-disable-next-line no-param-reassign
            options = {
              useGrouping: true,
              style: 'decimal'
            };
          }
          _validateNumberOptions(options, 'OraNumberConverter.format');
          var numberSettings = {};
          _getNumberSettings(localeElements, numberSettings, options, locale);
          return _formatNumberImpl(value, options, localeElements, numberSettings, locale);
        },
        /**
         * Parse a number.
         * @memberof OraNumberConverter
         * @param {string|number} str - string to be parsed.
         * @param {Object} localeElements - the instance of LocaleElements
         * bundle
         * @param {Object=} options - Containing the following properties:<br>
         * - <b>style.</b>  is one of the String values "decimal", "currency" or
         * "percent". The default is "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory
         * when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code",
         * "symbol", or "name", specifying whether to display the currency as
         * an ISO 4217 alphabetic currency code,
         *  a localized currency symbol, or a localized currency name if
         *  formatting with the "currency" style. It is only considered when
         *  style has the value "currency". The default is "symbol".<br>
         * - <b>pattern.</b> custom pattern. Will override above options when
         * present.<br>
         * - <b>roundingMode.</b> specifies the rounding behavior. This follows the
         *  Java.Math.RoundingMode behavior. Currently we support the options :
         *  HALF_UP, HALF_DOWN, and HALF_EVEN<br>
         *  - <b>roundDuringParse.</b> Boolean value. Specifies whether or not to round during parse.
         *  by default the number converter rounds during format but not during parse.<br>
         *  - <b>separators.</b> - An object with 2 fields: 'decimal' and 'group'.
         * It allows the user to override the locale's default decimal and grouping separators.<br>
         *  - <b>lenientParse.</b> specifies if lenient parse is enabled or disabled. Allowed values: "full", "none".
         *  default is "full" which means lenient parse is enabled.<br>
         * @param {string=} locale - A BCP47 compliant language tag. it is only
         * used to extract the unicode extension keys.
         * @return {number} a number object parsed from the string. In case of
         * error, returns null.
         * @throws {RangeError} If a property value of the options parameter is
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is
         * missing.
         * @throws {SyntaxError} If an unexpected character is encountered in
         * the pattern.
         * @throws {Error} If the <i>str</i> parameter does not match the number
         * pattern.
         */
        parse: function (str, localeElements, options, locale) {
          if (typeof str === 'number') {
            return str;
          }
          if (Object.prototype.toString.call(str) === '[object Number]') {
            return Number(str);
          }
          if (arguments.length <= 2 || options === undefined) {
            // eslint-disable-next-line no-param-reassign
            options = {
              useGrouping: true,
              style: 'decimal'
            };
          }
          _validateNumberOptions(options, 'OraNumberConverter.parse');
          return _parseNumberImpl(str, localeElements, options, locale);
        },
        /**
         * Resolve options.
         * Returns a new object with properties reflecting the number formatting
         * options computed based on the options parameter.
         * If options is not provided, the properties will be derived from the
         * locale defaults.
         * @memberof OraNumberConverter
         * @param {Object} localeElements - the instance of LocaleElements
         * bundle
         * @param {Object=} options containing the following properties:<br>
         * - <b>style.</b> "decimal", "currency", "percent" or "unit". The default is
         * "decimal".<br>
         * - <b>unit.</b> one of the strings "byte" or "bit" when the style is "unit".<br>
         * - <b>decimalFormat.</b> It can have one of the string values "short", "long", "standard".
         * "standard" is the default. It is used for compact number formatting. For example 3000 is displayed
         *  as 3K for "short" and 3 thousand for "long". We take into consideration
         *  the locale's plural rules for the compact pattern.<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory
         * when when style is "currency".<br>
         * - <b>currencyFormat.</b> is used in conjuction with "currency" style.
         * It can have one of the string values "short", "long", "standard". "standard"
         * is the default. It is used for compact currency formatting. For example $3000 is displayed
         *  as $3K for "short" and 3 thousand US Dollar for "long".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code",
         * "symbol", or "name", specifying whether to display the currency as
         * an ISO 4217 alphabetic currency code,
         *   a localized currency symbol, or a localized currency name if
         *   formatting with the "currency" style. It is only present
         *   when style has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value
         * indicating the minimum integer digits to be used. Numbers will be
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value
         * indicating the minimum fraction digits to be used. Numbers will be
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value
         * indicating the maximum fraction digits to be used. Numbers will be
         * rounded if necessary.<br>
         * - <b>numberingSystem</b>. The numbering system.<br>
         * - <b>useGrouping.</b> is a Boolean value indicating whether a
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options when
         * present.<br>
         * - <b>roundingMode.</b> specifies the rounding behavior. This follows the
         *  Java.Math.RoundingMode behavior. Currently we support the options :
         *  HALF_UP, HALF_DOWN, and HALF_EVEN<br>
         *  - <b>roundDuringParse.</b> Boolean value. Specifies whether or not to round during parse.
         *  by default the number converter rounds during format but not during parse.<br>
         *  - <b>separators.</b> - An object with 2 fields: 'decimal' and 'group'.
         * It allows the user to override the locale's default decimal and grouping separators.<br>
         *  - <b>lenientParse.</b> specifies if lenient parse is enabled or disabled. Allowed values: "full", "none".
         * default is "full" which means lenient parse is enabled.<br>
         * @param {string=} locale - A BCP47 compliant language tag. it is only
         * used to extract the unicode extension keys.
         * @return {Object} Resolved options object.
         * @throws {RangeError} If a property value of the options parameter is
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is
         * missing.
         */
        resolvedOptions: function (localeElements, options, locale) {
          if (arguments.length < 3 || locale === undefined) {
            // eslint-disable-next-line no-param-reassign
            locale = __ConverterUtilsI18n.OraI18nUtils.getLocaleElementsMainNodeKey(localeElements);
          }
          if (arguments.length < 2 || options === undefined) {
            // eslint-disable-next-line no-param-reassign
            options = {
              useGrouping: true,
              style: 'decimal'
            };
          }
          var numberSettings = _resolveNumberSettings(localeElements, options, locale);
          return _resolveOptions(numberSettings, options, locale);
        }
      };
    }

    return {
      /**
       * getInstance.
       * Returns the singleton instance of OraNumberConverter class.
       * @memberof OraNumberConverter
       * @return {Object} The singleton OraNumberConverter instance.
       */
      getInstance: function () {
        if (!instance) {
          instance = _init();
        }
        return instance;
      }
    };
  })();

  /**
   * oj.NumberConverter Contract.
   * @ignore
   */

  /**
   * @class
   * @name oj.NumberConverter
   * @constructor
   * @hideconstructor
   * @abstract
   * @augments oj.Converter
   * @ojsignature {target: "Type",
   *                value: "abstract class NumberConverter implements Converter<number>"}
   *
   * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
   * @export
   * @since 0.6.0
   * @see oj.IntlNumberConverter JET's implementation of the NumberConverter
   */
  const NumberConverter = function () {
    this.Init();
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(NumberConverter, Converter, 'oj.NumberConverter');

  /**
   * Initializes the number converter instance with the set options.
   * @param {Object=} options an object literal used to provide an optional information to
   * initialize the converter.<p>
   * @export
   * @ignore
   */
  NumberConverter.prototype.Init = function (options) {
    NumberConverter.superclass.Init.call(this, options);
  };

  /**
   * Formats the Number value using the options provided and returs a String value.
   *
   * @param {number} value the value to be formatted for display
   * @return {(string|null)} the localized and formatted value suitable for display
   * @throws {Error} a ConverterError if formatting fails.
   * @export
   * @memberof oj.NumberConverter
   * @instance
   * @method format
   */
  NumberConverter.prototype.format = function (value) {
    return NumberConverter.superclass.format.call(this, value);
  };

  /**
   * Parses the value using the options provided and returns a Number object.
   *
   * @param {string} value to parse
   * @return {number|null} the parsed value as a Number object.
   * @throws {Error} a ConverterError if parsing fails
   * @export
   * @memberof oj.NumberConverter
   * @instance
   * @method parse
   */
  NumberConverter.prototype.parse = function (value) {
    return NumberConverter.superclass.parse.call(this, value);
  };

  /**
   * @export
   * Placeholder here as closure compiler objects to export annotation outside of top level
   */

  /**
   * @constructor
   * @final
   * @name oj.IntlNumberConverter
   * @classdesc Constructs an immutable instance and initializes it with the options provided. When initialized
   * with no options, the default options for the current locale are assumed. The converters by
   * default use the current page locale (set with the html lang attribute and what is returned by oj.Config.getLocale()).
   * There are several ways to initialize the converter.
   * <p>
   * <ul>
   * <li>Using options defined by the ECMA 402 Specification, these would be the properties style,
   * currency, currencyDisplay, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits,
   * useGrouping. NOTE: minimumSignificantDigits and maximumSignificantDigits are not supported.</li>
   * <li>Using the decimalFormat option to define a locale-based pattern, e.g.,
   *  a compact pattern, such as "1M" and "1 million".</li>
   * <li>Using the currencyFormat option to define a locale-based pattern, e.g.,
   * a compact pattern, such as "$1M" and "$1 million".</li>
   * <li>Using the roundingMode and roundDuringParse options to round the number UP, DOWN, CEILING, FLOOR, HALF_UP, HALF_DOWN or HALF_EVEN.</li>
   * <li>Using a custom decimal, currency or percent format pattern. specified using the 'pattern' property. (deprecated)</li>
   * </ul>
   * <p>
   *
   * The converter provides leniency when parsing user input value to a number in the following ways:<br/>
   *
   * <ul>
   * <li>Prefix and suffix that do not match the pattern, are removed. E.g., when the options are
   * {style: "percent"} (suffix is the % character), a value of "abc-123.45xyz", will be leniently parsed as
   * if the value was -123.45 to
   * -123%</li>
   * <li>When a value includes a symbol but the pattern doesn't require it.  E.g., the options are
   * {pattern: "###", currency: 'USD'}, then values ($123), (123) and -123 will be leniently parsed as
   * -123.</li>
   * </ul>
   * <p>
   * Lenient parse can be disabled by setting the property lenientParse to "none". In which case the user input must
   * be an exact match of the expected pattern and all the leniency described above will be disabled.
   * <p>
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>
   * Please be aware that newer converters are available and IntlNumberConverter will be deprecated in the future.
   * See the docs for <a href="BigDecimalStringConverter.html" target="_blank">BigDecimalStringConverter</a> and
   * <a href="NumberConverter.html" target="_blank">NumberConverter</a> for more details.
   * </p>
   * @param {Object=} options - an object literal used to provide optional information to
   * initialize the converter.
   *
   * @example <caption>Create a number converter for currencies</caption>
   * var options = {style: "currency", currency: "USD", minimumIntegerDigits: 2};
   * converter = new IntlNumberConverter(options);
   * converter.format(9); --> "$09.00" if page locale is 'en-US'
   * converter.format(9); --> "09,00 $US" if page locale is 'fr-FR'<br/>
   *
   * @example <caption>A number converter for percent values using a custom (CLDR) pattern</caption>
   * var options = {pattern: '#,##0%'};
   * converter = new IntlNumberConverter(options);<br/>
   *
   * @example <caption>To parse a value as percent but format it without displaying the percent character</caption>
   * var options = {style: 'percent', pattern: '#,##0'};<br/>
   *
   * @example <caption>To parse a value as currency using a custom (CLDR) pattern</caption>
   * var options = {pattern: '¤#,##0', currency: 'USD'};
   *
   * @example <caption>To format a value as digital bit unit</caption>
   * var options = {style:'unit', unit:'bit'};
   * converter = new IntlNumberConverter(options);
   * var nb = 1024;
   * converter.format(nb, localeElements, options);--> 1Kb<br/>
   *
   * @example <caption>To format a value as digital byte unit</caption>
   * var options = {style:'unit', unit:'byte'};
   * converter = new IntlNumberConverter(options);
   * var nb = 1024;
   * converter.format(nb, localeElements, options);--> 1KB<br/>
   *
   * @example <caption>The following decimalFormat examples are in en locale.
   * To format a value as short (default for fraction digits is based on the locale)</caption>
   * var options = {style:'decimal', decimalFormat:'short'};
   * converter = new IntlNumberConverter(options);
   * converter.format(12345);--> 12.354K<br/>
   *
   * @example <caption>Same as above for currencyFormat.
   * To format a value as short (default for fraction digits is based on the locale)</caption>
   * var options = {style:'currency', currency: 'USD', currencyFormat:'short'};
   * converter = new IntlNumberConverter(options);
   * converter.format(1234);--> $1.23K<br/>
   *
   * @example <caption>To format a value as long (default for fraction digits is based on the locale):</caption>
   * var options = {style:'decimal', decimalFormat:'long'};
   * converter = new IntlNumberConverter(options);
   * converter.format(12345);--> 12.345 thousand<br/>
   *
   * @example <caption>To format a value as long currency format:</caption>
   * var options = {style:'currency',  currency: 'USD', currencyFormat:'long'};
   * converter = new IntlNumberConverter(options);
   * converter.format(1234);--> $1.23 thousand<br/>
   *
   * @example <caption>To format a value as short with minimum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'short',
   * minimumFractionDigits:4};
   * converter = new IntlNumberConverter(options);
   * converter.format(1234);--> 1.2340K<br/>
   *
   * @example <caption>To format a value as short with maximum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'short',
   * maximumFractionDigits:0};
   * converter = new IntlNumberConverter(options);
   * converter.format(12345);--> 12K<br/>
   *
   * @example <caption>To format a value as long with minimum and maximum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'long',
   * minimumFractionDigits:2, maximumFractionDigits:4};
   * converter = new IntlNumberConverter(options);
   * converter.format(12000);--> 12.00 thousand<br/>
   *
   * @example <caption>To format a value as short with minimum and maximum fraction digits:</caption>
   * options = { style:'decimal', decimalFormat:'long',
   * minimumFractionDigits:2, maximumFractionDigits:4};
   * converter = new IntlNumberConverter(options);
   * converter.format(12345678);--> 12.345 million<br/>
   *
   * @example <caption>decimal style default is standard:</caption>
   * options = { style:'decimal', decimalFormat:'standard'};
   * converter = new IntlNumberConverter(options);
   * converter.format(12345);--> 12,345<br/>
   *
   * @example <caption>decimal round UP:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'UP'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.221);--> 0.23
   * converter.parse(0.221);-->0.221 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round DOWN:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'DOWN'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.229);--> 0.22
   * converter.parse(0.229);-->0.229 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round CEILING:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'CEILING'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.221);--> 0.23
   * converter.parse(0.221);-->0.221 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round FLOOR:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'FLOOR'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.229);--> 0.22
   * converter.parse(0.229);-->0.229 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round HALF_DOWN:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'HALF_DOWN'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.225);--> 0.22
   * converter.parse(0.225);-->0.225 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round HALF_UP:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'HALF_UP'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.225);--> 0.23
   * converter.parse(0.225);--> 0.225 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round HALF_EVEN:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2, roundingMode:'HALF_EVEN'};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.225);--> 0.22
   * converter.format(0.235);--> 0.24
   * converter.parse(0.225);--> 0.225 //doesn't round during parse by default
   * converter.parse(0.235);--> 0.235 //doesn't round during parse by default<br/>
   *
   * @example <caption>decimal round UP and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'UP', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.221);--> 0.23
   * converter.parse(0.221);-->0.23<br/>
   *
   * @example <caption>decimal round DOWN and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'DOWN', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.229);--> 0.22
   * converter.parse(0.229);-->0.22<br/>
   *
   * @example <caption>decimal round CEILING and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'CEILING', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.221);--> 0.23
   * converter.parse(0.221);-->0.23<br/>
   *
   * @example <caption>decimal round FLOOR and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'FLOOR', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.229);--> 0.22
   * converter.parse(0.229);-->0.22<br/>
   *
   * @example <caption>decimal round HALF_DOWN and roundDuringParse:</caption>
   * options = { style:'decimal', maximumFractionDigits:2,
   *             roundingMode:'HALF_DOWN', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.225);--> 0.22
   * converter.parse(0.225);-->0.22<br/>
   *
   * @example <caption>decimal round HALF_UP and roundDuringParse:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2,
   *             roundingMode:'HALF_UP', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.225);--> 0.23
   * converter.parse(0.225);--> 0.23<br/>
   *
   * @example <caption>decimal round HALF_EVEN and roundDuringParse:</caption>
   * options = { style:'decimal',  maximumFractionDigits:2,
   *             roundingMode:'HALF_EVEN', roundDuringParse: true};
   * converter = new IntlNumberConverter(options);
   * converter.format(0.225);--> 0.22
   * converter.format(0.235);--> 0.24
   * converter.parse(0.225);--> 0.22
   * converter.parse(0.235);--> 0.24<br/>
   *
   * @example <caption>Use custom decimal and grouping separators:</caption>
   * options = { style:'decimal', separators: {decimal: ',',  group: '.'}};
   * converter = new IntlNumberConverter(options);
   * var nb = 1234567.89;
   * converter.format(nb);--> 1.234.567,89
   * converter.parse("1.234.567,89");--> 1234567.89
   * <br/>
   *
   * @example <caption>Disable lenient parse:</caption>
   * options = { style:'decimal',  lenientParse: 'none'};
   * converter = new IntlNumberConverter(options);
   * converter.parse("abc-123.45xyz");--> Error: Unparsable number abc-123.45xyz The expected number pattern is #,##0.###
   * <br/>
   *
   * @export
   * @augments oj.NumberConverter
   * @name oj.IntlNumberConverter
   * @ojsignature [{target: "Type",
   *                value: "class IntlNumberConverter extends NumberConverter"},
   *               {target: "Type",
   *                value: "oj.IntlNumberConverter.ConverterOptions",
   *                for: "options", jsdocOverride: true}
   *              ]
   * @since 0.6.0
   */
  const IntlNumberConverter = function (options) {
    const mo = ojconverterPreferences.getMergedNumberPreferencesWithOptions(options);
    this.Init(mo);
  };

  /**
   * @typedef {object} oj.IntlNumberConverter.Separators
   * @property {string=} decimal - Allows the user to provide custom decimal separators.
   * <br/>Example: { style:'decimal', separators: {decimal: ',',  group: '.'}};
   * @property {string=} group - Allows the user to provide custom group separators.
   * <br/>Example: { style:'decimal', separators: {decimal: ',',  group: '.'}};
   */

  /**
   * @typedef {object} oj.IntlNumberConverter.ConverterOptions
   * @property {('decimal'|'currency'|'percent'|'unit')=} style - sets the style of number formatting. Allowed values are "decimal"
   * (the default), "currency", "percent" or "unit". When a number is formatted as a decimal, the decimal
   * character is replaced with the most appropriate symbol for the locale. In English this is a
   * decimal point ("."), while in many locales it is a decimal comma (","). If grouping is enabled the
   * locale dependent grouping separator is also used. These symbols are also used for numbers
   * formatted as currency or a percentage, where appropriate.
   * @property {string=} currency - specifies the currency that will be used when formatting the
   * number. The value should be a ISO 4217 alphabetic currency code. If the style is set to currency,
   * it's required that the currency property also be specified. This is because there is no default
   * currency associated with the current locale. The user must always specify the currency code
   * to be shown, otherwise an error will be thrown. The current page locale
   * (returned by oj.Config.getLocale()) determines the formatting elements of the number
   * like grouping separator and decimal separator. The currency code tells us which currency to
   * display in current page locale. JET has translations for currency names.
   * <p>
   * As an example if we want to format 1000.35 EURO and the page locale is "en-US",
   * we pass {style:'currency', currency:'EUR', currencyDisplay:'symbol'} and we will get "€1,000.35"
   * If the page locale is "fr-FR", with the same options, we will get: "1 000,35 €"
   * </p>
   * @property {('byte'|'bit')=} unit - Mandatory when style is "unit". Allowed values:
   * "byte" or "bit". It is used for formatting only. It can not be used for parsing.
   * <p>
   * It is used to format digital units like 10Mb for bit unit or 10MB for byte unit.
   * There is no need to specify the scale of the unit. We automatically detect it.
   * For example 1024 is formatted as 1KB and ?1048576? as 1MB.
   * The user can also specify 'minimumFractionDigits' and  'maximumFractionDigits' to be displayed,
   * otherwise we use the locale's default max and min fraction digits.
   * </p>
   * @property {('code'|'symbol'|'name')=} currencyDisplay - if the number is using currency formatting, specifies
   * if the currency will be displayed using its "code" (as an ISO 4217 alphabetic currency code),
   * "symbol" (a localized currency symbol (e.g. $ for US dollars, £ for Great British pounds, and so
   * on), or "name" (a localized currency name. Allowed values are "code", "symbol" and "name".
   * The default is "symbol".
   * @property {('standard'|'short'|'long')=} decimalFormat -
   * specifies the decimal format length to use when style is set to "decimal".
   * Allowed values are : "standard"(default), "short" and "long". 'standard' is equivalent to not
   * specifying the 'decimalFormat' attribute, in that case the locale’s default decimal pattern
   * is used for formatting.
   * <p>
   * The user can also specify 'minimumFractionDigits' and  'maximumFractionDigits' to display.
   * When not present we use the locale's default max and min fraction digits.
   * </p>
   * <p>
   * There is no need to specify the scale; we automatically detect greatest scale that is less or
   * equal than the input number. For example  1000000 is formatted as "1M" or "1 million" and
   * 1234 is formatted, with zero fractional digits, as "1K" or " 1 thousand" for
   * short and long formats respectively. The pattern for the short and long number is locale dependent
   * and uses plural rules for the particular locale.
   * </p>
   * <p>
   * NOTE: Currently this option formats a value (e.g., 2000 -> 2K), but it does not parse a value
   * (e.g., 2K -> 2000), so it can only be used
   * in a readOnly EditableValue because readOnly EditableValue components do not call
   * the converter's parse function.
   * </p>
   * @property {('standard'|'short'|'long')=} currencyFormat -
   * specifies the currency format length to use when style is set to "currency".
   * Allowed values are : "standard"(default), "short" and "long". 'standard' is equivalent to not
   * specifying the 'currencyFormat' attribute, in that case the locale's default currency pattern
   * is used for formatting.
   * Similar to decimalFormat, currencyFormat can only be used for formatting. It can not be used for parsing.
   * <p>
   * The user can also specify 'minimumFractionDigits' and  'maximumFractionDigits' to display.
   * When not present we use the locale's default max and min fraction digits.
   * </p>
   * <p>
   * There is no need to specify the scale; we automatically detect greatest scale that is less or
   * equal than the input number. For example  1000000 is formatted as "$1M" or "1 million dollar" and
   * 1000 is formatted as "$1K" or " 1 thousand dollar" for short and long formats respectively.
   * The pattern for the short and long number is locale dependent and uses plural rules for the particular locale.
   * </p>
   * @property {number=} minimumIntegerDigits - sets the minimum number of digits before the
   * decimal place (known as integer digits). The number is padded with leading zeros if it would not
   * otherwise have enough digits. The value must be an integer between 1 and 21.
   * @property {number=} minimumFractionDigits - similar to 'minimumIntegerDigits', except it
   * deals with the digits after the decimal place (fractional digits). It must be an integer between
   * 0 and 20. The fractional digits will be padded with trailing zeros if they are less than the minimum.
   * @property {number=} maximumFractionDigits - follows the same rules as 'minimumFractionDigits',
   * but sets the maximum number of fractional digits that are allowed. The value will be rounded if
   * there are more digits than the maximum specified.
   * @property {boolean=} useGrouping - when the value is truthy, the locale dependent grouping
   * separator is used when formatting the number. This is often known as the thousands separator,
   * although it is up to the locale where it is placed. The ‘useGrouping’ is set to true by default.
   * @property {string=} pattern an optional localized pattern, where the characters used in
   * pattern are as defined in the Unicode CLDR for numbers, percent or currency formats. When present
   * this will override the other "options". <p>
   *
   * &nbsp;&nbsp;- When the pattern represents a currency style the 'currency' property is required to
   * be set, as not setting this will throw an error. The 'currencyDisplay' is optional. <br/>Example:
   * {pattern: '¤#,##0', currency: 'USD'}. <p>
   *
   * &nbsp;&nbsp;- It's not mandatory for the pattern to have the special character '¤' (currency sign)
   * be present. When not present, values are treated as a currency value, but are not formatted to
   * show the currency symbol. <br/>Example: {pattern: '#,##0', currency: 'USD'} <p>
   *
   * &nbsp;&nbsp;- When the pattern represents a percent style, the percent special character ('%') needs to be
   * explicitly specified in the pattern, e.g., {pattern: "#,##0%"}. If the pattern does not contain
   * the percent character it's treated as a decimal pattern, unless the style is set to percent,
   * in which case the value is treated as a percent value, but not formatted to show the percent symbol.
   * <br/>Example: {style: 'percent', pattern: "#,##0"}. <p>
   *
   * &nbsp;&nbsp;- A decimal pattern or exponent pattern is specified in the pattern using the CLDR
   * conventions. <br/>Example: {pattern: "#,##0.00"} or {pattern: "0.##E0"}. <p>
   *
   * NOTE: 'pattern' is provided for backwards compatibility with existing apps that may want the
   * convenience of specifying an explicit format mask. Setting a pattern will override the default
   * locale specific format. <br/>
   * @ojdeprecated {target: 'property', for:'pattern', since: '11.0.0', description: 'Use other options instead like style'}
   *
   * @property {('HALF_UP'|'HALF_DOWN'|'HALF_EVEN'|'UP'|'DOWN'|'CEILING'|'FLOOR')=} roundingMode - specifies the rounding behavior.
   * This follows the Java.Math.RoundingMode behavior. https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html
   *
   * @property {boolean=} roundDuringParse - Specifies whether or not to round during
   * parse. Defaults to false; the number converter rounds during format but not during parse.
   *
   * @property {oj.IntlNumberConverter.Separators=} separators - An object with 2 fields: 'decimal' and 'group'.
   * It allows the user to provide custom decimal and grouping separators. It is accepted for both
   * format and parse methods.
   * <br/>
   *
   * @property {('full'|'none')=} lenientParse - The lenientParse property can be used to enable or disable leninet parsing.
   *  Allowed values: "full" (default), "none".
   * <p style='padding-left: 5px;'>
   * By default the lenient parse is enabled and the leniency rules descibed above will be used. When lenientParse is
   * set to "none" the lenient parse is disabled and the user input must match the expected input otherwise an exception will
   * be thrown.<br/><br/>
   */
  oj$1.Object.createSubclass(IntlNumberConverter, NumberConverter, 'oj.IntlNumberConverter');

  /**
   * Initializes the number converter instance with the set options.
   * @param {Object=} options an object literal used to provide an optional information to
   * initialize the converter.<p>
   * @export
   * @ignore
   * @memberof oj.IntlNumberConverter
   */
  IntlNumberConverter.prototype.Init = function (options) {
    IntlNumberConverter.superclass.Init.call(this, options);
  };

  // Returns the wrapped number converter implementation object.
  // FA is overriding our ojs/ojconverter-datetime bundle and needs to define this function
  // or else they will get an error.
  // Do not rename. TODO: Ideally we will remove the need for them to have to define this function.
  IntlNumberConverter.prototype._getWrapped = function () {
    if (!this._wrapped) {
      this._wrapped = OraNumberConverter.getInstance();
    }

    return this._wrapped;
  };

  /**
   * Formats a Number and returns the formatted string, using the options this converter was
   * initialized with.
   *
   * @param {number} value to be formatted for display
   * @return {string} the localized and formatted value suitable for display. When the value is
   * formatted as a percent it's multiplied by 100.
   *
   * @throws {Error} a ConverterError both when formatting fails, or if the options provided during
   * initialization cannot be resolved correctly.
   * @memberof oj.IntlNumberConverter
   * @export
   * @instance
   * @method format
   */
  IntlNumberConverter.prototype.format = function (value) {
    // undefined, null and empty string values all return null. If value is NaN then return "".
    if (
      value == null ||
      (typeof value === 'string' && oj$1.StringUtils.trim('' + value).length === 0) ||
      (typeof value === 'number' && isNaN(value))
    ) {
      return '';
    }

    var locale = Config.getLocale();
    var localeElements = LocaleData.__getBundle();
    var resolvedOptions = this.resolvedOptions();
    var converterError;
    var formatValue;

    try {
      formatValue = this._getWrapped().format(value, localeElements, resolvedOptions, locale);
    } catch (e) {
      converterError = this._processConverterError(e, value);
      throw converterError;
    }
    // The base converter returns NaN if the value is a string. This
    // is expected behavior and is also the same behavior of the
    // browser's Intl.NumberFormat. So this converter takes that and
    // logs an error. NOTE: it is
    // an application error if the value option is not a valid number.
    if (formatValue === 'NaN') {
      var summary = Translations.getTranslatedString(
        'oj-converter.number.invalidNumberFormat.summary',
        { value: value }
      );
      var detail = Translations.getTranslatedString('oj-converter.number.invalidNumberFormat.detail');
      Logger.error(summary + ' ' + detail);
    }
    return formatValue;
  };

  /**
   * In general, returns hint for the converter. For a IntlNumberConverter returned value is always null.
   *
   * @return {null} a hint describing the format the value is expected to be in.
   * @memberof oj.IntlNumberConverter
   * @export
   * @instance
   * @method getHint
   */
  IntlNumberConverter.prototype.getHint = function () {
    // UX does not want any hint for numbers.
    // return oj.Translations.getTranslatedString("oj-converter.hint.summary",
    //        {'exampleValue': this._getHintValue()});
    // return IntlNumberConverter.superclass.getHint.call(this); // this asserts, and we don't want that.
    return null;
  };

  /**
   * Returns the options called with converter initialization.
   * @return {Object} an object of options.
   * @ojsignature {target:"Type", for: "returns",
   *    value: "oj.IntlNumberConverter.ConverterOptions"}
   * @memberof oj.IntlNumberConverter
   * @export
   * @instance
   * @method getOptions
   * @ojdeprecated {since: '11.0.0', description: 'Use resolvedOptions.'}
   */
  IntlNumberConverter.prototype.getOptions = function () {
    return IntlNumberConverter.superclass.getOptions.call(this);
  };

  /**
   * Parses a string value to return a Number, using the options this converter was initialized with.
   *
   * @param {string} value to parse
   * @return {number|null} the parsed number or null if the value was null or an empty string. When
   * the value is parsed as a percent its 1/100th part is returned.
   *
   * @throws {Error} a ConverterError both when parsing fails, or if the options provided during
   * initialization cannot be resolved correctly.
   * @memberof oj.IntlNumberConverter
   * @export
   * @instance
   * @method parse
   */
  IntlNumberConverter.prototype.parse = function (value) {
    var converterError;
    var locale;
    var localeElements;
    var resolvedOptions;

    // null and empty string values are ignored and not parsed. It
    // undefined.
    if (value == null || value === '') {
      // check for undefined, null and ""
      return null;
    }

    locale = Config.getLocale();
    localeElements = LocaleData.__getBundle();
    resolvedOptions = this.resolvedOptions();

    try {
      // we want to trim the value for leading spaces before and after
      return this._getWrapped().parse(
        oj$1.StringUtils.trim(value),
        localeElements,
        resolvedOptions,
        locale
      );
    } catch (e) {
      converterError = this._processConverterError(e, value);
      throw converterError;
    }
  };

  /**
   * Returns an object literal with properties reflecting the number formatting options computed based
   * on the options parameter. If options (or pattern) is not provided, the properties will be derived
   * from the locale defaults.
   *
   * @return {Object} An object literal containing the resolved values for the following options. Some
   * of these properties may not be present, indicating that the corresponding components will not be
   * represented in the formatted output.
   * <ul>
   * <li><b>locale</b>: a String value with the language tag of the locale whose localization is used
   * for formatting.</li>
   * <li><b>style</b>: a String value. One of the allowed values - "decimal", "currency" or "percent".</li>
   * <li><b>currency</b>: a String value.  an ISO 4217 alphabetic currency code. May be present only
   *  when style is currency.</li>
   * <li><b>currencyDisplay</b>: a String value. One of the allowed values - "code", "symbol", or
   *  "name".</li>
   * <li><b>numberingSystem</b>: a String value of the numbering system used. E.g. latn</li>
   * <li><b>minimumIntegerDigits</b>: a non-negative integer Number value indicating the minimum
   *  integer digits to be used.</li>
   * <li><b>minimumFractionDigits</b>: a non-negative integer Number value indicating the minimum
   *  fraction digits to be used.</li>
   * <li><b>maximumFractionDigits</b>: a non-negative integer Number value indicating the maximum
   *  fraction digits to be used.</li>
   * <li><b>useGrouping</b>: a Boolean value indicating whether a grouping separator is used.</li>
   * <li><b>lenientParse</b>: specifies if lenient parse is enabled or disabled. Allowed values: "full", "none".
   * default is "full" which means lenient parse is enabled.</li>
   * <li><b>separators</b>: - An object with 2 fields: 'decimal' and 'group'.</li>
   *
   * @throws a ConverterError when the options that the converter was initialized with are invalid.
   * @ojsignature {target:"Type", for: "returns",
   *    value: "oj.IntlNumberConverter.ConverterOptions"}
   * @memberof oj.IntlNumberConverter
   * @export
   * @instance
   * @method resolvedOptions
   */
  IntlNumberConverter.prototype.resolvedOptions = function () {
    var converterError;
    var locale = Config.getLocale();
    var localeElements;

    // options are resolved and cached for the current locale. when locale changes resolvedOptions
    // is reevaluated as it contains locale specific info.
    if (locale !== this._locale || !this._resolvedOptions) {
      // leave this line unchanged so that we can test that LocaleData can also be accessed from the oj namespace.
      localeElements = LocaleData.__getBundle();
      try {
        if (!localeElements) {
          Logger.error('locale bundle for the current locale %s is unavailable', locale);
          return {};
        }

        // cache if successfully resolved
        this._resolvedOptions = this._getWrapped().resolvedOptions(
          localeElements,
          this.getOptions(),
          locale
        );
        this._locale = locale;
      } catch (e) {
        converterError = this._processConverterError(e);
        throw converterError;
      }
    }

    return this._resolvedOptions;
  };

  /**
   * Processes the error returned by the converter implementation and throws a ConverterError
   * instance.
   *
   * FA is overriding our ojs/ojconverter-datetime bundle and needs to define this function
   * or else they will get an error.
   * Do not rename. TODO: Ideally we will remove the need for them to have to define this function.
   * @param {Error} e
   * @param {String|string|Number|number|Object=} value
   * @throws an instance of ConverterError
   * @private
   */
  IntlNumberConverter.prototype._processConverterError = function (e, value) {
    var converterError;
    var errorInfo = e.errorInfo;
    var detail;
    var resourceKey;
    var summary;

    if (errorInfo) {
      var errorCode = errorInfo.errorCode;
      var parameterMap = errorInfo.parameterMap;
      oj$1.Assert.assertObject(parameterMap);

      switch (errorCode) {
        case 'optionTypesMismatch':
        case 'optionTypeInvalid':
          converterError = __ConverterUtilsI18n.IntlConverterUtils.__getConverterOptionError(
            errorCode,
            parameterMap
          );
          break;
        case 'optionOutOfRange':
          converterError = __ConverterUtilsI18n.IntlConverterUtils.__getConverterOptionError(
            errorCode,
            parameterMap
          );
          break;
        case 'optionValueInvalid':
          converterError = __ConverterUtilsI18n.IntlConverterUtils.__getConverterOptionError(
            errorCode,
            parameterMap
          );
          break;
        case 'decimalFormatMismatch':
          // The '{value}' does not match the expected number format
          resourceKey = 'oj-converter.number.decimalFormatMismatch.summary';
          break;
        case 'currencyFormatMismatch':
          // The {value} does not match the expected currency format
          resourceKey = 'oj-converter.number.currencyFormatMismatch.summary';
          break;
        case 'percentFormatMismatch':
          // The {value} does not match the expected currency format
          resourceKey = 'oj-converter.number.percentFormatMismatch.summary';
          break;
        case 'unsupportedParseFormat':
          // TODO: We'll be able to remove this exception when this bug is fixed post V1.1:
          //  - implement parse() for short number converter
          //
          summary = Translations.getTranslatedString(
            'oj-converter.number.shortLongUnsupportedParse.summary'
          );
          detail = Translations.getTranslatedString(
            'oj-converter.number.shortLongUnsupportedParse.detail'
          );
          converterError = new ojvalidationError.ConverterError(summary, detail);
          break;
        default:
          break;
      }

      // The formatMismatch errors need a hint
      if (resourceKey) {
        summary = Translations.getTranslatedString(resourceKey, {
          value: value || parameterMap.value,
          format: parameterMap.format
        });

        // _getHintValue is smart. It uses the converter's 'format' function
        //  to get the example format to show the end user.
        detail = Translations.getTranslatedString('oj-converter.number.parseError.detail', {
          exampleValue: this._getHintValue()
        });

        converterError = new ojvalidationError.ConverterError(summary, detail);
      }
    }

    if (!converterError) {
      // An error we are unfamiliar with. Get the message and set as detail
      summary = e.message; // TODO: What should the summary be when it's missing??
      detail = e.message;
      converterError = new ojvalidationError.ConverterError(summary, detail);
    }

    return converterError;
  };

  // Returns the hint value. It uses the converter's format function to return a formatted
  // example. For example, if the converter's style is decimal and decimalFormat is short,
  // this.format(12345.98765) returns 12K, and we show 12K in the error message as an example
  // of what they should type in.
  // FA is overriding our ojs/ojconverter-datetime bundle and needs to define this function
  // or else they will get an error.
  // Do not rename. TODO: Ideally we will remove the need for them to have to define this function.
  IntlNumberConverter.prototype._getHintValue = function () {
    var value = '';
    try {
      // use .format to get a real example to show the user what format they can type in to the field.
      value = this.format(12345.98765);
    } catch (e) {
      if (e instanceof ojvalidationError.ConverterError) {
        // Something went wrong and we don't have a way to retrieve a valid value.
        value = '';
        Logger.error('error retrieving hint value in format');
      }
    }

    // returns the formatted value of 12345.98765
    return value;
  };

  exports.IntlNumberConverter = IntlNumberConverter;
  exports.NumberConverter = NumberConverter;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojvalidator-numberrange',['ojs/ojcore', 'ojs/ojtranslation', 'ojs/ojvalidator', 'ojs/ojvalidation-error', 'ojs/ojconverterutils'], function (oj, Translations, Validator, ojvalidationError, ConverterUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Validator = Validator && Object.prototype.hasOwnProperty.call(Validator, 'default') ? Validator['default'] : Validator;
  ConverterUtils = ConverterUtils && Object.prototype.hasOwnProperty.call(ConverterUtils, 'default') ? ConverterUtils['default'] : ConverterUtils;

  /**
   * Constructs a NumberRangeValidator that ensures the value provided is within a given range.
   * @param {Object=} options an object literal used to provide the following properties
   * @export
   * @constructor
   * @final
   * @augments oj.Validator
   * @name oj.NumberRangeValidator
   * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
   * @ojtsimport {module: "ojconverter-number", type:"AMD", imported: ["NumberConverter"]}
   * @ojtsmodule
   * @ojsignature [{target: "Type",
   *                value: "class NumberRangeValidator implements Validator<string|number>"},
   *               {target: "Type",
   *                value: "oj.NumberRangeValidator.ValidatorOptions",
   *                for: "options", jsdocOverride: true}
   *              ]
   * @since 0.7.0
   * @see oj.AsyncNumberRangeValidator
   *
   */
  const NumberRangeValidator = function _NumberRangeValidator(options) {
    this.Init(options);
  };

  // Subclass from oj.Validator
  oj.Object.createSubclass(NumberRangeValidator, Validator, 'oj.NumberRangeValidator');

  /**
   * @typedef {object} oj.NumberRangeValidator.ValidatorOptions
   * @property {oj.NumberConverter=} converter - an instance implementation of oj.NumberConverter.
   * It is used to format the value in error message. It is optional for the validator that a converter is passed in.
   * @property {number=} min - the minimum number value of the entered value.
   * @property {number=} max - the maximum number value of the entered value.
   * @property {Object=} hint - an optional object literal of hints to be used. If not set,
   * defaults will be used for the validator hint.
   * See the individual hint properties below for details.
   * <p>The hint strings (e.g., hint.min) are  passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * @property {string=} hint.max - a hint used to indicate the allowed maximum. When not present,
   * the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.hint.max</code>.<p>
   * Tokens: <br/>
   * {max} - the maximum<p>
   * Usage: <br/>
   * Enter a number less than or equal to {max}
   * @property {string=} hint.min - a hint used to indicate the allowed minimum. When not present,
   * the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.hint.min</code>.<p>
   * Tokens: <br/>
   * {min} the minimum <p>
   * Usage: <br/>
   * Enter a number greater than or equal to {min}</li>
   * @property {string=} hint.inRange - a hint used to indicate the allowed range. When not
   * present, the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.hint.inRange</code>.<p>
   * Tokens:<br/>
   * {min} the minimum<br/>
   * {max} the maximum<p>
   * Usage: <br/>
   * Enter a number between {min} and {max}
   * @property {string=} hint.exact - a hint used to indicate the allowed value.
   * This is used when min and max are non-null and are equal to each other.
   * When not present, the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.hint.exact</code>.<p>
   * Tokens:<br/>
   * {num} the number allowed<br/>
   * Usage: <br/>
   * Enter the number {num}
   * @since 3.0.0
   * @property {Object=} messageDetail - an optional object literal of custom error messages to
   * be used.
   * <p>The messageDetail strings (e.g., messageDetail.rangeUnderflow) are  passed as the 'pattern'
   * parameter to [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * @property {string=} messageDetail.rangeUnderflow - the detail error message to be used when
   * input value is less than the set minimum value. When not present, the default detail message is
   * the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.messageDetail.rangeUnderflow</code>.<p>
   * Tokens:<br/>
   * {value} - value entered by the user<br/>
   * {min} - the minimum allowed value<p>
   * Usage: <br/>
   * The number must be greater than or equal to {min}.
   * @property {string=} messageDetail.rangeOverflow - the detail error message to be used when
   * input value exceeds the maximum value set. When not present, the default detail message is
   * the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.messageDetail.rangeOverflow</code>.<p>
   * Tokens:<br/>
   * {value} - value entered by the user<br/>
   * {max} - the maximum allowed value<p>
   * Usage: <br/>
   * The number must be less than or equal to {max}.
   * @property {string=} messageDetail.exact - the detail error message to be used when the
   * input value is not between min and max when min and max are both non-null and equal.
   *  When not present, the default detail message is the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.messageDetail.exact</code>.<p>
   * Tokens:<br/>
   * {num} - the allowed value<p>
   * Usage: <br/>
   * The number must be {num}.
   * @since 3.0.0
   * @property {Object=} messageSummary - optional object literal of custom error summary message
   * to be used.
   * @property {string=} messageSummary.rangeUnderflow - the summary of the error message when
   * input value is less than the set minimum value. When not present, the default message summary is
   * the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.messageSummary.rangeUnderflow</code>.
   * @property {string=} messageSummary.rangeOverflow - the summary of the error message when
   * input value exceeds the maximum value set.  When not present, the default message summary is
   * the resource defined with the key
   * <code class="prettyprint">oj-validator.range.number.messageSummary.rangeOverflow</code>.
   */

  /**
   * Initializes validator instance with the set options
   * @param {Object=} options
   * @memberof oj.NumberRangeValidator
   * @instance
   * @export
   * @ignore
   */
  NumberRangeValidator.prototype.Init = function (options) {
    NumberRangeValidator.superclass.Init.call(this);

    if (options) {
      this._min = options.min;
      this._max = options.max;
      this._converter = ConverterUtils.getConverterInstance(options.converter);
      this._hint = options.hint || {};
      this._customMessageSummary = options.messageSummary || {};
      this._customMessageDetail = options.messageDetail || {};
    }
  };

  /**
   * Validates the minimum + maximum conditions
   *
   * @param {string|number} value that is being validated
   * @returns {void}
   *
   * @throws {Error} when value is out of range
   * @ojsignature {target: "Type", for: "returns",
   *                value: "void"}
   * @memberof oj.NumberRangeValidator
   * @instance
   * @export
   * @method validate
   */
  NumberRangeValidator.prototype.validate = function (value) {
    var string = value ? value.toString() : value;
    var numberValue = parseFloat(string);
    var customMessageSummary = this._customMessageSummary;
    var customMessageDetail = this._customMessageDetail;
    var messageDetailRangeOverflow = customMessageDetail.rangeOverflow;
    var messageDetailRangeUnderflow = customMessageDetail.rangeUnderflow;
    var messageDetailExact = customMessageDetail.exact;
    var messageSummaryRangeOverflow = customMessageSummary.rangeOverflow;
    var messageSummaryRangeUnderflow = customMessageSummary.rangeUnderflow;
    var min = this._min !== undefined ? parseFloat(this._min) : null;
    var max = this._max !== undefined ? parseFloat(this._max) : null;
    var summary = '';
    var detail = '';
    var params = null;
    var translations = Translations;

    if (value === null) {
      // request to not throw an error when value being passed is of null
      return;
    }

    if (min !== null && max !== null) {
      // range
      if ((numberValue >= min && numberValue <= max) || min > max) {
        return;
      }
    } else if (min !== null) {
      // only min
      if (numberValue >= min) {
        return;
      }
    } else if (max === null || numberValue <= max) {
      // max only or no min or max
      return;
    }

    var generateValidationError = function (minStr, maxStr) {
      // if we haven't returned with an OK, then we need to throw a ValidatorError
      //
      // First check if we have both a max and a min and if they are equal. If so the message will
      // be the messageDetail.exact message, like "Enter the number 1"
      if (max !== null && min !== null && min === max) {
        params = { value: value, num: maxStr };
        detail = messageDetailExact
          ? translations.applyParameters(messageDetailExact, params)
          : translations.getTranslatedString('oj-validator.range.number.messageDetail.exact', params);
        // if number is greater than max, the summary may say "The number is too high"
        if (numberValue > max) {
          summary =
            messageSummaryRangeOverflow ||
            translations.getTranslatedString(
              'oj-validator.range.number.messageSummary.rangeOverflow'
            );
        } else if (numberValue < min) {
          // if number is less than min, the summary may say "The number is too low"
          summary = messageSummaryRangeOverflow
            ? messageSummaryRangeUnderflow
            : translations.getTranslatedString(
                'oj-validator.range.number.messageSummary.rangeUnderflow'
              );
        }
      } else if (max !== null && numberValue > max) {
        // Next check if we have a max, and the number we are validating is greater than the max
        // throw an error,
        // like "The number is too high." and "The number must be less than or equal to {max}"
        params = { value: value, max: maxStr };
        summary =
          messageSummaryRangeOverflow ||
          translations.getTranslatedString('oj-validator.range.number.messageSummary.rangeOverflow');
        detail = messageDetailRangeOverflow
          ? translations.applyParameters(messageDetailRangeOverflow, params)
          : translations.getTranslatedString(
              'oj-validator.range.number.messageDetail.rangeOverflow',
              params
            );
      } else {
        // Else the number we are validating is less than the min, throw an error,
        // like "The number is too low." and "The number must be greater than or equal to {min}"
        params = { value: value, min: minStr };
        summary =
          messageSummaryRangeUnderflow ||
          translations.getTranslatedString('oj-validator.range.number.messageSummary.rangeUnderflow');
        detail = messageDetailRangeUnderflow
          ? translations.applyParameters(messageDetailRangeUnderflow, params)
          : translations.getTranslatedString(
              'oj-validator.range.number.messageDetail.rangeUnderflow',
              params
            );
      }
      return [summary, detail];
    };

    var minStr = min && this._converter ? this._converter.format(min) : min;
    var maxStr = max && this._converter ? this._converter.format(max) : max;
    var error = generateValidationError(minStr, maxStr);
    throw new ojvalidationError.ValidatorError(error[0], error[1]);
  };

  /**
   * @returns {string|null} a hint message or null if no hint is available in the options.
   * A hint message may be like "Enter a value between {min} and {max}"
   * or "Enter a number greater than or equal to {min}"
   * @memberof oj.NumberRangeValidator
   * @instance
   * @export
   * @method getHint
   */
  NumberRangeValidator.prototype.getHint = function () {
    var hints = this._hint;
    var hintInRange = hints.inRange;
    var hintExact = hints.exact;
    var hintMinimum = hints.min;
    var hintMaximum = hints.max;
    var translations = Translations;
    var min = this._min !== undefined ? parseFloat(this._min) : null;
    var max = this._max !== undefined ? parseFloat(this._max) : null;

    var generateHintText = function (minStr, maxStr) {
      var hint = null;
      // if both min and max are specified, the hint may say something like "Enter a value
      // between {min} and {max}".
      if (min !== null && max !== null) {
        if (min !== max) {
          // if hintInRange is specified (validator's hint.inRange option is set),
          // use that string, else use the default.
          hint = hintInRange
            ? translations.applyParameters(hintInRange, { min: minStr, max: maxStr })
            : translations.getTranslatedString('oj-validator.range.number.hint.inRange', {
                min: minStr,
                max: maxStr
              });
        } else {
          // if hintExact is specified (validator's hint.exact option is set),
          // use that string, else use the default.
          hint = hintExact
            ? translations.applyParameters(hintExact, { num: minStr })
            : translations.getTranslatedString('oj-validator.range.number.hint.exact', {
                num: minStr
              });
        }
      } else if (min !== null) {
        // else if min is specified, the hint may say something like "Enter a value
        // greater than or equal to {min}".

        // if hintMinimum is specified (validator's hint.min option is set),
        // use that string, else use the default.
        hint = hintMinimum
          ? translations.applyParameters(hintMinimum, { min: minStr })
          : translations.getTranslatedString('oj-validator.range.number.hint.min', { min: minStr });
      } else if (max !== null) {
        // else if max is specified, the hint may say something like "Enter a value
        // less than or equal to {max}".

        // if hintMaximum is specified (validator's hint.max option is set),
        // use that string, else use the default.
        hint = hintMaximum
          ? translations.applyParameters(hintMaximum, { max: maxStr })
          : translations.getTranslatedString('oj-validator.range.number.hint.max', { max: maxStr });
      }
      return hint;
    };

    var minStr = min && this._converter ? this._converter.format(min) : min;
    var maxStr = max && this._converter ? this._converter.format(max) : max;

    return generateHintText(minStr, maxStr);
  };

  return NumberRangeValidator;

});


define('ojs/ojinputnumber',['ojs/ojcore-base', 'jquery', 'ojs/ojcontext', 'ojs/ojbutton', 'ojs/ojeditablevalue', 'ojs/ojcomponentcore', 'ojs/ojdomutils', 'ojs/ojthemeutils', 'ojs/ojlogger', 'ojs/ojvalidator-numberrange', 'ojs/ojconverter-number'], function (oj, $, ojcontext, ojbutton, ojeditablevalue, Components, DomUtils, ThemeUtils, Logger, NumberRangeValidator, ojconverterNumber) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  NumberRangeValidator = NumberRangeValidator && Object.prototype.hasOwnProperty.call(NumberRangeValidator, 'default') ? NumberRangeValidator['default'] : NumberRangeValidator;

  (function () {
var __oj_input_number_metadata = 
{
  "properties": {
    "asyncValidators": {
      "type": "Array<Object>",
      "value": []
    },
    "autocomplete": {
      "type": "string",
      "value": "on",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "autofocus": {
      "type": "boolean",
      "value": false,
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "converter": {
      "type": "object"
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "max": {
      "type": "number"
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "min": {
      "type": "number"
    },
    "name": {
      "type": "string",
      "value": "",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "placeholder": {
      "type": "string",
      "value": ""
    },
    "rawValue": {
      "type": "string",
      "writeback": true,
      "readOnly": true
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "step": {
      "type": "number"
    },
    "transientValue": {
      "type": "number",
      "writeback": true,
      "readOnly": true
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "numberRange": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "object",
              "properties": {
                "exact": {
                  "type": "string"
                },
                "inRange": {
                  "type": "string"
                },
                "max": {
                  "type": "string"
                },
                "min": {
                  "type": "string"
                }
              }
            },
            "messageDetail": {
              "type": "object",
              "properties": {
                "exact": {
                  "type": "string"
                },
                "rangeOverflow": {
                  "type": "string"
                },
                "rangeUnderflow": {
                  "type": "string"
                }
              }
            },
            "messageSummary": {
              "type": "object",
              "properties": {
                "rangeOverflow": {
                  "type": "string"
                },
                "rangeUnderflow": {
                  "type": "string"
                }
              }
            }
          }
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        },
        "tooltipDecrement": {
          "type": "string"
        },
        "tooltipIncrement": {
          "type": "string"
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "validators": {
      "type": "Array<Object>",
      "value": []
    },
    "value": {
      "type": "number",
      "writeback": true
    },
    "virtualKeyboard": {
      "type": "string",
      "enumValues": [
        "auto",
        "number",
        "text"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "stepDown": {},
    "stepUp": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    __oj_input_number_metadata.extension._WIDGET_NAME = 'ojInputNumber';
    __oj_input_number_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    __oj_input_number_metadata.extension._INNER_ELEM = 'input';
    __oj_input_number_metadata.extension._GLOBAL_TRANSFER_ATTRS = [
      'accesskey',
      'aria-label',
      'tabindex'
    ];

    oj.CustomElementBridge.register('oj-input-number', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_input_number_metadata, {
        properties: {
          readonly: {
            binding: { consume: { name: 'readonly' } }
          },
          userAssistanceDensity: {
            binding: { consume: { name: 'userAssistanceDensity' } }
          },
          labelEdge: {
            binding: { consume: { name: 'labelEdge' } }
          }
        }
      })
    });
  })();

  /**
   * @preserve Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  // jeanne retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.spinner.js on 6/2013, and then modified

  /**
   * @private
   */
  var _sDefaultNumberConverter;

  /**
   * For default converter
   * @static
   * @ignore
   */
  function _getNumberDefaultConverter() {
    return new ojconverterNumber.IntlNumberConverter(null);
  }

  /*!
   * JET InputNumber @VERSION
   *
   *
   * Depends:
   *  jquery.ui.widget.js
   */
  (function () {
    // inputNumber wrapper function, to keep "private static members" private
    /**
     * @ojcomponent oj.ojInputNumber
     * @augments oj.editableValue
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojInputNumber extends editableValue<number|null, ojInputNumberSettableProperties, number|null, string>"
     *               },
     *               {
     *                target: "Type",
     *                value: "ojInputNumberSettableProperties extends editableValueSettableProperties<number|null, number|null, string>",
     *                for: "SettableProperties"
     *               }
     *              ]
     * @since 0.6.0
     * @ojshortdesc An input number allows the user to enter a number value.
     * @ojrole textbox
     * @ojrole spinbutton
     *
     * @ojimportmembers oj.ojDisplayOptions
     * @ojtsimport {module: "ojvalidationfactory-base", type: "AMD", imported:["Validation"]}
     * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
     * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
     * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
     * @ojtsimport {module: "ojconverter-number", type: "AMD",  imported: ["IntlNumberConverter", "NumberConverter"]}
     * @ojtsimport {module: "ojvalidator-length", type: "AMD", importName: "LengthValidator"}
     * @ojtsimport {module: "ojvalidator-numberrange", type: "AMD", importName: "NumberRangeValidator"}
     * @ojtsimport {module: "ojvalidator-regexp", type: "AMD", importName: "RegExpValidator"}
     * @ojtsimport {module: "ojvalidator-required", type: "AMD", importName: "RequiredValidator"}
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "min", "max", "step", "required", "disabled", "readonly", "virtualKeyboard", "converter"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 6
     * @ojvbmincolumns 2
     *
     * @ojoracleicon 'oj-ux-ico-input-number'
     * @ojuxspecs ['input-number']
     *
     * @ojdeprecated [
     *   {
     *     type: "maintenance",
     *     since: "16.0.0",
     *     value: ["oj-c-input-number"]
     *   }
     * ]
     *
     * @classdesc
     * <h3 id="inputNumberOverview-section">
     *   JET InputNumber Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputNumberOverview-section"></a>
     * </h3>
     * <p>Description: The oj-input-number component enhances a browser input element
     * into one that holds numbers and it has a spinbox to quickly increment or
     * decrement the number. The <code class="prettyprint">value</code> attribute must be a number and must
     * be within the <code class="prettyprint">min</code> and <code class="prettyprint">max</code> range.
     * </p>
     * <p>A step mismatch is when
     * the value is not a multiple of <code class="prettyprint">step</code>,
     * starting at the <code class="prettyprint">min</code>
     * else initial vlaue if no <code class="prettyprint">min</code> is set, else 0.
     * A step mismatch will not be flagged as a validation error by default, but
     * the step up and step down feature will change the value to be a step match
     * if it isn't already.
     * </p>
     *
     * {@ojinclude "name":"validationAndMessagingDoc"}
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The component is accessible; it sets and maintains the appropriate aria- attributes,
     * like aria-valuenow, aria-valuemax, aria-valuemin and aria-valuetext.
     * </p>
     * <p>
     * {@ojinclude "name":"accessibilityLabelEditableValue"}
     * {@ojinclude "name":"accessibilityPlaceholderEditableValue"}
     * {@ojinclude "name":"accessibilityDisabledEditableValue"}
     * </p>
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     *
     * <p>
     * To migrate from oj-input-number to oj-c-input-number, you need to revise the import statement
     * and references to oj-c-input-number in your app. Please note the changes between the two components below.
     * </p>
     *
     * <h5>Global attributes</h5>
     * <p>
     * The following global attributes are no longer supported:
     * <ul>
     * <li>accesskey - not considered accessible</li>
     * <li>tabindex - not considered accessible</li>
     * <li>
     * aria-label - use label-hint instead. If you do not want a visible label set label-edge="none".
     * </li>
     * </ul>
     * </p>
     *
     * <h5>Converter attribute</h5>
     * <p>
     * The converter attribute is changed to support only a converter instance, null, or undefined. It does not support
     * a Promise that resolves to a converter instance. The application should resolve the promise and then update the
     * converter attribute with the resolved converter instance.
     * </p>
     * <p>
     * The converter is no longer applied when the value is <code>null</code>, <code>undefined</code>, or <code>''</code>.
     * When the field is empty, the value gets normalized to <code>null</code>, so the converter does not run on an empty field.
     * <p>
     *
     * <h5>New converters</h5>
     * <p>
     * New converters are available. See <a href="BigDecimalStringConverter.html" target="_blank">BigDecimalStringConverter</a>
     * and <a href="NumberConverter.html" target="_blank">NumberConverter</a> for more details.
     * </p>
     * <p>
     * oj-c-input-number uses NumberConverter as its default converter whereas oj-input-number uses IntlNumberConverter as its default converter.
     * The default converter used by oj-c-input-number does not currently respect user preferences.
     * </p>
     *
     * <h5>Validators</h5>
     * <p>
     * Only the required validator is run for an empty field, and only if required is true. The component's other validators
     * are no longer run when the field is empty.
     * If you created your own validator to check that the field was filled in, it will not run if the
     * field is empty. Set the required attribute to true instead which conforms to the Redwood UX design.
     * </p>
     *
     * <h5>LabelEdge attribute</h5>
     * <p>
     * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
     * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
     * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
     * attribute to the corresponding value.
     * </p>
     *
     * <h5>MessagesCustom attribute</h5>
     * <p>
     * The type of the <code class="prettyprint">severity</code> property of the messages in the
     * array has changed from
     * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
     * essentially <code class="prettyprint">string | number</code>, to simply
     * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
     * values are the same as the previously supported string values.
     * The application can no longer specify severity as a number, including hardcoded numbers,
     * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
     * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
     * </p>
     *
     * <h5>TextAlign attribute</h5>
     * <p>
     * The usage of the style classes: oj-form-control-text-align-right, oj-form-control-text-align-start and oj-form-control-text-align-end is now
     * replaced with this attribute. The value of this attribute maps to these style classes as shown below:
     * <ul>
     * <li>
     * .oj-form-control-text-align-right maps to 'right'
     * </li>
     * <li>
     * .oj-form-control-text-align-start maps to 'start'
     * </li>
     * <li>
     * .oj-form-control-text-align-end maps to 'end'
     * </li>
     * </ul>
     * </p>
     * <h5>Translations attribute</h5>
     * <ul>
     * <li>The translations.required.message-detail attribute has changed to required-message-detail.
     * </li>
     * <li>The translations.number-range.message-detail.exact attribute has changed to number-range-exact-message-detail.
     * </li>
     * <li>The translations.number-range.message-detail.overflow attribute has changed to number-range-overflow-message-detail.
     * </li>
     * <li>The translations.number-range.message-detail.underflow attribute has changed to number-range-underflow-message-detail.
     * </li>
     * </ul>
     * <h5>Value attribute</h5>
     * <p>
     * Clearing the field and committing the value will now set the value attribute to <code>null</code>
     * instead of <code>''</code>.
     * </p>
     *
     * <h5>Refresh method</h5>
     * <p>
     * The refresh method is no longer supported. The application should no longer need to use this method. If the application
     * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
     * </p>
     *
     * <h5>StepDown method</h5>
     * <p>
     * The stepDown method is no longer supported. Please programmatically set the value instead.
     * </p>
     *
     * <h5>StepUp method</h5>
     * <p>
     * The stepUp method is no longer supported. Please programmatically set the value instead.
     * </p>
     *
     * <h5>Animation Events</h5>
     * <p>
     * ojAnimateStart and ojAnimateEnd events are no longer supported.
     * </p>
     *
     * <h5>Custom Label</h5>
     * <p>
     * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
     * label-hint attribute to add a label for the form component.
     * </p>
     * <p>
     * The application should no longer need to use an &lt;oj-label-value> component to layout the form component. The application
     * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
     * </p>
     *
     * <h5>DescribedBy attribute</h5>
     * <p>
     * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
     * This attribute is not carried forward to the core pack component.
     * </p>
     *
     * <h5>Formatted messages</h5>
     * <p>
     * Formatting messages using html tags is not supported in the core pack component.
     * </p>
     *
     * <h5>Usage in Dynamic Form</h5>
     * <p>
     * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
     * </p>
     * @example <caption>Declare the oj-input-number component with no attributes specified:</caption>
     * &lt;oj-input-number>&lt;/oj-input-number>
     *
     * @example <caption>Initialize the component with some attributes:</caption>
     * &lt;oj-input-number id="numberId" max="100" min="0" step="2">&lt;/oj-input-number>
     *
     * @example <caption>Initialize a component attribute via component binding:</caption>
     * &lt;oj-input-number id="numberId" value="{{currentValue}}">&lt;/oj-input-number>
     */

    //----------------------------------------------------------------
    //      API doc for inherited methods with no JS in this file
    //----------------------------------------------------------------

    /**
     * Removes the inputNumber functionality completely.
     * This will return the element back to its pre-init state.
     *
     * <p>This method does not accept any arguments.
     *
     * @method
     * @name oj.ojInputNumber#destroy
     * @memberof oj.ojInputNumber
     * @instance
     * @ignore
     *
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * myComp.destroy();
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Up Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Increment the number.</td>
     *     </tr>
     *     <tr>
     *       <td>Down Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Decrement the number.</td>
     *     </tr>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Set focus to the input. Show user assistance text. This may be inline or in a notewindow
     * depending upon theme and property settings.</td>
     *     </tr>
     *     <tr>
     *       <td>Elsewhere on Page</td>
     *       <td><kbd>Touch</kbd></td>
     *       <td>Submit the value you typed in the input field.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojInputNumber
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="4">Input</td>
     *       <td><kbd>Enter</kbd> or <kbd>Tab</kbd></td>
     *       <td>Submit the value you typed in the input field.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to input. Show user assistance text. This may be inline or in a notewindow
     * depending upon theme and property settings.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Increment the number.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Decrement the number.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojInputNumber
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the inputNumber's Up arrow.</p>
     *
     * @ojsubid oj-inputnumber-up
     * @memberof oj.ojInputNumber
     *
     * @example <caption>Get the node for the Up arrow:</caption>
     * var node = myComp.getNodeBySubId('oj-inputnumber-up');
     */

    /**
     * <p>Sub-ID for the inputNumber's Down arrow.</p>
     *
     * @ojsubid oj-inputnumber-down
     * @memberof oj.ojInputNumber
     *
     * @example <caption>Get the node for the Down arrow:</caption>
     * var node = myComp.getNodeBySubId('oj-inputnumber-down);
     */

    /**
     * <p>Sub-ID for the inputNumber's input element.</p>
     * @ojsubid oj-inputnumber-input
     * @memberof oj.ojInputNumber
     *
     * @example <caption>Get the node for the input element:</caption>
     * var node = myComp.getNodeBySubId('oj-inputnumber-input');
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------
    /**
     * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
     * The form control style classes can be applied to the component, or an ancestor element. <br/>
     * When applied to an ancestor element, all form components that support the style classes will be affected.
     */
    // ---------------- oj-form-control-full-width --------------
    /**
     * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
     * @ojstyleclass oj-form-control-full-width
     * @ojdisplayname Full Width
     * @memberof oj.ojInputNumber
     * @ojtsexample
     * &lt;oj-input-number class="oj-form-control-full-width">
     * &lt;/oj-input-number>
     */

    // ---------------- oj-form-control max-width --------------
    /**
     * In the Redwood theme the default max width of a text field is 100%.
     * These max width convenience classes are available to create a medium or small field.<br>
     * The class is applied to the root element.
     * @ojstyleset form-control-max-width
     * @ojdisplayname Max Width
     * @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
     * @ojstylerelation exclusive
     * @memberof oj.ojInputNumber
     * @ojunsupportedthemes ['Alta']
     * @ojtsexample
     * &lt;oj-input-number class="oj-form-control-max-width-md">&lt;/oj-input-number>
     */
    /**
     * @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
     * @ojshortdesc Sets the max width for a small field
     * @ojdisplayname Small
     * @memberof! oj.ojInputNumber
     */
    /**
     * @ojstyleclass form-control-max-width.oj-form-control-max-width-md
     * @ojshortdesc Sets the max width for a medium field
     * @ojdisplayname Medium
     * @memberof! oj.ojInputNumber
     */

    // ---------------- oj-form-control width --------------
    /**
     * In the Redwood theme the default width of a text field is 100%.
     * These width convenience classes are available to create a medium or small field.<br>
     * The class is applied to the root element.
     * @ojstyleset form-control-width
     * @ojdisplayname Width
     * @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
     * @ojstylerelation exclusive
     * @memberof oj.ojInputNumber
     * @ojunsupportedthemes ['Alta']
     * @ojtsexample
     * &lt;oj-input-number class="oj-form-control-width-md">&lt;/oj-input-number>
     */
    /**
     * @ojstyleclass form-control-width.oj-form-control-width-sm
     * @ojshortdesc Sets the width for a small field
     * @ojdisplayname Small
     * @memberof! oj.ojInputNumber
     */
    /**
     * @ojstyleclass form-control-width.oj-form-control-width-md
     * @ojshortdesc Sets the width for a medium field
     * @ojdisplayname Medium
     * @memberof! oj.ojInputNumber
     */

    // ---------------- oj-form-control-text-align- --------------
    /**
     * Classes that help align text of the element.
     * @ojstyleset text-align
     * @ojdisplayname Text Alignment
     * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
     * @ojstylerelation exclusive
     * @memberof oj.ojInputNumber
     * @ojtsexample
     * &lt;oj-input-number class="oj-form-control-text-align-right">
     * &lt;/oj-input-number>
     */
    /**
     * @ojstyleclass text-align.oj-form-control-text-align-right
     * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
     * @ojdisplayname Align-Right
     * @memberof! oj.ojInputNumber
     */
    /**
     * @ojstyleclass text-align.oj-form-control-text-align-start
     * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
     * @ojdisplayname Align-Start
     * @memberof! oj.ojInputNumber
     */
    /**
     * @ojstyleclass text-align.oj-form-control-text-align-end
     * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
     * @ojdisplayname Align-End
     * @memberof! oj.ojInputNumber
     */
    // --------------------------------------------------- oj.ojInputNumber Styling end ------------------------------------------------------------

    oj.__registerWidget('oj.ojInputNumber', $.oj.editableValue, {
      version: '1.0.0',
      defaultElement: '<input>',
      widgetEventPrefix: 'oj',

      /**
       * @private
       */
      _ALLOWED_TYPES: ['number', 'text'],

      options: {
        /**
         * List of asynchronous validators used by the component when performing validation.
         * Use <code class="prettyprint">async-validators</code> when you need to
         * perform some validation work on the server. Otherwise, use
         * <code class="prettyprint">validators</code>, which are synchronous.
         * <p>
         * Each item in the Array is an instance that duck types {@link oj.AsyncValidator}.
         * Implicit validators created by a component when certain attributes
         * are present (e.g. <code class="prettyprint">required</code> attribute) are separate from
         * validators specified through the <code class="prettyprint">async-validators</code>
         * attribute and the <code class="prettyprint">validators</code> attribute.
         * At runtime when the component runs validation, it
         * combines the implicit validators with the list specified through the
         * <code class="prettyprint">validators</code>
         * attribute and also the list specified through the
         * <code class="prettyprint">async-validators</code> attribute.
         * Error messages are shown as soon as each async validator returns;
         * we do not wait until all the async validators finish to show errors.
         * If the component's valid state changes for the worse, it is also updated
         * as each validator returns so valid will be invalidShown
         * as soon as the first validator has an Error.
         * </p>
         * <p> It is recommended that you show the
         * value you are validating in the error message because if the async operation takes a while,
         * the user could be typing in a new value when the error message comes back
         * and might be confused what value the error is for. However, if the user enters a new value
         * (like presses Enter or Tab), a new validation lifecycle will start
         * and validation errors for the previous value will not be shown to the user.
         * If you need to format the value for the error message,
         * you can use e.g. for number
         * <code class="prettyprint">new NumberConverter.IntlNumberConverter(converterOption)</code>
         * to get the converter instance,
         * then call <code class="prettyprint">converter.format(value)</code>.
         * </p>
         * <p>
         * Hints exposed by validators are shown inline by default in the Redwood theme when the
         * field has focus.
         * In the Alta theme, validator hints are shown in a notewindow on focus,
         * or as determined by the
         * 'validatorHint' property set on the <code class="prettyprint">display-options</code>
         * attribute.
         * In either theme, you can turn off showing validator hints by using the
         * 'validatorHint' property set to 'none' on the <code class="prettyprint">display-options</code>
         * attribute.
         * </p>
         * <p>Since async validators are run asynchronously, you should wait on the BusyContext before
         * you check valid property or the value property. Alternatively you can add a callback to
         * the validChanged or valueChanged events.
         * </p>
         * <p>
         * The steps performed always, running validation and clearing messages is the same as
         * for the <code class="prettyprint">{@link oj.ojInputNumber#validators}</code> attribute.
         * </p>
         * <br/>
         * @example <caption>Create an Object that duck-types the oj.AsyncValidator interface.
         * Bind the Object to the JET form component's async-validators attribute. The
         * validator's 'validate' method will be called when the user changes the input.</caption>
         *  self.asyncValidator1 = {
         *    // required validate method
         *    'validate': function(value) {
         *      return new Promise(function(resolve, reject) {
         *        var successful = someBackendMethod();
         *        if (successful) {
         *          resolve(true);
         *        } else {
         *          reject(new Error('The amount of purchase is too high. It is ' + value));
         *        }
         *      });
         *    },
         *    // optional hint attribute. hint shows up when user sets focus to input.
         *    'hint': new Promise(function (resolve, reject) {
         *      var formattedMaxPurchase = getSomeBackendFormattedMaxPurchase();
         *      resolve(maxPurchase + " is the maximum.");
         *    });
         *  };
         *  -- HTML --
         *  &lt;oj-input-number value="{{value}}"
         *  async-validators="[[[asyncValidator1]]]">&lt;/oj-input-number>
         * @example <caption>Initialize the component with multiple AsyncValidator
         * duck-typed instances:</caption>
         * -- HTML --
         * &lt;oj-input-number id="asyncValKo1" data-oj-context
                    valid="{{koAsyncValid}}" value="{{koAsyncValue}}"
                    required validators="[[[checkfoo, checkfooey]]]"
                    async-validators="[[[asyncValidator1, asyncValidator2]]]">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">asyncValidators</code>
         * property after initialization:</caption>
         * // getter
         * var validators = myComp.asyncValidators;
         *
         * // setter
         * var myValidators = [{
         * 'validate' : function(value) {
         *   return new Promise(function(resolve, reject) {
         *   // mock server-side delay
         *   setTimeout(function () {
         *     if (value === 100 || value === 1000) {
         *       resolve(true);
         *     } else {
         *       reject(new Error("value isn't 100 or 1000. It is " + value.));
         *     }
         *   },10);
         *   });
         * }
         * }];
         * myComp.asyncValidators = myValidators;
         * @ojdeprecated {since: '8.0.0', description: 'Use the validators property instead for either regular Validators or AsyncValidators.'}
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc Specifies a list of asynchronous validators used by the component when performing validation. Use async-validators when you need to perform some validation work on the server. See the Help documentation for more information.
         * @ojsignature  { target: "Type",
         *       value: "Array<oj.AsyncValidator<number>>",
         *       jsdocOverride: true}
         * @type {Array.<Object>}
         * @default []
         */
        asyncValidators: [],
        /**
         * Dictates component's autocomplete state.
         * This attribute indicates whether the value of the control can be automatically
         * completed by the browser. The common values are "on" and "off".
         * <p>Since this attribute passes through to the input element
         * unchanged, you can look at the html specs for detailed information for how browsers behave
         * and what values besides "on" and "off" you can set. The html spec says the default is "on",
         * so when autocomplete is not explicitly set, the browsers treat it as "on".
         * </p>
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}
         * @see {@link https://caniuse.com/#feat=input-autocomplete-onoff}
         * @see {@link https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute}
         *
         *
         * @example <caption>Initialize component with <code class="prettyprint">autocomplete</code> attribute:</caption>
         * &lt;oj-input-number autocomplete = "on">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">autocomplete</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.autocomplete;
         *
         * // setter
         * myComp.autocomplete = "on";
         * @ojshortdesc Specifies a component's autocomplete state. See the Help documentation for more information.
         * @expose
         * @type {"on"|"off"|string=}
         * @default "on"
         * @instance
         * @access public
         * @memberof oj.ojInputNumber
         * @ojextension {_COPY_TO_INNER_ELEM: true}
         */
        autocomplete: undefined,
        /**
         * Autofocus is a Boolean that reflects the autofocus attribute, If it is set to true
         * then the associated component  will get input focus when the page is loaded.
         * Setting this property doesn't set the focus to the component:
         * it tells the browser to focus to it when the element is inserted in the document.
         *
         * @example <caption>Initialize component with <code class="prettyprint">autofocus</code> attribute:</caption>
         * &lt;oj-input-number autofocus>&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">autofocus</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.autofocus;
         *
         * // setter
         * myComp.autofocus = false;
         *
         * @expose
         * @type {boolean}
         * @access public
         * @default false
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc Specifies whether the component will get input focus when the page is loaded. See the Help documentation for more information.
         * @ojextension {_COPY_TO_INNER_ELEM: true}
         */
        autofocus: false,
        // TODO: revisit
        // It's expensive to create a default converter ahead of time when a page author can set a custom
        // one for if they do this will be promptly discarded.

        /**
         * A number converter instance or one that duck types {@link oj.NumberConverter}. The number converter instance defaults
         * to options suitable for the current locale.
         * <p>
         * When no converter is specified, the default converter will be used,
         * and default option of "numeric" is used.
         * </p>
         * <p>
         *  During validation, the converter takes the input value and parses it into the
         * type of the component's value property (i.e. a number) before it passes
         *  it to the validator. It then takes the validated value property and formats it
         *  into a string and puts it into the input. If the converter's format or parse functions
         *  throw an error, it will be displayed to the user.
         * </p>
         * <p>
         * When <code class="prettyprint">converter</code> property changes due to programmatic
         * intervention, the component performs various tasks based on the current state it is in. </br>
         * When initialized with no options, the default options for the current locale are assumed. </br>
         *
         * <p>
         * The hint exposed by the converter is shown inline by default in the Redwood theme when
         * the field has focus.
         * In the Alta theme, converter hints are shown in a notewindow on focus,
         * or as determined by the
         * 'converterHint' property set on the <code class="prettyprint">display-options</code>
         * attribute.
         * In either theme, you can turn off showing converter hints by using the
         * 'converterHint' property set to 'none' on the <code class="prettyprint">display-options</code>
         * attribute.
         * </p>
         * <p>
         * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
         * help.instruction shows; if no help.instruction then validator hints show;
         * if none, then help-hints.definition shows; if none, then converter hint shows.
         * help-hints.source always shows along with the other help or hint.
         * </p>
         *
         * <h4>Steps Performed Always When Converter Is Changed</h4>
         * <ul>
         * <li>Any cached converter instance is cleared and new converter created. The converter hint is
         * pushed to messaging. E.g., notewindow displays the new hint(s).
         * </li>
         * </ul>
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>if component is valid when <code class="prettyprint">converter</code> property changes, the
         * display value is refreshed.</li>
         * <li>if component is invalid and is showing messages when
         * <code class="prettyprint">converter</code> property changes, then all messages generated by the
         * component are cleared and full validation run using its current display value.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated, and the errors are shown. The display value is not refreshed in this case. </li>
         *   <li>if no errors result from the validation, <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event to clear custom errors. The display value is refreshed with the formatted
         *   value provided by converter.</li>
         * </ul>
         * </li>
         * <li>if component is invalid and has deferred messages when
         * <code class="prettyprint">converter</code> property changes, then the display value is
         * refreshed with the formatted value provided by converter.</li>
         * </ul>
         * </p>
         *
         * <h4>Clearing Messages</h4>
         * <ul>
         * <li>messages created by
         * the component  are cleared.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared. Page authors can
         * choose to clear it explicitly when setting the converter property.</li>
         * </ul>
         * </p>
         *
         *
         * @example <caption>Initialize component to use default converter</caption>
         * &lt;oj-input-number value="25000">&lt;/oj-input-number>
         *
         * @example <caption>Initialize the component with a number converter instance:</caption>
         * // Initialize converter instance using currency options
         * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
         * var salaryConverter = new NumberConverter.IntlNumberConverter(options);<br/>
         * // set converter instance using converter attribute
         * &lt;oj-input-number value="25000" converter="[[salaryConverter]]">&lt;/oj-input-number>
         *
         *
         * @example <caption>Get or set the <code class="prettyprint">converter</code> property after initialization:</caption>
         * // Getter
         * var convtr = myComponent.converter;
         *
         * // Setter
         * myComponent.converter = salaryConverter;
         *
         *
         * @default new IntlNumberConverter()
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc An object that converts the value. See the Help documentation for more information.
         * @ojsignature [{
         *    target: "Type",
         *    value: "oj.Converter<number>",
         *    jsdocOverride: true},
         * {target: "Type",
         *    value: "Promise<oj.Converter<number>>|oj.Converter<number>|oj.Validation.RegisteredConverter",
         *    consumedBy: 'tsdep'}]
         * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredConverter'],
         *                description:'Defining a converter with an object literal with converter type and its options
         *                  (aka JSON format) has been deprecated and does nothing. If needed, you can make the JSON format
         *                  work again by importing the deprecated ojvalidation-number module.'}
         * @ojdeprecated {since: '17.0.0', target: 'memberType', value: ['Promise<oj.Converter<number>>'],
         *                description: 'Defining a Promise to a Converter instance has been deprecated. The application should resolve the promise and then update the converter attribute with the resolved converter instance.'}
         * @type {Object}
         */
        converter: null,
        /**
         * <p>
         * The oj-label sets the labelledBy property programmatically on the form component
         * to make it easy for the form component to find its oj-label component (a
         * document.getElementById call.)
         * </p>
         * <p>
         * The application developer should use the 'for'/'id api
         * to link the oj-label with the form component;
         * the 'for' on the oj-label to point to the 'id' on the input form component.
         * This is the most performant way for the oj-label to find its form component.
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
         * &lt;oj-label for="numberId">Number:&lt;/oj-label>
         * &lt;oj-input-number id="numberId">
         * &lt;/oj-input-number>
         * // ojLabel then writes the labelled-by attribute on the oj-input-number.
         * &lt;oj-label id="labelId" for="numberId">Number:&lt;/oj-label>
         * &lt;oj-input-number id="numberId" labelled-by"labelId">
         * &lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelledBy = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         *
         * @expose
         * @ojshortdesc The oj-label sets the labelledBy property programmatically on the form component.
         * @type {string|null}
         * @default null
         * @public
         * @instance
         * @since 7.0.0
         * @memberof oj.ojInputNumber
         */
        labelledBy: null,

        /**
         * The maximum allowed value. This number is used in the range validator; if the
         * <code class="prettyprint">value</code> is greater than the <code class="prettyprint">max</code>,
         * then the range validator flags an error to the user. The up arrow
         *  is disabled when the maximum value is reached.
         * <p>
         *  <code class="prettyprint">Max</code> must be a
         *  <code class="prettyprint">number</code> or <code class="prettyprint">null</code>;
         *  <code class="prettyprint">null</code> indicates no maximum.
         * <p>
         * The <code class="prettyprint">max</code> must not be less than the
         * <code class="prettyprint">min</code>, else an Error is thrown during initialization.
         * @expose
         * @memberof oj.ojInputNumber
         * @ojshortdesc The maximum allowed value. A value of null indicates that there is no maximum. See the Help documentation for more information.
         * @instance
         * @type {?number}
         * @default null
         * @example <caption>Initialize the inputNumber with the
         * <code class="prettyprint">max</code> attribute specified:</caption>
         * &lt;oj-input-number max="100">&lt;/oj-input-number>
         *
         * @example <caption>Change the <code class="prettyprint">max</code> property to a float:</caption>
         * myComponent.max = 100.5;
         *
         * @example <caption>To remove the maximum range restriction from inputNumber:</caption>
         * myComponent.max =  null;
         *
         * @example <caption>Get or set the <code class="prettyprint">max</code> property after initialization:</caption>
         * // Getter
         * var max = myComponent.max;
         *
         * // Setter
         * myComponent.max = 100;
         */
        max: null,

        /**
         * The minimum allowed value. This number is used in the range validator; if the
         * <code class="prettyprint">value</code> is less than the <code class="prettyprint">min</code>,
         * then the range validator flags an error to the user. The down arrow
         *  is disabled when the minimum value is reached.
         *  <p>
         *  <code class="prettyprint">Min</code> must be a <code class="prettyprint">number</code> or <code class="prettyprint">null</code>;
         *  <code class="prettyprint">null</code> indicates no minimum.
         * <p>
         * The <code class="prettyprint">max</code> must not be less than the
         * <code class="prettyprint">min</code>, else an Error is thrown during initialization.
         * @expose
         * @memberof oj.ojInputNumber
         * @ojshortdesc The minimum allowed value. A value of null indicates that there is no minimum. See the Help documentation for more information.
         * @instance
         * @type {?number}
         * @default null
         * @example <caption>Initialize the inputNumber with the
         * <code class="prettyprint">min</code> attribute specified:</caption>
         * &lt;oj-input-number min="0">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">min</code> property after initialization:</caption>
         * // Getter
         * var min = myComponent.min;
         *
         * // Setter
         * myComponent.min = 0;
         *
         * @example <caption>Change the <code class="prettyprint">min</code> property to a float:</caption>
         * myComponent.min = 10.5;
         *
         * @example <caption>To remove the minimum range restriction from inputNumber:</caption>
         * myComponent.min =  null;
         *
         */
        min: null,
        /**
         * It indicates the name of the component.
         *
         * @example <caption>Initialize component with <code class="prettyprint">name</code> attribute:</caption>
         * &lt;oj-input-number name="myName">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">name</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.name;
         *
         * // setter
         * myComp.name = "myName";
         *
         * @expose
         * @type {string}
         * @ojshortdesc Specifies the name of the component.
         * @access public
         * @instance
         * @default ""
         * @ojdeprecated {since: '6.0.0', description: 'JET does not use form submit, so this is not needed.'}
         * @ojtsignore
         * @memberof oj.ojInputNumber
         * @ojextension {_COPY_TO_INNER_ELEM: true}
         */
        name: '',
        /**
         * The placeholder text to set on the element.
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> attribute:</caption>
         * &lt;oj-input-number placeholder="Enter a number">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
         * // Getter
         * var placeholder = myComponent.placeholder;
         *
         * // Setter
         * myComponent.placeholder = "Address";
         *
         * If the attribute is not set then the default can be a converter hint. See display-options for
         * details.
         *
         * @expose
         * @instance
         * @default ""
         * @memberof oj.ojInputNumber
         * @type {string|null}
         * @ojtranslatable
         */
        placeholder: '',
        /**
         * <p>The <code class="prettyprint">rawValue</code> is the read-only property for retrieving
         * the current value from the input field in string form. The main consumer of
         * <code class="prettyprint">rawValue</code> is a converter.</p>
         * <p>
         * The <code class="prettyprint">rawValue</code> updates on the 'input' javascript event,
         * so the <code class="prettyprint">rawValue</code> changes as the value of the input is changed.
         * If the user types in '1,200' into the field, the rawValue will be '1', then '1,', then '1,2',
         * ..., and finally '1,200'. Then when the user blurs or presses Enter
         * the <code class="prettyprint">value</code> property gets updated.
         * </p>
         * <p>This is a read-only property so page authors cannot set or change it directly.</p>
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc Read-only property used for retrieving the current value from the input field in string form. See the Help documentation for more information.
         * @type {string}
         * @ojsignature {target:"Type", value:"string"}
         * @since 1.2.0
         * @readonly
         * @ojwriteback
         */
        rawValue: undefined,
        /**
         * Whether the component is readonly. The readonly property sets or returns whether an element is readonly, or not.
         * A readonly element cannot be modified. However, a user can tab to it, highlight it, focus on it, and copy the text from it.
         * If you want to prevent the user from interacting with the element, use the disabled property instead.
         * <p>
         * The default value for readonly is false. However, if the form component is a descendent of
         * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
         * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
         * The <code class="prettyprint">oj-form-layout</code> uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">readonly</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the readonly property if an ancestor provides it and
         * it is not explicitly set.
         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
         * not have its readonly attribute set, the form component's readonly will be true.
         * </p>
         * @example <caption>Initialize component with <code class="prettyprint">readonly</code> attribute:</caption>
         * &lt;oj-input-number readonly>&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
         * // Getter
         * var readonly = myComponent.readonly;
         *
         * // Setter
         * myComponent.readonly = false;
         *
         * @default false
         * @access public
         * @expose
         * @type {?boolean}
         * @name readonly
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc Specifies whether the component is read-only.  A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
         */
        readOnly: false,
        /**
         * <p>
         * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
         * This is the default.
         * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
         * </p>
         * <p>
         * In the Redwood theme, by default, a Required text is rendered inline when the field is empty.
         * If user-assistance-density is 'compact', it will show on the label as an icon.
         * In the Alta theme the input's label will render a required icon.
         * </p>
         * <p>The Required error text is based on Redwood UX designs, and it is not recommended that
         * it be changed.
         * To override the required error message,
         * use the <code class="prettyprint">translations.required</code> attribute.
         * The component's label text is passed in as a token {label} and can be used in the message detail.
         * </p>
         * <p>When required is set to true, an implicit
         * required validator is created, i.e.,
         * <code class="prettyprint">new RequiredValidator()</code>. The required validator is the only
         * validator to run during initial render, and its error is not shown to the user at this time;
         * this is called deferred validation. The required validator also runs during normal validation;
         * this is when the errors are shown to the user.
         * See the <a href="#validation-section">Validation and Messaging</a> section for details.
         * </p>
         * <p>
         * When the <code class="prettyprint">required</code> property changes due to programmatic intervention,
         * the component may clear component messages and run validation, based on the current state it's in. </br>
         *
         * <h4>Running Validation when required property changes</h4>
         * <ul>
         * <li>if component is valid when required is set to true, then it runs deferred validation on
         * the value property. If the field is empty, the valid state is invalidHidden. No errors are
         * shown to the user.
         * </li>
         * <li>if component is invalid and has deferred messages when required is set to false, then
         * component messages are cleared (messages-custom messages are not cleared)
         * but no deferred validation is run because required is false.
         * </li>
         * <li>if component is invalid and currently showing invalid messages when required is set, then
         * component messages are cleared and normal validation is run using the current display value.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated and the error is shown.
         *   </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event on the component to clear custom errors.</li>
         * </ul>
         * </li>
         * </ul>
         *
         * <h4>Clearing Messages when required property changes</h4>
         * <ul>
         * <li>Only messages created by the component, like validation messages, are cleared when the required property changes.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
         * </ul>
         *
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">required</code> attribute:</caption>
         * &lt;oj-input-number required>&lt;/oj-input-number><br/>
         *
         * @example <caption>Customize messages and hints used by implicit required validator when
         * <code class="prettyprint">required</code> attribute is set:</caption>
         * &lt;oj-input-number required translations='{"required": {
         *                 "hint": "custom: enter at least 3 alphabets",
         *                 "messageSummary": "custom: \'{label}\' is Required",
         *                 "messageDetail": "custom: please enter a valid value for \'{label}\'"}}'>
         * &lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
         * // getter
         * var rq = myComp.required;
         *
         * // setter
         * myComp.required = false;
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc Specifies whether the component is required or optional. See the Help documentation for more information.
         * @type {boolean}
         * @default false
         * @since 0.7.0
         * @see #translations
         */
        required: false,
        /**
         * The size of the step to take when spinning via buttons or via the up/down arrows or via the
         * <code class="prettyprint">stepUp()</code>/<code class="prettyprint">stepDown()</code> methods.
         * If step is 0, inputNumber will not have buttons or up/down spin functionality.
         * If step is less than 0, an exception is thrown.
         * <p><code class="prettyprint">step</code> defaults to <code class="prettyprint">1</code>
         * in all themes except the redwood theme where it defaults to <code class="prettyprint">0</code>.
         * </p>
         * <p>
         * <p>
         * The <code class="prettyprint">step</code> attribute can be used together
         * with the <code class="prettyprint">min</code> and
         * <code class="prettyprint">max</code> attributes
         * to create a range of values the up/down arrows will step through. For example,
         * if min is 0 and step is 3, the range of values is 0, 3, 6, etc.
         * </p>
         * <p>
         * The up/down arrows will spin the value and adjust it to keep it a
         * 'step match' value.
         * A 'step match' value is when the value is a multiple
         * of <code class="prettyprint">step</code>,
         * starting at the <code class="prettyprint">min</code>, and if
         * <code class="prettyprint">min</code> is not set,
         * then starting at the initial <code class="prettyprint">value</code>,
         * and if neither <code class="prettyprint">min</code> and initial
         * <code class="prettyprint">value</code> are set,
         * then starting at 0.
         * </p>
         * <p>When using step > 1 with min and/or max,
         * make sure the initial value and max are both a 'step match' value,
         * otherwise the first step will adjust the value in a way
         * that could confuse the user.</p>
         * </p>
         * <p>
         * A value can be a step mismatch; if the <code class="prettyprint">value</code> is set
         * to be a step mismatch, it will not be flagged as a validation error.
         * </p>
         * @expose
         * @instance
         * @type {?number}
         * @ojexclusivemin -1
         * @memberof oj.ojInputNumber
         * @ojshortdesc Specifies the amount to increase or decrease the value when moving in step increments. If 0, no step functionality. See the Help documentation for more information.
         * @access public
         * @example <caption>Initialize the inputNumber with the
         * <code class="prettyprint">step</code> attribute specified:</caption>
         * &lt;oj-input-number step="2">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">step</code> property after initialization:</caption>
         * // Getter
         * var step = myComponent.step;
         *
         * // Setter
         * myComponent.step = 5;
         * */
        step: 1,
        /**
         * <p>The <code class="prettyprint">transientValue</code> is the read-only attribute for
         * retrieving the transient value from the component.</p>
         * <p>
         * The <code class="prettyprint">transientValue</code> updates to display the transient
         * changes from pressing the up or down arrow (subject to the step constraints).
         * <code class="prettyprint">transientValue</code> will update only if it passes
         * validation.
         * </p>
         * <p>
         * The difference
         * in behavior is
         * <code class="prettyprint">transientValue</code> will be updated
         * as the up or down arrow is pressed (and only if validation succeeds),
         * whereas <code class="prettyprint">value</code>
         * is updated only after the up or down arrow is released
         * (and only if validation succeeds).
         * </p>
         * <p>This is a read-only attribute so page authors cannot set or change it directly.</p>
         * @expose
         * @access public
         * @instance
         * @default null
         * @memberof oj.ojInputNumber
         * @ojshortdesc Read-only property used for retrieving the transient value from the component. See the Help documentation for more information.
         * @type {?number}
         * @since 6.2.0
         * @readonly
         * @ojwriteback
         *
         */
        transientValue: null,
        /**
         * List of validators, synchronous or asynchronous,
         * used by component along with asynchronous validators from the deprecated async-validators option
         * and the implicit component validators when performing validation. Each item is either an
         * instance that duck types {@link oj.Validator} or {@link oj.AsyncValidator}.
         * <p>
         * Implicit validators are created by the element when certain attributes are present.
         * For example, if the <code class="prettyprint">required</code>
         * attribute is set, an implicit {@link oj.RequiredValidator} is created. If the
         * <code class="prettyprint">min</code> and/or <code class="prettyprint">max</code> attribute
         * is set, an implicit {@link oj.NumberRangeValidator} is created.
         * At runtime when the component runs validation, it
         * combines all the implicit validators with all the validators
         * specified through this <code class="prettyprint">validators</code> attribute
         * and the deprecated <code class="prettyprint">async-validators</code> attribute, and
         * runs all of them.
         * </p>
         * <p>
         * Hints exposed by validators are shown inline by default in the Redwood theme when the
         * field has focus.
         * In the Alta theme, validator hints are shown in a notewindow on focus,
         * or as determined by the
         * 'validatorHint' property set on the <code class="prettyprint">display-options</code>
         * attribute.
         * In either theme, you can turn off showing validator hints by using the
         * 'validatorHint' property set to 'none' on the <code class="prettyprint">display-options</code>
         * attribute.
         * </p>
         * <p>
         * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
         * help.instruction shows; if no help.instruction then validator hints show;
         * if none, then help-hints.definition shows; if none, then converter hint shows.
         * help-hints.source always shows along with the other help or hint.
         * </p>
         *
         * <p>
         * When <code class="prettyprint">validators</code> property changes due to programmatic
         * intervention, the component may decide to clear messages and run validation, based on the
         * current state it is in. </br>
         *
         * <h4>Steps Performed Always</h4>
         * <ul>
         * <li>The cached list of validator instances are cleared and new validator hints are pushed to
         * messaging. E.g., notewindow displays the new hint(s).
         * </li>
         * </ul>
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>if component is valid when validators changes, component does nothing other than the
         * steps it always performs.</li>
         * <li>if component is invalid and is showing messages when
         * <code class="prettyprint">validators</code> or
         * <code class="prettyprint">async-validators</code> changes then all component messages
         *  are cleared and full validation run using the display value on the component.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated and the error is shown.
         *   </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event to clear custom errors.</li>
         * </ul>
         * </li>
         * <li>if component is invalid and has deferred messages when validators changes, it does
         * nothing other than the steps it performs always.</li>
         * </ul>
         * </p>
         *
         * <h4>Clearing Messages</h4>
         * <ul>
         * <li>Only messages created by the component are cleared.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
         * </ul>
         * </p>
         * <br/>
         *
         * @example <caption>Initialize the component with a Validator instance:</caption>
         * &lt;oj-input-number validators='[[[myRegExpValidator]]]'>
         * &lt;/oj-input-number>
         * self.myRegExpValidator = new RegExpValidator({
         *   pattern: "[a-zA-Z0-9]{3,}",
         *   messageDetail: "You must enter at least 3 letters or numbers"});
         * @example <caption>Initialize the component with a custom validator:</caption>
         * // A custom validator whose validate method, ensures that the value is not 100.
         * self.no100Validator = {
         *   'validate' : function (value) {
         *      value = value + "";
         *      if (value === 100) {
         *        throw new Error("You cannot enter a value that is 100!!");
         *      }
         *      return true;
         *    },
         *    'getHint': function() {
         *       return null;
         *    }
         *  };
         * ...
         * HTML
         * ----
         * &lt;oj-input-number validators='[[[no100Validator,someOtherValidator]]]'>
         * &lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">validators</code> property after initialization:</caption>
         * // getter
         * var validators = myComp.validators;
         *
         * // setter
         * myComp.validators = myValidators;
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc Specifies a list of validators for performing validation by the element. See the Help documentation for more information.
         * @ojsignature  [{ target: "Type",
         *       value: "Array<oj.Validator<number>|oj.AsyncValidator<number>",
         *       jsdocOverride: true},
         * { target: "Type",
         *       value: "Array<oj.Validator<number>|oj.AsyncValidator<number>|
         *       oj.Validation.RegisteredValidator>",
         *       consumedBy: 'tsdep'}]
         * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredValidator'],
         *                description: 'Defining a validator with an object literal with validator type and
         *                  its options (aka JSON format) has been deprecated and does nothing. If needed, you can
         *                  make the JSON format work again by importing the deprecated ojvalidation-number module.'}
         * @type {Array.<Object>}
         * @default []
         */

        validators: [],
        /**
         * The value of the component. Value must be a number or null.
         *
         * <p>
         * When <code class="prettyprint">value</code> property changes due to programmatic
         * intervention, the component always clears all messages
         * including <code class="prettyprint">messagesCustom</code>, runs deferred validation, and
         * always refreshes UI display value.</br>
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>component always runs deferred validation; if there is a validation error the
         * <code class="prettyprint">valid</code> property is updated.</li>
         * </ul>
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">value</code> attribute specified:</caption>
         * &lt;oj-input-number value='10'>&lt;/oj-input-number>
         * @example <caption>Get or set <code class="prettyprint">value</code> attribute, after initialization:</caption>
         * // Getter: returns 10
         * var val = myComp.value;
         * // Setter: sets 20
         * myComp.value = 20;
         *
         * @expose
         * @access public
         * @instance
         * @default null
         * @ojwriteback
         * @ojeventgroup common
         * @memberof oj.ojInputNumber
         * @ojshortdesc The value of the component, which must be either a number or null. See the Help documentation for more information.
         * @type {?number}
         */
        value: null,
        /**
         * The type of virtual keyboard to display for entering a value on mobile browsers. This attribute has no effect on desktop browsers.
         * @example <caption>Initialize the component with the <code class="prettyprint">virtual-keyboard</code> attribute:</caption>
         * &lt;oj-input-number virtual-keyboard="number">&lt;/oj-input-number>
         *
         * @example <caption>Get or set the <code class="prettyprint">virtualKeyboard</code> property after initialization:</caption>
         * // Getter
         * var virtualKeyboard = myComp.virtualKeyboard;
         *
         * // Setter
         * myComp.virtualKeyboard = "number";
         *
         * @expose
         * @instance
         * @memberof oj.ojInputNumber
         * @ojshortdesc The type of virtual keyboard to display for entering a value on mobile browsers. See the Help documentation for more information.
         * @type {string}
         * @ojvalue {string} "auto" The component will determine the best mobile virtual keyboard to use. For example, it may look at the converter's resolvedOptions
         *                          to determine if it formats using non-numeric characters or not. If it formats using non-numeric characters, like oj-input-number's default
         *                          converter for 'en-US' loocale (1000 formats to "1,000"), then it will use "text".
         * @ojvalue {string} "number" Use a mobile virtual keyboard for entering numbers. If using "number", you must set the converter attribute to a converter
         *                            that formats to numeric characters only, otherwise the value will not be shown. The reason for this
         *                            is oj-input-number uses the browser native input type='number'  and when you set an input value that contains a non-numeric character,
         *                              browsers do not display the value. For example, "1,000" would not be shown. And oj-input-number's default converter for 'en-US' locale formats using non-numeric characters, e.g., 1000 formats to "1,000".
         *                            <p>Note that on Android and Windows Mobile, the "number" keyboard does
         *                            not contain the minus sign.  This value should not be used on fields that
         *                            accept negative values.</p>
         * @ojvalue {string} "text" Use a mobile virtual keyboard for entering text.
         * @default "auto"
         * @since 5.0.0
         */
        virtualKeyboard: 'auto'

        // Events

        /**
         * Triggered when the ojInputNumber is created.
         *
         * @event
         * @name create
         * @memberof oj.ojInputNumber
         * @instance
         * @property {Event} event event object
         * @property {Object} ui Currently empty
         * @ignore
         *
         * @example <caption>Initialize the ojInputNumber with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojInputNumber({
         *     "create": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
      },
      // P U B L I C    M E T H O D S

      getNodeBySubId: function (locator) {
        var node = this._superApply(arguments);
        var subId;
        if (!node) {
          subId = locator.subId;
          if (subId === 'oj-inputnumber-up') {
            node = this.widget()[0].querySelector('.oj-inputnumber-up');
          }
          if (subId === 'oj-inputnumber-down') {
            node = this.widget()[0].querySelector('.oj-inputnumber-down');
          }
          if (subId === 'oj-inputnumber-input') {
            node = this.widget()[0].querySelector('.oj-inputnumber-input');
          }
        }
        // Non-null locators have to be handled by the component subclasses
        return node || null;
      },
      getSubIdByNode: function (node) {
        var subId = null;

        if (node != null) {
          if (node === this.widget()[0].querySelector('.oj-inputnumber-up')) {
            subId = { subId: 'oj-inputnumber-up' };
          } else if (node === this.widget()[0].querySelector('.oj-inputnumber-down')) {
            subId = { subId: 'oj-inputnumber-down' };
          } else if (node === this.widget()[0].querySelector('.oj-inputnumber-input')) {
            subId = { subId: 'oj-inputnumber-input' };
          }
        }

        return subId || this._superApply(arguments);
      },
      /**
       * Refreshes the inputNumber component
       * <p>A <code class="prettyprint">refresh()</code> or re-init is required
       * when an inputNumber is changed in a non-option way, like in the following circumstances:
       * <ul>
       *   <li>Button translations change.</li>
       * </ul>
       * @expose
       * @memberof oj.ojInputNumber
       * @ojshortdesc Refreshes the component.
       * @access public
       * @instance
       * @return {void}
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myComp.refresh();
       */
      refresh: function () {
        this._super();
        this._setup();
      },
      /**
       * <p>Decrements the value by the specified number of steps.
       * Without the parameter, a single step is decremented. One step is
       * defined by the component's step property.
       * If the component's step property is 0, the stepDown method is a no-op.</p>
       * <p>If the resulting value is above the max, below the min,
       * or results in a step mismatch, the value will be adjusted to the closest valid value.</p>
       * @param {number=} steps - Number of steps to decrement, defaults to 1.
       * @return {void}
       * @expose
       * @instance
       * @memberof oj.ojInputNumber
       * @ojshortdesc Decrements the value by the specified number of steps. See the Help documentation for more information.
       * @access public
       * @example <caption>Invoke the <code class="prettyprint">stepDown</code> method:</caption>
       * myComp.stepDown();
       * @ojdeprecated {since: '14.0.0', description: 'Programmatically change the value instead.'}
       */
      stepDown: function (steps) {
        var step = this.options.step;
        if (step === 0) {
          return;
        }
        var realStep = (steps != null ? steps : 1) * step * -1;
        this._step(realStep);
      },
      /**
       * <p>Increments the value by the specified number of steps.
       * Without the parameter, a single step is incremented. One step is
       * defined by the component's step property.
       * If the component's step property is 0, the stepUp method is a no-op.</p>
       * <p>If the resulting value is above the max, below the min,
       * or results in a step mismatch, the value will be adjusted to the closest valid value.</p>
       * @param {number=} steps - Number of steps to increment, defaults to 1.
       * @return {void}
       * @expose
       * @instance
       * @memberof oj.ojInputNumber
       * @ojshortdesc Increments the value by the specified number of steps. See the Help documentation for more information.
       * @access public
       * @example <caption>Invoke the <code class="prettyprint">stepUp</code> method:</caption>
       * myComp.stepUp();
       * @ojdeprecated {since: '14.0.0', description: 'Programmatically change the value instead.'}
       */
      stepUp: function (steps) {
        var step = this.options.step;
        if (step === 0) {
          return;
        }
        var realStep = (steps != null ? steps : 1) * step;
        this._step(realStep);
      },

      /**
       * Returns a jQuery object containing the element visually representing the inputnumber.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @memberof oj.ojInputNumber
       * @instance
       * @return {jQuery} the inputnumber
       * @access public
       * @ignore
       */
      widget: function () {
        return $(this.uiInputNumber);
      },

      // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

      // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********

      /**
       * Called at component create time primarily to initialize options, often using DOM values. This
       * method is called before _ComponentCreate is called, so components that override this method
       * should be aware that the component has not been rendered yet. The element DOM is available and
       * can be relied on to retrieve any default values. <p>
       * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors.
       * For example, if we have the step attribute defaulted to 12 in this class, it will be 12. (unless there
       * is some global default on the component ?)
       * @param {?Object} constructorOptions - options passed into the widget constructor
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        var opts = this.options;
        var self = this;

        // call super class with arguments: originalDefaults and constructorOptions. It will set
        // the this.options.
        this._superApply(arguments);

        if (!this._IsCustomElement()) {
          // 'props' is the list of properties that I need to get from the dom if they aren't already defined in the options.
          // There is no need to list defaults here like we used to do
          // since the defaults are in originalDefaults and they are merged in with the options in the this._superApply call.

          // attribute below is the html-5 dom attribute name. If 'option' is different, like in the case of
          // readonly (readonly html vs readOnly (camelcase) component option), specify both.
          var props = [
            { attribute: 'disabled', validateOption: true },
            { attribute: 'placeholder' },
            { attribute: 'value' }, // don't coerce here. I do it myself
            { attribute: 'readonly', option: 'readOnly', validateOption: true },
            { attribute: 'required', coerceDomValue: true, validateOption: true },
            { attribute: 'title' },
            { attribute: 'min' },
            { attribute: 'max' },
            { attribute: 'step' }
          ];

          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(
            props,
            constructorOptions,
            this,
            // post-process callback
            function (initializedOptions) {
              // coerce regardless of where the option value came from - dom/constructor
              var toParse = ['value', 'step', 'min', 'max'];

              for (var i = 0; i < toParse.length; i++) {
                var opt = toParse[i];
                var value = opt in initializedOptions ? initializedOptions[opt] : opts[opt];
                if (value != null) {
                  if (opt === 'step') {
                    // eslint-disable-next-line no-param-reassign
                    initializedOptions[opt] = self._parseStep(value);
                  } else {
                    // eslint-disable-next-line no-param-reassign
                    initializedOptions[opt] = self._parse(opt, value);
                  }
                }
              }
            }
          );
        }

        // The custom element bridge framework coerces the options according to the options
        // @type, so there is no need to do the coercion in _InitOptions
        // for custom elements like we do above for non-custom-elements.
        // Check the 'step' to make sure it's in the correct range.
        if (this._IsCustomElement()) {
          // this will coerce with a + and throw an error if it is < 0.
          // since the bridge framework code already coerced step to a number before _InitOptions
          // was called, all we care about is throwing an error if step < 0.
          self._parseStep(opts.step);
        }

        this.initialValue = opts.value;

        // now make sure min < max, else throw an Error
        if (opts.min != null && opts.max != null) {
          if (opts.max < opts.min) {
            throw new Error("ojInputNumber's max must not be less than min");
          }
        }
      },
      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @override
       * @protected
       * @instance
       * @memberof oj.ojInputNumber
       */
      _ComponentCreate: function () {
        this._super();

        this._draw();

        this._inputNumberDefaultValidators = {};
        this._setup();
        this._registerEvents();
        this._focusable({
          element: $(this.uiInputNumber),
          applyHighlight: true
        });
      },
      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @override
       * @protected
       * @instance
       * @memberof oj.ojInputNumber
       * @return {void}
       */
      _AfterCreate: function () {
        this._super();

        // Initialize transientValue to be the same as value upon component creation
        var context = { writeback: true, internalSet: true, readOnly: true };
        this.option({ transientValue: this.options.value }, { _context: context });

        this._refreshAriaMinMax();
        // buttons and aria-valuenow and aria-valuetext are updated in _Refresh for value which
        // is called from EditableValue's _AfterCreate.
        this.stepQueue = [];
        this._blurEnterSetValueCounter = 0;
        if (this._IsCustomElement()) {
          let labelledBy = this.options.labelledBy;
          this._initInputIdLabelForConnection(
            this._GetContentElement()[0],
            this.widget()[0].id,
            labelledBy
          );
        }
        // create a readonly div. This also sets the div's textContent with
        // the converted display value, which is why this is in _AfterCreate.
        if (this.options.readOnly) {
          this._createOrUpdateReadonlyDiv(this.element[0]);
        }
      },

      /**
       * Performs post processing after _SetOption() is called. Different options when changed perform
       * different tasks. See _AfterSetOption[OptionName] method for details.
       *
       * @param {string} option
       * @param {Object|string=} previous
       * @param {Object=} flags
       * @protected
       * @memberof oj.ojInputNumber
       * @instance
       * @override
       */
      // eslint-disable-next-line no-unused-vars
      _AfterSetOption: function (option, previous, flags) {
        this._superApply(arguments);
        switch (option) {
          case 'min':
          case 'max':
            this._Refresh(option, this.options[option]);
            break;
          case 'readOnly':
            this._AfterSetOptionDisabledReadOnly(option, ojeditablevalue.EditableValueUtils.readOnlyOptionOptions);
            break;
          case 'required':
            this._AfterSetOptionRequired(option);
            break;
          case 'validators':
            this._AfterSetOptionValidators(option);
            break;
          case 'asyncValidators':
            this._AfterSetOptionAsyncValidators(option);
            break;
          case 'converter':
            this._AfterSetOptionConverter(option);
            break;
          case 'virtualKeyboard':
            this._SetInputType(this._ALLOWED_TYPES);
            break;
          default:
            break;
        }
      },
      /**
       * Whether the a value can be set on the component. For example, if the component is
       * disabled or readOnly then setting value on component is a no-op.
       *
       * @see #_SetValue
       * @return {boolean}
       * @memberof oj.ojInputNumber
       * @override
       * @instance
       * @protected
       */
      _CanSetValue: function () {
        var readOnly;
        var superCanSetValue = this._super();

        if (!superCanSetValue) {
          return false;
        }

        readOnly = this.options.readOnly || false;
        return !readOnly;
      },
      /**
       * Performs post processing after value option changes by taking the following steps.
       * This method piggybacks on the super's method by using the 'doNotClearMessages' flag to
       * determine if this was a direct value option programmatic change.
       *
       * - Calls super<br/>
       * - if setOption was from programmatic intervention, <br/>
       * &nbsp;&nbsp;- reset the this.initialValue which is used to determine the stepBase; <br/>
       *
       * @param {string} option
       * @param {Object=} flags
       *
       * @protected
       * @memberof oj.ojInputNumber
       * @instance
       *
       */
      _AfterSetOptionValue: function (option, flags) {
        this._superApply(arguments);
        var context = flags ? flags._context : null;
        var isUIValueChange;
        var doNotClearMessages;

        if (context) {
          isUIValueChange = !!context.originalEvent;
          doNotClearMessages = context.doNotClearMessages || false;
        }

        if (!isUIValueChange) {
          // value option can be updated directly (i.e., programmatically or through user interaction)
          // or updated indirectly as a result of some other option changing - e.g., converter,
          // validators, required etc.
          // When value changes directly due to programatic intervention (usually page author does this)
          // then update this.initialValue.
          if (!doNotClearMessages) {
            this.initialValue = this.options.value;
          }
        }
      },
      /**
       * Called when the display value on the element needs to be updated. This method updates the
       * (content) element value. Widgets can override this method to update the element
       * appropriately.
       *
       * @param {string} displayValue the new string to be displayed
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _SetDisplayValue: function (displayValue) {
        this._superApply(arguments);
        if (this.options.readOnly) {
          let readonlyElem = this._getReadonlyDiv();
          if (readonlyElem) {
            // need to set the textContent on its child
            readonlyElem.textContent = displayValue;
          }
        }
      },

      /**
       * Whether the component is required.
       *
       * @return {boolean} true if required; false
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       * @override
       */
      _IsRequired: function () {
        return this.options.required;
      },
      /**
       * Performs post processing after required option is set by taking the following steps.
       *
       * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
       * run full validation with UI value (we don't know if the UI error is from a required validator
       * or something else);<br/>
       * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
       * updated<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to optionChange(value) to clear custom errors.<br/>
       *
       * - if component is invalid and has messagesHidden -> required: false -> clear component
       * errors; no deferred validation is run.<br/>
       * - if component has no error -> required: true -> run deferred validation (we don't want to flag
       * errors unnecessarily)<br/>
       * - messagesCustom is never cleared<br/>
       *
       * @param {string} option
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _AfterSetOptionRequired: ojeditablevalue.EditableValueUtils._AfterSetOptionRequired,
      /**
       * When validators option changes, take the following steps.
       *
       * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
       * - if component is valid -> validators changes -> no change<br/>
       * - if component is invalid has messagesShown -> validators changes -> clear all component
       * messages and re-run full validation on displayValue. if there are no errors push value to
       * model;<br/>
       * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
       * the required-ness of component <br/>
       * - messagesCustom is not cleared.<br/>
       *
       * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern,
       * etc. Components can call this method when these options change.
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _AfterSetOptionValidators: ojeditablevalue.EditableValueUtils._AfterSetOptionValidators,
      /**
       * When async-validators attribute changes, take the following steps.
       *
       * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
       * - if component is valid -> validators changes -> no change<br/>
       * - if component is invalid has messagesShown -> validators changes -> clear all component
       * messages and re-run full validation on displayValue. if there are no errors push value to
       * model;<br/>
       * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
       * the required-ness of component <br/>
       * - messagesCustom is not cleared.<br/>
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _AfterSetOptionAsyncValidators: ojeditablevalue.EditableValueUtils._AfterSetOptionAsyncValidators,
      /**
       * Performs post processing after converter option changes by taking the following steps.
       *
       * - always push new converter hint to messaging <br/>
       * - if component has no errors -> refresh UI value<br/>
       * - if component is invalid has messagesShown -> clear all component errors and run full
       * validation using display value. <br/>
       * &nbsp;&nbsp;- if there are validation errors, value is not pushed to model; messagesShown is
       * updated.<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to optionChange(value) to clear custom errors.<br/>
       * - if component is invalid has messagesHidden -> refresh UI value. no need to run deferred
       * validations. <br/>
       * - messagesCustom is never cleared<br/>
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _AfterSetOptionConverter: ojeditablevalue.EditableValueUtils._AfterSetOptionConverter,
      /**
       * Called when converter option changes and we have gotten the new converter
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _ResetConverter: ojeditablevalue.EditableValueUtils._ResetConverter,

      /**
       * This method also updates the messaging strategies as hints associated with validators could
       * have changed.
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _ResetAllValidators: function () {
        this._inputNumberDefaultValidators = {};

        this._superApply(arguments);
      },

      // *********** END WIDGET FACTORY METHODS **********
      /**
       * Need to override since we allow users to set the converter to null, undefined, and etc and when
       * they do we use the default converter
       *
       * @return {Object} a converter instance or null
       *
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       * @override
       */
      _GetConverter: function () {
        if (this.options.converter) {
          return this._getConverter();
        }
        return _getNumberDefaultConverter();
      },
      /**
       * This returns an array of all validators
       * normalized from the validators option set on the component. <br/>
       * @return {Array} of validators.
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _GetNormalizedValidatorsFromOption: ojeditablevalue.EditableValueUtils._GetNormalizedValidatorsFromOption,
      /**
       * This returns an array of all async validators
       * normalized from the async-validators attribute set on the component. <br/>
       * @return {Array} of validators.
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _GetNormalizedAsyncValidatorsFromOption:
        ojeditablevalue.EditableValueUtils._GetNormalizedAsyncValidatorsFromOption,
      /**
       * Called to find out if aria-required is unsupported.
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       */
      _AriaRequiredUnsupported: function () {
        return false;
      },
      /**
       * Handles options specific to inputnumber.
       * Note that _setOption does not get called during create in the super class.
       * It only gets called when the component has already been created.
       * However, we do call _setOption in _draw for certain attributes
       * (disabled)
       * @override
       * @protected
       * @memberof oj.ojInputNumber
       */
      _setOption: function (key, value, flags) {
        var coercedValue;

        if (!this._IsCustomElement() && (key === 'value' || key === 'max' || key === 'min')) {
          // we only have to coerce for non-custom-elements since the frameworkd coerces for us for
          // custom elements.
          coercedValue = this._parse(key, value);
        } else if (key === 'step') {
          coercedValue = this._parseStep(value);
        } else if (key === 'transientValue') {
          // transientValue is readOnly, so throw an error and return.
          Logger.error(key + ' option cannot be set');
          return;
        } else {
          coercedValue = value;
        }

        // the superclass calls _Refresh. Our _Refresh calls _updateButtons
        // and refreshes aria-valuenow/valuetext/valuemin/valuemax
        // call _super with the newly coerced 'value' property.
        this._super(key, coercedValue, flags);

        if (key === 'value') {
          // Set transientValue to be the same if value is set programmatically
          var context = { writeback: true, internalSet: true, readOnly: true };
          this.option({ transientValue: this.options.value }, { _context: context });
        }

        if (key === 'max' || key === 'min') {
          // since validators are immutable, they will contain min + max as local values.
          // Because of this will need to recreate the Implicit NumberRange validators.
          // This resets validators and async-validators and runs validation
          this._AfterSetOptionValidators();
        }

        // when a dom element supports disabled, use that, and not aria-disabled.
        // having both is an error.
        // having aria-disabled on root dom element is ok (if it is added in base class)
        if (key === 'disabled') {
          // force it to be a boolean. this is what/how ojbutton, EditableValue does.
          this.element[0].disabled = !!value;
        }
        // when a dom element supports readonly, use that, and not aria-readonly.
        // having both is an error
        if (key === 'readOnly') {
          // if readonly, we remove buttons/spinner functionality.
          this._createOrDestroyOjButtonset();
          this.element[0].readOnly = !!value;
          if (value) {
            this._createOrUpdateReadonlyDiv(this.element[0]);
          }
          this._refreshStateTheming('readOnly', this.options.readOnly);
        }
        if (key === 'step') {
          // if step is 0, we remove buttons/spinner functionality.
          this._createOrDestroyOjButtonset();
        }
        if (key === 'labelledBy') {
          let labelledBy = this.options.labelledBy;
          if (labelledBy) {
            var id = this._GetContentElement()[0].id;
            this._labelledByUpdatedForInputComp(labelledBy, id);
          }
        }
      },
      /**
       * Override of protected base class method.
       * Method name needn't be quoted since is in externs.js.
       * @protected
       * @memberof oj.ojInputNumber
       * @instance
       */
      _destroy: function () {
        var ret = this._super();

        // destroy the buttonset
        if (this.buttonSet) {
          this._destroyOjButtonset();
        }
        this.initialValue = null;
        this.element.off('blur keydown keyup compositionstart compositionend input');
        //  - DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout
        DomUtils.unwrap(this.element, $(this.uiInputNumber));
        clearTimeout(this.timer);

        return ret;
      },

      /**
       * Validates the component's display value using the converter and all validators registered on
       * the component and updates the <code class="prettyprint">value</code> option by performing the
       * following steps.
       *
       * <p>
       * <ol>
       * <li>All messages are cleared, including custom messages added by the app. </li>
       * <li>If no converter is present then processing continues to next step. If a converter is
       * present, the UI value is first converted (i.e., parsed). If there is a parse error then
       * the messages are shown.</li>
       * <li>If there are no validators setup for the component the <code class="prettyprint">value</code>
       * option is updated using the display value. Otherwise all
       * validators are run in sequence using the parsed value from the previous step. The implicit
       * required validator is run first if the component is marked required. When a validation error is
       * encountered it is remembered and the next validator in the sequence is run. </li>
       * <li>At the end of validation if there are errors, the messages are shown.
       * If there were no errors, then the
       * <code class="prettyprint">value</code> option is updated.</li>
       * </ol>
       *
       * @example <caption>Validate component using its current value.</caption>
       * // validate display value and shows messages if there are any to be shown.
       * myComp.validate();
       * @example <caption>Validate component and use the Promise's resolved state.</caption>
       * myComp.validate().then(
       *  function(result) {
       *    if(result === "valid")
       *    {
       *      submitForm();
       *    }
       *  });
       * @return {Promise.<string>} Promise resolves to "valid" if there were no converter parse errors and
       * the component passed all validations.
       * The Promise resolves to "invalid" if there were converter parse errors or
       * if there were validation errors.
       *
       *
       * @method
       * @access public
       * @expose
       * @instance
       * @memberof oj.ojInputNumber
       * @ojshortdesc Validates the component's display value using all validators registered on the component. If there are no validation errors. then the value is updated. See the Help documentation for more information.
       * @since 4.0.0
       *
       */
      validate: ojeditablevalue.EditableValueUtils.validate,
      /**
       * Used for explicit cases where the component needs to be refreshed
       * (e.g., when the value option changes or other UI gestures).
       * @override
       * @protected
       * @memberof oj.ojInputNumber
       */
      // eslint-disable-next-line no-unused-vars
      _Refresh: function (name, value, forceDisplayValueRefresh) {
        var valuenow;

        this._superApply(arguments);

        switch (name) {
          case 'value':
            valuenow = this.options.value || 0;
            // this gets called after value option changes, so no need to convert
            // the display value.
            this._updateButtonsAria(valuenow);

            break;

          case 'disabled':
            // We have often said in the JET team that
            // it makes no sense for an app to disable an invalid value, so it's fine that we
            // do not use the converted display value here and instead use this.options.value
            // which is the valid value.
            valuenow = this.options.value || 0;
            this._updateButtons(valuenow);
            break;

          case 'max':
          case 'min':
            // It is possible that the value is invalid, like 'foo',
            // when the app dev changes the min/max
            // values, so need to use the converted display value instead of this.options.value
            // which is the last valid value. This way the buttons will be disabled if
            // the converted display value is invalid and valuenow is undefined.
            this._refreshAriaMinMax();
            valuenow = this._getDisplayValueParsed();
            // disables or enables both the up and down buttons depending upon what the value
            // is on the screen after conversion plus what min/max are set to.
            this._updateButtons(valuenow);

            break;

          case 'converter':
            // we refresh the display value in super.
            valuenow = this.options.value;
            this._refreshAriaText(valuenow);
            break;

          case 'required':
            this._refreshRequired(value);
            break;

          default:
            break;
        }
      },
      /**
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      _labelledByUpdatedForInputComp: ojeditablevalue.EditableValueUtils._labelledByUpdatedForInputComp,
      /**
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      _initInputIdLabelForConnection: ojeditablevalue.EditableValueUtils._initInputIdLabelForConnection,
      /**
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      /**
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      _linkLabelForInputComp: ojeditablevalue.EditableValueUtils._linkLabelForInputComp,
      /**
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      _refreshRequired: ojeditablevalue.EditableValueUtils._refreshRequired,

      /**
       * Sets up a synchronous numberRange validator if min and max is set and the
       * RangeValidator was overridden by a sync validator.
       *
       * If the validator is created, it is added to the
       * this._inputNumberDefaultValidators type->validator instance map
       *
       * @ignore
       * @protected
       * @override
       * @instance
       * @memberof oj.ojInputNumber
       * @return {Object} returns the implicit sync validators map, where the key is the sync
       * validator type, e.g., 'numberrange'.
       */
      _GetImplicitValidators: function () {
        var ret = this._superApply(arguments);

        if (this.options.min != null || this.options.max != null) {
          this._inputNumberDefaultValidators.numberrange = this._getImplicitNumberRangeValidator();
        }

        return Object.assign(this._inputNumberDefaultValidators, ret);
      },

      /**
       * Returns the default styleclass for the component.
       *
       * @return {string}
       * @memberof oj.ojInputNumber
       * @override
       * @protected
       */
      _GetDefaultStyleClass: function () {
        return 'oj-inputnumber';
      },

      /**
       * This gets called if/when the converter is loading.
       * We do not want to set the oj-input-number's readonly attribute,
       * but we do want the UI of readonly. The buttonset may be rendered,
       * but in theming it is set display:none if oj-read-only is there.
       * This is preferred for this scenario over removing the buttonset dom
       * only to add it back again when loading is compolete.
       * @protected
       * @override
       * @instance
       * @memberof oj.ojInputNumber
       */
      _SetLoading: function () {
        this._super();
        var readOnly = true;

        this.element[0].readOnly = readOnly;
        // removes role spinbutton while loading
        this._refreshRoleSpinbutton(!readOnly);
      },

      /**
       *
       * @protected
       * @override
       * @instance
       * @memberof oj.ojInputNumber
       */
      _ClearLoading: function () {
        this._super();
        var readOnly = this.options.readOnly;
        this.element[0].readOnly = readOnly;
      },

      /**
       * Returns if the element is a text field element or not.
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       * @return {boolean}
       */
      _IsTextFieldComponent: function () {
        return true;
      },

      /**
       * Returns the components wrapper under which label needs to be inserted in the inside strategy
       * For input number we need the label to go under the span so that it occupies the same width
       * as the input text giving way to the buttons.
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       * @return {Element|undefined}
       */
      _GetContentWrapper: function () {
        if (this._IsCustomElement()) {
          return this._getRootElement().querySelector('.oj-text-field-middle');
        }
        return undefined;
      },

      /**
       * Return the element on which aria-label can be found.
       * Usually this is the root element, but some components have aria-label as a transfer attribute,
       * and aria-label set on the root element is transferred to the inner element.
       * @memberof! oj.ojInputNumber
       * @instance
       * @protected
       */
      _GetAriaLabelElement: function () {
        return this.element[0];
      },

      // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S
      //
      // Subclasses should not override or call these methods
      /**
       * @private
       * @const
       * @memberof oj.ojInputNumber
       */
      _BUNDLE_KEY: {
        _TOOLTIP_DECREMENT: 'tooltipDecrement',
        _TOOLTIP_INCREMENT: 'tooltipIncrement'
      },
      /**
       * when below listed options are passed to the component, corresponding CSS will be toggled
       * @private
       * @const
       * @memberof oj.ojInputNumber
       * @type {Object}
       */
      _OPTION_TO_CSS_MAPPING: {
        readOnly: 'oj-read-only'
      },
      /**
       * Returns the numberRange validator instance.
       * @private
       * @memberof oj.ojInputNumber
       */
      _getImplicitNumberRangeValidator: function () {
        var numberRangeValidatorOptions = this._createRangeValidatorOptions();
        var rangeValidator = new NumberRangeValidator(numberRangeValidatorOptions);

        return rangeValidator;
      },
      /**
       * _setup is called on create and refresh.
       * @private
       * @memberof oj.ojInputNumber
       */
      _setup: function () {
        // we only render buttons if not readonly and step > 0.
        var needsButtonset = this._needsButtonset();
        if (needsButtonset) {
          // add/update translated strings to buttons
          var incrementString = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_INCREMENT);
          var decrementString = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_DECREMENT);
          this.upButton.ojButton({ label: incrementString });
          this.downButton.ojButton({ label: decrementString });
        }
        // update element DOM for readOnly
        if (typeof this.options.readOnly === 'boolean') {
          this.element[0].readOnly = this.options.readOnly;
        }
        this._refreshStateTheming('readOnly', this.options.readOnly);
        this._refreshRoleSpinbutton(needsButtonset);
        this._refreshRequired(this.options.required);
      },
      // Mark internal JET components for automation support. The automation
      // support needs to know while traversing the nodes that the JET button/buttonset
      // is not the root JET component, but an internal node to a JET component.
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _markInternalComponents: function () {
        this.upButton[0].setAttribute('data-oj-internal', '');
        this.downButton[0].setAttribute('data-oj-internal', '');
        this.buttonSet[0].setAttribute('data-oj-internal', '');
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _createOjButtonset: function () {
        var buttonSetObj = this._createButtonset();
        this.inputNumberWrapper.appendChild(buttonSetObj.buttonSet); // @HTMLUpdateOK

        // As the buttons are not in the keyboard sequence at first
        // we decided it makes sense to add aria-hidden="true" to them
        // and rely on the up/down arrow keys. However, now we decided to remove aria-hidden because
        // in voiceover there is no way to access the up/down buttons otherwise.
        // Still, voiceover is broken due to this webkit bug
        //  - ios: input number doesn't support vo because of webkit bug
        var buttons = this.uiInputNumber.querySelectorAll('.oj-inputnumber-button');
        var len = buttons.length;
        for (var i = 0; i < len; i++) {
          buttons[i].setAttribute('tabindex', '-1');
          buttons[i].setAttribute('aria-hidden', 'true');
        }

        const buttonChromingDefault =
          ThemeUtils.getCachedCSSVarValues([
            '--oj-private-input-number-button-global-chroming-default'
          ])[0] || 'solid';
        var buttonsetDiv = buttonSetObj.upButton.parentNode;
        this.upButton = $(buttonSetObj.upButton).ojButton({
          display: 'icons',
          chroming: buttonChromingDefault,
          label: this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_INCREMENT),
          icons: { start: 'oj-component-icon oj-inputnumber-up-icon' }
        });
        this.downButton = $(buttonSetObj.downButton).ojButton({
          display: 'icons',
          chroming: buttonChromingDefault,
          label: this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_DECREMENT),
          icons: { start: 'oj-component-icon oj-inputnumber-down-icon' }
        });
        this.buttonSet = $(buttonsetDiv).ojButtonset({
          focusManagement: 'none',
          chroming: buttonChromingDefault
        });
        this._markInternalComponents();
      },
      /**
       * destroys the ojButtonset
       * @private
       * @memberof oj.ojInputNumber
       */
      _destroyOjButtonset: function () {
        this.buttonSet.ojButtonset('destroy');
        this.buttonSet.remove();
        this.upButton = null;
        this.downButton = null;
        this.buttonSet = null;
      },
      /**
       * creates or destroys buttonset and adds or removes role=spinbutton.
       * Called when we toggle readonly or step
       * @private
       * @memberof oj.ojInputNumber
       */
      _createOrDestroyOjButtonset: function () {
        let needsButtonset = this._needsButtonset();
        // Create or destroy buttonset
        if (needsButtonset && this.buttonSet == null) {
          this._createOjButtonset();
          this._updateButtons(this.options.value || 0);
          this.uiInputNumber.classList.add('oj-has-buttons');
        } else if (!needsButtonset && this.buttonSet) {
          this._destroyOjButtonset();
          this.uiInputNumber.classList.remove('oj-has-buttons');
        }
        // when there is no step, we remove the 'spinbutton' role and aria-value attributes.
        // when there is a step, we add the 'spinbutton' role and aria-value attributes.
        this._refreshRoleSpinbutton(needsButtonset);
        this._refreshAriaMinMax();
        this._toggleAriaValueNowText();
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _draw: function () {
        var element = this.element[0];

        element.classList.add('oj-inputnumber-input');
        element.classList.add('oj-text-field-input');
        var spanElem = document.createElement('span');
        spanElem.className = 'oj-inputnumber-wrapper';
        this.inputNumberWrapper = spanElem;
        this.uiInputNumber = spanElem;

        var containerElem = document.createElement('div');
        containerElem.className = 'oj-text-field-container';
        containerElem.setAttribute('role', 'presentation');

        // only custom element will have an OuterWrapper
        if (this.OuterWrapper) {
          containerElem.appendChild(spanElem);

          var middleWrapper = this._CreateMiddleWrapper();
          spanElem.appendChild(middleWrapper);

          middleWrapper.appendChild(element);

          this.OuterWrapper.appendChild(containerElem); // @HTMLUpdateOK
          this.uiInputNumber = this.OuterWrapper;
          this.uiInputNumber.classList.add('oj-inputnumber');
          this.uiInputNumber.classList.add('oj-component');
        } else {
          var divElem = document.createElement('div');
          divElem.className = 'oj-inputnumber oj-component';
          element.parentNode.insertBefore(divElem, element); // @HTMLUpdateOK
          divElem.appendChild(containerElem); // @HTMLUpdateOK
          containerElem.appendChild(spanElem); // @HTMLUpdateOK
          spanElem.appendChild(element); // @HTMLUpdateOK
          this.uiInputNumber = divElem;
        }

        //
        // TODO: need to save off attributes and reset on destroy generically.
        this.saveType = element.type;
        this._SetInputType(this._ALLOWED_TYPES);

        // Won't create buttons if readonly or if step is 0.
        if (this._needsButtonset()) {
          this._createOjButtonset();
          this.uiInputNumber.classList.add('oj-has-buttons');
        }
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _needsButtonset: function () {
        return this.options.readOnly !== true && this.options.step > 0;
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _createButtonset: function () {
        var buttonSet = document.createElement('div');
        buttonSet.className = 'oj-buttonset-width-auto';

        var downButton = document.createElement('button');
        downButton.setAttribute('type', 'button');
        downButton.className = 'oj-inputnumber-button oj-inputnumber-down';
        buttonSet.appendChild(downButton);

        var upButton = document.createElement('button');
        upButton.setAttribute('type', 'button');
        upButton.className = 'oj-inputnumber-button oj-inputnumber-up';
        buttonSet.appendChild(upButton);

        return { buttonSet: buttonSet, downButton: downButton, upButton: upButton };
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _start: function () {
        this.spinning = true;
        return true;
      },
      /**
       * This is called when the user has clicked up or down, or held down up or down.
       * If the user is holding down, this means he wants to spin up or down the value until he sees
       * the value he wants, then he lets up. If the user clicks and doesn't hold down, it
       * will step up or down in the direction.
       * @param {Number} i - time to wait before recursively calling _repeat again. Defaults
       *   to 500.
       * @param {Number} direction - > 0 steps up, else steps down.
       * @param {Object=} event an optional event if this was a result of ui interaction.
       * @param {boolean=} spinning true if we are calling _repeat recursively while the user is holding
       * down the up/down key or button.
       * @private
       * @memberof oj.ojInputNumber
       */
      _repeat: function (i, direction, event, spinning) {
        var stopRepeat = false;
        var domElem;
        var busyContext;
        var self = this;
        var stepOpt = this.options.step;

        // if direction is > 0, it is going up, else it is going down.
        // need to check if min/max is reached, and if so, stop the repeat.
        // we do a quick css check to see if it is disabled.
        if (direction > 0) {
          if (this.upButton[0].classList.contains('oj-disabled')) {
            stopRepeat = true;
          }
        } else if (this.downButton[0].classList.contains('oj-disabled')) {
          stopRepeat = true;
        }
        // repeat spinning as long as the key is down and min/max isn't reached
        // eslint-disable-next-line no-param-reassign
        i = i || 500;

        clearTimeout(this.timer);
        // this.timer will be cleared elsewhere, like when the user stops holding down the up/down
        // arrows. See this._stop
        this.timer = setTimeout(function () {
          if (!stopRepeat) {
            self._repeat(40, direction, event, true);
          }
        }, i);

        // I need two paths. When I am 'spinning' and when I click click click the up
        // or down buton or key individually. When I step individually, I queue up the steps
        // using this.stepQueue if needed (e.g., a slow async validator)
        if (!spinning) {
          this._stepNoStartStop(direction * stepOpt, event);
        } else {
          // if we are actually spinning, it is ok to wait on the busyContext before we call
          // _spin again. _spin increments the value and validates it.
          domElem = this.element[0];
          busyContext = oj.Context.getContext(domElem).getBusyContext();
          if (busyContext.isReady()) {
            // this clears the stepQueue so that when the user stops holding down
            // the up/down button/key the number will stop spinning, even if the step
            // queue isn't empty. e.g., the user clicks up 10 times, but then
            // holds down the up. When he lets up, the number shouldn't keep going up just
            // because the stepQueue isn't empty yet.
            this.stepQueue = [];
            this._spin(direction * stepOpt, event, true);
          }
        }
      },
      /**
       * This gets called when the user clicks the up/down buttons or the up/down arrows
       * on the keyboard, or the app dev calls stepUp/stepDown. We need to get the current
       * value, convert it to a number, update it by the step, then validate the new value.
       * @private
       * @memberof oj.ojInputNumber
       * @param {Number} step - Number of steps to increment.
       * Negative steps means we are decrementing.
       * @param {Object|null} event an event if this was a result of ui interaction. null otherwise.
       * @param {boolean} transientOnly true to update transientValue only. false to update both transientValue and value.
       */
      _spin: function (step, event, transientOnly) {
        var adjustedValue;
        var currentDisplayValue = this._GetDisplayValue();
        var displayValue = currentDisplayValue || 0;
        var value = this._ParseValueShowErrors(displayValue);

        // parsing is synchronous, but _SetValue could be async if we have async-validators.
        if (value !== undefined) {
          adjustedValue = this._adjustParsedValueOnSpinAndUpdateDisplay(value, step);
          this._valuePending = transientOnly;
          return this._SetValue(adjustedValue, event, {
            validationMode: this._VALIDATION_MODE.VALIDATORS_ONLY,
            targetOptions: transientOnly ? ['transientValue'] : ['transientValue', 'value']
          });
        }
        // parsing failed if I get here. It is showing the error message, so I can return.
        this._updateButtonsAria(value);
        return false;
      },

      /**
       * Given the parsed value, it adjusts it by the step, formats, and updates the displayValue,
       * rawValue, aria-* attributes, and buttons. It returns the adjustedValue.
       * @return {number} the parsed value incremented by step.
       * @private
       * @memberof oj.ojInputNumber
       */
      _adjustParsedValueOnSpinAndUpdateDisplay: function (value, step) {
        var options = this.options;
        var minOpt = options.min;
        var maxOpt = options.max;
        var stepOpt = options.step;
        var initialValue = this.initialValue;
        var precision;
        var adjustedValue;
        var formatReturn;

        // get the max precision. e.g., min=2.4, initialValue=3.444, maxPrecision is 3.
        precision = this._precision(minOpt, stepOpt, initialValue);

        adjustedValue = this._adjustValue(
          value,
          step,
          minOpt,
          maxOpt,
          stepOpt,
          precision,
          initialValue
        );

        // Show the user what is going to be validated. We are making it so that clicking on the
        // up/down button is the same as if the user typed in a number and blurred.
        if (this._CanSetValue()) {
          // format the value, then add that to the element's input and update rawValue with that.
          // Passing true means 'do not show error messages or change valid state' since we
          // do that in _SetValue.
          formatReturn = this._UpdateElementDisplayValue(adjustedValue, true);
          if (formatReturn !== undefined) {
            // keep in sync with the input's val
            this._updateButtonsAria(adjustedValue);
          }
        }
        return adjustedValue;
      },

      /**
       * called from _adjustValue
       * @private
       * @memberof oj.ojInputNumber
       */
      _precision: function (minOpt, stepOpt, value) {
        var precision = this._precisionOf(stepOpt);

        if (minOpt != null) {
          precision = Math.max(precision, this._precisionOf(minOpt));
        }

        if (value != null) {
          precision = Math.max(precision, this._precisionOf(value));
        }

        return precision;
      },
      /**
       * return the number of digits after the '.'
       * called from _adjustValue->_precision
       * @private
       * @memberof oj.ojInputNumber
       * @param {Number} num - Number from which to calculate the precision
       */
      _precisionOf: function (num) {
        var str = num.toString();
        var decimal = str.indexOf('.');
        return decimal === -1 ? 0 : str.length - decimal - 1;
      },
      /**
       * adjust the value to be "valid".
       * The logic follows that of HTML-5's input number.
       * http://www.w3.org/TR/html5/forms.html#dom-input-stepup
       * A valid value is one that is a multiple of
       * step starting at stepBase, where stepBase is min (if present),
       * else initial value (if present),
       * else (if type == number) 0
       * If max is not a valid value, stepUp/stepDown will never go to max. It
       * will go to the calculated valid max (one that is the largest value
       * that is an integral multiple of the step, and that is less than or equal
       * to the maximum.
       * @private
       * @memberof oj.ojInputNumber
       * @param {number} value - the current value
       * @param {number} step - the step you want to adjust the value by
       * @param {number} minOpt - the min option
       * @param {number} maxOpt - the max option
       * @param {number} stepOpt - the step option
       * @param {number} precision - the precision @see _precision
       * @param {number} initialValue - the value when the component was created
       * @returns {number} - the new value after it has been adjusted
       */
      _adjustValue: function (value, step, minOpt, maxOpt, stepOpt, precision, initialValue) {
        var newValue;
        var stepBase;
        var aboveMin;
        var valueWithFraction;

        if (precision > 0) {
          valueWithFraction = this._adjustValueForFractions(
            value,
            step,
            minOpt,
            maxOpt,
            stepOpt,
            precision,
            initialValue
          );
          return valueWithFraction;
        }

        // make sure we're at a valid step when we step up or down.
        // - find out where we are relative to the base.
        // follow these rules. use min, else use initial value, else use 0.
        // https://www.w3.org/TR/html5/forms.html#concept-input-min-zero
        stepBase = minOpt != null ? minOpt : initialValue;
        if (stepBase == null) {
          stepBase = 0;
        }

        // From http://www.w3.org/TR/html5/forms.html#dom-input-stepup:
        // If value subtracted from the step base is not an integral multiple
        // of the step, then set value to the nearest value that, when subtracted
        // from the step base, is an integral multiple of the allowed value step,
        // and that is less than value if the method invoked was stepDown() and
        // more than value if the method invoked was stepUp().

        // is value-stepBase an integral multiple of step?
        try {
          // eslint-disable-next-line no-param-reassign
          value = parseFloat(value.toFixed(precision));
        } catch (e) {
          if (e instanceof TypeError) {
            // I've only seen this fail if they set a null converter.
            Logger.warn(
              "inputNumber's value after conversion is not a number. \n" +
                'The converter must convert the value to a Number. coercing using +'
            );
            // eslint-disable-next-line no-param-reassign
            value = +value; // coerce
          }
        }
        aboveMin = value - stepBase;

        var rounded = Math.round(aboveMin / stepOpt) * stepOpt;
        rounded = parseFloat(rounded.toFixed(precision));
        var multiple = rounded === aboveMin;

        if (!multiple) {
          if (step < 0) {
            aboveMin = Math.ceil(aboveMin / stepOpt) * stepOpt;
          } else {
            aboveMin = Math.floor(aboveMin / stepOpt) * stepOpt;
          }
          // rounding is based on 0, so adjust back to our base
          newValue = stepBase + aboveMin + step;
        } else {
          newValue = value + step;
        }

        // fix precision from bad JS floating point math
        // toFixed returns the newValue with a specific # of digits after the
        // decimal point (this_precision() looks at max of step/min/value's # of
        // digits.
        newValue = parseFloat(newValue.toFixed(precision));

        if (minOpt != null && newValue < minOpt) {
          return minOpt;
        }

        if (maxOpt != null && newValue > maxOpt) {
          var validMax = Math.floor((maxOpt - stepBase) / stepOpt) * stepOpt + stepBase;
          // fix precision from bad JS floating point math
          validMax = parseFloat(validMax.toFixed(precision));
          return validMax;
        }

        return newValue;
      },
      /**
       * Call this from _adjustValue when you have numbers with precision > 0. This method
       * multiples everything by Math.pow(10,precision), calls _adjustValue with these numbers so that
       * the math works, then divides the result by Math.pow(10,precision) to get it back to fractions.
       * This is to work around the issue with Javascript's binary floating-point numbers not being
       * great about adding decimal fractions. e.g., 0.1 + 0.2 is not equal to 0.3. It is
       * an intentional consequence of the IEEE Standard for Binary Floating-Point Arithmetic (IEEE 754)
       * @private
       * @memberof oj.ojInputNumber
       * @param {number} value - the current value
       * @param {number} step - the step you want to adjust the value by
       * @param {number} minOpt - the min option
       * @param {number} maxOpt - the max option
       * @param {number} stepOpt - the step option
       * @param {number} precision - the precision @see _precision
       * @param {number} initialValue - the value when the component was created
       * @returns {number}
       */
      _adjustValueForFractions: function (
        value,
        step,
        minOpt,
        maxOpt,
        stepOpt,
        precision,
        initialValue
      ) {
        // don't call this function if precision is 0
        oj.Assert.assert(precision > 0);
        var power = Math.pow(10, precision);
        // if minOpt, maxOpt, stepOpt are undefined, keep them that way
        // when we adjust the values to make them decimals, they should be whole numbers.
        // javascript sometimes gives them fractions (
        // e.g., 10000000.45*100=1000000044.9999999), so everywhere here we multiply
        // by power, round the value to make it a whole number.
        var minOptPower = minOpt != null ? Math.round(minOpt * power) : minOpt;
        var maxOptPower = maxOpt != null ? Math.round(maxOpt * power) : maxOpt;
        var stepOptPower = Math.round(stepOpt * power);

        var adjustValuePower = this._adjustValue(
          Math.round(value * power),
          Math.round(step * power),
          minOptPower,
          maxOptPower,
          stepOptPower,
          0,
          Math.round(initialValue * power)
        );
        return adjustValuePower / power;
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _stop: function (event) {
        if (!this.spinning) {
          return;
        }
        if (this._valuePending) {
          // transientValue would have been validated, so simply set value to it.
          // Normally when the value is updated, EditableValue._AfterSetOptionValue checks if it
          // needs to run deferred validation and refresh UI display value.  Since we
          // get here only from UI event, neither of those are necessary, so there is no
          // need to call _AfterSetOptionValue.
          var context = { originalEvent: event, internalSet: true };
          this.option({ value: this.options.transientValue }, { _context: context });
          this._valuePending = false;
        }
        clearTimeout(this.timer);
        this.spinning = false;
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       * @return {boolean} true if there is no touch detected within the last 500 ms
       */
      _isRealMouseEvent: function () {
        return !DomUtils.recentTouchEnd();
      },
      /**
       * disables or enables both the up and down buttons depending upon what the value
       * is on the screen after conversion plus what min/max are set to.
       * e.g., $10.00 is on the screen, valuenow is 10
       * @private
       * @memberof oj.ojInputNumber
       */
      _updateButtons: function (valuenow) {
        var options = this.options;
        var maxOpt = options.max;
        var minOpt = options.min;
        var downButton = this.downButton;
        var upButton = this.upButton;
        var downButtonDisabledAlready;
        var upButtonDisabledAlready;
        var isMaxOptNonNull = maxOpt != null;
        var isMinOptNonNull = minOpt != null;

        if (!downButton && !upButton) {
          return;
        }

        // to prevent the overhead of disabling a button that is already disabled, check to see
        // if it is already disabled already.
        downButtonDisabledAlready = downButton[0].classList.contains('oj-disabled');
        upButtonDisabledAlready = upButton[0].classList.contains('oj-disabled');

        if (
          options.disabled ||
          valuenow === undefined ||
          (isMaxOptNonNull && isMinOptNonNull && maxOpt === minOpt && valuenow === maxOpt)
        ) {
          if (!downButtonDisabledAlready) {
            downButton.ojButton('disable');
          }
          if (!upButtonDisabledAlready) {
            upButton.ojButton('disable');
          }
        } else if (isMaxOptNonNull && valuenow >= maxOpt) {
          if (downButtonDisabledAlready) {
            downButton.ojButton('enable');
          }
          if (!upButtonDisabledAlready) {
            upButton.ojButton('disable');
          }
        } else if (isMinOptNonNull && valuenow <= minOpt) {
          if (!downButtonDisabledAlready) {
            downButton.ojButton('disable');
          }
          if (upButtonDisabledAlready) {
            upButton.ojButton('enable');
          }
        } else {
          if (downButtonDisabledAlready) {
            downButton.ojButton('enable');
          }
          if (upButtonDisabledAlready) {
            upButton.ojButton('enable');
          }
        }
      },
      /**
       * Returns the normalized converter instance.
       *
       * @return {Object} a converter instance or null
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      _getConverter: ojeditablevalue.EditableValueUtils._GetConverter,
      /**
       * Draw a readonly div or update one. When readonly, this div is shown and
       * the input has display:none on it through theming, and vice versa.
       * We set the textContent in _SetDisplayValue() if readonly
       * @param {HTMLElement} pass in this.element[0]
       * @memberof oj.ojInputNumber
       * @instance
       * @private
       */
      _createOrUpdateReadonlyDiv: ojeditablevalue.EditableValueUtils._createOrUpdateReadonlyDiv,
      /**
       * Returns the converted display value.
       * This function gets the display value (or 0 if no display value), then parses it using
       * the converter.
       * The converted display value is used for 'valuenow'. For example,
       * the display value might be $6.00, but we want valuenow to be 6.
       * @private
       * @memberof oj.ojInputNumber
       */
      _getDisplayValueParsed: function () {
        var value;
        var displayValue;
        try {
          displayValue = this._GetDisplayValue() || 0;
          // if displayValue is not parseable, say it is 'abc',
          // then _parseValue throws an error. catch it and move on.
          value = this._parseValue(displayValue);
        } catch (e) {
          // catch the error, set value to undefined, and continue to update
          // the buttons. both the up/down buttons will be disabled in this case.
          value = undefined;
        }
        return value;
      },
      /**
       * This calls _SetValue to parse, validate, and format the user's input.
       * If we have async validators, this may happen asynchronously.
       * If asynchronous and a new call is made to this method,
       * it will ignore the Promise resolution from the previous request.
       * @param {Object=} event the ui interaction event.
       * @private
       * @memberof oj.ojInputNumber
       */
      _blurEnterSetValue: function (event) {
        var val = this.element.val();
        var valuenow;
        var setValueReturn;
        var self = this;
        var currentCounter;

        this._stop(event);
        // clear step queue
        this.stepQueue = [];
        // used to ignore if we get newer blurs
        this._blurEnterSetValueCounter += 1;
        currentCounter = this._blurEnterSetValueCounter;

        this._valuePending = false;
        setValueReturn = this._SetValue(val, event, { targetOptions: ['transientValue', 'value'] });

        if (setValueReturn instanceof Promise) {
          // We already set BusyContext in _SetValue
          setValueReturn.then(function (setValueResolved) {
            // valuenow/buttons are updated already in _Refresh for value option.
            // handle the case where it wasn't.
            // ignore if we got a more recent blur/enter while this one was still waiting.
            if (currentCounter === self._blurEnterSetValueCounter) {
              if (!setValueResolved) {
                // If setValueResolved is false, there was an error in _SetValue parse/validate
                // or it was ignored. Since we deal with ignoring ourselves,
                // then we can rule that out.
                valuenow = self._getDisplayValueParsed();
                // we get here if parse is synchronous but validate is async, and validate
                // failed.
                self._updateButtonsAria(valuenow);
              }
            }
          });
        } else {
          valuenow = setValueReturn ? this.options.value : this._getDisplayValueParsed();
          // disables or enables both the up and down buttons depending upon what the value
          // is on the screen after conversion plus what min/max are set to.
          this._updateButtonsAria(valuenow);
        }
      },
      /**
       * This gets called at various times, like on initialization and when you spin.
       * @private
       * @memberof oj.ojInputNumber
       */
      _updateButtonsAria: function (valuenow) {
        this._refreshAriaValueNowText(valuenow);
        this._updateButtons(valuenow);
      },
      /**
       * Get the options for a number range validator, async or sync.
       * Use the 'min' and 'max' options.
       * @return {Object} the options
       * @private
       * @memberof oj.ojInputNumber
       */
      _createRangeValidatorOptions: function () {
        var options = this.options;
        var minOpt = options.min;
        var maxOpt = options.max;
        var newMin = minOpt != null ? minOpt : undefined;
        var newMax = maxOpt != null ? maxOpt : undefined;
        var translations = options.translations;
        var translationsOptionNumberRange = translations ? translations.numberRange || {} : {};
        var hintMin;
        var hintMax;
        var hintInRange;
        var hintExact;
        var messageDetailRangeOverflow;
        var messageDetailRangeUnderflow;
        var messageDetailExact;
        var messageSummaryRangeOverflow;
        var messageSummaryRangeUnderflow;
        var translationsHint = translationsOptionNumberRange.hint || {};
        var translationsMessageDetail = translationsOptionNumberRange.messageDetail || {};
        var translationsMessageSummary = translationsOptionNumberRange.messageSummary || {};
        var numberRangeValidatorOptions;

        // First check if the translations hint/messageDetail/messageSummary options are set, and if
        // so, use them.
        // This is how the app dev could use inputNumber's translations option.
        // var element = $("#spin").ojInputNumber(
        //      {value: 10, min: -50,
        //        translations:
        //        {numberRange:
        //          {hint:
        //            {min: 'Translations Option Test: Please enter a number greater than or equal to {min}',
        //             max: 'Translations Option Test: Please enter a number less than or equal to {max}',
        //             inRange: 'Translations Option Test: Please enter a number between {min} and {max}'
        //            },
        //            messageDetail:
        //            {rangeUnderflow:
        //            'Translations Option Test: The number {value} must be greater than or equal to {min}',
        //              rangeOverflow:
        //              'Translations Option Test: The number {value} must be less than or equal to {max}'
        //            }
        //          }
        //        } // end numberRange
        if (translationsHint !== null) {
          hintMin = translationsHint.min || null;
          hintMax = translationsHint.max || null;
          hintInRange = translationsHint.inRange || null;
          hintExact = translationsHint.exact || null;
        }
        if (translationsMessageDetail !== null) {
          messageDetailRangeOverflow = translationsMessageDetail.rangeOverflow || null;
          messageDetailRangeUnderflow = translationsMessageDetail.rangeUnderflow || null;
          messageDetailExact = translationsMessageDetail.exact || null;
        }
        if (translationsMessageSummary !== null) {
          messageSummaryRangeOverflow = translationsMessageSummary.rangeOverflow || null;
          messageSummaryRangeUnderflow = translationsMessageSummary.rangeUnderflow || null;
        }

        // unless the translations options for the numberrange were set, the hints and messageDetails
        // and messageSummaries will be null and we'll pick up the default strings from the
        // NumberRangeValidator.
        numberRangeValidatorOptions = {
          min: newMin,
          max: newMax,
          hint: {
            min: hintMin || null,
            max: hintMax || null,
            inRange: hintInRange || null,
            exact: hintExact || null
          },
          messageDetail: {
            rangeOverflow: messageDetailRangeOverflow || null,
            rangeUnderflow: messageDetailRangeUnderflow || null,
            exact: messageDetailExact || null
          },
          messageSummary: {
            rangeOverflow: messageSummaryRangeOverflow || null,
            rangeUnderflow: messageSummaryRangeUnderflow || null
          },
          converter: this._GetConverter()
        };

        return numberRangeValidatorOptions;
      },

      // The user can clear out min/max by setting the option to null, so we
      // do not coerce null.
      /**
       * @param {string} option name of the option. this will show up in the error if thrown
       * @param val value to parse
       * @throws {Error} if option value is invalid
       * @private
       * @memberof oj.ojInputNumber
       */
      _parse: function (option, val) {
        var returnValue;
        if (val !== null) {
          returnValue = +val;
        } else {
          returnValue = val;
        }

        // isNaN(null) returns false, which is what we want
        if (isNaN(returnValue)) {
          throw new Error("ojInputNumber's " + option + ' option is not a number');
        }

        return returnValue;
      },
      /**
       * parse the step's value
       * We are following the behavior of HTML-5 the best we can. According
       * to the spec, it says step must be a number greater than 0.
       * Chrome defaults it to 1 if it is not.
       * In v8.0 we added the feature to not step or show buttons if
       * step is 0.
       * @throws {Error} if option value is invalid
       * @private
       * @memberof oj.ojInputNumber
       */
      _parseStep: function (val) {
        var defaultStep = 1;
        var parsedStep;
        if (val === null) {
          return defaultStep;
        }
        if (val === '') {
          // throw an exception
          throw new Error('Invalid step for ojInputNumber; step must be a number 0 or greater.');
        }

        parsedStep = this._parse('step', val);
        if (parsedStep < 0) {
          // throw an exception
          throw new Error('Invalid step for ojInputNumber; step must be 0 or greater.');
        }
        return parsedStep;
      },
      /**
       * Toggles css selector on the widget. E.g., when readOnly option changes,
       * the oj-read-only selector needs to be toggled.
       * @param {string} option
       * @param {Object|string|boolean} value
       * @private
       * @memberof oj.ojInputNumber
       */
      _refreshStateTheming: function (option, value) {
        if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) !== -1) {
          // value is a boolean
          if (value) {
            this.widget()[0].classList.add(this._OPTION_TO_CSS_MAPPING[option]);
          } else {
            this.widget()[0].classList.remove(this._OPTION_TO_CSS_MAPPING[option]);
          }
        }
      },
      /**
       * The role spinbutton needs to be toggled.
       * If the up/down buttons are not rendered, then we do not want the
       * role spinbutton.
       * E.g., We don't have role spinbutton on readOnly inputNumber.
       * @param {boolean} needsRole
       * @private
       * @memberof oj.ojInputNumber
       */
      _refreshRoleSpinbutton: function (needsRole) {
        if (!needsRole) {
          this.element[0].removeAttribute('role');
        } else {
          this.element[0].setAttribute('role', 'spinbutton'); // @HTMLUpdateOK
        }
      },
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _refreshAriaMinMax: function () {
        // According to the wai-aria rules you cannot have aria-value
        // attributes without role='spinbutton', and we only have role='spinbutton'
        // when we can increment/decrement the number with the spin buttons or arrows.
        if (this._needsButtonset()) {
          this._setAttr('aria-valuemin', this.options.min);
          this._setAttr('aria-valuemax', this.options.max);
        } else {
          this._setAttr('aria-valuemin', null);
          this._setAttr('aria-valuemax', null);
        }
      },
      /**
       * Update aria-valuenow to valuenow and aria-valuetext to the
       * displayValue if it is different than valuenow.
       * If valuenow is undefined, then aria-valuenow is skipped; it's not set or removed,
       * so it will be the last known valid value.
       * Rules for aria-valuenow/aria-valuetext:
       * if the input value shown to the user can be parsed to a valid non-formatted number,
       * I'll set aria-valuenow, else it won't be there at all.
       * if the input value shown is not equal to what aria-valuenow is,
       * set aria-valuetext, e.g.,
       * USD 10.00 for aria-valuetext, 10 for aria-valuenow.
       * else it won't be there at all.
       * My goal is for voiceover to read what is in the field, showing to the user.
       * @private
       * @memberof oj.ojInputNumber
       */
      _refreshAriaValueNowText: function (valuenow) {
        if (this._needsButtonset()) {
          this._setAttr('aria-valuenow', valuenow);
          this._refreshAriaText(valuenow);
        }
      },
      /**
       * Toggles aria-valuenow and aria-valuetext when readonly or step changes.
       * We do not render aria-value attributes when there are no step buttons and
       * there are no step buttons when the component is readonly or has no step.
       * @private
       * @memberof oj.ojInputNumber
       */
      _toggleAriaValueNowText: function () {
        const valuenow = this.options.value || 0;
        // aria-value attributes are valid only when role='spinbutton'.
        if (this._needsButtonset()) {
          this._setAttr('aria-valuenow', valuenow);
          this._refreshAriaText(valuenow);
        } else {
          this._setAttr('aria-valuenow', null);
          this._setAttr('aria-valuetext', null);
        }
      },

      /* updates the aria-text if needed */
      /**
       * @private
       * @memberof oj.ojInputNumber
       */
      _refreshAriaText: function (valuenow) {
        var valuetext = this.element.val();

        if (valuetext !== '' && !this._CompareOptionValues('value', '' + valuenow, valuetext)) {
          this._setAttr('aria-valuetext', valuetext);
        } else {
          this._setAttr('aria-valuetext', null);
        }
      },
      /**
       * Set an element attribute using jQuery logic, but javascript apis.
       * This allows easy replacement of jQuery attr() calls.
       * @param {string} attrName the attribute to set
       * @param {any} value the attribute value
       * @private
       * @memberof oj.ojInputNumber
       */
      _setAttr: function (attrName, value) {
        if (value !== undefined) {
          if (value === null) {
            this.element[0].removeAttribute(attrName);
          } else {
            this.element[0].setAttribute(attrName, value); // @HTMLUpdateOK
          }
        }
      },
      /**
       * Step the inputnumber value up or down.
       * If this is async because of async validators,
       * then we queue up the step requests, so if a user clicks three times, but updating is slow
       * due to slow validators, the user still sees the result of his three clicks
       * at the end. This is different than when the user holds down the up/down
       * key/button.
       * @private
       * @memberof oj.ojInputNumber
       * @param {Number} step - Number of steps to increment, like 10 or 1. If undefined, we
       * pull from the this.stepQueue queue.
       * @param {boolean} up If true step up, else step down.
       * @param {Object=} event an optional event if this was a result of ui interaction.
       */
      _stepNoStartStop: function (step, event) {
        var currentStepObject;
        var currentSpinStep;
        var currentEvent;
        // this.stepQueue = []; initialized in _AfterCreate and cleared if spinning or blurEnter
        var spinPromise;
        var self = this;

        if (step === undefined) {
          // pull from the queue. If it's empty, return.
          if (this.stepQueue.length === 0) {
            return;
          }
          currentStepObject = this.stepQueue.shift();
          currentSpinStep = currentStepObject.step;
          currentEvent = currentStepObject.event;
        } else {
          // if we are already processing something in the queue, push new step request
          //  to the queue, and return.
          if (this.stepQueue.length >= 1) {
            this.stepQueue.push({ step: step, event: event });
            return;
          }
          currentSpinStep = step;
          currentEvent = event;
        }

        spinPromise = this._spin(currentSpinStep, currentEvent, false);
        if (spinPromise instanceof Promise) {
          this.stepQueue.push({ step: currentSpinStep, event: currentEvent });
          spinPromise.then(function () {
            // pop it off because it has been processed. This is used as a 'flag' that we
            // are awaiting the promise to resolve.
            self.stepQueue.shift();
            // continue stepping if stepQueue is not empty.
            self._stepNoStartStop(undefined, currentEvent);
          });
        }
      },

      /**
       * step the inputnumber value up or down.
       * @private
       * @memberof oj.ojInputNumber
       * @param {Number} step - Number of steps to increment, like 10 or 1 or -10.
       * @param {Object=} event an optional event if this was a result of ui interaction.
       */
      _step: function (step, event) {
        this._start();
        this._stepNoStartStop(step, event);
        this._stop(event);
      },

      /**
       * Set the type of the input element based on virtualKeyboard option.
       * @memberof oj.ojInputNumber
       * @instance
       * @protected
       * @ignore
       */
      _SetInputType: ojeditablevalue.EditableValueUtils._SetInputType,

      /**
       * Events registerd without the passive option
       * @private
       * @memberof oj.ojInputNumber
       * @ignore
       */
      _regularEventsAndListeners: {
        compositionstart: function () {
          // See _isComposing in InputBase for comments on what this does
          this._isComposing = true;
        },
        compositionend: function (event) {
          this._isComposing = false;
          this._SetRawValue(this.element.val(), event);
        },
        input: function (event) {
          if (!this._isComposing) {
            this._SetRawValue(this.element.val(), event);
          }
        },
        keydown: function (event) {
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
            case keyCode.ENTER:
              this._blurEnterSetValue(event);
              event.preventDefault();
              break;
            case keyCode.UP:
              // same as if you used the up and down buttons
              // if buttons aren't there, then up/down keys shouldn't be
              // there as well.
              if (this._needsButtonset()) {
                if (!this.spinning) {
                  this._start();
                  this._repeat(null, 1, event);
                }
              }
              event.preventDefault();

              break;
            case keyCode.DOWN:
              if (this._needsButtonset()) {
                if (!this.spinning) {
                  this._start();
                  this._repeat(null, -1, event);
                }
              }
              event.preventDefault();
              break;
            default:
              break;
          }
        },
        keyup: function (event) {
          var keyCode = $.ui.keyCode;

          switch (event.keyCode) {
            case keyCode.UP:
            case keyCode.DOWN:
              this._stop(event);
              break;
            default:
              this._stop(event);
              break;
          }
        },
        blur: function (event) {
          this._blurEnterSetValue(event);
        },
        'touchend .oj-inputnumber-button': function (event) {
          this._stop(event);
        },
        'touchcancel .oj-inputnumber-button': function (event) {
          this._stop(event);
        },
        'mousedown .oj-inputnumber-button.oj-enabled': function (event) {
          if (this._isRealMouseEvent(event)) {
            this._start();

            this._repeat(
              null,
              event.currentTarget.classList.contains('oj-inputnumber-up') ? 1 : -1,
              event
            );
          }
        },
        'mouseup .oj-inputnumber-button': function (event) {
          if (this._isRealMouseEvent(event)) {
            this._stop(event);
          }
        },
        'mouseenter .oj-inputnumber-button.oj-enabled': function (event) {
          // button will add oj-active if mouse was down while mouseleave and kept down
          if (!event.currentTarget.classList.contains('oj-active')) {
            return;
          }
          if (this._isRealMouseEvent(event)) {
            this._start();

            this._repeat(
              null,
              event.currentTarget.classList.contains('oj-inputnumber-up') ? 1 : -1,
              event
            );
          }
        },
        // TODO: do we really want to consider this a stop?
        // shouldn't we just stop the repeater and wait until mouseup before
        // we trigger the stop event?
        'mouseleave .oj-inputnumber-button': function (event) {
          if (this._isRealMouseEvent(event)) {
            this._stop(event);
          }
        }
      },

      /**
       * Events registerd with the passive option
       * @private
       * @memberof oj.ojInputNumber
       * @ignore
       */
      _passiveEventsAndListeners: {
        'touchstart .oj-inputnumber-button.oj-enabled': function (event) {
          this._start();
          this._repeat(
            null,
            event.currentTarget.classList.contains('oj-inputnumber-up') ? 1 : -1,
            event
          );
        }
      },

      /**
       * Register event listeners
       * @memberof oj.ojInputNumber
       * @private
       * @ignore
       */
      _registerEvents: function () {
        // register all regular events
        this._on(this._regularEventsAndListeners);
        // will register these with the passive option in 8.1.0
        this._on(this._passiveEventsAndListeners);
      }
    });

    Components.setDefaultOptions({
      ojInputNumber: {
        step: Components.createDynamicPropertyGetter(function () {
          return ThemeUtils.getCachedCSSVarValues([
            '--oj-private-input-number-global-step-default'
          ])[0];
        }),
        converter: Components.createDynamicPropertyGetter(function () {
          if (_sDefaultNumberConverter == null) {
            _sDefaultNumberConverter = _getNumberDefaultConverter();
          }
          return _sDefaultNumberConverter;
        })
      }
    });
  })(); // end of inputNumber wrapper function

});


define('ojs/ojvalidator-regexp',['ojs/ojcore', 'ojs/ojtranslation', 'ojs/ojvalidator', 'ojs/ojvalidation-error'], function (oj, Translations, Validator, ojvalidationError) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Validator = Validator && Object.prototype.hasOwnProperty.call(Validator, 'default') ? Validator['default'] : Validator;

  /**
   * Constructs a RegExpValidator that ensures the value matches the provided pattern.
   * @param {Object=} options an object literal used to provide the pattern, an optional hint and error
   * message.
   * @export
   * @constructor
   * @final
   * @augments oj.Validator
   * @name oj.RegExpValidator
   * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
   * @ojtsmodule
   * @ojsignature [{target: "Type",
   *                value: "class RegExpValidator implements Validator<string|number>"},
   *               {target: "Type",
   *                value: "oj.RegExpValidator.ValidatorOptions",
   *                for: "options", jsdocOverride: true}
   *              ]
   * @since 0.6.0
   * @see oj.AsyncRegExpValidator
   */
  const RegExpValidator = function (options) {
    this.Init(options);
  };

  // Subclass from oj.Object or Validator. It does not matter
  oj.Object.createSubclass(RegExpValidator, Validator, 'oj.RegExpValidator');

  // key to access required validator specific resources in the bundle
  RegExpValidator._BUNDLE_KEY_DETAIL = 'oj-validator.regExp.detail';
  RegExpValidator._BUNDLE_KEY_SUMMARY = 'oj-validator.regExp.summary';

  /**
   * @typedef {object} oj.RegExpValidator.ValidatorOptions
   * @property {string=} pattern - a regexp pattern that the validator matches a value against.<p>
   * Example:<br/>
   * '\\d{10}'
   * @property {string=} hint - an optional hint text. There is no default hint provided by the
   * validator. It is generally not recommended to show the actual pattern in the hint as it might be
   * confusing to end-user, but if you do, you can use the {pattern} token.<p>
   * <p>The hint string is passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * Tokens: <br/>
   * {pattern} - the pattern to enforce<p>
   * Example:<br/>
   * "value must meet this pattern {pattern}"
   * @property {string=} label - an optional label text used when the {label} token is passed
   * into messageSummary or messageDetail.
   * @property {string=} messageSummary - a custom error message summarizing the error when the
   * users input does not match the specified pattern. When not present, the default summary is the
   * resource defined with the key <code class="prettyprint">oj-validator.regExp.summary</code>.
   * It is generally not recommended to show the actual pattern in the message as it might be
   *  confusing to end-user. <p>
   * <p>The messageSummary string is passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * Tokens: <p>
   * {label} - label of the component for which this message applies. The label may not always be
   * available depending on the usage of the validator. <br/>
   * {pattern} - the pattern the value should match<br/>
   * {value} - value entered by user<p>
   * Examples:<br/>
   * "'{label}' Format Incorrect" // translating to 'Phone Number' Format Incorrect
   * @property {string=} messageDetail - a custom error message to be used for creating detail
   * part of message, when the users input does not match the specified pattern. When not present, the
   * default detail message is the resource defined with the key
   * <code class="prettyprint">oj-validator.regExp.detail</code>.<p>
   * <p>The messageDetail string is passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * Tokens:<br/>
   * {label} - label text of the component for which this message applies. <br/>
   * {pattern} the 'pattern' that the value should match <br/>
   * {value} value entered by the user <p>
   * Examples:<br/>
   * "The value {value} must contain at least 3 alphanumeric characters"<br/>
   */
  /**
   * Initializes validator instance with the set options
   * @param {Object=} options
   * @memberof oj.RegExpValidator
   * @instance
   * @ignore
   */
  RegExpValidator.prototype.Init = function (options) {
    RegExpValidator.superclass.Init.call(this);
    this._options = options;
  };

  /**
   * Validates value for matches using the regular expression provided by the pattern. This method
   * does not raise an error when value is the empty string or null; the method returns true indicating
   * that the validation was successful. If the application wants the empty string to fail validation,
   * then the application should chain in the required validator (e.g., set required on the input).
   *
   * @param {string|number} value that is being validated
   * @returns {void}
   * @ojsignature {target: "Type", for: "returns",
   *                value: "void"}
   *
   * @throws {Error} when there is no match
   * @memberof oj.RegExpValidator
   * @instance
   * @export
   * @method validate
   */
  RegExpValidator.prototype.validate = function (value) {
    var detail;
    var label;
    var summary;
    var pattern = (this._options && this._options.pattern) || '';

    // don't validate null or empty string; per 
    // There are one of two ways we could handle the empty string:
    // 1) blow up on null and then require that customers wrap the validator with one that
    // succeeds on null if they don’t like the behavior
    // 2) Accept null and expect that the application will chain in the required checked if necessary
    // As a team we decided 2) was better than 1).
    if (value === null || value === undefined || value === '') {
      return;
    }

    // when using digits as input values parseString becomes a integer type, so get away with it.
    var valueString = value.toString();

    // We intend that the pattern provided is matched exactly
    var exactPattern = '^(' + pattern + ')$';

    var matchArr = valueString.match(exactPattern);
    if (!(matchArr !== null && matchArr[0] === valueString)) {
      if (this._options) {
        summary = this._options.messageSummary || null;
        detail = this._options.messageDetail || null;
        label = (this._options && this._options.label) || '';
      }

      var params = { label: label, pattern: pattern, value: valueString };
      var localizedSummary = summary
        ? Translations.applyParameters(summary, params)
        : Translations.getTranslatedString(this._getSummaryKey(), params);
      var localizedDetail = detail
        ? Translations.applyParameters(detail, params)
        : Translations.getTranslatedString(this._getDetailKey(), params);

      throw new ojvalidationError.ValidatorError(localizedSummary, localizedDetail);
    }
  };

  /**
   * A message to be used as hint, when giving a hint on the expected pattern. There is no default
   * hint for this property.
   *
   * @returns {string|null} a hint message or null if no hint is available in the options
   * @memberof oj.RegExpValidator
   * @instance
   * @export
   * @method getHint
   */
  RegExpValidator.prototype.getHint = function () {
    var hint = null;
    var params = {};
    if (this._options && this._options.hint) {
      params = { pattern: this._options.pattern };
      hint = Translations.applyParameters(this._options.hint, params);
    }

    return hint;
  };

  RegExpValidator.prototype._getSummaryKey = function () {
    return RegExpValidator._BUNDLE_KEY_SUMMARY;
  };

  RegExpValidator.prototype._getDetailKey = function () {
    return RegExpValidator._BUNDLE_KEY_DETAIL;
  };

  return RegExpValidator;

});


define('ojs/ojfilter',[],function () { 'use strict';



});


define('ojs/ojfilter-length',[],function () { 'use strict';

    class LengthFilter {
        constructor(options) {
            this.options = options;
            if (!options.max) {
                throw new Error("length filter's max option cannot be less than 1. max option is " + options.max);
            }
            if (isNaN(options.max)) {
                throw new Error("length filter's max option is not a number. max option is " + options.max);
            }
            if (options.max !== null && options.max < 1) {
                throw new Error("length filter's max option cannot be less than 1. max option is " + options.max);
            }
            options.countBy = options.countBy === undefined ? 'codePoint' : options.countBy;
        }
        filter(currentRawValue, proposedRawValue) {
            const proposedValueLength = this.calcLength(proposedRawValue);
            return proposedValueLength <= this.options.max
                ? proposedRawValue
                : currentRawValue.slice(0, this.options.max);
        }
        calcLength(text) {
            const countBy = this.options.countBy;
            if (text == '' || text == null || text == undefined) {
                return 0;
            }
            const codeUnitLength = text.length;
            let length;
            let surrogateLength = 0;
            switch (countBy) {
                case 'codePoint':
                    for (let i = 0; i < codeUnitLength; i++) {
                        if ((text.charCodeAt(i) & 0xf800) === 0xd800) {
                            surrogateLength += 1;
                        }
                    }
                    length = codeUnitLength - surrogateLength / 2;
                    break;
                case 'codeUnit':
                default:
                    length = codeUnitLength;
            }
            return length;
        }
    }

    return LengthFilter;

});


define('ojs/ojinputtext',['ojs/ojcore', 'jquery', 'ojs/ojthemeutils', 'ojs/ojeditablevalue', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojfilter-length', 'ojs/ojvalidator-regexp', 'ojs/ojcustomelement-utils'], function (ojcore, $, ojthemeutils, ojeditablevalue, oj, DomUtils, LengthFilter, RegExpValidator, ojcustomelementUtils) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  LengthFilter = LengthFilter && Object.prototype.hasOwnProperty.call(LengthFilter, 'default') ? LengthFilter['default'] : LengthFilter;
  RegExpValidator = RegExpValidator && Object.prototype.hasOwnProperty.call(RegExpValidator, 'default') ? RegExpValidator['default'] : RegExpValidator;

  (function () {
    var bindingMeta = {
      properties: {
        readonly: {
          binding: { consume: { name: 'readonly' } }
        },
        userAssistanceDensity: {
          binding: { consume: { name: 'userAssistanceDensity' } }
        },
        labelEdge: {
          binding: { consume: { name: 'labelEdge' } }
        }
      }
    };

var __oj_input_password_metadata = 
{
  "properties": {
    "asyncValidators": {
      "type": "Array<Object>",
      "value": []
    },
    "autocomplete": {
      "type": "string",
      "value": "on",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "autofocus": {
      "type": "boolean",
      "value": false,
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "maskIcon": {
      "type": "string",
      "enumValues": [
        "hidden",
        "visible"
      ],
      "value": "hidden"
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "name": {
      "type": "string",
      "value": "",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "placeholder": {
      "type": "string"
    },
    "rawValue": {
      "type": "string",
      "writeback": true,
      "readOnly": true
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleHidePassword": {
          "type": "string"
        },
        "accessibleMaxLengthExceeded": {
          "type": "string"
        },
        "accessibleMaxLengthRemaining": {
          "type": "string"
        },
        "accessibleShowPassword": {
          "type": "string"
        },
        "regexp": {
          "type": "object",
          "properties": {
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "validators": {
      "type": "Array<Object>",
      "value": []
    },
    "value": {
      "type": "string",
      "writeback": true
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    __oj_input_password_metadata.extension._WIDGET_NAME = 'ojInputPassword';
    __oj_input_password_metadata.extension._INNER_ELEM = 'input';
    __oj_input_password_metadata.extension._GLOBAL_TRANSFER_ATTRS = [
      'accesskey',
      'aria-label',
      'tabindex'
    ];
    __oj_input_password_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    oj.CustomElementBridge.register('oj-input-password', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_input_password_metadata, bindingMeta)
    });

var __oj_input_text_metadata = 
{
  "properties": {
    "asyncValidators": {
      "type": "Array<Object>",
      "value": []
    },
    "autocomplete": {
      "type": "string",
      "value": "on",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "autofocus": {
      "type": "boolean",
      "value": false,
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "clearIcon": {
      "type": "string",
      "enumValues": [
        "always",
        "conditional",
        "never"
      ],
      "value": "never"
    },
    "converter": {
      "type": "object"
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "length": {
      "type": "object",
      "properties": {
        "countBy": {
          "type": "string",
          "enumValues": [
            "codePoint",
            "codeUnit"
          ],
          "value": "codePoint"
        },
        "max": {
          "type": "number"
        }
      }
    },
    "list": {
      "type": "string",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "name": {
      "type": "string",
      "value": "",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "placeholder": {
      "type": "string"
    },
    "rawValue": {
      "type": "string",
      "writeback": true,
      "readOnly": true
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleClearIcon": {
          "type": "string"
        },
        "accessibleMaxLengthExceeded": {
          "type": "string"
        },
        "accessibleMaxLengthRemaining": {
          "type": "string"
        },
        "regexp": {
          "type": "object",
          "properties": {
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "validators": {
      "type": "Array<Object>",
      "value": []
    },
    "value": {
      "type": "any",
      "writeback": true
    },
    "virtualKeyboard": {
      "type": "string",
      "enumValues": [
        "auto",
        "email",
        "number",
        "search",
        "tel",
        "text",
        "url"
      ],
      "value": "auto"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    /* global __oj_input_text_metadata:false */
    __oj_input_text_metadata.extension._WIDGET_NAME = 'ojInputText';
    __oj_input_text_metadata.extension._INNER_ELEM = 'input';
    __oj_input_text_metadata.extension._GLOBAL_TRANSFER_ATTRS = [
      'accesskey',
      'aria-label',
      'tabindex',
      'autocapitalize'
    ];
    __oj_input_text_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    oj.CustomElementBridge.register('oj-input-text', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_input_text_metadata, bindingMeta)
    });

var __oj_text_area_metadata = 
{
  "properties": {
    "asyncValidators": {
      "type": "Array<Object>",
      "value": []
    },
    "autocomplete": {
      "type": "string",
      "value": "on",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "autofocus": {
      "type": "boolean",
      "value": false,
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "converter": {
      "type": "object"
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "length": {
      "type": "object",
      "properties": {
        "countBy": {
          "type": "string",
          "enumValues": [
            "codePoint",
            "codeUnit"
          ],
          "value": "codePoint"
        },
        "counter": {
          "type": "string",
          "enumValues": [
            "none",
            "remaining"
          ],
          "value": "none"
        },
        "max": {
          "type": "number"
        }
      }
    },
    "maxRows": {
      "type": "number",
      "value": 0
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "name": {
      "type": "string",
      "value": "",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "placeholder": {
      "type": "string"
    },
    "rawValue": {
      "type": "string",
      "writeback": true,
      "readOnly": true
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "resizeBehavior": {
      "type": "string",
      "enumValues": [
        "both",
        "horizontal",
        "none",
        "vertical"
      ],
      "value": "none"
    },
    "rows": {
      "type": "number",
      "extension": {
        "_COPY_TO_INNER_ELEM": true
      }
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleMaxLengthExceeded": {
          "type": "string"
        },
        "accessibleMaxLengthRemaining": {
          "type": "string"
        },
        "regexp": {
          "type": "object",
          "properties": {
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "validators": {
      "type": "Array<Object>",
      "value": []
    },
    "value": {
      "type": "any",
      "writeback": true
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    /* global __oj_text_area_metadata:false */
    __oj_text_area_metadata.extension._WIDGET_NAME = 'ojTextArea';
    __oj_text_area_metadata.extension._INNER_ELEM = 'textarea';
    __oj_text_area_metadata.extension._GLOBAL_TRANSFER_ATTRS = [
      'accesskey',
      'aria-label',
      'tabindex',
      'autocapitalize'
    ];
    __oj_text_area_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    oj.CustomElementBridge.register('oj-text-area', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_text_area_metadata, bindingMeta)
    });
  })();

  /**
   * @ojcomponent oj.inputBase
   * @augments oj.editableValue
   * @abstract
   * @ojsignature [{
   *                target: "Type",
   *                value: "abstract class inputBase<V, SP extends inputBaseSettableProperties<V, SV>, SV= V, RV= V> extends editableValue<V, SP, SV, RV>"
   *               },
   *               {
   *                target: "Type",
   *                value: "inputBaseSettableProperties<V, SV=V, RV= V> extends editableValueSettableProperties<V, SV, RV>",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @since 0.6.0
   * @ojshortdesc Abstract InputBase element
   * @ojrole input
   * @hideconstructor
   * @ojimportmembers oj.ojDisplayOptions
   * @ojtsimport {module: "ojvalidationfactory-base", type: "AMD", imported:["Validation"]}
   * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
   * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
   * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
   * @ojtsimport {module: "ojvalidator-daterestriction", type: "AMD", importName: "DateRestrictionValidator"}
   * @ojtsimport {module: "ojvalidator-datetimerange", type: "AMD", importName: "DateTimeRangeValidator"}
   * @ojtsimport {module: "ojvalidator-length", type: "AMD", importName: "LengthValidator"}
   * @ojtsimport {module: "ojvalidator-numberrange", type: "AMD", importName: "NumberRangeValidator"}
   * @ojtsimport {module: "ojvalidator-regexp", type: "AMD", importName: "RegExpValidator"}
   * @ojtsimport {module: "ojvalidator-required", type: "AMD", importName: "RequiredValidator"}
   *
   * @classdesc
   * <h3 id="inputBaseOverview-section">
   *   Abstract inputBase component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputBaseOverview-section"></a>
   * </h3>
   * {@ojinclude "name":"validationAndMessagingDoc"}
   * <p>Description: The inputBase component takes care of general needs of other input components [i.e. text + password]
   *
   * @param {Object=} options a map of option-value pairs to set on the component
   */
  oj.__registerWidget(
    'oj.inputBase',
    $.oj.editableValue,
    {
      version: '1.0.0',
      widgetEventPrefix: 'oj',

      /**
       * Convenience Array which one can extend to set the attribute to a mandatory value if it doesn't exist or is set to something else
       * [
       * {
       *    "attr"              : string - attribute associated to the task
       *    "setMandatory"      : value it must be set to [i.e. type="text"]
       * }
       * ]
       *
       * Examples:
       * 1) [{"attr": "type", "setMandatory": "text"}]
       *
       * @expose
       * @memberof! oj.inputBase
       * @private
       */
      _ATTR_CHECK: [],

      /**
       * Class names to be applied to this.element()
       *
       * @expose
       * @memberof! oj.inputBase
       * @private
       */
      _CLASS_NAMES: '',

      /**
       * Class names to be applied to this.widget()
       *
       * Note that if this value is defined then the this.element will be wrapped with a root dom element
       *
       * @expose
       * @memberof! oj.inputBase
       * @private
       */
      _WIDGET_CLASS_NAMES: '',

      /**
       * Class names to be applied to the dom that wraps the input and trigger elements. It is a child
       * of the root dom element - this.widget().
       *
       * An element can be wrapped by a root dom element OR by both a root dom element and this extra
       * wrapper dom. the time and date pickers have two wrappers since we want to do an extra
       * wrapping when an input has trigger elements (date icon, for example). This is needed so we
       * can add extra dom to the root dom element for inline messaging.
       *
       * @expose
       * @memberof! oj.inputBase
       * @private
       */
      _ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES: '',

      /**
       * Array to be used for EditableValueUtils.initializeOptionsFromDom attribute is the html-5 dom attribute name.
       * If option is different, like in the case of readonly (readonly html vs readOnly
       * (camelcase) component option), specify both attribute and option.
       * NOTE: This is for the widget components only. Do not add custom element attributes here.
       * @expose
       * @memberof! oj.inputBase
       * @private
       */
      _GET_INIT_OPTIONS_PROPS_FOR_WIDGET: [
        { attribute: 'disabled', validateOption: true },
        { attribute: 'pattern' },
        { attribute: 'placeholder' },
        { attribute: 'value' },
        { attribute: 'readonly', option: 'readOnly', validateOption: true },
        { attribute: 'required', coerceDomValue: true, validateOption: true },
        { attribute: 'title' },
        { attribute: 'spellcheck' }
      ],
      /**
       * If defined will append a div element containing text to be read out by Jaws when focus is placed on the input element
       * and the value will be used to locate the translated text to be read out by Jaws.
       *
       * Note the component must also be wrapped
       *
       * @expose
       * @memberof! oj.inputBase
       * @private
       */
      _INPUT_HELPER_KEY: '',

      _FOCUS_HANDLER_KEY: 'focus',
      _BLUR_HANDLER_KEY: 'blur',
      _KEYDOWN_HANDLER_KEY: 'keydown',
      _KEYUP_HANDLER_KEY: 'keyup',
      _COMPOSITIONSTART_HANDLER_KEY: 'compositionstart',
      _COMPOSITIONEND_HANDLER_KEY: 'compositionend',
      _INPUT_HANDLER_KEY: 'input',
      _DROP_HANDLER_KEY: 'drop',
      _CLICK_HANDLER_KEY: 'click',

      _TEXT_FIELD_COUNTER_CLASS: 'oj-text-field-counter',
      _TEXT_FIELD_HIDDEN_ARIA_LIVE_CLASS: 'oj-text-field-hidden-aria-live',
      _TEXT_FIELD_MAX_LENGTH_REMAINING_KEY: 'accessibleMaxLengthRemaining',
      _TEXT_FIELD_MAX_LENGTH_EXCEEDED_KEY: 'accessibleMaxLengthExceeded',
      _counterSpanEl: null,
      _ariaLiveTimer: null,

      options: {
        /**
         * List of asynchronous validators used by the component when performing validation.
         * Use <code class="prettyprint">async-validators</code> when you need to
         * perform some validation work on the server. Otherwise, use
         * <code class="prettyprint">validators</code>, which are synchronous.
         * <p>
         * Each item in the Array is an instance that duck types {@link oj.AsyncValidator}.
         * Implicit validators created by a component when certain attributes
         * are present (e.g. <code class="prettyprint">required</code> attribute) are separate from
         * validators specified through the <code class="prettyprint">async-validators</code>
         * attribute and the <code class="prettyprint">validators</code> attribute.
         * At runtime when the component runs validation, it
         * combines the implicit validators with the list specified through the
         * <code class="prettyprint">validators</code>
         * attribute and also the list specified through the
         * <code class="prettyprint">async-validators</code> attribute.
         * Error messages are shown as soon as each async validator returns;
         * we do not wait until all the async validators finish to show errors.
         * If the component's valid state changes for the worse, it is also updated
         * as each validator returns so valid will be invalidShown
         * as soon as the first validator has an Error.
         * </p>
         * <p> It is recommended that you show the
         * value you are validating in the error message because if the async operation takes a while,
         * the user could be typing in a new value when the error message comes back
         * and might be confused what value the error is for. However, if the user enters a new value
         * (like presses Enter or Tab), a new validation lifecycle will start
         * and validation errors for the previous value will not be shown to the user.
         * If you need to format the value for the error message,
         * you can use e.g. for number
         * <code class="prettyprint">new NumberConverter.IntlNumberConverter(converterOption)</code>
         * to get the converter instance,
         * then call <code class="prettyprint">converter.format(value)</code>.
         * </p>
         * <p>
         * Hints exposed by validators are shown inline by default in the Redwood theme when the
         * field has focus.
         * In the Alta theme, validator hints are shown in a notewindow on focus,
         * or as determined by the
         * 'validatorHint' property set on the <code class="prettyprint">display-options</code>
         * attribute.
         * In either theme, you can turn off showing validator hints by using the
         * 'validatorHint' property set to 'none' on the <code class="prettyprint">display-options</code>
         * attribute.
         * </p>
         * <p>Since async validators are run asynchronously, you should wait on the BusyContext before
         * you check valid property or the value property. Alternatively you can add a callback to
         * the validChanged or valueChanged events.
         * </p>
         * <p>
         * The steps performed always, running validation and clearing messages is the same as
         * for the <code class="prettyprint">{@link oj.inputBase#validators}</code> attribute.
         * </p>
         * <br/>
         * @example <caption>Create an Object that duck-types the oj.AsyncValidator interface.
         * Bind the Object to the JET form component's async-validators attribute. The
         * validator's 'validate' method will be called when the user changes the input.</caption>
         *  self.asyncValidator1 = {
         *    // required validate method
         *    'validate': function(value) {
         *      return new Promise(function(resolve, reject) {
         *        var successful = someBackendMethod();
         *        if (successful) {
         *          resolve(true);
         *        } else {
         *          reject(new Error('The amount of purchase is too high. It is ' + value));
         *        }
         *      });
         *    },
         *    // optional hint attribute. hint shows up when user sets focus to input.
         *    'hint': new Promise(function (resolve, reject) {
         *      var formattedMaxPurchase = getSomeBackendFormattedMaxPurchase();
         *      resolve(maxPurchase + " is the maximum.");
         *    });
         *  };
         *  -- HTML --
         *  &lt;oj-input-text value="{{value}}"
         *  async-validators="[[[asyncValidator1]]]">&lt;/oj-input-text>
         * @example <caption>Initialize the component with multiple AsyncValidator
         * duck-typed instances:</caption>
         * -- HTML --
         * &lt;oj-input-text id="asyncValKo1" data-oj-context
                    valid="{{koAsyncValid}}" value="{{koAsyncValue}}"
                    required validators="[[[checkfoo, checkfooey]]]"
                    async-validators="[[[asyncValidator1, asyncValidator2]]]">&lt;/oj-input-text>
         *
         * @example <caption>Get or set the <code class="prettyprint">asyncValidators</code>
         * property after initialization:</caption>
         * // getter
         * var validators = myComp.asyncValidators;
         *
         * // setter
         * var myValidators = [{
         * 'validate' : function(value) {
         *   return new Promise(function(resolve, reject) {
         *   // mock server-side delay
         *   setTimeout(function () {
         *     if (value === "pass" || value === "another pass") {
         *       resolve(true);
         *     } else {
         *       reject(new Error("value isn't 'pass' or 'another pass'. It is " + value.));
         *     }
         *   },10);
         *   });
         * }
         * }];
         * myComp.asyncValidators = myValidators;
         * @ojdeprecated {since: '8.0.0', description: 'Use the validators property instead for either regular Validators or AsyncValidators.'}
         * @expose
         * @access public
         * @instance
         * @memberof oj.inputBase
         * @ojsignature  { target: "Type",
         *       value: "Array<oj.AsyncValidator<V>>",
         *       jsdocOverride: true}
         * @type {Array.<Object>}
         * @ojshortdesc Specifies a list of asynchronous validators used by the component when performing validation. Use async-validators when you need to perform some validation work on the server. See the Help documentation for more information.
         * @default []
         */
        asyncValidators: [],
        /**
         * <p>
         * When <code class="prettyprint">converter</code> property changes due to programmatic
         * intervention, the element performs various tasks based on the current state it is in. </br>
         *
         * <h4>Steps Performed Always</h4>
         * <ul>
         * <li>Any cached converter instance is cleared and new converter created. The converter hint is
         * pushed to messaging. E.g., notewindow displays the new hint(s).
         * </li>
         * </ul>
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>if element is valid when <code class="prettyprint">converter</code> property changes, the
         * display value is refreshed.</li>
         * <li>if element is invalid and is showing messages when
         * <code class="prettyprint">converter</code> property changes then all element messages are
         * cleared and full validation run using the current display value on the element.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated, and the error is shown.
         *   The display value is not refreshed in this case. </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event to clear custom errors. The
         *   display value is refreshed with the formatted value provided by converter.</li>
         * </ul>
         * </li>
         * <li>if element is invalid and has deferred messages when converter property changes, the
         *   display value is again refreshed with the formatted value provided by converter.</li>
         * </ul>
         *
         * <h4>Clearing Messages</h4>
         * <ul>
         * <li>Only messages created by the element are cleared.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.
         * Page authors can
         * choose to clear it explicitly when setting the converter option.</li>
         * </ul>
         * </p>
         * @ojfragment inputBaseConverterOptionDoc
         * @memberof oj.inputBase
         **/
        /**
         * Dictates component's autocomplete state.
         * This attribute indicates whether the value of the control can be automatically
         * completed by the browser. The common values are "on" and "off".
         * <p>Since this attribute passes through to the input element
         * unchanged, you can look at the html specs for detailed information for how browsers behave
         * and what values besides "on" and "off" you can set. The html spec says the default is "on",
         * so when autocomplete is not explicitly set, the browsers treat it as "on".
         * </p>
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}
         * @see {@link https://caniuse.com/#feat=input-autocomplete-onoff}
         * @see {@link https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute}
         *
         * @example <caption>Initialize component with <code class="prettyprint">autocomplete</code> attribute:</caption>
         * &lt;oj-some-element autocomplete="on">&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">autocomplete</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.autocomplete;
         *
         * // setter
         * myComp.autocomplete = "on";
         * @ojshortdesc Specifies a component's autocomplete state. See the Help documentation for more information.
         * @expose
         * @type {"on"|"off"|string=}
         * @default "on"
         * @instance
         * @since 4.0.0
         * @memberof oj.inputBase
         * @ojextension {_COPY_TO_INNER_ELEM: true}
         */
        autocomplete: undefined,
        /**
         * Autofocus is a Boolean that reflects the autofocus attribute, If it is set to true
         * then the associated component  will get input focus when the page is loaded.
         * Setting this property doesn't set the focus to the component:
         * it tells the browser to focus to it when the element is inserted in the document.
         *
         * @example <caption>Initialize component with <code class="prettyprint">autofocus</code> attribute:</caption>
         * &lt;oj-some-element autofocus>&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">autofocus</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.autofocus;
         *
         * // setter
         * myComp.autofocus = false;
         *
         * @expose
         * @type {boolean}
         * @alias autofocus
         * @default false
         * @instance
         * @since 4.0.0
         * @memberof oj.inputBase
         * @ojshortdesc Specifies whether the component will get input focus when the page is loaded. See the Help documentation for more information.
         * @ojextension {_COPY_TO_INNER_ELEM: true}
         */
        autofocus: false,
        /**
         * <p>
         * The oj-label sets the labelledBy property programmatically on the form component
         * to make it easy for the form component to find its oj-label component (a
         * document.getElementById call.)
         * </p>
         * <p>
         * The application developer should use the 'for'/'id api
         * to link the oj-label with the form component;
         * the 'for' on the oj-label to point to the 'id' on the input form component.
         * This is the most performant way for the oj-label to find its form component.
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
         * &lt;oj-label for="textId">Name:&lt;/oj-label>
         * &lt;oj-input-text id="textId">
         * &lt;/oj-input-text>
         * // ojLabel then writes the labelled-by attribute on the oj-input-text.
         * &lt;oj-label id="labelId" for="textId">Name:&lt;/oj-label>
         * &lt;oj-input-text id="textId" labelled-by"labelId">
         * &lt;/oj-input-text>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelledBy = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         *
         * @expose
         * @ojshortdesc The oj-label sets the labelledBy property programmatically on the form component. See the Help documentation for more information.
         * @type {string|null}
         * @default null
         * @public
         * @instance
         * @since 7.0.0
         * @memberof oj.inputBase
         */
        labelledBy: null,
        /**
         * Specifies the name of the component.
         *
         * @example <caption>Initialize component with <code class="prettyprint">name</code> attribute:</caption>
         * &lt;oj-some-element name="myName">&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">name</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.name;
         *
         * // setter
         * myComp.name = myName;
         *
         * @expose
         * @type {string}
         * @default ""
         * @alias name
         * @instance
         * @since 4.0.0
         * @ojdeprecated {since: '6.0.0', description: 'JET does not use form submit, so this is not needed.'}
         * @ojtsignore
         * @memberof oj.inputBase
         * @ojextension {_COPY_TO_INNER_ELEM: true}
         */
        name: '',
        /**
         * The placeholder text to set on the element.
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> attribute:</caption>
         * &lt;oj-some-element placeholder="User Name">&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
         * // getter
         * var myPh = myComp.placeholder;
         *
         * // setter
         * myComp.placeholder = myPlaceholder;
         *
         * If the attribute is not set and if a converter is set then the
         * converter hint is used. See displayOptions for details.
         *
         *
         * @expose
         * @access public
         * @instance
         * @memberof! oj.inputBase
         * @type {string}
         * @ojtranslatable
         */
        placeholder: '',
        /**
         * <p>The  <code class="prettyprint">rawValue</code> is the read-only property for retrieving
         * the current value from the input field in string form. The main consumer of
         * <code class="prettyprint">rawValue</code> is a converter.</p>
         * <p>
         * The <code class="prettyprint">rawValue</code> updates on the 'input' javascript event,
         * so the <code class="prettyprint">rawValue</code> changes as the value of the input is changed.
         * If the user types in '1,200' into the field, the rawValue will be '1', then '1,', then '1,2',
         * ..., and finally '1,200'. Then when the user blurs or presses
         * Enter the <code class="prettyprint">value</code> property gets converted and validated
         * (if there is a converter or validators) and then gets updated if valid.
         * </p>
         * <p>This is a read-only attribute so page authors cannot set or change it directly.</p>
         * @expose
         * @access public
         * @instance
         * @memberof! oj.inputBase
         * @ojshortdesc Read-only property used for retrieving the current value from the input field in string form. See the Help documentation for more information.
         * @type {string}
         * @ojsignature {target: "Type", value: "RV"}
         * @since 1.2.0
         * @readonly
         * @ojwriteback
         */
        rawValue: undefined,
        /**
         * Whether the component is readonly. The readonly property sets or returns whether an element is readonly, or not.
         * A readonly element cannot be modified. However, a user can tab to it, highlight it, focus on it, and copy the text from it.
         * If you want to prevent the user from interacting with the element, use the disabled property instead.
         * <p>
         * The default value for readonly is false. However, if the form component is a descendent of
         * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
         * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
         * The <code class="prettyprint">oj-form-layout</code> uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">readonly</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the readonly property if an ancestor provides it and
         * it is not explicitly set.
         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
         * not have its readonly attribute set, the form component's readonly will be true.
         * </p>
         * @example <caption>Initialize component with <code class="prettyprint">readonly</code> attribute:</caption>
         * &lt;oj-some-element readonly>&lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
         * // getter
         * var ro = myComp.readonly;
         *
         * // setter
         * myComp.readonly = false;
         *
         * @expose
         * @type {boolean}
         * @alias readonly
         * @ojshortdesc Specifies whether the component is read-only.  A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
         * @default false
         * @instance
         * @memberof! oj.inputBase
         */
        readOnly: false,
        /**
         * <p>
         * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
         * This is the default.
         * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
         * </p>
         * <p>
         * In the Redwood theme, by default, a Required text is rendered inline when the field is empty.
         * If user-assistance-density is 'compact', it will show on the label as an icon.
         * </p>
         * <p>The Required error text is based on Redwood UX designs, and it is not recommended that
         * it be changed.
         * To override the required error message,
         * use the <code class="prettyprint">translations.required</code> attribute.
         * The component's label text is passed in as a token {label} and can be used in the message detail.
         * </p>
         * <p>When required is set to true, an implicit
         * required validator is created, i.e.,
         * <code class="prettyprint">new RequiredValidator()</code>. The required validator is the only
         * validator to run during initial render, and its error is not shown to the user at this time;
         * this is called deferred validation. The required validator also runs during normal validation;
         * this is when the errors are shown to the user.
         * See the <a href="#validation-section">Validation and Messaging</a> section for details.
         * </p>
         * <p>
         * When the <code class="prettyprint">required</code> property changes due to programmatic intervention,
         * the component may clear component messages and run validation, based on the current state it's in. </br>
         *
         * <h4>Running Validation when required property changes</h4>
         * <ul>
         * <li>if component is valid when required is set to true, then it runs deferred validation on
         * the value property. If the field is empty, the valid state is invalidHidden. No errors are
         * shown to the user.
         * </li>
         * <li>if component is invalid and has deferred messages when required is set to false, then
         * component messages are cleared (messages-custom messages are not cleared)
         * but no deferred validation is run because required is false.
         * </li>
         * <li>if component is invalid and currently showing invalid messages when required is set, then
         * component messages are cleared and normal validation is run using the current display value.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated and the error is shown.
         *   </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event on the component to clear custom errors.</li>
         * </ul>
         * </li>
         * </ul>
         *
         * <h4>Clearing Messages when required property changes</h4>
         * <ul>
         * <li>Only messages created by the component, like validation messages, are cleared when the required property changes.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
         * </ul>
         *
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">required</code> attribute:</caption>
         * &lt;oj-some-element required>&lt;/oj-some-element><br/>
         *
         * @example <caption>Customize messages and hints used by implicit required validator when
         * <code class="prettyprint">required</code> attribute is set:</caption>
         * &lt;oj-some-element required translations='{"required": {
         *                 "hint": "custom: enter at least 3 alphabets",
         *                 "messageSummary": "custom: \'{label}\' is Required",
         *                 "messageDetail": "custom: please enter a valid value for \'{label}\'"}}'>
         * &lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
         * // getter
         * var rq = myComp.required;
         *
         * // setter
         * myComp.required = false;
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.inputBase
         * @ojshortdesc Specifies whether the component is required or optional. See the Help documentation for more information.
         * @type {boolean}
         * @default false
         * @since 0.7.0
         * @see #translations
         */
        required: false,

        /**
         * List of validators, synchronous or asynchronous,
         * used by component along with asynchronous validators from the deprecated async-validators option
         * and the implicit component validators when performing validation. Each item is either an
         * instance that duck types {@link oj.Validator} or {@link oj.AsyncValidator}.
         * <p>
         * Implicit validators are created by the element when certain attributes are present.
         * For example, if the <code class="prettyprint">required</code> attribute
         * is set, an implicit {@link oj.RequiredValidator} is created.
         * At runtime when the component runs validation, it
         * combines all the implicit validators with all the validators
         * specified through this <code class="prettyprint">validators</code> attribute
         * and the <code class="prettyprint">async-validators</code> attribute, and
         * runs all of them.
         * </p>
         * <p>
         * Hints exposed by validators are shown inline by default in the Redwood theme when the
         * field has focus.
         * In the Alta theme, validator hints are shown in a notewindow on focus,
         * or as determined by the
         * 'validatorHint' property set on the <code class="prettyprint">display-options</code>
         * attribute.
         * In either theme, you can turn off showing validator hints by using the
         * 'validatorHint' property set to 'none' on the <code class="prettyprint">display-options</code>
         * attribute.
         * </p>
         * <p>
         * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
         * help.instruction shows; if no help.instruction then validator hints show;
         * if none, then help-hints.definition shows; if none, then converter hint shows.
         * help-hints.source always shows along with the other help or hint.
         * </p>
         *
         * <p>
         * When <code class="prettyprint">validators</code> property changes due to programmatic
         * intervention, the component may decide to clear messages and run validation, based on the
         * current state it is in. </br>
         *
         * <h4>Steps Performed Always</h4>
         * <ul>
         * <li>The cached list of validator instances are cleared and new validator hints is pushed to
         * messaging. E.g., notewindow displays the new hint(s).
         * </li>
         * </ul>
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>if component is valid when validators changes, component does nothing other than the
         * steps it always performs.</li>
         * <li>if component is invalid and is showing messages when
         * <code class="prettyprint">validators</code> or
         * <code class="prettyprint">async-validators</code> changes then all component messages
         *  are cleared and full validation run using the display value on the component.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated and the error is shown.
         *   </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event to clear custom errors.</li>
         * </ul>
         * </li>
         * <li>if component is invalid and has deferred messages when validators changes, it does
         * nothing other than the steps it performs always.</li>
         * </ul>
         * </p>
         *
         * <h4>Clearing Messages</h4>
         * <ul>
         * <li>Only messages created by the component are cleared.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
         * </ul>
         * </p>

         *
         * @example <caption>Initialize the component with validator instance:</caption>
         * &lt;oj-some-element validators='[[[myRegExpValidator]]]'>
         * &lt;/oj-some-element>
         * self.myRegExpValidator = new RegExpValidator(
         * {pattern: "[a-zA-Z0-9]{3,}",
         * messageDetail: "You must enter at least 3 letters or numbers"});
         *
         *
         * @example <caption>Initialize the component with multiple validator instances:</caption>
         * self.checkfooey = {
         *   'validate' : function(value) {
         *     if (value === "fooey" || value === "pass") {
         *       return true;
         *     } else {
         *       throw new Error("value isn't fooey or pass");
         *     }
         *   },
         *  'getHint': function() {
         *    return null;
         *  }
         * };
         * self.checkbar = {
         * 'validate' : function(value) {
         *   if (value === "bar" || value === "pass") {
         *     return true;
         *   } else {
         *     throw new Error("value isn't bar or pass");
         *   }
         *  },
         *  'getHint': function() {
         *    return null;
         *  }
         * };
         * var validators = [checkfooey, checkbar]<br/>
         * ... HTML...
         * &lt;oj-some-element validators='[[validators]]'>
         * &lt;/oj-some-element>
         *
         * @example <caption>Get or set the <code class="prettyprint">validators</code> property after initialization:</caption>
         * // getter
         * var validators = myComp.validators;
         *
         * // setter
         * myComp.validators = myValidators;
         *
         * @expose
         * @access public
         * @instance
         * @default []
         * @memberof oj.inputBase
         * @ojshortdesc Specifies a list of synchronous validators for performing validation by the element. See the Help documentation for more information.
         * @ojsignature  [{ target: "Type",
         *       value: "Array<oj.Validator<V>|oj.AsyncValidator<V>>|null",
         *       jsdocOverride: true},
         * { target: "Type",
         *       value: "Array<oj.Validator<V>|oj.AsyncValidator<V>|
         *       oj.Validation.RegisteredValidator>|null",
         *       consumedBy: 'tsdep'}]
         * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredValidator'],
         *                description: 'Defining a validator with an object literal with validator type and
         *                  its options (aka JSON format) has been deprecated and does nothing. If needed, you can
         *                  make the JSON format work again by importing the deprecated ojvalidation module you need,
         *                  like ojvalidation-base.'}
         * @type {Array.<Object>}
         */
        validators: []
      },

      /**
       * The base method needs to be overriden so that one can perform attribute check/set [i.e. ojInputText can only have type="text"]
       *
       * @protected
       * @override
       * @param {Object} element - jQuery selection to save attributes for
       * @instance
       * @memberof! oj.inputBase
       */
      // eslint-disable-next-line no-unused-vars
      _SaveAttributes: function (element) {
        var ret = this._superApply(arguments);

        this._processAttrCheck();

        return ret;
      },

      /**
       * @protected
       * @override
       * @instance
       * @memberof! oj.inputBase
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        this._super(originalDefaults, constructorOptions);
        if (!this._IsCustomElement()) {
          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(
            this._GET_INIT_OPTIONS_PROPS_FOR_WIDGET,
            constructorOptions,
            this
          );
        }
      },

      /**
       * 1) Initializes the options
       * 2) If needed wraps the input element,
       *
       * @protected
       * @override
       * @instance
       * @memberof! oj.inputBase
       */
      _ComponentCreate: function () {
        var ret = this._superApply(arguments);
        var readOnly = this.options.readOnly;

        this._rtl = this._GetReadingDirection() === 'rtl';
        // JET-39086 - raw-value is not getting updated until space in android devices
        // In android device we need to update rawValue even for composition events
        // Get and store agent info
        this._isAndroidDevice = oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;

        // update element state using options
        if (typeof readOnly === 'boolean') {
          this.element.prop('readonly', readOnly);
        }

        // If we need to wrap this.element, we should do it in one pass instead of multiple
        // passes.  If elements are reparented multiple times, it will impact performance.
        if (this._DoWrapElement()) {
          var outerWrapper;
          var newParent;

          // Wraps the this.element and adds _WIDGET_CLASS_NAMES classes to the wrapped element
          if (this.OuterWrapper) {
            // this.OuterWrapper is only set for custom element.
            // For custom element, the outer wrapper is the custom element itself.
            outerWrapper = this.OuterWrapper;
            if (outerWrapper.className) {
              outerWrapper.className = outerWrapper.className + ' ' + this._WIDGET_CLASS_NAMES;
            } else {
              outerWrapper.className = this._WIDGET_CLASS_NAMES;
            }
          } else {
            // For widget, we need to create the outer wrapper around the element that the component binds to.
            outerWrapper = document.createElement('div');
            outerWrapper.className = this._WIDGET_CLASS_NAMES;
            // this.element doesn't always have a parent (e.g. when it's in a template)
            if (this.element[0].parentNode) {
              this.element[0].parentNode.insertBefore(outerWrapper, this.element[0]);
            }
            // For now, just insert the outer wrapper before this.element.
            // Don't bother reparenting this.element until all the other wrappers have been created.
          }
          newParent = outerWrapper;
          this._wrapper = $(outerWrapper);

          // may need to do an extra wrapping if the element has triggers
          if (this._DoWrapElementAndTriggers()) {
            var containerWrapper = this._CreateContainerWrapper();
            outerWrapper.appendChild(containerWrapper);
            newParent = containerWrapper;

            // _CreateMiddleWrapper may return null (e.g. oj-date-picker)
            var middleWrapper = this._CreateMiddleWrapper();
            if (middleWrapper) {
              containerWrapper.appendChild(middleWrapper);
              newParent = middleWrapper;
            }
          }

          // Only reparent this.element once
          newParent.appendChild(this.element[0]);

          this._focusable({
            element: this._wrapper,
            applyHighlight: true
          });
        } else {
          this._focusable({
            element: this.element,
            applyHighlight: true
          });
        }

        // We need to add style classes before _AfterCreate() is called because textarea needs to use these in _AfterCreate() to determine its height.
        if (this._CLASS_NAMES) {
          this.element.addClass(this._CLASS_NAMES);
          this.element.addClass('oj-text-field-input');
        }

        // remove pattern attribute to not trigger html5 validation + inline bubble
        //    if ('pattern' in savedAttributes)
        //    {
        //      node.removeAttr('pattern');
        //    }

        this._defaultRegExpValidator = {};
        this._eventHandlers = null;

        if (this._hasMaxLength()) {
          this.lengthFilter = new LengthFilter(this.options.length);
        }

        return ret;
      },
      /**
       * 1) Updates component state based on the option values
       * 2) Adds the classname to the element [intentionally postponing till this process since the component might need to
       *    reset this.element for some reason]
       * 3) Hooks up the blur handler
       * 4) If necessary appends an input helper to be read out by Jaws accessibility reader
       *
       * @protected
       * @override
       * @instance
       * @memberof! oj.inputBase
       */
      _AfterCreate: function () {
        var ret = this._superApply(arguments);
        var options = ['disabled', 'readOnly'];
        var self = this;

        this._refreshRequired(this.options.required);

        // attach handlers such as blur, keydown, and drop. placed in a function so to detach the handlers as well
        // when the options change
        this._attachDetachEventHandlers();

        this._AppendInputHelper();

        // some components need to be able to announce dynamic changes to AT.
        this._AppendAriaLiveHelper();

        $.each(options, function (index, ele) {
          if (self.options[ele]) {
            self._processOptions(ele, self.options[ele]);
          }
        });

        if (this._IsCustomElement()) {
          // Don't do this for datepicker and datetimepicker because those are
          // divs not inputs, so make this overrideable.
          let labelledBy = this.options.labelledBy;
          this._initLabelledByForInputBase(labelledBy);
        }
        if (this._hasMaxLength()) {
          this._processLengthCounterAttr(this.options.length.counter);
        }
        return ret;
      },
      /**
       * Whether the component is required.
       *
       * @return {boolean} true if required; false
       *
       * @memberof! oj.inputBase
       * @instance
       * @protected
       * @override
       */
      _IsRequired: function () {
        return this.options.required;
      },
      /**
       * Performs post processing after required option is set by taking the following steps.
       *
       * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
       * run full validation with UI value (we don't know if the UI error is from a required validator
       * or something else);<br/>
       * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
       * updated<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to valueChanged to clear custom errors.<br/>
       *
       * - if component is invalid and has messagesHidden -> required: false -> clear component
       * errors; no deferred validation is run.<br/>
       * - if component has no error -> required: true -> run deferred validation (we don't want to flag
       * errors unnecessarily)<br/>
       * - messagesCustom is never cleared<br/>
       *
       * @param {string} option
       *
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _AfterSetOptionRequired: ojeditablevalue.EditableValueUtils._AfterSetOptionRequired,

      /**
       * When validators option changes, take the following steps.
       *
       * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
       * - if component is valid -> validators changes -> no change<br/>
       * - if component is invalid has messagesShown -> validators changes -> clear all component
       * messages and re-run full validation on displayValue. if there are no errors push value to
       * model;<br/>
       * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
       * the required-ness of component <br/>
       * - messagesCustom is not cleared.<br/>
       *
       * NOTE: The behavior applies to any option that creates implicit validators - min, max, pattern,
       * etc. Components can call this method when these options change.
       *
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _AfterSetOptionValidators: ojeditablevalue.EditableValueUtils._AfterSetOptionValidators,
      /**
       * When async-validators attribute changes, take the following steps.
       *
       * - Clear the cached normalized list of all validator instances. push new hints to messaging.<br/>
       * - if component is valid -> validators changes -> no change<br/>
       * - if component is invalid has messagesShown -> validators changes -> clear all component
       * messages and re-run full validation on displayValue. if there are no errors push value to
       * model;<br/>
       * - if component is invalid has messagesHidden -> validators changes -> do nothing; doesn't change
       * the required-ness of component <br/>
       * - messagesCustom is not cleared.<br/>
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _AfterSetOptionAsyncValidators: ojeditablevalue.EditableValueUtils._AfterSetOptionAsyncValidators,
      /**
       * Performs post processing after converter option changes by taking the following steps.
       *
       * - always push new converter hint to messaging <br/>
       * - if component has no errors -> refresh UI value<br/>
       * - if component is invalid has messagesShown -> clear all component errors and run full
       * validation using display value. <br/>
       * &nbsp;&nbsp;- if there are validation errors, value is not pushed to model; messagesShown is
       * updated.<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to valueChanged to clear custom errors.<br/>
       * - if component is invalid has messagesHidden -> refresh UI value. no need to run deferred
       * validations. <br/>
       * - messagesCustom is never cleared<br/>
       *
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _AfterSetOptionConverter: ojeditablevalue.EditableValueUtils._AfterSetOptionConverter,
      /**
       * Called when converter option changes and we have gotten the new converter
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _ResetConverter: ojeditablevalue.EditableValueUtils._ResetConverter,
      /**
       * Returns the normalized converter instance.
       *
       * @return {Object} a converter instance or null
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _GetConverter: ojeditablevalue.EditableValueUtils._GetConverter,
      /**
       * This returns an array of all validators
       * normalized from the validators option set on the component. <br/>
       * @return {Array} of validators.
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _GetNormalizedValidatorsFromOption: ojeditablevalue.EditableValueUtils._GetNormalizedValidatorsFromOption,
      /**
       * This returns an array of all async validators
       * normalized from the async-validators attribute set on the component. <br/>
       * @return {Array} of validators.
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _GetNormalizedAsyncValidatorsFromOption:
        ojeditablevalue.EditableValueUtils._GetNormalizedAsyncValidatorsFromOption,

      /**
       * Called when the display value on the element needs to be updated. This method updates the
       * (content) element value. Widgets can override this method to update the element
       * appropriately.
       *
       * @param {string} displayValue the new string to be displayed
       *
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _SetDisplayValue: function (displayValue) {
        this._superApply(arguments);
        if (this.options.readOnly) {
          let readonlyElem = this._getReadonlyDiv();
          if (readonlyElem) {
            readonlyElem.textContent = displayValue;
          }
        }
      },
      /**
       * Draw a readonly div or update one. When readonly, this div is shown and
       * the input has display:none on it through theming, and vice versa.
       * We set the textContent in _SetDisplayValue() if readonly
       * @param {HTMLElement} pass in this.element[0]
       * @memberof! oj.inputBase
       * @instance
       * @private
       */
      _createOrUpdateReadonlyDiv: ojeditablevalue.EditableValueUtils._createOrUpdateReadonlyDiv,
      _processOptions: function (key, value) {
        if (key === 'disabled') {
          this.element.prop('disabled', value);
        }

        if (key === 'readOnly') {
          this.element.prop('readonly', value);
          // if readonly, then create the readonly div if it doesn't exist
          // and set its textContent to the input's display value.
          if (value) {
            // Putting it inside of DoWrapElement keeps it from getting called twice for
            // ojinputdatetime, which calls it once for ojinputdatetime and another for ojinputdatetime's
            // ojInputTime instantiation. DoWrapElement calls _isIndependentInput in ojinputtime.
            this._createOrUpdateReadonlyDiv(
              this.element[0],
              this._DoWrapElement() && this.OuterWrapper
            );
          }
          // last thing we do is refresh the state theming since this
          // affects the display css of the textarea and readonlydiv dom nodes.
          this._refreshStateTheming('readOnly', value);
        }

        if (key === 'disabled' || key === 'readOnly') {
          this._attachDetachEventHandlers();
        }
      },

      /**
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @override
       */
      // eslint-disable-next-line no-unused-vars
      _setOption: function (key, value, flags) {
        // save off old value before we update this.options in super
        // so we can compare old with new option value.
        const oldValue = this.options[key];
        var retVal = this._superApply(arguments);
        switch (key) {
          case 'disabled':
          case 'readOnly':
            this._processOptions(key, value);
            break;
          case 'pattern':
            this._defaultRegExpValidator.regexp = this._getImplicitRegExpValidator();
            this._AfterSetOptionValidators();
            break;
          case 'labelledBy': {
            // pass in old option value and new option value for labelledBy
            this._setLabelledByForInputBase(oldValue, value);
            break;
          }
          default:
            break;
        }
        return retVal;
      },
      /**
       * Performs post processing after _SetOption() is called. Different options when changed perform
       * different tasks. See _AfterSetOption[OptionName] method for details.
       *
       * @param {string} option
       * @param {Object|string=} previous
       * @param {Object=} flags
       * @protected
       * @memberof! oj.inputBase
       * @instance
       */
      // eslint-disable-next-line no-unused-vars
      _AfterSetOption: function (option, previous, flags) {
        this._superApply(arguments);
        switch (option) {
          case 'readOnly':
            this._AfterSetOptionDisabledReadOnly(option, ojeditablevalue.EditableValueUtils.readOnlyOptionOptions);
            break;
          case 'required':
            this._AfterSetOptionRequired(option);
            break;
          case 'validators':
            this._AfterSetOptionValidators(option);
            break;
          case 'asyncValidators':
            this._AfterSetOptionAsyncValidators(option);
            break;
          case 'converter':
            this._AfterSetOptionConverter(option);
            break;
          case 'length':
            this._AfterSetOptionLength(this.options.length);
            break;
          default:
            break;
        }
      },

      /**
       * Checks if the component has length attribute
       *
       * @protected
       * @memberof oj.ojInputBase
       * @instance
       */
      _hasMaxLength: function () {
        return this.options.length && this.options.length.max && !isNaN(this.options.length.max);
      },

      /**
       * Sets up the labelledBy changes when labelledBy option changes.
       * This is overridden for the datepicker and datetimepicker since
       * the way you link up label to the component is like the 'set' components.
       * aria-labelledby.
       *
       * @protected
       * @memberof oj.ojInputBase
       * @instance
       */
      _setLabelledByForInputBase: function (oldValue, labelledBy) {
        if (labelledBy) {
          const id = this._GetContentElement()[0].id;
          this._labelledByUpdatedForInputComp(labelledBy, id);
        }
      },

      /**
       * Initializes labelledBy.
       * This is overridden for the datepicker and datetimepicker since
       * the way you link up label to the component is like the 'set' components.
       * aria-labelledby.
       *
       * @protected
       * @memberof oj.ojInputBase
       * @instance
       */
      _initLabelledByForInputBase: function (labelledBy) {
        this._initInputIdLabelForConnection(
          this._GetContentElement()[0],
          this.widget()[0].id,
          labelledBy
        );
      },

      /**
       * Filters input text based on length.max value and set to the component
       *
       * @protected
       * @memberof oj.ojInputBase
       * @instance
       */
      _filterTextOnValueChange: function () {
        if (this.options.length.max) {
          var currentVal = this.options.rawValue;
          var proposedVal = this.options.value;
          this._filterTextAndSetValues(currentVal, proposedVal, true, false);
        }
      },

      /**
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @override
       */
      _destroy: function () {
        var ret = this._superApply(arguments);

        this.element.off('blur drop keydown keyup compositionstart compositionend input');

        if (this._inputHelper) {
          this._inputHelper.remove();
        }

        // unwrap only for non custom elements.
        // for custom elements, the wrapper is created by apps. So no need to replace it with input.
        if (this._DoWrapElement() && !this._IsCustomElement()) {
          //  - DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout
          if (this._DoWrapElementAndTriggers()) {
            DomUtils.unwrap(this.element, this._wrapper);
          } else {
            DomUtils.unwrap(this.element);
          }
        }

        return ret;
      },

      /**
       *
       * @protected
       * @override
       * @instance
       * @memberof! oj.inputBase
       */
      _SetLoading: function () {
        this._super();
        // don't want to type into the field when it is loading.
        this.element.prop('readonly', true);
      },

      /**
       *
       * @protected
       * @override
       * @instance
       * @memberof! oj.inputBase
       */
      _ClearLoading: function () {
        this._super();
        this.element.prop('readonly', this.options.readOnly);
      },

      _attachDetachEventHandlers: function () {
        if (!this.options.readOnly && !this.options.disabled) {
          this._eventHandlers = {};

          var focusHandler = $.proxy(this._onFocusHandler, this);
          var blurHandler = $.proxy(this._onBlurHandler, this);
          var keyDownHandler = $.proxy(this._onKeyDownHandler, this);
          var keyUpHandler = $.proxy(this._onKeyUpHandler, this);
          var compositionStartHandler = $.proxy(this._onCompositionStartHandler, this);
          var compositionEndHandler = $.proxy(this._onCompositionEndHandler, this);
          var inputHandler = $.proxy(this._onInputHandler, this);
          var dropHandler = function () {
            this.focus();
          };

          this.element.on(this._FOCUS_HANDLER_KEY, focusHandler);
          this.element.on(this._BLUR_HANDLER_KEY, blurHandler);
          this.element.on(this._KEYDOWN_HANDLER_KEY, keyDownHandler);
          this.element.on(this._KEYUP_HANDLER_KEY, keyUpHandler);
          this.element.on(this._COMPOSITIONSTART_HANDLER_KEY, compositionStartHandler);
          this.element.on(this._COMPOSITIONEND_HANDLER_KEY, compositionEndHandler);
          this.element.on(this._INPUT_HANDLER_KEY, inputHandler);

          // other than FF when a drop is dispatched focus is placed back on the element
          // this would cause difference in behavior of the observable change [as set within blur], so in order to provide
          // consistency placing the focus on the element after the drop
          this.element.on(this._DROP_HANDLER_KEY, dropHandler);

          this._eventHandlers[this._FOCUS_HANDLER_KEY] = focusHandler;
          this._eventHandlers[this._BLUR_HANDLER_KEY] = blurHandler;
          this._eventHandlers[this._KEYDOWN_HANDLER_KEY] = keyDownHandler;
          this._eventHandlers[this._KEYUP_HANDLER_KEY] = keyUpHandler;
          this._eventHandlers[this._COMPOSITIONSTART_HANDLER_KEY] = compositionStartHandler;
          this._eventHandlers[this._COMPOSITIONEND_HANDLER_KEY] = compositionEndHandler;
          this._eventHandlers[this._INPUT_HANDLER_KEY] = inputHandler;
          this._eventHandlers[this._DROP_HANDLER_KEY] = dropHandler;
        } else if (this._eventHandlers) {
          // meaning either it is readOnly or is disabled, remove the handlers if they were attached previously
          var eventEntries = [
            this._FOCUS_HANDLER_KEY,
            this._BLUR_HANDLER_KEY,
            this._KEYDOWN_HANDLER_KEY,
            this._KEYUP_HANDLER_KEY,
            this._COMPOSITIONSTART_HANDLER_KEY,
            this._COMPOSITIONEND_HANDLER_KEY,
            this._INPUT_HANDLER_KEY,
            this._DROP_HANDLER_KEY
          ];

          for (var i = 0, j = eventEntries.length; i < j; i++) {
            if (this._eventHandlers[eventEntries[i]]) {
              this.element.off(eventEntries[i], this._eventHandlers[eventEntries[i]]);
              delete this._eventHandlers[eventEntries[i]];
            }
          }
        }
      },

      /**
       * when below listed options are passed to the component, corresponding CSS will be toggled
       * @private
       * @memberof! oj.inputBase
       * @const
       * @type {Object}
       */
      _OPTION_TO_CSS_MAPPING: {
        readOnly: 'oj-read-only'
      },

      /**
       * Performs the attribute check/set by using _ATTR_CHECK variable [i.e. ojInputText must have type be set to "text"].
       *
       * @private
       * @memberof! oj.inputBase
       */
      _processAttrCheck: function () {
        var attrCheck = this._ATTR_CHECK;

        for (var i = 0, j = attrCheck.length; i < j; i++) {
          var attr = attrCheck[i].attr;
          var setMandatoryExists = 'setMandatory' in attrCheck[i];

          // if it doesn't exist just have to check whether one should set it to a mandatory value
          if (setMandatoryExists) {
            this.element.attr(attr, attrCheck[i].setMandatory); // @HTMLUpdateOK
          }
        }
      },

      /**
       * Invoked when focus is triggered of the this.element
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      _onFocusHandler: function () {
        if (this._hasMaxLength()) {
          // on focus, we add the aria-live remaining chars message if needed.
          this._processLengthCounterAttr(this.options.length.counter);
        }
      },

      /**
       * Invoked when blur is triggered of the this.element
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      _onBlurHandler: function (event) {
        this._SetValue(this._GetDisplayValue(), event);

        if (this._hasMaxLength()) {
          // on blur, we want to remove the aria-live with the remaining chars message.
          this._processLengthCounterAttr(this.options.length.counter);
        }
      },

      /**
       * Invoked when keydown is triggered of the this.element
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      // eslint-disable-next-line no-unused-vars
      _onKeyDownHandler: function (event) {},

      /**
       * Invoked when keyup is triggered of the this.element
       *
       * When of keyCode is of Enter, invoke _SetValue on it
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      _onKeyUpHandler: function (event) {
        if (event.keyCode === $.ui.keyCode.ENTER) {
          this._SetValue(this._GetDisplayValue(), event);
        }
      },

      /**
       * Invoked when the compositionstart event happens
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      _onCompositionStartHandler: function () {
        // Keep track of whether the user is composing a character
        this._isComposing = true;
      },

      /**
       * Invoked when the compositionend event happens
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      _onCompositionEndHandler: function (event) {
        this._isComposing = false;

        // On some browsers, compositionend event is fired before the final input event,
        // while it's the other way around on other browsers.  Just update rawValue here
        // anyway since _SetRawValue will compare the value before actually updating it.
        this._SetRawValue(this._GetContentElement().val(), event);

        // For languages like Japanese/Chinese, we need to update the counter once composing is over.
        if (this._hasMaxLength()) {
          this._onInputHandler(event);
        }
      },

      /**
       * Invoked when the input event happens
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @param {Event} event
       */
      _onInputHandler: function (event) {
        // Update rawValue only if the user is not in the middle of composing a character.
        // Non-latin characters can take multiple keystrokes to compose one character.
        // The keystroke sequence is bracketed by compositionstart and compositionend events,
        // and each keystroke also fires the input event.  Including the intermediate input
        // in rawValue makes it hard to do meaningful validation.
        // JET-39086 - raw-value is not getting updated until space in android devices
        // In android devices, typing in an English word will behave similar to what one
        // would see when they compose a CJK character in desktop devices. So, we need to
        // update the raw-value for all the input events in Android devices without considering
        // composition events so that the property gets updated for each english character and not
        // only for delimiters. In GBoard all the CJK keyboard layouts directly allow users
        // to input a CJK character, so we do not need to rely on composition events for that.
        // In Japanese keyboard, one of the three available layouts uses english chars
        // to compose a Japanese character in which case circumventing the logic would end up
        // updating the property with garbage values. But, it is highly unlikely for one to
        // use this layout as the other two layouts would allow users to directly type in Japanese
        // characters. So, for now we will not have to worry about composition events in
        // Android devices.
        if (!this._isComposing || this._isAndroidDevice) {
          if (this._hasMaxLength()) {
            // JET-35424 - Text Area - Pasting a value that exceeds the character limit,
            // should be truncated
            // pass the pasted text as both the current and proposed values so that even if it
            // exceeds the max length, it will be truncated and set
            var text = this._GetContentElement().val();
            this._filterTextAndSetValues(text, text, false, true);
          } else {
            this._SetRawValue(this._GetContentElement().val(), event);
          }
        }
      },

      /**
       * Whether the this.element should be wrapped in a root dom element.
       * Method so that additional conditions can be placed
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @return {boolean}
       */
      _DoWrapElement: function () {
        return this._WIDGET_CLASS_NAMES;
      },

      /**
       * Whether the this.element and triggers should be wrapped.
       * Method so that additional conditions can be placed
       *
       * @ignore
       * @protected
       * @memberof! oj.inputBase
       * @return {boolean}
       */
      _DoWrapElementAndTriggers: function () {
        return this._ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES;
      },

      /**
       * Wraps the this.element and adds _ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES classes to the wrapped element.
       * We might need this extra wrapper if the component has input+triggers (like inputDate).
       *
       * @protected
       * @ignore
       * @memberof! oj.inputBase
       * @return {Element}
       */
      _CreateContainerWrapper: function () {
        var wrapper = document.createElement('div');
        wrapper.setAttribute('role', 'presentation');
        wrapper.className = this._ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES;
        return wrapper;
      },

      /**
       * In some complex components [i.e. datepicker], when the input element receives focus we wish to have Jaws read
       * out some content.
       *
       * For those case does this method exist.
       *
       * @protected
       * @instance
       * @memberof! oj.inputBase
       */
      _AppendInputHelper: function () {
        if (this._INPUT_HELPER_KEY && this._DoWrapElement()) {
          var describedBy = this.element.attr('aria-describedby') || '';
          var helperDescribedById = this._GetSubId(this._INPUT_HELPER_KEY);

          describedBy += ' ' + helperDescribedById;
          this.element.attr('aria-describedby', describedBy);
          this._inputHelper = $(
            "<div class='oj-helper-hidden-accessible' aria-hidden='true' id='" +
              helperDescribedById +
              "'>" +
              this._EscapeXSS(this.getTranslatedString(this._INPUT_HELPER_KEY)) +
              '</div>'
          );

          this._AppendInputHelperParent().append(this._inputHelper); // @HTMLUpdateOK append action of the div element created with escaped translated text, so ok
        }
      },

      /**
       * The aria-live helper div for accessibility cases that need to announce dynamic content to the AT user.
       * Includes a polite and assertive div
       * Currently, we only append this for components that have a length.max
       *
       * @protected
       * @instance
       * @memberof! oj.inputBase
       */
      _AppendAriaLiveHelper: function () {
        var ariaLiveHelperParent = this._AppendInputHelperParent();

        // Only add the ariaLive div if there is a
        // length.max set.
        if (this.options.length && this.options.length.max) {
          var hiddendiv = document.createElement('div');
          hiddendiv.classList.add('oj-helper-hidden-accessible');
          hiddendiv.classList.add(this._TEXT_FIELD_HIDDEN_ARIA_LIVE_CLASS);
          var politeDiv = document.createElement('div');
          politeDiv.setAttribute('aria-live', 'polite');
          var assertiveDiv = document.createElement('div');
          assertiveDiv.setAttribute('aria-live', 'assertive');
          hiddendiv.appendChild(politeDiv);
          hiddendiv.appendChild(assertiveDiv);
          ariaLiveHelperParent[0].appendChild(hiddendiv);
        }
      },

      /**
       * Helper function to escape Cross site script text
       *
       * @param {string} escapeMe
       * @return {jQuery|string}
       * @memberof! oj.inputBase
       * @ignore
       */
      _EscapeXSS: function (escapeMe) {
        return $('<span>' + escapeMe + '</span>').text();
      },

      /**
       * Which parent node the inputHelper should be appended to. Usually do not need to override.
       *
       * @protected
       * @instance
       * @memberof! oj.inputBase
       */
      _AppendInputHelperParent: function () {
        return this.widget();
      },

      /**
       * Sets up a default synchronous regexp validator if pattern is set and the
       * app has not overridden the async regexp validator that JET registered.
       * If the validator is created, it is added to the
       * this._defaultRegExpValidator type->validator instance map
       *
       * @ignore
       * @protected
       * @override
       * @instance
       * @memberof! oj.inputBase
       * @return {Object} returns the implicit validators map, where the key is the
       * validator type, e.g., 'regexp'.
       */
      _GetImplicitValidators: function () {
        var ret = this._superApply(arguments);

        // register a default RegExp validator if we have a valid pattern
        if (this.options.pattern) {
          var validator = this._getImplicitRegExpValidator();
          this._defaultRegExpValidator.regexp = validator;
        }
        return Object.assign(this._defaultRegExpValidator, ret);
      },

      /**
       * Whether the a value can be set on the component. For example, if the component is
       * disabled or readOnly then setting value on component is a no-op.
       *
       * @see #_SetValue
       * @return {boolean}
       * @memberof! oj.inputBase
       * @override
       * @instance
       * @protected
       */
      _CanSetValue: function () {
        var readOnly;
        var superCanSetValue = this._super();

        if (!superCanSetValue) {
          return false;
        }

        readOnly = this.options.readOnly || false;
        return !readOnly;
      },
      /**
       * Toggles css selector on the widget. E.g., when readonly property changes,
       * the oj-read-only selector needs to be toggled.
       * @param {string} option
       * @param {Object|string} value
       * @memberof! oj.inputBase
       * @private
       */
      _refreshStateTheming: function (option, value) {
        if (Object.keys(this._OPTION_TO_CSS_MAPPING).indexOf(option) !== -1) {
          // value is a boolean
          this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
        }
      },

      /**
       * Returns the regexp validator instance or creates it if needed and caches it.
       * @private
       * @memberof! oj.inputBase
       */
      _getImplicitRegExpValidator: function () {
        if (!this.options.pattern) {
          return null;
        }
        var regexpOptions = { pattern: this.options.pattern, label: this._getLabelText() };

        $.extend(regexpOptions, this.options.translations.regexp || {});
        var regexpValidator = new RegExpValidator(regexpOptions);

        return regexpValidator;
      },

      /**
       * Return the element on which aria-label can be found.
       * Usually this is the root element, but some components have aria-label as a transfer attribute,
       * and aria-label set on the root element is transferred to the inner element.
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _GetAriaLabelElement: function () {
        return this.element[0];
      },

      /**
       * This helper function will generate ids using widget's uuid as unique identifier for
       * wai-aria and other necessary ids
       *
       * @ignore
       * @protected
       * @param {string} sub
       * @return {string}
       * @memberof! oj.inputBase
       */
      _GetSubId: function (sub) {
        return this.uuid + '_' + sub;
      },

      /**
       * @ignore
       * @protected
       * @return {boolean}
       * @memberof! oj.inputBase
       */
      _IsRTL: function () {
        return this._rtl;
      },

      /**
       * Returns if the element is a text field element or not.
       * @memberof oj.ojInputBase
       * @instance
       * @protected
       * @return {boolean}
       */
      _IsTextFieldComponent: function () {
        return true;
      },

      /**
       * Wrappers the input component "content element".
       * @ignore
       * @protected
       * @memberof oj.ojInputBase
       * @instance
       */
      _GetContentWrapper: function () {
        var contentElement = this._GetContentElement()[0];
        if (!contentElement.parentElement.classList.contains('oj-text-field-middle')) {
          var containerElement = document.createElement('DIV');
          containerElement.classList.add('oj-text-field-middle');
          contentElement.parentElement.insertBefore(containerElement, contentElement);
          containerElement.appendChild(contentElement);
        }

        return contentElement.parentElement;
      },

      /**
       * Removes the previous lengthFilter instance and creates a new one with new length filter options
       * @memberof oj.ojInputBase
       * @instance
       * @protected
       * @ignore
       */
      _resetLengthFilter: function (lengthOptions) {
        this.lengthFilter = new LengthFilter(lengthOptions);
      },

      /**
       * Refresh the input element value based on the newly set filter options.
       * @memberof oj.ojInputBase
       * @instance
       * @protected
       * @ignore
       */
      _AfterSetOptionLength: function (lengthOptions) {
        if (lengthOptions.max) {
          this._resetLengthFilter(lengthOptions);
          var wrapperElem = this._GetContentWrapper();
          var currentVal;
          if (wrapperElem.parentElement.parentNode.classList.contains('oj-complete')) {
            currentVal = this.element[0].value;
          } else {
            currentVal = this.options.value;
          }
          this._filterTextAndSetValues(currentVal, currentVal, true, false);
        }
        this._processLengthCounterAttr(lengthOptions.counter);
      },

      /**
       * Creates a click handler method that is bound to 'this' object
       * @memberof oj.ojInputBase
       * @instance
       * @protected
       * @ignore
       */
      _setFocusOnTextAreaBind: function () {
        this._setFocusOnTextArea = function () {
          this.element[0].focus();
        }.bind(this);
      },

      /**
       *
       * Processes the length attribute set on the component
       * @memberof oj.ojInputBase
       * @instance
       * @protected
       * @ignore
       */
      _processLengthCounterAttr: function (lengthCounterAttr) {
        var wrapperElem = this._GetContentWrapper().parentElement;
        var counterEl = wrapperElem.querySelector('.' + this._TEXT_FIELD_COUNTER_CLASS);
        var hiddenAriaLiveEl = wrapperElem.parentNode.querySelector(
          '.' + this._TEXT_FIELD_HIDDEN_ARIA_LIVE_CLASS
        );
        var textLength = this.lengthFilter ? this.lengthFilter.calcLength(this.options.rawValue) : -1;
        var remainingChars = '';
        var newAriaLiveContent = '';
        var hasFocus = document.activeElement === this.element[0];

        if (
          lengthCounterAttr === 'none' ||
          lengthCounterAttr === undefined ||
          lengthCounterAttr === null ||
          this.options.length.max === 0 ||
          this.options.disabled ||
          this.options.readOnly
        ) {
          // remove the icon if it is there
          if (counterEl) {
            counterEl.removeEventListener(this._CLICK_HANDLER_KEY, this._setFocusOnTextArea);
            wrapperElem.removeChild(counterEl);
          }
          this._counterSpanEl = null;

          // remove the aria live text if textLength === -1 or length.max === 0 or
          // options.disabled or options.readOnly are true
          if (
            textLength === -1 ||
            this.options.length.max === 0 ||
            this.options.disabled ||
            this.options.readOnly ||
            !hasFocus
          ) {
            newAriaLiveContent = '';
          } else {
            remainingChars = this.options.length.max - textLength;

            // update aria live
            newAriaLiveContent = this.getTranslatedString(this._TEXT_FIELD_MAX_LENGTH_REMAINING_KEY, {
              chars: remainingChars
            });
          }
        } else {
          if (counterEl === null) {
            var textFieldCounter = document.createElement('div');
            textFieldCounter.className = this._TEXT_FIELD_COUNTER_CLASS;
            if (this._TEXTAREA_COUNTER_CONTAINER) {
              textFieldCounter.className += ' ' + this._TEXTAREA_COUNTER_CONTAINER;
            }

            counterEl = document.createElement('span');
            if (this._INPUTTEXT_COUNTER_EL) {
              counterEl.className += ' ' + this._INPUTTEXT_COUNTER_EL;
            }

            if (this._TEXTAREA_COUNTER_EL) {
              counterEl.className += ' ' + this._TEXTAREA_COUNTER_EL;
              this._setFocusOnTextAreaBind();
              textFieldCounter.addEventListener(this._CLICK_HANDLER_KEY, this._setFocusOnTextArea);
            }

            textFieldCounter.appendChild(counterEl);
            wrapperElem.appendChild(textFieldCounter);
            this._counterSpanEl = counterEl;
            this._counterSpanEl.textContent = '';
          }

          // if textLength isn't -1, which means there is a length filter, we update the aria-live
          // characters remaining.
          if (textLength !== -1) {
            remainingChars = this.options.length.max - textLength;

            // Only update when the component has focus.  Otherwise, the aria-live can be announced at times that it's not appropriate.
            if (hasFocus) {
              // update aria live
              newAriaLiveContent = this.getTranslatedString(
                this._TEXT_FIELD_MAX_LENGTH_REMAINING_KEY,
                {
                  chars: remainingChars
                }
              );
            }
          }
        }

        // If we have an active counter span, update it.
        if (this._counterSpanEl) {
          this._counterSpanEl.textContent = remainingChars;
        }

        // Update the aria live element if it exists and the new content is different
        if (hiddenAriaLiveEl) {
          // Only update the aria-live div when the user has paused for more than
          // 500 milliseconds. That way, we avoid queued up aria-live messages which
          // would be annoying and not helpful. The 500ms was agreed upon in the
          // accessibility review meeting.
          // We're going to do this in a cancellable setTimeout and only update
          // this when the timeout resolves.  If new aria live content is available
          // before the timeout resolves, cancel the timeout and start a new setTimeout.
          if (this._ariaLiveTimer) {
            clearTimeout(this._ariaLiveTimer);
          }
          this._ariaLiveTimer = setTimeout(() => {
            var politeDiv = hiddenAriaLiveEl.children[0];
            politeDiv.textContent = newAriaLiveContent;
            this._ariaLiveTimer = null;
          }, 500); // wait 500 milliseconds before updating aria live polite div
        }
      },

      /**
       * @memberof oj.ojInputBase
       * @instance
       * @protected
       * @ignore
       * @param {string} currentVal Current value of the text field
       * @param {string} proposedVal Proposed value of the text field
       * @param {boolean} setValue Whether to set component value or not
       * @param {boolean} processLengthCounter whether to process length counter or not
       */
      _filterTextAndSetValues(currentVal, proposedVal, setValue, processLengthCounter) {
        var filteredText = this.lengthFilter.filter(currentVal, proposedVal);
        this._SetRawValue(filteredText, null);
        this._SetDisplayValue(filteredText, null);
        var wrapperElem = this._GetContentWrapper().parentElement;
        var hiddenAriaLiveEl = wrapperElem.parentNode.querySelector(
          '.' + this._TEXT_FIELD_HIDDEN_ARIA_LIVE_CLASS
        );

        // If the proposed value is longer than the filtered text, then the length has exceeded
        // the max length and we need to update the aria live div with an error message.
        // Otherwise, remove clear the text from the assertiveDiv.
        if (hiddenAriaLiveEl) {
          var assertiveDiv = hiddenAriaLiveEl.children[1];

          // Both filteredText and proposedVal can be null
          var filteredTextLen = filteredText ? filteredText.length : 0;
          var proposedValLen = proposedVal ? proposedVal.length : 0;
          if (filteredTextLen < proposedValLen) {
            assertiveDiv.textContent = ''; // Clear it first, so we always hear this message.
            assertiveDiv.textContent = this.getTranslatedString(
              this._TEXT_FIELD_MAX_LENGTH_EXCEEDED_KEY,
              { len: this.options.length.max }
            );
          } else if (this.lastFilteredText !== proposedVal) {
            // We don't clear the error message if nothing has changed.
            assertiveDiv.textContent = '';
          }
        }

        this.lastFilteredText = filteredText;

        if (setValue) {
          this._SetValue(this.lastFilteredText);
        }
        if (processLengthCounter) {
          this._processLengthCounterAttr(this.options.length.counter);
        }
      },

      /**
       * <p>Refreshes the component.  Usually called after dom changes have been made.
       *
       * @example <caption>Refresh component after dome changes have been made.</caption>
       * // refresh component.
       * myComp.refresh();

       * @expose
       * @memberof oj.inputBase
       * @ojshortdesc Refreshes the component.
       * @public
       * @return {void}
       * @instance
       */
      refresh: function () {
        var retVal = this._superApply(arguments);

        this._rtl = this._GetReadingDirection() === 'rtl';

        this._refreshRequired(this.options.required);

        return retVal;
      },
      /**
       * @memberof! oj.inputBase
       * @instance
       * @private
       */
      _refreshRequired: ojeditablevalue.EditableValueUtils._refreshRequired,
      /**
       * @memberof! oj.inputBase
       * @instance
       * @private
       */
      _labelledByUpdatedForInputComp: ojeditablevalue.EditableValueUtils._labelledByUpdatedForInputComp,
      /**
       * @memberof! oj.inputBase
       * @instance
       * @private
       */
      _initInputIdLabelForConnection: ojeditablevalue.EditableValueUtils._initInputIdLabelForConnection,
      /**
       * @memberof! oj.inputBase
       * @instance
       * @private
       */
      _linkLabelForInputComp: ojeditablevalue.EditableValueUtils._linkLabelForInputComp,
      /**
       * the validate method from v3.x that returns a boolean
       * @memberof! oj.inputBase
       * @instance
       * @protected
       * @ignore
       */
      _ValidateReturnBoolean: ojeditablevalue.EditableValueUtils._ValidateReturnBoolean,

      /**
       * the validate method that returns a Promise
       * @memberof! oj.inputBase
       * @instance
       * @protected
       * @ignore
       */
      _ValidateReturnPromise: ojeditablevalue.EditableValueUtils._ValidateReturnPromise,

      getNodeBySubId: function (locator) {
        return this._super(locator);
      },

      /**
       * Validates the component's display value using the converter and all validators registered on
       * the component and updates the <code class="prettyprint">value</code> option by performing the
       * following steps.
       *
       * <p>
       * <ol>
       * <li>All messages are cleared, including custom messages added by the app. </li>
       * <li>If no converter is present then processing continues to next step. If a converter is
       * present, the UI value is first converted (i.e., parsed). If there is a parse error then
       * the messages are shown.</li>
       * <li>If there are no validators setup for the component the <code class="prettyprint">value</code>
       * option is updated using the display value. Otherwise all
       * validators are run in sequence using the parsed value from the previous step. The implicit
       * required validator is run first if the component is marked required. When a validation error is
       * encountered it is remembered and the next validator in the sequence is run. </li>
       * <li>At the end of validation if there are errors, the messages are shown.
       * If there were no errors, then the
       * <code class="prettyprint">value</code> option is updated.</li>
       * </ol>
       *
       * @example <caption>Validate component using its current value.</caption>
       * // validate display value and shows messages if there are any to be shown.
       * myComp.validate();
       * @example <caption>Validate component and use the Promise's resolved state.</caption>
       * myComp.validate().then(
       *  function(result) {
       *    if(result === "valid")
       *    {
       *      submitForm();
       *    }
       *  });
       * @return {Promise.<string>} Promise resolves to "valid" if there were no converter parse errors and
       * the component passed all validations.
       * The Promise resolves to "invalid" if there were converter parse errors or
       * if there were validation errors.
       * @ojsignature {target: "Type", value: "Promise<'valid'|'invalid'>", for : "returns"}
       *
       *
       * @method
       * @access public
       * @expose
       * @memberof oj.inputBase
       * @ojshortdesc Validates the component's display value using all converters and validators registered on the component. If there are no validation errors. then the value is updated. See the Help documentation for more information.
       * @instance
       * @since 4.0.0
       *
       */
      validate: ojeditablevalue.EditableValueUtils.validate,

      /**
       * Called to find out if aria-required is unsupported.
       * @memberof! oj.inputBase
       * @instance
       * @protected
       */
      _AriaRequiredUnsupported: function () {
        return false;
      },
      /**
       * Returns a <code class="prettyprint">jQuery</code> object containing the element visually
       * representing the component, excluding the label associated with the it.
       *
       * <p>This method does not accept any arguments.</p>
       *
       * @expose
       * @memberof! oj.inputBase
       * @instance
       * @return {jQuery} the root of the component
       * @ignore
       *
       * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
       * var widget = $( ".selector" ).ojFoo( "widget" ); // Foo is InputText, InputPassword, TextArea
       */
      widget: function () {
        return this._DoWrapElement() ? this._wrapper : this.element;
      }
    },
    true
  );

  /**
   * @ojcomponent oj.ojInputPassword
   * @augments oj.inputBase
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojInputPassword<V = string> extends inputBase<V, ojInputPasswordSettableProperties<V>>",
   *                genericParameters: [{"name": "V", "description": "Type of value of the component"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojInputPasswordSettableProperties<V = string> extends inputBaseSettableProperties<V>",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @since 0.6.0
   * @ojshortdesc An input password allows the user to enter a password.
   * @ojrole textbox
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "maskIcon", "required", "disabled", "readonly"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-text-input-password'
   * @ojuxspecs ['input-password']
   *
   * @ojdeprecated [
   *   {
   *     "type": "maintenance",
   *     "since": "16.0.0",
   *     "value": ["oj-c-input-password"]
   *   }
   * ]
   *
   * @classdesc
   * <h3 id="inputPasswordOverview-section">
   *   JET InputPassword Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputPasswordOverview-section"></a>
   * </h3>
   *
   * <p>Description: The oj-input-password component enhances a browser input type="password" element.
   *
   * <pre class="prettyprint"><code>&lt;oj-input-password>&lt;/oj-input-password></code></pre>
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>
   * {@ojinclude "name":"accessibilityLabelEditableValue"}
   * {@ojinclude "name":"accessibilityPlaceholderEditableValue"}
   * {@ojinclude "name":"accessibilityDisabledEditableValue"}
   * </p>
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>
   * To migrate from oj-input-password to oj-c-input-password, you need to revise the import statement
   * and references to oj-c-input-password in your app. Please note the changes between the two components below.
   * </p>
   *
   * <h5>Global attributes</h5>
   * <p>
   * The following global attributes are no longer supported:
   * <ul>
   * <li>accesskey - not considered accessible</li>
   * <li>tabindex - not considered accessible</li>
   * <li>
   * aria-label - use label-hint instead. If you do not want a visible label set label-edge="none".
   * </li>
   * </ul>
   * </p>
   *
   * <h5>Converter attribute</h5>
   * <p>
   * The converter attribute is changed to support only a converter instance, null, or undefined. It does not support
   * a Promise that resolves to a converter instance. The application should resolve the promise and then update the
   * converter attribute with the resolved converter instance.
   * </p>
   *
   * <h5>LabelEdge attribute</h5>
   * <p>
   * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
   * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
   * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
   * attribute to the corresponding value.
   * </p>
   *
   * <h5>MaskIcon attribute</h5>
   * <p>
   * The default value of the mask-icon attribute is changed from 'hidden' to 'visible'.
   * </p>
   *
   * <h5>MessagesCustom attribute</h5>
   * <p>
   * The type of the <code class="prettyprint">severity</code> property of the messages in the
   * array has changed from
   * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
   * essentially <code class="prettyprint">string | number</code>, to simply
   * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
   * values are the same as the previously supported string values.
   * The application can no longer specify severity as a number, including hardcoded numbers,
   * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
   * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
   * </p>
   *
   * <h5>TextAlign attribute</h5>
   * <p>
   * The usage of the style classes: oj-form-control-text-align-right, oj-form-control-text-align-start and oj-form-control-text-align-end is now
   * replaced with this attribute. The value of this attribute maps to these style classes as shown below:
   * <ul>
   * <li>
   * .oj-form-control-text-align-right maps to 'right'
   * </li>
   * <li>
   * .oj-form-control-text-align-start maps to 'start'
   * </li>
   * <li>
   * .oj-form-control-text-align-end maps to 'end'
   * </li>
   * </ul>
   * </p>
   * <h5>Translations attribute</h5>
   * <p>
   * <p>
   * The translations.required.message-detail attribute has changed to required-message-detail.
   * </p>
   *
   * <h5>Value attribute</h5>
   * <p>
   * Clearing the field and committing the value will now set the value attribute to <code>null</code>
   * instead of <code>''</code>.
   * </p>
   *
   * <h5>Refresh method</h5>
   * <p>
   * The refresh method is no longer supported. The application should no longer need to use this method. If the application
   * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
   * </p>
   *
   * <h5>Animation Events</h5>
   * <p>
   * ojAnimateStart and ojAnimateEnd events are no longer supported.
   * </p>
   *
   * <h5>Custom Label</h5>
   * <p>
   * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
   * label-hint attribute to add a label for the form component.
   * </p>
   * <p>
   * The application should no longer need to use an &lt;oj-label-value> component to layout the form component. The application
   * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
   * </p>
   *
   * <h5>DescribedBy attribute</h5>
   * <p>
   * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
   * This attribute is not carried forward to the core pack component.
   * </p>
   *
   * <h5>Formatted messages</h5>
   * <p>
   * Formatting messages using html tags is not supported in the core pack component.
   * </p>
   *
   * <h5>Usage in Dynamic Form</h5>
   * <p>
   * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
   * </p>
   *
   * @example <caption>Initialize the oj-input-password element with no attributess specified:</caption>
   * &lt;oj-input-password>&lt;/oj-input-password>
   *
   * @example <caption>Initialize the oj-input-password element with some attributes:</caption>
   * &lt;oj-input-password id="pwdId" disabled>&lt;/oj-input-password>
   *
   * @example <caption>Initialize a component attribute via component binding:</caption>
   * &lt;oj-input-password id="pwdId" value="{{currentValue}}">&lt;/oj-input-password>
   */
  // --------------------------------------------------- oj.ojInputPassword Styling Start ------------------------------------------------------------
  /**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form control style classes can be applied to the component, or an ancestor element. <br/>
   * When applied to an ancestor element, all form components that support the style classes will be affected.
   */
  // ---------------- oj-form-control-full-width --------------
  /**
   * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
   * @ojstyleclass oj-form-control-full-width
   * @ojdisplayname Full Width
   * @memberof oj.ojInputPassword
   * @ojtsexample
   * &lt;oj-input-password class="oj-form-control-full-width">
   * &lt;/oj-input-password>
   */

  // ---------------- oj-form-control max-width --------------
  /**
   * In the Redwood theme the default max width of a text field is 100%.
   * These max width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-max-width
   * @ojdisplayname Max Width
   * @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojInputPassword
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-input-password class="oj-form-control-max-width-md">&lt;/oj-input-password>
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
   * @ojshortdesc Sets the max width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojInputPassword
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-md
   * @ojshortdesc Sets the max width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojInputPassword
   */

  // ---------------- oj-form-control width --------------
  /**
   * In the Redwood theme the default width of a text field is 100%.
   * These width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-width
   * @ojdisplayname Width
   * @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojInputPassword
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-input-password class="oj-form-control-width-md">&lt;/oj-input-password>
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-sm
   * @ojshortdesc Sets the width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojInputPassword
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-md
   * @ojshortdesc Sets the width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojInputPassword
   */
  // --------------------------------------------------- oj.ojInputPassword Styling end ------------------------------------------------------------
  oj.__registerWidget('oj.ojInputPassword', $.oj.inputBase, {
    version: '1.0.0',
    defaultElement: '<input>',
    widgetEventPrefix: 'oj',

    /**
     * @expose
     * @private
     * @memberof! oj.ojInputPassword
     */
    _ATTR_CHECK: [{ attr: 'type', setMandatory: 'password' }],

    /**
     * @expose
     * @private
     * @memberof! oj.ojInputPassword
     */
    _CLASS_NAMES: 'oj-inputpassword-input',

    /**
     * @expose
     * @private
     * @memberof! oj.ojInputPassword
     */
    _WIDGET_CLASS_NAMES: 'oj-inputpassword oj-form-control oj-component',

    _INPUT_CONTAINER_CLASS: 'oj-text-field-container',

    _MASK_ICON_SHOW_PASSWORD_LABEL_KEY: 'accessibleShowPassword',
    _MASK_ICON_HIDE_PASSWORD_LABEL_KEY: 'accessibleHidePassword',

    options: {
      /**
       * @expose
       * @access public
       * @instance
       * @memberof! oj.ojInputPassword
       * @type {Object|null}
       * @ignore
       */
      converter: null,
      /**
       * The mask icon is used to mask or unmask the visibility of the password. The password
       * always starts out masked, but using the mask icon the user can toggle the visibility
       * of the password so that it can be read.  The <code class="prettyprint">mask-icon</code>
       * attribute is used to make the mask icon visible or hidden.  If it is hidden, then the
       * user has no way to toggle the visibility of the password.
       *
       * @expose
       * @memberof! oj.ojInputPassword
       * @instance
       * @type {string}
       * @ojvalue {string} "hidden" The mask visibility icon is never visible
       * @ojvalue {string} "visible" The mask visibility icon is always visible
       * @default "hidden"
       */
      maskIcon: 'hidden',
      /**
       * Regular expression pattern which will be used to validate the component's value.
       * <p>
       * When pattern is set to true, an implicit regExp validator is created using
       * the RegExpValidator -
       * <code class="prettyprint">new RegExpValidator()</code>.
       * </p>
       *
       * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> attribute:</caption>
       * &lt;oj-input-password pattern="[a-zA-Z0-9]{3,}">&lt;/oj-input-password><br/>
       *
       * @example <caption>Get or set the <code class="prettyprint">pattern</code> property after initialization:</caption>
       * // getter
       * var pattern = myComp.pattern;
       *
       * // setter
       * myComp.pattern = "[0-9]{3,}";
       *
       * @expose
       * @instance
       * @memberof! oj.ojInputPassword
       * @type {string|undefined}
       * @ignore
       */
      pattern: '',
      /**
       * The value of the component. Value must be a string or null.
       *
       * <p>
       * When <code class="prettyprint">value</code> property changes due to programmatic
       * intervention, the component always clears all messages
       * including <code class="prettyprint">messagesCustom</code>, runs deferred validation, and
       * always refreshes UI display value.</br>
       *
       * <h4>Running Validation</h4>
       * <ul>
       * <li>component always runs deferred validation; if there is a validation error the
       * <code class="prettyprint">valid</code> property is updated.</li>
       * </ul>
       * </p>
       *
       * @example <caption>Initialize the component with the <code class="prettyprint">value</code> attribute specified:</caption>
       * &lt;oj-input-password value='12345'>&lt;/oj-input-password>
       * @example <caption>Get or set <code class="prettyprint">value</code> attribute, after initialization:</caption>
       * // Getter: returns 10
       * var val = myComp.value;
       * // Setter: sets 20
       * myComp.value = 20;
       *
       * @expose
       * @access public
       * @instance
       * @default null
       * @ojwriteback
       * @ojeventgroup common
       * @memberof oj.ojInputPassword
       * @type {string|null}
       * @ojsignature { target: "Type",
       *                value: "V|null"}
       */
      value: undefined

      // Events

      /**
       * Triggered when the ojInputPassword is created.
       *
       * @event
       * @name create
       * @memberof oj.ojInputPassword
       * @instance
       * @property {Event} event event object
       * @property {Object} ui Currently empty
       * @ignore
       *
       * @example <caption>Initialize the ojInputPassword with the <code class="prettyprint">create</code> callback specified:</caption>
       * $( ".selector" ).ojInputPassword({
       *     "create": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
       * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
       */
      // create event declared in superclass, but we still want the above API doc
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojInputPassword
     */
    _ComponentCreate: function () {
      var retVal = this._super();

      // add in the mask visibility icon if needed
      this._processMaskVisibilityIcon();

      return retVal;
    },

    /**
     * Render or remove the mask visibility icon
     * @ignore
     * @private
     * @memberof oj.ojInputPassword
     * @instance
     */
    _processMaskVisibilityIcon: function () {
      var wrapperElem = this._GetContentWrapper().parentElement;
      var elem = this.element[0]; // Get the input element
      var maskVisibilityIconWrapper = wrapperElem.querySelector('span.oj-text-field-end');

      if (this.options.disabled || this.options.readOnly) {
        // remove the icon if it is there
        if (maskVisibilityIconWrapper) {
          wrapperElem.removeChild(maskVisibilityIconWrapper);
          elem.type = 'password';
        }
      } else if (maskVisibilityIconWrapper === null) {
        if (this.options.maskIcon === 'visible') {
          var maskVisibilityIcon;
          var maskVisibilityIconBtn;
          maskVisibilityIconWrapper = document.createElement('span');
          maskVisibilityIconWrapper.className = 'oj-text-field-end';
          maskVisibilityIconBtn = document.createElement('a');
          maskVisibilityIconBtn.className = 'oj-component-icon oj-clickable-icon-nocontext';

          maskVisibilityIconBtn.setAttribute(
            'aria-label',
            this.getTranslatedString(this._MASK_ICON_SHOW_PASSWORD_LABEL_KEY)
          );
          maskVisibilityIconBtn.role = 'button';

          maskVisibilityIconBtn.setAttribute('target', '_blank');
          maskVisibilityIconBtn.setAttribute('tabindex', '0');
          maskVisibilityIcon = document.createElement('span');
          maskVisibilityIcon.className = 'oj-inputpassword-show-password-icon';

          maskVisibilityIconBtn.appendChild(maskVisibilityIcon);
          maskVisibilityIconWrapper.appendChild(maskVisibilityIconBtn);
          wrapperElem.appendChild(maskVisibilityIconWrapper);

          var $maskVisIconBtn = $(maskVisibilityIconBtn);
          this._AddHoverable($maskVisIconBtn);
          this._AddActiveable($maskVisIconBtn);

          maskVisibilityIconBtn.addEventListener(
            this._CLICK_HANDLER_KEY,
            this._onMaskVisibilityIconClickHandler.bind(this)
          );
          maskVisibilityIconBtn.addEventListener(
            this._KEYDOWN_HANDLER_KEY,
            this._onMaskVisibilityIconKeyDownHandler.bind(this)
          );
        }
      } else if (this.options.maskIcon !== 'visible') {
        // The Icon is currently visible, so remove it.
        wrapperElem.removeChild(maskVisibilityIconWrapper);
        elem.type = 'password'; // Make sure we are the right type.
      }
    },

    /**
     * The handler clears the value of the input element and sets the focus on the element
     * NOTE: this handler expects the input text component to be bound to this via .bind()
     *
     * @ignore
     * @private
     * @memberof! oj.ojInputPassword
     */
    _onMaskVisibilityIconClickHandler: function () {
      var elem = this.element[0]; // Get the input element
      var wrapperElem = this._GetContentWrapper().parentElement;
      var maskVisibilityIconBtn = wrapperElem.querySelector('a.oj-component-icon');
      var maskVisibilityIcon = maskVisibilityIconBtn.children[0];

      // toggle the input type and the icon class
      if (elem.type === 'password') {
        // password is currently hidden
        elem.type = 'text';
        maskVisibilityIcon.classList.remove('oj-inputpassword-show-password-icon');
        maskVisibilityIcon.classList.add('oj-inputpassword-hide-password-icon');
        maskVisibilityIconBtn.setAttribute(
          'aria-label',
          this.getTranslatedString(this._MASK_ICON_HIDE_PASSWORD_LABEL_KEY)
        );
      } else {
        // password is currently visible
        elem.type = 'password';
        maskVisibilityIcon.classList.remove('oj-inputpassword-hide-password-icon');
        maskVisibilityIcon.classList.add('oj-inputpassword-show-password-icon');
        maskVisibilityIconBtn.setAttribute(
          'aria-label',
          this.getTranslatedString(this._MASK_ICON_SHOW_PASSWORD_LABEL_KEY)
        );
      }
    },

    /**
     * If the key code is ENTER or SPACE, we call _onMaskVisibilityIconClickHandler() to
     * toggle the mask visibility.
     *
     * @ignore
     * @private
     * @memberof! oj.ojInputPassword
     */
    _onMaskVisibilityIconKeyDownHandler: function (event) {
      if (event.altKey || event.ctrlKey) {
        return;
      }
      var keyCode = $.ui.keyCode;

      switch (event.keyCode) {
        case keyCode.SPACE:
        case keyCode.ENTER:
          this._onMaskVisibilityIconClickHandler();
          break;
        default:
      }
    },
    /**
     * Performs post processing after _SetOption() calls _superApply(). Different options, when changed, perform
     * different tasks.
     *
     * @param {string} option
     * @param {Object=} flags
     * @protected
     * @memberof oj.ojInputPassword
     * @instance
     */
    _AfterSetOption: function (option, flags) {
      this._super(option, flags);

      switch (option) {
        // all of these options potentially affect the visiblity and/or rendering of the icon
        // so we need to process the icon if any of these change.
        case 'disabled':
        case 'readOnly':
        case 'maskIcon':
          this._processMaskVisibilityIcon();
          break;
        default:
          break;
      }
    },

    /**
     * @ignore
     * @override
     * @protected
     * @memberof! oj.ojInputPassword
     * @return {boolean}
     */
    _DoWrapElementAndTriggers: function () {
      this._ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES = this._INPUT_CONTAINER_CLASS;
      return true;
    },

    /**
     * ojInputPassword extends from InputBase which creates a readonly div,
     * so overriding it to return false prevents ojInputPassword from creating
     * a readonly div. We do not want inputPassword to show its password in
     * plain text.
     * @ignore
     * @override
     * @protected
     * @memberof! oj.ojInputPassword
     * @return {boolean}
     */
    _UseReadonlyDiv: function () {
      return false;
    },

    getNodeBySubId: function (locator) {
      var node = this._superApply(arguments);
      var subId;
      if (!node) {
        subId = locator.subId;
        if (subId === 'oj-inputpassword-input') {
          node = this.element ? this.element[0] : null;
        }
      }
      // Non-null locators have to be handled by the component subclasses
      return node || null;
    },

    /**
     * @override
     * @instance
     * @memberof! oj.ojInputPassword
     * @protected
     * @return {string}
     */
    _GetDefaultStyleClass: function () {
      return 'oj-inputpassword';
    }
  });

  // Fragments:

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *    <tr>
   *       <td>Input</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Sets focus to input. Show user assistance text. This may be inline or in a notewindow
   * depending upon theme and property settings.</td>
   *     </tr>
   *   </tbody>
   *  </table>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojInputPassword
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Input element</td>
   *       <td><kbd>Tab In</kbd></td>
   *       <td>Set focus to the input.
   *       Show user assistance text. This may be inline or in a notewindow
   * depending upon theme and property settings.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojInputPassword
   */

  // ////////////////     SUB-IDS     //////////////////
  /**
   * <p>Sub-ID for the ojInputPassword component's input element.</p>
   *
   * @ojsubid oj-inputpassword-input
   * @ignore
   * @memberof oj.ojInputPassword
   * @deprecated 4.0.0 Since the application supplies this element, it can supply a unique ID by which the element can be accessed.
   *
   * @example <caption>Get the node for the input element:</caption>
   * var node = myComp.getNodeBySubId("oj-inputpassword-input");
   */

  /**
   * @ojcomponent oj.ojInputText
   * @augments oj.inputBase
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojInputText<V = any> extends inputBase<V, ojInputTextSettableProperties<V>>",
   *                genericParameters: [{"name": "V", "description": "Type of value of the component"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojInputTextSettableProperties<V = any> extends inputBaseSettableProperties<V>",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @since 0.6.0
   * @ojshortdesc An input text allows the user to enter a text value.
   * @ojrole textbox
   * @ojtsimport {module: "ojconverter-number", type: "AMD", imported: ["IntlNumberConverter", "NumberConverter"]}
   * @ojtsimport {module: "ojconverter-color", type: "AMD", importName: "ColorConverter"}
   * @ojtsimport {module: "ojconverter-datetime", type: "AMD",  imported: ["IntlDateTimeConverter", "DateTimeConverter"]}
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "required", "disabled", "readonly", "clearIcon", "virtualKeyboard"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-text-input'
   * @ojuxspecs ['input-text']
   *
   * @ojdeprecated [
   *   {
   *     "type": "maintenance",
   *     "since": "16.0.0",
   *     "value": ["oj-c-input-text"]
   *   }
   * ]
   *
   * @classdesc
   * <h3 id="inputTextOverview-section">
   *   JET InputText Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputTextOverview-section"></a>
   * </h3>
   *
   * <p>Description: The oj-input-text component enhances a browser input type="text" element.
   *
   * <pre class="prettyprint"><code>&lt;oj-input-text>&lt;/oj-input-text></code></pre>
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>
   * {@ojinclude "name":"accessibilityLabelEditableValue"}
   * {@ojinclude "name":"accessibilityPlaceholderEditableValue"}
   * {@ojinclude "name":"accessibilityDisabledEditableValue"}
   * </p>
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>
   * To migrate from oj-input-text to oj-c-input-text, you need to revise the import statement
   * and references to oj-c-input-text in your app. Please note the changes between the two components below.
   * </p>
   *
   * <h5>Global attributes</h5>
   * <p>
   * The following global attributes are no longer supported:
   * <ul>
   * <li>accesskey - not considered accessible</li>
   * <li>tabindex - not considered accessible</li>
   * <li>
   * aria-label - use label-hint instead. If you do not want a visible label set label-edge="none".
   * </li>
   * </ul>
   * </p>
   *
   * <h5>Converter attribute</h5>
   * <p>
   * The converter attribute is changed to support only a converter instance, null, or undefined. It does not support
   * a Promise that resolves to a converter instance. The application should resolve the promise and then update the
   * converter attribute with the resolved converter instance.
   * </p>
   * <p>
   * The converter is no longer applied when the value is <code>null</code>, <code>undefined</code>, or <code>''</code>.
   * When the field is empty, the value gets normalized to <code>null</code>, so the converter does not run on an empty field.
   * <p>
   *
   * <h5>Validators</h5>
   * <p>
   * Only the required validator is run for an empty field, and only if required is true. The component's other validators
   * are no longer run when the field is empty.
   * If you created your own validator to check that the field was filled in, it will not run if the
   * field is empty. Set the required attribute to true instead which conforms to the Redwood UX design.
   * </p>
   *
   * <h5>LabelEdge attribute</h5>
   * <p>
   * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
   * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
   * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
   * attribute to the corresponding value.
   * </p>
   *
   * <h5>List attribute</h5>
   * <p>
   * The list attribute is no longer supported.
   * </p>
   *
   * <h5>MessagesCustom attribute</h5>
   * <p>
   * The type of the <code class="prettyprint">severity</code> property of the messages in the
   * array has changed from
   * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
   * essentially <code class="prettyprint">string | number</code>, to simply
   * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
   * values are the same as the previously supported string values.
   * The application can no longer specify severity as a number, including hardcoded numbers,
   * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
   * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
   * </p>
   *
   * <h5>TextAlign attribute</h5>
   * <p>
   * The usage of the style classes: oj-form-control-text-align-right, oj-form-control-text-align-start and oj-form-control-text-align-end is now
   * replaced with this attribute. The value of this attribute maps to these style classes as shown below:
   * <ul>
   * <li>
   * .oj-form-control-text-align-right maps to 'right'
   * </li>
   * <li>
   * .oj-form-control-text-align-start maps to 'start'
   * </li>
   * <li>
   * .oj-form-control-text-align-end maps to 'end'
   * </li>
   * </ul>
   * </p>
   * <h5>Translations attribute</h5>
   * <p>
   * The translations.required.message-detail attribute has changed to required-message-detail.
   * </p>
   *
   * <h5>Value attribute</h5>
   * <p>
   * Clearing the field and committing the value will now set the value attribute to <code>null</code>
   * instead of <code>''</code>.
   * </p>
   *
   * <h5>Refresh method</h5>
   * <p>
   * The refresh method is no longer supported. The application should no longer need to use this method. If the application
   * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
   * </p>
   *
   * <h5>Animation Events</h5>
   * <p>
   * ojAnimateStart and ojAnimateEnd events are no longer supported.
   * </p>
   *
   * <h5>Custom Label</h5>
   * <p>
   * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
   * label-hint attribute to add a label for the form component.
   * </p>
   * <p>
   * The application should no longer need to use an &lt;oj-label-value> component to layout the form component. The application
   * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
   * </p>
   *
   * <h5>DescribedBy attribute</h5>
   * <p>
   * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
   * This attribute is not carried forward to the core pack component.
   * </p>
   *
   * <h5>Formatted messages</h5>
   * <p>
   * Formatting messages using html tags is not supported in the core pack component.
   * </p>
   *
   * <h5>Usage in Dynamic Form</h5>
   * <p>
   * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
   * </p>
   *
   * @example <caption>Declare the oj-input-text component with no attributes specified:</caption>
   * &lt;oj-input-text>&lt;/oj-input-text>
   *
   * @example <caption>Initialize the component with some attributes:</caption>
   * &lt;oj-input-text id="textId" disabled>&lt;/oj-input-text>
   *
   * @example <caption>Initialize a component attribute via component binding:</caption>
   * &lt;oj-input-text id="textId" value="{{currentValue}}">&lt;/oj-input-text>
   */
  // --------------------------------------------------- oj.ojInputText Styling Start ------------------------------------------------------------
  /**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form control style classes can be applied to the component, or an ancestor element. <br/>
   * When applied to an ancestor element, all form components that support the style classes will be affected.
   */
  // ---------------- oj-form-control-full-width --------------
  /**
   * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
   * @ojstyleclass oj-form-control-full-width
   * @ojdisplayname Full Width
   * @memberof oj.ojInputText
   * @ojtsexample
   * &lt;oj-input-text class="oj-form-control-full-width">
   * &lt;/oj-input-text>
   */

  // ---------------- oj-form-control max-width --------------
  /**
   * In the Redwood theme the default max width of a text field is 100%.
   * These max width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-max-width
   * @ojdisplayname Max Width
   * @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojInputText
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-input-text class="oj-form-control-max-width-md">&lt;/oj-input-text>
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
   * @ojshortdesc Sets the max width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojInputText
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-md
   * @ojshortdesc Sets the max width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojInputText
   */

  // ---------------- oj-form-control width --------------
  /**
   * In the Redwood theme the default width of a text field is 100%.
   * These width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-width
   * @ojdisplayname Width
   * @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojInputText
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-input-text class="oj-form-control-width-md">&lt;/oj-input-text>
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-sm
   * @ojshortdesc Sets the width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojInputText
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-md
   * @ojshortdesc Sets the width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojInputText
   */

  // ---------------- oj-form-control-text-align- --------------
  /**
   * Classes that help align text of the element.
   * @ojstyleset text-align
   * @ojdisplayname Text Alignment
   * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
   * @ojstylerelation exclusive
   * @memberof oj.ojInputText
   * @ojtsexample
   * &lt;oj-input-text class="oj-form-control-text-align-right">
   * &lt;/oj-input-text>
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-right
   * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
   * @ojdisplayname Align-Right
   * @memberof! oj.ojInputText
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-start
   * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
   * @ojdisplayname Align-Start
   * @memberof! oj.ojInputText
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-end
   * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
   * @ojdisplayname Align-End
   * @memberof! oj.ojInputText
   */
  // ---------------- oj-text-field-start-end-icon --------------
  /**
   * Use this class on a child div element if you want an icon to display in the start or end slot of an oj-input-text element.
   * @ojstyleclass oj-text-field-start-end-icon
   * @ojdisplayname Start-End Icon
   * @ojstyleselector "oj-input-text > div"
   * @memberof oj.ojInputText
   * @ojtsexample
   * &lt;oj-input-text id="myInputText" label-hint="My label">
   *   &lt;div slot="start" :class="oj-text-field-start-end-icon oj-ux-ico-cc-card" role="img">&lt;div>
   * &lt;/oj-input-text>
   */
  // --------------------------------------------------- oj.ojInputText Styling end ------------------------------------------------------------
  oj.__registerWidget('oj.ojInputText', $.oj.inputBase, {
    version: '1.0.0',
    defaultElement: '<input>',
    widgetEventPrefix: 'oj',

    /**
     * @expose
     * @private
     */
    _ATTR_CHECK: [{ attr: 'type', setMandatory: 'text' }],

    /**
     * @expose
     * @private
     */
    _CLASS_NAMES: 'oj-inputtext-input',

    /**
     * @expose
     * @private
     */
    _WIDGET_CLASS_NAMES: 'oj-inputtext oj-form-control oj-component',

    /**
     * @private
     */
    _ALLOWED_TYPES: ['email', 'number', 'search', 'tel', 'text', 'url'],

    _CLICK_HANDLER_KEY: 'click',

    _INPUT_CONTAINER_CLASS: 'oj-text-field-container',
    _INPUTTEXT_COUNTER_EL: 'oj-inputtext-counter-el',
    _INPUTTEXT_CLEAR_ICON_KEY: 'accessibleClearIcon',

    options: {
      /**
       * @expose
       * @memberof! oj.ojInputText
       * @instance
       * @type {string}
       * @ojvalue {string} "never" The clear icon is never visible
       * @ojvalue {string} "always" The clear icon is always visible
       * @ojvalue {string} "conditional" The clear icon is visible under the following conditions:
       * if the component has a non-empty value, and it either has focus or the mouse is over the field.
       * @default "never"
       * @desc Specifies if an icon to clear the input field should be visible.
       *
       * @example <caption>Initialize the oj-input-text with the <code class="prettyprint">clear-icon</code> attribute specified:</caption>
       * &lt;oj-input-text clear-icon="conditional" id="inputcontrol">&lt;/oj-input-text>
       *
       * @example <caption>Get or set the <code class="prettyprint">clearIcon</code> property after initialization:</caption>
       * // getter
       * var clearIcon = myInputText.clearIcon;
       *
       * // setter
       * myInputText.clearIcon = 'conditional';
       */
      clearIcon: 'never',
      /**
       * A converter instance or one that duck types {@link oj.Converter}.
       * {@ojinclude "name":"inputBaseConverterOptionDoc"}
       * <p>
       *  During validation, the converter takes the input value which is a string
       *  and parses it into the type of the component's value property
       *  (e.g. a number)
       *  before it passes it to the validator. It then takes the validated value property
       *  and formats it into a string to be displayed and puts it into the input.
       *  If the converter's format or parse functions
       *  throw an error, it will be displayed to the user inline on the field.
       * </p>
       * <p>
       * The hint exposed by the converter is shown inline by default in the Redwood theme when
       * the field has focus.
       * In the Alta theme, converter hints are shown in a notewindow on focus,
       * or as determined by the
       * 'converterHint' property set on the <code class="prettyprint">display-options</code>
       * attribute.
       * In either theme, you can turn off showing converter hints by using the
       * 'converterHint' property set to 'none' on the <code class="prettyprint">display-options</code>
       * attribute.
       * </p>
       * <p>
       * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
       * help.instruction shows; if no help.instruction then validator hints show;
       * if none, then help-hints.definition shows; if none, then converter hint shows.
       * help-hints.source always shows along with the other help or hint.
       * </p>
       * @example <caption>Initialize the component with a number converter instance:</caption>
       * &lt;oj-input-text converter="[[salaryConverter]]">&lt;/oj-input-text><br/>
       * // Initialize converter instance using currency options
       * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
       * this.salaryConverter = new NumberConverter(options);
       *
       * @example <caption>Get or set the <code class="prettyprint">converter</code>
       *  property after initialization:</caption>
       * // getter
       * var converter = myComp.converter;
       *
       * // setter
       * myComp.converter = myConverter;
       * @expose
       * @access public
       * @instance
       * @memberof! oj.ojInputText
       * @ojshortdesc An object that converts the value. See the Help documentation for more information.
       * @default null
       * @ojsignature [{
       *    target: "Type",
       *    value: "oj.Converter<V>|
       *            null",
       *    jsdocOverride: true},
       *    {target: "Type",
       *    value: "Promise<oj.Converter<V>>|oj.Converter<V>|
       *            oj.Validation.RegisteredConverter|
       *            null",
       *    consumedBy: 'tsdep'}]
       * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredConverter'],
       *                description:'Defining a converter with an object literal with converter type and its options
       *                  (aka JSON format) has been deprecated and does nothing. If needed, you can make the JSON format
       *                  work again by importing the deprecated module you need, like ojvalidation-base or
       *                  ojvalidation-number module.'}
       * @ojdeprecated {since: '17.0.0', target: 'memberType', value: ['Promise<oj.Converter<V>>'],
       *                description: 'Defining a Promise to a Converter instance has been deprecated. The application should resolve the promise and then update the converter attribute with the resolved converter instance.'}
       * @type {Object|null}
       */
      converter: null,
      /**
       * Indicates a list of pre-defined options to suggest to the user.
       * The value must be the id of a &lt;datalist> element in the same page.
       * This attribute is ignored when the type attribute's value is hidden.
       *
       * @example <caption>Initialize component with <code class="prettyprint">list</code> attribute:</caption>
       * &lt;oj-some-element list="sampleDataList">&lt;/oj-some-element>
       *
       * <p>Example for datalist:
       * <pre class="prettyprint">
       * <code>
       * &lt;datalist id="sampleDataList">
       *   &lt;option value="item 1">item 1&lt;/option>
       *   &lt;option value="item 2">item 2&lt;/option>
       *   &lt;option value="item 3">item 3&lt;/option>
       *   &lt;option value="item 4">item 4&lt;/option>
       * &lt;/datalist>
       * </code></pre>
       *
       * @example <caption>Get or set the <code class="prettyprint">list</code> property after initialization:</caption>
       * // getter
       * var ro = myComp.list;
       *
       * // setter
       * myComp.list = "myDataList";
       *
       * @expose
       * @instance
       * @memberof! oj.ojInputText
       * @ojshortdesc Specifies a list of pre-defined options to present to the user. See the Help documentation for more information.
       * @type {string}
       * @public
       * @ojextension {_COPY_TO_INNER_ELEM: true}
       */
      list: '',

      /**
       * Regular expression pattern which will be used to validate the component's value.
       * <p>
       * When pattern is set to a non-empty string value, an implicit regExp validator is created using
       * the RegExpValidator -
       * <code class="prettyprint">new RegExpValidator()</code>.
       * </p>
       *
       * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> attribute:</caption>
       * &lt;oj-input-text pattern="[a-zA-Z0-9]{3,}">&lt;/oj-input-text><br/>
       *
       * @example <caption>Get or set the <code class="prettyprint">pattern</code> property after initialization:</caption>
       * // getter
       * var pattern = myComp.pattern;
       *
       * // setter
       * myComp.pattern = "[0-9]{3,}";
       *
       * @expose
       * @instance
       * @memberof! oj.ojInputText
       * @type {string|undefined}
       * @ignore
       */
      pattern: '',
      /**
       * The type of virtual keyboard to display for entering a value on mobile browsers. This attribute has no effect on desktop browsers.
       * @example <caption>Initialize the component with the <code class="prettyprint">virtual-keyboard</code> attribute:</caption>
       * &lt;oj-input-text virtual-keyboard="number">&lt;/oj-input-text>
       *
       * @example <caption>Get or set the <code class="prettyprint">virtualKeyboard</code> property after initialization:</caption>
       * // Getter
       * var virtualKeyboard = myComp.virtualKeyboard;
       *
       * // Setter
       * myComp.virtualKeyboard = "number";
       *
       * @expose
       * @instance
       * @memberof oj.ojInputText
       * @ojshortdesc The type of virtual keyboard to display for entering a value on mobile browsers. See the Help documentation for more information.
       * @type {string}
       * @ojvalue {string} "auto" The component will determine the best mobile virtual keyboard to use.
       *                          For example, it may look at the converter's resolvedOptions
       *                          to determine the mobile virtual keyboard type.
       * @ojvalue {string} "email" Use a mobile virtual keyboard for entering email addresses.
       * @ojvalue {string} "number" Use a mobile virtual keyboard for entering numbers.
       *                            <p>If using "number", you must set the converter attribute to a converter
       *                            that formats to numeric characters only, otherwise the value will not be shown. The reason for this
       *                            is oj-input-text uses the browser native input type='number' and when you set a value that contains a non-numeric character,
       *                            browsers do not display the value. For example, "1,000" would not be shown.</p>
       *                            <p>Note that on Android and Windows Mobile, the "number" keyboard does
       *                            not contain the minus sign.  This value should not be used on fields that
       *                            accept negative values.</p>
       * @ojvalue {string} "search" Use a mobile virtual keyboard for entering search terms.
       * @ojvalue {string} "tel" Use a mobile virtual keyboard for entering telephone numbers.
       * @ojvalue {string} "text" Use a mobile virtual keyboard for entering text.
       * @ojvalue {string} "url" Use a mobile virtual keyboard for URL entry.
       * @default "auto"
       * @since 5.0.0
       */
      virtualKeyboard: 'auto',

      /**
          *
          * @expose
          * @instance
          * @memberof oj.ojInputText
          * @name length
          * @type {Object}
          * @since 8.0.0
          * @ojshortdesc An object whose properties describe the maximum length attributes.
          // * @ojtsignore tsdefonly
        */

      length: {
        /**
         * Maximum number of characters that can be entered in the input field.
         *
         * @expose
         * @name length.max
         * @ojshortdesc Specifies the maximum number of characters to be entered in the input text.
         * @memberof! oj.ojInputText
         * @instance
         * @type {number|null}
         * @default null
         * @since 8.0.0
         */
        max: null,

        /**
         * Dictates how the input text characters has to be counted.
         *
         * @expose
         * @name length.countBy
         * @ojshortdesc Specifies the manner in which the input text characters has to be counted.
         * @memberof! oj.ojInputText
         * @instance
         * @type {string=}
         * @ojvalue {string} 'codePoint' Uses code point to calculate the text length
         * @ojvalue {string} 'codeUnit' Uses code unit to calculate the text length
         * @default "codePoint"
         * @since 8.0.0
         */
        countBy: 'codePoint'
      }

      // Events

      /**
       * Triggered when the ojInputText is created.
       *
       * @event
       * @name create
       * @memberof oj.ojInputText
       * @instance
       * @property {Event} event event object
       * @property {Object} ui Currently empty
       * @ignore
       *
       * @example <caption>Initialize the ojInputText with the <code class="prettyprint">create</code> callback specified:</caption>
       * $( ".selector" ).ojInputText({
       *     "create": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
       * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
       */
      // create event declared in superclass, but we still want the above API doc
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojInputText
     */
    _ComponentCreate: function () {
      var retVal = this._super();

      // add in the clear icon if needed
      var clearIconAttr = this.options.clearIcon;

      this._processClearIconAttr(clearIconAttr);
      this._processSlottedChildren();

      this._AddHoverable(this._wrapper);

      // Set the input type attribute based on virtualKeyboard property
      this._SetInputType(this._ALLOWED_TYPES);

      return retVal;
    },
    /**
     * @ignore
     * @override
     * @protected
     * @memberof! oj.InputText
     * @return {boolean}
     */
    _DoWrapElementAndTriggers: function () {
      this._ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES = this._INPUT_CONTAINER_CLASS;
      return true;
    },
    /**
     * Render or remove the clear icon
     * @ignore
     * @private
     * @param {string} clearIconAttr
     * @memberof oj.ojInputText
     * @instance
     */
    _processClearIconAttr: function (clearIconAttr) {
      var wrapperElem = this._GetContentWrapper().parentElement;

      var clearIconBtn = wrapperElem.querySelector('a.oj-inputtext-clear-icon-btn');

      if (clearIconAttr === 'never' || this.options.disabled || this.options.readOnly) {
        // remove the icon if it is there
        if (clearIconBtn) {
          wrapperElem.removeChild(clearIconBtn);
        }

        // if the clearIcon is not rendered, we shouldn't have these classes
        wrapperElem.classList.remove('oj-inputtext-clearicon-visible');
        wrapperElem.classList.remove('oj-inputtext-clearicon-conditional');
      } else {
        if (clearIconBtn === null) {
          var clearIcon;
          var agentInfo = oj.AgentUtils.getAgentInfo();
          clearIconBtn = document.createElement('a');
          clearIconBtn.className =
            'oj-inputtext-clear-icon-btn oj-component-icon oj-clickable-icon-nocontext';
          clearIconBtn.setAttribute('tabindex', '-1');
          clearIconBtn.setAttribute(
            'title',
            this.getTranslatedString(this._INPUTTEXT_CLEAR_ICON_KEY)
          );
          // Only add aria-label for screen readers on mobile browsers
          if (
            agentInfo.os === oj.AgentUtils.OS.ANDROID ||
            agentInfo.os === oj.AgentUtils.OS.IOS ||
            agentInfo.os === oj.AgentUtils.OS.WINDOWSPHONE
          ) {
            clearIconBtn.setAttribute('aria-label', 'Clear input');
            clearIconBtn.setAttribute('role', 'button');
          } else {
            // clear icon is hidden from screen reader users for desktop.
            clearIconBtn.setAttribute('aria-hidden', 'true');
          }

          clearIconBtn.setAttribute('target', '_blank');
          clearIcon = document.createElement('span');
          clearIcon.className = 'oj-inputtext-clear-icon';

          clearIconBtn.appendChild(clearIcon);
          wrapperElem.appendChild(clearIconBtn);

          clearIconBtn.addEventListener(
            this._CLICK_HANDLER_KEY,
            this._onClearIconClickHandler.bind(this)
          );
        }

        // If clear-icon = "always", we want the icon visible all the time
        if (clearIconAttr === 'always') {
          wrapperElem.classList.add('oj-inputtext-clearicon-visible');
        } else {
          wrapperElem.classList.remove('oj-inputtext-clearicon-visible');

          // For the conditional case, we render oj-form-control-empty-clearicon if the input doesn't
          // have a value, as we always want the clear icon hidden for this case.  When the input does
          // have a value, then we use oj-inputtext-clearicon-conditional, which has selectors for
          // oj-hover and oj-focus to determine when the icon is visible.
          wrapperElem.classList.add('oj-inputtext-clearicon-conditional');

          var val;

          // if the component is not fully rendered, then we need to use the value option's value
          // instead of the input element's value
          if (wrapperElem.classList.contains('oj-complete')) {
            val = this.element[0].value;
          } else {
            val = this.options.value;
          }

          if (val && val !== '') {
            wrapperElem.classList.remove('oj-form-control-empty-clearicon');
          } else {
            wrapperElem.classList.add('oj-form-control-empty-clearicon');
          }
        }
      }
    },
    /**
     * Handles slotted start and end icons.
     * @ignore
     * @private
     * @memberof oj.ojInputText
     * @instance
     */
    _processSlottedChildren: function () {
      function scrubSlots(slotMap) {
        var VALID_SLOTS = { contextMenu: true, start: true, end: true, '': true };
        var keys = Object.keys(slotMap);
        for (var i = keys.length - 1; i > -1; i--) {
          var key = keys[i];
          if (!VALID_SLOTS[key]) {
            var nodes = slotMap[key];
            for (var n = 0; n < nodes.length; n++) {
              var node = nodes[n];
              node.parentElement.removeChild(node);
            }
          }
        }
      }
      function processStartSlots(contentContainer, nodes) {
        var wrapperElem = document.createElement('span');
        var textFieldContainer = contentContainer.parentElement;
        wrapperElem.classList.add('oj-text-field-start');
        textFieldContainer.insertBefore(wrapperElem, contentContainer);
        textFieldContainer.classList.add('oj-text-field-has-start-slot');
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          wrapperElem.appendChild(node);
        }
      }
      function processEndSlots(contentContainer, nodes) {
        var wrapperElem = document.createElement('span');
        var textFieldContainer = contentContainer.parentElement;
        wrapperElem.classList.add('oj-text-field-end');
        textFieldContainer.appendChild(wrapperElem);
        textFieldContainer.classList.add('oj-text-field-has-end-slot');
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          wrapperElem.appendChild(node);
        }
      }

      var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(this._getRootElement());
      scrubSlots(slotMap);

      var contextContainer = this._GetContentWrapper();
      var slotName = 'start';
      if (slotMap[slotName]) {
        processStartSlots(contextContainer, slotMap[slotName]);
      }
      slotName = 'end';
      if (slotMap[slotName]) {
        processEndSlots(contextContainer, slotMap[slotName]);
      }
    },

    /**
     * Performs post processing after _SetOption() calls _superApply(). Different options, when changed, perform
     * different tasks.
     *
     * @param {string} option
     * @param {Object=} flags
     * @protected
     * @memberof oj.ojInputText
     * @instance
     */
    _AfterSetOption: function (option, flags) {
      this._super(option, flags);

      switch (option) {
        // all of these options potentially affect the visiblity and/or rendering of the icon
        // so we need to process the icon if any of these change.
        case 'clearIcon':
        case 'disabled':
        case 'readOnly':
          this._processClearIconAttr(this.options.clearIcon);
          break;

        case 'virtualKeyboard':
          this._SetInputType(this._ALLOWED_TYPES);
          break;

        case 'value':
          this._processClearIconAttr(this.options.clearIcon);
          this._filterTextOnValueChange();
          this._AfterSetOptionLength(this.options.length);
          break;

        default:
          break;
      }
    },
    /**
     * Invoked when the input event happens
     *
     * @ignore
     * @protected
     * @memberof! oj.ojInputText
     * @param {Event} event
     */
    _onInputHandler: function (event) {
      this._super(event);
      var inputNode = event.target;
      var wrapperNode = this._GetContentWrapper().parentElement;
      var clearIconAttr = this.options.clearIcon;

      if (clearIconAttr === 'conditional') {
        if (inputNode.value !== '') {
          wrapperNode.classList.remove('oj-form-control-empty-clearicon');
        } else {
          wrapperNode.classList.add('oj-form-control-empty-clearicon');
        }
      }
    },
    /**
     * The handler clears the value of the input element and sets the focus on the element
     * NOTE: this handler expects the input text component to be bound to this via .bind()
     *
     * @ignore
     * @private
     * @memberof! oj.ojInputText
     * @param {Event} event
     */
    _onClearIconClickHandler: function (event) {
      var elem = this.element[0];

      elem.value = '';
      // we need to update the raw value to keep it in sync
      this._SetRawValue(elem.value, event);
      elem.focus();
      var wrapper = this._GetContentWrapper().parentElement;
      wrapper.classList.add('oj-form-control-empty-clearicon');
      this._processLengthCounterAttr(this.options.length.counter);
    },
    /**
     * Invoked when blur is triggered of the this.element
     * We don't want to set the value if the event.relatedTarget is the clear icon button
     *
     * @ignore
     * @protected
     * @memberof! oj.inputText
     * @param {Event} event
     */
    _onBlurHandler: function (event) {
      var wrapperNode = this._wrapper[0];
      var target = event.relatedTarget;

      // if this is the clear icon, skip the blur handler if it is an ancestor of the input text
      if (
        !(
          target &&
          target.classList.contains('oj-inputtext-clear-icon-btn') &&
          target.parentElement &&
          DomUtils.isAncestorOrSelf(wrapperNode, target.parentElement)
        )
      ) {
        this._super(event);
      } else {
        // We need to put the oj-focus back on the wrapperNode so that the icon
        // doesn't disappear on iOS and make it so that the click handler will fire.
        wrapperNode.classList.add('oj-focus');
      }
    },
    getNodeBySubId: function (locator) {
      var node = this._superApply(arguments);
      var subId;
      if (!node) {
        subId = locator.subId;
        if (subId === 'oj-inputtext-input') {
          node = this.element ? this.element[0] : null;
        }
      }
      // Non-null locators have to be handled by the component subclasses
      return node || null;
    },

    /**
     * @override
     * @instance
     * @memberof! oj.ojInputText
     * @protected
     * @return {string}
     */
    _GetDefaultStyleClass: function () {
      return 'oj-inputtext';
    },

    /**
     * Set the type of the input element based on virtualKeyboard option.
     * @memberof oj.ojInputText
     * @instance
     * @protected
     * @ignore
     */
    _SetInputType: ojeditablevalue.EditableValueUtils._SetInputType
  });

  // Fragments:

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *    <tr>
   *       <td>Input</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Sets focus to input. Show user assistance text. This may be inline or in a notewindow
   * depending upon theme and property settings.</td>
   *     </tr>
   *   </tbody>
   *  </table>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojInputText
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Input</td>
   *       <td><kbd>Tab In</kbd></td>
   *       <td>Set focus to the input.
   *       Show user assistance text. This may be inline or in a notewindow
   * depending upon theme and property settings.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojInputText
   */

  // ////////////////     SUB-IDS     //////////////////
  /**
   * <p>Sub-ID for the ojInputText component's input element.</p>
   *
   * @ojsubid oj-inputtext-input
   * @memberof oj.ojInputText
   *
   * @example <caption>Get the node for the input element:</caption>
   * var node = myComp.getNodeBySubId("oj-input-text-input");
   */

  /**
   * <p>The <code class="prettyprint">start</code> slot is for adding html content before the input area, typically an icon.</p>
   * <p>For example, an icon identifying the credit card type based on the value entered.</p>
   *
   * @ojslot start
   * @ojshortdesc The start slot enables adding leading html content such as an icon
   * @since 9.1.0
   * @memberof oj.ojInputText
   *
   * @ojtsexample <caption>Initialize the input text with child content specified for the start slot:</caption>
   * &lt;oj-input-text on-raw-value-changed="[[changeCreditCardTypeIcon]]">
   *   &lt;img slot="start" :src="[[creditCardTypeIcon]]">
   * &lt;/oj-input-text>
   */

  /**
   * <p>The <code class="prettyprint">end</code> slot is for adding html content after the input area, typically an oj-button or and icon.
   * For example, a magnifying glass icon button for a search field can be provided in this slot.
   * </p>
   *
   * @ojslot end
   * @ojshortdesc The end slot enables adding trailing html content such as an icon button.
   * @since 9.1.0
   * @memberof oj.ojInputText
   *
   * @ojtsexample <caption>Initialize the input text with child content specified for the end slot:</caption>
   * &lt;oj-input-text>
   *   &lt;oj-button slot="end" on-oj-action="[[performSearch]]" display="icons" >
   *     &lt;img slot="endIcon" src="search.png">Search
   *    &lt;/oj-button>
   * &lt;/oj-input-text>
   */

  /**
   * @ojcomponent oj.ojTextArea
   * @augments oj.inputBase
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojTextArea<V = any> extends inputBase<V, ojTextAreaSettableProperties<V>>",
   *                genericParameters: [{"name": "V", "description": "Type of value of the component"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojTextAreaSettableProperties<V = any> extends inputBaseSettableProperties<V>",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @since 0.6.0
   * @ojshortdesc A text area allows the user to enter a multi-line text value.
   * @ojrole textbox
   * @ojtsimport {module: "ojconverter-number", type: "AMD", imported: ["IntlNumberConverter", "NumberConverter"]}
   * @ojtsimport {module: "ojconverter-color", type: "AMD", importName: "ColorConverter"}
   * @ojtsimport {module: "ojconverter-datetime", type: "AMD",  imported: ["IntlDateTimeConverter", "DateTimeConverter"]}
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "rows", "maxRows","disabled", "required", "readonly"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-text-input-area'
   * @ojuxspecs ['input-text']
   *
   * @ojdeprecated [
   *   {
   *     "type": "maintenance",
   *     "since": "16.0.0",
   *     "value": ["oj-c-text-area"]
   *   }
   * ]
   *
   * @classdesc
   * <h3 id="textAreaOverview-section">
   *   JET TextArea Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#textAreaOverview-section"></a>
   * </h3>
   *
   * <p>Description: The oj-text-area component enhances a browser textarea element.
   *
   * <pre class="prettyprint"><code>&lt;oj-text-area>&lt;/oj-text-area></code></pre>
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>
   * {@ojinclude "name":"accessibilityLabelEditableValue"}
   * {@ojinclude "name":"accessibilityPlaceholderEditableValue"}
   * {@ojinclude "name":"accessibilityDisabledEditableValue"}
   * </p>
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>
   * To migrate from oj-text-area to oj-c-text-area, you need to revise the import statement
   * and references to oj-c-text-area in your app. Please note the changes between the two components below.
   * </p>
   *
   * <h5>Global attributes</h5>
   * <p>
   * The following global attributes are no longer supported:
   * <ul>
   * <li>accesskey - not considered accessible</li>
   * <li>tabindex - not considered accessible</li>
   * <li>
   * aria-label - use label-hint instead. If you do not want a visible label set label-edge="none".
   * </li>
   * </ul>
   * </p>
   *
   * <h5>Converter attribute</h5>
   * <p>
   * The converter attribute is changed to support only a converter instance, null, or undefined. It does not support
   * a Promise that resolves to a converter instance. The application should resolve the promise and then update the
   * converter attribute with the resolved converter instance.
   * </p>
   * <p>
   * The converter is no longer applied when the value is <code>null</code>, <code>undefined</code>, or <code>''</code>.
   * When the field is empty, the value gets normalized to <code>null</code>, so the converter does not run on an empty field.
   * <p>
   *
   * <h5>Validators</h5>
   * <p>
   * Only the required validator is run for an empty field, and only if required is true. The component's other validators
   * are no longer run when the field is empty.
   * If you created your own validator to check that the field was filled in, it will not run if the
   * field is empty. Set the required attribute to true instead which conforms to the Redwood UX design.
   * </p>
   *
   * <h5>LabelEdge attribute</h5>
   * <p>
   * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
   * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
   * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
   * attribute to the corresponding value.
   * </p>
   *
   * <h5>Length.Counter attribute</h5>
   * <p>
   * Note that the default for this attribute has changed in oj-c-text-area.  To get the legacy default behavior, you will
   * need to specify length.counter = 'none'.
   * </p>
   *
   * <h5>MessagesCustom attribute</h5>
   * <p>
   * The type of the <code class="prettyprint">severity</code> property of the messages in the
   * array has changed from
   * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
   * essentially <code class="prettyprint">string | number</code>, to simply
   * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
   * values are the same as the previously supported string values.
   * The application can no longer specify severity as a number, including hardcoded numbers,
   * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
   * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
   * </p>
   *
   * <h5>TextAlign attribute</h5>
   * <p>
   * The usage of the style classes: oj-form-control-text-align-right, oj-form-control-text-align-start and oj-form-control-text-align-end is now
   * replaced with this attribute. The value of this attribute maps to these style classes as shown below:
   * <ul>
   * <li>
   * .oj-form-control-text-align-right maps to 'right'
   * </li>
   * <li>
   * .oj-form-control-text-align-start maps to 'start'
   * </li>
   * <li>
   * .oj-form-control-text-align-end maps to 'end'
   * </li>
   * </ul>
   * </p>
   * <h5>Translations attribute</h5>
   * <p>
   * The translations.required.message-detail attribute has changed to required-message-detail.
   * </p>
   *
   * <h5>Value attribute</h5>
   * <p>
   * Clearing the field and committing the value will now set the value attribute to <code>null</code>
   * instead of <code>''</code>.
   * </p>
   *
   * <h5>Refresh method</h5>
   * <p>
   * The refresh method is no longer supported. The application should no longer need to use this method. If the application
   * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
   * </p>
   *
   * <h5>Animation Events</h5>
   * <p>
   * ojAnimateStart and ojAnimateEnd events are no longer supported.
   * </p>
   *
   * <h5>Custom Label</h5>
   * <p>
   * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
   * label-hint attribute to add a label for the form component.
   * </p>
   * <p>
   * The application should no longer need to use an &lt;oj-label-value> component to layout the form component. The application
   * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
   * </p>
   *
   * <h5>DescribedBy attribute</h5>
   * <p>
   * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
   * This attribute is not carried forward to the core pack component.
   * </p>
   *
   * <h5>Formatted messages</h5>
   * <p>
   * Formatting messages using html tags is not supported in the core pack component.
   * </p>
   *
   * <h5>Usage in Dynamic Form</h5>
   * <p>
   * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
   * </p>
   *
   * @example <caption>Initialize the textarea with no attributes specified:</caption>
   * &lt;oj-text-area>&lt;/oj-text-area>
   *
   * * @example <caption>Initialize the textarea with some attributes:</caption>
   * &lt;oj-text-area id="txtAreaId" disabled>&lt;/oj-text-area>
   *
   * @example <caption>Initialize the textarea via the JET component binding:</caption>
   * &lt;oj-text-area id="txtAreaId" value="{{currentValue}}">&lt;/oj-text-area>
   */
  // --------------------------------------------------- oj.ojTextArea Styling Start ------------------------------------------------------------
  /**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form control style classes can be applied to the component, or an ancestor element. <br/>
   * When applied to an ancestor element, all form components that support the style classes will be affected.
   */
  // ---------------- oj-form-control-full-width --------------
  /**
   * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
   * @ojstyleclass oj-form-control-full-width
   * @ojdisplayname Full Width
   * @memberof oj.ojTextArea
   * @ojtsexample
   * &lt;oj-text-area class="oj-form-control-full-width">
   * &lt;/oj-text-area>
   */

  // ---------------- oj-form-control max-width --------------
  /**
   * In the Redwood theme the default max width of a text field is 100%.
   * These max width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-max-width
   * @ojdisplayname Max Width
   * @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojTextArea
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-text-area class="oj-form-control-max-width-md">&lt;/oj-text-area>
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
   * @ojshortdesc Sets the max width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojTextArea
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-md
   * @ojshortdesc Sets the max width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojTextArea
   */

  // ---------------- oj-form-control width --------------
  /**
   * In the Redwood theme the default width of a text field is 100%.
   * These width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-width
   * @ojdisplayname Width
   * @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojTextArea
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-text-area class="oj-form-control-width-md">&lt;/oj-text-area>
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-sm
   * @ojshortdesc Sets the width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojTextArea
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-md
   * @ojshortdesc Sets the width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojTextArea
   */

  // ---------------- oj-form-control-text-align- --------------
  /**
   * Classes that help align text of the element.
   * @ojstyleset text-align
   * @ojdisplayname Text Alignment
   * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
   * @ojstylerelation exclusive
   * @memberof oj.ojTextArea
   * @ojtsexample
   * &lt;oj-text-area class="oj-form-control-text-align-right">
   * &lt;/oj-text-area>
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-right
   * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
   * @ojdisplayname Align-Right
   * @memberof! oj.ojTextArea
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-start
   * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
   * @ojdisplayname Align-Start
   * @memberof! oj.ojTextArea
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-end
   * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
   * @ojdisplayname Align-End
   * @memberof! oj.ojTextArea
   */
  // --------------------------------------------------- oj.ojTextArea Styling end ------------------------------------------------------------

  oj.__registerWidget('oj.ojTextArea', $.oj.inputBase, {
    version: '1.0.0',
    defaultElement: '<textarea>',
    widgetEventPrefix: 'oj',

    /**
     * @expose
     * @private
     * @memberof! oj.ojTextArea
     */
    _ATTR_CHECK: [],

    /**
     * @expose
     * @private
     * @memberof! oj.ojTextArea
     */
    _CLASS_NAMES: 'oj-textarea-input',

    /**
     * @expose
     * @private
     * @memberof! oj.ojTextArea
     */
    _WIDGET_CLASS_NAMES: 'oj-textarea oj-form-control oj-component',

    _INPUT_CONTAINER_CLASS: 'oj-text-field-container',
    _TEXTAREA_COUNTER_CONTAINER: 'oj-textarea-counter-container',
    _TEXTAREA_COUNTER_EL: 'oj-textarea-counter-el',

    _INPUT_HANDLER_KEY: 'input',

    options: {
      /**
       * A converter instance or one that duck types {@link oj.Converter}.
       * {@ojinclude "name":"inputBaseConverterOptionDoc"}
       *
       * <p>
       * The hint exposed by the converter is shown inline by default in the Redwood theme when
       * the field has focus.
       * In the Alta theme, converter hints are shown in a notewindow on focus,
       * or as determined by the
       * 'converterHint' property set on the <code class="prettyprint">display-options</code>
       * attribute.
       * In either theme, you can turn off showing converter hints by using the
       * 'converterHint' property set to 'none' on the <code class="prettyprint">display-options</code>
       * attribute.
       * </p>
       * <p>
       * In the Redwood theme, only one hint shows at a time, so the precedence rules are:
       * help.instruction shows; if no help.instruction then validator hints show;
       * if none, then help-hints.definition shows; if none, then converter hint shows.
       * help-hints.source always shows along with the other help or hint.
       * </p>
       * @example <caption>Initialize the component with a number converter instance:</caption>
       * &lt;oj-text-area converter="[[salaryConverter]]">&lt;/oj-text-area><br/>
       * // Initialize converter instance using currency options
       * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
       * this.salaryConverter = new NumberConverter(options);
       *
       * @example <caption>Get or set the <code class="prettyprint">converter</code>
       * property after initialization:</caption>
       * // getter
       * var converter = myComp.converter;
       *
       * // setter
       * myComp.converter = myConverter;
       * @expose
       * @access public
       * @instance
       * @default null
       * @memberof! oj.ojTextArea
       * @ojshortdesc An object that converts the value. See the Help documentation for more information.
       * @ojsignature [{
       *    target: "Type",
       *    value: "oj.Converter<V>|
       *            null",
       *    jsdocOverride: true},
       *    {target: "Type",
       *    value: "Promise<oj.Converter<V>>|oj.Converter<V>|
       *            oj.Validation.RegisteredConverter|
       *            null",
       *    consumedBy: 'tsdep'}]
       * @ojdeprecated {since: '8.0.0', target: 'memberType', value: ['oj.Validation.RegisteredConverter'],
       *                description:'Defining a converter with an object literal with converter type and its options
       *                  (aka JSON format) has been deprecated and does nothing. If needed, you can make the JSON format
       *                  work again by importing the deprecated module you need, like ojvalidation-base or
       *                  ojvalidation-number module.'}
       * @ojdeprecated {since: '17.0.0', target: 'memberType', value: ['Promise<oj.Converter<V>>'],
       *                description: 'Defining a Promise to a Converter instance has been deprecated. The application should resolve the promise and then update the converter attribute with the resolved converter instance.'}
       * @type {Object|null}
       */
      converter: null,
      /**
       * The maximum number of visible text lines of the textarea. The textarea will change its height in response to content change.
       * If this is 0, the number of visible text lines is always as specified by the "rows" attribute, and the textarea will never change
       * its size.
       * If this is -1, there is no maximum and the textarea will grow to show all the content.
       * If this is a positive number larger than the "rows" attribute, the textarea will grow to fit the content,
       * up to the maximum number of text lines.
       * The height will never be less than the number of rows specified by the "rows" attribute.
       *
       * @example <caption>Initialize component with <code class="prettyprint">max-rows</code> attribute:</caption>
       * &lt;oj-some-element max-rows="5">&lt;/oj-some-element>
       *
       * @example <caption>Get or set the <code class="prettyprint">max-rows</code> property after initialization:</caption>
       * // getter
       * var ro = myComp.maxRows;
       *
       * // setter
       * myComp.maxRows = 5;
       *
       * @expose
       * @instance
       * @memberof! oj.ojTextArea
       * @ojshortdesc Specifies the maximum number of visible text lines of the textarea.
       * @type {number}
       * @default 0
       * @since 8.0.0
       */
      maxRows: 0,
      /**
       * Regular expression pattern which will be used to validate the component's value.
       * <p>
       * When pattern is set to true, an implicit regExp validator is created using
       * the RegExpValidator -
       * <code class="prettyprint">new RegExpValidator()</code>.
       * </p>
       *
       *
       * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> attribute:</caption>
       * &lt;oj-text-area pattern="[a-zA-Z0-9]{3,}">&lt;/oj-text-area><br/>
       *
       * @example <caption>Get or set the <code class="prettyprint">pattern</code> property after initialization:</caption>
       * // getter
       * var pattern = myComp.pattern;
       *
       * // setter
       * myComp.pattern = "[0-9]{3,}";
       *
       * @expose
       * @instance
       * @memberof! oj.ojTextArea
       * @type {string|undefined}
       * @ignore
       */
      pattern: '',
      /**
       *
       * Defines the resizeBehavior of the textarea.
       * Note that this is implemented via the native browser support for resize on the textarea element.
       * If a browser doesn't support this (IE, Edge, iOS, Android), then this attribute has no effect.
       *
       * @expose
       * @memberof oj.ojTextArea
       * @ojshortdesc Specifies the resize behavior, based upon native browser support. See the Help documentation for more information.
       * @instance
       * @type {string}
       * @ojvalue {string} "both" The textarea will be interactively resizable horizontally and vertically.
       * @ojvalue {string} "horizontal" The textarea will be resizable in the horizontal direction only.
       * @ojvalue {string} "vertical" The textarea will be resizable in the vertical direction only.
       * @ojvalue {string} "none" The textarea will not be interactively resizable.
       * @default "none"
       * @since 7.0.0
       *
       * @example <caption>Initialize the textarea to a specific <code class="prettyprint">resizeBehavior</code></caption>
       * &lt;oj-text-area resize-behavior="none" &gt;&lt;/oj-text-area&gt;
       *
       * @example <caption>Get or set the <code class="prettyprint">resizeBehavior</code> property, after initialization:</caption>
       *
       * // getter
       * var resizeBehavior = myTextarea.resizeBehavior;
       *
       * // setter
       * myTextarea.resizeBehavior = "none";
       */
      resizeBehavior: 'none',
      /**
       * The number of visible text lines in the textarea. It can also be used to
       * give specific height to the textarea.  When used in conjuction with max-rows,
       * the rows attribnute will be the minimum height of the textarea.
       *
       * @example <caption>Initialize component with <code class="prettyprint">rows</code> attribute:</caption>
       * &lt;oj-some-element rows="5">&lt;/oj-some-element>
       *
       * @example <caption>Get or set the <code class="prettyprint">rows</code> property after initialization:</caption>
       * // getter
       * var ro = myComp.rows;
       *
       * // setter
       * myComp.rows = 5;
       *
       * @expose
       * @instance
       * @memberof! oj.ojTextArea
       * @ojshortdesc Specifies the visible number of lines in the text area.
       * @type {number}
       * @ojextension {_COPY_TO_INNER_ELEM: true}
       */
      rows: undefined,

      /**
       * @expose
       * @instance
       * @memberof oj.ojTextArea
       * @name length
       * @type {Object}
       * @ojshortdesc An object whose properties describe the maximum length attributes.
       * @since 8.0.0
       */
      length: {
        /**
         * Maximum number of characters that can be entered in the input field.
         *
         * @expose
         * @name length.max
         * @ojshortdesc Specifies the maximum number of characters to be entered in the text area.
         * @memberof! oj.ojTextArea
         * @instance
         * @type {number|null}
         * @default null
         * @since 8.0.0
         */
        max: null,

        /**
         * Dictates how the input text characters has to be counted.
         *
         * @expose
         * @name length.countBy
         * @ojshortdesc Specifies the manner in which the text area characters has to be counted.
         * @memberof! oj.ojTextArea
         * @instance
         * @type {string=}
         * @ojvalue {string} 'codePoint' Uses code point to calculate the text length
         * @ojvalue {string} 'codeUnit' Uses code unit to calculate the text length
         * @default "codePoint"
         * @since 8.0.0
         */
        countBy: 'codePoint',

        /**
         * Decides whether the remaining number of characters
         * that can be entered is shown or not.
         *
         * @expose
         * @name length.counter
         * @ojshortdesc The type of counter to display.
         * @memberof! oj.ojTextArea
         * @instance
         * @type {string=}
         * @ojvalue {string} 'none' The remaining characters count is not displayed.
         * @ojvalue {string} 'remaining' The remaining characters count is displayed.
         * @default "none"
         * @since 8.0.0
         */
        counter: 'none'
      }

      // Events

      /**
       * Triggered when the ojTextArea is created.
       *
       * @event
       * @name create
       * @memberof oj.ojTextArea
       * @instance
       * @property {Event} event event object
       * @property {Object} ui Currently empty
       * @ignore
       *
       * @example <caption>Initialize the ojTextArea with the <code class="prettyprint">create</code> callback specified:</caption>
       * $( ".selector" ).ojTextArea({
       *     "create": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
       * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
       */
      // create event declared in superclass, but we still want the above API doc
    },

    /**
     * Performs post processing after _SetOption() calls _superApply(). Different options, when changed, perform
     * different tasks.
     *
     * @param {string} option
     * @param {Object=} flags
     * @protected
     * @memberof oj.ojTextArea
     * @instance
     */
    _AfterSetOption: function (option, flags) {
      this._super(option, flags);

      switch (option) {
        case 'value':
          this._filterTextOnValueChange();
          this._AfterSetOptionLength(this.options.length);
          break;

        default:
          break;
      }
    },

    /**
     * This function gets called on initial render,
     * and when oj-text-area attributes are modified.
     *
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojTextArea
     */
    _AfterCreate: function () {
      var ret = this._superApply(arguments);
      if (this.options.value === undefined) {
        this._SetDisplayValue('');
      }
      this.widget()[0].querySelector('.' + this._INPUT_CONTAINER_CLASS).style.resize =
        this.options.resizeBehavior;
      this._setupResizeTextareaBind();
      var maxrows = this.options.maxRows;
      if (maxrows === -1) {
        this.widget()[0].classList.add('oj-maxrows-neg1');
      }
      return ret;
    },
    /**
     * Do things here for creating the component where you need the converter, since
     * getting the converter can be asynchronous. We get the converter before calling
     * this method, so it is there. This function is called once the converter is resolved.
     *
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojTextArea
     */
    _AfterCreateConverterCached: function () {
      var ret = this._super();
      var textarea = this._GetContentElement()[0];
      var maxrows = this.options.maxRows;
      // don't resize <textarea> if you don't have to
      let textAreaNotInUse = this._textAreaElementNotDisplayed();
      if (!textAreaNotInUse && (maxrows === -1 || maxrows > textarea.rows)) {
        this._calculateLineHeight(textarea);
        this._resizeTextArea();
      }
      return ret;
    },

    /**
     * @ignore
     * @protected
     * @memberof! oj.ojTextArea
     * @override
     */
    // eslint-disable-next-line no-unused-vars
    _setOption: function (key, value, flags) {
      var retVal = this._superApply(arguments);

      if (key === 'resizeBehavior') {
        this.widget()[0].querySelector('.' + this._INPUT_CONTAINER_CLASS).style.resize = value;
      } else if (key === 'value') {
        // only resize if maxrows is more than rows and we aren't using readonlyDiv at the moment.
        let textAreaNotInUse = this._textAreaElementNotDisplayed();
        let maxrows = this.options.maxRows;
        if (!textAreaNotInUse && (maxrows === -1 || maxrows > this._GetContentElement()[0].rows)) {
          this._resizeTextArea();
        }
      }
      return retVal;
    },
    /**
     * Notifies the component that its subtree has been connected to the document
     * programmatically after the component has been created.
     * @return {void}
     * @memberof oj.ojTextArea
     * @instance
     * @protected
     * @override
     */
    _NotifyAttached: function () {
      this._super();
      var maxrows = this.options.maxRows;
      if (maxrows === -1 || maxrows > this._GetContentElement()[0].rows) {
        this._resizeTextArea();
      }
    },
    /**
     * Invoked when the input event happens
     *
     * @ignore
     * @protected
     * @memberof! oj.inputBase
     * @param {Event} event
     */
    _onInputHandler: function (event) {
      this._super(event);
      var textarea = this._GetContentElement()[0];
      // only resize if maxrows is more than rows
      var maxrows = this.options.maxRows;
      if (maxrows === -1 || maxrows > textarea.rows) {
        this._resizeTextArea();
      }
    },
    /**
     * Resize the textarea based on the content.
     * @ignore
     * @protected
     * @memberof! oj.ojTextArea
     */
    _resizeTextArea: function () {
      if (this._textAreaElementNotDisplayed() || this._lineHeight === undefined) {
        return;
      }
      const maxRows = this.options.maxRows;
      const textarea = this._GetContentElement()[0];
      const rows = textarea.rows;
      textarea.style.height = 0;
      const paddingHeight = this._getStylingHeight(textarea, 'padding');
      const heightForRows = this._lineHeight * rows + paddingHeight;
      const scrollHeight = textarea.scrollHeight;
      var resizedHeight = 0;
      // if maxRows is -1 the textarea will grow or shrink to fit all the content.
      // it won't shrink any less than rows.
      if (maxRows === -1) {
        // we want to fit the entire scrollHeight, but we don't want
        // to shrink smaller than the height for rows.
        if (scrollHeight < heightForRows) {
          resizedHeight = heightForRows;
        } else {
          resizedHeight = scrollHeight;
        }
      } else if (maxRows > rows) {
        // if maxRows is positive and greater than rows, the textarea will grow to fit the content
        // up to maxrows, or shrink to fit the content and down to rows.
        var heightForMaximumRows = this._lineHeight * maxRows + paddingHeight;
        if (scrollHeight > heightForMaximumRows) {
          resizedHeight = heightForMaximumRows;
        } else if (scrollHeight < heightForRows) {
          resizedHeight = heightForRows;
        } else {
          resizedHeight = scrollHeight;
        }
      } else {
        resizedHeight = heightForRows;
      }
      textarea.style.height = resizedHeight + 'px';
    },

    _setupResizeTextareaBind: function () {
      if (this._textAreaElementNotDisplayed()) {
        return;
      }

      this._resizeTextareaBind = function () {
        var textarea = this._GetContentElement()[0];
        // only resize if maxrows is more than rows or maxrows is -1,
        // which means it will grow as you type if need be.
        var maxrows = this.options.maxRows;
        if (maxrows === -1 || maxrows > textarea.rows) {
          this._resizeTextArea();
        }
      }.bind(this);
      window.addEventListener('resize', this._resizeTextareaBind, false);
    },
    /**
     * Calculates the padding and borders height for text-area
     *
     * @ignore
     * @protected
     * @memberof! oj.ojTextArea
     * @param {element} textarea
     * @param {string} type - accept 'padding', 'border', 'paddingAndBorder'
     */
    _getStylingHeight: function (textarea, type) {
      var cssStyle = window.getComputedStyle(textarea);
      var stylingHeight = 0;
      if (type === 'padding' || type === 'paddingAndBorder') {
        var paddingTop = parseFloat(cssStyle.paddingTop);
        var paddingBottom = parseFloat(cssStyle.paddingBottom);
        stylingHeight += paddingTop + paddingBottom;
      }
      if (type === 'border' || type === 'paddingAndBorder') {
        var borderTopWidth = parseFloat(cssStyle.borderTopWidth);
        var borderBottomWidth = parseFloat(cssStyle.borderBottomWidth);
        stylingHeight += borderTopWidth + borderBottomWidth;
      }
      return stylingHeight;
    },
    /**
     * Calculates the line height for text-area
     *
     * @ignore
     * @protected
     * @memberof! oj.ojTextArea
     */
    _calculateLineHeight: function (textarea) {
      if (this._textAreaElementNotDisplayed()) {
        return;
      }
      var computedStyle = window.getComputedStyle(textarea);
      if (computedStyle.display === 'none') {
        return;
      }
      var computedlineHeight = computedStyle.lineHeight;
      switch (computedlineHeight) {
        // We get 'normal' for values 'initial', 'inherit', 'unset' and 'normal'
        // In Alta Web theme, the lineHeight returns 'normal', we should keep this.
        case 'normal':
          // getComputedStyle always return fontSize in pixels.  Not likely a float, but since it's legal
          // we use parseFloat()
          var fontSize = parseFloat(computedStyle.fontSize);
          this._lineHeight = 1.2 * fontSize;
          break;
        // We get the value in pixels for all units (%, em, cm, mm, in, pt, pc, px)
        default:
          this._lineHeight = parseFloat(computedlineHeight);
      }
    },
    /**
     * @ignore
     * @private
     */
    _cleanUpListeners: function () {
      if (this._resizeTextareaBind) {
        window.removeEventListener('resize', this._resizeTextareaBind);
      }
    },
    /**
     * @ignore
     * @protected
     * @override
     */
    _ReleaseResources: function () {
      this._super();
      this._cleanUpListeners();
    },
    getNodeBySubId: function (locator) {
      var node = this._superApply(arguments);
      var subId;
      if (!node) {
        subId = locator.subId;
        if (subId === 'oj-textarea-input') {
          node = this.element ? this.element[0] : null;
        }
      }
      // Non-null locators have to be handled by the component subclasses
      return node || null;
    },

    /**
     * @ignore
     * @override
     * @protected
     * @memberof! oj.ojTextArea
     * @return {boolean}
     */
    _DoWrapElementAndTriggers: function () {
      this._ELEMENT_TRIGGER_WRAPPER_CLASS_NAMES = this._INPUT_CONTAINER_CLASS;
      return true;
    },

    /**
     * ojTextArea extends from InputBase which creates a readonly div,
     * so overriding it to return false prevents ojTextArea from creating
     * a readonly div. Only form components that show their value in an
     * html input element need to use a readonly div for readonly in the
     * redwood theme.
     * @ignore
     * @override
     * @protected
     * @memberof! oj.ojTextArea
     * @return {boolean}
     */
    _UseReadonlyDiv: function () {
      var ret = this._super();
      if (ret) {
        // if max-rows is -1, then use readonly div when it is readonly.
        if (this.options.maxRows === -1) {
          return true;
        }
        return false;
      }
      return ret;
    },

    /**
     * @instance
     * @memberof! oj.ojTextArea
     * @override
     * @protected
     * @return {string}
     */
    _GetDefaultStyleClass: function () {
      return 'oj-textarea';
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojTextArea
     */
    _GetTranslationsSectionName: function () {
      return 'oj-inputBase';
    },
    /**
     * If the converter is async or not
     *
     * @ignore
     * @protected
     * @memberof! oj.ojTextArea
     */
    _isConverAsync: function () {
      var converter = this._GetConverter();
      if (converter instanceof Promise) {
        return true;
      }
      return false;
    },
    /**
     * Invoked when keyup is triggered of the this.element
     *
     * When of keyCode is of Enter, oj-text-area should do nothing as
     * the enter key is just user entered data.
     *
     * @ignore
     * @protected
     * @override
     * @memberof! oj.ojTextArea
     * @param {Event} event
     */
    // eslint-disable-next-line no-unused-vars
    _onKeyUpHandler: function (event) {},
    /**
     * Invoked when keydown is triggered of the this.element
     *
     * When of keyCode is of ALT+ENTER, oj-text-area will insert a new line.
     * It is useful in the cases where Enter is used by the parent component, such as an oj-text-area in an oj-data-grid,
     * where Enter will go to the cell below in an editable data grid. Therefore in that case, use Alt+Enter on Windows and
     * Option+Return on MacOS to insert a new line in textarea.
     *
     * @ignore
     * @protected
     * @override
     * @memberof! oj.ojTextArea
     * @param {Event} event
     */
    // eslint-disable-next-line no-unused-vars
    _onKeyDownHandler: function (event) {
      if (event.keyCode === 13 || event.key === 'Enter') {
        if (event.altKey) {
          var textarea = this._GetContentElement()[0];
          var textValue = textarea.value;
          var textBefore = textValue.substring(0, textarea.selectionStart);
          var textAfter = textValue.substring(textarea.selectionEnd);
          textarea.value = textBefore + '\r\n' + textAfter;
          var cursorPosition = textarea.value.length - textAfter.length;
          textarea.setSelectionRange(cursorPosition, cursorPosition);
          // Using blur()/focus() to bring the cursor position so that it's visible in the textarea
          textarea.blur();
          textarea.focus();
          var maxrows = this.options.maxRows;
          if (maxrows === -1 || maxrows > textarea.rows) {
            this._resizeTextArea();
          }
          event.stopPropagation();
        }
      }
    },
    /**
     * Returns true if the <textarea> dom element is not being used,
     * and instead the readonlyDiv is being used. In that case we
     * do not want to resize the <textarea> element.
     *
     * @ignore
     * @private
     * @memberof! oj.ojTextArea
     */
    _textAreaElementNotDisplayed: function () {
      return this._UseReadonlyDiv() && this.options.readOnly && this.options.maxRows === -1;
    }
  });

  // Fragments:

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *    <tr>
   *       <td>TextArea</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Sets focus to textarea. Show user assistance text. This may be inline or in a notewindow
   * depending upon theme and property settings.</td>
   *     </tr>
   *   </tbody>
   *  </table>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojTextArea
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>TextArea</td>
   *       <td><kbd>Tab In</kbd></td>
   *       <td>Set focus to the textarea.
   *       Show user assistance text. This may be inline or in a notewindow
   * depending upon theme and property settings.</td>
   *     </tr>
   *     <tr>
   *       <td>TextArea</td>
   *       <td>MacOS:<kbd>Return</kbd>; Windows:<kbd>Enter</kbd></td>
   *       <td>Insert a newline. This is used for a plain textarea or a nested textarea where
   * Enter is not used by the parent component for other purpose.</td>
   *     </tr>
   *     <tr>
   *       <td>TextArea</td>
   *       <td>MacOS:<kbd>Option+Return</kbd>; Windows:<kbd>Alt+Enter</kbd></td>
   *       <td>Insert a newline. This is used for cases where Enter is used by the parent component,
   * such as an oj-text-area in an oj-data-grid, where Enter will go to the cell below in an editable data grid.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojTextArea
   */

  // ////////////////     SUB-IDS     //////////////////
  /**
   * <p>Sub-ID for the ojTextArea component's textarea element.</p>
   *
   * @ojsubid oj-textarea-input
   * @ignore
   * @memberof oj.ojTextArea
   * @deprecated 4.0.0  Since the application supplies this element, it can supply a unique ID by which the element can be accessed.
   *
   * @example <caption>Get the node for the input element:</caption>
   * var node = myComp.getNodeBySubId("oj-textarea-input");
   */

});


define('ojs/ojoptgroup',['ojs/ojcore-base', 'ojs/ojcomponentcore'], function (oj, ojcomponentcore) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @constructor
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  function ojOptGroup(context) {
    this.updateDOM = function () {
      var customRenderer = context.element.customOptgroupRenderer;
      if (customRenderer && typeof customRenderer === 'function') {
        customRenderer(context.element);
      }
    };
  }

  /**
   * @protected
   * @ignore
   */
  (function () {
    // not documented
var __oj_optgroup_metadata = 
{
  "properties": {
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "label": {
      "type": "string"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_optgroup_metadata.properties.customOptgroupRenderer = {};
    __oj_optgroup_metadata.extension._CONSTRUCTOR = ojOptGroup;
    oj.CustomElementBridge.register('oj-optgroup', { metadata: __oj_optgroup_metadata });
  })();

  /**
   * @ojcomponent oj.ojOptgroup
   * @since 4.0.0
   * @ojdisplayname Option Group
   * @ojshortdesc An optgroup supports grouping of child oj-option elements.
   * @ojrole option
   *
   * @ojsignature class ojOptgroup extends JetElement<ojOptgroupSettableProperties>
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["label", "disabled"]}
   *
   * @ojoracleicon 'oj-ux-ico-get-options'
   *
   * @classdesc
   * <h3 id="optgroupOverview-section">
   *   JET Optgroup
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optgroupOverview-section"></a>
   * </h3>
   * <p>The oj-optgroup element is used to group [oj-option]{@link oj.ojOption} elements.</p>
   * <p>For example:
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-select-one>
   *   &lt;oj-optgroup label="group1 label">
   *     &lt;oj-option value="option 1">option 1&lt;/oj-option>
   *     &lt;oj-option value="option 2">option 2&lt;/oj-option>
   *   &lt;/oj-optgroup>
   *   &lt;oj-optgroup label="group2 label">
   *     &lt;oj-option value="option 3">option 3&lt;/oj-option>
   *     &lt;oj-option value="option 4">option 4&lt;/oj-option>
   *   &lt;/oj-optgroup>
   * &lt;/oj-select-one>
   * </code></pre>
   */

  /**
   * <p>Disables the oj-optgroup if set to <code class="prettyprint">true</code>.
   *
   * @name disabled
   * @ojshortdesc Disables the group if set to true.
   * @expose
   * @memberof oj.ojOptgroup
   * @instance
   * @type {boolean}
   * @default false
   *
   * @example <caption>Initialize the oj-optgroup with the <code class="prettyprint">disabled</code> attribute specified:</caption>
   * &lt;oj-optgroup disabled="[[isDisabled]]">&lt;/oj-optgroup>
   *
   * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
   * // getter
   * var disabledValue = myOptgroup.disabled;
   *
   * // setter
   * myOptgroup.disabled = true;
   */

  /**
   * <p>Specifies the oj-optgroup's label.
   *
   * @name label
   * @ojshortdesc The group label.
   * @ojrequired
   * @ojtranslatable
   * @expose
   * @memberof oj.ojOptgroup
   * @instance
   * @type {string}
   *
   * @example <caption>Initialize the oj-optgroup with the <code class="prettyprint">label</code> attribute specified:</caption>
   * &lt;oj-optgroup label="group1 label">&lt;/oj-optgroup>
   *
   * @example <caption>Get or set the <code class="prettyprint">label</code> property after initialization:</caption>
   * // getter
   * var labelValue = myOptgroup.label;
   *
   * // setter
   * myOptgroup.label = 'Group 1';
   */

  /**
   * <p>The oj-optgroup element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
   * accepted children and slots.</p>
   *
   * @ojchild Default
   * @memberof oj.ojOptgroup
   * @ojshortdesc The oj-optgroup element accepts oj-option elements as children.
   * @ojpreferredcontent ["OptionElement"]
   *
   * @example <caption>Initialize the oj-optgroup with child content specified:</caption>
   * &lt;oj-optgroup>
   *   &lt;oj-option value="option1">Option label&lt;/oj-option>
   * &lt;/oj-optgroup>
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   * @expose
   * @memberof oj.ojOptgroup
   * @instance
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   * @expose
   * @memberof oj.ojOptgroup
   * @instance
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Refreshes the visual state of the component.
   *
   * @function refresh
   * @return {void}
   * @expose
   * @memberof oj.ojOptgroup
   * @instance
   */
  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof oj.ojOptgroup
   * @instance
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */

});


define('ojs/ojlabelvalue',['ojs/ojcore', 'ojs/ojcomponentcore', 'ojs/ojlabel', 'ojs/ojcore-base'], function (ojcore, ojcomponentcore, ojlabel, oj) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @ojcomponent oj.ojLabelValue
   * @since 5.1.0
   * @ojshortdesc A label value is used to lay out a label and value, it is most commonly used in a form layout.
   *
   * @ojsignature {target: "Type", value:"class ojLabelValue extends JetElement<ojLabelValueSettableProperties>"}
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelEdge", "labelWidth", "colspan"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-label-value'
   * @ojuxspecs ['label']
   *
   * @classdesc
   * <h3 id="optionOverview-section">
   *   JET LabelValue
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optionOverview-section"></a>
   * </h3>
   * <p>The oj-label-value element is used to group label(s) and value(s) elements into a single
   * layout element that is most commonly a child of oj-form-layout.  This component gives some
   * flexibility to what shows up in the label portion and what shows up in the value portion of
   * an oj-form-layout element sequence of laid out elements (most commonly which are label/value pairs).
   * The 'label' and 'value' slots are used to add elements to either the 'label' or 'value' parts
   * of a label/value form layout item.
   *
   * <p>For example:
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-form-layout max-columns='2' label-edge='start' label-width="50%">
   *   &lt;oj-label-value>
   *     &lt;my-label slot="label" for="my1">&lt;/my-label>
   *     &lt;my-input slot="value" id="my1">&lt;/my-input>
   *   &lt;/oj-label-value>
   *   &lt;oj-label-value>
   *     &lt;my-label slot="label" for="my2">&lt;/my-label>
   *   &lt;/oj-label-value>
   *   &lt;oj-label-value>
   *     &lt;my-input slot="value" id="my2">&lt;/my-input>
   *   &lt;/oj-label-value>
   * &lt;/oj-form-layout>
   * </code></pre>
   *
   * <p>Any slot child elements not in either a 'label' or 'value' slot will be removed from the DOM.
   * This includes the default slot.
   * </p>
   */

  /**
   * @member
   * @name colspan
   * @expose
   * @memberof oj.ojLabelValue
   * @ojshortdesc Specifies how many columns this label/value pair will occupy in the parent form layout. See the Help documentation for more information.
   * @instance
   * @type {number}
   * @default 1
   * @since 6.2.0
   * @desc Specifies how many columns this label/value pair will occupy in the parent oj-form-layout.
   * <p>This attribute only has an effect if the parent oj-form-layout has direction="row".</p>
   * <p>If there are fewer columns left in the current row than the colspan value specified, then the remaining available columns will be used.</p>
   * <p>By default, the label portion will occupy the same location and width as the label portion of any other label-value pairs, and the value portion will extend over the remaining columns. The default location and width can be changed with the label-edge and label-width attributes on the oj-label-value, respectively.</p>
   * <p>If a percentage is specified for label-width, it is relative to all columns the element occupy. For example, if colspan is 2 and label-width is set to 50%, the label portion will occupy 1 column, and the value portion will occupy 1 column.</p>
   * @example <caption>Initialize the oj-label-value with the <code class="prettyprint">colspan</code> attribute specified:</caption>
   * &lt;oj-label-value colspan="2">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   * &lt;/oj-label-value>
   *
   * @example <caption>Get or set the <code class="prettyprint">colspan</code> property after initialization:</caption>
   * // getter
   * var cols = myLabelValue.colspan;
   *
   * // setter
   * myLabelValue.colspan = 3;
   */

  /**
   * @member
   * @name labelEdge
   * @expose
   * @memberof oj.ojLabelValue
   * @ojshortdesc Specifies how the label is aligned with its value component.
   * @instance
   * @type {string}
   * @default "inherit"
   * @ojvalue {string} "inside" Label is on top of its value component, with a smaller font-size applied to any oj-label child.
   * @ojvalue {string} "start" Label is inline with the start of its value component
   * @ojvalue {string} "top" Label is on top of its value component.
   * @ojvalue {string} "inherit"  Label will inherit label-edge from its closest custom element ancestor element.
   * @desc Specifies how the label is aligned with its value component.
   * <p>If the value is 'inherit', it will inherit label-edge from its closest custom element ancestor element. If the ancestor doesn't have a label-edge attribute, the default is "top".</p>
   * <p><b>Note: For 'inherit' to work correctly, the application must use data binding (i.e. calling ko.applyBindings on
   * an ancestor node of the oj-label-value).</b></p>
   * <p>
   * When using the oj-label-value custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   * @example <caption>Initialize the oj-label-value with the <code class="prettyprint">label-edge</code> attribute specified:</caption>
   * &lt;oj-label-value label-edge="top">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   * &lt;/oj-label-value>
   *
   * @example <caption>Get or set the <code class="prettyprint">labelEdge</code> property after initialization:</caption>
   * // getter
   * var edge = myLabelValue.labelEdge;
   *
   * // setter
   * myLabelValue.labelEdge = 'start';
   */

  /**
   * @member
   * @name labelWidth
   * @expose
   * @memberof oj.ojLabelValue
   * @ojshortdesc Specifies the label width. See the Help documentation for more information.
   * @instance
   * @type {string}
   * @default "inherit"
   * @desc Specifies the label width.
   * <p>This can be any legal <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/width">CSS width</a> or 'inherit',
   * which will inherit label-width from its closest custom element ancestor element.  If the value is "inherit" and ancestor doesn't have a label-width attribute, the default is "33%".</p>
   * <p>
   * When using the oj-label-value custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">label-width</code> attribute specified:</caption>
   * &lt;oj-form-layout label-width="50%">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">labelWidth</code> property after initialization:</caption>
   * // getter
   * var width = myLabelValue.labelWidth;
   *
   * // setter
   * myLabelValue.labelWidth = '60px';
   */

  /**
   * @member
   * @name _calculatedLabelWidth
   * @expose
   * @memberof oj.ojLabelValue
   * @ojshortdesc Specifies the calculated label width to provide to its descendants.
   * @instance
   * @type {string}
   * @desc This hidden property is used to provide the calculated label width via binding propagation.
   * @ignore
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {*} value - The new value to set the property to.
   * @return {void}
   *
   * @expose
   * @memberof oj.ojLabelValue
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @instance
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {*}
   *
   * @expose
   * @memberof oj.ojLabelValue
   * @instance
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof oj.ojLabelValue
   * @instance
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */
  /**
   * Refreshes the visual state of the component.
   *
   * @function refresh
   *
   * @expose
   * @memberof oj.ojLabelValue
   * @ojshortdesc Refreshes the component.
   * @return {void}
   * @instance
   */

  /**
   * <p>The <code class="prettyprint">label</code> slot is used to specify the 'label' part of a label/value form layout item.</p>
   *
   * @ojslot label
   * @memberof oj.ojLabelValue
   *
   * @example <caption>Initialize a label/value form layout item:</caption>
   * &lt;oj-label-value>
   *   &lt;oj-label for="textWindow" slot="label">Type here&lt;/oj-label>
   *   &lt;oj-textarea id="textWindow" slot="value" rows="5" style="width: 100%; min-width: 100%">&lt;/oj-textarea>
   * &lt;/oj-label-value>
   */
  /**
   * <p>The <code class="prettyprint">value</code> slot is used to specify the 'value' part of a label/value form layout item.</p>
   *
   * @ojslot value
   * @memberof oj.ojLabelValue
   *
   * @example <caption>Initialize a label/value form layout item:</caption>
   * &lt;oj-label-value>
   *   &lt;oj-label for="textWindow" slot="label">Type here&lt;/oj-label>
   *   &lt;oj-textarea id="textWindow" slot="value" rows="5" style="width: 100%; min-width: 100%">&lt;/oj-textarea>
   * &lt;/oj-label-value>
   */

  /**
   * The _ojLabelValue constructor function.
   *
   * @constructor
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  function ojLabelValue(context) {
    var element = context.element;
    var labelOjFlexItem;
    var valueOjFlexItem;

    this.createDOM = function () {
      element.classList.add('oj-label-value', 'oj-form');

      // Create the flex wrapper div
      var ojFlexDiv = document.createElement('div');
      ojFlexDiv.classList.add('oj-flex');
      ojFlexDiv.setAttribute('data-oj-context', '');
      ojFlexDiv.setAttribute('data-oj-internal', '');

      // Create the label div
      labelOjFlexItem = document.createElement('div');
      labelOjFlexItem.classList.add('oj-flex-item');
      labelOjFlexItem.setAttribute('data-oj-context', '');
      labelOjFlexItem.setAttribute('data-oj-internal', '');

      // Create the value div
      valueOjFlexItem = document.createElement('div');
      valueOjFlexItem.classList.add('oj-flex-item');
      valueOjFlexItem.setAttribute('data-oj-context', '');
      valueOjFlexItem.setAttribute('data-oj-internal', '');

      // move the slot children to the appropriate div
      while (element.firstElementChild) {
        var child = element.firstElementChild;
        switch (child.getAttribute('slot')) {
          case 'label':
            labelOjFlexItem.appendChild(child); // @HTMLUpdateOK reparenting child nodes
            break;
          case 'value':
            valueOjFlexItem.appendChild(child); // @HTMLUpdateOK reparenting child nodes
            if (child.tagName === 'OJ-FORM-LAYOUT') {
              // For the nested form layout case, we need to have a way to apply styles to the
              // flex item element that is the parent of the oj-form-layout so that we can
              // make padding adjustments, etc.
              valueOjFlexItem.classList.add('oj-formlayout-nested-formlayout');
            }
            // If we have a corepack form component, we need to hide the label flex item as the
            // component will be rendering its own label for 'top' and 'start' in addition to 'inside'
            if (child.tagName.toLowerCase().startsWith('oj-c-') && 'labelEdge' in child) {
              labelOjFlexItem.classList.add('oj-helper-hidden');
            }
            break;
          default: // removing any non 'label'/'value' slot children
            element.removeChild(child);
            break;
        }
      }

      ojFlexDiv.appendChild(labelOjFlexItem); // @HTMLUpdateOK appending internally created DOM element
      ojFlexDiv.appendChild(valueOjFlexItem); // @HTMLUpdateOK appending internally created DOM element
      element.appendChild(ojFlexDiv); // @HTMLUpdateOK appending internally created DOM element
    };

    /**
     * The main render function.  This function gets called on initial render,
     * when oj-label-value attributes are modified.
     *
     * @memberof oj.ojLabelValue
     * @instance
     * @private
     */
    this.updateDOM = function () {
      var customElementAncestor = _findClosestCustomElementAncestor();

      // Resolve labelEdge to an explict value either from oj-label-value or from ancestor oj-form-layout
      var labelEdge = _getLabelEdge(customElementAncestor);
      var labelWidth = labelEdge === 'start' ? _getLabelWidth(customElementAncestor) : '100%';
      var direction = _getParentFormLayoutDirection(customElementAncestor);

      if (labelEdge === 'start') {
        element.classList.add('oj-formlayout-labels-inline');
        element.classList.remove('oj-form-control-label-inside');
      } else if (labelEdge === 'inside') {
        element.classList.add('oj-form-control-label-inside');
        element.classList.remove('oj-formlayout-labels-inline');
      } else {
        // labelEdge === 'top'
        element.classList.remove('oj-formlayout-labels-inline');
        element.classList.remove('oj-form-control-label-inside');
      }

      // To pick up the correct styles, we need to add the form layout class name that
      // is used for direction = 'row'
      if (direction === 'row') {
        element.classList.add('oj-formlayout-form-across');
      } else {
        element.classList.remove('oj-formlayout-form-across');
      }

      labelOjFlexItem.style.flexGrow = '0';
      labelOjFlexItem.style.flexShrink = '1';
      labelOjFlexItem.style.flexBasis = labelWidth;
      labelOjFlexItem.style.width = labelWidth;
      labelOjFlexItem.style.maxWidth = labelWidth;
      valueOjFlexItem.style.flex = '1 1 0';

      // update the _calculatedLabelWidth
      element._calculatedLabelWidth = labelWidth;
    };

    function _getLabelEdge(customElementAncestor) {
      var labelEdge = 'top'; // default value if "inherit" and ancestor doesn't support labelEdge

      if (element.labelEdge === 'inherit') {
        // We will inherit from custom element if it supports labelEdge
        if (customElementAncestor && 'labelEdge' in customElementAncestor) {
          labelEdge = customElementAncestor.labelEdge;
        }
      } else {
        labelEdge = element.labelEdge;
      }

      return labelEdge;
    }

    function _getParentFormLayoutDirection(customElementAncestor) {
      var direction = 'column'; // default value of oj-form-layout

      if (customElementAncestor && 'direction' in customElementAncestor) {
        direction = customElementAncestor.direction;
      }

      return direction;
    }

    // This is only called when labelEdge === 'start'
    function _getLabelWidth(customElementAncestor) {
      var labelWidth = '33%'; // default value if "inherit" and ancestor doesn't support labelWidth

      if (element.labelWidth === 'inherit') {
        // We will inherit from custom element if it supports labelWidth
        if (customElementAncestor && 'labelWidth' in customElementAncestor) {
          labelWidth = customElementAncestor.labelWidth;
          // for units that are (or can be) relative to horizontal screen size.
          // for '%' labelWidth, we need to devide the value by the number of columns this component
          // is spanning (which can be less that the colspan property value);
          var CssUnitsRegex = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
          var parts = labelWidth.match(CssUnitsRegex);

          switch (parts[2]) {
            case 'vw':
            case 'vmin':
            case 'vmax':
            case '%':
              // find the actual colspan for this element and divide the percentage by the number of cols.
              // This is only done for the "inherit" case.  If a specific value is set on the oj-label-value,
              // then we use that value without modifying it.
              var colspan = Number(element.getAttribute('data-oj-colspan'));
              var columnGap = element.getAttribute('data-oj-column-gap');
              // if it is 0, then the parent component didn't update this and we use the default.
              if (colspan > 0) {
                labelWidth =
                  'calc(((' +
                  labelWidth +
                  ' / ' +
                  colspan +
                  ') - ((' +
                  columnGap +
                  ' * (' +
                  (colspan - 1) +
                  ') * ' +
                  parts[1] / colspan / 100 +
                  ')))';
              }
              break;
            default:
              break;
          }
        }
      } else {
        labelWidth = element.labelWidth;
      }

      return labelWidth;
    }

    // searches ancestor elements, until and interesting tag-name is found,
    // returns null if no interesting element is found.
    function _findClosestCustomElementAncestor() {
      var ancestor = element.parentElement;
      // walk up parents until we find the first custom element
      for (; ancestor; ancestor = ancestor.parentElement) {
        // Is it a custom element?
        if (ancestor.tagName.indexOf('-') !== -1) {
          return ancestor;
        }
      }

      return null; // no custom element ancestor
    }
  }

  (function () {
var __oj_label_value_metadata = 
{
  "properties": {
    "colspan": {
      "type": "number",
      "value": 1
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inherit",
        "inside",
        "start",
        "top"
      ],
      "value": "inherit"
    },
    "labelWidth": {
      "type": "string",
      "value": "inherit"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_label_value_metadata.extension._CONSTRUCTOR = ojLabelValue;
    oj.CustomElementBridge.register('oj-label-value', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_label_value_metadata, {
        properties: {
          labelEdge: {
            binding: {
              provide: [
                { name: 'containerLabelEdge' },
                { name: 'labelEdge', transform: { top: 'provided', start: 'provided' } }
              ],
              consume: { name: 'containerLabelEdge' }
            }
          },
          _calculatedLabelWidth: {
            binding: {
              provide: [{ name: 'labelWidth' }]
            }
          }
        }
      })
    });
  })();

});


define('ojs/ojformlayout',['ojs/ojcore', 'ojs/ojcomponentcore', 'ojs/ojlabel', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojcontext', 'ojs/ojlogger', 'ojs/ojthemeutils', '@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext'], function (ojcore, ojcomponentcore, ojlabel, oj, DomUtils, Context, ojlogger, ojthemeutils, UNSAFE_useFormVariantContext) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   * @ojcomponent oj.ojFormLayout
   * @since 4.1.0
   * @ojshortdesc A form layout manages the layout of labels and fields in a form.
   *
   * @ojsignature {target: "Type", value:"class ojFormLayout extends JetElement<ojFormLayoutSettableProperties>"}
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["maxColumns", "labelEdge", "labelWidth", "readonly"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-form-layout'
   * @ojuxspecs ['form-layout']
   *
   * @classdesc
   * <h3 id="optionOverview-section">
   *   JET FormLayout
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optionOverview-section"></a>
   * </h3>
   * <p>The oj-form-layout element is used to layout groups of label/value pairs in an organized layout that
   * can be optimized for multiple display sizes via attribute value settings.  The following describes how child
   * elements are handled:<br><br>
   * - The following JET components have a <code class="prettyprint">label-hint</code> attribute that allows them to be treated as a
   * label/value pair with an oj-label element dynamically created from the label-hint and help-hints:<br>
   * oj-checkboxset, oj-color-palette, oj-color-spectrum, oj-input-date, oj-input-date-time, oj-input-time,
   * oj-input-number, oj-input-text, oj-text-area, oj-input-password, oj-combobox-one, oj-combobox-many,
   * oj-radioset, oj-select-one, oj-select-many, oj-slider, oj-switch<br>
   * - An oj-label element, followed by any element. The oj-label element will be in the label area
   * and the next element will be in the value area<br>
   * - An oj-label-value child component allows the developer to place elements in the label and/or value area as 'label' and 'value' slot chilren.<br>
   * - All other elements will span the entire width of a single label/value pair.
   *
   * To have a form element span multiple columns, add an oj-label-value component as a child of the oj-form-layout
   * add the component that you want to span multiple columns as a child of the oj-label-value. The colspan attribute
   * on the oj-label-value is used to specify the number of columns to span, and the direction attribute on the
   * oj-form-layout must be set to "row".
   * NOTE: To minimize the need for adding a style attribute to achieve a max-width of 100% on the column spanning
   * component and to facilitate start and end field alignment, the default max-width for form controls is changed
   * to 100% when all of the following conditions are met:
   * - direction == "row"
   * - max-columns > 1
   * - there is at least one oj-label-value child with a colspan attribute specified.
   *
   * <p>For example:
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-form-layout max-columns='2' label-edge='start' label-width="50%">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   *   &lt;oj-input-text id="inputcontrol2" value="text" label-hint="input 2">&lt;/oj-input-text>
   *   &lt;oj-input-text id="inputcontrol3" value="text" label-hint="input 3 longer label">&lt;/oj-input-text>
   *   &lt;oj-label>oj-label in label area&lt;/oj-label>
   *   &lt;p>Next element in value area&lt;/p>
   *   &lt;oj-label-value id="labelonly">
   *     &lt;p slot="label">Some text in the label area&lt;/p>
   *   &lt;/oj-label-value>
   *   &lt;oj-label-value id="valueonly">
   *     &lt;p slot="value">Some text in the value area&lt;/p>
   *   &lt;/oj-label-value>
   *   &lt;p>Some text that spans the label/value area&lt;/p>
   * &lt;/oj-form-layout>
   * </code></pre>
   *
   * <p>The oj-form-layout element currently supports custom element children that support the label-hint
   * and help-hints attributes (oj-input-text, oj-text-area, etc.).
   * For each custom element child with label-hint, FormLayout will generate an oj-label element and pair
   * them together in the layout.
   * </p>
   * <h6>
   *   Accessbility
   * </h6>
   * <p>
   * For a form control to be accessible, it should be labelled, which can be a visible label or, in the case
   * there is no visible label, an aria-label or aria-labelledby attribute.
   * </p>
   * <p>
   * oj-form-layout or form controls can dynamically create labels at different locations based on the combinations of label-edge
   * and label-hint. Refer to the documentation of the label-edge and label-hint attributes for details.
   * </p>
   * <p>
   * If a form control has label-edge=“none” and a label-hint attribute but no
   * labelled-by, aria-label, or aria-labelledby attribute, the label-hint value will be used as the aria-label.
   * </p>
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>
   * To migrate from oj-form-layout to oj-c-form-layout, you need to revise the import statement
   * and references to oj-c-form-layout in your app. Please note the changes between the two components below.
   * </p>
   * <p>
   * The oj-c-form-layout is not compatible with legacy form components, only core pack form components.  If you are using a mix of legacy and core pack components, you will need to use legacy oj-form-layout.
   *
   * <h5>ColspanWrap attribute</h5>
   * <p>
   * The colspan-wrap attribute was removed because oj-c-form-layout only supports wrap for components spanning more than one column.
   * </p>
   *
   * <h5>LabelWidth attribute</h5>
   * <p>
   * The LabelWidth attribute has been renamed to LabelStartWidth but has the same functionality.
   * </p>
   *
   * <h5>oj-label-value not supported</h5>
   * <p>
   * <ul>
   * <li>
   * non form controls - currently only Core Pack form controls are supported in oj-c-form-layout.
   * If you are using oj-label-value to add other components you'll need to stick to legacy oj-form-layout for now
   * </li>
   * <li>
   * column spanning - all Core Pack form components and oj-c-form-layout have a column-span attribute,
   * so oj-label-value is not needed for column spanning
   * </li>
   * </ul>
   * </p>
   */

  // --------------------------------------------------- oj.ojFormLayout Styling Start ------------------------------------------------------------
  /**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form layout style classes should be applied to the oj-form-layout component. <br/>
   */
  // ---------------- oj-formlayout-full-width --------------
  /**
   * In Redwood by default a form layout has a max width, add this class if you'd like to opt out and have the form layout to stretch the full width.
   * @ojstyleclass oj-formlayout-full-width
   * @ojdisplayname Form Layout Full Width
   * @memberof oj.ojFormLayout
   * @ojtsexample
   * &lt;oj-form-layout class="oj-formlayout-full-width">
   * &lt;/oj-form-layout>
   */
  /**
   * @ojstylevariableset oj-form-layout-css-set1
   * @ojstylevariable oj-form-layout-margin-bottom {description: "Bottom margin of each row in a form layout", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-column-min-width {description: "Form layout column min width", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-column-max-width {description: "Form layout column max width", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-start-edge-column-min-width {description: "Form layout column min width when label-edge is set to start", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-start-edge-column-max-width {description: "Form layout column max width when label-edge is set to start", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-column-gutter {description: "Gutter between form layout columns", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-top-edge-label-to-value-padding {description: "Vertical padding between the label and value when label-edge is set to top in a form layout", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-start-edge-label-text-align {description: "Label text align when label-edge is set to start in a form layout", keywords: ["start","end"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-start-edge-value-text-align {description: "Value text align when label-edge is set to start in a form layout", keywords: ["start","end"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-start-edge-label-to-value-padding {description: "Horizontal padding between the label and value when label-edge is set to start in a form layout", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-horizontal-margin {description: "Form layout horizontal margin", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-divider-width {description: "Form layout divider width", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-form-layout-divider-margin {description: "Form layout divider margin", formats: ["length"], help: "#css-variables"}
   * @memberof oj.ojFormLayout
   */

  // --------------------------------------------------- oj.ojFormLayout Styling end ------------------------------------------------------------

  /**
   * @member
   * @name colspanWrap
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {string}
   * @ojvalue {string} "nowrap" The component will occupy the remaining columns in the current row.
   * @ojvalue {string} "wrap" The component will start from the first column of the next row.
   * @desc Specifies how to fit components with colspan attribute in the form layout, when there are fewer columns left in the current row
   * than the colspan value specifies.
   * <p>The default value depends on the theme.</p>
   *
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">colspan-wrap</code> attribute specified:</caption>
   * &lt;oj-form-layout max-columns="3" colspan-wrap="wrap">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-label-value colspan="2">
   *     &lt;oj-label slot="label" for="textareacontrol">textarea&lt;/oj-input-text>
   *     &lt;oj-text-area slot="value" id="textareacontrol" value='text' rows="6">&lt;/oj-text-area>
   *   &lt;/oj-label-value>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">colspanWrap</code> property after initialization:</caption>
   * // getter
   * var wrap = myFormLayout.colspanWrap;
   *
   * // setter
   * myFormLayout.colspanWrap = 'wrap';
   */

  /**
   * @member
   * @name direction
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {string}
   * @ojvalue {string} "column" Components are laid out in columns
   * @ojvalue {string} "row" Components are laid out in rows
   * @desc Specifies the layout direction of the form layout children.
   * <p>The default value depends on the theme.</p>
   *
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">direction</code> attribute specified:</caption>
   * &lt;oj-form-layout direction="row">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
   * // getter
   * var dir = myFormLayout.direction;
   *
   * // setter
   * myFormLayout.direction = "column";
   */

  /**
   * @member
   * @name labelEdge
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {string}
   * @ojvalue {string} "inside" oj-form-layout will not create any label. Label will be created by the form control if the form control has its label-edge set to "inside".
   *                            Please see the specific form control's label-edge attribute documentation for details.
   * @ojvalue {string} "start" oj-form-layout will create a label that's before the start of the form control if the form control's label-edge is not explicitly set.
   *                           If the form control specifies "inside" or "none" as its label-edge, no label will be created by oj-form-layout.
   * @ojvalue {string} "top" oj-form-layout will create a label that's on top of the form control if the form control‘s label-edge is not explicitly set.
   *                         If the form control specifies "inside" or "none" as its label-edge, no label will be created by oj-form-layout.
   * @desc Specifies how the label is created and aligned with its form control.
   * <p>The default value varies by theme, and it works well for the theme in most cases.
   * The oj-form-layout component uses the <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
   * <code class="prettyprint">provide</code> property to provide its <code class="prettyprint">label-edge</code>
   * attribute to any descendent form components and oj-form-layout. It also uses
   * <a href="MetadataTypes.html#ProvideProperty">MetadataTypes.ProvideProperty</a> <code class="prettyprint">transform</code> property
   * to transform the <code class="prettyprint">label-edge</code> attribute to its descendent form components.
   * The form components and the oj-form-layout are configured to consume the label-edge property if it is not explicitly set.
   * For example, if the oj-form-layout's label-edge attribute is set to "top" or "start", and a descendent form component does
   * not have its label-edge attribute set, the form component's label-edge will be the transformed value "provided".</p>
   * <p>
   * When using the oj-form-layout custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   * @ojshortdesc Specifies how the label is created and aligned with its form control. See the Help documentation for more information.
   *
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">label-edge</code> attribute specified:</caption>
   * &lt;oj-form-layout label-edge="top">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">labelEdge</code> property after initialization:</caption>
   * // getter
   * var edge = myFormLayout.labelEdge;
   *
   * // setter
   * myFormLayout.labelEdge = 'start';
   */

  /**
   * @member
   * @name labelWidth
   * @ojshortdesc Specifies the label width. See the Help documentation for more information.
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {string}
   * @default "33%"
   * @desc Specifies the label width.
   * <p>This specifies the width of the oj-label elements.  This can be any legal <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/width">CSS width</a>.</p>
   * <p>
   * When using the oj-form-layout custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">label-width</code> attribute specified:</caption>
   * &lt;oj-form-layout label-width="50%">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">labelWidth</code> property after initialization:</caption>
   * // getter
   * var width = myFormLayout.labelWidth;
   *
   * // setter
   * myFormLayout.labelWidth = '60px';
   */

  /**
   * @member
   * @name labelWrapping
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {string}
   * @default "wrap"
   * @ojvalue {string} "truncate" Label will truncate if needed
   * @ojvalue {string} "wrap" Label will wrap if needed
   * @desc Specifies if the label text should wrap or truncate.
   * <p>
   * When using the oj-form-layout custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">label-wrapping</code> attribute specified:</caption>
   * &lt;oj-form-layout label-wrapping="truncate">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">labelWrapping</code> property after initialization:</caption>
   * // getter
   * var wrap = myFormLayout.labelWrapping;
   *
   * // setter
   * myFormLayout.labelWrapping = 'wrap';
   */

  /**
   * @member
   * @name columns
   * @ojshortdesc Specifies the exact number of columns. This attribute overrides max-columns if it is positive.
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {number}
   * @default 0
   * @desc Specifies the absolute number of columns and overrides max-columns, if the value is positive.
   * If the value is not positive, then this attribute is ignored and max-columns is used to determine
   * the number of columns. This attribute should only be used in special circumstances where you need
   * a specific number of columns even if the fields will be narrower than the suggested minimum
   * (a nested form layout might be an example).
   * </p>
   *
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">columns</code> attribute specified:</caption>
   * &lt;oj-form-layout columns="2">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">columns</code> property after initialization:</caption>
   * // getter
   * var cols = myFormLayout.columns;
   *
   * // setter
   * myFormLayout.columns = 2;
   */

  /**
   * @member
   * @name maxColumns
   * @ojshortdesc Specifies the maximum number of columns. See the Help documentation for more information.
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {number}
   * @default 1
   * @ojmin 1
   * @desc Specifies the maximum number of columns.  The actual number of columns will be responsively determined
   * based on the viewport size and the column width specified in the theme. Note that max-columns will be ignored
   * if columns has a positive value.
   *
   * @example <caption>Initialize the oj-form-layout with the <code class="prettyprint">max-columns</code> attribute specified:</caption>
   * &lt;oj-form-layout max-columns="2">
   *   &lt;oj-input-text id="inputcontrol" required value="text" label-hint="input 1">&lt;/oj-input-text>
   *   &lt;oj-text-area id="textareacontrol" value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   * &lt;/oj-form-layout>
   *
   * @example <caption>Get or set the <code class="prettyprint">maxColumns</code> property after initialization:</caption>
   * // getter
   * var maxCol = myFormLayout.maxColumns;
   *
   * // setter
   * myFormLayout.maxColumns = 2;
   */

  /**
   * @member
   * @name readonly
   * @ojshortdesc Specifies whether the form is readonly. See the Help documentation for more information.
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {boolean}
   * @default false
   * @desc Specifies whether the form is readonly. A readonly form has no reserved rows for user assistance text.
   * <p>
   * The oj-form-layout component uses the
   * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
   * <code class="prettyprint">provide</code> property to provide its
   * <code class="prettyprint">readonly</code>
   * property to any descendent components that are
   * configured to consume it.
   * The form components and the oj-form-layout are configured to consume the readonly property
   * if it is not explicitly set.
   * For example, if the oj-form-layout's readonly attribute is set to true,
   * and a descendent form component does
   * not have its readonly attribute set, the form component's readonly will be true.
   * </p>
   * <p>
   * When using the oj-form-layout custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   */

  /**
   * @member
   * @name userAssistanceDensity
   * @ojunsupportedthemes ["Alta"]
   * @ojshortdesc Specifies the density of the form component's user assistance presentation.
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   * @type {string}
   * @ojsignature {target: "Type", value: "'reflow'|'efficient'|'compact'",  jsdocOverride: true}
   * @ojvalue {string} "reflow" If reflow, messages, help, hints, and required are all shown inline under the field with no reserved space.
   * @ojvalue {string} "efficient" messages, help, hints, and required are all shown inline under the field with reserved space underneath.
   * @ojvalue {string} "compact" messages, help, hints, and required will not be shown inline; they will show in a mode that keeps the screen more compact, like
   * a popup for the messages, and a required icon to indicate Required.
   * @default "efficient"
   *
   * @desc <p>Specifies the density of the form layout's user assistance presentation.
   * It can be shown inline with reserved rows to prevent reflow if
   * a user assistance text shows up, inline without reserved rows,
   * or it can be shown compactly in a popup instead.</p>
   * <p>
   * The oj-form-layout component uses the
   * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
   * <code class="prettyprint">provide</code> property to provide its
   * user-assistance-density property to any descendent components that are
   * configured to consume it.
   * The form components and the oj-form-layout are configured to consume the
   * user-assistance-density property if it is not explicitly set.
   * For example, oj-form-layout's user-assistance-density defaults to 'efficient', so all its
   * oj-form-layout and form control descendants will have user-assistance-density='efficient' by default.
   * </p>
   * <p>
   * When using the oj-form-layout custom element inside of a VDOM application, this property will not propagate down to the child components.
   * This is because binding propagation is Knockout-based, and VDOM applications are not Knockout-based.
   * </p>
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   *
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   *
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof oj.ojFormLayout
   * @instance
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */
  /**
   * Refreshes the visual state of the component.
   *
   * @function refresh
   *
   * @expose
   * @memberof oj.ojFormLayout
   * @return {void}
   * @instance
   */

  // Slots
  // //////

  /**
   * <p>The <code class="prettyprint">&lt;oj-form-layout></code> element only accepts element children
   * in the Default slot.  Content in <code class="prettyprint">&lt;oj-form-layout></code>'s Default
   * slot will be laid out in a row/column style form layout.
   *
   * @ojchild Default
   * @memberof oj.ojFormLayout
   * @since 4.1.0
   *
   * @example <caption>Initialize <code class="prettyprint">&lt;oj-form-layout></code> with children in the
   * Default slot.</caption>
   * &lt;oj-form-layout id="AddressormLayout">
   *   &lt;oj-input-text id="firstname" label-hint="First Name" value="{{firstname}}">&lt;/oj-oj-input-text>
   *   &lt;oj-input-text id="lastname" label-hint="Last Name" value="{{lastname}}">&lt;/oj-oj-input-text>
   *   &lt;oj-input-text id="address" label-hint="Address" value="{{address}}">&lt;/oj-oj-input-text>
   * &lt;/oj-form-layout>
   */

var __oj_form_layout_metadata = 
{
  "properties": {
    "colspanWrap": {
      "type": "string",
      "enumValues": [
        "nowrap",
        "wrap"
      ]
    },
    "columns": {
      "type": "number",
      "value": 0
    },
    "direction": {
      "type": "string",
      "enumValues": [
        "column",
        "row"
      ]
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "start",
        "top"
      ]
    },
    "labelWidth": {
      "type": "string",
      "value": "33%"
    },
    "labelWrapping": {
      "type": "string",
      "enumValues": [
        "truncate",
        "wrap"
      ],
      "value": "wrap"
    },
    "maxColumns": {
      "type": "number",
      "value": 1
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "efficient"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_form_layout_metadata */
  Object.freeze(__oj_form_layout_metadata);

  // counter for the generation of unique ids.
  var _uidCounter = 0;

  /**
   * @private
   */
  const _OJ_DEFAULTS = 'oj-form-layout-option-defaults';

  /**
   * The _ojFormLayout constructor function.  This function adds a wrapper div with
   * an oj-form class.
   *
   * @constructor
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  function ojFormLayout(context) {
    var self = this;
    var element = context.element;
    var LABEL_ELEMENT_ID = '-labelled-by';
    // We need to mark every element we add so that we can remove it during a refresh/re-render.
    var BONUS_DOM_ATTR = 'data-oj-formlayout-bonus-dom';
    var BONUS_DOM_SELECTOR = '[' + BONUS_DOM_ATTR + ']';
    const _OJ_INTERNAL = 'data-oj-internal';
    const _OJ_CONTEXT = 'data-oj-context';
    const _OJ_ENABLED = 'oj-enabled';
    const _OJ_NOWRAP = 'oj-formlayout-labels-nowrap';
    const _OJ_FORM_LAYOUT = 'OJ-FORM-LAYOUT';
    var ojFormReadyResolveFunc;
    var readyResolveFunc;
    var ojForm;
    var isInitialRender = true;
    var unresolvedChildren;
    var updatePending = false;
    var calculatedColumns;

    // update labelEdge and colspanWrap based on context
    _updateDefaultFromTheme(context);

    // Our version of GCC has a bug where the second param of MutationObserver.observe must be of
    // type MutationObserverInit which isn't a real class that we can instantiate. Work around is to
    // create the MutationObserver on an alias of 'this' and call observe in a different function.
    // TODO Cleanup when we replace GCC with uglify in 5.0.0.
    /**
     * If the dom is mutated, call refresh to allow for added or deleted editable
     * value components.
     *
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    self._rootElementMutationObserver = new MutationObserver(function (mutations) {
      // if the oj-form-layout has been removed from the body element's subtree,
      // no need to remove event listeners or refresh.  Just disconnect the observer.
      // This can happen when you press apply in the cookbook demo.
      if (document.body.contains(element)) {
        // Move any added direct children to the ojForm div.
        _moveNewDirectChildrenToOjFormDiv(mutations);
        // Ignore mutations that aren't direct children of bonus dom div elements as those
        // are not generated by application program logic and the should't require
        // a refresh. Examples of mutations that we care about: an application
        // adding a new editable value element; removing an existing original
        // child element.  Example of mutations that we don't care about: dom
        // elements added or removed inside of the editable value child elements
        // or oj-label elements.
        // In theory, we shouldn't get mutaion events if we wait until a component is ready
        // but are are still seeing mutations sometimes even though the we waited on the busyContext
        // for the component. See 
        if (!_ignoreMutations(mutations)) {
          _removeEventListenersFromRemovedChildren(mutations);
          element.refresh();
        }
      } else {
        this.disconnect();
      }
    });

    // declare the resize handler for this instance.
    self._resizeHandler = _handleResize;

    this.createDOM = function () {
      element.classList.add('oj-form-layout');

      // Create wrapper div
      ojForm = document.createElement('div');
      ojForm.classList.add('oj-form');
      ojForm.setAttribute(_OJ_CONTEXT, ''); // @HTMLUpdateOK
      ojForm.setAttribute(_OJ_INTERNAL, ''); // @HTMLUpdateOK
      ojForm.setAttribute(BONUS_DOM_ATTR, ''); // @HTMLUpdateOK

      // set style
      if (element.readonly) {
        ojForm.classList.remove(_OJ_ENABLED);
      } else {
        ojForm.classList.add(_OJ_ENABLED);
      }

      // set styleclass for user-assistance-density
      const efficientStyleClass = 'oj-efficient';
      if (element.userAssistanceDensity === 'efficient') {
        ojForm.classList.add(efficientStyleClass);
      } else {
        ojForm.classList.remove(efficientStyleClass);
      }

      // wrap the children with the div
      // we use .firstChild and not .firstElementChild so that comment
      // nodes will be copied
      while (element.firstChild) {
        ojForm.appendChild(element.firstChild); // @HTMLUpdateOK reparenting child nodes
      }

      element.appendChild(ojForm); // @HTMLUpdateOK appending internally created DOM element
    };

    /**
     * In Chrome 103 - the relative/absolute positioning inside a multi-col layout is broken
     * https://bugs.chromium.org/p/chromium/issues/detail?id=1338997
     * This is to workaround this bug and make things render correctly for chromium browsers.
     * This bug will be fixed in 104 and later.
     */
    // data-oj- attributes used to identify the workaround DOM
    const _WORKAROUND_DOM_ATTR = 'data-oj-formlayout-workaround-dom';
    // Form layout can have nested oj-form-layout, so query only for the direct child
    const _WORKAROUND_DOM_SELECTOR = `:scope > [${_WORKAROUND_DOM_ATTR}]`;

    /**
     * Applies the workaround for the Chromium v103 bug
     */
    function _applyChromium103Workaround() {
      const workaroundDiv = document.createElement('div');
      workaroundDiv.style.display = 'table';
      workaroundDiv.style.visibility = 'hidden';
      workaroundDiv.setAttribute(_WORKAROUND_DOM_ATTR, ''); // @HTMLUpdateOK
      ojForm.appendChild(workaroundDiv);
    }

    /**
     * Removes the workaround for the Chromium v103 bug
     */
    function _removeChromium103Workaround() {
      const workaroundDiv = ojForm.querySelector(_WORKAROUND_DOM_SELECTOR);
      if (workaroundDiv) {
        ojForm.removeChild(workaroundDiv);
      }
    }

    /**
     * Register event listeners for resize the container DOM element.
     * @param {Element} domElem  DOM element
     * @private
     */
    function _registerResizeListener(domElem) {
      // register resize listener if needed
      if (_shouldRegisterResizeListener()) {
        DomUtils.addResizeListener(domElem, self._resizeHandler, 25, true);
      }
    }

    /**
     * We don't need a resize listener if 'columns' is positive as the oj-form-layout is not responsive.
     * Also not needed for direction = column because the browser does the work so is not needed.
     * @private
     */
    function _shouldRegisterResizeListener() {
      return element.columns < 1 && element.direction === 'row';
    }

    /**
     * Unregister event listeners for resize the container DOM element.
     * @param {Element} domElem  DOM element
     * @private
     */
    function _unregisterResizeListener(domElem) {
      if (domElem && self._resizeHandler) {
        // remove existing listener
        DomUtils.removeResizeListener(domElem, self._resizeHandler);
      }
    }

    /**
     * The resize handler.  We only pay attention to changes in the width.
     * @param {number} width the new width
     * @param {number} height the new height
     * @private
     */
    // eslint-disable-next-line no-unused-vars
    function _handleResize(width, height) {
      let newColumns = _calculateColumns();

      // If the number of calculated columns changes, we need to refresh the form layout
      if (newColumns !== calculatedColumns) {
        // When the column count changes, we need to completely re-render the oj-form-layout
        // because the components need to be shuffled around, the numbder of rows changes, etc.
        // and it's easier to just start over by throwing away all of the generated dom and
        // generate new dom in the right configuration.
        element.refresh();
      }
    }

    // Handles property changes for oj-form-layout.
    // handlePropertyChanged is an optional DefinitionalElementBridge method where if defined,
    // will be called with the property and value that changed
    // letting the component handle a partial update case. The component
    // can return true in this callback to skip a full render call to updateDOM
    // which will be done if this method returns false or undefined.

    // eslint-disable-next-line no-unused-vars
    self.handlePropertyChanged = function (property, value) {
      switch (property) {
        // if readonly, just update the styleclass and move on.
        case 'readonly': {
          if (element.readonly) {
            ojForm.classList.remove(_OJ_ENABLED);
          } else {
            ojForm.classList.add(_OJ_ENABLED);
          }
          return true;
        }
        case 'userAssistanceDensity': {
          // if ojFormLayout's userAssistanceDensity property changes,
          // update the styleclass.
          // See _childUserAssistanceDensityChanged for formlayout's responsibilities
          // when the form control's userAssistanceDensity changes.
          const efficientStyleClass = 'oj-efficient';
          if (element.userAssistanceDensity === 'efficient') {
            ojForm.classList.add(efficientStyleClass);
          } else {
            ojForm.classList.remove(efficientStyleClass);
          }
          return true;
        }
        case 'labelWrapping': {
          if (element.labelWrapping === 'truncate') {
            ojForm.classList.add(_OJ_NOWRAP);
          } else {
            ojForm.classList.remove(_OJ_NOWRAP);
          }
          return true;
        }
        default:
          return false;
      }
    };

    /**
     * The main render function.  This function gets called on initial render,
     * when oj-form-layout attributes are modified, and when mutations occur
     * (child nodes are added or deleted).  If the render is not the initial
     * render, all of the bonus dom elements are removed.  Then the bonus dom
     * elements are added (for both initial and non-initial cases).  The bonus dom
     * are the elements like oj-flex/oj-flex-item DIVs and oj-label elements that
     * get added and these are marked with "data-oj-formlayout-bonus-dom".
     *
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    this.updateDOM = function () {
      function doUpdate() {
        _notReady();

        _updateDefaultFromTheme();

        unresolvedChildren = []; // start with an empty list

        // Wait until child elements have finished upgrading before performing DOM
        // manipulations so we can access child properties, like label-hint and help-hints.
        // The new oj-form div element has a data-oj-context attribute so we can get
        // the correctly scoped busy context  for the oj-form div subtree. When custom
        // elements are reparented, they reregister their busy state if they haven't
        // finished upgrading. Also, if the oj-form itself is being rendered, wait for
        // that as well.
        var busyContext = Context.getContext(ojForm).getBusyContext();
        busyContext.whenReady().then(function () {
          var tmpFocusElem = document.activeElement;
          var needsFocusRestored = false;
          // add a busy state for the oj-form div so we don't have multiple threads
          // modifying the oj-form div at the same time.
          _ojFormNotReady();

          // we don't want the observer being called when we are making modifications to dom subtree elements.
          self._rootElementMutationObserver.disconnect();

          _unregisterResizeListener(ojForm);
          _removeChromium103Workaround();

          _updateOjFormDiv();

          if (!isInitialRender) {
            _removeAllBonusDomElements();
          }

          _addLabelsFromHints();
          _addAllFlexDivs();
          if (oj.Components) {
            // if ojs/ojcomponentcore was loaded by some component, there may be logic that depends on being notified
            // when the component gets reattched.  this might be components themselves (via NotifyAttached) or it might
            // be ResizeListeners.  the subtreeAttached code ensure that both codepaths get notifications.
            oj.Components.subtreeAttached(ojForm);
          }
          if (tmpFocusElem) {
            needsFocusRestored = DomUtils.isAncestorOrSelf(element, tmpFocusElem);
          }
          // If the current focus is inside form layout while updating the DOM, place the focus back to the element;
          if (needsFocusRestored) {
            // : Since IE11 is having different render sequence of the DOM tree, it will blur out of the focused element.
            // To avoide losing focus, we need to add setTimeout to give the broswer enough time to finish the normal sequence and then
            // set the focus back.
            setTimeout(function () {
              tmpFocusElem.focus();
            }, 0);
          }

          // we need to do this before the mutation observer is activated because this can add divs which
          // would fire the mutation observer and send it into a refresh->mutation loop.
          _registerResizeListener(ojForm);
          _applyChromium103Workaround();

          // We are done making modifications to dom subtree elements so we should start paying attention
          // to mutations of the oj-form DIV subtree.  The mutations we care about are added elements and
          // removed elements. For the added elements, we should only see them added next to an existing
          // original child element, which is always a child of a bonus dom DIV element, so we ignore all
          // other added elements. For removed elements, we only care about removed original children.
          // All other removed elements are ignored by the observer.
          //
          // We also need to track custom element upgrade status. We do this by observing attribute
          // mutations and if the 'class' attribute gets "oj-complete" added, we know the custom element
          // is finished upgrading.
          self._rootElementMutationObserver.observe(element, {
            childList: true,
            subtree: true,
            attributes: true
          });

          // During debugging a different bug, I noticed on IE11 that sometimes this wasn't updated
          // when it obviously should have been (i.e. we reentered this function after the initial time
          // and isInitialRender was still true), so moving this setting before marking the promiss ready
          if (isInitialRender) {
            isInitialRender = false;
          }

          _ojFormMakeReady();
          _makeReady();
        });
      }

      // Dynamic form could set the busy state on the oj-form-layout element
      // when it's inserting children to oj-form-layout.  In this case we want
      // to delay the update until the busy state is clear.
      // The only other time the oj-form-layout can be busy when updateDOM is called is
      // during initial render, when busy state is set by DefinitionalElementBridge.
      // In that case we don't want to delay the update.
      // No need to do anything if an update is already pending.
      if (!updatePending) {
        var delayUpdate;
        var outerBusyContext;
        if (!isInitialRender && element.hasAttribute(_OJ_CONTEXT)) {
          outerBusyContext = Context.getContext(element).getBusyContext();
          delayUpdate = !outerBusyContext.isReady();
        } else {
          delayUpdate = false;
        }
        if (delayUpdate) {
          updatePending = true;
          outerBusyContext.whenReady().then(function () {
            updatePending = false;
            doUpdate();
          });
        } else {
          doUpdate();
        }
      }
    };

    /*
     * Called to set the component busy during rendering
     */
    function _notReady() {
      if (!readyResolveFunc) {
        var busyContext = Context.getContext(element).getBusyContext();
        var options = {
          description:
            "The oj-form-layout component with id = '" + element.id + "' is being rendered."
        };
        readyResolveFunc = busyContext.addBusyState(options);
      }
    }

    /*
     * Called to set the component not busy after rendering is finished
     */
    function _makeReady() {
      if (readyResolveFunc) {
        readyResolveFunc();
        readyResolveFunc = null;
      }
    }

    /*
     * Called to make the oj-form div busy during rendering
     */
    function _ojFormNotReady() {
      if (!ojFormReadyResolveFunc) {
        var busyContext = Context.getContext(ojForm).getBusyContext();
        var options = {
          description:
            "The oj-form div for oj-form-layout component with id = '" +
            element.id +
            "' is being rendered."
        };
        ojFormReadyResolveFunc = busyContext.addBusyState(options);
      }
    }

    /*
     * Called to make the oj-form div not busy after rendering is finished
     */
    function _ojFormMakeReady() {
      if (ojFormReadyResolveFunc) {
        ojFormReadyResolveFunc();
        ojFormReadyResolveFunc = null;
      }
    }

    /**
     * Updates the oj-form div with the appropriate styles and column count.
     *
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _updateOjFormDiv() {
      var maxCols;

      if (element.labelEdge === 'start') {
        // If labelWidth is set to 0 (including "0", "0px", "0%", etc.), we don't need the
        // oj-form-cols-labels-inline class because the labels are not visible.
        var width = parseInt(element.labelWidth, 10);
        if (isNaN(width) || width > 0) {
          ojForm.classList.add('oj-form-cols-labels-inline');
        }
        element.classList.add('oj-formlayout-labels-inline');
        ojForm.classList.remove('oj-form-cols');
      } else {
        ojForm.classList.add('oj-form-cols');
        ojForm.classList.remove('oj-form-cols-labels-inline');
        element.classList.remove('oj-formlayout-labels-inline');
      }

      if (element.labelWrapping === 'truncate') {
        ojForm.classList.add(_OJ_NOWRAP);
      } else {
        ojForm.classList.remove(_OJ_NOWRAP);
      }

      // Compute the actual number of columns and save them for later.  This depends on the style
      // classes set above, and is used by the code below, so it has to happen here.
      let oldColumns = calculatedColumns;
      calculatedColumns = _calculateColumns();
      // Any time we recalculate the number of columns, we need to adjust this style class.
      if (calculatedColumns !== oldColumns) {
        var newClass = 'oj-formlayout-max-cols-' + calculatedColumns;
        var cName = element.className;
        if (cName.indexOf('oj-formlayout-max-cols-') !== -1) {
          // This will replace the old class name with the new one
          element.className = cName.replace(/oj-formlayout-max-cols-[\d+]/, newClass);
        } else {
          element.classList.add(newClass); // First time, just add it.
        }
      }

      // When direction === "row", we need to set the columns to 1, as we use the
      // oj-flex and oj-flex-item divs to control the number of columns.
      // Also, we need to add the 'oj-formlayout-form-across' class to get the buffer between the
      // label/value pairs.
      if (element.direction === 'row') {
        maxCols = 1;
        ojForm.classList.add('oj-formlayout-form-across');
      } else {
        maxCols = calculatedColumns;
        ojForm.classList.remove('oj-formlayout-form-across');
      }

      ojForm.style.columnCount = maxCols;
      ojForm.style.webkitColumnCount = maxCols;
      ojForm.style.MozColumnCount = maxCols;
    }

    /**
     * This method goes through and removes all of the bonus dom elements, those that
     * have been marked with the 'data-oj-formlayout-bonus-dom' attribute. For oj-label bonus
     * dom elements, we just remove the element as we don't need to preserve the children.
     * For the oj-flex and oj-flex-item DIVs, we need to preserve the children as they
     * contain the original child elements that we don't want removed.
     *
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _removeAllBonusDomElements() {
      var bonusDomElems = ojForm.querySelectorAll(BONUS_DOM_SELECTOR);
      var length = bonusDomElems.length;

      for (var i = 0; i < length; ++i) {
        var bonusDomElem = bonusDomElems[i];

        // don't remove bonus dom elems owned by child oj-form-layouts
        if (_isNodeOfThisFormLayout(bonusDomElem)) {
          if (bonusDomElem.tagName === 'OJ-LABEL') {
            // Before we remove the oj-label, set the for to "" to trigger the code to
            // unlink the oj-label from its form component
            bonusDomElem.for = '';
            // For the oj-label elements we create, we can just remove them safely
            // as none of their children are the original child elements we are preserving
            bonusDomElem.parentElement.removeChild(bonusDomElem);
          } else {
            // for all other elements, remove the element preserving the children
            _removeElementAndReparentChildren(bonusDomElem);
          }
        }
      }
    }

    /**
     * For each editable value child with a label hint, add an oj-label.
     *
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _addLabelsFromHints() {
      var child = ojForm.firstElementChild;
      var childCnt = 0;
      var directionIsColumn = element.direction === 'column';

      // for all of the direct children, add a label for any child element supports "labelHint"
      while (child) {
        var tagName = child.tagName.toLowerCase();
        // check for custom element
        if (tagName.indexOf('-') !== -1) {
          if (tagName === 'oj-label') {
            // if we find an oj-label component, then skip it and the next sibling element.
            // If there is no next sibling element, throw an error.  We don't need to know
            // if they are completely upgraded as we are excepting all element types for the child
            // that follows an oj-label.  The assumption is that the app developer has correctly
            // associated the oj-label with and element of some kind.
            var label = child;
            child = child.nextElementSibling; // move to the next child element

            // an oj-label should always be followed by an element
            if (!child) {
              _ensureUniqueId(element);
              _ensureUniqueId(label);

              // make the component ready before throwing an error so the page won't hang
              _ojFormMakeReady();
              _makeReady();

              throw new Error(
                "oj-form-layout component with id='" +
                  element.id +
                  "' has an oj-label child element with id='" +
                  label.id +
                  "' but has no next sibling element that it is associated with."
              );
            }
          } else if (tagName === 'oj-label-value') {
            // if were are being re-rendered, then we need to refresh any oj-label-value children.
            if (!isInitialRender) {
              child.refresh();
            }
          } else if (child.classList.contains('oj-complete')) {
            _addLabelFromHint(child);
          } else {
            // we need to tell this child if it needs an oj-flex div created for it.
            if (directionIsColumn || childCnt % calculatedColumns === 0) {
              child.setAttribute('data-oj-needs-oj-flex-div', ''); // @HTMLUpdateOK
            }
            // This custom element child hasn't been upgraded so add it to the unresolved children
            unresolvedChildren.push(child);
          }
        }

        childCnt += 1;
        child = child.nextElementSibling; // move to the next child element
      }
    }

    /**
     * Return true if the label is handled by the child element; false otherwise.
     */
    function _isLabelByChild(child) {
      return element.labelEdge === 'inside' || child.labelEdge !== 'provided';
    }

    /**
     * For one child, add an oj-label if it supports label-hint.
     *
     * @param {EventTarget} child The element that may need an oj-label created
     * @memberof oj.ojFormLayout
     * @returns {Element|null} the oj-label element or null if no label was created
     * @instance
     * @private
     */
    function _addLabelFromHint(child) {
      var ojLabel = null;

      if (_isLabelByChild(child)) {
        // if the label is created by the component we just return
        return ojLabel;
      }

      if (child instanceof Element && 'labelHint' in child && child.labelHint !== '') {
        _ensureUniqueId(child);
        ojLabel = _createOjLabelAndInitialize(child);

        // the label should preceed the input element it is associated with
        child.parentElement.insertBefore(ojLabel, child); // @HTMLUpdateOK insert oj-label containing trusted content.

        // JET's custom element's property change events,
        // e.g., labelHintChanged,
        // do not bubble and component events do bubble.
        // Therefore, we can't listen on the
        // oj-form-layout for child property change events.
        // We add them to the component themselves.
        _addChildEventListeners(child);
      }

      return ojLabel;
    }

    /**
     * create the oj-label and initialize it
     *
     * @param {Element} editableElem the element associated with the oj-label element
     * @returns {Element} the oj-label element
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _createOjLabelAndInitialize(editableElem) {
      let evLabelledBy = editableElem.labelledBy;
      if (evLabelledBy) {
        // catch the condition where the app dev removed
        // oj-label in favor of label-hint but forgot to remove labelled-by.
        let labelledByLabel = document.getElementById(evLabelledBy);
        if (labelledByLabel) {
          ojlogger.error(
            'The oj-form-layout descendent component with id ' +
              editableElem.id +
              ' has both label-hint and labelled-by. Remove labelled-by="' +
              evLabelledBy +
              '" since no matching element was found in the document, ' +
              'and a label will be created using the label-hint.'
          );
        }
      }
      var ojLabel = document.createElement('oj-label');
      ojLabel.setAttribute(BONUS_DOM_ATTR, ''); // @HTMLUpdateOK
      ojLabel.setAttribute(_OJ_INTERNAL, ''); // @HTMLUpdateOK

      // programmatically created elements not managed by a binding stratagy like knockout
      // needs this attribute to signal the component should be created.
      ojLabel.setAttribute('data-oj-binding-provider', 'none');
      ojLabel.setAttribute(_OJ_CONTEXT, ''); // @HTMLUpdateOK

      // Note: the hint might be null, but that is fine, we still want a label for this case to hang the required and help icons off of
      // and allow for programatic changes to label-hint, help-hints, required.
      var span = document.createElement('span');
      span.id = editableElem.id + '|hint';
      span.textContent = editableElem.labelHint;

      // For Alta theme, we ignore userAssistanceDensity and always show help on label
      if (_showUserAssistanceNotInline(editableElem)) {
        _updateLabelHelpAndShowRequired(editableElem, ojLabel);
      }

      ojLabel.appendChild(span); // @HTMLUpdateOK append span containing trusted content.

      _linkLabelAndElement(ojLabel, editableElem);

      return ojLabel;
    }

    /**
     * Link the oj-label and editable component with 'for'/'id.
     * As of v7.0 all form components have 'labelledBy' attribute. If oj-label has 'for' on it,
     * the oj-label will set labelledBy on the form component.
     *
     * @param {Element} _ojLabel
     * @param {Element} _editableElem element to link with the oj-label
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _linkLabelAndElement(_ojLabel, _editableElem) {
      var ojLabel = _ojLabel;
      var editableElem = _editableElem;
      ojLabel.id = editableElem.id + LABEL_ELEMENT_ID;
      ojLabel.setAttribute('for', editableElem.id);
    }

    /**
     * listener for labelHintChanged events.
     *
     * @param {Event} event the change event object
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _childLabelHintChanged(event) {
      var editable = event.target;
      // Get the hint span and update its innerText
      var span = document.getElementById(editable.id + '|hint');

      if (span) {
        span.textContent = event.detail.value;
      }
    }

    /**
     * listener for helpHintsChanged events.
     *
     * @param {Event} event the change event object
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _childHelpHintsChanged(event) {
      var editable = event.target;
      var ojLabel = _getOjLabelForChildElement(editable);
      let help = event.detail.value;

      if (ojLabel) {
        let showHelpOnLabel = _showRequiredHelpOnLabel(editable);
        if (showHelpOnLabel) {
          ojLabel.help = help;
        }
      }
    }

    /**
     * listener for requiredChanged events.
     *
     * @param {Event} event the change event object
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _childRequiredChanged(event) {
      var editable = event.target;
      var ojLabel = _getOjLabelForChildElement(editable);
      if (ojLabel) {
        let required = event.detail.value;
        // need to see if we should show required on the label.
        // For example, in 'inline' mode, required is not shown on the label.
        let showRequiredOnLabel;
        if (required) {
          showRequiredOnLabel = _showRequiredHelpOnLabel(editable);
        } else {
          showRequiredOnLabel = false;
        }
        ojLabel.showRequired = showRequiredOnLabel;
      }
    }

    /**
     * listener for userAssistanceDensityChanged events on the form controls.
     * When userAssistanceDensity changes on a form control, ojformlayout needs
     * to update the form control's label it created (if any).
     * For example, when 'compact', the label has the required icon and
     * the help definition/source icon, otherwise it does not.
     *
     * @param {Event} event the change event object
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _childUserAssistanceDensityChanged(event) {
      let eventTarget = event.target;
      let userAssistanceValue = event.detail.value; // compact or not.
      let userAssistancePrevious = event.detail.previousValue;

      // In this callback, we only care about if userAssistanceDensity
      // changed from or changed to 'compact'. So, for example,
      // if it is going from 'efficient' to 'reflow', then we can return
      if (userAssistanceValue !== 'compact' && userAssistancePrevious !== 'compact') {
        return;
      }

      let ojLabel = _getOjLabelForChildElement(eventTarget);
      // For Alta theme, we ignore userAssistanceDensity and always show help on label
      if (_showUserAssistanceNotInline(eventTarget)) {
        _updateLabelHelpAndShowRequired(eventTarget, ojLabel);
      } else {
        // clear out label because if it shown inline
        if (eventTarget.required) {
          ojLabel.showRequired = false;
        }
        const helpHints = eventTarget.helpHints;
        if (helpHints) {
          if (helpHints.definition || helpHints.source) {
            ojLabel.help = { definition: null, source: null };
          }
        }
      }
    }

    /*
     * Returns true if required is not shown inline, meaning it needs to be on the label.
     * @param {Element} editable
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _showRequiredHelpOnLabel(editable) {
      let defaultOptions = ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults');
      // this will return 'use' or 'ignore'. This tells us whether we should use the
      // user-assistance-density attribute or ignore it. If we ignore it, we will
      // use the displayOptions attribute.
      var useUserAssistanceOption = defaultOptions.useUserAssistanceOptionDefault;

      let displayMethod =
        useUserAssistanceOption === 'use' ? editable.userAssistanceDensity : 'displayOptions';
      return displayMethod === 'compact' || displayMethod === 'displayOptions';
    }

    /**
     * Components with label-hint and label-edge of none or inside create
     * their own labels, and therefore these event listeners are not created here,
     * but instead event listeners are in the BaseInsideLabelStrategy.
     * Only when the oj-form-layout creates the label
     * (label-edge='top' on oj-form-layout and 'provided' on component)
     * do we listen here.
     * If the child element doesn't have listeners yet, add them.
     * Only the component events bubble and not the property change events,
     * so it doesn't work to listen on the oj-form-layout for
     * these property change events. Instead we
     * put them on the child component themselves, and we share the listener.
     *
     * @param {Element} child
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _addChildEventListeners(child) {
      child.addEventListener('labelHintChanged', _childLabelHintChanged);
      child.addEventListener('helpHintsChanged', _childHelpHintsChanged);
      child.addEventListener('requiredChanged', _childRequiredChanged);
      child.addEventListener('userAssistanceDensityChanged', _childUserAssistanceDensityChanged);
    }

    /**
     * This function moves any new direct children under the ojForm node, which is where the
     * oj-form-layout component expects these children to be.
     * @param {Array.<MutationRecord>} mutations the mustation list passed in to the mutation observer function
     * @returns {undefined}
     */
    function _moveNewDirectChildrenToOjFormDiv(mutations) {
      var mutationsLength = mutations.length;

      for (var i = 0; i < mutationsLength; i++) {
        var mutation = mutations[i];

        if (mutation.type === 'childList') {
          var addedNodesLength = mutation.addedNodes.length;

          for (var j = 0; j < addedNodesLength; j++) {
            var child = mutation.addedNodes[j];

            // check to see if it was added as a direct child
            if (child.parentNode === element) {
              ojForm.appendChild(child);
            }
          }
        }
      }
    }

    /**
     * if the removed child nodes have event listeners we've added, remove them
     * Only the component events bubble and not the property change events,
     * so it doesn't work to listen on the oj-form-layout
     * for these property change events. We add/remove the listener from the
     * child JET component itself.
     *
     * @param {Array.<MutationRecord>} mutations the array of MutationRecords from the observer
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _removeEventListenersFromRemovedChildren(mutations) {
      var mutationsLength = mutations.length;

      for (var i = 0; i < mutationsLength; i++) {
        var mutation = mutations[i];

        if (mutation.type === 'childList') {
          var removedNodesLength = mutation.removedNodes.length;

          for (var j = 0; j < removedNodesLength; j++) {
            var child = mutation.removedNodes[j];

            if (child.nodeType === 1) {
              child.removeEventListener('labelHintChanged', _childLabelHintChanged);
              child.removeEventListener('helpHintsChanged', _childHelpHintsChanged);
              child.removeEventListener('requiredChanged', _childRequiredChanged);
              child.removeEventListener(
                'userAssistanceDensityChanged',
                _childUserAssistanceDensityChanged
              );
            }
          }
        }
      }
    }

    /**
     * Return the oj-label element for a component. This may be the oj-label with a for attribute
     * for the component, or may be the oj-label that this component's labelled-by points to.
     *
     * @param {EventTarget} child The child element whose label we want to return
     * @memberof oj.ojFormLayout
     * @instance
     * @return {Element} The oj-label element.
     * @private
     */
    function _getOjLabelForChildElement(child) {
      var ojLabel;
      // for editable value components that have a labelled-by attribute, we need to
      // retrieve the oj-label by the labelledBy ID. Otherwise
      // we query for it by the for attribute.
      if ('labelledBy' in child) {
        // For some reason, element is undefined in this case, so using document
        ojLabel = document.getElementById(child.labelledBy);
      } else {
        ojLabel = element.querySelector('oj-label[for="' + child.id + '"]');
      }

      return ojLabel;
    }

    /**
     * Update the help and showRequired from the form component's helpHints and
     * required attributes.  This needs to be done after the label is no longer
     * busy.
     *
     * @param {Element} comp
     * @param {Element} _ojLabel
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _updateLabelHelpAndShowRequired(comp, _ojLabel) {
      var ojLabel = _ojLabel;
      var helpHints = comp.helpHints;

      if (helpHints) {
        // if either of these has a value, set the help property of ojLabel.
        // This is a work around for the fact that oj-label doesn't correctly
        // handle the default value for help.definition or help.source (i.e. when
        // the value is "").  If we have the default value, null or undefined
        // for both of them, we don't set the help attribute on the oj-label.
        if (helpHints.definition || helpHints.source) {
          ojLabel.help = helpHints;
        }
      }
      let required = comp.required;
      let showRequiredOnLabel;
      if (required) {
        showRequiredOnLabel = _showRequiredHelpOnLabel(comp);
      } else {
        showRequiredOnLabel = false;
      }
      ojLabel.showRequired = showRequiredOnLabel;
    }

    // Determine whether we should skip non-element nodes
    function _skipNonElementNodes() {
      // If direction is column or max-columns is 1, we don't need to move non-element nodes
      // because we are wrapping every element in its own oj-flex div, so the order
      // of the nodes will always remain the same.
      return element.direction === 'column' || calculatedColumns === 1;
    }

    // Move all non-element nodes preceding elem into ojFlex
    function _movePrecedingNonElementNodes(ojFlex, elem) {
      if (_skipNonElementNodes()) {
        return;
      }

      var firstNode;

      // Find the first of all non-element nodes preceding elem
      var sibling = elem.previousSibling;
      while (sibling && sibling.nodeType !== 1) {
        firstNode = sibling;
        sibling = sibling.previousSibling;
      }

      // Move all the non-element nodes into ojFlex in order
      while (firstNode && firstNode !== elem) {
        sibling = firstNode.nextSibling;
        ojFlex.appendChild(firstNode);
        firstNode = sibling;
      }
    }

    // Move all non-element nodes succeeding ojFlex into ojFlex
    // Stop if an oj-bind-* comment node is encountered.
    function _moveSucceedingNonElementNodes(ojFlex) {
      if (_skipNonElementNodes()) {
        return;
      }

      while (ojFlex.nextSibling) {
        var sibling = ojFlex.nextSibling;
        if (sibling.nodeType === 1) {
          // Stop if we get to an element
          break;
        } else if (sibling.nodeType === 8) {
          var str = sibling.textContent.trim();
          // Stop if we get to a start comment node for oj-bind-*
          // It needs to stay with the next element
          if (str.indexOf('oj-bind-') === 0) {
            break;
          }
        }
        // Move the node into ojFlex
        ojFlex.appendChild(sibling);
      }
    }

    // Create a new flex div for a row
    function _createRowDiv(currentRow, insertBeforeElem) {
      // If we are ending a row, move any succeeding non-element nodes into it
      // because there may be end comment node for the last element.
      if (currentRow) {
        _moveSucceedingNonElementNodes(currentRow);
      }

      var newRow = _createDivElement('oj-flex');
      insertBeforeElem.parentElement.insertBefore(newRow, insertBeforeElem); // @HTMLUpdateOK insert div containing trusted content.

      // After starting a new row, move any preceding non-element nodes into it
      // because there may be start comment nodes for the next element.
      _movePrecedingNonElementNodes(newRow, newRow);

      return newRow;
    }

    /**
     * Add an oj-flex div for each label/input pair and add an oj-flex-item div
     * for each label and each input.
     *
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _addAllFlexDivs() {
      var childArray = []; // copy array
      var arrayLength = ojForm.children.length;
      var directionIsColumn = element.direction === 'column';
      var j = 0;
      var pairCnt = 0; // counter of label/element count

      _appendChildrenToArray(ojForm.children, childArray);

      var currentRow;
      var curCol = 0;
      var colspan;
      var directionColspanError = false;
      var needsFullWidthClass = false;

      // each iteration should process a label/input pair
      while (j < arrayLength) {
        var label = childArray[j];
        colspan = 1;

        if (directionIsColumn || pairCnt % calculatedColumns === 0) {
          currentRow = _createRowDiv(currentRow, label);
        } // This will be the oj-flex div for a row

        // if the current child element is on the unresolvedChildren list, skip it
        if (unresolvedChildren.indexOf(label) === -1) {
          var tagName = label.tagName.toLowerCase();
          if (tagName === 'oj-label') {
            j += 1; // skip to the next element
            var elem = childArray[j];

            // for direction === "row", we only render the oj-flex div once per row.
            _addFlexDivs(label, elem, currentRow);
          } else if ('labelHint' in label && _isLabelByChild(label)) {
            // In case of label edge = inside or top generated by component,
            // Form layout does not render the label.
            // But we want all the flow to be similar to what it does if component was rendering a label
            _addFlexDivs(label, null, currentRow);
          } else {
            // handle the non oj-label child, which includes oj-label-value
            // if the child element supports colspan, we need to calculate that actual
            // colspan based on the available columns left in this row.
            // Issue a warning if colspan is used, but direction is not set to row
            if ('colspan' in label && label.colspan > 1) {
              if (directionIsColumn) {
                // We only need to issue this error once
                if (!directionColspanError) {
                  ojlogger.error('Colspan attribute is ignored unless direction is set to "row"');
                  directionColspanError = true;
                }
              } else {
                var availableCols = calculatedColumns - curCol;
                // force integer colspan values
                colspan = Math.floor(label.colspan);
                if (element.colspanWrap === 'wrap' && availableCols < colspan && curCol > 0) {
                  // If colspanWrap is 'wrap' and there isn't enough column left to satisfy colspan,
                  // then just add empty flex items to take up remaining columns and adjust the counters.
                  _addMissingFlexItems(currentRow, pairCnt);
                  pairCnt += availableCols;
                  colspan = Math.min(colspan, calculatedColumns);

                  // Start a new row
                  currentRow = _createRowDiv(currentRow, label);
                } else {
                  // don't exceed availableCols
                  colspan = Math.min(colspan, availableCols);
                }

                if (!needsFullWidthClass && calculatedColumns > 1) {
                  needsFullWidthClass = true;
                }
              }
            }

            _addFlexDivs(label, null, currentRow, colspan);
          }
        }

        pairCnt += colspan;

        // we want to add a gutter div as long as we aren't at the end of the row
        if (!directionIsColumn && pairCnt % calculatedColumns !== 0) {
          _addColumnGutterDiv(currentRow);
        }

        curCol = pairCnt % calculatedColumns;
        j += 1;
      }

      // if we need the full width class, put it on the ojForm element so that if this class was
      // specified on the oj-form-layout, we don't accidentally remove it.
      if (needsFullWidthClass && !directionIsColumn) {
        ojForm.classList.add('oj-form-control-full-width');
      } else {
        ojForm.classList.remove('oj-form-control-full-width');
      }

      _addMissingFlexItems(currentRow, pairCnt);
    }

    // This function returns the actual number of columns the oj-form-layout should be
    // using.  Currently, this only applies to direction = 'row', as direction = column
    // responsive layout is handled by the browser
    function _calculateColumns() {
      let calculatedCols = element.maxColumns;
      const cols = element.columns;

      // if columns is positive, then a value was specified and we use that value
      // as absolute, rather than calculating the number of columns
      // also, we add a style class that is used to remove the column-width
      // of the oj-form div so that the browser doesn't change the number of
      // columns.
      if (cols > 0) {
        calculatedCols = cols;
        element.classList.add('oj-form-layout-no-min-column-width');
      } else {
        element.classList.remove('oj-form-layout-no-min-column-width');

        // adjust if we are in row direction.  For column direction, the browser
        // will already automatically adjust the number of displayed columns based
        // on the column-width specified.
        // TODO: should we be consistent and set the computed columns for direction
        // "column" for consistency?

        if (element.direction === 'row' && !_isIE11()) {
          // get the column width specified in the theme
          let colWidth = parseFloat(window.getComputedStyle(ojForm).columnWidth);

          // if there is no column-width, we just use max-columns
          if (!isNaN(colWidth)) {
            // get the total width of the parent container
            let totalWidth = parseFloat(window.getComputedStyle(element.parentElement).width);
            // Determine the number of columns.  This should be at least 1.
            let computedMaxCols = Math.max(Math.floor(totalWidth / colWidth), 1);

            // We can't fit the number of columns in calculatedCols, need to adjust.
            if (computedMaxCols < calculatedCols) {
              calculatedCols = computedMaxCols;
            }
          }
        }
      }

      return calculatedCols;
    }

    // The elem passed in is the elem that will be that child element for this flex item that we
    // are calculation the width for.
    function _getFullFlexItemWidth(elem, availableCols) {
      var colspan = 1;
      // For direction === 'column', we want the width to be 100%.  For 'row', we want it to be
      // the 100% divided by the number of columns.
      if (element.direction === 'column') {
        return '100%';
      }

      // If elem has a colspan property, then
      if (elem && 'colspan' in elem && elem.colspan) {
        colspan = Math.min(Math.floor(elem.colspan), availableCols); /* force integer colspan values,
                                                                        don't exceed availableCols */
      }

      let columnGap = ojthemeutils.parseJSONFromFontFamily(_OJ_DEFAULTS).columnGap;

      // TODO: remove this IE specific hack that I had to put in here because IE's rounding errors cause the resulting
      // width to be just a tad to long and was causing the last column to wrap.  This minor work around fixes that.
      let fullWidth =
        'calc(((100% / ' +
        calculatedColumns +
        ') - ((' +
        columnGap +
        ' * (' +
        (calculatedColumns - 1) +
        ') / ' +
        calculatedColumns +
        '))' +
        (_isIE11() ? ' - 0.1px' : '') +
        ')';

      // We only need to append this when we are spanning more than one column.
      if (colspan > 1) {
        fullWidth += ' * ' + colspan + ' + (' + columnGap + ' * ' + (colspan - 1) + ')';
      }

      // add the closing paren
      fullWidth += ')';

      return fullWidth;
    }

    function _addEmptyFlexItem(flexContainer, width) {
      var flexItem = _createDivElement('oj-flex-item');

      //  - IE11 doesn't allow calc() expressions in 'style.flex' so we have to specify
      // the longhand versions just in case the slotWidth is specified as a calc() expression
      flexItem.style.flexGrow = '0';
      flexItem.style.flexShrink = '1';
      flexItem.style.flexBasis = width;
      flexItem.style.width = width;
      flexItem.style.maxWidth = width;

      flexContainer.appendChild(flexItem);
      return flexItem;
    }

    function _addMissingFlexItems(flexContainer, count) {
      var last = count % calculatedColumns;
      var flexItemWidth = _getFullFlexItemWidth();

      if (element.direction !== 'column' && flexContainer && last > 0) {
        for (var i = last; i < calculatedColumns; i++) {
          // add a column gutter div for every missing column except the first.
          if (i !== last) {
            _addColumnGutterDiv(flexContainer);
          }
          _addEmptyFlexItem(flexContainer, flexItemWidth);
        }
      }
    }

    function _addColumnGutterDiv(flexContainer) {
      var gutterDiv = _createDivElement('oj-formlayout-column-gutter');
      flexContainer.appendChild(gutterDiv);
    }

    /**
     * Add an oj-flex-item div for each label and each input.
     *
     * @param {Object} labelOrElem when there is an explicit oj-label/component pair, it is the <oj-label>. Else it is the component.
     * @param {Element} elem when there is an explicit oj-label/component pair, it is the component, else it is null.
     * @param {Element} ojFlex the oj-flex div
     * @param {number} colspan
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _addFlexDivs(labelOrElem, elem, ojFlex, colspan) {
      var slotWidth = _getFullFlexItemWidth(labelOrElem, colspan);

      _movePrecedingNonElementNodes(ojFlex, labelOrElem);

      var elementOjFlexItem = _createDivElement('oj-flex-item');
      ojFlex.appendChild(elementOjFlexItem); // @HTMLUpdateOK append div containing trusted content.
      elementOjFlexItem.appendChild(labelOrElem); // @HTMLUpdateOK append oj-label containing trusted content.

      // create the component flex-item and append the element as a child
      if (elem) {
        // Set the flex style of the value flex item.
        // Set a flex-grow factor of 1 and a flex-basis of 0 so that all "value" flex items share the
        // remaining space left over by "label" flex items equally.
        //  - IE11 doesn't allow calc() expressions in 'style.flex' so we have to specify
        // the longhand versions just in case the slotWidth is specified as a calc() expression
        elementOjFlexItem.style.flexGrow = '1';
        elementOjFlexItem.style.flexShrink = '1';
        elementOjFlexItem.style.flexBasis = slotWidth;
        elementOjFlexItem.style.width = slotWidth;
        elementOjFlexItem.style.maxWidth = slotWidth;

        if (elem.tagName === _OJ_FORM_LAYOUT) {
          // For the nested form layout case, we need to have a way to apply styles to the
          // flex item element that is the parent of the oj-form-layout so that we can
          // make padding adjustments, etc.
          elementOjFlexItem.classList.add('oj-formlayout-nested-formlayout');
        }

        // If labelEdge is 'start', then we need to set the flex item to be display flex and set
        // the appropriate widths on the child wrapping divs
        if (element.labelEdge === 'start') {
          elementOjFlexItem.style.display = 'flex';
          // create wrapper divs for the label and elem so we can add flex css for the label.
          let labelWrappingDiv = _createDivElement('oj-formlayout-inline-label');
          let elemWrappingDiv = _createDivElement('oj-formlayout-inline-value');

          labelWrappingDiv.style.flexGrow = '0';
          labelWrappingDiv.style.flexShrink = '0';
          labelWrappingDiv.style.flexBasis = element.labelWidth;
          labelWrappingDiv.style.width = element.labelWidth;
          labelWrappingDiv.style.maxWidth = element.labelWidth;
          labelWrappingDiv.appendChild(labelOrElem); // @HTMLUpdateOK append oj-label containing trusted content.
          elementOjFlexItem.appendChild(labelWrappingDiv); // @HTMLUpdateOK append oj-label containing trusted content.
          elemWrappingDiv.style.flexGrow = '1';
          elemWrappingDiv.style.flexShrink = '1';
          elemWrappingDiv.style.flexBasis = 'calc(100% - ' + element.labelWidth + ')';
          elemWrappingDiv.style.width = elemWrappingDiv.style.flexBasis;
          elemWrappingDiv.style.maxWidth = elemWrappingDiv.style.flexBasis;
          elemWrappingDiv.appendChild(elem); // @HTMLUpdateOK append oj-label containing trusted content.
          elementOjFlexItem.appendChild(elemWrappingDiv); // @HTMLUpdateOK append oj-label containing trusted content.
        } else {
          // otherwise, we just need to append the elem to the flex item div
          elementOjFlexItem.appendChild(elem); // @HTMLUpdateOK append element containing trusted content.
        }
      } else if ('labelHint' in labelOrElem && _isLabelByChild(labelOrElem)) {
        elementOjFlexItem.style.flexGrow = '1';
        elementOjFlexItem.style.flexShrink = '1';
        elementOjFlexItem.style.flexBasis = slotWidth;
        elementOjFlexItem.style.width = slotWidth;
        elementOjFlexItem.style.maxWidth = slotWidth;
        elementOjFlexItem.appendChild(labelOrElem); // @HTMLUpdateOK append oj-label containing trusted content.
      } else {
        elementOjFlexItem.appendChild(labelOrElem); // @HTMLUpdateOK append oj-label containing trusted content.
        // this is actually the element flex item in this case
        //  - IE11 doesn't allow calc() expressions in 'style.flex' so we have to specify
        // the longhand versions just in case the slotWidth is specified as a calc() expression
        elementOjFlexItem.style.flexGrow = '1';
        elementOjFlexItem.style.flexShrink = '1';
        elementOjFlexItem.style.flexBasis = slotWidth;
        elementOjFlexItem.style.width = slotWidth;
        elementOjFlexItem.style.maxWidth = slotWidth;
        // We need this for both row and column direction so that labels will
        // truncate correctly.
        elementOjFlexItem.classList.add('oj-formlayout-no-label-flex-item'); // This is actually the element
        // we need to tell the oj-label-value child how many actual columns are being spanned.
        if (labelOrElem.tagName === 'OJ-LABEL-VALUE') {
          // We need to pass the columnGutter down to the oj-label-value
          let columnGap = ojthemeutils.parseJSONFromFontFamily(_OJ_DEFAULTS).columnGap;

          elementOjFlexItem.classList.add('oj-formlayout-nested-labelvalue'); // This is actually the element
          labelOrElem.setAttribute('data-oj-colspan', colspan);
          labelOrElem.setAttribute('data-oj-column-gap', columnGap);
          labelOrElem.refresh();
        } else if (labelOrElem.tagName === _OJ_FORM_LAYOUT) {
          // For the nested form layout case, we need to have a way to apply styles to the
          // flex item element that is the parent of the oj-form-layout so that we can
          // make padding adjustments, etc.
          elementOjFlexItem.classList.add('oj-formlayout-nested-formlayout');
        }
      }

      _moveSucceedingNonElementNodes(ojFlex);
    }

    /**
     * Append a children list to an array.
     *
     * @param {NodeList} children the child element list to copy
     * @param {Array.<Element>} _childArray the array to copy to
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _appendChildrenToArray(children, _childArray) {
      var childArray = _childArray;
      for (var i = children.length - 1; i >= 0; i--) {
        childArray[i] = children[i];
      }
    }

    /**
     * Create a div element and initialize it.
     *
     * @param {string} className the style class name of the div
     * @returns {Element} the created div element
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _createDivElement(className) {
      var div = document.createElement('div');
      div.setAttribute(BONUS_DOM_ATTR, ''); // @HTMLUpdateOK
      div.setAttribute(_OJ_INTERNAL, ''); // @HTMLUpdateOK
      div.classList.add(className);
      return div;
    }

    /**
     * The target element of a mutation should be a DIV with the bonus dom attribute
     * set on it.  Otherwise ignore the mutations.  We never have to worry about bonus
     * dom being inserted or removed.  The only time bonus dom elements are added
     * or removed, the mutation observer is disconnected.  The application developer
     * should never manipulate generated dom elements.  What this is checking for
     * is if there are any nodes being added or removed from our bonus dom divs while
     * the observer is active.  Specific examples would be adding a new
     * oj-input-text element, or removing an existing editable value element. These
     * should always be add to, or removed from one of the bonus dom DIV elements.
     * Any set of mutations that doesn't contain at least one node added or removed
     * from a bonus dom div will be ignored.
     *
     * @param {Array.<MutationRecord>} mutations the array of MutationRecords from the observer
     * @private
     * @returns {boolean} true if we should ignore these mutations
     */
    function _ignoreMutations(mutations) {
      var ignore = true;
      var mutationsLength = mutations.length;
      var dontIgnoreAttribute = ['colspan', 'label-hint'];

      for (var i = 0; i < mutationsLength; i++) {
        var mutation = mutations[i];

        if (
          mutation.type === 'childList' &&
          _isBonusDomDivOrSelf(mutation.target) &&
          _isNodeOfThisFormLayout(mutation.target)
        ) {
          ignore = false;
          break;
        }
        // If an attribute we care about changes on a child, we don't ignore the mutation
        if (mutation.type === 'attributes' && dontIgnoreAttribute.includes(mutation.attributeName)) {
          ignore = false;
          break;
        }
      }

      return ignore;
    }

    /**
     * Checks to see if the node is a DIV with our bonus dom attribute on it or if it is the
     * oj-form-layout itself.
     *
     * @param {Node} node Node to check.
     * @returns {boolean|null} true if we have a parent DIV with the bonus dom attribute
     */
    function _isBonusDomDivOrSelf(node) {
      return (
        node === element || (node && node.tagName === 'DIV' && node.hasAttribute(BONUS_DOM_ATTR))
      );
    }
    /**
     * Checks to make sure that this node belongs to this oj-form-layout rather than a nested -oj-form-layout
     * @param {Node} node
     * @returns {boolean}
     */
    function _isNodeOfThisFormLayout(_node) {
      var node = _node;
      var result = true;

      while (node !== element) {
        if (node.tagName === _OJ_FORM_LAYOUT) {
          result = false;
          break;
        }

        node = node.parentElement;

        // must be a deleted node so ignore it
        if (node == null) {
          result = false;
          break;
        }
      }

      return result;
    }
    /**
     * Remove a dom element preserving all of its children
     *
     * @param {Element} elem
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _removeElementAndReparentChildren(elem) {
      // We need to reparent all nodes, not just element nodes because some comment nodes
      // may be oj-bind-* components.
      while (elem.firstChild) {
        var child = elem.firstChild;
        elem.parentNode.insertBefore(child, elem); // @HTMLUpdateOK reparenting existing element.
      }

      elem.parentNode.removeChild(elem);
    }

    /**
     * If an element doesn't have an ID, generate a unique ID for it.
     *
     * @param {Element} _elem
     * @memberof oj.ojFormLayout
     * @instance
     * @private
     */
    function _ensureUniqueId(_elem) {
      var elem = _elem;
      if (!elem.id) {
        elem.id = 'oflId_' + _uidCounter;
        _uidCounter += 1;
      }
    }

    /**
     * @private
     */
    function _isIE11() {
      var agent = oj.AgentUtils.getAgentInfo();
      return agent.browser === 'ie' && agent.browserVersion === 11;
    }

    /**
     * In the Alta theme, we show required on the label with an * icon,
     * and help on label with a ? icon.
     * In the Redwood theme, we show 'Required'/help as text inline if
     * user-assistance-density attribute is not 'compact',
     * else we show it as an * on the icon.
     */
    function _showUserAssistanceNotInline(editableElem) {
      let defaultOptions = ojthemeutils.parseJSONFromFontFamily('oj-form-control-option-defaults');
      let resolvedUserAssistance = 'displayOptions';

      if (defaultOptions) {
        // this will return 'use' or 'ignore'. This tells us whether we should use the
        // user-assistance-density attribute or ignore it. If we ignore it, we will
        // use the displayOptions attribute.
        let useUserAssistanceOption = defaultOptions.useUserAssistanceOptionDefault;
        resolvedUserAssistance =
          useUserAssistanceOption === 'use' ? editableElem.userAssistanceDensity : 'displayOptions';
      }
      return resolvedUserAssistance === 'compact' || resolvedUserAssistance === 'displayOptions';
    }

    /**
     * Some properties of the form is based on the theme.
     * We first check if the user has set a value. If so, we use it and do not find a default from themes.
     * Else we take the default from themes and use it.
     */
    function _updateDefaultFromTheme(componentContext) {
      var themeDefault = ojthemeutils.parseJSONFromFontFamily(_OJ_DEFAULTS) || {};
      if (componentContext) {
        if (!componentContext.props.labelEdge) {
          element.labelEdge = themeDefault.labelEdge;
        }
        if (!componentContext.props.colspanWrap) {
          element.colspanWrap = themeDefault.colspanWrap;
        }
        if (!componentContext.props.direction) {
          element.direction = themeDefault.direction;
        }
      } else {
        if (!element.labelEdge) {
          element.labelEdge = themeDefault.labelEdge;
        }
        if (!element.colspanWrap) {
          element.colspanWrap = themeDefault.colspanWrap;
        }
        if (!element.direction) {
          element.direction = themeDefault.direction;
        }
      }
    }
  }

  // static function called by the bridge to get attribute default values
  ojFormLayout.getDynamicDefaults = function () {
    var themeDefault = ojthemeutils.parseJSONFromFontFamily(_OJ_DEFAULTS) || {};
    return {
      labelEdge: themeDefault.labelEdge,
      direction: themeDefault.direction
    };
  };

  // eslint-disable-next-line wrap-iife
  (function () {
    __oj_form_layout_metadata.extension._CONSTRUCTOR = ojFormLayout;
    __oj_form_layout_metadata.extension._TRACK_CHILDREN = 'nearestCustomElement';
    __oj_form_layout_metadata.extension._BINDING = {
      provide: new Map([[UNSAFE_useFormVariantContext.FormVariantContext, 'default']])
    };
    oj.CustomElementBridge.register('oj-form-layout', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_form_layout_metadata, {
        properties: {
          readonly: {
            binding: {
              provide: [{ name: 'containerReadonly', default: false }, { name: 'readonly' }],
              consume: { name: 'containerReadonly' }
            }
          },
          userAssistanceDensity: {
            binding: {
              provide: [
                { name: 'containerUserAssistanceDensity', default: 'efficient' },
                { name: 'userAssistanceDensity', default: 'efficient' }
              ],
              consume: { name: 'containerUserAssistanceDensity' }
            }
          },
          labelEdge: {
            binding: {
              provide: [
                { name: 'containerLabelEdge' },
                { name: 'labelEdge', transform: { top: 'provided', start: 'provided' } }
              ],
              consume: { name: 'containerLabelEdge' }
            }
          },
          labelWidth: {
            binding: {
              provide: [{ name: 'labelWidth' }]
            }
          },
          labelWrapping: {
            binding: {
              // This is consumed by oj-c- form components to pass to the preact FormContext.
              provide: [{ name: 'labelWrapping' }]
            }
          }
        }
      })
    });
  })();

});


define('ojs/ojradiocheckbox',['ojs/ojcore-base', 'jquery', 'ojs/ojlogger', 'ojs/ojcomponentcore'], function (oj, $, Logger, Components) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * The _ojRadio component enhances a browser input element into one that is
   * of type=radio. This is a private component used by ojRadioset.
   *
   * <h3>Events:</h3>
   * <ul>
   *   <li>clicked/checked?<p>
   *   Triggered if the checkbox is clicked; or if the checkbox was checked programatically
   *   with the checked option.
   *   </li>
   * </ul>
   *
   * @ojcomponent oj._ojRadioCheckbox
   * @private
   * @augments oj.baseComponent TODO: Should I extend this?
   * Pros: it gives me oj-disabled/oj-enabled. (easy to add myself)
   * Cons: It gives me tooltip stuff that I don't want. I want that on the div or on the first checkbox only.
   * Pro/Con?: it rewrites required for me if it is on the dom node, but then it makes it required??? Should I rewrite required or don't care?
   */
  oj.__registerWidget('oj._ojRadioCheckbox', $.oj.baseComponent, {
    version: '1.0.0',
    defaultElement: '<input>',
    widgetEventPrefix: 'oj',
    options: {
      /**
       * First we look for the disabled option to be explicitly set. If not, then
       * we look if disabled is on the dom. If null, disabled defaults to false.
       * @expose
       * @type {?boolean|undefined}
       * @default <code class="prettyprint">false</code>
       * @public
       * @instance
       * @memberof oj._ojRadioCheckbox
       */
      disabled: null,
      /**
       * First we look for the checked option to be explicitly set. If not, then
       * we look if checked is on the dom. If null, checked defaults to false.
       * @expose
       * @type {?boolean}
       * @public
       * @instance
       * @memberof oj._ojRadioCheckbox */
      checked: null,
      /**
       * First we look for the disabled option to be explicitly set. If not, then
       * we look if disabled is on the dom. If null, disabled defaults to false.
       * @expose
       * @type {?boolean}
       * @default <code class="prettyprint">false</code>
       * @public
       * @instance
       * @memberof oj._ojRadioCheckbox
       */
      type: null
    },
    /** ** start Public APIs ****/
    /**
     *
     * <p>This method does not accept any arguments.
     *
     * @public
     * @expose
     * @memberof oj.RadioCheckbox
     * @return {jQuery} the label(s) for the checkbox/radio input
     */
    label: function () {
      if (this.$label === undefined) {
        this.$label = this._getLabelsForElement();
      }
      return this.$label;
    },
    /**
     * @expose
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @override
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" )._ojRadioCheckbox( "refresh" );
     */
    refresh: function () {
      this._super();
      this._setup();
    },
    /**
     * @expose
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @override
     * @example <caption>Invoke the <code class="prettyprint">refreshDisabled</code> method:</caption>
     * $( ".selector" )._ojRadioCheckbox( "refreshDisabled" );
     */
    refreshDisabled: function () {
      // this looks at the effectivelyDisabled flag and updates the disabled attributes on the dom.
      this._renderDisabled();
    },
    /**
     * Set the oj-selected class to the element's checked property.
     * We keep the oj-selected class in sync with the input's checked attribute, not necessarily the
     * component's checked property. The component's checked property is set after it is validated.
     * if validation doesn't pass, the input may still be checked, but the this.options.checked isn't.
     * Think of it like an inputText. You can clear it out when it is required, blur,
     * and the display value is an empty field, but the value is the value that was there before.
     * @expose
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @override
     * @example <caption>Invoke the <code class="prettyprint">setSelectedClass</code> method:</caption>
     * $( ".selector" )._ojRadioCheckbox( "setSelectedClass", true );
     */
    setSelectedClass: function (checked) {
      this.element.toggleClass('oj-selected', checked);
      this.$label.toggleClass('oj-selected', checked);
      this.$choiceItem.toggleClass('oj-selected', checked);
    },
    /**
     * Returns a jQuery object containing the element visually representing the checkbox.
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @return {jQuery} the checkbox or radio
     */
    widget: function () {
      return this.uiRadioCheckbox;
    },

    /** ** end Public APIs ****/

    /** ** start internal widget functions ****/
    /**
     * Called at component create time primarily to initialize options, often using DOM values. This
     * method is called before _ComponentCreate is called, so components that override this method
     * should be aware that the component has not been rendered yet. The element DOM is available and
     * can be relied on to retrieve any default values. <p>
     * @param {!Object} originalDefaults - original default options defined on the widget and its ancestors
     * @param {?Object} constructorOptions - options passed into the widget constructor
     *
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @protected
     */
    _InitOptions: function (originalDefaults, constructorOptions) {
      var checkedFromDom;
      var disabledFromDom;

      this._super(originalDefaults, constructorOptions);

      // CHECKED:
      // if options.checked is not set, get it from the element
      // if options.checked is set to a valid value (boolean), set it on the
      // element to keep the two in sync (we do this in _CreateComponent->_setup)
      //
      // use DOM value if not in constructorOptions
      if (!('checked' in constructorOptions)) {
        this.initCheckedFromDom = true;
        checkedFromDom = !!this.element.prop('checked');
        // writeback not needed since "not in constructorOptions" means "not bound"
        this.option('checked', checkedFromDom, { _context: { internalSet: true } });
      }
      if (typeof this.options.checked !== 'boolean') {
        throw new Error('checked option must be a boolean');
      }
      // DISABLED:
      // if options.disabled is not set, get it from the element
      // if options.disabled is set to a valid value (boolean), set it on the
      // element to keep the two in sync (we do this in _CreateComponent->_setup)
      // use DOM value if not in constructorOptions
      if (!('disabled' in constructorOptions)) {
        // !! ensures it is a boolean
        disabledFromDom = !!this.element.prop('disabled');
        // writeback not needed since "not in constructorOptions" means "not bound"
        this.option('disabled', disabledFromDom, { _context: { internalSet: true } });
      }
      if (typeof this.options.disabled !== 'boolean') {
        throw new Error('disabled option must be a boolean');
      }

      // TYPE:
      // Gets the type which will be either radio or checkbox.
      // writeback not needed since "not in constructorOptions" means "not bound"
      if (!('type' in constructorOptions)) {
        this.option('type', this.element.prop('type'), { _context: { internalSet: true } });
      }
    },
    /**
     * After _ComponentCreate and _AfterCreate,
     * the widget should be 100% set up. this._super should be called first.
     * @override
     * @protected
     * @instance
     * @memberof oj._ojRadioCheckbox
     */
    _ComponentCreate: function () {
      this._super();

      var type = this.options.type;
      if (type === 'checkbox') {
        this.uiRadioCheckbox = this.element.addClass('oj-checkbox oj-component');
        this.$label = this._getLabelsForElement();
        this.$label.addClass('oj-checkbox-label');
      } else if (type === 'radio') {
        this.uiRadioCheckbox = this.element.addClass('oj-radio oj-component');
        this.$label = this._getLabelsForElement();
        this.$label.addClass('oj-radio-label');
      }

      // this will not be null since we create a choice item if there isn't one
      this.$choiceItem = this._getChoiceItem();

      var iElem = document.createElement('span');
      iElem.setAttribute('class', 'oj-radiocheckbox-icon oj-component-icon');
      this.element.wrapAll(iElem); // @HTMLUpdateOK iElem constructed locally

      var self = this;
      this._focusable(this.element);

      this._AddHoverable(this.$choiceItem);
      this._AddActiveable(this.$choiceItem);

      // the input gets focus on keyboard tabbing. It bubbles up, so in case the
      // input element is hidden (e.g., in the native themes the input is hidden and an image is
      // shown instead), we need to set the focus selectors on the oj-choice-item so
      // we can style the checked image.
      this._focusable({
        element: this.$choiceItem,
        applyHighlight: true
      });

      this._AddHoverable(this.$label);
      this._AddActiveable(this.$label);

      // loop through each label to add dom and styles
      $.each(self.$label, function () {
        // wrap children in span
        $(this.childNodes).wrapAll("<span class='oj-radiocheckbox-label-text'></span>"); // @HTMLUpdateOK
      });
      this._setup();
    },
    /**
     * <p>Save only the 'class' attribute since that is what
     * we manipulate. We don't have to save all the attributes.
     * </p>
     *
     * @param {Object} element - jQuery selection to save attributes for
     * @protected
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @override
     */
    _SaveAttributes: function (element) {
      this._savedClasses = element.attr('class');
    },
    /**
     * <p>Restore what was saved in _SaveAttributes
     * </p>
     *
     * @protected
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @override
     */
    _RestoreAttributes: function () {
      // restore the saved "class" attribute. Setting class attr to undefined is a no/op, so
      // if this._savedClasses is undefined we explicitly remove the 'class' attribute.
      if (this._savedClasses) {
        this.element.attr('class', this._savedClasses);
      } else {
        this.element.removeAttr('class');
      }
    },
    /* _setup called during creation */
    _setup: function () {
      this._renderDisabled();

      if (!this.initCheckedFromDom) {
        // if we got it from the dom in _InitOptions, there is no need to reset it on the dom in _setup
        this._setCheckedOnDom(this.options.checked);
      }
      if (this.options.checked) {
        this.setSelectedClass(this.options.checked);
      }
    },
    _setCheckedOnDom: function (checked) {
      // !! to turn checked into a boolean
      // eslint-disable-next-line no-param-reassign
      checked = !!checked;

      this.element.prop('checked', checked);
    },
    _renderDisabled: function () {
      // Determines whether this component is effectively disabled,
      // i.e. it has its 'disabled' option set to true or
      // it has been disabled by its ancestor component
      var effectivelyDisabled = this._IsEffectivelyDisabled();
      if (effectivelyDisabled) {
        // set the dom to show DISABLED, but do NOT change the disabled option!
        //
        // when a dom element supports disabled, use that, and not aria-disabled.
        // having both is an error.
        this.element
          .prop('disabled', true)
          .removeAttr('aria-disabled')
          .removeClass('oj-enabled')
          .addClass('oj-disabled');

        this.$label.removeClass('oj-enabled').addClass('oj-disabled');

        this.$choiceItem.removeClass('oj-enabled').addClass('oj-disabled');
      } else {
        // option not set to disabled. nor is parent. On refresh this is ok, since we get it from the option.
        // when a dom element supports disabled, use that, and not aria-disabled.
        // having both is an error.
        this.element
          .prop('disabled', false)
          .removeAttr('aria-disabled')
          .removeClass('oj-disabled')
          .addClass('oj-enabled');
        this.$label.addClass('oj-enabled').removeClass('oj-disabled');
        this.$choiceItem.addClass('oj-enabled').removeClass('oj-disabled');
      }
    },
    /**
     * @override
     * @private
     */
    _setOption: function (key, value) {
      this._superApply(arguments);

      if (key === 'disabled') {
        // eslint-disable-next-line no-param-reassign
        value = !!value;
        this._renderDisabled(value);
      }

      if (key === 'checked') {
        this._setCheckedOnDom(value);
        this.setSelectedClass(value);
      }
    },
    /**
     * Returns the list of labels for the element. Most likely this will be
     * one label, not multiple labels.
     * We do not guarantee that the returned list is live
     * We do not guarantee that the returned list is in document order
     * We check a jquery selector query on <label>s with a 'for' id equal to our id starting at the document level
     * and also as a sibling of the input (needed if documentFragment instead of document as the
     * table/datagrid use).
     * We do not support a label wrapping an input, so if we find that, we log an error.
     * NOTE: The .labels DOM property does not work on most browsers, so we don't use it.
     * e.g,
     * <pre>
     * <input id="opt3" type="checkbox" name="rb" value="opt3">
     * <label for="opt3">Checkbox Option 3</label>
     * </pre>
     * @private
     */
    _getLabelsForElement: function () {
      // this looks to see if the label is wrapping the input, which we do not support
      var $labelClosestParent = this.element.closest('label');

      var id = this.element.prop('id');
      var labelForQuery = "label[for='" + id + "']";
      var $labelForElems = $(labelForQuery);
      var $labelSibling;

      if ($labelClosestParent.length !== 0) {
        Logger.error(
          "Found a label that is an input's ancestor." +
            ' This is not supported in the ojCheckboxset or ojRadioset component and the component will\n' +
            'not work correctly. ' +
            "Use a label as a sibling to the input and use the label 'for' attribute to tie the two together."
        );
      }

      // make sure that the $labelClosestParent isn't also the one we found with the 'for' which would
      // be weird, but still. If it is, remove it from the jQuery element list so we don't count it as found.
      // e.g., <label for="input"><input id="input"></label> // not supported!
      // .not() method creates a new set and leaves the original set unchanged
      $labelForElems = $labelForElems.not($labelClosestParent);

      if ($labelForElems.length === 0) {
        // table and datagrid create their rows using documentFragment. With documentFragment
        // the labelFor query will return []. In that case, look for the label as a sibling of
        // the element
        $labelSibling = this.element.siblings(labelForQuery);
        // .add() method creates a new set and leaves the original set unchanged
        $labelForElems = $labelForElems.add($labelSibling);
      }

      // combine these query results to return the label
      // with the for attribute pointing to the checkbox's id.
      return $labelForElems;
    },
    /**
     * Call this before you wrap the input in a span class='oj-radiocheckbox-icon' because we
     * are looking for the span with oj-choice-item as the parent of the input.
     * If it isn't there, this function will add it. So it never returns null.
     * @private
     * @returns {Object}
     */
    _getChoiceItem: function () {
      var choiceItem = null;
      var elementParent;
      var labelSelector;
      var ojChoiceItemSpanString;
      var siblingLabel;

      elementParent = this.element.parent();
      // oj-choice-row and oj-choice-row-inline have been deprecated on December 7, 2016 in
      // version 3.0.0. Use oj-choice-item instead.
      if (
        elementParent &&
        (elementParent.hasClass('oj-choice-item') ||
          elementParent.hasClass('oj-choice-row') ||
          elementParent.hasClass('oj-choice-row-inline'))
      ) {
        choiceItem = elementParent;
      } else {
        Logger.warn(
          "The radioset/checkboxset's input and label dom should be wrapped in a dom " +
            "node with class 'oj-choice-item'. JET is adding this missing dom to make the component work correctly."
        );

        // Since we can't find the oj-choice-item, create one.
        // It needs to wrap the input and its label (if any)
        ojChoiceItemSpanString = "<span class='oj-choice-item oj-choice-item-added'></span>";

        // the most common case is an <input id='foo'><label for='foo'> pair, so look for that first
        labelSelector = "label[for='" + this.element.attr('id') + "']";
        siblingLabel = this.element.siblings().filter(labelSelector);

        if (siblingLabel.length !== 0) {
          this.element.add(siblingLabel).wrapAll(ojChoiceItemSpanString); // @HTMLUpdateOK adding empty span for styling
          choiceItem = this.element.parent();
        } else {
          this.element.wrapAll(ojChoiceItemSpanString); // @HTMLUpdateOK adding empty span for styling
          choiceItem = this.element.parent();
        }
      }

      return choiceItem;
    },
    /**
     * Return the subcomponent node represented by the documented locator attribute values.
     * Test authors should target spinner sub elements using the following names:
     * <ul>
     * <li><b>oj-radiocheckbox-input</b>: the radio/checkbox's input</li>
     * <li><b>oj-radiocheckbox-label</b>: the radio/checkbox's label</li>
     * </ul>
     *
     * @expose
     * @override
     * @memberof oj._ojRadioCheckbox
     * @instance
     * @param {Object} locator An Object containing at minimum a subId property
     * whose value is a string, documented by the component, that allows the component to
     * look up the subcomponent associated with that string.  It contains:
     * <ul>
     * <li>
     * component: optional - in the future there may be more than one component
     *   contained within a page element
     * </li>
     * <li>
     * subId: the string, documented by the component, that the component expects
     * in getNodeBySubId to locate a particular subcomponent
     * </li>
     * </ul>
     * @returns {Element|null} the subcomponent located by the subId string
     * passed in locator, if found.
     */
    getNodeBySubId: function (locator) {
      var node = this._super(locator);
      if (!node) {
        var subId = locator.subId;
        if (subId === 'oj-radiocheckbox-input') {
          node = this.element[0];
        }
        if (subId === 'oj-radiocheckbox-label') {
          // this.label() returns a jquery object. we want to return a dom element
          node = this.label()[0];
        }
      }
      // Non-null locators have to be handled by the component subclasses
      return node || null;
    },

    /**
     * @ignore
     * @protected
     * @override
     */
    _destroy: function () {
      var ret = this._super();

      this._RemoveHoverable(this.$choiceItem);
      this._RemoveActiveable(this.$choiceItem);

      this._RemoveHoverable(this.$label);
      this._RemoveActiveable(this.$label);

      var type = this.options.type;

      // this.$label is the label for the checkbox/radio, NOT the label for the radioset/checkboxset.
      // We don't save and restore these attributes in base class, so we need to clean up ourselves
      if (type === 'checkbox') {
        this.$label.removeClass('oj-enabled oj-disabled oj-selected oj-checkbox-label');
      } else if (type === 'radio') {
        this.$label.removeClass('oj-enabled oj-disabled oj-selected oj-radio-label');
      }

      this.$choiceItem.removeClass('oj-enabled oj-disabled oj-selected');

      var self = this;

      // loop through each label to remove things we added
      $.each(self.$label, function () {
        var text = this.getElementsByClassName('oj-radiocheckbox-label-text');
        if (text !== undefined) {
          $(text[0].childNodes[0]).unwrap();
        }
      });

      // remove the oj-radiocheckbox-icon span around the element.
      this.element.unwrap();

      // remove the oj-choice-item span only if I added it.
      // I marked it with 'oj-choice-item-added' style.
      if (this.$choiceItem.hasClass('oj-choice-item-added')) {
        this.element.unwrap();
      }

      this.$choiceItem = null;
      this.$label = null;

      return ret;
    }

    /** ** end internal widget functions ****/
  });

  /**
   * @class RadioCheckboxUtils
   * @classdesc JET Radio and Checkbox Component Utils
   * @export
   * @since 6.1.0
   * @hideconstructor
   * @ignore
   *
   */
  const RadioCheckboxUtils = {};
  oj._registerLegacyNamespaceProp('RadioCheckboxUtils', RadioCheckboxUtils);

  /**
   * Render option items from existing data.
   *
   * @public
   * @ignore
   */
  RadioCheckboxUtils.renderOptions = function () {
    var optionsDataArray = this._optionsDataArray;
    var choiceset = this.element[0];

    if (optionsDataArray) {
      // The wrapper should have been created in _ComponentCreate
      var wrapperClass =
        choiceset.tagName === 'OJ-RADIOSET' ? 'oj-radioset-wrapper' : 'oj-checkboxset-wrapper';
      var wrapper = choiceset.querySelector('.' + wrapperClass);

      // Remove all the existing option items
      var optionItems = wrapper.querySelectorAll('.oj-choice-item');
      for (let i = 0; i < optionItems.length; i++) {
        let item = optionItems[i];
        item.parentNode.removeChild(item);
      }
      // When in readonly mode, unselected oj-options will be unprocessed.
      // We need to remove them as well.
      optionItems = wrapper.querySelectorAll('oj-option');
      for (let i = 0; i < optionItems.length; i++) {
        let item = optionItems[i];
        item.parentNode.removeChild(item);
      }

      // Determine option renderer
      var optionRenderer = this.options.optionRenderer;
      var optionsKeys = this.options.optionsKeys;
      var valueKey = optionsKeys && optionsKeys.value ? optionsKeys.value : 'value';
      if (typeof optionRenderer !== 'function') {
        // Default option renderer
        optionRenderer = function (optionContext) {
          var labelKey = optionsKeys && optionsKeys.label ? optionsKeys.label : 'label';
          var disabledKey = 'disabled';
          var ojOption = document.createElement('oj-option');
          ojOption.value = optionContext.data[valueKey];
          ojOption.textContent = optionContext.data[labelKey];
          ojOption.disabled = optionContext.data[disabledKey];
          return ojOption;
        };
      }

      // Create all oj-option from option data
      for (let i = 0; i < optionsDataArray.length; i++) {
        var optionContext = {
          component: choiceset,
          index: i,
          data: optionsDataArray[i]
        };
        var ojOption = optionRenderer(optionContext);
        if (ojOption && ojOption.tagName === 'OJ-OPTION') {
          // Need to set data-oj-binding-provider so that the element will be upgraded
          if (!ojOption.hasAttribute('data-oj-binding-provider')) {
            ojOption.setAttribute('data-oj-binding-provider', 'none');
          }
          if (ojOption.value === null || ojOption.value === undefined) {
            ojOption.value = optionContext.data[valueKey];
          }
          wrapper.appendChild(ojOption);
          Components.subtreeAttached(ojOption);
        }
      }

      // Call refresh, which will set up all oj-option as _ojRadioCheckbox
      // and update the display value and disabled state.
      this.refresh();
    }
  };

  /**
   * Fetch DataProvider data and render option items from it.
   * This is called when the component is created, when the "options" property changes,
   * and when the DataProvider data is changed.
   *
   * @public
   * @ignore
   */
  RadioCheckboxUtils.generateOptionsFromData = function () {
    var dataProvider = this.options.options;

    // Remove any existing DataProvider listeners
    RadioCheckboxUtils.removeDataListener.call(this);

    // Nothing else to do here if no DataProvider is used
    if (!dataProvider || !oj.DataProviderFeatureChecker.isDataProvider(dataProvider)) {
      return;
    }

    // Add a busy state
    var desc = 'The component identified by "' + this.element[0].id + '" is fetching data';
    var busyStateOptions = { description: desc };
    var busyContext = oj.Context.getContext(this.element[0]).getBusyContext();
    var resolveFunc = busyContext.addBusyState(busyStateOptions);

    // Create a clientId symbol that uniquely identify this consumer so that
    // DataProvider which supports it can optimize resources
    this._clientId = this._clientId || Symbol();

    // Fetch all the option data
    // eslint-disable-next-line no-param-reassign
    this._optionsDataArray = [];
    var i;
    var asyncIterator = dataProvider.fetchFirst({ clientId: this._clientId })[Symbol.asyncIterator]();
    var self = this;
    var processResults = function (iterResult) {
      var nextPromise;

      if (iterResult && iterResult.value) {
        var fetchListResult = iterResult.value;
        for (i = 0; i < fetchListResult.data.length; i++) {
          self._optionsDataArray.push(fetchListResult.data[i]);
        }

        // fetch the next batch if we're not done
        if (!iterResult.done) {
          nextPromise = asyncIterator.next().then(processResults);
        }
      }

      return nextPromise;
    };

    var fetchPromise = asyncIterator.next().then(processResults);

    fetchPromise.then(
      function () {
        RadioCheckboxUtils.renderOptions.call(self);
        // Add back DataProvider listeners after the options are rendered
        RadioCheckboxUtils.addDataListener.call(self);
        // Resolve busy state
        resolveFunc();
      },
      function () {
        resolveFunc();
      }
    );
  };

  /**
   * Add listeners to DataProvider events.
   *
   * @public
   * @ignore
   */
  RadioCheckboxUtils.addDataListener = function () {
    // Remove any existing listener first
    RadioCheckboxUtils.removeDataListener.call(this);

    if (this.options.options && oj.DataProviderFeatureChecker.isDataProvider(this.options.options)) {
      // Remember which dataprovider is used because this.options.options can change
      // eslint-disable-next-line no-param-reassign
      this._optionsDataProvider = this.options.options;
      // eslint-disable-next-line no-param-reassign
      this._optionsDataListener = RadioCheckboxUtils.generateOptionsFromData.bind(this);
      this._optionsDataProvider.addEventListener('refresh', this._optionsDataListener);
      this._optionsDataProvider.addEventListener('mutate', this._optionsDataListener);
    }
  };

  /**
   * Remove listeners from DataProvider events.
   *
   * @public
   * @ignore
   */
  RadioCheckboxUtils.removeDataListener = function () {
    if (this._optionsDataListener) {
      this._optionsDataProvider.removeEventListener('refresh', this._optionsDataListener);
      this._optionsDataProvider.removeEventListener('mutate', this._optionsDataListener);
      // eslint-disable-next-line no-param-reassign
      this._optionsDataProvider = null;
      // eslint-disable-next-line no-param-reassign
      this._optionsDataListener = null;
    }
  };

});


define('ojs/ojcheckboxset',['ojs/ojcomponentcore', 'ojs/ojeditablevalue', 'ojs/ojradiocheckbox', 'ojs/ojoption', 'ojs/ojcore-base', 'jquery', 'ojs/ojlogger', 'ojs/ojtranslation', 'ojs/ojlabelledbyutils'], function (ojcomponentcore, ojeditablevalue, ojradiocheckbox, ojoption, oj, $, Logger, Translations, LabeledByUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  LabeledByUtils = LabeledByUtils && Object.prototype.hasOwnProperty.call(LabeledByUtils, 'default') ? LabeledByUtils['default'] : LabeledByUtils;

  (function () {
var __oj_checkboxset_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "optionRenderer": {
      "type": "function"
    },
    "options": {
      "type": "object"
    },
    "optionsKeys": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "readonlyNoValue": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "Array<any>",
      "writeback": true,
      "value": []
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    __oj_checkboxset_metadata.extension._WIDGET_NAME = 'ojCheckboxset';
    __oj_checkboxset_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    __oj_checkboxset_metadata.extension._TRACK_CHILDREN = 'immediate';

    oj.CustomElementBridge.register('oj-checkboxset', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_checkboxset_metadata, {
        properties: {
          readonly: {
            binding: { consume: { name: 'readonly' } }
          },
          userAssistanceDensity: {
            binding: { consume: { name: 'userAssistanceDensity' } }
          },
          labelEdge: {
            binding: { consume: { name: 'labelEdge' } }
          }
        }
      })
    });
  })();

  (function () {
    /*!
     * JET Checkboxset @VERSION
     */

    // -----------------------------------------------------------------------------
    // "private static members" shared by all checkboxsets
    // -----------------------------------------------------------------------------

    // do not do a value change check in _SetValue
    var _sValueChangeCheckFalse = { doValueChangeCheck: false };

    /**
     * @ojcomponent oj.ojCheckboxset
     * @augments oj.editableValue
     * @since 0.6.0
     * @ojshortdesc A checkbox set allows the user to select one or more options from a set.
     * @ojrole checkbox
     * @ojrole checkboxgroup
     * @ojrole option
     * @ojimportmembers oj.ojDisplayOptions
     * @ojdisplayname Checkbox Set
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
     *
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojCheckboxset<K, D, V =any> extends editableValue<Array<V>, ojCheckboxsetSettableProperties<K, D, V>>",
     *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"},
     *                {"name": "V", "description": "Type of each item in the value of the component"}]
     *               },
     *               {
     *                target: "Type",
     *                value: "ojCheckboxsetSettableProperties<K, D, V> extends editableValueSettableProperties<Array<V>>",
     *                for: "SettableProperties"
     *               }
     *              ]
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "required", "disabled"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 6
     * @ojvbmincolumns 2
     *
     * @ojoracleicon 'oj-ux-ico-checkbox-set'
     * @ojuxspecs ['checkboxset']
     *
     * @ojdeprecated [
     *   {
     *     type: "maintenance",
     *     since: "16.0.0",
     *     value: ["oj-c-checkboxset"]
     *   }
     * ]
     *
     * @classdesc
     * <h3 id="checkboxsetOverview-section">
     *   JET Checkboxset
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#checkboxsetOverview-section"></a>
     * </h3>
     * <p>
     * The JET oj-checkboxset component manages a set of
     * <code class="prettyprint">oj-option</code> child elements and creates the necessary dom elements for
     * the actual checkboxes.
     * </p>
     * <p>To use an oj-checkboxset, add one or more oj-option child elements for each checkbox desired.
     * Note, if you add or remove an oj-option after the oj-checkboxset is rendered, you should call
     * refresh() on the oj-checkboxset.
     * Note, oj-optgroup is not a supported child element of oj-checkboxset.
     * </p>
     * <p>The child content can be configured via inline HTML content or a DataProvider.
     * It is recommended that inline HTML content should only be used for static data and the DataProvider should always be used for mutable data.
     * </p>
     * <p>A JET Checkbox Set can be created with the following markup.</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-checkboxset>
     *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
     *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
     *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
     *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
     * &lt;/oj-checkboxset>
     * </code></pre>
     * <p>A JET Checkbox Set can be created with a DataProvider.</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-checkboxset options="[[dataprovider]]">
     * &lt;/oj-checkboxset>
     * </code></pre>
     *
     * <p>
     *  You can enable and disable an oj-checkboxset,
     *  which will enable and disable all contained checkboxes.
     * </p>
     * {@ojinclude "name":"validationAndMessagingDoc"}
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET Checkboxset takes care of setting <code class="prettyprint">role="group"</code>
     * on the oj-checkboxset element.
     *
     * <p>
     * {@ojinclude "name":"accessibilitySetLabelEditableValue"}
     * {@ojinclude "name":"accessibilityDisabledEditableValue"}
     * </p>
     *
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     *
     * <p>
     * To migrate from oj-checkboxset to oj-c-checkboxset, you need to revise the import statement
     * and references from oj-checkboxset to oj-c-checkboxset in your app. For instance if your application imported <code>ojs/ojcheckboxset</code> this needs to be
     * updated to <code>oj-c/checkboxset</code>.
     * Please note the following changes between the two components below.
     * </p>
     *
     * <h5>options attribute</h5>
     * <p>
     * The <code>options</code> attribute is the only way to provide data to the new oj-c-checkboxset component. Adding <code>oj-option</code>
     * child elements inline is not supported anymore.
     * Besides maintaining its support for DataProvider, the <code>options</code> attribute also accepts an Array of data items.
     * Regardless of the type used for this attribute (whether it's a DataProvider implementation or an Array of data items)
     * the "label" property is required. In the DataProvider case, the "key" of the DataProvider will be used as
     * the checkbox value. The "label" property will provide the text for the checkbox.
     * </p>
     * <h5>label-edge attribute</h5>
     * <p>
     * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
     * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
     * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
     * attribute to the corresponding value.
     * </p>
     *
     * <h5>option-renderer attribute</h5>
     * <p>
     * The <code>option-renderer</code> attribute is not supported anymore and was removed from <code>oj-c-checkboxset</code>.
     * The item label text must be provided directly through the <code>options</code> data.
     * </p>
     *
     * <h5>option-keys attribute</h5>
     * <p>
     * The <code>options-keys</code> attribute is no longer supported and was removed from <code>oj-c-checkboxset</code>.
     * This attribute was used to map an arbitrary DataProvider data item signature to a label and value. The application can instead wrap their
     * DataProvider implementation in a <a href="ListDataProviderView.html">ListDataProviderView</a> with data mapping to match
     * the data shape required by <code>oj-c-checkboxset</code>.
     * </p>
     *
     * <h5>readonly checkboxset visual appearance</h5>
     * <p>
     * A readonly oj-c-checkboxset will render all checkboxes, with an OK check mark for the selected item. This is
     * different from oj-checkboxset where only the selected checkbox was rendered.
     * </p>
     *
     * <h5>messages-custom attribute</h5>
     * <p>
     * The type of the <code class="prettyprint">severity</code> property of the messages in the
     * array has changed from
     * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
     * (essentially <code class="prettyprint">string | number</code>), to simply
     * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
     * values are the same as the previously supported string values.
     * The application can no longer specify severity as a number, including hardcoded numbers,
     * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
     * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
     * </p>
     *
     * <h5>Removed style classes</h5>
     * <p>
     * The usage of the style classes: oj-choice-direction-column, oj-choice-direction-row that would affect the row or column
     * orientation of the checkboxset are now replaced with the <code>direction</code> attribute. The value of this attribute
     * maps to these style classes as shown below:
     * <ul>
     * <li>
     * .oj-choice-direction-column maps to 'column'
     * </li>
     * <li>
     * .oj-choice-direction-row maps to 'row'
     * </li>
     * </ul>
     * </p>
     * <p>
     * The following style classes were removed from oj-c-checkboxset without having a mapping to a new attribute:
     * <ul>
     * <li>
     * .oj-checkboxset-input-end
     * </li>
     * <li>
     * .oj-checkboxset-input-start
     * </li>
     * <li>
     * .oj-checkboxset-no-chrome
     * </li>
     * </ul>
     * </p>
     * <h5>translations attribute</h5>
     * <p>
     * The translations.required.message-detail attribute has changed to required-message-detail.
     * </p>
     *
     * <h5>refresh method</h5>
     * <p>
     * The refresh method is no longer supported. The application should no longer need to use this method. If the application
     * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
     * </p>
     *
     * <h5>reset method</h5>
     * <p>
     * This method does not synchronously reset the component. The application should wait on the busy context of the component after
     * invoking this method for the changes to appear.
     * </p>
     *
     * <h5>showMessages method</h5>
     * <p>
     * This method does not synchronously show the hidden messages of the component. The application should wait on the busy context
     * of the component after invoking this method for the changes to appear.
     * </p>
     *
     * <h5>Custom Label</h5>
     * <p>
     * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
     * label-hint attribute to add a label for the form component.
     * </p>
     * <p>
     * The application should no longer need to use an &lt;oj-label-value> component to layout the form component. The application
     * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
     * </p>
     *
     * <h5>DescribedBy attribute</h5>
     * <p>
     * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
     * This attribute is not carried forward to the core pack component.
     * </p>
     *
     * <h5>display-options attribute</h5>
     * <p>
     * The <code>display-options</code> attribute only supports the messages sub-property, <code>converter-hint</code> and <code>validator-hint</code> sub-properties were removed.
     * </p>
     *
     * <h5>Formatted messages</h5>
     * <p>
     * Formatting messages using html tags is not supported in the core pack component.
     * </p>
     *
     * <h5>Usage in Dynamic Form</h5>
     * <p>
     * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
     * </p>
     *
     *
     * @example <caption>Declare the oj-input-text component with no attributes specified:</caption>
     * &lt;oj-input-text>&lt;/oj-input-text>
     *
     * @example <caption>Initialize the component with some attributes:</caption>
     * &lt;oj-input-text id="textId" disabled>&lt;/oj-input-text>
     *
     * @example <caption>Initialize a component attribute via component binding:</caption>
     * &lt;oj-input-text id="textId" value="{{currentValue}}">&lt;/oj-input-text>


     *
     * @example <caption>Initialize the checkboxset with no attributes specified:</caption>
     * &lt;oj-checkboxset id="colorCheckbox" value="{{currentColor}}">
     *   &lt;oj-option value="blue">Blue&lt;/oj-option>
     *   &lt;oj-option value="green">Green&lt;/oj-option>
     * &lt;/oj-checkboxset>
     *
     * @example <caption>Initialize component and an associated oj-label component</caption>
     * &lt;oj-label id="grouplabel">Greetings&lt;/oj-label>
     * &lt;oj-checkboxset id="checkboxset" labelled-by="grouplabel" value="{{currentGreeting}}">
     *   &lt;oj-option id="helloid" value="hello">Hello&lt;/oj-option>
     *   &lt;oj-option id="bonjourid" value="bonjour"/>Bonjour&lt;/oj-option>
     *   &lt;oj-option id="ciaoid" value="ciao"/>Ciao&lt;/oj-option>
     * &lt;/oj-checkboxset>
     * <br/>
     * // set the value to "ciao". (The 'ciao' checkbox will be checked)
     * myComp.value = ["ciao"];
     */

    /**
     * Removes the checkboxset functionality completely.
     * This will return the element back to its pre-init state.
     *
     * <p>This method does not accept any arguments.
     *
     * @method
     * @name oj.ojCheckboxset#destroy
     * @memberof oj.ojCheckboxset
     * @instance
     * @ignore
     *
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojCheckboxset( "destroy" );
     */

    //------------------------------------------------------------
    //                              Fragments
    //------------------------------------------------------------
    /**
     * <p>The &lt;oj-checkboxset> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
     * accepted children and slots.</p>
     *
     * @ojchild Default
     * @memberof oj.ojCheckboxset
     * @ojshortdesc The oj-checkboxset element accepts oj-option elements as children.
     * @ojpreferredcontent ["OptionElement"]
     *
     * @example <caption>Initialize the Checkboxset with child content specified:</caption>
     * &lt;oj-checkboxset>
     *   &lt;oj-option value="check1">Check 1&lt;/oj-option>
     *   &lt;oj-option value="check2">Check 2&lt;/oj-option>
     *   &lt;oj-option value="check3">Check 3&lt;/oj-option>
     * &lt;/oj-checkboxset>
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Select/unselect the checkbox</td>
     *     </tr>
     *     <tr>
     *       <td>Checkbox's Label</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Select/unselect the corresponding checkbox</td>
     *    </tr>
     *     <tr>
     *       <td>Checkbox or Label</td>
     *       <td><kbd>Press & Hold</kbd></td>
     *       <td>If hints, help.instruction or messages exist in a notewindow,
     *           pop up the notewindow.</td>
     *    </tr>
     *   </tbody>
     *  </table>
     *
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojCheckboxset
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Checkboxset</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the first focusable checkbox in the checkboxset.
     *       Disabled checkboxes are not focusable.
     *       If hints, helpInstruction or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *     <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Space</kbd></td>
     *       <td>Toggles the checkbox; Iff the checkbox is unselected, it will select it and vice versa.</td>
     *     </tr>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Sets focus to the next focusable checkbox in the checkboxset.
     *        Disabled checkboxes are not focusable. If the target is the last focusable checkbox in the
     *        checkboxset, focus goes to the next focusable item after the oj-checkboxset.</td>
     *     </tr>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>Sets focus to the previous focusable checkbox in the checkboxset.
     *        Disabled checkboxes are not focusable. If the target is the first focusable checkbox in the
     *        checkboxset, focus goes to the previous focusable item before the oj-checkboxset.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojCheckboxset
     */
    //--------------------------------------------------------
    //                   SUB-IDS
    //--------------------------------------------------------
    /**
     * <p>Sub-ID for the checkboxset's checkboxes.
     *
     * @ojsubid oj-checkboxset-inputs
     * @deprecated 3.0.0 Since the application supplies the input elements, it can supply a unique ID by which the input elements can be accessed.
     * @ignore
     * @memberof oj.ojCheckboxset
     * @example <caption>Get the nodes for the checkboxes:</caption>
     * var nodes = myComp.getNodeBySubId('oj-checkboxset-inputs');
     */

    //------------------------------------------------------
    //                  Styling Start
    //------------------------------------------------------
    /**
     * Use this style class to lay out the checkboxes in a column. This is the default.
     * @ojstyleclass oj-choice-direction-column
     * @ojdisplayname Column Layout
     * @memberof oj.ojCheckboxset
     * @ojtsexample
     * &lt;oj-checkboxset id="checkboxsetId" class="oj-choice-direction-column">
     *   &lt;!-- Content -->
     * &lt;/oj-checkboxset>
     */
    /**
     * Use this style class to lay out the checkboxes in a row.
     * @ojstyleclass oj-choice-direction-row
     * @ojdisplayname Row Layout
     * @memberof oj.ojCheckboxset
     * @ojtsexample
     * &lt;oj-checkboxset id="checkboxsetId" class="oj-choice-direction-row">
     *   &lt;!-- Content -->
     * &lt;/oj-checkboxset>
     */
    /**
     * Use this style class if you don't want the chrome around the set.
     * @ojstyleclass oj-checkboxset-no-chrome
     * @ojdisplayname No Chrome
     * @memberof oj.ojCheckboxset
     * @ojtsexample
     * &lt;oj-checkboxset id="checkboxsetId" class="oj-checkboxset-no-chrome">
     *   &lt;!-- Content -->
     * &lt;/oj-checkboxset>
     */
    /**
     * Use this style class to order the checkbox at the start and label text at the end, even if a theme has a different default order.
     * @ojstyleclass oj-checkboxset-input-start
     * @ojdisplayname Input Start
     * @memberof oj.ojCheckboxset
     * @ojtsexample
     * &lt;oj-checkboxset id="checkboxsetId" class="oj-checkboxset-input-start">
     *   &lt;!-- Content -->
     * &lt;/oj-checkboxset>
     */
    /**
     * Use this style class to order the checkbox at the end and the label text at the start, even if a theme has a different default order.
     * @ojstyleclass oj-checkboxset-input-end
     * @ojdisplayname Input End
     * @memberof oj.ojCheckboxset
     * @ojtsexample
     * &lt;oj-checkboxset id="checkboxsetId" class="oj-checkboxset-input-end">
     *   &lt;!-- Content -->
     * &lt;/oj-checkboxset>
     */

    oj.__registerWidget('oj.ojCheckboxset', $.oj.editableValue, {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',

      /**
       * @expose
       * @private
       */
      _WRAPPER_CLASS_NAMES: 'oj-checkboxset-wrapper oj-form-control-container',

      options: {
        /**
         * <p>
         * Disabled <code class="prettyprint">true</code> disables the component and disables
         * all the inputs/labels.
         * Disabled <code class="prettyprint">false</code> enables the component, and leaves the inputs
         * disabled state as it is in the dom.
         * <p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">disabled</code> attribute:</caption>
         * &lt;oj-checkboxset disabled>
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-checkboxset>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabled = myComp.disabled;
         *
         * // setter
         * myComp.disabled = false;
         *
         * @expose
         * @type {boolean}
         * @default false
         * @ojshortdesc Specifies if the component is disabled. If true, then all of its inputs and labels are also disabled. See the Help documentation for more information.
         * @public
         * @instance
         * @memberof oj.ojCheckboxset
         */
        disabled: false,
        /**
         * labelled-by is used to establish a relationship between this component and another element.
         * A common use is to tie the oj-label and the oj-checkboxset together for accessibility.
         * The oj-label custom element has an id, and you use the labelled-by attribute
         * to tie the two components together to facilitate correct screen reader behavior.
         *
         * @example <caption>Initialize component with <code class="prettyprint">labelled-by</code> attribute:</caption>
         * &lt;oj-label id="labelId">Name:&lt;/oj-label>
         * &lt;oj-checkboxset labelled-by="labelId">
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-checkboxset>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var disabled = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         *
         * @expose
         * @type {string|null}
         * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documenation for more information.
         * @public
         * @instance
         * @memberof oj.ojCheckboxset
         */
        labelledBy: null,
        /**
         * Whether the component is readonly. The readonly property sets or returns whether an element is readonly, or not.
         * A readonly element cannot be modified. However, a user can tab to it, highlight it, focus on it, and copy the text from it.
         * If you want to prevent the user from interacting with the element, use the disabled property instead.
         * <p>
         * The default value for readonly is false. However, if the form component is a descendent of
         * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
         * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
         * The <code class="prettyprint">oj-form-layout</code> uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">readonly</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the readonly property if an ancestor provides it and
         * it is not explicitly set.
         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
         * not have its readonly attribute set, the form component's readonly will be true.
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">readonly</code> attribute:</caption>
         * &lt;oj-checkboxset readonly>&lt;/oj-checkboxset>
         *
         * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
         * // Getter
         * var readonly = myComponent.readonly;
         *
         * // Setter
         * myComponent.readonly = false;
         *
         * @default false
         * @access public
         * @expose
         * @type {?boolean}
         * @ojshortdesc Specifies whether the component is read-only. A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
         * @name readonly
         * @instance
         * @memberof oj.ojCheckboxset
         */
        readOnly: false,
        /**
         * @typedef {Object} oj.ojCheckboxset.OptionContext
         * @property {Element} component A reference to the Checkboxset element.
         * @property {number} index The index of the option, where 0 is the index of the first option.
         * @property {Object} data The data object for the option.
         * @ojsignature [{target:"Type", value:"<D>", for:"genericTypeParameters"},
         *               {target:"Type", value:"D", for:"data"}]
         */
        /**
         * {@ojinclude "name":"checkboxsetCommonOptionRenderer"}
         * @name optionRenderer
         * @ojshortdesc The renderer function that renders the content of each option.
         * @expose
         * @memberof oj.ojCheckboxset
         * @instance
         * @type {null|function(Object):Object}
         * @ojsignature { target: "Type",
         *                value: "?((param0: oj.ojCheckboxset.OptionContext<D>) => Element)|null",
         *                jsdocOverride: true}
         * @default null
         * @example <caption>Initialize the checkboxset with a renderer:</caption>
         * &lt;oj-checkboxset option-renderer="[[optionRenderer]]">&lt;/oj-checkboxset>
         * @example var optionRenderer = function(context) {
         *            var ojOption = document.createElement('oj-option');
         *            // Set the textContent or append other child nodes
         *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];
         *            return ojOption;
         *          };
         */
        /**
         * The renderer function that renders each option.
         * The function should return an oj-option element.
         * <p>It is not necessary to set the "value" attribute on the oj-option as it is available from the options data.</p>
         * <p>
         * See <a href="#options">options</a>
         * and <a href="#optionsKeys">options-keys</a> for configuring option label and value.
         * </p>
         *
         * <p>The context parameter passed to the renderer contains the following keys:</p>
         * <table class="keyboard-table">
         *   <thead>
         *     <tr>
         *       <th>Key</th>
         *       <th>Description</th>
         *     </tr>
         *   </thead>
         *   <tbody>
         *     <tr>
         *       <td><kbd>component</kbd></td>
         *       <td>A reference to the Checkboxset element.</td>
         *     </tr>
         *     <tr>
         *       <td><kbd>index</kbd></td>
         *       <td>The index of the option, where 0 is the index of the first option.</td>
         *     </tr>
         *     <tr>
         *       <td><kbd>data</kbd></td>
         *       <td>The data object for the option.</td>
         *     </tr>
         *   </tbody>
         * </table>
         *
         * @expose
         * @memberof oj.ojCheckboxset
         * @instance
         * @ojfragment checkboxsetCommonOptionRenderer
         */
        optionRenderer: null,

        /**
         * @typedef {Object} oj.ojCheckboxset.Option
         * @property {boolean=} disabled Option item is disabled.
         * @property {string=} label The display label for the option item. If it's missing, string(value) will be used.
         * @property {any} value The value of the option item.
         */
        /**
         * {@ojinclude "name":"checkboxsetCommonOptions"}
         *
         * @name options
         * @ojshortdesc The option items for the checkbox set.
         * @expose
         * @access public
         * @instance
         * @type {Object|null}
         * @ojsignature { target: "Type",
         *                value: "DataProvider<K, D>|null",
         *                jsdocOverride: true}
         * @default null
         * @memberof oj.ojCheckboxset
         *
         * @example <caption>Initialize the Checkboxset with a data provider and data mapping:</caption>
         * &lt;oj-checkboxset options="[[dataProvider]]">&lt;/oj-checkboxset>
         *
         * @example <caption>Use simple DataProvider if data has value and label properties.</caption>
         * var dataArray = [
         *            {value: 'Id 1', label: 'Name 1'},
         *            {value: 'Id 2', label: 'Name 2'},
         *            {value: 'Id 3', label: 'Name 3'}];
         *
         * var dataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'value'});
         *
         * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>
         * // actual field names are "id" and "name"
         * var dataArray = [
         *            {id: 'Id 1', name: 'Name 1'},
         *            {id: 'Id 2', name: 'Name 2'},
         *            {id: 'Id 3', name: 'Name 3'}];
         *
         * // In mapfields, map "name" to "label" and "id" to "value"
         * var mapFields = function(item) {
         *   var data = item['data'];
         *   var mappedItem = {};
         *   mappedItem['data'] = {};
         *   mappedItem['data']['label'] = data['name'];
         *   mappedItem['data']['value'] = data['id'];
         *   mappedItem['metadata'] = {'key': data['id']};
         *   return mappedItem;
         * };
         * var dataMapping = {'mapFields': mapFields};
         *
         * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});
         * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});
         */
        /**
         * A data provider that returns the option items for the Checkboxset.
         * This attribute can be used instead of providing a list of <code class="prettyprint">oj-option</code> child elements of the Checkboxset element.
         * <p>This data provider must implement <a href="DataProvider.html">DataProvider</a>.
         *   <ul>
         *   <li><code class="prettyprint">value</code> in <code class="prettyprint">oj.ojCheckboxset.Option</code> must be the row key in the data provider.</li>
         *   <li>All rows will be displayed in the Checkboxset.</li>
         *   </ul>
         * </p>
         *
         * @expose
         * @memberof oj.ojCheckboxset
         * @instance
         * @ojfragment checkboxsetCommonOptions
         */
        options: null,

        /**
         * @typedef {Object} oj.ojCheckboxset.OptionsKeys
         * @property {?string=} label The key name for the label.
         * @property {?string=} value The key name for the value.
         */
        /**
         * {@ojinclude "name":"checkboxsetCommonOptionsKeys"}
         *
         * @example <caption>Initialize the Checkboxset with <code class="prettyprint">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>
         * &lt;oj-checkboxset options-keys="[[optionsKeys]]">&lt;/oj-checkboxset>
         * @example var optionsKeys = {value : "state_abbr", label : "state_name"};
         *
         * @name optionsKeys
         * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.
         * @expose
         * @access public
         * @instance
         * @type {?Object}
         * @ojsignature { target: "Type",
         *                value: "?oj.ojCheckboxset.OptionsKeys",
         *                jsdocOverride: true}
         * @default null
         * @memberof oj.ojCheckboxset
         */
        /**
         * Specify the key names to use in the options array.
         * <p>Depending on options-keys means that the signature of the data does not match what is supported by the options attribute. When using Typescript, this would result in a compilation error.</p>
         * <p>Best practice is to use a <a href="ListDataProviderView.html">ListDataProviderView</a> with data mapping as a replacement.</p>
         * <p>However, for the app that must fetch data from a REST endpoint where the data fields do not match those that are supported by the options attribute, you may use the options-keys with any dataProvider that implements <a href="DataProvider.html">DataProvider</a> interface.</p>
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojCheckboxset
         * @ojfragment checkboxsetCommonOptionsKeys
         */
        optionsKeys: {
          /**
           * The key name for the label.
           *
           * @name optionsKeys.label
           * @expose
           * @public
           * @instance
           * @memberof! oj.ojCheckboxset
           * @type {?string}
           * @ojsignature { target: "Type",
           *                value: "?"}
           * @default null
           */
          /**
           * The key name for the value.
           *
           * @name optionsKeys.value
           * @expose
           * @public
           * @instance
           * @memberof! oj.ojCheckboxset
           * @type {?string}
           * @ojsignature { target: "Type",
           *                value: "?"}
           * @default null
           */
        },

        /**
         * <p>
         * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
         * This is the default.
         * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
         * </p>
         * <p>
         * In the Redwood theme, by default, a Required text is rendered inline when the field is empty.
         * If user-assistance-density is 'compact', it will show on the label as an icon.
         * In the Alta theme the input's label will render a required icon.
         * </p>
         * <p>The Required error text is based on Redwood UX designs, and it is not recommended that
         * it be changed.
         * To override the required error message,
         * use the <code class="prettyprint">translations.required</code> attribute.
         * The component's label text is passed in as a token {label} and can be used in the message detail.
         * </p>
         * <p>When required is set to true, an implicit
         * required validator is created, i.e.,
         * <code class="prettyprint">new RequiredValidator()</code>. The required validator is the only
         * validator to run during initial render, and its error is not shown to the user at this time;
         * this is called deferred validation. The required validator also runs during normal validation;
         * this is when the errors are shown to the user.
         * See the <a href="#validation-section">Validation and Messaging</a> section for details.
         * </p>
         * <p>
         * When the <code class="prettyprint">required</code> property changes due to programmatic intervention,
         * the component may clear component messages and run validation, based on the current state it's in. </br>
         *
         * <h4>Running Validation when required property changes</h4>
         * <ul>
         * <li>if component is valid when required is set to true, then it runs deferred validation on
         * the value property. If the field is empty, the valid state is invalidHidden. No errors are
         * shown to the user.
         * </li>
         * <li>if component is invalid and has deferred messages when required is set to false, then
         * component messages are cleared (messages-custom messages are not cleared)
         * but no deferred validation is run because required is false.
         * </li>
         * <li>if component is invalid and currently showing invalid messages when required is set, then
         * component messages are cleared and normal validation is run using the current display value.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated and the error is shown.
         *   </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event on the component to clear custom errors.</li>
         * </ul>
         * </li>
         * </ul>
         *
         * <h4>Clearing Messages when required property changes</h4>
         * <ul>
         * <li>Only messages created by the component, like validation messages, are cleared when the required property changes.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
         * </ul>
         *
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">required</code> attribute:</caption>
         * &lt;oj-checkboxset required>
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-checkboxset>
         *
         * @example <caption>Customize messages and hints used by implicit required validator when
         * <code class="prettyprint">required</code> option is set:</caption>
         * &lt;oj-checkboxset required value="{{colors}}"
         *                    translations='{"required":
         *                                    {"hint": "custom: check at least one value",
         *                                     "messageSummary": "custom: \'{label}\' is Required",
         *                                     "messageDetail", "custom: please check at least one value for \'{label}\'"}}'>
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-checkboxset>
         *
         * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
         * // getter
         * var required = myComp.required;
         *
         * // setter
         * myComp.required = false;
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojCheckboxset
         * @type {boolean}
         * @ojshortdesc Specifies whether the component is required or optional. See the Help documentation for more information.
         * @default false
         * @since 0.7.0
         * @see #translations
         */
        required: false,
        /**
         * The value of the component.
         *
         * <p>
         * When <code class="prettyprint">value</code> is set to <code class="prettyprint">null</code>,
         * it will be converted to the default value [].
         * When <code class="prettyprint">value</code> property changes due to programmatic
         * intervention, the component always clears all messages and runs deferred validation, and
         * always refreshes UI display value.</br>
         *
         * <h4>Clearing Messages</h4>
         * <ul>
         * <li>All messages are cleared. This includes
         * the <code class="prettyprint">messagesCustom</code> property.</li>
         * </ul>
         *
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>component always runs deferred validation</li>
         * </ul>
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">value</code> attribute specified:</caption>
         * &lt;oj-checkboxset required value='["coffee"]'>
         *   &lt;oj-option value="coffee">Coffee&lt;/oj-option>
         *   &lt;oj-option value="tea">Tea&lt;/oj-option>
         * &lt;/oj-checkboxset>
         * @example <caption>Get or set <code class="prettyprint">value</code> option, after initialization:</caption>
         * // Getter: returns ["coffee"]
         * var val = myComp.value;
         * // Setter: sets ["coffee", "tea"]
         * myComp.value = ["coffee", "tea"];
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojCheckboxset
         * @ojwriteback
         * @default []
         * @type {Array.<any>}
         * @ojsignature [{target: "Type", value: "Array<V>|null"}]
         * @ojshortdesc An array that represents the value of the component. See the Help documentation for more information.
         * @ojeventgroup common
         */
        value: []
      },
      /** ** start Public APIs ****/

      /**
       * Refreshes the checkboxset
       * <p>A <code class="prettyprint">refresh()</code> or re-init is required
       * when a checkboxset is programatically changed, like in the following circumstances:
       * <ul>
       *   <li>After oj-options are added or removed.</li>
       * </ul>
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myComp.refresh();
       *
       * @expose
       * @public
       * @return {void}
       * @ojshortdesc Refreshes the checkbox set. A refresh is required after a checkbox set is programmatically changed. See the Help documentation for more information.
       * @memberof oj.ojCheckboxset
       * @instance
       */
      refresh: function () {
        this._super();
        this._setup();
      },
      /**
       * Returns a jQuery object containing the element visually representing the checkboxset.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @memberof oj.ojCheckboxset
       * @instance
       * @public
       * @return {jQuery} the checkbox
       * @ignore
       */
      widget: function () {
        return this.uiCheckboxset;
      },
      /**
       * Validates the component's display value using all validators registered on
       * the component and updates the <code class="prettyprint">value</code> option by performing the
       * following steps.
       *
       * <p>
       * <ol>
       * <li>All messages are cleared, including custom messages added by the app. </li>
       * <li>The implicit
       * required validator is run if the component is marked required.</li>
       * <li>At the end of validation if there are errors, the messages are shown.
       * If there were no errors, then the
       * <code class="prettyprint">value</code> property is updated.</li>
       * </ol>
       *
       * @example <caption>Validate component using its current value.</caption>
       * myComp.validate();
       * @example <caption>Validate component and use the Promise's resolved state.</caption>
       * myComp.validate().then(
       *  function(result) {
       *    if(result === "valid")
       *    {
       *      submitForm();
       *    }
       *  });
       * @return {Promise.<string>} Promise resolves to "valid" if
       * the component passed all validations.
       * The Promise resolves to "invalid" if there were validation errors.
       *
       * @method
       * @access public
       * @expose
       * @ojshortdesc Validates the component's display value using all validators registered on the component. If there are no validation errors. then the value is updated. See the Help documentation for more information.
       * @instance
       * @memberof oj.ojCheckboxset
       * @since 4.0.0
       *
       */
      validate: ojeditablevalue.EditableValueUtils.validate,

      /** ** end Public APIs ****/

      /** ** start internal widget functions ****/

      /**
       * Overridden to set the options.value. When constructorOptions value is undefined,
       * we read the CHECKED options on the checkboxes and build the value array from that.
       *
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        var checkedValues = [];
        var selectedCheckbox;
        var domValue;
        var props = [
          { attribute: 'disabled', validateOption: true },
          { attribute: 'readonly', option: 'readOnly', validateOption: true },
          { attribute: 'title' },
          // {attribute: "value", "defaultValue": null},  // code below sets value
          { attribute: 'required', coerceDomValue: true, validateOption: true }
        ];

        this._super(originalDefaults, constructorOptions);

        if (!this._IsCustomElement()) {
          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
        }

        // component, app, and constructor are merged into this.options.option by the time _InitOptions
        // is called. Let's take this example:
        // component (widget) default - 'foo'<br/>
        // app default - 'bar'<br/>
        // dom  - 'lucy'<br/>
        // constructorOptions['value'] - undefined<br/>
        // this.options.option is set to 'bar' initially. We don't want to just take this value, because
        // we want DOM value to win over the app and components default if DOM is set.
        // Therefore, the component needs to check if the constructorOptions['value'] is
        // undefined and if so, set value option to 'lucy' (the DOM value in this example). <br/>
        //
        // use DOM value if constructorOptions is undefined. if DOM value is undefined, then
        // leave this.options["value"] alone since it's the merged app/widget default at this point.
        if (!this._IsCustomElement()) {
          if (constructorOptions.value === undefined) {
            // constructor option for value is undefined. Then we check the dom.
            this.$checkboxes = this._findCheckboxesWithMatchingName();
            selectedCheckbox = this.$checkboxes.filter(':checked');
            if (selectedCheckbox.length > 0) {
              selectedCheckbox.each(function () {
                checkedValues.push($(this).val());
              });
              domValue = checkedValues;

              // when defaulting from DOM we want to trigger optionChange to writeback new value

              this.option('value', domValue, { _context: { writeback: true, internalSet: true } });
            }
            // if nothing is checked, we leave this.options["value"] as it is if not undefined, else
            // the widget's default is [].
            if (this.options.value === undefined) {
              this.options.value = [];
            }
          } else {
            this._checkValueType(this.options.value);
          }
        } else {
          this._checkValueType(this.options.value);
        }
      },
      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @override
       * @protected
       * @memberof oj.ojCheckboxset
       * @instance
       */
      _ComponentCreate: function () {
        const $element = this.element;
        this._super();
        // first check to see if element is NOT a fieldset. If fieldset, throw error.
        if ($element.is('fieldset')) {
          throw new Error('ojCheckboxset cannot be bound to a fieldset. Use a div instead.');
        }

        // since the oj-option renderer uses the oj-checkboxset ID for the name
        // attribute of the rendered chekcboxes, let's make sure the checkboxset
        // has an ID
        $element.uniqueId();
        // Retrieve the tabindex from the container and store it in an instance variable.
        // Also we need to remove the tabindex from the container so that it will not receive
        // focus
        this._externalTabIndex = this.element.attr('tabindex') || 0;
        this.element.removeAttr('tabindex');
        // Async step that generates oj-option if DateProvider is used.
        // RadioCheckboxUtils will set this._optionsDataProvider, this._optionsDataListener
        // and this._optionsDataArray.
        oj.RadioCheckboxUtils.generateOptionsFromData.call(this);

        // Continue processing for the static oj-option case and set up the component itself
        this._processOjOptions();
        // The processOjOptions renders input/label, so we need to go through and
        // get the this.$checkboxes after this is called.
        this.$checkboxes = this._findCheckboxesWithMatchingName();
        // Turn each checkbox into ojCheckbox. Do this first, since we need it
        // in calls from 'create'. Also, since ojCheckboxSet delegates to the _ojRadioCheckbox
        // component, and we need to mark this as an internal node so that oj.Components.getComponentElementByNode
        // knows it is an internal component in this case, not a stand-alone component
        this.$checkboxes._ojRadioCheckbox().attr('data-oj-internal', '');

        // keep the root dom element and slots as is, and add a wrapper dom underneath it. This way we can
        // have one div around all the inputs and labels, and for inline messaging we can have another
        // div around the inline messaging content. And we can style the borders of the two boxes differently.
        this.uiCheckboxset = $element.addClass('oj-checkboxset oj-component').attr('role', 'group');
        // need to grab all elements using contents first and then do filter because jquery children will automatically
        // exclude all comment and text nodes
        const $childNodes = $element.contents().filter(function () {
          return !(this.getAttribute && this.getAttribute('slot') === 'contextMenu');
        });
        // When using dataprovider, the childNodes will not be generated yet.
        // So, in that case append the wrapper directly to the element.
        if ($childNodes.length > 0) {
          $childNodes.wrapAll(`<div class='${this._WRAPPER_CLASS_NAMES}'></div>`); // @HTMLUpdateOK
        } else {
          $element.append(`<div class='${this._WRAPPER_CLASS_NAMES}'></div>`); // @HTMLUpdateOK
        }

        // if readonly, set tabindex on the wrapper
        this._updateReadonlyState();
        this._on(this._events);
        this._setup();
      },

      /**
       * Resets this.checkboxes. This is called at the beginning of a refresh in EditableValue
       * @override
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       */
      _ResetComponentState: function () {
        // we could have added, removed, or modified radios, so we need to re-find all the
        // oj-options, inputs on refresh and turn the ones that aren't already
        // ojRadioCheckboxes into them.
        this._processOjOptions();
        this.$checkboxes = this._findCheckboxesWithMatchingName();

        // we have a rule for refresh: if we have a public API for it, then the app dev has to use the
        // option, and not expect changing the dom will update the state with refresh.
        // However, ojCheckboxset does not expose a public API for the individual checkbox's disabled state
        // to the app developer. Our private ojRadioCheckbox component has a disabled option that
        // our code has access to.
        // For each checkbox, we need to look at the disabled attribute dom and update the
        // ojradiocheckbox's disabled option.

        // !! ensures it is a boolean
        // update the private ojradiocheckbox component's disabled option to keep it in sync with the dom
        this.$checkboxes.filter('.oj-checkbox').each(function () {
          var disabledValue =
            $(this).attr('disabled') !== undefined ? !!$(this).prop('disabled') : false;

          $(this)._ojRadioCheckbox('option', 'disabled', disabledValue);
        });

        // no need to refresh the ojRadioCheckbox's that exist since we have options for everything.
        // of the type=radio inputs that are not yet ojRadioCheckboxs, make them ojRadioCheckboxes.

        // create ojRadioCheckboxes on any new ones.
        this.$checkboxes.not('.oj-checkbox')._ojRadioCheckbox();
      },

      /**
       * @override
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       * @since 5.0.0
       */
      GetFocusElement: function () {
        // JET-48463 - oj-table issue where focus is lost
        // GetFocusElement() needs to return the correct readonly element
        // If _GetReadonlyFocusElement() returns null, fallback to the
        // enabled element logic.
        if (this.options.readOnly === true) {
          const readonlyFocusElement = this._GetReadonlyFocusElement();
          if (readonlyFocusElement) {
            return readonlyFocusElement;
          }
        }
        // We need :disabled here so that we don't try to focus on an element that isn't focusable.
        // :focusable doesn't work because this is called before the custom element is fully upgraded
        // and is still hidden in the DOM.
        return this._GetContentElement().not(':disabled').first()[0];
      },
      /**
       * oj-checkboxset doesn't use .oj-text-field-readonly for the focusable readonly content,
       * so we need to use a different selector.
       * @memberof oj.ojCheckboxset
       * @instance
       * @override
       * @protected
       * @return {Element|null}
       */
      _GetReadonlyFocusElement: function () {
        return this.widget()[0].querySelector('.oj-form-control-container');
      },
      /**
       * Sets the disabled option onto the dom.
       * This is a no-op for checkboxset since its root dom element is a div, and disabled is
       * invalid on a div. If we did try to set disabled on the div, then restore attributes doesn't
       * work correctly since it wasn't saved correctly.
       * @param {Object} node - dom node
       *
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       * @since 1.0.0
       */
      _SetDisabledDom: function () {
        // no-op
      },
      /**
       * Whether the component is required.
       *
       * @return {boolean} true if required; false
       *
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       * @override
       */
      _IsRequired: function () {
        return this.options.required;
      },
      /**
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       */
      _refreshRequired: ojeditablevalue.EditableValueUtils._refreshRequired,

      /**
       * This function processes the oj-option children, sets the custom renderer, and
       * creates input type=checkbox and label dom from them.
       *
       * We don't want to rely on the framework calling the customOptionRenderer
       * as a result of setting options[i]["customOptionRenderer"] = renderer; in this function.
       * This could lead to timing bugs when data-oj-binding-provider="none". (when not "none",
       * we know the oj-options are created before the oj-checkboxset gets created, so no timing issue)
       * Therefore we create the input/label not in the customOptionRenderer,
       * but in a separate function that we call.
       * @private
       * @instance
       */
      _processOjOptions: function () {
        // if the value doesn't exist as an option, it will end up at the top of the resultant array
        function sortValuesInOptionsOrder(vals, opts) {
          var values = vals.slice(0);
          var optIndex = opts.length - 1;
          var valIndex = values.length - 1;
          while (valIndex > 0 && optIndex > -1) {
            var optVal = opts[optIndex].value;
            var val = values[valIndex];
            if (optVal !== val) {
              var i = values.indexOf(optVal);
              if (i > -1) {
                values[i] = val;
                values[valIndex] = optVal;
                valIndex -= 1;
              }
              optIndex -= 1;
            } else {
              valIndex -= 1;
              optIndex -= 1;
            }
          }
          return values;
        }

        // set the custom renderer on oj-option
        if (this._IsCustomElement()) {
          var i;
          var len;
          var domElem = this.element[0];
          var wrapperDom = domElem.querySelector('.oj-checkboxset-wrapper');
          var renderer = this._customOptionRenderer.bind(this);
          // Get all the oj-option elements of the oj-checkboxset
          // Those that are direct child as well as those inside the wrapperDOM
          var options = this.element
            .children('oj-option')
            .add(this.element.children('.oj-checkboxset-wrapper').find('oj-option'));
          var selectedOptionsArray = sortValuesInOptionsOrder(this.options.value, options);
          var numSelected = selectedOptionsArray.length;

          // If the wrapperDom isn't created yet, we use the component element as the wrapper
          if (!wrapperDom) {
            wrapperDom = domElem;
          }

          var novaluespan = domElem.querySelector('[data-no-value-span]');
          // Remove the old no-value span when there is one and there is a current selection or not in readonly mode
          if (novaluespan) {
            if (numSelected > 0 || !this.options.readOnly) {
              novaluespan.parentElement.removeChild(novaluespan);
            }
          } else if (numSelected === 0 && this.options.readOnly) {
            // Otherwise, add the no value span if no selection.
            var span = document.createElement('span');
            span.setAttribute('data-no-value-span', '');
            span.setAttribute('class', 'oj-choice-item');
            span.setAttribute('aria-readonly', true);
            var noCheckboxSelected = this.getTranslatedString('readonlyNoValue');
            if (noCheckboxSelected !== null) {
              span.textContent = noCheckboxSelected;
            }
            wrapperDom.appendChild(span); // @HTMLUpdateOK
          }

          for (i = 0, len = options.length; i < len; i++) {
            options[i].customOptionRenderer = renderer;
            if (this.options.readOnly) {
              this._processReadonlyOptions(options[i], selectedOptionsArray);
            } else {
              this._initInputLabelFromOjOption(options[i]);
            }
          }
        }
      },

      /**
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       */
      _processReadonlyOptions: function (ojOption, selectedOptionsArray) {
        const optionValue = ojOption.value;
        const selectedArrayLength = selectedOptionsArray.length;
        const element = this.element.get(0);
        const choiceItemSelector = 'span.oj-choice-item';
        const parentSpan = $(ojOption).parentsUntil(element, choiceItemSelector).get(0);

        // If the provided ojOption is present inside an oj-choice-item, it means
        // it is already processed. If not, it is still not processed.
        // It should be sufficient to hide just ojOption element when it is not
        // processed. But, if it is processed, then we need to hide the parent
        // oj-choice-item
        if (parentSpan == null) {
          // this is when span wrapper is not yet created around ojoption.
          // the ojoption will be hidden first and then unhide the checked option
          ojOption.classList.add('oj-helper-hidden');
        } else {
          parentSpan.classList.add('oj-helper-hidden');
        }
        // if element is readonly and there is no checked option then we do not need to process options,
        if (selectedArrayLength > 0) {
          var i = selectedOptionsArray.indexOf(optionValue);
          if (i > -1) {
            var isLastOption = i === selectedArrayLength - 1;
            this._initReadonlyLabelFromOjOption(ojOption, parentSpan, isLastOption);
          } else if (parentSpan != null) {
            // remove 'aria-readonly' for unselected options.
            parentSpan.removeAttribute('aria-readonly');
          }
        } else if (parentSpan != null) {
          // remove 'aria-readonly' for all options when set value to empty
          parentSpan.removeAttribute('aria-readonly');
        }
      },
      /**
       * Create the input type='checkbox'/label dom from attributes on oj-option element.
       * oj-checkboxset is made up of input/labels.
       * This gets called during the oj-checkboxset _CreateComponent and refresh
       * @param {Element} elem the oj-option element
       * @private
       * @instance
       */
      _initInputLabelFromOjOption: function (elem) {
        var span;
        var label;
        var ojoption = elem;

        // let's make sure that each oj-option has an ID so the
        // label element can reference the input element via the 'for' attribute
        // we have tests in place where oj-option doesn't have id and where it does
        // both for the databound case and non-databound case. In the databound case, the
        // bindings are resolved before we get here, so we will be fine.
        $(ojoption).uniqueId();

        var id = ojoption.getAttribute('id');
        var checkboxId = id + '|cb';
        var checkbox = document.getElementById(checkboxId);
        var alreadyProcessed = checkbox !== null; // Was the oj-option already processed

        // if the oj-option is already processed, we don't need to add the additional dom
        // in the code below, we use setAttribute() for everything as we want to be
        // setting the initial value for these elements.
        if (!alreadyProcessed) {
          checkbox = document.createElement('input');
          checkbox.setAttribute('type', 'checkbox');
          // The value is needed for accessibiliy of the image used for the checkbox
          checkbox.setAttribute('value', ojoption.value);
          checkbox.setAttribute('id', checkboxId);
          // Need to transfer the tabindex to the input element
          // All the input element will have the same tabindex
          checkbox.setAttribute('tabindex', this._externalTabIndex);
          // in readonly mode, if a option is selected, the <oj-option> will be surrounded by <label> tag
          // if a option is selected, we can set attribute for the previous label and there is no need to create a new label
          // if a option is not selected, we need to create a new label.
          if (ojoption.parentElement.nodeName === 'LABEL') {
            label = ojoption.parentElement;
            label.parentElement.insertBefore(checkbox, label);
            // remove 'aria-readonly' when toggle readonly to false
            label.parentElement.removeAttribute('aria-readonly');
            // also we need to remove the oj-helper-hidden class from the parentElement
            label.parentElement.classList.remove('oj-helper-hidden');
          } else {
            span = document.createElement('span');
            label = document.createElement('label');
            span.setAttribute('class', 'oj-choice-item');
            ojoption.parentElement.insertBefore(span, ojoption);
            span.appendChild(checkbox);
            span.appendChild(label);
            label.appendChild(ojoption);
          }
          label.setAttribute('for', checkboxId);

          // if the ojoption doesn't have any textContent, hide the label element.  The use case for
          // this is the case where you have an oj-checkboxset with one checkbox with no label (i.e. you
          // specify one oj-option with no textContent).  We want to hide the generated label element so
          // that the checkbox is easier to center in the parent container (such as a table cell).
          // Note: this is not an issue for oj-radioset, as there is no use case that uses a single
          // radio button in an oj-radioset.
          if (!ojoption.textContent || ojoption.textContent === '') {
            label.classList.add('oj-helper-hidden');
          }
          // in readonly mode, options are not selected will be hidden
          // when we toggle readonly to false, we need to remove the 'oj-helper-hidden' class
          ojoption.classList.remove('oj-helper-hidden');
        } else {
          // find the parent label element.  This is the element we need to hide if there is no text
          // content in the oj-option
          label = ojoption;

          do {
            label = label.parentElement;
          } while (label && !(label.tagName === 'LABEL'));

          // if the ojoption doesn't have any textContent, hide the label element by adding the
          // class oj-helper-hidden
          // if for some reason, a label element is not found, don't do anything
          if (label) {
            if (!ojoption.textContent || ojoption.textContent === '') {
              label.classList.add('oj-helper-hidden');
            } else {
              label.classList.remove('oj-helper-hidden');
            }
          }
          // if the element is already processed we need to check if the component has readonly classes, then we need to clear the
          // classes when it is not readonly
          if (!this.options.readOnly) {
            var parentSpan = ojoption;
            do {
              parentSpan = parentSpan.parentElement;
            } while (parentSpan && !parentSpan.classList.contains('oj-choice-item'));
            if (
              parentSpan &&
              parentSpan.classList.contains('oj-helper-hidden') &&
              parentSpan.classList.contains('oj-choice-item') &&
              parentSpan.tagName === 'SPAN'
            ) {
              parentSpan.classList.remove('oj-helper-hidden');
            }
            if (ojoption && ojoption.classList.contains('oj-helper-hidden')) {
              ojoption.classList.remove('oj-helper-hidden');
            }
            if (checkbox && checkbox.parentElement.classList.contains('oj-helper-hidden')) {
              checkbox.parentElement.classList.remove('oj-helper-hidden');
            }
          }
        }

        var name = this.element[0].id; // Use the id of the ojcheckboxset as the name of the oj-options.
        var ariaLabel = ojoption.getAttribute('aria-label');
        var ariaLabelledBy = ojoption.getAttribute('aria-labelledby');

        var separatorNode = label.querySelector('span[data-oj-internal]');
        if (separatorNode) {
          separatorNode.parentElement.removeChild(separatorNode);
        }

        // The value attribute of the checkbox only supports text, so we need to be
        // able to access the oj-option's value property instead.  This attribute
        // is a link back to the oj-option so that we don't need to use dom traversal
        // to get to the oj-option to get its value.
        checkbox.setAttribute('data-oj-option-id', id);

        if (name && name !== '') {
          checkbox.setAttribute('name', name);
        } else {
          checkbox.removeAttribute('name');
        }

        if (ariaLabel && ariaLabel !== '') {
          checkbox.setAttribute('aria-label', ariaLabel);
        } else {
          checkbox.removeAttribute('aria-label');
        }
        if (ariaLabelledBy && ariaLabelledBy !== '') {
          checkbox.setAttribute('aria-labelledby', ariaLabelledBy);
        } else {
          checkbox.removeAttribute('aria-labelledby');
        }
        if (ojoption.disabled) {
          checkbox.setAttribute('disabled', true);
        } else {
          checkbox.removeAttribute('disabled');
        }
      },
      /**
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       */
      _initReadonlyLabelFromOjOption: function (elem, parentSpan, isLastOption) {
        function toggleLabelSeparator(label, needsSeparator) {
          var separatorNode = label.querySelector('span[data-oj-internal]');
          if (needsSeparator && !separatorNode) {
            var separator = Translations.getTranslatedString('oj-converter.plural-separator');
            separatorNode = document.createElement('span');
            separatorNode.setAttribute('data-oj-internal', '');
            separatorNode.textContent = separator;
            label.appendChild(separatorNode);
          } else if (!needsSeparator && separatorNode) {
            separatorNode.parentElement.removeChild(separatorNode);
          }
        }

        var label = document.createElement('label');
        var ojoption = elem;
        var isRowDirection = this.element.hasClass('oj-choice-direction-row');
        var needsSeparator = isRowDirection && !isLastOption;
        if (parentSpan) {
          $(ojoption).uniqueId();

          var id = ojoption.getAttribute('id');
          var checkboxId = id + '|cb';
          var checkbox = document.getElementById(checkboxId);
          var checkboxExists = checkbox !== null;
          // we do not render the input when the checkboxset id readonly
          // the checkboxset only exists in the update case where readonly is set using setAttribute
          // so we would need to hide the input as we only show label in case of readonly and not input.
          if (checkboxExists) {
            checkbox.parentElement.classList.add('oj-helper-hidden');
            // when we toggle readonly to true, we need to remove the checkbox element.
            var oldlabel = checkbox.parentElement.nextElementSibling;
            if (oldlabel !== null) {
              label.appendChild(ojoption);
              // Before removing the checkbox element, check if _ojRadioCheckbox is initialized
              // for the option. If so, destroy the wiget before removing it from the DOM
              if (checkbox.classList.contains('oj-checkbox')) {
                $(checkbox)._ojRadioCheckbox('destroy');
              }
              parentSpan.removeChild(oldlabel.previousSibling);
              parentSpan.removeChild(oldlabel);
              parentSpan.appendChild(label);
            }
          }
          parentSpan.classList.remove('oj-helper-hidden');
          parentSpan.setAttribute('aria-readonly', true);
          toggleLabelSeparator(ojoption.parentElement, needsSeparator);
        } else {
          elem.classList.remove('oj-helper-hidden');
          var span = document.createElement('span');
          ojoption.parentElement.insertBefore(span, ojoption); // @HTMLUpdateOK
          span.setAttribute('class', 'oj-choice-item');
          label.appendChild(ojoption);
          toggleLabelSeparator(label, needsSeparator);
          if (!isRowDirection) {
            label.setAttribute('class', 'oj-checkbox-label');
          }
          span.appendChild(label);
          span.setAttribute('aria-readonly', true);
        }
      },

      // custom oj-option renderer
      // Because we can't rely on this being called when we set the customOptionRenderer property
      // in _processOjOptions we shouldn't do the input.label creation from the oj-option
      // in this function. (If we did, the _ComponentCreate code that relies on the
      // inputs/labels being created already would not work.)
      // The correct thing to do is to create the input/label in _initInputLabelFromOjOption
      // Then rely on this function being called after the oj-option has been created and we are
      // changing properties on it.
      _customOptionRenderer: function (elem) {
        var ojoption = elem;
        var id = ojoption.getAttribute('id');
        var checkboxId = id + '|cb';
        var checkbox = document.getElementById(checkboxId);
        // Was the oj-option already rendered into an _ojRadioCheckbox() in _CreateComponent?
        var checkboxExists = checkbox !== null;
        var hasOjCheckboxClass = checkboxExists && checkbox.classList.contains('oj-checkbox');

        // When an oj-option child is disabled (by setting the disabled attribute to
        // true) and it re-renders, the component should refresh automatically rather than requiring the
        // user to call refresh. See .
        if (hasOjCheckboxClass) {
          $(checkbox)._ojRadioCheckbox('option', 'disabled', ojoption.disabled);
        }
      },
      /**
       * If custom element, get the labelledBy option, and set this
       * onto the root dom element as aria-labelledby. We append "|label" so it matches the id that
       * is on the oj-label's label element.
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       */
      _labelledByUpdatedForSet: LabeledByUtils._labelledByUpdatedForSet,

      /**
       * Returns a jquery object that is a set of elements that are input type checkbox
       * and have the name of the first checkbox found.
       *
       * @return {jQuery} jquery object of all the checkboxes within the root dom element
       * that have the same 'name' attribute as the first checkbox found.
       * @private
       * @memberof oj.ojCheckboxset
       */
      _findCheckboxesWithMatchingName: function () {
        var allcheckboxes;
        var $first = this.element.find('input[type=checkbox]:first');
        var name;
        var selector;

        if ($first.length === 0) {
          Logger.warn('Could not find any input type=checkbox within this element');
        }
        // get the name attribute of the first input checkbox
        name = $first.attr('name');
        // find all input checkboxes with matching name
        if (name === undefined) {
          // search for all checkboxes with no name
          allcheckboxes = this.element.find('input[type=checkbox]');
          // now loop and find the ones without 'name' attribute
          return allcheckboxes.not('[name]');
        }

        // search for all checkboxes with the name
        selector = 'input[type=checkbox][name="' + name + '"]';
        return this.element.find(selector);
      },

      // Override to set custom launcher
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        // Setting the launcher to the first tabbable checkbox in the set.
        // Component owner should feel free to specify a different launcher if appropriate,
        // e.g. could specify the "current" checkbox rather than the first if desired.
        // See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
        var launcher = this.element.find('input[type=checkbox]:tabbable').first();
        this._OpenContextMenu(event, eventType, { launcher: launcher });
      },
      // Override to set launcher to widget
      _GetMessagingLauncherElement: function () {
        // focus events only get triggered on input, but they do bubble up and we will capture them
        // on the widget.
        // mouseenter events get called once once if the user hovers over for the entire widget. if
        // we put it on the inputs, it gets called every time you leave and enter a new input. Plus,
        // this doesn't work when we hide the input like we do in the native themes.
        return this.widget();
      },
      /**
       * _setup is called on create and refresh. Use the disabled option to
       * update the component. If the component's option is disabled, then
       * leave it alone.
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       */
      _setup: function () {
        // at this point we already have this.$checkboxes set to a list of checkboxes for this
        // checkboxset
        this._propagateDisabled(this.options.disabled);

        if (this.$checkboxes !== null) {
          if (this.$checkboxes.length === 1) {
            this.element.addClass('oj-checkboxset-single');
          } else {
            this.element.removeClass('oj-checkboxset-single');
          }
        }

        // add to the root dom the style class 'oj-read-only'
        if (this.options.readOnly) {
          this.element.addClass('oj-read-only');
        } else {
          this.element.removeClass('oj-read-only');
        }

        // add to the root dom the style class 'oj-choice-direction-column'
        // if there isn't already a 'oj-choice-direction-row' or 'oj-choice-direction-column' there.
        if (
          !this.element.hasClass('oj-choice-direction-column') &&
          !this.element.hasClass('oj-choice-direction-row')
        ) {
          this.element.addClass('oj-choice-direction-column');
        }
        this._refreshRequired(this.options.required);
        var widget = this.widget();
        this._labelledByUpdatedForSet(widget[0].id, null, this.options.labelledBy, widget);
      },
      _events: {
        change: function (event) {
          this._HandleChangeEvent(event);
        },
        'click .oj-choice-item': function (event) {
          if (
            !this.widget()[0].classList.contains('oj-choice-direction-row') &&
            event.target.tagName !== 'INPUT'
          ) {
            $(event.target).find('input').click();
          }
        }
      },
      /**
       * If value is undefined or null, set it to the default value, which is [].
       * Else, confirm it is an Array and throw an error if it isn't.
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       * @param {Object|null|undefined} value the value to check
       * @throws new Error if value (undefined is converted to an []) isn't an Array
       */
      _checkValueType: function (value) {
        // if value is undefined or null, set it to its default value [].
        if (value == null) {
          this.option('value', [], { _context: { writeback: true, internalSet: true } });
        } else {
          this._confirmValueIsArray(value);
        }
      },
      /**
       * Confirm value is an Array.
       * @memberof oj.ojCheckboxset
       * @instance
       * @private
       * @param {Object|null|undefined} value the value to check
       * @throws new Error if value isn't an Array
       */
      _confirmValueIsArray: function (value) {
        if (!Array.isArray(value)) {
          throw new Error(
            "Invalid 'value' set on JET Checkboxset: " + value + '.It must be an Array. '
          );
        }
      },

      /**
       * @param {Event} event DOM event
       * @override
       * @protected
       * @memberof oj.ojCheckboxset
       */
      _HandleChangeEvent: function (event) {
        var submittedValue;
        var checkboxes;

        // keep oj-selected in sync with the input element's checked state
        checkboxes = this.$checkboxes;
        if (checkboxes.length > 0) {
          checkboxes.each(function () {
            if (this === event.target) {
              // the target is one of the checkboxes. Update the oj-selected class to keep it
              // in sync with the input's HTML checked attribute
              $(this)._ojRadioCheckbox('setSelectedClass', event.target.checked);
            }
          });
        }
        // run full validation. There is no need to check if values have changed
        // since for checkboxset/radioset if we get into this function we know value has changed.
        // passing in doValueChangeCheck: false will skip the new-old value comparison
        submittedValue = this._GetDisplayValue();
        this._SetValue(submittedValue, event, _sValueChangeCheckFalse);
      },

      /**
       * Returns the display value that is ready to be passed to the converter.
       *
       * @param {Object} value the stored value if available that needs to be formatted for display
       * @override
       * @protected
       * @memberof oj.ojCheckboxset
       */
      _GetDisplayValue: function (
        // eslint-disable-next-line no-unused-vars
        value
      ) {
        // return the value of the 'checked' checkboxes
        return this._GetElementValue();
      },
      /**
       * Called when the display value on the element needs to be updated
       * as a result of a value change.
       * ojCheckboxset stores an Array value, and this value matches the values
       * of the currently checked checkboxes. So, if we need to set the display value,
       * what this means is we need to 'check' the checkboxes whose values match the
       * displayValue and 'uncheck' those that don't.
       *
       * @param {Array} displayValueArray an Array of values that need to be checked, e.g., ["red","blue"].
       *  Any checkbox in the checkboxset that doesn't match one of the checkBoxes needs to be unchecked
       *  if it isn't already.
       * @override
       * @protected
       * @throws new Error if displayValueArray is not an Array
       * @memberof oj.ojCheckboxset
       */
      _SetDisplayValue: function (displayValueArray) {
        var i;
        var length = this.$checkboxes.length;
        var optionValue;
        var checkbox;
        var $checkbox;

        this._checkValueType(displayValueArray);

        // If it is empty or not an array, then set all the _ojRadioCheckboxes's checked option to false.
        // _GetDisplayValue gets the checked options and creates an Array from it.
        if (
          displayValueArray === null ||
          displayValueArray === undefined ||
          displayValueArray.length === 0
        ) {
          this.$checkboxes._ojRadioCheckbox('option', 'checked', false);
        } else {
          // go through each _ojRadioCheckbox and see if it needs to be checked or unchecked.
          for (i = 0; i < length; i++) {
            checkbox = this.$checkboxes[i];
            $checkbox = $(checkbox);
            optionValue = this._GetOptionValue(checkbox);
            // does the checkbox's value exist in the checkedBoxes array?
            var index = this._GetOptionIndex(displayValueArray, optionValue);
            var checked = $checkbox._ojRadioCheckbox('option', 'checked');

            if (index !== -1) {
              // yes. this needs to be checked, if it isn't already
              if (!checked) {
                $checkbox._ojRadioCheckbox('option', 'checked', true);
              }
            } else if (checked) {
              // no. this needs to be unchecked, if it isn't already
              $checkbox._ojRadioCheckbox('option', 'checked', false);
            }
          }
        }
      },
      /**
       * Returns the element's value. Normally, this is a call to this.element.val(),
       * but in the case of ojCheckboxset, the element's value is really the value
       * of the checked checkboxes in the set.
       * @override
       * @protected
       * @memberof oj.ojCheckboxset
       * @return {Array} An Array<any> of selected values or the empty array [] if nothing selected.
       */
      _GetElementValue: function () {
        // "input:checked" selects checkboxes that are currently checked as
        // reflected in their boolean (true or false) checked property,
        // which is affected when the user clicks the checkbox for example.
        // for checkboxset, there will be zero or more checked;
        var self = this;
        var checkedValues = [];
        var selectedCheckboxes = this.$checkboxes.filter(':checked');

        if (selectedCheckboxes.length === 0) {
          return [];
        }

        selectedCheckboxes.each(function () {
          checkedValues.push(self._GetOptionValue(this));
        });
        return checkedValues;
      },

      /**
       * Returns the index of the array that matches the optionValue. First check
       * equality with ===, then if not found, check with deep compare,
       * oj.Object.compareValues(), because values can be objects or arrays.
       * @override
       * @protected
       * @memberof oj.ojCheckboxset
       */
      _GetOptionIndex: function (optionValueArray, optionValue) {
        // Find the matching value via === comparison that indexOf uses
        var matchIndex = optionValueArray.indexOf(optionValue);
        var length;

        // If not found via indexOf(), do a deep equals compare
        if (matchIndex === -1) {
          length = optionValueArray.length;
          for (var i = 0; i < length; i++) {
            if (oj.Object.compareValues(optionValueArray[i], optionValue)) {
              matchIndex = i;
              break;
            }
          }
        }

        return matchIndex;
      },
      /**
       * For custom element, we get the value from the oj-option element, otherwise
       * we get the value from the checkbox element.
       * @override
       * @protected
       * @memberof oj.ojCheckboxset
       * @return {any} Returns the value property of the associated oj-option, or the value attribute of the checkbox element.
       */
      _GetOptionValue: function (checkboxElem) {
        var option;
        var val;

        if (this._IsCustomElement()) {
          option = document.getElementById(checkboxElem.getAttribute('data-oj-option-id'));

          if (option) {
            val = option.value;
          }
        } else {
          val = checkboxElem.value;
        }

        return val;
      },

      /**
       * Returns the default styleclass for the component. Currently this is
       * used to pass to the ojLabel component, which will append -label and
       * add the style class onto the label. This way we can style the label
       * specific to the input component. For example, for inline labels, the
       * checkboxset/checkboxset components need to have margin-top:0, whereas all the
       * other inputs need it to be .5em. So we'll have a special margin-top style
       * for .oj-label-inline.oj-checkboxset-label
       * All input components must override
       *
       * @return {string}
       * @memberof oj.ojCheckboxset
       * @override
       * @protected
       */
      _GetDefaultStyleClass: function () {
        return 'oj-checkboxset';
      },
      /**
       * Returns a jquery object of the elements representing the content nodes (checkboxes/labels).
       * @protected
       * @override
       * @memberof oj.ojCheckboxset
       */
      _GetContentElement: function () {
        if (this.$checkboxes != null) {
          return this.$checkboxes;
        }

        this.$checkboxes = this._findCheckboxesWithMatchingName();
        return this.$checkboxes;
      },

      /**
       * Called to find out if aria-required is unsupported. This is needed for the label.
       * It is not legal to have aria-required on radio/checkboxes, nor on
       * radiogroup/group.
       * If aria-required is not supported, then we wrap the required icon as well as the
       * help icons so that JAWS can read required. We don't do this for form controls that use
       * aria-required because if we did JAWS would read required twice.
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       * @return {boolean}
       */
      _AriaRequiredUnsupported: function () {
        return true;
      },

      /**
       * This is called from InlineHelpHintsStrategy to determine
       * the location of the inline help hints, above the component
       * or below.
       * @ignore
       * @protected
       * @override
       * @memberof oj.ojCheckboxset
       * @return {'above'|'inline'}
       */
      _ShowHelpHintsLocation: function () {
        return 'above';
      },

      /**
       * Performs post processing after required option is set by taking the following steps.
       *
       * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
       * run full validation with UI value (we don't know if the UI error is from a required validator
       * or something else);<br/>
       * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
       * updated<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to optionChange(value) to clear custom errors.<br/>
       *
       * - if component is invalid and has messagesHidden -> required: false -> clear component
       * errors; no deferred validation is run.<br/>
       * - if component has no error -> required: true -> run deferred validation (we don't want to flag
       * errors unnecessarily)<br/>
       * - messagesCustom is never cleared<br/>
       *
       * @param {string} option
       *
       * @memberof oj.ojCheckboxset
       * @instance
       * @protected
       */
      _AfterSetOptionRequired: ojeditablevalue.EditableValueUtils._AfterSetOptionRequired,

      /**
       *
       * @param {boolean} _disabled
       * @private
       * @memberof oj.ojCheckboxset
       */
      _propagateDisabled: function (_disabled) {
        var disabled = !!_disabled;
        this.$checkboxes.each(function () {
          // this is the technique to use to call package-private functions
          // Calling it like this.$radios.ojRadioCheckbox("__setAncestorComponentDisabled",value)
          // gives an error because jquery prevents you from calling functions with an "_"
          //
          // This is how we handle 'disabled' for the checkboxset. We don't change the radiocheckbox
          // component's disabled option ever since if we do that we've lost what the initial disabled
          // state is (we store the disabled dom value from the radio into its disabled option)
          // and we need that when we refresh. Instead what we do
          // is we mark if its ancestor (the checkboxset) is disabled or not. Then, when we render
          // out the checkboxes 'disabled' state, like oj-disabled, we look to see if it is 'effectively
          // disabled' (see _IsEffectivelyDisabled call in ojRadioCheckbox), that is if its
          // option is disabled OR its ancestor (the checkboxset) is disabled.
          $(this).data('oj-_ojRadioCheckbox').__setAncestorComponentDisabled(disabled);
        });

        this.$checkboxes._ojRadioCheckbox('refreshDisabled'); // re-render disabled
      },

      /**
       * Updates the component's state based on whether or not it is in the readonly
       * state.
       * @private
       * @memberof! oj.ojCheckboxSet
       */
      _updateReadonlyState: function () {
        const wrapperDom = this.element[0].querySelector('.oj-checkboxset-wrapper');
        if (this.options.readOnly) {
          wrapperDom.setAttribute('tabindex', this._externalTabIndex);
          this.element.addClass('oj-read-only');

          // JET-49297 - reassess accessibility implementation of 'readonly' checkboxset
          // In readonly mode, we will not have any checkbox input in the visible DOM. Thus,
          // in this state it will just be showing generic text based on the value selected.
          // So, we need to clean up the role along with the aria-labelledby attributes we added
          // for that role to make things accessible.
          this.element.removeAttr('role').removeAttr('aria-labelledby');
          return;
        }

        // remove tabindex and role
        wrapperDom.removeAttribute('tabindex');
        this.element.removeClass('oj-read-only');

        // JET-49297 - reassess accessibility implementation of 'readonly' checkboxset
        // add back the role and aria attributes removed before
        this.element.attr('role', 'group');
        this._labelledByUpdatedForSet(
          this.widget()[0].id,
          null,
          this.options.labelledBy,
          this.widget()
        );
      },

      /**
       * @override
       * @private
       * @memberof oj.ojCheckboxset
       */
      _setOption: function (key, value, flags) {
        var originalValue = this.options.labelledBy;
        this._super(key, value, flags);

        switch (key) {
          case 'disabled':
            this._propagateDisabled(value);
            break;
          case 'readOnly':
            this.options.readOnly = !!value;
            var val = this.options.value;
            this._updateReadonlyState();
            this._ResetComponentState();
            // when toggle readonly to false, we need to check the initial set values.
            if (val != null) {
              this._SetDisplayValue(val);
            }
            break;
          case 'value':
            this._processOjOptions();
            break;
          case 'labelledBy':
            // remove the old one and add the new one
            var widget = this.widget();
            this._labelledByUpdatedForSet(widget[0].id, originalValue, value, widget);
            break;
          case 'options':
            oj.RadioCheckboxUtils.generateOptionsFromData.call(this);
            break;
          case 'optionsKeys':
          case 'optionRenderer':
            oj.RadioCheckboxUtils.renderOptions.call(this);
            break;
          default:
            break;
        }
      },

      /**
       * Performs post processing after _SetOption() is called. Different options when changed perform
       * different tasks. See _AfterSetOption[OptionName] method for details.
       *
       * @param {string} option
       * @param {Object|string=} previous
       * @param {Object=} flags
       * @protected
       * @memberof oj.ojCheckboxset
       * @instance
       * @override
       */
      // eslint-disable-next-line no-unused-vars
      _AfterSetOption: function (option, previous, flags) {
        this._superApply(arguments);
        switch (option) {
          case 'required':
            this._AfterSetOptionRequired(option);
            break;
          default:
            break;
        }
      },

      getNodeBySubId: function (locator) {
        var node = this._super(locator);
        var checkboxes;
        var subId;
        var value;

        if (!node) {
          checkboxes = this.$checkboxes.get();
          subId = locator.subId;

          switch (subId) {
            case 'oj-checkboxset-inputs': // TODO: deprecated for a while now, remove this in 4.0.0
              node = checkboxes;
              break;

            case 'oj-checkboxset-checkbox':
              // We find these by the value attribute on the input element, which is
              // much more stable that using an index.
              value = locator.value;

              if (typeof value !== 'undefined') {
                var arrayLength = checkboxes.length;
                var i;
                var matchIndex = -1;
                var checkboxValues = [];

                // Build the values array
                for (i = 0; i < arrayLength; i++) {
                  checkboxValues[i] = this._GetOptionValue(checkboxes[i]);
                }

                // Find the index of the matching value.
                matchIndex = this._GetOptionIndex(checkboxValues, value);

                if (matchIndex !== -1) {
                  node = checkboxes[matchIndex];
                }
              }
              break;
            default:
              break;
          }
        }
        // Non-null locators have to be handled by the component subclasses
        return node || null;
      },

      getSubIdByNode: function (node) {
        var topElem = this._GetContentElement()[0].parentElement.parentElement.parentElement;
        var currentNode = node;

        while (currentNode && currentNode !== topElem) {
          if (currentNode.nodeName === 'LABEL') {
            currentNode = document.getElementById(currentNode.for);
          }

          if (currentNode.nodeName === 'INPUT') {
            return { subId: 'oj-checkboxset-checkbox', value: this._GetOptionValue(currentNode) };
          }

          currentNode = currentNode.parentElement;
        }

        return this._super(node);
      },

      /**
       * @ignore
       * @protected
       * @memberof oj.ojCheckboxset
       * @override
       */
      _destroy: function () {
        var ret = this._super();
        var wrapperDom = this.element[0].firstElementChild;

        if (this.$checkboxes) {
          this.$checkboxes._ojRadioCheckbox('destroy');
        }

        // remove the dom we added to wrap the children of this.element, but don't remove the children.
        $(wrapperDom).contents().unwrap();

        oj.RadioCheckboxUtils.removeDataListener.call(this);

        return ret;
      }
    });
  })();

});


define('ojs/ojradioset',['ojs/ojcore', 'jquery', 'ojs/ojcomponentcore', 'ojs/ojeditablevalue', 'ojs/ojradiocheckbox', 'ojs/ojoption', 'ojs/ojdataprovider', 'ojs/ojcore-base', 'ojs/ojlogger', 'ojs/ojlabelledbyutils'], function (ojcore, $, ojcomponentcore, ojeditablevalue, ojradiocheckbox, ojoption, ojdataprovider, oj, ojlogger, LabeledByUtils) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  LabeledByUtils = LabeledByUtils && Object.prototype.hasOwnProperty.call(LabeledByUtils, 'default') ? LabeledByUtils['default'] : LabeledByUtils;

  (function () {
var __oj_radioset_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "optionRenderer": {
      "type": "function"
    },
    "options": {
      "type": "object"
    },
    "optionsKeys": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "readonlyNoValue": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "any",
      "writeback": true
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    __oj_radioset_metadata.extension._WIDGET_NAME = 'ojRadioset';
    __oj_radioset_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    __oj_radioset_metadata.extension._TRACK_CHILDREN = 'immediate';
    oj.CustomElementBridge.register('oj-radioset', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_radioset_metadata, {
        properties: {
          readonly: {
            binding: { consume: { name: 'readonly' } }
          },
          userAssistanceDensity: {
            binding: { consume: { name: 'userAssistanceDensity' } }
          },
          labelEdge: {
            binding: { consume: { name: 'labelEdge' } }
          }
        }
      })
    });
  })();

  (function () {
    /*!
     * JET Radioset @VERSION
     */

    // -----------------------------------------------------------------------------
    // "private static members" shared by all radiosets
    // -----------------------------------------------------------------------------

    //  do not do a value change check in _SetValue

    var _sValueChangeCheckFalse = { doValueChangeCheck: false };

    /**
     * @ojcomponent oj.ojRadioset
     * @augments oj.editableValue
     * @ojimportmembers oj.ojDisplayOptions
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojRadioset<K, D, V=any> extends editableValue<V, ojRadiosetSettableProperties<K, D, V>>",
     *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"},
     *                {"name": "V", "description": "Type of value of the component"}]
     *               },
     *               {
     *                target: "Type",
     *                value: "ojRadiosetSettableProperties<K, D, V> extends editableValueSettableProperties<V>",
     *                for: "SettableProperties"
     *               }
     *              ]
     * @since 0.6.0
     * @ojshortdesc A radio set allows the user to select one option from a set of mutually exclusive options.
     * @ojrole radio
     * @ojrole radiogroup
     * @ojrole option
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "required", "disabled"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 6
     * @ojvbmincolumns 2
     *
     * @ojoracleicon 'oj-ux-ico-radio-button-set'
     * @ojuxspecs ['radioset']
     *
     * @ojdeprecated [
     *   {
     *     type: "maintenance",
     *     since: "16.0.0",
     *     value: ["oj-c-radioset"]
     *   }
     * ]
     *
     *
     * @classdesc
     * <h3 id="radiosetOverview-section">
     *   JET Radioset
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#radiosetOverview-section"></a>
     * </h3>
     * <p>
     * The JET oj-radioset component manages a set of
     * <code class="prettyprint">oj-option</code> child elements and creates the necessary dom elements for
     * the actual radio buttons.
     * </p>
     * <p>To use an oj-radioset, add one or more oj-option child elements for each radio button desired.
     * Note, if you add or remove an oj-option after the oj-radioset is rendered, you should call
     * refresh() on the oj-radioset.
     * Note, oj-optgroup is not a supported child element of oj-radioset.
     * </p>
     * <p>The child content can be configured via inline HTML content or a DataProvider.
     * It is recommended that inline HTML content should only be used for static data and the DataProvider should always be used for mutable data.
     * </p>
     * <p>A JET Radio Set can be created with the following markup.</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-radioset>
     *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
     *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
     *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
     *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
     * &lt;/oj-radioset>
     * </code></pre>
     * <p>A JET Radio Set can be created with a DataProvider.</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-radioset options="[[dataprovider]]">
     * &lt;/oj-radioset>
     * </code></pre>
     * <p>
     *  You can enable and disable an oj-radioset,
     *  which will enable and disable all contained radios.
     * </p>
     * <p>
     *  You can set an oj-radioset to readonly,
     *  which will make the options readonly and only selected option's label will be displayed.
     * </p>
     *
     * {@ojinclude "name":"validationAndMessagingDoc"}
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET oj-radioset takes care of setting
     * <code class="prettyprint">role="radiogroup"</code> on the oj-radioset element.
     *
     * <p>
     * {@ojinclude "name":"accessibilitySetLabelEditableValue"}
     * {@ojinclude "name":"accessibilityDisabledEditableValue"}
     * </p>
     *
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     *
     * <p>
     * To migrate from oj-radioset to oj-c-radioset, you need to revise the import statement
     * and references from oj-radioset to oj-c-radioset in your app. For instance if your application imported <code>ojs/ojradioset</code> this needs to be
     * updated to <code>oj-c/radioset</code>.
     * Please note the following changes between the two components below.
     * </p>
     *
     * <h5>options attribute</h5>
     * <p>
     * The <code>options</code> attribute is the only way to provide data to the new oj-c-radioset component. Adding <code>oj-option</code>
     * child elements inline is not supported anymore.
     * Besides maintaining its support for DataProvider, the <code>options</code> attribute also accepts an Array of data items.
     * Regardless of the type used for this attribute (whether it's a DataProvider implementation or an Array of data items)
     * the "label" property is required. In the DataProvider case, the "key" of the DataProvider will be used as
     * the radio item value. The "label" property will provide the text for the radio item.
     * </p>
     * <h5>label-edge attribute</h5>
     * <p>
     * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
     * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
     * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
     * attribute to the corresponding value.
     * </p>
     *
     * <h5>option-renderer attribute</h5>
     * <p>
     * The <code>option-renderer</code> attribute is not supported anymore and was removed from <code>oj-c-radioset</code>.
     * The item label text must be provided directly through the <code>options</code> data.
     * </p>
     * <h5>options-keys attribute</h5>
     * <p>
     * The <code>options-keys</code> attribute is no longer supported and was removed from <code>oj-c-radioset</code>.
     * This attribute was used to map an arbitrary DataProvider data item signature to a label and value. The application can instead wrap their
     * DataProvider implementation in a <a href="ListDataProviderView.html">ListDataProviderView</a> with data mapping to match
     * the data shape required by <code>oj-c-radioset</code>.
     * </p>
     * <h5>readonly radioset visual appearance</h5>
     * <p>
     * A readonly oj-c-radioset will render all radio items, with an OK check mark for the selected item. This is
     * different from oj-radioset where only the selected radio item was rendered.
     * </p>
     *
     * <h5>messages-custom attribute</h5>
     * <p>
     * The type of the <code class="prettyprint">severity</code> property of the messages in the
     * array has changed from
     * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
     * (essentially <code class="prettyprint">string | number</code>), to simply
     * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
     * values are the same as the previously supported string values.
     * The application can no longer specify severity as a number, including hardcoded numbers,
     * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
     * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
     * </p>
     *
     * <h5>Removed style classes</h5>
     * <p>
     * The usage of the style classes: oj-choice-direction-column, oj-choice-direction-row that would affect the row or column
     * orientation of the radioset are now replaced with the <code>direction</code> attribute. The value of this attribute
     * maps to these style classes as shown below:
     * <ul>
     * <li>
     * .oj-choice-direction-column maps to 'column'
     * </li>
     * <li>
     * .oj-choice-direction-row maps to 'row'
     * </li>
     * </ul>
     * </p>
     * <p>
     * The following style classes were removed from oj-c-radioset without having a mapping to a new attribute:
     * <ul>
     * <li>
     * .oj-radioset-input-end
     * </li>
     * <li>
     * .oj-radioset-input-start
     * </li>
     * <li>
     * .oj-radioset-no-chrome
     * </li>
     * </ul>
     * </p>
     * <h5>translations attribute</h5>
     * <p>
     * The translations.required.message-detail attribute has changed to required-message-detail.
     * </p>
     *
     * <h5>refresh method</h5>
     * <p>
     * The refresh method is no longer supported. The application should no longer need to use this method. If the application
     * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
     * </p>
     *
     * <h5>reset method</h5>
     * <p>
     * This method does not synchronously reset the component. The application should wait on the busy context of the component after
     * invoking this method for the changes to appear.
     * </p>
     *
     * <h5>showMessages method</h5>
     * <p>
     * This method does not synchronously show the hidden messages of the component. The application should wait on the busy context
     * of the component after invoking this method for the changes to appear.
     * </p>
     *
     * <h5>Custom Label</h5>
     * <p>
     * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
     * label-hint attribute to add a label for the form component.
     * </p>
     * <p>
     * The application should no longer need to use an &lt;oj-label-value> component to layout the form component. The application
     * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
     * </p>
     *
     * <h5>DescribedBy attribute</h5>
     * <p>
     * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
     * This attribute is not carried forward to the core pack component.
     * </p>
     *
     * <h5>display-options attribute</h5>
     * <p>
     * The <code>display-options</code> attribute only supports the messages sub-property, <code>converter-hint</code> and <code>validator-hint</code> sub-properties were removed.
     * </p>
     *
     * <h5>Formatted messages</h5>
     * <p>
     * Formatting messages using html tags is not supported in the core pack component.
     * </p>
     *
     * <h5>Usage in Dynamic Form</h5>
     * <p>
     * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
     * </p>
     *
     * @example <caption>Initialize the radioset with no options specified:</caption>
     * &lt;oj-radioset id="colorRadio" value="{{currentColor}}">
     *   &lt;oj-option value="blue">Blue&lt;/oj-option>
     *   &lt;oj-option value="green">Green&lt;/oj-option>
     * &lt;/oj-radioset>
     *
     * @example <caption>Initialize component and an associated oj-label component</caption>
     * &lt;oj-label id="grouplabel">Greetings&lt;/oj-label>
     * &lt;oj-radioset id="radioset" labelle-dby="grouplabel" value="{{currentGreeting}}">
     *   &lt;oj-option id="helloid" value="hello">Hello&lt;/oj-option>
     *   &lt;oj-option id="bonjourid" value="bonjour"/>Bonjour&lt;/oj-option>
     *   &lt;oj-option id="ciaoid" value="ciao"/>Ciao&lt;/oj-option>
     * &lt;oj-radioset>
     * <br/>
     * // set the value to "ciao". (The 'ciao' radio will be selected)
     * myComp.value = "ciao";
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the radioset's radios.</p>
     *
     * @ojsubid oj-radioset-inputs
     * @deprecated 3.0.0 Since the application supplies the input elements, it can supply a unique ID by which the input elements can be accessed.
     * @ignore
     * @memberof oj.ojRadioset
     *
     * @example <caption>Get the nodes for the radios:</caption>
     * var nodes = $( ".selector" ).ojRadioset( "getNodeBySubId", {'subId': 'oj-radioset-inputs'} );
     */

    //-----------------------------------------------------
    //                   Slots
    //-----------------------------------------------------

    /**
     * <p>The &lt;oj-radioset> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
     * accepted children and slots.</p>
     *
     * @ojchild Default
     * @memberof oj.ojRadioset
     * @ojshortdesc The oj-radioset element accepts oj-option elements as children.
     * @ojpreferredcontent ["OptionElement"]
     *
     * @example <caption>Initialize the Radioset with child content specified:</caption>
     * &lt;oj-radioset>
     *   &lt;oj-option value="radio1">Radio 1&lt;/oj-option>
     *   &lt;oj-option value="radio2">Radio 2&lt;/oj-option>
     *   &lt;oj-option value="radio3">Radio 3&lt;/oj-option>
     * &lt;/oj-radioset>
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Select the input. In some themes, the input is not visible,
     *       so you will tap on the label.</td>
     *     </tr>
     *     <tr>
     *       <td>Input's label</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Select the corresponding input.</td>
     *     </tr>
     *     <tr>
     *       <td>Input or Label</td>
     *       <td><kbd>Press & Hold</kbd></td>
     *       <td>If hints, help.instruction or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *    </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojRadioset
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="2">Input</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Select the previous input in the group.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Select the next input in the group.</td>
     *     </tr>
     *     <tr>
     *       <td>Radioset</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the checked radio input. If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojRadioset
     */

    //-----------------------------------------------------
    //                   Styles
    //-----------------------------------------------------

    // ---------------- oj-choice-direction-column --------------
    /**
     * This is the default. It lays out the radios in a column.
     * @ojstyleclass oj-choice-direction-column
     * @ojdisplayname Column Layout
     * @memberof oj.ojRadioset
     * @ojtsexample
     * &lt;oj-radioset id="radiosetId" class='oj-choice-direction-column'>
     * &lt;/oj-radioset>
     */
    // ---------------- oj-choice-direction-row --------------
    /**
     * It lays out the radios in a row.
     * @ojstyleclass oj-choice-direction-row
     * @ojdisplayname Row Layout
     * @memberof oj.ojRadioset
     * @ojtsexample
     * &lt;oj-radioset id="radiosetId" class='oj-choice-direction-row'>
     * &lt;/oj-radioset>
     */
    // ---------------- oj-radioset-no-chrome --------------
    /**
     * Use this styleclass if you don't want the chrome around the set.
     * @ojstyleclass oj-radioset-no-chrome
     * @ojdisplayname No Chrome
     * @memberof oj.ojRadioset
     * @ojtsexample
     * &lt;oj-radioset id="radiosetId" class='oj-radioset-no-chrome'>
     * &lt;/oj-radioset>
     */
    // ---------------- oj-radioset-input-start --------------
    /**
     * Use this styleclass to order the radio at the start and label text at the end even if a theme has a different default order.
     * @ojstyleclass oj-radioset-input-start
     * @ojdisplayname Input Start
     * @memberof oj.ojRadioset
     * @ojtsexample
     * &lt;oj-radioset id="radiosetId" class='oj-radioset-input-start'>
     * &lt;/oj-radioset>
     */
    // ---------------- oj-radioset-input-end --------------
    /**
     * Use this styleclass to order the radio at the end and the label text at the start even if a theme has a different default order.
     * @ojstyleclass oj-radioset-input-end
     * @ojdisplayname Input End
     * @memberof oj.ojRadioset
     * @ojtsexample
     * &lt;oj-radioset id="radiosetId" class='oj-radioset-input-end'>
     * &lt;/oj-radioset>
     */
    // --------------------------------------------------- oj.ojRadioset Styling End -----------------------------------------------------------

    oj.__registerWidget('oj.ojRadioset', $.oj.editableValue, {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',

      /**
       * @expose
       * @private
       */
      _WRAPPER_CLASS_NAMES: 'oj-radioset-wrapper oj-form-control-container',

      options: {
        /**
         * <p>
         * Disabled <code class="prettyprint">true</code> disables the component and disables all the
         * inputs/labels.
         * Disabled <code class="prettyprint">false</code> enables the component, and leaves the
         * inputs' <code class="prettyprint">disabled</code> property as it is in the dom.
         * <p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">disabled</code> attribute:</caption>
         * &lt;oj-radioset disabled>
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-radioset>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabled = myComp.disabled;
         *
         * // setter
         * myComp.disabled = false;
         *
         * @expose
         * @type {boolean}
         * @default false
         * @public
         * @instance
         * @memberof oj.ojRadioset
         * @ojshortdesc Specifies if the component is disabled. If true, then all of its inputs and labels are also disabled. See the Help documentation for more information.
         */
        disabled: false,
        /**
         * Whether the component is readonly. The readonly property sets or returns whether an element is readonly, or not.
         * A readonly element cannot be modified. However, a user can tab to it, highlight it, focus on it, and copy the text from it.
         * If you want to prevent the user from interacting with the element, use the disabled property instead.
         * <p>
         * The default value for readonly is false. However, if the form component is a descendent of
         * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
         * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
         * The <code class="prettyprint">oj-form-layout</code> uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">readonly</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the readonly property if an ancestor provides it and
         * it is not explicitly set.
         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
         * not have its readonly attribute set, the form component's readonly will be true.
         * </p>
         * @example <caption>Initialize component with <code class="prettyprint">readonly</code> attribute:</caption>
         * &lt;oj-radioset readonly>&lt;/oj-radioset>
         *
         * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
         * // Getter
         * var readonly = myComponent.readonly;
         *
         * // Setter
         * myComponent.readonly = false;
         *
         * @default false
         * @ojshortdesc Specifies whether the component is read-only. A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
         * @access public
         * @expose
         * @type {?boolean}
         * @name readonly
         * @instance
         * @memberof oj.ojRadioset
         */
        readOnly: false,
        /**
         * It is used to establish a relationship between this component and another element.
         * A common use is to tie the oj-label and the oj-radioset together for accessibility.
         * The oj-label custom element has an id, and you use the labelled-by attribute
         * to tie the two components together to facilitate correct screen reader behavior.
         *
         * @example <caption>Initialize component with <code class="prettyprint">labelled-by</code> attribute:</caption>
         * &lt;oj-label id="labelId">Name:&lt;/oj-label>
         * &lt;oj-radioset labelled-by="labelId">
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-radioset>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var disabled = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         *
         * @expose
         * @type {string|null}
         * @public
         * @instance
         * @memberof oj.ojRadioset
         * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documentation for more information.
         */
        labelledBy: null,

        /**
         * @typedef {Object} oj.ojRadioset.OptionContext
         * @property {Element} component A reference to the Radioset element.
         * @property {number} index The index of the option, where 0 is the index of the first option.
         * @property {Object} data The data object for the option.
         * @ojsignature [{target:"Type", value:"<D>", for:"genericTypeParameters"},
         *               {target:"Type", value:"D", for:"data"}]
         */
        /**
         * {@ojinclude "name":"radiosetCommonOptionRenderer"}
         * @name optionRenderer
         * @ojshortdesc The renderer function that renders the content of each option.
         * @expose
         * @memberof oj.ojRadioset
         * @instance
         * @type {null|function(Object):Object}
         * @ojsignature { target: "Type",
         *                value: "?((param0: oj.ojRadioset.OptionContext<D>) => Element)|null",
         *                jsdocOverride: true}
         * @default null
         * @example <caption>Initialize the radioset with a renderer:</caption>
         * &lt;oj-radioset option-renderer="[[optionRenderer]]">&lt;/oj-radioset>
         * @example var optionRenderer = function(context) {
         *            var ojOption = document.createElement('oj-option');
         *            // Set the textContent or append other child nodes
         *            ojOption.textContent = context.data['FIRST_NAME'] + ' ' + context.data['LAST_NAME'];
         *            return ojOption;
         *          };
         */
        /**
         * The renderer function that renders each option.
         * The function should return an oj-option element.
         * <p>It is not necessary to set the "value" attribute on the oj-option as it is available from the options data.</p>
         * <p>
         * See <a href="#options">options</a>
         * and <a href="#optionsKeys">options-keys</a> for configuring option label and value.
         * </p>
         *
         * <p>The context parameter passed to the renderer contains the following keys:</p>
         * <table class="keyboard-table">
         *   <thead>
         *     <tr>
         *       <th>Key</th>
         *       <th>Description</th>
         *     </tr>
         *   </thead>
         *   <tbody>
         *     <tr>
         *       <td><kbd>component</kbd></td>
         *       <td>A reference to the Radioset element.</td>
         *     </tr>
         *     <tr>
         *       <td><kbd>index</kbd></td>
         *       <td>The index of the option, where 0 is the index of the first option.</td>
         *     </tr>
         *     <tr>
         *       <td><kbd>data</kbd></td>
         *       <td>The data object for the option.</td>
         *     </tr>
         *   </tbody>
         * </table>
         *
         * @expose
         * @memberof oj.ojRadioset
         * @instance
         * @ojfragment radiosetCommonOptionRenderer
         */
        optionRenderer: null,

        /**
         * @typedef {Object} oj.ojRadioset.Option
         * @property {boolean=} disabled Option item is disabled.
         * @property {string=} label The display label for the option item. If it's missing, string(value) will be used.
         * @property {any} value The value of the option item.
         */
        /**
         * {@ojinclude "name":"radiosetCommonOptions"}
         *
         * @name options
         * @ojshortdesc The option items for the Radioset.
         * @expose
         * @access public
         * @instance
         * @type {Object|null}
         * @ojsignature { target: "Type",
         *                value: "DataProvider<K, D>|null",
         *                jsdocOverride: true}
         * @default null
         * @memberof oj.ojRadioset
         *
         * @example <caption>Initialize the Radioset with a data provider and data mapping:</caption>
         * &lt;oj-radioset options="[[dataProvider]]">&lt;/oj-radioset>
         *
         * @example <caption>Use simple DataProvider if data has value and label properties.</caption>
         * var dataArray = [
         *            {value: 'Id 1', label: 'Name 1'},
         *            {value: 'Id 2', label: 'Name 2'},
         *            {value: 'Id 3', label: 'Name 3'}];
         *
         * var dataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'value'});
         *
         * @example <caption>Data mapping can be used if data doesn't have value and label properties.</caption>
         * // actual field names are "id" and "name"
         * var dataArray = [
         *            {id: 'Id 1', name: 'Name 1'},
         *            {id: 'Id 2', name: 'Name 2'},
         *            {id: 'Id 3', name: 'Name 3'}];
         *
         * // In mapfields, map "name" to "label" and "id" to "value"
         * var mapFields = function(item) {
         *   var data = item['data'];
         *   var mappedItem = {};
         *   mappedItem['data'] = {};
         *   mappedItem['data']['label'] = data['name'];
         *   mappedItem['data']['value'] = data['id'];
         *   mappedItem['metadata'] = {'key': data['id']};
         *   return mappedItem;
         * };
         * var dataMapping = {'mapFields': mapFields};
         *
         * var arrayDataProvider = new oj.ArrayDataProvider(dataArray, {keyAttributes: 'id'});
         * var dataProvider = new oj.ListDataProviderView(arrayDataProvider, {'dataMapping': dataMapping});
         */
        /**
         * A data provider that returns the option items for the Radioset.
         * This attribute can be used instead of providing a list of <code class="prettyprint">oj-option</code> child elements of the Radioset element.
         * <p>This data provider must implement <a href="DataProvider.html">DataProvider</a>.
         *   <ul>
         *   <li><code class="prettyprint">value</code> in <code class="prettyprint">oj.ojRadioset.Option</code> must be the row key in the data provider.</li>
         *   <li>All rows will be displayed in the Radioset.</li>
         *   </ul>
         * </p>
         *
         * @expose
         * @memberof oj.ojRadioset
         * @instance
         * @ojfragment radiosetCommonOptions
         */
        options: null,

        /**
         * @typedef {Object} oj.ojRadioset.OptionsKeys
         * @property {?string=} label The key name for the label.
         * @property {?string=} value The key name for the value.
         */
        /**
         * {@ojinclude "name":"radiosetCommonOptionsKeys"}
         *
         * @example <caption>Initialize the Radioset with <code class="prettyprint">options-keys</code> specified. This allows the key names to be redefined in the options array.</caption>
         * &lt;oj-radioset options-keys="[[optionsKeys]]">&lt;/oj-radioset>
         * @example var optionsKeys = {value : "state_abbr", label : "state_name"};
         *
         * @name optionsKeys
         * @ojshortdesc Specify the key names to use in the options array.  Depending on options-keys means that the signature of the data does not match what is supported by the options attribute.
         * @expose
         * @access public
         * @instance
         * @type {?Object}
         * @ojsignature { target: "Type",
         *                value: "?oj.ojRadioset.OptionsKeys",
         *                jsdocOverride: true}
         * @default null
         * @memberof oj.ojRadioset
         */
        /**
         * Specify the key names to use in the options array.
         * <p>Depending on options-keys means that the signature of the data does not match what is supported by the options attribute. When using Typescript, this would result in a compilation error.</p>
         * <p>Best practice is to use a <a href="ListDataProviderView.html">oj.ListDataProviderView</a> with data mapping as a replacement.</p>
         * <p>However, for the app that must fetch data from a REST endpoint where the data fields do not match those that are supported by the options attribute, you may use the options-keys with any dataProvider that implements <a href="DataProvider.html">DataProvider</a> interface.</p>
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojRadioset
         * @ojfragment radiosetCommonOptionsKeys
         */
        optionsKeys: {
          /**
           * The key name for the label.
           *
           * @name optionsKeys.label
           * @expose
           * @public
           * @instance
           * @memberof! oj.ojRadioset
           * @type {?string}
           * @ojsignature { target: "Type",
           *                value: "?"}
           * @default null
           */
          /**
           * The key name for the value.
           *
           * @name optionsKeys.value
           * @expose
           * @public
           * @instance
           * @memberof! oj.ojRadioset
           * @type {?string}
           * @ojsignature { target: "Type",
           *                value: "?"}
           * @default null
           */
        },

        /**
         * <p>
         * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
         * This is the default.
         * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
         * </p>
         * <p>
         * In the Redwood theme, by default, a Required text is rendered inline when the field is empty.
         * If user-assistance-density is 'compact', it will show on the label as an icon.
         * In the Alta theme the input's label will render a required icon.
         * </p>
         * <p>The Required error text is based on Redwood UX designs, and it is not recommended that
         * it be changed.
         * To override the required error message,
         * use the <code class="prettyprint">translations.required</code> attribute.
         * The component's label text is passed in as a token {label} and can be used in the message detail.
         * </p>
         * <p>When required is set to true, an implicit
         * required validator is created, i.e.,
         * <code class="prettyprint">new RequiredValidator()</code>. The required validator is the only
         * validator to run during initial render, and its error is not shown to the user at this time;
         * this is called deferred validation. The required validator also runs during normal validation;
         * this is when the errors are shown to the user.
         * See the <a href="#validation-section">Validation and Messaging</a> section for details.
         * </p>
         * <p>
         * When the <code class="prettyprint">required</code> property changes due to programmatic intervention,
         * the component may clear component messages and run validation, based on the current state it's in. </br>
         *
         * <h4>Running Validation when required property changes</h4>
         * <ul>
         * <li>if component is valid when required is set to true, then it runs deferred validation on
         * the value property. If the field is empty, the valid state is invalidHidden. No errors are
         * shown to the user.
         * </li>
         * <li>if component is invalid and has deferred messages when required is set to false, then
         * component messages are cleared (messages-custom messages are not cleared)
         * but no deferred validation is run because required is false.
         * </li>
         * <li>if component is invalid and currently showing invalid messages when required is set, then
         * component messages are cleared and normal validation is run using the current display value.
         * <ul>
         *   <li>if there are validation errors, then <code class="prettyprint">value</code>
         *   property is not updated and the error is shown.
         *   </li>
         *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
         *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
         *   event on the component to clear custom errors.</li>
         * </ul>
         * </li>
         * </ul>
         *
         * <h4>Clearing Messages when required property changes</h4>
         * <ul>
         * <li>Only messages created by the component, like validation messages, are cleared when the required property changes.</li>
         * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
         * </ul>
         *
         * </p>
         *
         * @example <caption>Initialize the component with the <code class="prettyprint">required</code> attribute:</caption>
         * &lt;oj-radioset required>
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-radioset>
         *
         * @example <caption>Customize messages and hints used by implicit required validator when
         * <code class="prettyprint">required</code> option is set:</caption>
         * &lt;oj-radioset required value="{{colors}}"
         *                    translations='{"required":
         *                                    {"hint": "custom: check at least one value",
         *                                     "messageSummary": "custom: \'{label}\' is Required",
         *                                     "messageDetail", "custom: please check at least one value for \'{label}\'"}}'>
         *   &lt;oj-option value="blue">Blue&lt;/oj-option>
         * &lt;/oj-radioset>
         *
         * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
         * // getter
         * var required = myComp.required;
         *
         * // setter
         * myComp.required = false;
         *
         * @expose
         * @access public
         * @instance
         * @memberof oj.ojRadioset
         * @ojshortdesc Specifies whether the component is required or optional. See the Help documentation for more information.
         * @type {boolean}
         * @default false
         * @since 0.7.0
         * @see #translations
         */
        required: false,
        /**
         * The value of the component.
         *
         * <p>
         * When <code class="prettyprint">value</code> option changes due to programmatic
         * intervention, the component always clears all messages and runs deferred validation, and
         * always refreshes UI display value.</br>
         *
         * <h4>Clearing Messages</h4>
         * <ul>
         * <li>All messages are cleared. This includes
         * <code class="prettyprint">messagesCustom</code> property.</li>
         * </ul>
         *
         *
         * <h4>Running Validation</h4>
         * <ul>
         * <li>component always runs deferred validation</li>
         * </ul>
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">value</code> attribute:</caption>
         * &lt;oj-radioset value="coffee">
         *   &lt;oj-option value="coffee">Coffee&lt;/oj-option>
         *   &lt;oj-option value="tea">Tea&lt;/oj-option>
         * &lt;/oj-radioset>
         *
         * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
         * // getter
         * var val = myComp.value;
         *
         * // setter
         * myComp.value = "tea";
         *
         *
         * @expose
         * @access public
         * @instance
         * @ojwriteback
         * @default null
         * @memberof oj.ojRadioset
         * @ojeventgroup common
         * @ojshortdesc The value of the component. See the Help documentation for more information.
         * @type {any}
         * @ojsignature [{target: "Type", value: "V|null"}]
         */
        value: undefined
      },
      /** ** start Public APIs ****/

      /**
       * Refreshes the radioset
       * <p>A <code class="prettyprint">refresh()</code> is required
       * when a radioset is programatically changed, like in the following circumstances:
       * <ul>
       *   <li>After radios are added or removed or modified (without using ojRadioset) in the DOM.</li>
       * </ul>
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myComp.refresh();
       *
       * @expose
       * @memberof oj.ojRadioset
       * @ojshortdesc Refreshes the radioset. A refresh is required after a radioset is programmatically changed. See the Help documentation for more information.
       * @public
       * @return {void}
       * @instance
       */
      refresh: function () {
        // Set _ResetComponentState. It is called first in EditableValue's refresh,
        // and we override it in ojradioset to reset the this.$radios in case some have
        // been deleted or overridden.

        this._super();
        this._setup();
      },
      /**
       * Returns a jQuery object containing the element visually representing the radioset.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @memberof oj.ojRadioset
       * @instance
       * @public
       * @return {jQuery} the radio
       * @ignore
       */
      widget: function () {
        return this.uiRadioset;
      },
      /**
       * Validates the component's display value using all validators registered on
       * the component and updates the <code class="prettyprint">value</code> option by performing the
       * following steps.
       *
       * <p>
       * <ol>
       * <li>All messages are cleared, including custom messages added by the app. </li>
       * <li>The implicit
       * required validator is run if the component is marked required.</li>
       * <li>At the end of validation if there are errors, the messages are shown.
       * If there were no errors, then the
       * <code class="prettyprint">value</code> property is updated.</li>
       * </ol>
       *
       * @example <caption>Validate component using its current value.</caption>
       * myComp.validate();
       * @example <caption>Validate component and use the Promise's resolved state.</caption>
       * myComp.validate().then(
       *  function(result) {
       *    if(result === "valid")
       *    {
       *      submitForm();
       *    }
       *  });
       * @return {Promise.<string>} Promise resolves to "valid" if
       * the component passed all validations.
       * The Promise resolves to "invalid" if there were validation errors.
       *
       * @method
       * @access public
       * @expose
       * @instance
       * @memberof oj.ojRadioset
       * @ojshortdesc Validates the component's display value using all validators registered on the component. If there are no validation errors, then the value is updated. See the Help documentation for more information.
       * @since 4.0.0
       *
       */
      validate: ojeditablevalue.EditableValueUtils.validate,

      /** ** end Public APIs ****/

      /** ** start internal widget functions ****/
      /**
       * @protected
       * @override
       * @instance
       * @memberof oj.ojRadioset
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        var checkedRadio;
        var domValue;
        var props = [
          { attribute: 'disabled', validateOption: true },
          { attribute: 'readonly', option: 'readOnly', validateOption: true },
          { attribute: 'required', coerceDomValue: true, validateOption: true },
          { attribute: 'title' }
          // {attribute: "value"} // code below sets value
        ];

        this._super(originalDefaults, constructorOptions);

        if (!this._IsCustomElement()) {
          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);

          // component, app, and constructor are merged into this.options.option by the time _InitOptions
          // is called. Let's take this example:
          // component (widget) default - 'foo'<br/>
          // app default - 'bar'<br/>
          // dom  - 'lucy'<br/>
          // constructorOptions['value'] - undefined<br/>
          // this.options.option is set to 'bar' initially. We don't want to just take this value, because
          // we want DOM value to win over the app and components default if DOM is set.
          // Therefore, the component needs to check if the constructorOptions['value'] is
          // undefined and if so, set value option to 'lucy' (the DOM value in this example). <br/>
          //
          // use DOM value if constructorOptions is undefined. if DOM value is undefined, then
          // leave this.options["value"] alone since it's the merged app/widget default at this point.
          if (constructorOptions.value === undefined) {
            // return the checked values by simply looking at DOM node
            this.$radios = this._findRadiosWithMatchingName();
            checkedRadio = this.$radios.filter(':checked');
            domValue = checkedRadio.length === 0 ? undefined : checkedRadio.val();
            // we only use the dom if SOMETHING is checked. If nothing is checked, we stay with whatever
            // is in this.options['value'].
            if (domValue !== undefined) {
              // when defaulting from DOM we want to trigger optionChange to writeback new value
              this.option('value', domValue, { _context: { writeback: true, internalSet: true } });
            }
            // widget defaults to null
            if (this.options.value === undefined) {
              this.options.value = null;
            }
          }
        }
      },
      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @override
       * @protected
       * @memberof oj.ojRadioset
       * @instance
       */
      _ComponentCreate: function () {
        const $element = this.element;
        this._super();

        // since the oj-option renderer uses the oj-radioset ID for the name
        // attribute of the rendered radio buttons, let's make sure the radioset
        // has an ID
        $element.uniqueId();

        // Retrieve the tabindex from the container and store it in an instance variable.
        // Also we need to remove the tabindex from the container so that it will not receive
        // focus
        this._externalTabIndex = this.element.attr('tabindex') || 0;
        this.element.removeAttr('tabindex');

        // Async step that generates oj-option if DateProvider is used.
        // RadioCheckboxUtils will set this._optionsDataProvider, this._optionsDataListener
        // and this._optionsDataArray.
        oj.RadioCheckboxUtils.generateOptionsFromData.call(this);

        // Continue processing for the static oj-option case and set up the component itself
        this._processOjOptions();
        // The processOjOptions renders input/label from the oj-options,
        // so now we need to go through and get this.$radios.
        this.$radios = this._findRadiosWithMatchingName();

        // first check to see if this.element is NOT a fieldset. If fieldset, throw error.
        if ($element.is('fieldset')) {
          throw new Error('ojRadioset cannot be bound to a fieldset. Use a div instead.');
        }
        // Turn each radio into ojRadioCheckbox. Since ojRadioset delegates to the _ojRadioCheckbox
        // component, and we need to mark this as an internal node so that oj.Components.getComponentElementByNode
        // knows it is an internal component in this case, not a stand-alone component
        this.$radios._ojRadioCheckbox().attr('data-oj-internal', '');

        // keep the root dom element and slots as is, and add a wrapper dom underneath it. This way we can
        // have one div around all the inputs and labels, and for inline messaging we can have another
        // div around the inline messaging content. And we can style the borders of the two boxes differently.
        this.uiRadioset = $element.addClass('oj-radioset oj-component').attr('role', 'radiogroup');
        // need to grab all elements using contents first and then do filter because jquery children will automatically
        // exclude all comment and text nodes
        const $childNodes = $element.contents().filter(function () {
          return !(this.getAttribute && this.getAttribute('slot') === 'contextMenu');
        });
        // When using dataprovider, the childNodes will not be generated yet.
        // So, in that case append the wrapper directly to the element.
        if ($childNodes.length > 0) {
          $childNodes.wrapAll(`<div class='${this._WRAPPER_CLASS_NAMES}'></div>`); // @HTMLUpdateOK
        } else {
          $element.append(`<div class='${this._WRAPPER_CLASS_NAMES}'></div>`); // @HTMLUpdateOK
        }

        // if readonly, set tabindex and aria-readonly on the wrapper
        this._updateReadonlyState();
        this._on(this._events);
        this._setup();
      },
      /**
       * Resets this.$radios. This is called at the beginning of a refresh in EditableValue
       * @override
       * @memberof oj.ojRadioset
       * @instance
       * @protected
       */
      _ResetComponentState: function () {
        // we could have added, removed, or modified radios, so we need to re-find all the
        // inputs on refresh and turn the ones that aren't already ojRadioCheckboxes into them.
        this._processOjOptions();
        this.$radios = this._findRadiosWithMatchingName();

        // we have a rule for refresh: if we have a public API for it, then the app dev has to use the
        // option, and not expect changing the dom will update the state with refresh.
        // However, ojRadioset does not expose a public API for the individual radios' disabled state
        // to the app developer. Our private ojRadioCheckbox component has a disabled option that
        // our code has access to.
        // For each radio, we need to look at the disabled attribute dom and update the
        // ojradiocheckbox's disabled option.

        // !! ensures it is a boolean
        // update the private ojradiocheckbox component's disabled option to keep it in sync with the dom
        this.$radios.filter('.oj-radio').each(function () {
          var disabledValue =
            $(this).attr('disabled') !== undefined ? !!$(this).prop('disabled') : false;
          $(this)._ojRadioCheckbox('option', 'disabled', disabledValue);
        });

        // no need to refresh the ojRadioCheckbox's that exist since we have options for everything.
        // of the type=radio inputs that are not yet ojRadioCheckboxs, make them ojRadioCheckboxes.

        // create ojRadioCheckboxes on any new ones.
        this.$radios.not('.oj-radio')._ojRadioCheckbox();
      },
      /**
       * @override
       * @memberof oj.ojRadioset
       * @instance
       * @protected
       * @since 5.0.0
       */
      GetFocusElement: function () {
        // JET-48463 - oj-table issue where focus is lost
        // GetFocusElement() needs to return the correct readonly element
        // If _GetReadonlyFocusElement() returns null, fallback to the
        // enabled element logic.
        if (this.options.readOnly === true) {
          const readonlyFocusElement = this._GetReadonlyFocusElement();
          if (readonlyFocusElement) {
            return readonlyFocusElement;
          }
        }
        // JET-43430 - dynamic form focus issue for radio buttonset
        // When tabbing through, the input element that is currently checked will be focused if
        // one is available. Otherwise the first input element will be given focus. We need to
        // follow the same behavior when programtically setting focus.
        // We need :disabled here so that we don't try to focus on an element that isn't focusable.
        // :focusable doesn't work because this is called before the custom element is fully upgraded
        // and is still hidden in the DOM.
        const firstCheckedInputElement = this._GetContentElement()
          .not(':disabled')
          .filter(':checked')[0];
        if (firstCheckedInputElement) {
          return firstCheckedInputElement;
        }

        // If there is no checked inputs, simply return the first enabled input
        return this._GetContentElement().not(':disabled').first()[0];
      },
      /**
       * oj-radioset doesn't use .oj-text-field-readonly for the focusable readonly content,
       * so we need to use a different selector.
       * @memberof oj.ojRadioset
       * @instance
       * @override
       * @protected
       * @return {Element|null}
       */
      _GetReadonlyFocusElement: function () {
        return this.widget()[0].querySelector('.oj-form-control-container');
      },
      /**
       * Whether the component is required.
       *
       * @return {boolean} true if required; false
       *
       * @memberof! oj.ojRadioset
       * @instance
       * @protected
       * @override
       */
      _IsRequired: function () {
        return this.options.required;
      },
      /**
       * Sets the disabled option onto the dom.
       * This is a no-op for radioset since its root dom element is a div, and disabled is
       * invalid on a div. If we did try to set disabled on the div, then restore attributes doesn't
       * work correctly since it wasn't saved correctly.
       * @param {Object} node - dom node
       *
       * @memberof oj.ojRadioset
       * @instance
       * @protected
       * @since 1.0.0
       */
      // eslint-disable-next-line no-unused-vars
      _SetDisabledDom: function (node) {
        // no-op
      },
      /**
       * @memberof oj.ojRadioset
       * @instance
       * @private
       */
      _refreshRequired: ojeditablevalue.EditableValueUtils._refreshRequired,

      /**
       * This function processes the oj-option children, sets the custom renderer, and
       * creates input type=radio and label dom from them.
       *
       * We don't want to rely on the framework calling the customOptionRenderer
       * as a result of setting options[i]["customOptionRenderer"] = renderer; in this function.
       * This could lead to timing bugs when data-oj-binding-provider="none". (when not "none",
       * we know the oj-options are created before the oj-radioset gets created, so no timing issue)
       * Therefore we create the input/label not in the customOptionRenderer,
       * but in a separate function that we call.
       * @private
       * @instance
       */
      _processOjOptions: function () {
        if (this._IsCustomElement()) {
          // set the custom renderer on oj-option
          var i;
          var len;
          var renderer = this._customOptionRenderer.bind(this);
          var domElem = this.element[0];
          var wrapperDom = domElem.querySelector('.oj-radioset-wrapper');
          var selectedOption = this.options.value;

          // if there isn't a wrapper yet, use the component as the wrapper.
          if (!wrapperDom) {
            wrapperDom = domElem;
          }

          var novaluespan = domElem.querySelector('[data-no-value-span]');
          // Remove the old no-value span, if there is one and there is a current selection or not in readonly mode
          if (novaluespan) {
            if ((selectedOption && selectedOption !== '') || !this.options.readOnly) {
              novaluespan.parentElement.removeChild(novaluespan);
            }
          } else if ((!selectedOption || selectedOption === '') && this.options.readOnly) {
            // Otherwise, add the no value span if no selection.
            var span = document.createElement('span');
            span.setAttribute('data-no-value-span', '');
            span.setAttribute('class', 'oj-choice-item');
            var noCheckboxSelected = this.getTranslatedString('readonlyNoValue');
            if (noCheckboxSelected !== null) {
              span.textContent = noCheckboxSelected;
            }
            wrapperDom.appendChild(span); // @HTMLUpdateOK
          }

          // Process all options and update them accordingly
          // Get all the oj-option elements of the oj-radioset
          // Those that are direct child as well as those inside the wrapperDOM if exists
          var options = this.element
            .children('oj-option')
            .add(this.element.children('.oj-radioset-wrapper').find('oj-option'));
          for (i = 0, len = options.length; i < len; i++) {
            options[i].customOptionRenderer = renderer;
            if (this.options.readOnly) {
              this._processReadonlyOptions(options[i]);
            } else {
              this._initInputLabelFromOjOption(options[i]);
            }
          }
        }
      },
      _processReadonlyOptions: function (ojOption) {
        const selectedOption = this.options.value;
        const optionValue = ojOption.value;
        const element = this.element.get(0);
        const choiceItemSelector = 'span.oj-choice-item';
        const parentSpan = $(ojOption).parentsUntil(element, choiceItemSelector).get(0);

        // If the provided ojOption is present inside an oj-choice-item, it means
        // it is already processed. If not, it is still not processed.
        // It should be sufficient to hide just ojOption element when it is not
        // processed. But, if it is processed, then we need to hide the parent
        // oj-choice-item
        if (parentSpan == null) {
          ojOption.classList.add('oj-helper-hidden');
        } else {
          parentSpan.classList.add('oj-helper-hidden');
        }
        if (selectedOption === optionValue) {
          ojOption.classList.remove('oj-helper-hidden');
          this._initReadonlyLabelFromOjOption(ojOption, parentSpan);
        }
      },

      /**
       * Create the input type='radio'/label dom from attributes on oj-option element.
       * oj-radioset is made up of input/labels.
       * This gets called during the oj-radioset _CreateComponent and refresh
       * @param {Element} elem the oj-option element
       * @private
       * @instance
       */
      _initInputLabelFromOjOption: function (elem) {
        var span;
        var label;
        var ojoption = elem;

        // let's make sure that each oj-option has an ID so the
        // label element can reference the input element via the 'for' attribute
        // we have tests in place where oj-option doesn't have id and where it does
        // both for the databound case and non-databound case. In the databound case, the
        // bindings are resolved before we get here, so we will be fine.
        $(ojoption).uniqueId();

        var id = ojoption.getAttribute('id');
        var radioId = id + '|rb';
        var radio = document.getElementById(radioId);
        // Was the oj-option already rendered?
        // It is possible that the answer is true;
        // the use case is when we dynamically add an oj-option to the oj-radioset, and in that
        // case we call _processOjOptions (which in turn calls this function) from _ResetComponentState
        var alreadyProcessed = radio !== null;

        // check to see if we've already processed the oj-option dom or not
        // in the code below, we use setAttribute() for everything as we want to be
        // setting the initial value for these elements.
        if (!alreadyProcessed) {
          radio = document.createElement('input');
          radio.setAttribute('type', 'radio');
          // The value is needed for accessibiliy of the image used for the radio
          radio.setAttribute('value', ojoption.value);
          radio.setAttribute('id', radioId);
          // Need to transfer the tabindex to the input element
          // All the input element will have the same tabindex
          radio.setAttribute('tabindex', this._externalTabIndex);
          // in readonly mode, if a option is selected, the <oj-option> will be surrounded by <label> tag
          // if a option is selected, we can set attribute for the previous label and there is no need to create a new label
          // if a option is not selected, we need to create a new label.
          if (ojoption.parentElement.nodeName === 'LABEL') {
            label = ojoption.parentElement;
            label.setAttribute('for', radioId);
            label.parentElement.insertBefore(radio, label);
            // also we need to remove the oj-helper-hidden class from the parentElement
            label.parentElement.classList.remove('oj-helper-hidden');
          } else {
            label = document.createElement('label');
            label.setAttribute('for', radioId);
            span = document.createElement('span');
            span.setAttribute('class', 'oj-choice-item');
            ojoption.parentElement.insertBefore(span, ojoption); // @HTMLUpdateOK
            span.appendChild(radio);
            span.appendChild(label);
            label.appendChild(ojoption); // append the oj-option as a child of label
          }
          ojoption.classList.remove('oj-helper-hidden');
        } else {
          var parentSpan = ojoption;
          do {
            parentSpan = parentSpan.parentElement;
          } while (parentSpan && !parentSpan.classList.contains('oj-choice-item'));
          if (
            parentSpan &&
            parentSpan.classList.contains('oj-helper-hidden') &&
            parentSpan.classList.contains('oj-choice-item') &&
            parentSpan.tagName === 'SPAN'
          ) {
            parentSpan.classList.remove('oj-helper-hidden');
          }
          if (ojoption && ojoption.classList.contains('oj-helper-hidden')) {
            ojoption.classList.remove('oj-helper-hidden');
          }
          if (radio && radio.parentElement.classList.contains('oj-helper-hidden')) {
            radio.parentElement.classList.remove('oj-helper-hidden');
          }
        }
        var name = this.element[0].id; // Use the id of the ojradioset as the name for the oj-options.
        var ariaLabel = ojoption.getAttribute('aria-label');
        var ariaLabelledBy = ojoption.getAttribute('aria-labelledby');

        // The value attribute of the radio only supports text, so we need to be
        // able to access the oj-option's value property instead.  This attribute
        // is a link back to the oj-option so that we don't need to use dom traversal
        // to get to the oj-option to get its value.
        radio.setAttribute('data-oj-option-id', id);

        if (name && name !== '') {
          radio.setAttribute('name', name);
        }

        if (ariaLabel && ariaLabel !== '') {
          radio.setAttribute('aria-label', ariaLabel);
        } else {
          radio.removeAttribute('aria-label');
        }

        if (ariaLabelledBy && ariaLabelledBy !== '') {
          radio.setAttribute('aria-labelledby', ariaLabelledBy);
        } else {
          radio.removeAttribute('aria-labelledby');
        }

        if (ojoption.disabled) {
          radio.setAttribute('disabled', true);
        } else {
          radio.removeAttribute('disabled');
        }
      },
      _initReadonlyLabelFromOjOption: function (elem, parentSpan) {
        var ojoption = elem;
        var span;
        var label;
        if (parentSpan) {
          // we do not render the input when the radioset is readonly,
          // input is only rendered with non readonly case
          // if the input exists and it is readonly case we need to hide it.
          $(ojoption).uniqueId();

          var id = ojoption.getAttribute('id');
          var radioId = id + '|rb';
          var radio = document.getElementById(radioId);
          var radioInputExists = radio !== null;
          if (radioInputExists) {
            radio.parentElement.classList.add('oj-helper-hidden');
          }
          parentSpan.classList.remove('oj-helper-hidden');
        } else {
          span = document.createElement('span');
          label = document.createElement('label');
          span.setAttribute('class', 'oj-choice-item');
          ojoption.parentElement.insertBefore(span, ojoption); // @HTMLUpdateOK
          label.appendChild(ojoption); // append the oj-option as a child of label
          span.appendChild(label);
        }
      },

      // custom oj-option renderer
      // Because we can't rely on this being called when we set the customOptionRenderer property
      // in _processOjOptions we shouldn't do the input.label creation from the oj-option
      // in this function. (If we did, the _ComponentCreate code that relies on the
      // inputs/labels being created already would not work.)
      // The correct thing to do is to create the input/label in _initInputLabelFromOjOption
      // Then rely on this function being called after the oj-option has been created and we are
      // changing properties on it.
      _customOptionRenderer: function (elem) {
        var ojoption = elem;
        var id = ojoption.getAttribute('id');
        var radioId = id + '|rb';
        var radio = document.getElementById(radioId);
        // Was the oj-option already rendered into an _ojRadioCheckbox() in _CreateComponent?
        var radioExists = radio !== null;
        var hasOjRadioClass = radioExists && radio.classList.contains('oj-radio');

        // When an oj-option child is disabled (by setting the disabled attribute to
        // true) and it re-renders, the component should refresh automatically rather than requiring the
        // user to call refresh. See .
        if (hasOjRadioClass) {
          $(radio)._ojRadioCheckbox('option', 'disabled', ojoption.disabled);
        }
      },
      /**
       * If custom element, get the labelledBy option, and set this
       * onto the root dom element as aria-labelledby. We append "|label" so it matches the id that
       * is on the oj-label's label element.
       * @memberof oj.ojRadioset
       * @instance
       * @private
       */
      _labelledByUpdatedForSet: LabeledByUtils._labelledByUpdatedForSet,
      /**
       * Returns a jquery object that is a set of elements that are input type radio
       * and have the name of the first radio found.
       *
       * @return {jQuery} jquery object of all the radios within the root dom element
       * that have the same 'name' attribute as the first radio found.
       * @private
       * @memberof oj.ojRadioset
       */
      _findRadiosWithMatchingName: function () {
        var allradios;
        var element = this.element;
        var $first = element.find('input[type=radio]:first');
        var name;
        var selector;

        if ($first.length === 0) {
          ojlogger.warn('Could not find any input type=radio within this element');
        }
        // get the name attribute of the first input radio
        name = $first.attr('name');
        // find all input radios with matching name
        if (name === undefined) {
          // search for all radios with no name
          allradios = element.find('input[type=radio]');
          // now loop and find the ones without 'name' attribute
          return allradios.not('[name]');
        }

        // search for all radios with the name
        selector = 'input[type=radio][name="' + name + '"]';
        return element.find(selector);
      },
      // Override to set custom launcher
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        // Setting the launcher to the checked radio if any (since that's what's tabbable in mainstream browsers),
        // else the first enabled radio (when no selection, all enabled radios are tabbable).
        // Component owner should feel free to specify a different launcher if appropriate.
        // See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
        var radios = this.element.find('input[type=radio]');
        var checked = radios.filter(':checked');
        var launcher = checked.length ? checked : radios.filter(':enabled').first();
        this._OpenContextMenu(event, eventType, { launcher: launcher });
      },
      // Override to set launcher to widget
      _GetMessagingLauncherElement: function () {
        // focus events only get triggered on input, but they do bubble up and we will capture them
        // on the widget.
        // mouseenter events get called once once if the user hovers over for the entire widget. if
        // we put it on the inputs, it gets called every time you leave and enter a new input. Plus,
        // this doesn't work when we hide the input like we do in the native themes.
        return this.widget();
      },
      /**
       * _setup is called on create and refresh. Use the disabled option to
       * update the component. If the component's option is disabled, then
       * leave it alone.
       * @memberof oj.ojRadioset
       * @instance
       * @private
       */
      _setup: function () {
        // at this point we already have this.$radios set to a list of radios for this radioset.
        this._propagateDisabled(this.options.disabled);

        // add to the root dom the style class 'oj-choice-direction-column'
        // if there isn't already a 'oj-choice-direction-row' or 'oj-choice-direction-column' there.
        if (
          !this.element.hasClass('oj-choice-direction-column') &&
          !this.element.hasClass('oj-choice-direction-row')
        ) {
          this.element.addClass('oj-choice-direction-column');
        }

        // add to the root dom the style class 'oj-read-only'
        if (this.options.readOnly) {
          this.element.addClass('oj-read-only');
        } else {
          this.element.removeClass('oj-read-only');
        }

        this._refreshRequired(this.options.required);
        // copy labelledBy to aria-labelledBy
        var widget = this.widget();
        this._labelledByUpdatedForSet(widget[0].id, null, this.options.labelledBy, widget);
      },
      _events: {
        change: function (event) {
          this._HandleChangeEvent(event);
        },
        'click .oj-choice-item': function (event) {
          if (
            !this.widget()[0].classList.contains('oj-choice-direction-row') &&
            event.target.tagName !== 'INPUT'
          ) {
            $(event.target).find('input').click();
          }
        }
      },

      /**
       * @param {Event} event DOM event
       * @override
       * @protected
       * @memberof oj.ojRadioset
       */
      _HandleChangeEvent: function (event) {
        // TODO make sure the target is an input radio?
        // TODO any more checks I need to do?
        // alert("XYZ In _changeSetValue target is " + event.target + " And the value of the input is " + event.target.value);

        // should I double check that the event.target is the same as the 'checked'?
        // if (event.target === this.$radios.filter(":checked"))???
        //
        var submittedValue = this._GetDisplayValue();
        // run full validation. There is no need to check if values have changed
        //  since for checkboxset/radioset if we get into this function we know value has changed.
        // passing in doValueChangeCheck: false will skip the new-old value comparison
        this._SetValue(submittedValue, event, _sValueChangeCheckFalse);
      },

      /**
       * Returns the display value that is ready to be passed to the converter.
       *
       * @param {Object} value the stored value if available that needs to be formatted for display
       * @override
       * @protected
       * @memberof oj.ojRadioset
       */
      // eslint-disable-next-line no-unused-vars
      _GetDisplayValue: function (value) {
        // return the value of the 'checked' radio
        return this._GetElementValue();
      },
      /**
       * Called when the display value on the element needs to be updated
       * as a result of a value change.
       * ojRadioset stores a String value, and this value matches the value
       * of the currently checked radio. So, if we need to set the display value,
       * what this means is we need to 'check' the radio whose value matches the
       * displayValue.
       *
       * @param {String} displayValue the value of the radio button that needs to be selected
       * @override
       * @protected
       * @memberof oj.ojRadioset
       */
      _SetDisplayValue: function (displayValue) {
        var i;
        var length = this.$radios.length;
        var matchIndex = -1;
        var radios = this.$radios.get();
        var radioValues = [];
        var $radio;

        // Find the element matching displayValue
        // first, do an === compare
        for (i = 0; i < length; i++) {
          // save the values for the deep compare case
          radioValues[i] = this._GetOptionValue(radios[i]);

          if (radioValues[i] === displayValue) {
            matchIndex = i;
            break;
          }
        }

        // If not found, do a deep compare
        if (matchIndex === -1) {
          for (i = 0; i < length; i++) {
            if (oj.Object.compareValues(radioValues[i], displayValue)) {
              matchIndex = i;
              break;
            }
          }
        }

        // go through each _ojRadioCheckbox and see if it needs to be checked or unchecked.
        for (i = 0; i < length; i++) {
          $radio = $(this.$radios[i]);
          // does the radio's value match the displayValue?
          var checked = $radio._ojRadioCheckbox('option', 'checked');
          if (i === matchIndex) {
            // yes. this needs to be checked, if it isn't already
            if (!checked) {
              $radio._ojRadioCheckbox('option', 'checked', true);
            }
          } else if (checked) {
            // / no. this needs to be unchecked, if it isn't already
            $radio._ojRadioCheckbox('option', 'checked', false);
          }
        }
      },
      /**
       * Returns the element's value. Normally, this is a call to this.element.val(),
       * but in the case of ojRadioset, the element's value is really the value
       * of the checked radio in the set.
       * @override
       * @protected
       * @memberof oj.ojRadioset
       * @return {any} The value of the selected radio, or null if no selection.
       */
      _GetElementValue: function () {
        // "input:checked" selects radios that are currently checked as
        // reflected in their boolean (true or false) checked property,
        // which is affected when the user clicks the radio for example.
        // for radio, there will be one or none checked;
        // if none are checked, return null (checkedRadio.val() is undefined if nothing is checked)
        var checkedRadio = this.$radios.filter(':checked');
        if (checkedRadio.length === 0) {
          return null;
        }
        return this._GetOptionValue(checkedRadio[0]);
      },
      /**
       * For custom element, we get the value from the oj-option element, otherwise
       * we get the value from the radio element.
       * @override
       * @protected
       * @memberof oj.ojRadioset
       * @return {any} Returns the value property of the associated oj-option, or the value attribute of the radio element.
       */
      _GetOptionValue: function (radioElem) {
        var option;
        var val;

        if (this._IsCustomElement()) {
          option = document.getElementById(radioElem.getAttribute('data-oj-option-id'));

          if (option) {
            val = option.value;
          }
        } else {
          val = radioElem.value;
        }

        return val;
      },
      /**
       * Returns the default styleclass for the component. Currently this is
       * used to pass to the ojLabel component, which will append -label and
       * add the style class onto the label. This way we can style the label
       * specific to the input component. For example, for inline labels, the
       * radioset/checkboxset components need to have margin-top:0, whereas all the
       * other inputs need it to be .5em. So we'll have a special margin-top style
       * for .oj-label-inline.oj-radioset-label
       * All input components must override
       *
       * @return {string}
       * @memberof oj.ojRadioset
       * @override
       * @protected
       */
      _GetDefaultStyleClass: function () {
        return 'oj-radioset';
      },
      /**
       * Returns a jquery object of the elements representing the
       * content nodes (input type=radio). This is used in EditableValue to add
       * aria-describedby to the input when there is a help icon, to add
       * aria-required and aria-invalid
       * @protected
       * @override
       * @memberof oj.ojRadioset
       */
      _GetContentElement: function () {
        if (this.$radios != null) {
          return this.$radios;
        }

        this.$radios = this._findRadiosWithMatchingName();
        return this.$radios;
      },
      /**
       * Called to find out if aria-required is unsupported. This is needed for the label.
       * It is not legal to have aria-required on radio/checkboxes, nor on
       * radiogroup/group.
       * If aria-required is not supported, then we wrap the required icon as well as the
       * help icons so that JAWS can read required. We don't do this for form controls that use
       * aria-required because if we did JAWS would read required twice.
       * @memberof oj.ojRadioset
       * @instance
       * @protected
       * @return {boolean}
       */
      _AriaRequiredUnsupported: function () {
        return true;
      },

      /**
       * This is called from InlineHelpHintsStrategy to determine
       * the location of the inline help hints, above the component
       * or below.
       * @ignore
       * @protected
       * @override
       * @memberof oj.ojRadioset
       * @return {'above'|'inline'}
       */
      _ShowHelpHintsLocation: function () {
        return 'above';
      },
      /**
       * Performs post processing after required option is set by taking the following steps.
       *
       * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
       * run full validation with UI value (we don't know if the UI error is from a required validator
       * or something else);<br/>
       * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
       * updated<br/>
       * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
       * listen to optionChange(value) to clear custom errors.<br/>
       *
       * - if component is invalid and has messagesHidden -> required: false -> clear component
       * errors; no deferred validation is run.<br/>
       * - if component has no error -> required: true -> run deferred validation (we don't want to flag
       * errors unnecessarily)<br/>
       * - messagesCustom is never cleared<br/>
       *
       * @param {string} option
       *
       * @memberof oj.ojRadioset
       * @instance
       * @protected
       */
      _AfterSetOptionRequired: ojeditablevalue.EditableValueUtils._AfterSetOptionRequired,

      /**
       * @private
       * @memberof oj.ojRadioset
       */
      _propagateDisabled: function (_disabled) {
        var disabled = !!_disabled;
        this.$radios.each(function () {
          // this is the technique to use to call package-private functions
          // Calling it like this.$radios.ojRadioCheckbox("__setAncestorComponentDisabled",value)
          // gives an error because jquery prevents you from calling functions with an "_"
          //
          // This is how we handle 'disabled' for radioset. We don't change the radiocheckbox
          // component's disabled option ever since if we do that we've lost what the initial disabled
          // state is (we store the disabled dom value from the radio into its disabled option)
          // and we need that when we refresh. Instead what we do
          // is we mark if its ancestor (the radioset) is disabled or not. Then, when we render
          // out the radios 'disabled' state, like oj-disabled, we look to see if it is 'effectively
          // disabled' (see _IsEffectivelyDisabled call in ojRadioCheckbox), that is if its
          // option is disabled OR its ancestor (the radioset) is disabled.
          $(this).data('oj-_ojRadioCheckbox').__setAncestorComponentDisabled(disabled);
        });

        this.$radios._ojRadioCheckbox('refreshDisabled');
      },

      /**
       * Updates the component's state based on whether or not it is in the readonly
       * state.
       * @private
       * @memberof! oj.ojRadioset
       */
      _updateReadonlyState: function () {
        const wrapperDom = this.element[0].querySelector('.oj-radioset-wrapper');
        if (this.options.readOnly) {
          wrapperDom.setAttribute('tabindex', this._externalTabIndex);
          wrapperDom.setAttribute('aria-readonly', 'true');
          this.element.addClass('oj-read-only');

          // JET-49107 - reassess accessibility implementation of 'readonly' radioset
          // In readonly mode, we will not have any radio input in the visible DOM. Thus,
          // in this state it will just be showing generic text based on the value selected.
          // So, we need to clean up the role along with the aria-labelledby attributes we added
          // for that role to make things accessible.
          this.element.removeAttr('role').removeAttr('aria-labelledby');
          return;
        }

        // remove tabindex and role
        wrapperDom.removeAttribute('tabindex');
        wrapperDom.removeAttribute('aria-readonly');
        this.element.removeClass('oj-read-only');

        // JET-49107 - reassess accessibility implementation of 'readonly' radioset
        // add back the role and aria attributes removed before
        this.element.attr('role', 'radiogroup');
        this._labelledByUpdatedForSet(
          this.widget()[0].id,
          null,
          this.options.labelledBy,
          this.widget()
        );
      },

      /**
       * Note that _setOption does not get called during create in the super class.
       * It only gets called when the component has already been created.
       * @override
       * @private
       * @memberof oj.ojRadioset
       */
      _setOption: function (key, value, flags) {
        var originalValue = this.options.labelledBy;
        this._super(key, value, flags);

        switch (key) {
          case 'disabled':
            this._propagateDisabled(value);
            break;
          case 'readOnly':
            var val = this.options.value;
            this._updateReadonlyState();
            this._ResetComponentState();
            // when toggle readonly to false, we need to check the initial set values.
            if (val != null) {
              this._SetDisplayValue(val);
            }
            break;
          case 'value':
            this._processOjOptions();
            break;
          case 'labelledBy':
            // remove the old one and add the new one
            var widget = this.widget();
            this._labelledByUpdatedForSet(widget[0].id, originalValue, value, widget);
            break;
          case 'options':
            oj.RadioCheckboxUtils.generateOptionsFromData.call(this);
            break;
          case 'optionsKeys':
          case 'optionRenderer':
            oj.RadioCheckboxUtils.renderOptions.call(this);
            break;
          default:
            break;
        }
      },
      /**
       * Performs post processing after _SetOption() is called. Different options when changed perform
       * different tasks. See _AfterSetOption[OptionName] method for details.
       *
       * @param {string} option
       * @param {Object|string=} previous
       * @param {Object=} flags
       * @protected
       * @memberof oj.ojRadioset
       * @instance
       * @override
       */
      // eslint-disable-next-line no-unused-vars
      _AfterSetOption: function (option, previous, flags) {
        this._superApply(arguments);
        switch (option) {
          case 'required':
            this._AfterSetOptionRequired(option);
            break;
          default:
            break;
        }
      },

      getNodeBySubId: function (locator) {
        var node = this._super(locator);
        var radios;
        var subId;
        var value;
        var i;

        if (!node) {
          radios = this.$radios.get();
          subId = locator.subId;

          switch (subId) {
            case 'oj-radioset-inputs': // TODO: depricated for a while now, remove this in 4.0.0
              node = radios;
              break;

            case 'oj-radioset-radio':
              // We find these by the value attribute on the input element, which is
              // much more stable that using an index.
              value = locator.value;

              if (typeof value !== 'undefined') {
                var arrayLength = radios.length;
                var matchIndex = -1;
                var radioValues = [];

                // Find the index of the match
                for (i = 0; i < arrayLength; i++) {
                  // save the values just in case we need to do deep compare
                  radioValues[i] = this._GetOptionValue(radios[i]);

                  if (radioValues[i] === value) {
                    matchIndex = i;
                    break;
                  }
                }
                // If not found, do a deep compare
                if (matchIndex === -1) {
                  for (i = 0; i < arrayLength; i++) {
                    if (oj.Object.compareValues(radioValues[i], value)) {
                      matchIndex = i;
                      break;
                    }
                  }
                }

                if (matchIndex !== -1) {
                  node = radios[matchIndex];
                }
              }
              break;
            default:
              break;
          }
        }

        // Non-null locators have to be handled by the component subclasses
        return node || null;
      },

      getSubIdByNode: function (node) {
        var topElem = this._GetContentElement()[0].parentElement.parentElement.parentElement;
        var currentNode = node;

        while (currentNode && currentNode !== topElem) {
          if (currentNode.nodeName === 'LABEL') {
            currentNode = document.getElementById(currentNode.for);
          }

          if (currentNode.nodeName === 'INPUT') {
            return { subId: 'oj-radioset-radio', value: this._GetOptionValue(currentNode) };
          }

          currentNode = currentNode.parentElement;
        }
        return this._super(node);
      },

      /**
       * @ignore
       * @protected
       * @memberof oj.ojRadioset
       * @override
       */
      _destroy: function () {
        var ret = this._super();
        var wrapperDom = this.element[0].firstElementChild;

        if (this.$radios) {
          this.$radios._ojRadioCheckbox('destroy');
        }

        // remove the dom we added to wrap the children of this.element, but don't remove the children.
        $(wrapperDom).contents().unwrap();

        oj.RadioCheckboxUtils.removeDataListener.call(this);

        return ret;
      }
      /** ** end internal widget functions ****/

      /**
       * Removes the radioset functionality completely.
       * This will return the element back to its pre-init state.
       *
       * <p>This method does not accept any arguments.
       *
       * @method
       * @name oj.ojRadioset#destroy
       * @memberof oj.ojRadioset
       * @instance
       * @ignore
       *
       * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
       * $( ".selector" ).ojRadioset( "destroy" );
       */
    });
  })();

});


define('ojs/ojconverter-color',['ojs/ojcore-base', 'ojs/ojtranslation', 'ojs/ojconverter', 'ojs/ojvalidation-error'], function (oj, Translations, Converter, ojvalidationError) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Converter = Converter && Object.prototype.hasOwnProperty.call(Converter, 'default') ? Converter['default'] : Converter;

  /**
   * ColorConverter Contract.
   * @ignore
   */

  /**
     * @export
     * @constructor
     * @final
     * @augments oj.Converter
     * @name oj.ColorConverter
     * @ojtsimport {module: "ojcolor", type: "AMD", importName: "Color"}
     * @ojtsimport {module: "ojconverter", type:"AMD", importName: "Converter"}
     * @ojtsmodule
     * @ojsignature [{target: "Type",
     *                value: "class ColorConverter implements Converter<oj.Color>"},
     *               {target: "Type",
     *                value: "oj.ColorConverter.ConverterOptions",
     *                for: "options",
     *                jsdocOverride: true}
     *              ]

     * @classdesc An {@link Color} object format converter.
     * @desc Creates a Converter that allows any color format to be obtained from an {@link Color} object.
     * @since 0.6.0
     * @param {Object=} options - an object literal used to provide optional information to
     * initialize the converter.
     * @example <caption>Create a color converter to convert an rgb specification to hsl format</caption>
     * var cv        = new ColorConverter({format: "hsl");
     * var color     = new oj.Color("rgb(30, 87, 236)") ;
     * var hsl       = cv.format(color);   -->  "hsl(223, 84%, 52%)"
     */
  const ColorConverter = function (options) {
    this.Init(options);
  };

  /**
   * @typedef {object} oj.ColorConverter.ConverterOptions
   * @property {('rgb'|'hsl'|'hsv'|'hex'|'hex3')=} format - sets the format of the converted color specification.
   * Allowed values are "rgb" (the default, if omitted), "hsl", "hsv" "hex", and "hex3". "hex" returns six
   * hex digits ('#rrggbb'), and "hex3" returns three hex digits if possible ('#rgb') or six hex
   * digits if the value cannot be converted to three.
   */

  // Subclass from Converter
  oj.Object.createSubclass(ColorConverter, Converter, 'oj.ColorConverter');

  /**
   * Initializes the color converter instance with the set options.
   * @param {Object=} options an object literal used to provide an optional information to
   * initialize the converter.<p>
   * @export
   * @ignore
   */
  ColorConverter.prototype.Init = function (options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    // eslint-disable-next-line no-param-reassign
    options.format = options.format || 'rgb';
    ColorConverter.superclass.Init.call(this, options);
  };

  /**
   * Formats the color using the options provided into a string.
   *
   * @param {oj.Color} color the {@link Color} instance to be formatted to a color specification string
   * @return {(string | null)} the color value formatted to the color specification defined in the options.
   * @throws {Error} a ConverterError if formatting fails, or the color option is invalid.
   * @export
   * @memberof oj.ColorConverter
   * @instance
   * @method format
   */
  ColorConverter.prototype.format = function (color) {
    var fmt = this._getFormat();
    var ret = null;

    if (fmt === 'rgb') {
      ret = color.toString();
    } else if (fmt === 'hsl') {
      ret = ColorConverter._toHslString(color);
    } else if (fmt === 'hex') {
      ret = ColorConverter._toHexString(color);
    } else if (fmt === 'hex3') {
      ret = ColorConverter._toHexString(color, true);
    } else if (fmt === 'hsv') {
      ret = ColorConverter._toHsvString(color);
    } else {
      ColorConverter._throwInvalidColorFormatOption();
    }

    return ret || ColorConverter.superclass.format.call(this, color);
  };

  /**
   * Parses a CSS3 color specification string and returns an oj.Color object.</br>
   * (Note that the "format" option used to create the Converter is not used
   * by this method, since the oj.Color object created is color agnostic.)
   * @param {string} value The color specification string to parse.
   * @return {oj.Color} the parsed value as an {@link Color} object.
   * @throws {Error} a ConverterError if parsing fails
   * @export
   * @memberof oj.ColorConverter
   * @instance
   * @method parse
   */
  ColorConverter.prototype.parse = function (value) {
    try {
      return new oj.Color(value); // throws error if invalid
    } catch (e) {
      throw ColorConverter._throwInvalidColorSyntax(); // This throw is not reachable.  THe function does it. Done for ESLint
    }
  };

  /**
   * Returns a hint that describes the color converter format.
   * @return {string} The expected format of a converted color.
   * @export
   * @memberof oj.ColorConverter
   * @instance
   * @method getHint
   */
  ColorConverter.prototype.getHint = function () {
    return this._getFormat();
  };

  /**
   * Returns an object literal with properties reflecting the color formatting options computed based
   * on the options parameter.
   *
   * @ojsignature {target: "Type", for: "returns", value: "oj.ColorConverter.ConverterOptions"}
   * @return {Object} An object literal containing the resolved values for the following options.
   * <ul>
   * <li><b>format</b>: A string value with the format of the color specification.
   * for formatting.</li>
   * </ul>
   * @export
   * @memberof oj.ColorConverter
   * @instance
   * @method resolvedOptions
   */
  ColorConverter.prototype.resolvedOptions = function () {
    return {
      format: this._getFormat()
    };
  };

  /**
   * Returns the options called with converter initialization.
   * @return {Object} an object of options.
   * @ojsignature {target: "Type", for: "returns",
   *                value: "oj.ColorConverter.ConverterOptions"}
   * @export
   * @memberof oj.ColorConverter
   * @instance
   * @method getOptions
   */
  ColorConverter.prototype.getOptions = function () {
    return ColorConverter.superclass.getOptions.call(this);
  };

  /**
   * @private
   * @memberof oj.ColorConverter
   */
  ColorConverter.prototype._getFormat = function () {
    return ColorConverter.superclass.getOptions.call(this).format;
  };

  /**-------------------------------------------------------------*/
  /*   Helpers                                                    */
  /**-------------------------------------------------------------*/

  /**
   *  Converts an oj.Color object to a 3 or 6 hex character string
   *  @param {Object} color  The oj.Color object to be converted to a hex string.
   *  @param {boolean=} allow3Char  If true the representation is 3 hex characters
   *  (if possible). If false, or omitted, 6 hex characters are used.
   *  @return {string} The hex string representation of the color object.
   *  @private
   */
  ColorConverter._toHexString = function (color, allow3Char) {
    return '#' + ColorConverter._toHex(color, allow3Char);
  };

  /**
   *  Converts an oj.Color object to an hsl/hsla string
   *  @param {Object} color  The oj.Color object to be converted to an hsl/hsla string.
   *  @return {string} The hsl/hsla representation of the color object.
   *  @private
   */
  ColorConverter._toHslString = function (color) {
    var hsl = ColorConverter._rgbToHsl(color._r, color._g, color._b);
    var h = Math.round(hsl.h * 360);
    var s = Math.round(hsl.s * 100);
    var l = Math.round(hsl.l * 100);

    return color._a === 1
      ? 'hsl(' + h + ', ' + s + '%, ' + l + '%)'
      : 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + color._a + ')';
  };

  /**
   *  Converts an oj.Color object to a 3 or 6 hex character string
   *  @param {Object} color  The oj.Color object to be converted to a hex string.
   *  @param {boolean=} allow3Char  If true the representation is 3 hex characters
   *                   (if possible). If false, or omitted, 6 hex characters are used.
   *  @return {string} The hex string representation of the color object.
   *  @private
   */
  ColorConverter._toHex = function (color, allow3Char) {
    return ColorConverter._rgbToHex(color._r, color._g, color._b, allow3Char);
  };

  /**
   *  Converts an oj.Color object to an hsv/hsva string
   *  @param {Object} color  The oj.Color object to be converted to an hsv/hsva string.
   *  @return {string} The hsv/hsva representation of the color object.
   *  @private
   */
  ColorConverter._toHsvString = function (color) {
    var hsv = ColorConverter._rgbToHsv(color._r, color._g, color._b);

    var h = Math.round(hsv.h * 360);
    var s = Math.round(hsv.s * 100);
    var v = Math.round(hsv.v * 100);

    return color._a === 1
      ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)'
      : // "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + color._a + ')';
  };

  /**
   * Converts RGB color values to hex
   * @param {number} r the red value in the set [0,255]
   * @param {number} g the green value in the set [0,255]
   * @param {number} b the blue value in the set [0,255]
   * @param {boolean=} allow3Char  If true the representation is 3 hex characters
   *                   (if possible). If false, or omitted, 6 hex characters are used.
   * @returns {string} a 3 or 6 hex character string.
   * @private
   */
  ColorConverter._rgbToHex = function (r, g, b, allow3Char) {
    var hex = [
      ColorConverter._pad2(Math.round(r).toString(16)),
      ColorConverter._pad2(Math.round(g).toString(16)),
      ColorConverter._pad2(Math.round(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (
      allow3Char &&
      hex[0].charAt(0) === hex[0].charAt(1) &&
      hex[1].charAt(0) === hex[1].charAt(1) &&
      hex[2].charAt(0) === hex[2].charAt(1)
    ) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join('');
  };

  /**
   * Converts an RGB color value to HSL.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the h,s,l values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  r, g, b in [0, 255] or [0, 1]
   * @param {number} r the red value
   * @param {number} g the green value
   * @param {number} b the blue value
   * @returns {Object} Object with properties h, s, l, in [0, 1].
   * @private
   */
  ColorConverter._rgbToHsl = function (r, g, b) {
    // eslint-disable-next-line no-param-reassign
    r = ColorConverter._bound01(r, 255);
    // eslint-disable-next-line no-param-reassign
    g = ColorConverter._bound01(g, 255);
    // eslint-disable-next-line no-param-reassign
    b = ColorConverter._bound01(b, 255);

    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      h = 0; // achromatic
      s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }

      h /= 6;
    }

    return { h: h, s: s, l: l };
  };

  /**
   * Converts an RGB color value to HSV.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the h,s,v values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  r, g, and b are contained in the set [0,255] or [0,1]
   * @param {number} r the red value
   * @param {number} g the green value
   * @param {number} b the blue value
   * @returns {Object} Object with properties h, s, v, in [0,1].
   * @private
   */
  ColorConverter._rgbToHsv = function (r, g, b) {
    // eslint-disable-next-line no-param-reassign
    r = ColorConverter._bound01(r, 255);
    // eslint-disable-next-line no-param-reassign
    g = ColorConverter._bound01(g, 255);
    // eslint-disable-next-line no-param-reassign
    b = ColorConverter._bound01(b, 255);

    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var v = max;

    var d = max - min;
    var s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
      h /= 6;
    }
    return { h: h, s: s, v: v };
  };

  /**
   * Converts an RGBA color plus alpha transparency to hex
   * Assumes r, g, b and a are contained in the set [0, 255]
   * @param {number} r the red value in the set [0, 255]
   * @param {number} g the green value in the set [0, 255]
   * @param {number} b the blue value in the set [0, 255]
   * @param {number} a the alpha value in the set [0,1]
   * Returns an 8 character hex string
   */
  /*    NOT USED currently
     function rgbaToHex(r, g, b, a)
     {
     var hex = [
     pad2(convertDecimalToHex(a)),
     pad2(mathRound(r).toString(16)),
     pad2(mathRound(g).toString(16)),
     pad2(mathRound(b).toString(16))
     ];

     return hex.join("");
     }
     */

  /**
   * Take input from [0, n] and return it as [0, 1]
   * @private
   */
  ColorConverter._bound01 = function (n, max) {
    if (ColorConverter._isOnePointZero(n)) {
      // eslint-disable-next-line no-param-reassign
      n = '100%';
    }

    var processPercent = ColorConverter._isPercentage(n);
    // eslint-disable-next-line no-param-reassign
    n = Math.min(max, Math.max(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
      // eslint-disable-next-line no-param-reassign
      n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if (Math.abs(n - max) < 0.000001) {
      return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
  };

  /**
   *   Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
   *   <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
   *   @private
   */
  ColorConverter._isOnePointZero = function (n) {
    return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
  };

  /**
   *  Check to see if string passed in is a percentage
   *  @param {string}  n  The number string
   *  @return {boolean}  True if the string contains a '%' character.
   *  @private
   */
  ColorConverter._isPercentage = function (n) {
    return typeof n === 'string' && n.indexOf('%') !== -1;
  };

  /**
   *  Force a hex value string to have 2 characters by inserting a preceding zero
   *  if neccessary.  e.g. 'a' -> '0a'
   *  @param {string} c  The hex character(s) to be tested.
   *  @return {string} A two character hex string.
   *  @private
   */
  ColorConverter._pad2 = function (c) {
    return c.length === 1 ? '0' + c : '' + c;
  };

  /*
   *   Throw an invalid color specfication error.
   */
  ColorConverter._throwInvalidColorSyntax = function () {
    var summary = Translations.getTranslatedString('oj-converter.color.invalidSyntax.summary');
    var detail = Translations.getTranslatedString('oj-converter.color.invalidSyntax.detail');

    var ce = new ojvalidationError.ConverterError(summary, detail);

    throw ce;
  };

  /*
   *   Throw an invalid converter specfication error.
   */
  ColorConverter._throwInvalidColorFormatOption = function () {
    var summary = Translations.getTranslatedString('oj-converter.color.invalidFormat.summary');
    var detail = Translations.getTranslatedString('oj-converter.color.invalidFormat.detail');

    var ce = new ojvalidationError.ConverterError(summary, detail);

    throw ce;
  };

  return ColorConverter;

});


define('ojs/ojvalidator-length',['ojs/ojcore', 'ojs/ojtranslation', 'ojs/ojvalidator', 'ojs/ojvalidation-error'], function (oj, Translations, Validator, ojvalidationError) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Validator = Validator && Object.prototype.hasOwnProperty.call(Validator, 'default') ? Validator['default'] : Validator;

  /**
   * Constructs a LengthValidator that ensures the value entered is within a given length.
   * <p>
   * By default this uses Javascript's String length property
   * which counts a UTF-16 surrogate pair as length === 2.
   * If you need to count surrogate pairs as length === 1, then set the
   * <code class="prettyprint">countBy</code> option to <code class="prettyprint">"codePoint"</code>
   * or use
   * <code class="prettyprint">oj.LengthValidator.defaults.countBy = "codePoint";</code>
   * to set the page-wide default.
   * </p>
   * <p>
   * You can customize the default messages of all validators including this one
   * using the messageDetail and messageSummary options.
   * <p>
   * @param {Object=} options an object literal used to provide:<p>
   * @export
   * @constructor
   * @final
   * @augments oj.Validator
   * @name oj.LengthValidator
   * @ojtsmodule
   * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
   * @ojsignature [{target: "Type",
   *                value: "class LengthValidator implements Validator<number|string>"},
   *               {target: "Type",
   *                value: "oj.LengthValidator.ValidatorOptions",
   *                for: "options",
   *                jsdocOverride: true}
   *              ]
   * @since 0.7.0
   * @see oj.AsyncLengthValidator
   */
  const LengthValidator = function (options) {
    this.Init(options);
  };

  /**
   * @typedef {object} oj.LengthValidator.ValidatorOptions
   * @property {('codeUnit'|'codePoint')=} countBy - A string that specifies how to count the length. Valid values are
   * <code class="prettyprint">"codeUnit"</code> and <code class="prettyprint">"codePoint"</code>.
   * Defaults to <code class="prettyprint">oj.LengthValidator.defaults.countBy</code> which defaults
   * to <code class="prettyprint">"codeUnit"</code>.<br/>
   * <code class="prettyprint">"codeUnit"</code> uses javascript's length function which counts the
   * number of UTF-16 code units. Here a Unicode surrogate pair has a length of two. <br/>
   * <code class="prettyprint">"codePoint"</code>
   * counts the number of Unicode code points.
   * Here a Unicode surrogate pair has a length of one.<br/>
   * @property {number=} min - a number 0 or greater that is the minimum length of the value.
   * @property {number=} max - a number 1 or greater that is the maximum length of the value.
   * @property {Object=} hint - an optional object literal of hints to be used. If not set,
   * defaults will be used for the validator hint.
   * See the individual hint properties below for details.
   * <p>The hint strings (e.g., hint.min) are  passed as the 'pattern' parameter to
   * [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * @property {string=} hint.max - a hint message to be used to indicate the allowed maximum.
   * When not present, the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.hint.max</code>.<p>
   * Tokens: <br/>
   * {max} - the maximum<p>
   * Usage: <br/>
   * Enter {max} or fewer characters
   * @property {string=} hint.min - a hint message to be used to indicate the allowed minimum.
   * When not present, the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.hint.min</code>.<p>
   * Tokens: <br/>
   * {min} the minimum<p>
   * Usage: <br/>
   * Enter {min} or more characters
   * @property {string=} hint.inRange - a hint message to be used to indicate the allowed range.
   * When not present, the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.hint.inRange</code>.<p>
   * Tokens: <br/>
   * {min} the minimum<p>
   * {max} - the maximum<p>
   * Usage: <br/>
   * Enter between {min} and {max} characters
   * @property {string=} hint.exact - a hint message to be used, to indicate the exact length.
   * When not present, the default hint is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.hint.exact</code>.<p>
   * Tokens: <br/>
   * {length} the length<p>
   * Usage: <br/>
   * Enter {length} characters
   * @property {Object=} messageDetail - an optional object literal of custom error messages to
   * be used.
   * <p>The messageDetail strings (e.g., messageDetail.tooLong) are  passed as the 'pattern'
   * parameter to [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * @property {string=} messageDetail.tooLong - the detail error message to be used as the error
   * message, when the length of the input value exceeds the maximum value set. When not present, the
   * default detail message is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.messageDetail.tooLong</code>.<p>
   * Tokens:<br/>
   * {value} - value entered by the user<br/>
   * {max} - the maximum allowed value<p>
   * Usage: <br/>
   * The {value} has too many characters. Enter {max} or fewer characters, not more.
   * @property {string=} messageDetail.tooShort - the detail error message to be used as the error
   * message, when the length of the input value is less the minimum value set. When not present, the
   * default detail message is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.messageDetail.tooShort</code>.<p>
   * Tokens:<br/>
   * {value} - value entered by the user<br/>
   * {min} - the minimum allowed value<p>
   * Usage: <br/>
   * The {value} has too few characters. Enter {min} or more characters, not less.
   * @property {Object=} messageSummary - optional object literal of custom error summary message
   * to be used.
   * <p>The messageSummary strings (e.g., messageSummary.tooLong) are  passed as the 'pattern'
   * parameter to [oj.Translations.html#applyParameters]{@link oj.Translations}. As stated in
   * that documentation, if you are using a reserved character, you need to escape it with
   * a dollar character ('$').
   * </p>
   * @property {string=} messageSummary.tooLong - the message to be used as the summary error
   * message, when the length of the input value exceeds the maximum value set. When not present, the
   * default message summary is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.messageSummary.tooLong</code>.
   * @property {string=} messageSummary.tooShort - the message to be used as the summary error
   * message, when input value is less than the set minimum value. When not present, the default
   * message summary is the resource defined with the key
   * <code class="prettyprint">oj-validator.length.messageSummary.tooShort</code>.
   */

  /**
   * The set of attribute/value pairs that serve as default values
   * when new LengthValidator objects are created.
   * <p>
   * LengthValidator's <code class="prettyprint">countBy</code> option may be changed
   * for the entire application after the 'ojs/ojvalidator-length' module is loaded
   * (each form control module includes the 'ojs/ojvalidator-length' module). If the
   * <code class="prettyprint">options.countBy</code> is specifically set,
   * it will take precedence over this default.
   * </p>
   * <p>For example:
   * <code class="prettyprint">
   * oj.LengthValidator.defaults.countBy = 'codePoint';
   * </code></p>
   * @property {string} countBy count the length by <code class="prettyprint">"codeUnit"</code> or
   * <code class="prettyprint">"codePoint"</code>.
   * Defaults to <code class="prettyprint">"codeUnit"</code>.
   * @export
   * @memberof oj.LengthValidator
   * @since 2.1.0
   * @type object
   * @name defaults
   * @static
   */
  LengthValidator.defaults = {
    countBy: 'codeUnit'
  };

  // Subclass from oj.Validator
  oj.Object.createSubclass(LengthValidator, Validator, 'oj.LengthValidator');

  /**
   * Initializes validator instance with the set options
   * @param {Object=} options
   * @memberof oj.LengthValidator
   * @instance
   * @export
   * @ignore
   */
  LengthValidator.prototype.Init = function (options) {
    var countByOptions = options.countBy;

    LengthValidator.superclass.Init.call(this);

    this._min = options.min !== undefined ? parseInt(options.min, 10) : null;
    this._max = options.max !== undefined ? parseInt(options.max, 10) : null;

    // check that the min/max make sense, otherwise throw an error
    if (isNaN(this._min)) {
      throw new Error("length validator's min option is not a number. min option is " + options.min);
    }
    if (isNaN(this._max)) {
      throw new Error("length validator's max option is not a number. max option is " + options.min);
    }
    if (this._min !== null && this._min < 0) {
      throw new Error(
        "length validator's min option cannot be less than 0. min option is " + options.min
      );
    }
    if (this._max !== null && this._max < 1) {
      throw new Error(
        "length validator's max option cannot be less than 1. max option is " + options.max
      );
    }

    this._countBy = countByOptions === undefined ? LengthValidator.defaults.countBy : countByOptions;

    if (options) {
      this._hint = options.hint || {};
      this._customMessageSummary = options.messageSummary || {};
      this._customMessageDetail = options.messageDetail || {};
    }
  };

  /**
   * A message to be used as hint, when giving a hint about the expected length. There is no default
   * hint for this property.
   *
   * @returns {string|null} a hint message or null if no hint is available in the options
   * @memberof oj.LengthValidator
   * @instance
   * @export
   * @method getHint
   */
  LengthValidator.prototype.getHint = function () {
    var hint = null;
    var hints = this._hint;
    var hintExact = hints.exact;
    var hintInRange = hints.inRange;
    var hintMaximum = hints.max;
    var hintMinimum = hints.min;

    var max = this._max;
    var min = this._min;
    var params;
    var translations = Translations;

    if (min !== null && max !== null) {
      if (min !== max) {
        params = { min: min, max: max };
        hint = hintInRange
          ? translations.applyParameters(hintInRange, params)
          : translations.getTranslatedString('oj-validator.length.hint.inRange', params);
      } else {
        params = { length: min };
        hint = hintExact
          ? translations.applyParameters(hintExact, params)
          : translations.getTranslatedString('oj-validator.length.hint.exact', params);
      }
    } else if (min !== null) {
      params = { min: min };
      hint = hintMinimum
        ? translations.applyParameters(hintMinimum, params)
        : translations.getTranslatedString('oj-validator.length.hint.min', params);
    } else if (max !== null) {
      params = { max: max };
      hint = hintMaximum
        ? translations.applyParameters(hintMaximum, params)
        : translations.getTranslatedString('oj-validator.length.hint.max', params);
    }

    return hint;
  };

  /**
   * Validates the length of value is greater than minimum and/or less than maximum.
   * @param {string|number} value that is being validated
   * @returns {void}
   * @ojsignature {target: "Type", for: "returns",
   *                value: "void"}
   * @throws {Error} when the length is out of range.
   * @export
   * @memberof oj.LengthValidator
   * @instance
   * @method validate
   */
  LengthValidator.prototype.validate = function (value) {
    var customMessageDetail = this._customMessageDetail;
    var customMessageSummary = this._customMessageSummary;
    var detail = '';
    var max = this._max;
    var messageSummaryTooLong = customMessageSummary.tooLong;
    var messageSummaryTooShort = customMessageSummary.tooShort;
    var messageTooLong = customMessageDetail.tooLong;
    var messageTooShort = customMessageDetail.tooShort;
    var min = this._min;
    var params;
    var summary = '';
    var translations = Translations;
    var string = '' + value;
    var length = this._getLength(string);

    // If only min is set and length is at least min, or
    // if only max is set and length is at most max, or
    // if length is between min and max or
    // if neither min or max is set return with no error.
    if ((min === null || length >= this._min) && (max === null || length <= this._max)) {
      return;
    }

    if (length < this._min) {
      // too short
      params = { value: value, min: min };
      summary = messageSummaryTooShort
        ? translations.applyParameters(messageSummaryTooShort, params)
        : translations.getTranslatedString('oj-validator.length.messageSummary.tooShort');
      detail = messageTooShort
        ? translations.applyParameters(messageTooShort, params)
        : translations.getTranslatedString('oj-validator.length.messageDetail.tooShort', params);
    } else {
      // too long
      params = { value: value, max: max };
      summary = messageSummaryTooLong
        ? translations.applyParameters(messageSummaryTooLong, params)
        : translations.getTranslatedString('oj-validator.length.messageSummary.tooLong');
      detail = messageTooLong
        ? translations.applyParameters(messageTooLong, params)
        : translations.getTranslatedString('oj-validator.length.messageDetail.tooLong', params);
    }

    throw new ojvalidationError.ValidatorError(summary, detail);
  };

  /**
   * @returns {number} the length of the text counted by UTF-16 codepoint
   *  or codeunit as specified in the countBy option.
   * @private
   */
  LengthValidator.prototype._getLength = function (text) {
    var countBy = this._countBy.toLowerCase();
    var codeUnitLength = text.length;
    var length;
    var surrogateLength = 0;

    switch (countBy) {
      case 'codepoint':
        // if countBy is "codePoint", then count supplementary characters as length of one
        // For UTF-16, a "Unicode  surrogate pair" represents a single supplementary character.
        // The first (high) surrogate is a 16-bit code value in the range U+D800 to U+DBFF.
        // The second (low) surrogate is a 16-bit code value in the range U+DC00 to U+DFFF.
        // This code figures out if a charCode is a high or low surrogate and if so,
        // increments surrogateLength
        for (var i = 0; i < codeUnitLength; i++) {
          // eslint-disable-next-line no-bitwise
          if ((text.charCodeAt(i) & 0xf800) === 0xd800) {
            surrogateLength += 1;
          }
        }
        // e.g., if the string is two supplementary characters, codeUnitLength is 4, and the
        // surrogateLength is 4, so we will return two.
        oj.Assert.assert(
          surrogateLength % 2 === 0,
          'the number of surrogate chars must be an even number.'
        );
        length = codeUnitLength - surrogateLength / 2;
        break;
      case 'codeunit':
      default:
        // Javascript's length function counts # of code units.
        // A supplementary character has a length of 2 code units.
        length = codeUnitLength;
    }
    return length;
  };

  return LengthValidator;

});



define('ojs/ojvalidationfactory-base',['ojs/ojcore',
'ojs/ojlogger',
'ojs/ojconverter-color', 
'ojs/ojvalidator-length', 
'ojs/ojvalidator-regexp', 
'ojs/ojvalidator-required'], function(oj,
Logger,
ColorConverter, 
LengthValidator, 
RegExpValidator, 
RequiredValidator)
{
  "use strict";



/* global Logger:false */

/**
 * Used to register and retrieve converterFactories and validationFactories.
 * There is no need to call the constructor.
 * @see oj.Validation.converterFactory
 * @see oj.Validation.validatorFactory
 * @see oj.ConverterFactory
 * @see oj.ValidatorFactory
 * @name oj.Validation
 * @namespace
 * @hideconstructor
 * @export
 * @since 0.6.0
 *
 */
var Validation = {};

/**
 * Internal properties to hold all factory provider callbacks or instances by name
 * @private
 */
Validation._converterFactories = {};
Validation._validatorFactories = {};

/**
 * Internal properties to hold the default factory instances.
 * @private
 */
Validation._defaultConverterFactories = {};
Validation._defaultValidatorFactories = {};

/**
 * Method to register and retrieve converter factory instances by name.
 * When passed only the name, an existing factory (registered for the name) is returned. Callers can
 * expect to get back the default 'number', 'datetime', or 'color' converters.
 * When passed two arguments, a new factory for the name is registered. If the name already exists
 * the new instance replaces the old one.
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances ColorConverter, DateTimeConverter, and NumberConverter instead.'}
 * @param {string} type a case insensitive name of the converter factory. e.g., 'number' (or
 * oj.ConverterFactory.CONVERTER_TYPE_NUMBER), 'datetime' (or oj.ConverterFactory.CONVERTER_TYPE_DATETIME),
 * or 'color' (or oj.ConverterFactory.CONVERTER_TYPE_COLOR).
 * @param {Object=} instance the instance of the factory that implements the contract for
 * oj.ConverterFactory.
 *
 * @export
 * @memberof oj.Validation
 * @name converterFactory
 * @method
 * @ojsignature {target: "Type",
 *                value: "<CF extends oj.ConverterFactory<any, any>>(type:'number'|'color'|'datetime'|string, instance?:CF): CF|null"}
 * @see oj.ConverterFactory
 * @example <caption>Initialize a JET datetime converter instance using options
 * and use it in a knockout-binding and bind it to the
 * converter attribute on the JET form element.</caption>
 * ----- Javascript ViewModel----
 * self.converter = ko.observable(
    oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).
      createConverter({formatType: 'date', dateFormat: 'full'}));
 * ----- HTML -----
 * &lt;oj-input-date value="{{endDate}}" converter="[[converter]]">&lt/oj-input-date>
 * @example <caption>Create your own converter, register it, and use it when displaying information
 * on the page to the user.</caption>
 * ----- Javascript -----
 * RelativeDateTimeConverterFactory = (function () {
 *  function _createRelativeDateTimeConverter(options)
 *  {
 *    // this is a custom converter that formats the datetime into "Today" or
 *    // "Tomorrow", or "This Week"/"Next Week", etc. See the Converter API or
 *    // the Custom Converter demos for how to create a custom converter.
 *    return new RelativeDateTimeConverter(options);
 *  }
 *  return {
 *    'createConverter': function (options) {
 *      return _createRelativeDateTimeConverter(options);
 *    }
 *  };
 *  }());
 * oj.Validation.converterFactory("relativeDate", RelativeDateTimeConverterFactory);
 *  // Use our custom relativeDate converter.
 *  // In this demo, we want to see in the Schedule For column the words
 *  // Today or Tomorrow so we set the relativeField option's value
 *  // to 'day'. If we want to see This Week, we'd set it to 'week', etc.
 *  var rdConverter =  oj.Validation.converterFactory("relativeDate")
 *  .createConverter({relativeField: 'day', year: "numeric", month: "numeric", day: "numeric"});
 *  ...
 *  // Our custom converter's format function returns an object with 'value' and 'title'.
 *  // We put the 'value' in innerHTML so the user can read it. E.g., Today or Tomorrow.
 *  // And we put the actual date in the title. The user can read it when they hover over
 *  // the word Today or Tomorrow.
 *  content = rdConverter.format(context.row.ScheduleFor);
 *  span.setAttribute('title', content.title);
 *  span.innerHTML = content.value;
 * ...
 * @example <caption>On your JET form component that has a 'converter' attribute,
 * set the 'converter' attribute using "type" of a registered converter. This
 * could be a JET Converter or a oj.Converter
 * (or Object that duck-types it) that you wrote. (it must implement parse and format
 * since our JET form components call format and parse.</caption>
 * &lt;oj-input-date value="{{date}}"
 * converter= '{"type":"datetime",
 * "options": {"year": "numeric", "month": "long", "day": "numeric"}}'> &lt;/oj-input-date>
 */
Validation.converterFactory = function (type, instance) {
  var retValue;
  if (type && !instance) {
    // getter
    retValue = Validation._getFactory(type, Validation._converterFactories);

    if (retValue === null) {
      let lowerTypeStr = type.toLowerCase();
      let errString = 'Converter of type ' + type + ' cannot be found.';
      switch (lowerTypeStr) {
        case 'datetime':
          Logger.error(errString + ' Please import the ojs/ojvalidation-datetime module.');
          break;
        case 'number':
          Logger.error(errString + ' Please import the ojs/ojvalidation-number module.');
          break;
        default:
          Logger.warn(errString);
      }
    }
  } else if (type && instance) {
    // setter
    retValue = Validation._registerFactory(
      type,
      instance,
      Validation._converterFactories,
      Validation._CONTRACTS.converter
    );
    Logger.error(
      'Registering a custom type or overriding the standard types is no longer supported. Please directly set the converter on the component. Please consult the Release Notes for further information.'
    );
  }

  return retValue;
};

/**
 * Method to register and retrieve validator factory instances by name.
 * When passed only the name, an existing factory (registered for the name) is returned.
 * When passed two arguments, a new factory for the name is registered. If the name already exists
 * the new instance replaces the old one.
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances validator instead.'}
 * @param {string} type a case insensitive name of the validator factory.
 * @param {Object=} instance the instance of the factory that implements the contract for
 * oj.ValidatorFactory.
 * @example <caption>Initialize a JET validator instance using options
 * and use it in a knockout-binding and bind it to the
 * validators attribute on the JET form element.</caption>
 * ----- Javascript ViewModel----
 * var options = {min: 5, max: 10};
 * var validator =
 * oj.Validation.validatorFactory(
 * oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH).createValidator(options);
 * self.validator = ko.observable([validator]);
 * ----- HTML -----
 * &lt;oj-input-text validators="[[validator]]">&lt/oj-input-text>
 * @example <caption>An easier usage is to return an Object since the validators option
 * takes an array where each item is either an instance that duck types oj.Validator,
 * or is an Object literal containing type and options.</caption>
 * ----- Javascript ViewModel -----
 * self.validators = ko.computed(function() {
 * return [{type: 'numberRange', options: { min: 10000.05, max: 25000.95,
 * hint: {inRange: 'Enter a value between {min} and {max}.'}}}];
 * });
 * ----- HTML -----
 * &lt;oj-input-text id="numberRange1" value="{{numberValue1}}" validators="[[validators]]">
 * &lt;/oj-input-text>
 * @example <caption>Get a registered validator with your options, and calls its validate method
 * on your own value.</caption>
 * var reqValOptions = {
 *   'hint': reqTrans['hint'] || null,
 *   'label': this._getLabelText(),
 *   'messageSummary': reqTrans['messageSummary'] || null,
 *   'messageDetail': reqTrans['messageDetail'] || null
 * };
 * var vf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED);
 * var requiredValidator = vf.createValidator(reqValOptions);
 * var isValid = validator.validate(value);
 * @example <caption>Create and register your own factory</caption>
 * MyOwnNumberRangeValidatorFactory = (function () {
 *   function _createNumberRangeValidator(options) {
 *     return new MyOwnNumberRangeValidator(options);
 *   }
 *
 *   return {
 *     'createValidator': function(options) {
 *       return _createNumberRangeValidator(options);
 *   }
 *   };
 * }());
 * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE, MyOwnNumberRangeValidatorFactory);
 * @export
 * @since 0.6.0
 * @see oj.ValidatorFactory
 * @memberof oj.Validation
 * @name validatorFactory
 * @method
 * @ojsignature {target: "Type",
 *   value: "<VF extends oj.ValidatorFactory<any,any>>(type:'required'|'regexp'|'numberRange'|'length'|'dateTimeRange'|'dateRestriction'|string, instance?:VF): VF|null"}
 */
Validation.validatorFactory = function (type, instance) {
  var retValue;
  if (type && !instance) {
    // getter
    retValue = Validation._getFactory(type, Validation._validatorFactories);
    if (retValue === null) {
      var lowerTypeStr = type.toLowerCase();
      var errString = 'Unable to locate a validatorFactory for the requested type: ' + type;
      switch (lowerTypeStr) {
        case 'daterestriction':
          Logger.error(errString + '. Please import the ojs/ojvalidation-datetime module.');
          break;
        case 'datetimerange':
          Logger.error(errString + '. Please import the ojs/ojvalidation-datetime module.');
          break;
        case 'numberrange':
          Logger.error(errString + '. Please import the ojs/ojvalidation-number module.');
          break;
        default:
          Logger.warn(errString);
      }
    }
  } else if (type && instance) {
    // setter
    retValue = Validation._registerFactory(
      type,
      instance,
      Validation._validatorFactories,
      Validation._CONTRACTS.validator
    );
    Logger.error(
      'Registering a custom type or overriding the standard types is no longer supported. Please directly set the converter on the component. Please consult the Release Notes for further information.'
    );
  }

  return retValue;
};

/**
 * Returns the default converter factory instances for the supported types as defined by the
 * oj.ConverterFactory. Instead of calling this method, it should be
 * sufficient to use oj.Validation.converterFactory.
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances ColorConverter, DateTimeConverter, and NumberConverter instead.'}
 * @param {string} type The default converter factory for the type. Supported types are 'number' and
 * 'datetime'
 * @return {Object|null} an instance of oj.ConverterFactory or null if an unknown type is requested.
 *
 * @export
 * @ojtsignore
 * @memberof oj.Validation
 * @method
 * @ojsignature {target:"Type",
 *    value: "<V>(type: 'number'|'color'|'datetime'): oj.ConverterFactory<V>|null"}
 * @see oj.ConverterFactory
 * @see oj.Validation.converterFactory
 *
 */
Validation.getDefaultConverterFactory = function (type) {
  return Validation._getFactory(type, Validation._defaultConverterFactories);
};

/**
 * Returns the default validator factory instance for the requested types as defined by the
 * oj.ValidatorFactory.  Instead of calling this method, it should be
 * sufficient to use oj.Validation.validatorFactory.
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances validator instead.'}
 * @param {string} type The default converter factory for the type. Supported types are 'number' and
 * 'datetime'
 * @return {Object|null} an instance of oj.ConverterFactory or null if an unknown type is requested.
 *
 * @export
 * @ojtsignore
 * @memberof oj.Validation
 * @method
 * @ojsignature {target:"Type",
 *    value: "<V>(type: 'required'|'regexp'|'numberRange'|'length'|'dateTimeRange'|'dateRestriction'): oj.ValidatorFactory<V>|null"}
 * @see oj.ValidatorFactory
 * @see oj.Validation.validatorFactory
 */
Validation.getDefaultValidatorFactory = function (type) {
  return Validation._getFactory(type, Validation._defaultValidatorFactories);
};

// PACKAGE PRIVATE METHODS
/**
 * Called only by internal jet converter factory implementations.
 *
 * @param {string} name
 * @param {Object} instance
 * @private
 */
Validation.__registerDefaultConverterFactory = function (name, instance) {
  // save to both factories
  var contractDef = Validation._CONTRACTS.converter;
  Validation._registerFactory(name, instance, Validation._defaultConverterFactories, contractDef);
  Validation._registerFactory(name, instance, Validation._converterFactories, contractDef);
};

/**
 * Called only by internal jet validator factory implementations.
 *
 * @param {string} name of the validator factory
 * @param {Object} instance of the validator factory that creates instances of the validator
 * @private
 */
Validation.__registerDefaultValidatorFactory = function (name, instance) {
  // save to both factories
  var contractDef = Validation._CONTRACTS.validator;
  Validation._registerFactory(name, instance, Validation._defaultValidatorFactories, contractDef);
  Validation._registerFactory(name, instance, Validation._validatorFactories, contractDef);
};

/**
 * Checks that the instance implements the interface type. If it doesn't it throws an error.
 * @param {Object} instance
 * @param {Object} type
 * @param {string} typeName
 * @throws {Error} if instance does not implement the methods defined on type.
 * @private
 */
Validation._doImplementsCheck = function (instance, type, typeName) {
  if (type) {
    // Check that instance duck types providerType
    if (!Validation._quacksLike(instance, type)) {
      throw new Error(
        'Factory instance does not implement the methods expected by the factory of type ' +
          typeName
      );
    }
  }
};

/**
 * Retrieves the converter factory by name from the provided factories.
 * @private
 */
Validation._getFactory = function (name, factories) {
  oj.Assert.assertString(name);
  var cachedInstance = null;

  var lowerName = name.toLowerCase();

  // getter called to retrieve the factory instance
  var providerProps = factories[lowerName] || {};
  cachedInstance = providerProps.instance || null;
  // TODO: log a warning that name is null
  return cachedInstance;
};

/**
 * Tests whether an object 'quacks like a duck'. Returns `true` if the thingie has all of the
 * methods of the second, parameter 'duck'. Returns `false` otherwise.
 *
 * @param {Object} thingie the object to test.
 * @param {Object} duck The archetypal object, or 'duck', that the test is against.
 * @private
 */
Validation._quacksLike = function (thingie, duck) {
  var valid = true;

  oj.Assert.assertObject(thingie);
  oj.Assert.assertObject(duck);

  var properties = Object.keys(duck);
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    // Ensure that thingie defines the same functions as duck. We don't care about other properties
    if (
      typeof duck[property] === 'function' &&
      (!thingie[property] || typeof thingie[property] !== 'function')
    ) {
      valid = false;
      break;
    }
  }

  return valid;
};

/**
 * Registers the factory instance by the name, storing it into the factories object, after ensuring
 * that the instance duck types the specified contract.
 *
 * @private
 */
Validation._registerFactory = function (name, instance, factories, contractDef) {
  oj.Assert.assertString(name);
  oj.Assert.assertObject(instance);

  // set new provider factory function clearing out the previously stored instance
  var props = {};
  props.instance = instance;
  Validation._doImplementsCheck(instance, contractDef.type, contractDef.name);

  // Save to default and public factories
  // eslint-disable-next-line no-param-reassign
  factories[name.toLowerCase()] = props;
};

/**
 * Contract for a ConverterFactory that provides a factory method to create a converter instance for
 * the requested type. Factories handle the details of object creation.
 * It allows the consumers of the factory to create specific converters
 * without knowing the internals of the converter creation.
 * <p>
 * JET provides three factory implementations for number and datetime
 * and color types that implement this contract.
 * </p>
 * <p>
 * Customers can register custom converter factories for the supported
 * types or create and register factories for new types altogether.
 * </p>
 * @example <caption>Get the ConverterFactory for 'datetime', and create
 * a JET dateTime converter with specific options.
 * See {@link oj.DateTimeConverterFactory} for what to set for options
 * for the DateTime Converter. </caption>
 * var dateTimeCvtr = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME);
 * var dateOptions = {day: 'numeric', month: 'numeric'};
 * var dayMonthConverter = dateTimeCvtr.createConverter(dateOptions);
 * @example <caption>Create a custom ConverterFactory with a new type and register that ConverterFactory.</caption>
 * // Define a new ConverterFactory for relative datetimes, like Today, Yesterday, Tomorrow
 * RelativeDateTimeConverterFactory = (function () {
 *   function _createRelativeDateTimeConverter(options)
 *   {
 *     // this is a custom converter
 *     // See the Custom Converter JET demo for details on how to create
 *     // your own Converter. Or see the Converter jsdoc.
 *     return new RelativeDateTimeConverter(options);
 *   }
 *   return {
 *     'createConverter': function (options) {
 *       return _createRelativeDateTimeConverter(options);
 *     }
 *   };
 * }());
 *
 * // Register the custom factory with the new "relativeDate" type
 * oj.Validation.converterFactory("relativeDate", RelativeDateTimeConverterFactory);
 *
 * // Get the custom factory using the new type.
 * var rdConverter =  oj.Validation.converterFactory("relativeDate")
 * .createConverter({relativeField: 'day', year: "numeric", month: "numeric", day: "numeric"});
 * @ojdeprecated {since: '8.0.0', description: 'Use string literals instead of the member constants.'}
 * @name oj.ConverterFactory
 * @abstract
 * @class
 * @export
 * @ojtsimport {module: "ojconverter", type: "AMD", importName: "Converter"}
 * @since 0.6.0
 * @ojsignature {target: "Type", value: "class ConverterFactory<V, O>", genericParameters: [{"name": "V", "description": "Type of value to be converted"}]}
 * @see oj.Validation
 * @see oj.NumberConverterFactory
 * @see oj.DateTimeConverterFactory
 * @see oj.ColorConverterFactory
 */
var ConverterFactory = {
  /**
   * Default type for a factory used to create number converters. This type is passed to the
   * [Validation.converterFactory]{@link oj.Validation.converterFactory} method to retrieve the
   * number converter factory of type {@link oj.NumberConverterFactory}.
   * @example <caption>Create a JET number converter with options</caption>
   * var convFactory = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER);
   * var converter  =  convFactory.createConverter({
   *  style: 'currency',
   *  currency: 'USD',
   *  currencyDisplay: 'symbol',
   *  pattern: '¤ ##,##0.00'});
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ConverterFactory
   * @type {string}
   */
  CONVERTER_TYPE_NUMBER: 'number',

  /**
   * Default type for a factory used to create datetime converters. This type is passed to the
   * [Validation.converterFactory]{@link oj.Validation.converterFactory} method to retrieve the
   * datetime converter factory of type {@link oj.DateTimeConverterFactory}.
   * @example <caption>Create a JET dateTime converter with options</caption>
   * var dateTimeCvtr = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME);
   * var dateOptions = {day: 'numeric', month: 'numeric'};
   * var dayMonthConverter = dateTimeCvtr.createConverter(dateOptions);
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ConverterFactory
   * @type {string}
   */

  CONVERTER_TYPE_DATETIME: 'datetime',

  /**
   * Default type for a factory used to create color converters. This type is passed to the
   * [Validation.converterFactory]{@link oj.Validation.converterFactory} method to retrieve the
   * color converter factory of type {@link oj.ColorConverterFactory}.
   * @example <caption>Create a JET color converter with options</caption>
   * this._convFactory = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_COLOR);
   * this._convHex  =  this._convFactory.createConverter({"format": "hex"})
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ConverterFactory
   * @type {string}
   */
  CONVERTER_TYPE_COLOR: 'color',

  /**
   * Creates an immutable converter instance of the type the factory implements.
   *
   * @param {Object=} options an object literal containing properties required by the converter
   * for its initialization. The properties provided in the options is implementation specific.
   *
   * @return {oj.Converter} a converter instance.
   * @memberof oj.ConverterFactory
   * @ojsignature {target: "Type",
   *               value: "(options?: O): Converter<V> | Promise.<Converter<V>>"}
   * @instance
   * @throws {TypeError} if an unrecognized type was provided
   * @expose
   *
   * @example <caption>Create a JET dateTime converter with options</caption>
   * var dateTimeCvtr = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME);
   * var dateOptions = {day: 'numeric', month: 'numeric'};
   * var dayMonthConverter = dateTimeCvtr.createConverter(dateOptions);
   * @example <caption>Create your own ConverterFactory and Converter, register the Converter on your
   * ConverterFactory, and use it when displaying relative date information
   * on the page to the user.</caption>
   * ----- Javascript -----
   * // Define new ConverterFactory
   * RelativeDateTimeConverterFactory = (function () {
   *   function _createRelativeDateTimeConverter(options)
   *   {
   *     // this is a custom converter See the Converter API or
   *     // Custom Converter JET demo for details on
   *     // how to create a custom converter.
   *     return new RelativeDateTimeConverter(options);
   *   }
   *   return {
   *     'createConverter': function (options) {
   *       return _createRelativeDateTimeConverter(options);
   *     }
   *   };
   * }());
   * // Register the custom factory with the new type
   * oj.Validation.converterFactory("relativeDate", RelativeDateTimeConverterFactory);
   * // Get the custom factory using the new type.
   * var rdConverter =  oj.Validation.converterFactory("relativeDate")
   * .createConverter({relativeField: 'day', year: "numeric", month: "numeric", day: "numeric"});
   *  ...
   *  // Our custom converter's format function returns an object with 'value' and 'title'.
   *  // We put the 'value' in innerHTML so the user can read it. E.g., Today or Tomorrow.
   *  // And we put the actual date in the title. The user can read it when they hover over
   *  // the word Today or Tomorrow.
   *  content = rdConverter.format(context.row.ScheduleFor);
   *  span.setAttribute('title', content.title);
   *  span.innerHTML = content.value;
   * ...
   */
  // eslint-disable-next-line no-unused-vars
  createConverter: function (options) {}
};

/**
 * Contract for a ValidatorFactory that provides a factory method to create a validator instance for
 * the requested type. JET provides several factory implementations that implement this contract -
 * for example dateRestriction, dateTimeRange, numberRange, length, required, regexp.
 * <p> Customers can
 * register custom validator factories for the supported types or create and register factories for
 * new types altogether.
 * </p>
 * @example <caption>Create a JET regexp validator</caption>
 * var validatorFactory =
 *   oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);
 *
 * var options =
 *   {pattern: '[a-zA-Z0-9]{3,}',
 *   hint: 'enter at least 3 letters or numbers.',
 *   messageDetail: 'You must enter at least 3 letters or numbers.'}
 *
 * var validator = validatorFactory.createValidator(options);
 * @example <caption>Create and register your own ValidatorFactory</caption>
 * MyOwnNumberRangeValidatorFactory = (function () {
 *   function _createNumberRangeValidator(options) {
 *     // See Validator api or Custom Validator demos for how to create your own Validator
 *     return new MyOwnNumberRangeValidator(options);
 *   }
 *
 *   return {
 *     'createValidator': function(options) {
 *       return _createNumberRangeValidator(options);
 *   }
 *   };
 * }());
 *
 * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE, MyOwnNumberRangeValidatorFactory);
 * @ojdeprecated {since: '8.0.0', description: 'Use string literals instead of the member constants.'}
 * @name oj.ValidatorFactory
 * @abstract
 * @class
 * @ojsignature {target: "Type", value: "class ValidatorFactory<V, O>", genericParameters: [{"name": "V", "description": "Type of value to be validated"}]}
 * @export
 * @ojtsimport {module: "ojvalidator", type: "AMD", importName: "Validator"}
 * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
 * @since 0.6.0
 * @see oj.Validation
 * @see oj.DateRestrictionValidatorFactory
 * @see oj.DateTimeRangeValidatorFactory
 * @see oj.LengthValidatorFactory
 * @see oj.NumberRangeValidatorFactory
 * @see oj.RegExpValidatorFactory
 * @see oj.RequiredValidatorFactory
 */
var ValidatorFactory = {
  /**
   * Default type for a factory used to create required validators. This type is passed to the
   * [Validation.validatorFactory]{@link oj.Validation.validatorFactory} method to retrieve the
   * required validator factory of type {@link oj.RequiredValidatorFactory}.
   * @example <caption>Create a JET required validator</caption>
   * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED);
   * var options = {'hint' : 'a value is required for this field'};
   * var requiredValidator = rvf.createValidator(options);
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ValidatorFactory
   * @type {string}
   */
  VALIDATOR_TYPE_REQUIRED: 'required',

  /**
   * Default type for a factory used to create regExp validators. This type is passed to the
   * [Validation.validatorFactory]{@link oj.Validation.validatorFactory} method to retrieve the
   * regExp validator factory of type {@link oj.RegExpValidatorFactory}.
   * @example <caption>Create a JET regexp validator</caption>
   * var validatorFactory =
   * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);
   * var options =
   * {pattern: '[a-zA-Z0-9]{3,}',
   * hint: 'enter at least 3 letters or numbers.',
   * messageDetail: 'You must enter at least 3 letters or numbers.'}
   * var validator = validatorFactory.createValidator(options);
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ValidatorFactory
   * @type {string}
   */
  VALIDATOR_TYPE_REGEXP: 'regexp',

  /**
   * Default type for a factory used to create numberRange validators. This type is passed to the
   * [Validation.validatorFactory]{@link oj.Validation.validatorFactory} method to retrieve the
   * numberRange validator factory of type {@link oj.NumberRangeValidatorFactory}.
   * @example <caption>Create a JET numberrange validator</caption>
   * var validatorFactory =
   * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE);
   * var options = {min: 10000.05, max: 25000.95,
   * hint: {inRange: 'Enter a value between {min} and {max}.'}};
   * var validator = validatorFactory.createValidator(options);
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ValidatorFactory
   * @type {string}
   */
  VALIDATOR_TYPE_NUMBERRANGE: 'numberRange',

  /**
   * Default type for a factory used to create length validators. This type is passed to the
   * [Validation.validatorFactory]{@link oj.Validation.validatorFactory} method to retrieve the
   * length validator factory of type {@link oj.LengthValidatorFactory}.
   * @example <caption>Create a JET length validator</caption>
   * var validatorFactory =
   * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH);
   * var options = {min: 5, max: 10};
   * var validator = validatorFactory.createValidator(options);
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ValidatorFactory
   * @type {string}
   */
  VALIDATOR_TYPE_LENGTH: 'length',

  /**
   * Default type for a factory used to create required validators. This type is passed to the
   * [Validation.validatorFactory]{@link oj.Validation.validatorFactory} method to retrieve the
   * dateTimeRange validator factory of type {@link oj.DateTimeRangeValidatorFactory}.
   * @example <caption>Create a JET datetime validator</caption>
   * var validator =
   * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE)
   * .createValidator({{max: oj.IntlConverterUtils.dateToLocalIso(new Date()),
   * min: oj.IntlConverterUtils.dateToLocalIso(new Date(2000, 00, 01)),
   * hint: {'inRange': 'Enter a date that falls in the current millennium.'}});
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ValidatorFactory
   * @type {string}
   */
  VALIDATOR_TYPE_DATETIMERANGE: 'dateTimeRange',

  /**
   * Default type for a factory used to create date restriction validators. This type is passed to
   * the [Validation.validatorFactory]{@link oj.Validation.validatorFactory} method to retrieve the
   * dateRestriction validator factory of type {@link oj.DateRestrictionValidatorFactory}.
   * @example <caption>Create a JET dateRestriction validator</caption>
   * var validatorFactory =
   * oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION);
   * var options = {dayFormatter : self.aprilFoolsFormatter, // your own formatter code
   * message : {messageDayMetaData : 'You can\'t fool me! Try a different date.'}};
   * var validator = validatorFactory.createValidator(options);
   * @ojdeprecated {since: '8.0.0', description: 'Use the string instead.'}
   * @expose
   * @const
   * @member
   * @memberof oj.ValidatorFactory
   * @type {string}
   */
  VALIDATOR_TYPE_DATERESTRICTION: 'dateRestriction',

  /**
   * Creates an immutable validator instance of the type the factory implements.
   * For the specific options parameters, see the Validator jsdoc for the validator you
   * are creating, e.g., oj.RequiredValidator if you are creating a required validator.
   *
   * @example <caption>create an instance of the required validator using the factory</caption>
   * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED);
   * var options = {'hint' : 'a value is required for this field'};
   * var requiredValidator = rvf.createValidator(options);
   * @param {(Object|null)} options an object literal containing properties required by the validator
   * for its initialization. The properties provided in the options is implementation specific.
   * @return {Object} a validator instance.
   * @throws {TypeError} if an unrecognized type was provided
   * @memberof oj.ValidatorFactory
   * @ojsignature { target: "Type",
   *                value: "oj.Validator<V> | oj.AsyncValidator<V>",
   *                for: "returns"}
   * @instance
   * @expose
   * @see oj.DateRestrictionValidator
   * @see oj.DateTimeRangeValidator
   * @see oj.LengthValidator
   * @see oj.NumberRangeValidator
   * @see oj.RegExpValidator
   * @see oj.RequiredValidator
   */
  // eslint-disable-next-line no-unused-vars
  createValidator: function (options) {}
};

/**
 * Internal property that identifies the type that is the contract for conveters and validators.
 * @private
 */
Validation._CONTRACTS = {
  converter: { name: 'oj.ConverterFactory', type: ConverterFactory },
  validator: { name: 'oj.ValidatorFactory', type: ValidatorFactory }
};

/**
 * A ducktype for accessing validator created and/ registered by referring to {@link oj.Validation.validatorFactory}
 * @typedef {object} oj.Validation.RegisteredValidator
 * @property {string} type the name of the factory registered validator
 * @property {Object=} options options to the validator
 */

/**
 * A ducktype for accessing converter created and/ registered by referring to {@link oj.Validation.converterFactory}
 * @typedef {object} oj.Validation.RegisteredConverter
 * @property {string} type the name of the factory registered converter
 * @property {Object=} options options to the converter
 */



/* global Validation:false, ConverterFactory:false, ValidatorFactory:false, ColorConverter:false, LengthValidator:false, RegExpValidator:false, RequiredValidator:false */

/**
 * A factory implementation to create the built-in color converter of type
 * {@link oj.ColorConverter}.
 *
 * @name oj.ColorConverterFactory
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances of {@link oj.ColorConverter} instead.'}
 * @public
 * @class
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojconverter-color", type: "AMD", importName: "ColorConverter"}
 * @hideconstructor
 * @example <caption>create an instance of the jet color converter using the options provided</caption>
 * var ccf = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_COLOR);
 * var options = {format: 'hsl'};
 * var colorConverter = ccf.createConverter(options);
 * @since 0.6.0
 *
 */
var ColorConverterFactory = (function () {
  function _createColorConverter(options) {
    return new ColorConverter(options);
  }

  /**
   *
   * @public
   */
  return {
    /**
     * Creates an immutable (jet) color converter instance.
     *
     * @param {Object=} options an object literal used to provide an optional information to
     * initialize the jet color converter. For details on what to pass for options, refer to
     * {@link oj.ColorConverter}.
     *
     * @return {oj.ColorConverter}
     * @ojsignature {target: "Type", for: "options", value: "oj.ColorConverter.ConverterOptions"}
     * @instance
     * @memberof oj.ColorConverterFactory
     * @public
     */
    createConverter: function (options) {
      return _createColorConverter(options);
    }
  };
})(); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
Validation.__registerDefaultConverterFactory(
  ConverterFactory.CONVERTER_TYPE_COLOR, // factory name
  ColorConverterFactory
);

// JET VALIDATOR FACTORIES

/**
 * A factory implementation to create an instance of the built-in required validator of type
 * {@link oj.RequiredValidator}.
 *
 * @example <caption>create an instance of the required validator using the factory</caption>
 * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED);
 * var options = {'hint' : 'a value is required for this field'};
 * var requiredValidator = rvf.createValidator(options);
 *
 * @name oj.RequiredValidatorFactory
 * @ojdeprecated {since: '17.0.0', description: 'Directly create new instances of RequiredValidator instead.'}
 * @hideconstructor
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojvalidator-required", type: "AMD", importName: "RequiredValidator"}
 * @class
 * @public
 * @since 0.6.0
 *
 */
var RequiredValidatorFactory = (function () {
  function _createRequiredValidator(options) {
    return new RequiredValidator(options);
  }

  return {
    /**
     * Creates an immutable validator instance of type @link oj.RequiredValidator that ensures that
     * the value provided is not empty.
     *
     * @param {Object=} options an object literal used to provide an optional hint and error
     * message. See {@link oj.RequiredValidator} for details.<p>
     *
     * @return {oj.RequiredValidator}
     * @ojsignature {target: "Type", for: "options", value: "oj.RequiredValidator.ValidatorOptions"}
     * @memberof oj.RequiredValidatorFactory
     * @instance
     * @public
     */
    createValidator: function (options) {
      return _createRequiredValidator(options);
    }
  };
})(); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
Validation.__registerDefaultValidatorFactory(
  ValidatorFactory.VALIDATOR_TYPE_REQUIRED,
  RequiredValidatorFactory
);

/**
 * A factory implementation that creates an instance of the built-in regExp validator of type
 * {@link oj.RegExpValidator}.
 *
 * @example <caption>create an instance of the regExp validator using the factory</caption>
 * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);
 * var usernameValidator = rvf.createValidator(
 *  {
 *    'pattern': '[a-zA-Z0-9]{3,}',
 *    'messageDetail': 'You must enter at least 3 letters or numbers'}
 *  });
 *
 * @name oj.RegExpValidatorFactory
 * @ojdeprecated {since: '17.0.0', description: 'Directly create new instances of RegExpValidator instead.'}
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojvalidator-regexp", type: "AMD", importName: "RegExpValidator"}
 * @class
 * @public
 * @hideconstructor
 * @since 0.6.0
 *
 */
var RegExpValidatorFactory = (function () {
  function _createRegExpValidator(options) {
    return new RegExpValidator(options);
  }

  return {
    /**
     * Creates an immutable validator instance of type {@link oj.RegExpValidator} that ensures the value
     * matches the provided pattern.
     *
     * @param {Object} options an object literal used to provide the pattern, an optional hint, error
     * message among others. See {@link oj.RegExpValidator} for details.<p>
     *
     *
     * @return {oj.RegExpValidator}
     * @memberof oj.RegExpValidatorFactory
     * @ojsignature {target: "Type", for: "options", value: "oj.RegExpValidator.ValidatorOptions"}
     * @instance
     * @public
     */
    createValidator: function (options) {
      return _createRegExpValidator(options);
    }
  };
})(); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
Validation.__registerDefaultValidatorFactory(
  ValidatorFactory.VALIDATOR_TYPE_REGEXP,
  RegExpValidatorFactory
);

/**
 * Returns an instance of oj.LengthValidatorFactory that provides a factory method to create an
 * instance of a length validator.
 *
 * @example <caption>create an instance of the length validator using the factory</caption>
 * var lvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH);
 * var options = {hint: {max: 'Enter {max} or fewer characters'}, max: 10};
 * var lValidator = lvf.createValidator(options);
 *
 * @name oj.LengthValidatorFactory
 * @ojdeprecated {since: '17.0.0', description: 'Directly create new instances of LengthValidator instead.'}
 * @hideconstructor
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojvalidator-length", type: "AMD", importName: "LengthValidator"}
 * @class
 * @public
 * @since 0.6.0
 *
 */
var LengthValidatorFactory = (function () {
  function _createLengthValidator(options) {
    return new LengthValidator(options);
  }

  return {
    /**
     * Creates an immutable validator instance of type oj.LengthValidator that ensures that the
     * value provided is withing a given length.
     *
     * @param {Object=} options an object literal used to provide the 'minimum', 'maximum' and other
     * optional values. See {@link oj.LengthValidator} for details.<p>
     *
     * @return {oj.LengthValidator}
     * @memberof oj.LengthValidatorFactory
     * @ojsignature {target: "Type", for: "options", value: "oj.LengthValidator.ValidatorOptions"}
     * @instance
     * @public
     */
    createValidator: function (options) {
      return _createLengthValidator(options);
    }
  };
})(); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
Validation.__registerDefaultValidatorFactory(
  ValidatorFactory.VALIDATOR_TYPE_LENGTH,
  LengthValidatorFactory
);


/* global Validation:false, ValidatorFactory:false, ConverterFactory:false */

var __ValidationFactoryBase = {};
__ValidationFactoryBase.Validation = Validation;
__ValidationFactoryBase.ValidatorFactory = ValidatorFactory;
__ValidationFactoryBase.ConverterFactory = ConverterFactory;

  ;return __ValidationFactoryBase;
});


define('ojs/ojvalidation-base',['ojs/ojcore', 
        'jquery', 
        'ojs/ojtranslation', 
        'ojs/ojmessaging', 
        'ojs/ojlocaledata', 
        'ojs/ojlogger',
        'ojs/ojconverterutils-i18n', 
        'ojs/ojconverter', 
        'ojs/ojvalidator', 
        'ojs/ojvalidationfactory-base',
        'ojs/ojconverter-color',
        'ojs/ojvalidator-length',
        'ojs/ojvalidator-regexp',
        'ojs/ojvalidator-required',  
        'ojs/ojvalidation-error', 
        'ojs/ojvalidator-async'], 
function(oj, 
         $, 
         Translations, 
         Message, 
         LocaleData, 
         Logger, 
         __ConverterI18nUtils, 
         Converter, 
         Validator,
         __ValidationFactoryBase,
         ColorConverter, 
         LengthValidator, 
         RegExpValidator, 
         RequiredValidator)
{
  "use strict";


/* global __ValidationFactoryBase:false, ColorConverter:false, __ConverterI18nUtils:false,
LengthValidator:false, RegExpValidator:false, RequiredValidator:false,
Converter:false, Validator:false */
// These were refactored into their own module which
// does not register anymore the object into the oj namespace.
// But to remain backward compatible, bleed back here.
oj.ColorConverter = ColorConverter;
oj.LengthValidator = LengthValidator;
oj.RegExpValidator = RegExpValidator;
oj.RequiredValidator = RequiredValidator;
oj.IntlConverterUtils = __ConverterI18nUtils.IntlConverterUtils;
oj.OraI18nUtils = __ConverterI18nUtils.OraI18nUtils;
oj.Converter = Converter;
oj.Validator = Validator;
oj.Validation = __ValidationFactoryBase.Validation;
oj.ValidatorFactory = __ValidationFactoryBase.ValidatorFactory;
oj.ConverterFactory = __ValidationFactoryBase.ConverterFactory;

var __ValidationBase = {};
__ValidationBase.ColorConverter = oj.ColorConverter;
__ValidationBase.IntlConverterUtils = oj.IntlConverterUtils;
__ValidationBase.LengthValidator = oj.LengthValidator;
__ValidationBase.RegExpValidator = oj.RegExpValidator;
__ValidationBase.RequiredValidator = oj.RequiredValidator;
__ValidationBase.Validation = oj.Validation;

  ;return __ValidationBase;
});


define('ojs/ojvalidationfactory-number',['ojs/ojcore', 'ojs/ojvalidationfactory-base', 'ojs/ojconverter-number', 
'ojs/ojvalidator-numberrange'], 
function(oj, __ValidationFactoryBase, __ConverterNumber, NumberRangeValidator)
{
  "use strict";


/* global __ValidationFactoryBase:false, __ConverterNumber:false, NumberRangeValidator:false */
/**
 * A factory implementation to create the built-in number converter of type
 * {@link oj.IntlNumberConverter}.
 *
 * @name oj.NumberConverterFactory
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances of NumberConverter instead.'}
 * @hideconstructor
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojconverter-number", type: "AMD", imported: ["IntlNumberConverter"]}

 * @class
 *
 * @example <caption>create an instance of the jet datetime converter using the options provided</caption>
 * var ncf = __ValidationFactoryBase.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER);
 * var salaryOptions = {currency: "EUR" , pattern: "¤#,##0.00;(¤#,##0.00)"};
 * var salaryConverter = ncf.createConverter(salaryOptions);
 * @public
 * @since 0.6.0
 *
 */
var NumberConverterFactory = (function () {
  function _createNumberConverter(options) {
    return new __ConverterNumber.IntlNumberConverter(options);
  }

  return {
    /**
     * Creates an immutable (jet) number converter instance.
     *
     * @param {Object=} options an object literal used to provide optional information to initialize
     * the jet number converter with. For details on what to pass for options, refer to
     * {@link oj.IntlNumberConverter}
     *
     * @return {oj.IntlNumberConverter}
     * @memberof oj.NumberConverterFactory
     * @ojsignature {target: "Type", for: "options", value: "oj.IntlNumberConverter.ConverterOptions"}
     * @instance
     * @public
     */
    createConverter: function (options) {
      return _createNumberConverter(options);
    }
  };
})(); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
__ValidationFactoryBase.Validation.__registerDefaultConverterFactory(
  __ValidationFactoryBase.ConverterFactory.CONVERTER_TYPE_NUMBER, // factory name
  NumberConverterFactory
);

// JET VALIDATOR FACTORIES

/**
 * a factory method to create an instance of a built-in numberRange validator of type
 * {@link oj.NumberRangeValidator}.
 *
 * @example <caption>create an instance of the numberRange validator using the factory</caption>
 * var lrvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBER_RANGE);
 * var options = {hint: {min: 'Enter a value greater than {min}'}, min: 100};
 * var lrValidator = lrvf.createValidator(options);
 *
 * @name oj.NumberRangeValidatorFactory
 * @ojdeprecated {since: '8.0.0', description: 'Directly create new instances of NumberRangeValidator instead.'}
 * @hideconstructor
 * @ojtsnoexport
 * @ojtsexportastype
 * @ojtsimport {module: "ojvalidator-numberrange", type: "AMD", importName: "NumberRangeValidator"}
 * @class
 * @public
 * @since 0.6.0
 *
 */
var NumberRangeValidatorFactory = (function () {
  function _createNumberRangeValidator(options) {
    return new NumberRangeValidator(options);
  }

  return {
    /**
     * Creates an immutable validator instance of type {@link oj.NumberRangeValidator} that ensures
     * that the value provided is within a given range.
     *
     * @param {Object=} options an object literal used to provide the minimum, maximum and other
     * optional values. See {@link oj.NumberRangeValidator} for details.<p>
     *
     * @return {oj.NumberRangeValidator}
     * @memberof oj.NumberRangeValidatorFactory
     * @instance
     * @ojsignature {target: "Type", for: "options", value: "oj.NumberRangeValidator.ValidatorOptions"}
     * @public
     */
    createValidator: function (options) {
      return _createNumberRangeValidator(options);
    }
  };
})(); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
__ValidationFactoryBase.Validation.__registerDefaultValidatorFactory(
  __ValidationFactoryBase.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE,
  NumberRangeValidatorFactory
);


/* global NumberConverterFactory:false, NumberRangeValidatorFactory:false */

var __ValidationFactoryNumber = {};
__ValidationFactoryNumber.NumberConverterFactory = NumberConverterFactory;
__ValidationFactoryNumber.NumberRangeValidatorFactory = NumberRangeValidatorFactory;

  ;return __ValidationFactoryNumber;
});


define('ojs/ojvalidation-number',['ojs/ojcore', 'jquery', 'ojs/ojconfig', 'ojs/ojtranslation', 
'ojL10n!ojtranslations/nls/localeElements', 'ojs/ojlocaledata', 
'ojs/ojvalidation-base', 'ojs/ojlogger', 
'ojs/ojvalidator-numberrange', 'ojs/ojconverter-number', 
'ojs/ojvalidationfactory-number'], 
function(oj, $, Config, Translations, ojld, LocaleData, __ValidationBase, Logger,
NumberRangeValidator, __NumberConverter, __ValidationFactoryNumber)
{
  "use strict";


/* global NumberRangeValidator:false, __NumberConverter:false,
__ValidationFactoryNumber:false */
// These were refactored into their own module which
// does not register anymore the object into the oj namespace.
// But to remain backward compatible, bleed back here.
oj.NumberRangeValidator = NumberRangeValidator;
oj.NumberConverter = __NumberConverter.NumberConverter;
oj.IntlNumberConverter = __NumberConverter.IntlNumberConverter;
oj.NumberConverterFactory = __ValidationFactoryNumber.NumberConverterFactory;
oj.NumberRangeValidatorFactory = __ValidationFactoryNumber.NumberRangeValidatorFactory;

var __ValidationNumber = {};
__ValidationNumber.NumberConverter = oj.NumberConverter;
__ValidationNumber.NumberRangeValidator = oj.NumberRangeValidator;
__ValidationNumber.IntlNumberConverter = oj.IntlNumberConverter;

  ;return __ValidationNumber;
});

define('ojs/ojvalidationgroup',['ojs/ojcore-base', 'ojs/ojcustomelement-utils', 'ojs/ojcontext', 'ojs/ojlogger', 'ojs/ojcomponentcore'], function (oj$1, ojcustomelementUtils, Context, Logger, Components) { 'use strict';

  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   * @ojcomponent oj.ojValidationGroup
   * @since 4.2.0
   *
   * @ojshortdesc A validation group tracks and summarizes the current validity state of a group of components.
   * @ojsignature class ojValidationGroup extends JetElement<ojValidationGroupSettableProperties>
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["valid"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-validation'
   *
   * @classdesc
   * <h3 id="optionOverview-section">
   *   JET ValidationGroup
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optionOverview-section"></a>
   * </h3>
   * <p>The oj-validation-group element tracks the current validity state of its
   * JET custom element descendents that contain the <code class="prettyprint">valid</code>
   *  property.
   * </p>
   * <p>The oj-validation-group element searches all its descendents.
   * When it finds a component with a <code class="prettyprint">valid</code> property,
   * it adds it to the list of components
   * it is tracking. For performance reasons it does not search the tracked component's
   * children since the tracked component's valid state will  be based on
   * its children's valid state, if it has children with valid states.

   * Once it finds all the components it needs to track, it calculates its own
   * valid property value based on all the enabled (including hidden) components it tracks.
   * Enabled means not disabled or readonly, so
   * oj-validation-group's valid state ignores any disabled or readonly components.
   * </p>
   * <p>
   * The most 'invalid' component's
   * <code class="prettyprint">valid</code> property value will be
   * oj-validation-group's <code class="prettyprint">valid</code> property value.
   * When any of the tracked component's valid value changes, oj-validation-group will
   * be notified and will update its own valid value if it has changed.
   * </p>
   * <p>The oj-validation-group does not perform its own validation</p>
   * <p>This is an example of the oj-validation-group wrapping the JET form components.
   * All the JET form components have the <code class="prettyprint">valid</code> property.
   * It is not shown in the HTML markup
   * because it is readonly and cannot be set by the application developer.
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-validation-group>
   *   &lt;oj-form-layout>
   *     &lt;oj-input-text required value="text" label-hint="input 1">&lt;/oj-input-text>
   *     &lt;oj-text-area value='text' rows="6" label-hint="textarea">&lt;/oj-text-area>
   *     &lt;oj-input-text value="text" label-hint="input 2">&lt;/oj-input-text>
   *     &lt;oj-input-text value="text" label-hint="input 3 longer label">&lt;/oj-input-text>
   *   &lt;/oj-form-layout>
   * &lt;/oj-validation-group>
   * </code></pre>
   * </p>
   *
   */

  /**
   * The current validity state of the
   * <code class="prettyprint">oj-validation-group</code> element.
   * <p>
   * The oj-validation-group's
   * <code class="prettyprint">valid</code> property value is calculated from all the
   * enabled components it tracks. The most 'invalid' component's
   * <code class="prettyprint">valid</code> property value will be
   * oj-validation-group's <code class="prettyprint">valid</code> property value.
   * For example,
   * if all the components are valid except one is "invalidShown", then oj-validation-group's
   * valid value will be "invalidShown". If one is "invalidShown" and one is "invalidHidden",
   * then oj-validation-group's valid value will be "invalidShown" since "invalidShown" is more
   * invalid than "invalidHidden".
   * </p>
   * <p>
   * When any of the enabled tracked component's valid value changes, oj-validation-group will
   * be notified and will update its own valid value if it has changed.
   * There is no default value for the valid property
   * since it is a read-only property that is calculated on initialization
   * and kept updated if any of its tracked component's valid value changes.
   * </p>
   * <p>
   * The oj-validation-group does not filter out components that are hidden.
   * Hidden components will be considered
   * in oj-validation-group's valid calculation as long as they are enabled.
   * A hidden enabled component's valid state is no different
   * than a visible enabled component; if there
   * is an error that isn't a deferred error, its valid value is "invalidShown".
   * You can disable any components you do not want
   * considered in oj-validation-group's valid value.
   * </p>
   * <p>
   *  Note: New valid states may be added to the list of valid values in future releases.
   *  If so, we will keep the convention where if it is valid, it will start with "valid".
   *  If it is invalid, it will start with "invalid".
   *  If it is pending, it will start with "pending".
   * </p>
   * @member
   * @name valid
   * @ojshortdesc Read-only property used for retrieving the current validity state of the group of components being tracked. See the Help documentation for more information.
   * @expose
   * @memberof oj.ojValidationGroup
   * @instance
   * @type {string}
   * @ojvalue {string} "valid" The component is valid
   * @ojvalue {string} "pending" The component is waiting for the validation state to be determined.
   * @ojvalue {string} "invalidHidden" The component has invalid messages hidden
   *    and no invalid messages showing. An invalid message is one with severity "error" or higher.
   * @ojvalue {string} "invalidShown" The component has invalid messages showing.
   *  An invalid message is one with severity "error" or higher.
   * @readonly
   * @ojwriteback
   * @since 4.2
   * @example <caption>Get the <code class="prettyprint">valid</code> property after initialization:</caption>
   * // getter
   * var valid = myValidationGroupElement.valid;
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   *
   * @expose
   * @memberof oj.ojValidationGroup
   * @instance
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   *
   * @expose
   * @memberof oj.ojValidationGroup
   * @instance
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof oj.ojValidationGroup
   * @instance
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */
  // Slots
  // //////

  /**
   * <p>The <code class="prettyprint">&lt;oj-validation-group></code> accepts
   * any DOM elements in its Default slot but only tracks the validity
   * state of any JET custom element descendents that contain the valid property.
   *
   * @ojchild Default
   * @memberof oj.ojValidationGroup
   * @since 4.2.0
   */

  /**
   * The _ojValidationGroup constructor function.
   *
   * @constructor
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  function ojValidationGroup(context) {
    var FIRST_INVALID_SHOWN_KEY = '@firstInvalidShown';

    var self = this;
    var element = context.element;

    var _trackedComponents = [];
    var _ojDiv;

    // Our version of GCC has a bug where the second param of MutationObserver.observe must be of
    // type MutationObserverInit which isn't a real class that we can instantiate. Work around is to
    // create the MutationObserver on an alias of 'this' and call observe in a different function.
    // TODO Cleanup when we replace GCC with uglify in 5.0.0.
    /**
     * If the dom is mutated, call _refreshTrackedComponents if needed
     *
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    self._rootElementMutationObserver = new MutationObserver(function (mutations) {
      // mutations is an array of objects, each of type MutationRecord.
      //
      // if the oj-validation-group has been removed from the body element's subtree,
      // no need to remove event listeners or refresh.  Just disconnect the observer.
      // This can happen when you press apply in the cookbook demo.

      if (document.body.contains(element)) {
        var mutationsLength = mutations.length;
        var refreshNeeded = false;

        // figure out if we have to refresh the tracked components list
        // if refreshNeeded is false,
        // then continue for loop and look at the next mutation to see if that can be ignored
        // or if _refreshTrackedComponents needs to be called.
        for (var i = 0; i < mutationsLength && !refreshNeeded; i++) {
          var mutation = mutations[i];
          // target is the node whose children changed
          var target = mutation.target;

          // we definitely need to refresh if we are removing a tracked node.
          // if we remove a tracked node, like ojInputTextNode.remove(), the target is the
          // tracked node's parent and the tracked node is in removedNodes.
          var removedNodes = mutation.removedNodes;
          var addedNodes = mutation.addedNodes;
          refreshNeeded = _isOrContainsTrackedComponent(removedNodes);
          if (!refreshNeeded && addedNodes.length > 0) {
            // if refreshNeeded is false, and we are adding something,
            // then look at this mutation;
            // if it is a child of any of the tracked components,
            // then ignore this mutation.
            var ignore = _isNodeInTrackedComponent(target);

            // if ignore is false, see if target or addedNodes needs to be tracked.
            // checking on the addedNodes does not always work. you must also check target
            // If so, set refreshNeeded to true
            if (!ignore && _isAnyNodeTrackable(target, addedNodes)) {
              refreshNeeded = true;
            }
          }
        }
        // if 'refreshNeeded' is true,
        // one of the mutations is or contains an element that needs tracking.
        if (refreshNeeded) {
          // remove event listeners from removed nodes if they are there
          _removeEventListenersFromRemovedChildren(mutations);
          // refresh the tracked components (clears and updates the _trackedComponents
          // and re-adds event handlers)
          _refreshTrackedComponents();
        }
      } else {
        this.disconnect();
      }
    }); // end self._rootElementMutationObserver

    // This gets called on initial render.
    // It gets the tracked components. No ui change is made here.
    self.createDOM = function () {
      element.classList.add('oj-validation-group');

      // 1. add a div child of oj-validation-group.
      //    We call this _ojDiv and add data-oj-context onto it
      //    to be used by the BusyContext.
      // 2. reparent its children to _ojDiv. With the reparenting the framework
      //    resolves the old busy context and creates a
      //    new one for the children when you add them back in the DOM. It doesn't work to
      //    put the data-oj-context on oj-validation-group since the
      //    BusyContext needs the data-oj-context attribute needs to be in place
      //    when the children are added. It would work if the app developer puts the data-oj-context
      //    on oj-validation-group in his html page,
      //    but we don't want the app dev to have to do that.
      _ojDiv = document.createElement('div');
      _ojDiv.setAttribute('data-oj-context', '');

      // wrap the children with the div
      // use firstChild so we can get text/comments/etc. ko bindings are comments, and we don't
      // want to skip those.
      while (element.firstChild) {
        _ojDiv.appendChild(element.firstChild); // @HTMLUpdateOK reparenting child nodes
      }
      element.appendChild(_ojDiv); // @HTMLUpdateOK appending internally created DOM element
    };

    // remove event listeners and refresh tracked components
    // this is not called for property changes since I override handlePropertyChanged
    // and return true from it.
    // This function gets called on initial render and when refresh() is called.
    self.updateDOM = function () {
      // We wait until the child elements have finished upgrading before we get the
      // tracked components.
      // If we do not do this, we may get a lot of mutations as the children are adding
      // dom themselves; e.g., oj-form-layout  marks itself busy as it manipulates
      // its dom (adds oj-label, bonus dom, etc), and we don't have to get
      // a mutation observer for each of its manipulations if we wait until the BusyContext resolves.
      //
      // Another benefit of waiting is if an app dev adds an on-valid-changed listener
      // on oj-validation-group that he wants called on page load,
      // the listener gets called on page load only when we wait on the BusyContext resolving.
      // We can wait here or we can have the app dev wait. It's best to wait here for these
      // reasons.
      //
      // However, in the case where knockout is not used and the child components
      // are registered after the parent so that the parent's logic
      // gets run first before the children even get a chance to
      // add their busy states (before they even get registered).
      //  In that case this would immediately get called. It's ok since we will
      // get mutations when the components get upgraded, and they get the valid
      // property.
      // In a JET 12 review it was pointed out that we now have
      // _TRACK_CHILDREN = 'nearestCustomElement'; in the componentRegister
      // and this will make it more predictable in non-knockout mode.
      // We are keeping the busycontext since it is doing no harm and would take a lot of testing
      // to ensure it isn't needed.
      var busyContext = Context.getContext(_ojDiv).getBusyContext();

      // Create a busy state on the element which is resolved after the valid state
      // has been set. This allows anything waiting on the whenReady Promise to run
      // after the state is set.
      let validStateResolve = Context.getContext(element)
        .getBusyContext()
        .addBusyState({
          description: `oj-validation-group#${element.id} initial valid state`
        });
      busyContext
        .whenReady()
        .then(function () {
          // if this is the initial render, _trackedComponents.length is 0
          var length = _trackedComponents.length;
          for (var i = 0; i < length; i++) {
            _removeEventListenersFromNode(_trackedComponents[i]);
          }

          _refreshTrackedComponents();

          // Pay attention to mutations.  The mutations
          // we care about are added elements and removed elements.
          // We need to update the trackedComponents and their listeners in these cases.
          self._rootElementMutationObserver.observe(element, { childList: true, subtree: true });
        })
        .finally(validStateResolve);
    };

    // Handles property changes for oj-validation-group.
    // handlePropertyChanged is an optional DefinitionalElementBridge method where if defined,
    // will be called with the property and value that changed
    // letting the component handle a partial update case. The component
    // can return true in this callback to skip a full render call to updateDOM
    // which will be done if this method returns false or undefined.

    // eslint-disable-next-line no-unused-vars
    self.handlePropertyChanged = function (property, value) {
      // skip a full render call to updateDOM when we get a property change.
      return true;
    };

    /**
     * Takes all deferred messages and shows them on each enabled component. An enabled
     * component is one that is not disabled or readonly.
     * As a result, the valid property may be updated; e.g.,
     * if the valid state was "invalidHidden"
     * before showMessages(), the valid state will become "invalidShown" after showMessages().
     * <p>
     * If there were no deferred messages this method simply returns.
     * </p>
     * @function showMessages
     * @access public
     * @instance
     * @return {void}
     * @example <caption>Display all messages including deferred ones.</caption>
     * validationGroupElem.showMessages();
     * @expose
     * @memberof oj.ojValidationGroup
     * @since 4.2.0
     */
    self.showMessages = function () {
      // get tracked components and call showMessages() on them
      // as long as they are enabled.
      for (var i = 0; i < _trackedComponents.length; i++) {
        var component = _trackedComponents[i];
        if (!(component.disabled || component.readonly)) {
          if ('showMessages' in component) {
            component.showMessages();
          }
        }
      }
    };

    /**
     * If the parameter passed in is "@firstInvalidShown", then
     * it sets focus on the first enabled component with invalid messages showing, if any.
     * If nothing is passed in, it will set focus to the first enabled component being tracked,
     * if any. An enabled component is one that is not disabled or readonly.
     *
     * @function focusOn
     * @ojshortdesc Sets the focus on one of the enabled components that is being tracked. See the Help documentation for more information.
     * @param {string=} key - "@firstInvalidShown" will focus on first invalidShown enabled
     * component in DOM order, if any. When no parameter is passed in, the method will
     * focus on first enabled component regardless of the valid state, if any. An enabled
     * component is one that is not disabled or readonly.
     * @ojsignature {target: "Type", for:"key", value: "'@firstInvalidShown'"}
     * @example <caption>Focus on the first enabled component showing invalid messages.</caption>
     * validationGroupElem.focusOn("@firstInvalidShown");
     * @example <caption>Focus on the first enabled component.</caption>
     * validationGroupElem.focusOn();
     * @access public
     * @instance
     * @return {void}
     * @expose
     * @memberof oj.ojValidationGroup
     * @since 4.2.0
     */
    self.focusOn = function (key) {
      var firstFocusable = null;
      var firstInvalid = null;

      if (key === FIRST_INVALID_SHOWN_KEY) {
        // JET-50765 - AUTO SCROLL FOCUS FIELD DOESN'T WORK ON MOBILE DEVICE
        // When this method is called, there might be cases where the core-pack
        // component has not updated the valid property yet which is done in a microtask.
        // So, schedule a microtask and try to focus the first invalid there. No need to set
        // a busyContext here as it resolves on a macrotask and we will be done by then.
        // This way, focusOn can be called synchronously after the showMessages call and it
        // will correctly focus the first invalid component.
        queueMicrotask(() => {
          firstInvalid = _getFirstInvalidComponent();

          if (firstInvalid) {
            // If the component has the 'focusOn' method,
            // call that instead of focus()
            // to handle nested oj-validation-groups
            if ('focusOn' in firstInvalid) {
              firstInvalid.focusOn(FIRST_INVALID_SHOWN_KEY);
            } else {
              firstInvalid.focus();
              // JET-50765 - AUTO SCROLL FOCUS FIELD DOESN'T WORK ON MOBILE DEVICE
              // In ios, the browser is not scrolling to the
              // element when calling focus on it. So, we scroll to the
              // element explicitly.
              if (oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS) {
                firstInvalid.scrollIntoView();
              }
            }
          }
        });
      } else if (key === undefined) {
        // Get the first non readonly or disabled, then call focus
        firstFocusable = _getFirstFocusable();

        if (firstFocusable) {
          // If the component has the 'focusOn' method,
          // call that instead of focus()
          // to handle nested oj-validation-groups
          if ('focusOn' in firstFocusable) {
            firstFocusable.focusOn();
          } else {
            firstFocusable.focus();
            // JET-50765 - AUTO SCROLL FOCUS FIELD DOESN'T WORK ON MOBILE DEVICE
            // In ios, the browser is not scrolling to the
            // element when calling focus on it. So, we scroll to the
            // element explicitly.
            if (oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS) {
              firstFocusable.scrollIntoView();
            }
          }
        }
      } else {
        // it's a no/op if they pass something into focusOn and it's not a key we support
        // which is now only '@firstInvalidShown'.
        // this behaves the same way html's focus() works.
        Logger.info(
          "focusOn's parameter value is not '@firstInvalidShown' or empty, so it's a no-op."
        );
      }
    };

    /**
     * This function clears out _trackedComponents, finds them all again, and adds
     * the child event listeners on each one. It also updates the 'valid' property.
     * <p>
     * The dom spec for addEventListener states that it will not add duplicate
     * event listeners, so there is no need to track if we already added this.
     * If you want to remove child event listeners, do so before this function is called.
     * </p>
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _refreshTrackedComponents() {
      // clear out the tracked components when this is called
      _trackedComponents = [];
      // this sets the _trackedComponents
      _getTrackedComponents(element);

      // eslint-disable-next-line no-param-reassign
      context.props.valid = _consolidateValid();

      // property change events do not bubble,
      // so add to each child where the property change occurs
      var length = _trackedComponents.length;
      for (var i = 0; i < length; i++) {
        _addChildEventListeners(_trackedComponents[i]);
      }
    }

    /**
     * Add the property change event listeners to the tracked component node, aka child.
     *
     * Only the component events bubble and not the property change events,
     * so it doesn't work to listen on the oj-validation-group for
     * these property change events. Instead we
     * put them on the child component themselves, and we share the listener.
     * @param {Element} child
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _addChildEventListeners(child) {
      child.addEventListener('validChanged', _handleValidChanged.bind(this));
      child.addEventListener('disabledChanged', _handleDisabledReadonlyChanged.bind(this));
      child.addEventListener('readonlyChanged', _handleDisabledReadonlyChanged.bind(this));
    }

    /**
     * remove child event listeners
     * Only the component events bubble and not the property change events,
     * so it doesn't work to listen on the oj-validation-group
     * for these property change events. We add/remove the listener from the
     * child JET component itself.
     *
     * @param {Array.<MutationRecord>} mutations the array of MutationRecords from the observer
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _removeEventListenersFromRemovedChildren(mutations) {
      var mutationsLength = mutations.length;
      for (var i = 0; i < mutationsLength; i++) {
        var mutation = mutations[i];
        var removedNodesLength = mutation.removedNodes.length;
        for (var j = 0; j < removedNodesLength; j++) {
          var child = mutation.removedNodes[j];

          if (child.nodeType === 1) {
            _removeEventListenersFromNode(child);
          }
        }
      }
    }

    /**
     * Given a node element, remove the event listeners we added
     * @param {Element} node The element from which to remove the event listeners we added.
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _removeEventListenersFromNode(node) {
      node.removeEventListener('validChanged', _handleValidChanged);
      node.removeEventListener('disabledChanged', _handleDisabledReadonlyChanged);
      node.removeEventListener('readonlyChanged', _handleDisabledReadonlyChanged);
    }

    /**
     * Handles any validChanged events from the tracked components.
     * This consolidates the valid properties of the tracked components,
     * finding the most invalid state, and setting the oj-validation-group's
     * 'valid' property to that state.
     * @param {Event} event
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _handleValidChanged() {
      // eslint-disable-next-line no-param-reassign
      context.props.valid = _consolidateValid();
    }

    /**
     * Handles any disabledChanged and readonlyChanged
     * events from the tracked components.
     * This consolidates the valid properties of the tracked components,
     * finding the most invalid state, and setting the oj-validation-group's
     * 'valid' property to that state.
     * We do not want to count the valid state of a non-enabled component
     * in our oj-validation-group valid state.
     * @param {Event} event
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _handleDisabledReadonlyChanged(event) {
      var component = event.target;
      var componentValid = component.valid;
      var componentEnabled = !(component.readonly || component.disabled);

      // If the component that changed
      // its disabled/readonly state is valid,
      // then it's a no-op since that won't
      // change oj-validation-group's valid property value.
      if (componentValid === 'valid') {
        // invalidShown is the 'most severe' valid state, so if the
        // enabled component's valid state is invalidShown, then no
        // matter what oj-validation-group is already, it will be invalidShown now.
        // if oj-validation-group is already invalidShown, the set property is a no/op.
      } else if (componentEnabled && componentValid === 'invalidShown') {
        // eslint-disable-next-line no-param-reassign
        context.props.valid = 'invalidShown';
      } else {
        // if it went from true to false or vice versa,
        // we need to re-consolidate the valid value since
        // we do not count disabled/readonly components
        // in the valid calculation.
        // eslint-disable-next-line no-param-reassign
        context.props.valid = _consolidateValid();
      }
    }

    /**
     * This consolidates the valid properties of the tracked components,
     * finding the most invalid state, and setting the oj-validation-group's
     * 'valid' property to that state.
     * We track components even when they are disabled or readonly, but
     * we do NOT consider them in the 'valid' state calculation.
     * We track them because we will consider them in the 'value',
     *  when that property is added to oj-validation-group
     * in a future release.
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     * @return {string} Returns the most invalid state: "invalidShown", "invalidHidden",
     * "pending", or "valid".
     */
    function _consolidateValid() {
      var mostInvalid = 'valid';

      // The order of validity (least valid to most valid) is:
      // "invalidShown", "invalidHidden", "pending", "valid"
      //
      // Find the most invalid state of all the tracked components.
      // break out of loop as soon as we see the
      // most invalid state, "invalidShown"
      var length = _trackedComponents.length;
      for (var i = 0; i < length && mostInvalid !== 'invalidShown'; i++) {
        var component = _trackedComponents[i];
        if (_isComponentNotDestroyed(component)) {
          var componentValidState = component.valid;
          var disabled = component.disabled;
          var readonly = component.readonly;
          // we do not count disabled/readonly components
          // in the valid calculation.
          if (!(disabled || readonly)) {
            if (componentValidState === 'invalidShown') {
              mostInvalid = 'invalidShown';
            } else if (componentValidState === 'invalidHidden') {
              mostInvalid = 'invalidHidden';
            } else if (componentValidState === 'pending' && mostInvalid === 'valid') {
              mostInvalid = 'pending';
            }
          }
        }
      }
      return mostInvalid;
    }

    /**
     * Gets all the tracked components within the tracker.
     * Check childNodes of root. If trackable, store in _trackedComponents and
     * don't go into descendents. If not trackable, store in notTrackableElements,
     * and do go into the descendents by calling this function recursively.
     * @param {Element} root The element from which to start the search for tracked components.
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _getTrackedComponents(root) {
      var i;
      var notTrackableElements = [];

      // get children
      // check each one. if trackable, store in trackedComponents and don't go into descendents.
      // if not trackable, store in notTrackableElements, and do go into the descendents.
      var children = root.childNodes;
      var length = children.length;
      for (i = 0; i < length; i++) {
        var child = children[i];
        var trackable = _isTrackable(child);
        if (trackable) {
          _trackedComponents.push(child);
        } else {
          notTrackableElements.push(child);
        }
      }

      // now loop through the notTrackableElements we found the first pass and check their children.
      length = notTrackableElements.length;
      for (i = 0; i < length; i++) {
        _getTrackedComponents(notTrackableElements[i]);
      }
    }

    /**
     * Check the node to see if oj-validation-group should track it.
     * In this first revision of oj-validation-group, we see if it has the 'valid' property.
     *
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     * @param {Node} elem see if the element is trackable by oj-validation-group
     * @return {boolean} true if the element is one the oj-validation-group must track.
     */
    function _isTrackable(elem) {
      // only look at elements with a '-' in it.
      if (elem.nodeType === 1 && elem.tagName.indexOf('-') !== -1 && 'valid' in elem) {
        if (_isComponentNotDestroyed(elem)) {
          var valid = elem.valid;
          if (valid !== undefined) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * Check the target and nodes to see if any of them are trackable.
     * Useful for our MutationObserver when figuring out if we can ignore a mutation.
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     * @param {Node} target node to see if trackable
     * @param {NodeList} nodes nodes to see if any are trackable
     * @return {boolean} true if the target or a node from nodelist is trackable, else false
     */
    function _isAnyNodeTrackable(target, nodes) {
      var length = nodes.length;

      if (_isTrackable(target)) {
        return true;
      }

      // loop through the nodes and see if one is trackable
      for (var i = 0; i < length; i++) {
        if (_isTrackable(nodes[i])) {
          return true;
        }
      }
      return false;
    }

    /**
     * Checks if a _trackedComponents component contains the elem (i.e., a child)
     * Useful for our MutationObserver when figuring out if we can ignore a mutation.
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     * @param {Node} node node to check to see if it is a child of one of the tracked components
     * @return {boolean} true if a _trackedComponents component contains the elem, false otherwise
     *
     */
    function _isNodeInTrackedComponent(node) {
      var length = _trackedComponents.length;

      if (node.nodeType !== 1) {
        return false;
      }

      // look at this mutation.
      // if it is a child of any of the tracked components,
      // then ignore this mutation.
      for (var i = 0; i < length; i++) {
        var trackedComponent = _trackedComponents[i];
        if (trackedComponent.contains(node)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Returns true if one of the nodes is or contains a tracked component.
     * Useful for our MutationObserver when looking at what nodes are being removed.
     *
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     * @param {NodeList} nodes nodes to see if any are in the _trackedComponents list or contain
     *  a tracked component
     * @return {boolean} true if any of the nodes are or contain a tracked component.
     */
    function _isOrContainsTrackedComponent(nodes) {
      var trackedLength = _trackedComponents.length;

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.nodeType === 1) {
          // check if node is in the _trackedComponents
          if (_trackedComponents.indexOf(node) !== -1) {
            return true;
          }
          // now check if the node contains a tracked node
          for (var j = 0; j < trackedLength; j++) {
            if (node.contains(_trackedComponents[j])) {
              return true;
            }
          }
        }
      }
      return false;
    }

    /**
     * Gets the first component that isn't readonly or disabled to focus on.
     *
     * @returns {Element|null} the first focusable element or null if none
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _getFirstFocusable() {
      var trackedComponent = null;

      var length = _trackedComponents.length;
      for (var i = 0; i < length; i++) {
        trackedComponent = _trackedComponents[i];
        if (!(trackedComponent.readonly || trackedComponent.disabled)) {
          return trackedComponent;
        }
      }
      return null;
    }

    /**
     * Gets the first invalid component and returns the component to focus on.
     *
     * @returns {Element|null} the component instance that has focus or null
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _getFirstInvalidComponent() {
      var invalidComponents = [];

      if (element.valid !== 'invalidShown') {
        return null;
      }

      // locate first invalid component and set focus on it
      // _trackedComponents may not be in DOM order if a new tracked component was added not
      // at the end of the DOM order.
      var length = _trackedComponents.length;
      for (var i = 0; i < length; i++) {
        var component = _trackedComponents[i];
        // don't try to focus on a disabled/readonly component
        if (!(component.disabled || component.readonly)) {
          if (component.valid === 'invalidShown') {
            invalidComponents.push(component);
          }
        }
      }

      if (invalidComponents.length === 0) {
        return null;
      }

      // sort the invalidComponents based on dom order
      invalidComponents.sort(function (elementA, elementB) {
        // If elementA precedes elementB in dom order, return -1
        // Node.DOCUMENT_POSITION_FOLLOWING returns a bitmask, so the & is intentional
        // eslint-disable-next-line no-bitwise
        return elementA.compareDocumentPosition(elementB) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
      });

      // invalidComponents is sorted now by document order, so return the first one.
      return invalidComponents[0];
    }

    /**
     * We need to make sure widgetElem hasn't been destroyed before
     * accessing its properties, like elem.["valid"].
     * We can remove this code in v5.0 when the framework handles custom elements implemented
     * as widgets's destroy/ko.cleanNode better.
     * In 5.0 the framework will  circumvent
     * jquery's cleanup altogether for custom elements and children of custom elements
     *
     * @param {Node} elem the element to check
     * @returns {boolean} true if it is safe to call .valid on the element, false if not.
     * @memberof oj.ojValidationGroup
     * @instance
     * @private
     */
    function _isComponentNotDestroyed(elem) {
      var widgetElem;

      var bridge = ojcustomelementUtils.CustomElementUtils.getElementBridge(elem);
      // if we do not have an element bridge, return true.
      // this would be the case for a vdom component, for example.
      if (!bridge) {
        return true;
      }
      var bridgeWidgetElem = bridge._WIDGET_ELEM;
      // bridgetWidgetElem is undefined for oj-validation-group
      // since it's not implemented using the widget code.
      // bridgetWidgetElem has a value for oj-input-text, oj-input-number, etc.,
      // since they are implemented using the widget code. e.g., the input element.
      if (bridgeWidgetElem !== undefined) {
        widgetElem = Components.__GetWidgetConstructor(bridgeWidgetElem);
      }

      return !!(bridgeWidgetElem === undefined || widgetElem);
    }
  }

  (function () {
var __oj_validation_group_metadata = 
{
  "properties": {
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    }
  },
  "methods": {
    "focusOn": {},
    "getProperty": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_validation_group_metadata.extension._CONSTRUCTOR = ojValidationGroup;
    __oj_validation_group_metadata.extension._TRACK_CHILDREN = 'nearestCustomElement';
    Object.freeze(__oj_validation_group_metadata);
    oj$1.CustomElementBridge.register('oj-validation-group', {
      metadata: __oj_validation_group_metadata
    });
  })();

});


define('ojs/ojasyncvalidator-adapter',[],function () { 'use strict';

    class SyncValidatorAdapter {
        constructor(options) {
            this.options = options;
        }
        validate(value) {
            let self = this;
            if (!this._validator) {
                this._InitLoadingPromise();
                return this._loadingPromise.then(function (validatorConstructor) {
                    self._validator = new validatorConstructor.default(self.options);
                    try {
                        self._validator.validate(value);
                    }
                    catch (e) {
                        return Promise.reject(e);
                    }
                    return null;
                });
            }
            try {
                this._validator.validate(value);
            }
            catch (e) {
                return Promise.reject(e);
            }
            return Promise.resolve(null);
        }
        _GetHint() {
            let self = this;
            if (!this._validator) {
                this._InitLoadingPromise();
                return this._loadingPromise.then(function (validatorConstructor) {
                    self._validator = new validatorConstructor.default(self.options);
                    return self._validator.getHint();
                });
            }
            return Promise.resolve(self._validator.getHint());
        }
        _InitLoadingPromise() { }
    }

    return SyncValidatorAdapter;

});


define('ojs/ojasyncvalidator-length',['require', 'ojs/ojasyncvalidator-adapter'], function (require, SyncValidatorAdapter) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) { return e; } else {
            var n = {};
            if (e) {
                Object.keys(e).forEach(function (k) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                });
            }
            n['default'] = e;
            return n;
        }
    }

    SyncValidatorAdapter = SyncValidatorAdapter && Object.prototype.hasOwnProperty.call(SyncValidatorAdapter, 'default') ? SyncValidatorAdapter['default'] : SyncValidatorAdapter;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     * @since 8.0.0
     * @export
     * @class AsyncLengthValidator
     * @final
     * @implements AsyncValidator
     * @classdesc Constructs an AsyncLengthValidator ensures the value entered is within a given length.
     * @param {Object=} options an object literal used to provide the following properties
     * @ojtsmodule
     * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
     * @ojtsimport {module: "ojvalidator-length", type: "AMD", importName: "LengthValidator"}
     * @ojsignature [{target: "Type",
     *                value: "class AsyncLengthValidator<V> implements AsyncValidator<V>"},
     *               {target: "Type",
     *                value: "LengthValidator.ValidatorOptions",
     *                for: "options", jsdocOverride: true}
     *              ]
     * @see oj.LengthValidator
     */

    /**
     * Validates the length of value is greater than minimum and/or less than maximum. Returns a
     * Promise which resolves when valid and rejects which invalid.
     *
     * @param {string} value that is being validated
     * @returns {Promise.<void>}
     * @ojsignature {target: "Type",
     *               value: "(value: V): Promise<void>"}
     * @memberof AsyncLengthValidator
     * @instance
     * @export
     * @method validate
     */

    /**
     * A message to be used as hint, when giving a hint about the expected length. There is no default
     * hint for this property.
     *
     * @memberof AsyncLengthValidator
     * @instance
     * @export
     * @name hint
     * @type {Promise.<string|null>}
     */

    // end of jsdoc

    class AsyncLengthValidator extends SyncValidatorAdapter {
        constructor(options) {
            super(options);
            this.options = options;
        }
        get hint() {
            return super._GetHint();
        }
        _InitLoadingPromise() {
            if (!this._loadingPromise) {
                this._loadingPromise = new Promise(function (resolve, reject) { require(['ojs/ojvalidator-length'], function (m) { resolve(_interopNamespace(m)); }, reject) });
            }
        }
    }

    return AsyncLengthValidator;

});


define('ojs/ojasyncvalidator-numberrange',['require', 'ojs/ojasyncvalidator-adapter'], function (require, SyncValidatorAdapter) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) { return e; } else {
            var n = {};
            if (e) {
                Object.keys(e).forEach(function (k) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                });
            }
            n['default'] = e;
            return n;
        }
    }

    SyncValidatorAdapter = SyncValidatorAdapter && Object.prototype.hasOwnProperty.call(SyncValidatorAdapter, 'default') ? SyncValidatorAdapter['default'] : SyncValidatorAdapter;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     * @since 8.0.0
     * @export
     * @class AsyncNumberRangeValidator
     * @final
     * @implements AsyncValidator
     * @classdesc Constructs an AsyncNumberRangeValidator that ensures the value provided is within a given range.
     * @param {Object=} options an object literal used to provide the following properties
     * @ojtsmodule
     * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
     * @ojtsimport {module: "ojvalidator-numberrange", type: "AMD", importName: "NumberRangeValidator"}
     * @ojsignature [{target: "Type",
     *                value: "class AsyncNumberRangeValidator<V> implements AsyncValidator<V>"},
     *               {target: "Type",
     *                value: "NumberRangeValidator.ValidatorOptions",
     *                for: "options", jsdocOverride: true}
     *              ]
     * @see oj.NumberRangeValidator
     */

    /**
     * Validates the minimum + maximum conditions. Returns a
     * Promise which resolves when valid and rejects which invalid.
     *
     * @param {string} value that is being validated
     * @returns {Promise.<void>}
     * @ojsignature {target: "Type",
     *               value: "(value: V): Promise<void>"}
     * @memberof AsyncNumberRangeValidator
     * @instance
     * @export
     * @method validate
     */

    /**
     * A hint message or null if no hint is available in the options.
     * A hint message may be like "Enter a value between {min} and {max}"
     * or "Enter a number greater than or equal to {min}"
     *
     * @memberof AsyncNumberRangeValidator
     * @instance
     * @export
     * @name hint
     * @type {Promise.<string|null>}
     */

    // end of jsdoc

    class AsyncNumberRangeValidator extends SyncValidatorAdapter {
        constructor(options) {
            super(options);
            this.options = options;
        }
        get hint() {
            return super._GetHint();
        }
        _InitLoadingPromise() {
            if (!this._loadingPromise) {
                this._loadingPromise = new Promise(function (resolve, reject) { require(['ojs/ojvalidator-numberrange'], function (m) { resolve(_interopNamespace(m)); }, reject) });
            }
        }
    }

    return AsyncNumberRangeValidator;

});


define('ojs/ojasyncvalidator-regexp',['require', 'ojs/ojasyncvalidator-adapter'], function (require, SyncValidatorAdapter) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) { return e; } else {
            var n = {};
            if (e) {
                Object.keys(e).forEach(function (k) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                });
            }
            n['default'] = e;
            return n;
        }
    }

    SyncValidatorAdapter = SyncValidatorAdapter && Object.prototype.hasOwnProperty.call(SyncValidatorAdapter, 'default') ? SyncValidatorAdapter['default'] : SyncValidatorAdapter;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     * @since 8.0.0
     * @export
     * @class AsyncRegExpValidator
     * @final
     * @implements AsyncValidator
     * @classdesc Constructs an AsyncRegExpValidator that ensures the value matches the provided pattern.
     * @param {Object=} options an object literal used to provide the following properties
     * @ojtsmodule
     * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
     * @ojtsimport {module: "ojvalidator-regexp", type: "AMD", importName: "RegExpValidator"}
     * @ojsignature [{target: "Type",
     *                value: "class AsyncRegExpValidator<V> implements AsyncValidator<V>"},
     *               {target: "Type",
     *                value: "RegExpValidator.ValidatorOptions",
     *                for: "options", jsdocOverride: true}
     *              ]
     * @see oj.RegExpValidator
     */

    /**
     * Validates value for matches using the regular expression provided by the pattern. This method
     * does not raise an error when value is the empty string or null; the method returns a Promise
     * which resolves indicating that the validation was successful. If the application wants the empty string to fail validation,
     * then the application should chain in the required validator (e.g., set required on the input).
     *
     * @param {string} value that is being validated
     * @returns {Promise.<void>}
     * @ojsignature {target: "Type",
     *               value: "(value: V): Promise<void>"}
     * @memberof AsyncRegExpValidator
     * @instance
     * @export
     * @method validate
     */

    /**
     * A message to be used as hint, when giving a hint on the expected pattern. There is no default
     * hint for this property.
     *
     * @memberof AsyncRegExpValidator
     * @instance
     * @export
     * @name hint
     * @type {Promise.<string|null>}
     */

    // end of jsdoc

    class AsyncRegExpValidator extends SyncValidatorAdapter {
        constructor(options) {
            super(options);
            this.options = options;
        }
        get hint() {
            return super._GetHint();
        }
        _InitLoadingPromise() {
            if (!this._loadingPromise) {
                this._loadingPromise = new Promise(function (resolve, reject) { require(['ojs/ojvalidator-regexp'], function (m) { resolve(_interopNamespace(m)); }, reject) });
            }
        }
    }

    return AsyncRegExpValidator;

});


define('ojs/ojasyncvalidator-required',['require', 'ojs/ojasyncvalidator-adapter'], function (require, SyncValidatorAdapter) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) { return e; } else {
            var n = {};
            if (e) {
                Object.keys(e).forEach(function (k) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                });
            }
            n['default'] = e;
            return n;
        }
    }

    SyncValidatorAdapter = SyncValidatorAdapter && Object.prototype.hasOwnProperty.call(SyncValidatorAdapter, 'default') ? SyncValidatorAdapter['default'] : SyncValidatorAdapter;

    /**
     * @preserve Copyright 2013 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    /* jslint browser: true,devel:true*/
    /**
     * @since 8.0.0
     * @export
     * @class AsyncRequiredValidator
     * @final
     * @implements AsyncValidator
     * @classdesc Constructs an AsyncRequiredValidator ensures that the value provided is not empty.
     * @param {Object=} options an object literal used to provide the following properties
     * @augments oj.AsyncValidator
     * @ojtsmodule
     * @ojtsimport {module: "ojvalidator-async", type: "AMD", importName: "AsyncValidator"}
     * @ojtsimport {module: "ojvalidator-required", type: "AMD", importName: "RequiredValidator"}
     * @ojsignature [{target: "Type",
     *                value: "class AsyncRequiredValidator<V> implements AsyncValidator<V>"},
     *               {target: "Type",
     *                value: "RequiredValidator.ValidatorOptions",
     *                for: "options", jsdocOverride: true}
     *              ]
     * @see oj.RequiredValidator
     */

    /**
     * Validates value to be non-empty
     *
     * @param {string} value that is being validated
     * @returns {Promise.<void>}
     * @throws {Error} when there is no match
     * @ojsignature {target: "Type",
     *               value: "(value: V): Promise<void>"}
     * @memberof AsyncRequiredValidator
     * @instance
     * @export
     * @method validate
     */

    /**
     * A message to be used as hint, when giving a hint on the expected pattern. There is no default
     * hint for this property.
     *
     * @memberof AsyncRequiredValidator
     * @instance
     * @export
     * @name hint
     * @type {Promise.<string|null>}
     */

    // end of jsdoc

    class AsyncRequiredValidator extends SyncValidatorAdapter {
        constructor(options) {
            super(options);
            this.options = options;
        }
        get hint() {
            return super._GetHint();
        }
        _InitLoadingPromise() {
            if (!this._loadingPromise) {
                this._loadingPromise = new Promise(function (resolve, reject) { require(['ojs/ojvalidator-required'], function (m) { resolve(_interopNamespace(m)); }, reject) });
            }
        }
    }

    return AsyncRequiredValidator;

});


define('ojs/ojslider',['ojs/ojcore', 'ojs/ojeditablevalue', 'jqueryui-amd/widgets/draggable', 'ojs/ojtouchproxy', 'ojs/ojcore-base', 'jquery', 'ojs/ojtranslation', 'ojs/ojdomutils'], function (ojcore, ojeditablevalue, draggable, ojtouchproxy, oj, $, Translations, DomUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  (function () {
    var bindingMeta = {
      properties: {
        readonly: {
          binding: { consume: { name: 'readonly' } }
        },
        userAssistanceDensity: {
          binding: { consume: { name: 'userAssistanceDensity' } }
        },
        labelEdge: {
          binding: { consume: { name: 'labelEdge' } }
        }
      }
    };
var __oj_slider_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "max": {
      "type": "number",
      "value": 100
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "min": {
      "type": "number",
      "value": 0
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "horizontal"
    },
    "step": {
      "type": "number",
      "value": 1
    },
    "transientValue": {
      "type": "number",
      "writeback": true,
      "readOnly": true
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "invalidStep": {
          "type": "string"
        },
        "maxMin": {
          "type": "string"
        },
        "noValue": {
          "type": "string"
        },
        "optionNum": {
          "type": "string"
        },
        "valueRange": {
          "type": "string"
        }
      }
    },
    "type": {
      "type": "string",
      "enumValues": [
        "fromMax",
        "fromMin",
        "single"
      ],
      "value": "fromMin"
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "number",
      "writeback": true,
      "value": 0
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    __oj_slider_metadata.extension._WIDGET_NAME = 'ojSlider';
    __oj_slider_metadata.extension._INNER_ELEM = 'input';
    oj.CustomElementBridge.register('oj-slider', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_slider_metadata, bindingMeta)
    });

var __oj_range_slider_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "max": {
      "type": "number",
      "value": 100
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "min": {
      "type": "number",
      "value": 0
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "horizontal"
    },
    "step": {
      "type": "number",
      "value": 1
    },
    "transientValue": {
      "type": "object",
      "writeback": true,
      "readOnly": true,
      "properties": {
        "end": {
          "type": "number"
        },
        "start": {
          "type": "number"
        }
      }
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "higherValueThumb": {
          "type": "string"
        },
        "lowerValueThumb": {
          "type": "string"
        },
        "startEnd": {
          "type": "string"
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "object",
      "writeback": true,
      "properties": {
        "end": {
          "type": "number"
        },
        "start": {
          "type": "number"
        }
      }
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    /* global __oj_range_slider_metadata */
    __oj_range_slider_metadata.extension._WIDGET_NAME = 'ojSlider';
    __oj_range_slider_metadata.extension._INNER_ELEM = 'input';
    oj.CustomElementBridge.register('oj-range-slider', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_range_slider_metadata, bindingMeta)
    });
  })();

  const OJ_SLIDER_THUMB = '.oj-slider-thumb';
  const ARIA_LABEL = 'aria-label';
  const ARIA_LABELLEDBY = 'aria-labelledby';
  const OJ_SLIDER_THUMB_INDEX = 'oj-slider-thumb-index';
  const EMPTY_DIV = '<div></div>';
  const OJ_SLIDER_BAR = 'oj-slider-bar';
  const OJ_SLIDER_BAR_VALUE = 'oj-slider-bar-value';
  const UI_DRAGGABLE = '.ui-draggable';

  (function () {
    /*!
     * JET Slider @VERSION
     *
     *
     * Depends:
     *  jquery.ui.widget.js
     */

    /**
     * @ojcomponent oj.ojRangeSlider
     * @ojdisplayname Range Slider
     * @augments oj.editableValue
     * @ojimportmembers oj.ojDisplayOptions
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojRangeSlider extends editableValue<Object|null, ojRangeSliderSettableProperties>"
     *               },
     *               {
     *                target: "Type",
     *                value: "ojRangeSliderSettableProperties extends editableValueSettableProperties<Object|null>",
     *                for: "SettableProperties"
     *               }
     *              ]
     * @ojrole rangeslider
     * @since 8.2.0
     * @ojshortdesc A range-slider allows a user to set a value range by moving the indicators.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "type", "orientation", "min", "max", "step", "disabled"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 3
     * @ojvbmincolumns 3
     *
     * @ojoracleicon 'oj-ux-ico-range-slider'
     * @ojuxspecs ['slider']
     *
     * @classdesc
     * <h3 id="sliderOverview-section">
     *   JET Range Slider Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sliderOverview-section"></a>
     * </h3>
     * <p>Description: The oj-range-slider component enhances an HTML
     * <code class="prettyprint">input</code> element into an interactive range-slider.
     * </p>
     * The numerical <code class="prettyprint">value</code> attribute determines the
     * current value of the range-slider, and thus affects the position of the range-slider thumb.
     * The value should be between the <code class="prettyprint">min</code> and
     * <code class="prettyprint">max</code> attribute values.
     * </p>
     * The <code class="prettyprint">step</code> attribute of the range-slider specifies the
     * interval between thumb stops. For example,
     * if <code class="prettyprint">min</code>  is set to 0 and
     * <code class="prettyprint">max</code>
     * is set to 10, a <code class="prettyprint">step</code> value of 2 would allow the thumb
     * to be positioned at 0, 2, 4, 6, 8, and 10.
     * </p>
     * The <code class="prettyprint">orientation</code> attribute defaults to
     * <code class="prettyprint">"horizontal"</code>.
     * Set <code class="prettyprint">orientation</code> to
     * <code class="prettyprint">"vertical"</code> for a vertical range-slider (one where the thumb
     * travels along the vertical axis).
     * </p>
     * The <code class="prettyprint">type</code> attribute is used to effect the rendered
     * style of the range-slider.
     * The <code class="prettyprint">type</code> attribute defaults to
     * <code class="prettyprint">"fromMin"</code>, which will style the value bar from the minimum
     * value to the range-slider thumb.
     * The <code class="prettyprint">type</code> attribute to either "single" or "fromMax" -
     * this will alter the rendered style of the range-slider's bar value.
     * </p>
     * Set the <code class="prettyprint">disabled</code> attribute
     * <code class="prettyprint">true</code> to display a range-slider that displays a value but does
     * not allow interaction.
     * </p>
     * Use <code class="prettyprint">style </code> attributes on the
     * <code class="prettyprint">oj-range-slider </code> element to set a horizontal range-slider's
     * width or a vertical range-slider's height.
     * </p>
     * Use the <code class="prettyprint">transient-value</code> attribute to access
     * range-slider value changes during range-slider thumb repositioning.
     * </p>
     * Note that the <code class="prettyprint">range</code> value for the
     * <code class="prettyprint">type</code> attribute
     * is not part of the initial (4.0) release of the custom element range-slider.
     * </p>
     * {@ojinclude "name":"validationAndMessagingDoc"}
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The range-slider component is accessible - it sets and maintains the appropriate aria- attributes,
     * including <code class="prettyprint">aria-valuenow</code>,
     * <code class="prettyprint">aria-valuemax</code>,
     * <code class="prettyprint">aria-valuemin</code>
     * and <code class="prettyprint">aria-orientation</code>.
     * <p>
     * {@ojinclude "name":"accessibilitySetLabelEditableValue"}
     * {@ojinclude "name":"accessibilityDisabledEditableValue"}
     * </p>
     * </p>
     * In addition, the range-slider thumb element can be accessed programmatically.
     * This approach may be necessary to ensure accessibility conformance.
     * For example, if the range-slider controls another element that is in a remote area of the page,
     * then the <code class="prettyprint">aria-controls</code> attribute for the range-slider thumb
     * should be set.
     *
     * <p>
     * Consider an example where you may need to set additional attributes for accessibility reasons.
     * Suppose there is another component that is in a remote area of the page
     * that controlled by the range-slider.
     * Assume that the <code class="prettyprint">id</code> of the remote element is
     * "idOfRemoteElement".
     * Below we show how to access the thumb element in order to set the
     * <code class="prettyprint">aria-controls</code> attribute of the thumb to point to the
     * id ("idOfRemoteElement") of the remote html element:
     *
     * <pre class="prettyprint">
     * <code>
     *     var thumb0 = myComponent.querySelectorAll('.oj-range-slider-thumb')[0];
     *     thumb0.setAttribute(aria-controls, "idOfRemoteElement");
     * </code></pre>
     *
     * @example <caption>Declare the oj-slider component with no attributes specified:</caption>
     * &lt;oj-range-slider>&lt;/oj-range-slider>
     *
     * @example <caption>Initialize the range-slider with a few attributes:</caption>
     * &lt;oj-range-slider value=10 max=100 min=0 step=2>&lt;/oj-range-slider>
     *
     * @example <caption>Initialize a component attribute via component binding:</caption>
     * &lt;oj-range-slider value="{{currentValue}}">&lt;/oj-range-slider>
     */

    //-----------------------------------------------------
    //                   Fragments RangeSlider
    //-----------------------------------------------------
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Range Slider Bar</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Reposition the thumb.</td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider Thumb</td>
     *       <td><kbd>Swipe</kbd></td>
     *       <td>Reposition the thumb.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc,
     * and standalone gesture doc
     * @memberof oj.ojRangeSlider
     */
    /**
     * The JET slider supports keyboard actions for thumb movement:
     *
     * <p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *        <th>Target</th>
     *       <th>Key</th>
     *       <th>Use</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td> Places focus on the range slider component.
     *        If hints, title or messages exist in a notewindow, pop up the notewindow.
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Scrolls right on a horizontal range slider, scrolls up on a vertical range slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Scrolls left on a horizontal range slider, scrolls down on a vertical range slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Scrolls right on a horizontal range slider, scrolls up on a vertical range slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Scrolls left on a horizontal range slider,
     *        scrolls down on a vertical range slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>PageUp</kbd></td>
     *       <td>Scrolls one page right on a horizontal range slider,
     *        scrolls one page up on a vertical range slider. <br>
     *       A page is defined as 20% of the range of the range slider.
     *     </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>PageDown</kbd></td>
     *       <td>Scrolls one page left on a horizontal range slider,
     *       scrolls one page down on a vertical range slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Scrolls to the right end on a horizontal range slider, scrolls to the bottom on a
     * vertical range slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Range Slider</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Scrolls to the left end on a horizontal range slider, scrolls to the top on a
     * vertical range slider.
     *       </td>
     *     </tr>
     * </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone
     * gesture doc
     * @memberof oj.ojRangeSlider
     */

    //-----------------------------------------------------
    //                   Slider
    //-----------------------------------------------------
    /**
     * @ojcomponent oj.ojSlider
     * @ojdisplayname Slider
     * @augments oj.editableValue
     * @ojimportmembers oj.ojDisplayOptions
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojSlider extends editableValue<number|null, ojSliderSettableProperties>"
     *               },
     *               {
     *                target: "Type",
     *                value: "ojSliderSettableProperties extends editableValueSettableProperties<number|null>",
     *                for: "SettableProperties"
     *               }
     *              ]
     *
     * @ojrole slider
     * @since 0.7.0
     * @ojshortdesc A slider allows a user to set a value by moving an indicator.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "type", "orientation", "min", "max", "step", "disabled"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 3
     * @ojvbmincolumns 3
     *
     * @ojoracleicon 'oj-ux-ico-slider'
     *
     * @classdesc
     * <h3 id="sliderOverview-section">
     *   JET Slider Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sliderOverview-section"></a>
     * </h3>
     * <p>Description: The oj-slider component enhances an HTML
     * <code class="prettyprint">input</code> element into an interactive slider.
     * </p>
     * The numerical <code class="prettyprint">value</code> attribute determines the
     * current value of the slider, and thus affects the position of the slider thumb.
     * The value should be between the <code class="prettyprint">min</code> and
     * <code class="prettyprint">max</code> attribute values.
     * </p>
     * The <code class="prettyprint">step</code> attribute of the slider specifies the
     * interval between thumb stops. For example,
     * if <code class="prettyprint">min</code>  is set to 0 and
     * <code class="prettyprint">max</code>
     * is set to 10, a <code class="prettyprint">step</code> value of 2 would allow the thumb
     * to be positioned at 0, 2, 4, 6, 8, and 10.
     * </p>
     * The <code class="prettyprint">orientation</code> attribute defaults to
     * <code class="prettyprint">"horizontal"</code>.
     * Set <code class="prettyprint">orientation</code> to
     * <code class="prettyprint">"vertical"</code> for a vertical slider (one where the thumb
     * travels along the vertical axis).
     * </p>
     * The <code class="prettyprint">type</code> attribute is used to effect the rendered
     * style of the slider.
     * The <code class="prettyprint">type</code> attribute defaults to
     * <code class="prettyprint">"fromMin"</code>, which will style the value bar from the minimum
     * value to the slider thumb.
     * The <code class="prettyprint">type</code> attribute to either "single" or "fromMax" -
     * this will alter the rendered style of the slider's bar value.
     * </p>
     * Set the <code class="prettyprint">disabled</code> attribute
     * <code class="prettyprint">true</code> to display a slider that displays a value but does
     * not allow interaction.
     * </p>
     * Use <code class="prettyprint">style </code> attributes on the
     * <code class="prettyprint">oj-slider </code> element to set a horizontal slider's
     * width or a vertical slider's height.
     * </p>
     * Use the <code class="prettyprint">transient-value</code> attribute to access
     * slider value changes during slider thumb repositioning.
     * </p>
     * Note that the <code class="prettyprint">range</code> value for the
     * <code class="prettyprint">type</code> attribute
     * is not part of the initial (4.0) release of the custom element slider.
     * </p>
     * {@ojinclude "name":"validationAndMessagingDoc"}
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The slider component is accessible - it sets and maintains the appropriate aria- attributes,
     * including <code class="prettyprint">aria-valuenow</code>,
     * <code class="prettyprint">aria-valuemax</code>,
     * <code class="prettyprint">aria-valuemin</code>
     * and <code class="prettyprint">aria-orientation</code>.
     * </p>
     * In addition, the slider thumb element can be accessed programmatically.
     * This approach may be necessary to ensure accessibility conformance.
     * For example, if the slider controls another element that is in a remote area of the page,
     * then the <code class="prettyprint">aria-controls</code> attribute for the slider thumb
     * should be set.
     *
     * <p>
     * Consider an example where you may need to set additional attributes for accessibility reasons.
     * Suppose there is another component that is in a remote area of the page
     * that controlled by the slider.
     * Assume that the <code class="prettyprint">id</code> of the remote element is
     * "idOfRemoteElement".
     * Below we show how to access the thumb element in order to set the
     * <code class="prettyprint">aria-controls</code> attribute of the thumb to point to the
     * id ("idOfRemoteElement") of the remote html element:
     *
     * <pre class="prettyprint">
     *
     * <code>
     *     var thumb0 = myComponent.querySelectorAll('.oj-slider-thumb')[0];
     *     thumb0.setAttribute(aria-controls, "idOfRemoteElement");
     * </code></pre>
     * {@ojinclude "name":"accessibilityDisabledEditableValue"}
     *
     * @example <caption>Declare the oj-slider component with no attributes specified:</caption>
     * &lt;oj-slider>&lt;/oj-slider>
     *
     * @example <caption>Initialize the slider with a few attributes:</caption>
     * &lt;oj-slider value=10 max=100 min=0 step=2>&lt;/oj-slider>
     *
     * @example <caption>Initialize a component attribute via component binding:</caption>
     * &lt;oj-slider value="{{currentValue}}">&lt;/oj-slider>
     */

    //-----------------------------------------------------
    //                   Fragments Slider
    //-----------------------------------------------------
    /**
     * The JET slider supports keyboard actions for thumb movement:
     *
     * <p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *        <th>Target</th>
     *       <th>Key</th>
     *       <th>Use</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td> Places focus on the slider component.
     *        If hints, title or messages exist in a notewindow, pop up the notewindow.
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Scrolls right on a horizontal slider, scrolls up on a vertical slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Scrolls left on a horizontal slider, scrolls down on a vertical slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Scrolls right on a horizontal slider, scrolls up on a vertical slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Scrolls left on a horizontal slider,
     *        scrolls down on a vertical slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>PageUp</kbd></td>
     *       <td>Scrolls one page right on a horizontal slider,
     *        scrolls one page up on a vertical slider. <br>
     *       A page is defined as 20% of the range of the slider.
     *     </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>PageDown</kbd></td>
     *       <td>Scrolls one page left on a horizontal slider,
     *       scrolls one page down on a vertical slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Scrolls to the right end on a horizontal slider, scrolls to the bottom on a
     * vertical slider.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Slider</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Scrolls to the left end on a horizontal slider, scrolls to the top on a
     * vertical slider.
     *       </td>
     *     </tr>
     * </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone
     * gesture doc
     * @memberof oj.ojSlider
     */
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Slider Bar</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Reposition the thumb.</td>
     *     </tr>
     *     <tr>
     *       <td>Slider Thumb</td>
     *       <td><kbd>Swipe</kbd></td>
     *       <td>Reposition the thumb.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc,
     * and standalone gesture doc
     * @memberof oj.ojSlider
     */

    //-----------------------------------------------------
    //                   Sub-ids Slider
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the slider thumb. Use this id to access the thumb of the  slider. </p>
     *
     * @ojsubid oj-slider-thumb-0
     * @memberof oj.ojSlider
     *
     * @example <caption>Get the node for the slider thumb:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-slider-thumb-0'});
     */

    /**
     * <p>Sub-ID for the slider bar. </p>
     *
     * @ojsubid oj-slider-bar
     * @memberof oj.ojSlider
     *
     * @example <caption>Get the node for the slider bar:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-slider-bar'});
     *
     */

    /**
     * <p>Sub-ID for the slider bar value. </p>
     *
     * @ojsubid oj-slider-bar-value
     * @memberof oj.ojSlider
     *
     * @example <caption>Get the node for the slider bar value:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-slider-bar-value'});
     *
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------
    // ---------------- oj-focus-highlight --------------
    /**
     * Under normal circumstances this class is applied automatically.
     * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojSlider
     * @ojtsexample
     * &lt;oj-slider class="oj-focus-highlight">
     *   &lt;!-- Content -->
     * &lt;/oj-slider>
     */
    // ---------------- oj-form-control-full-width --------------
    /**
     * Changes the max-width to 100% so that form components will occupy all the available horizontal space.
     * @ojstyleclass oj-form-control-full-width
     * @ojdisplayname Full Width
     * @memberof oj.ojSlider
     * @ojtsexample
     * &lt;oj-slider class="oj-form-control-full-width">
     * &lt;/oj-slider>
     */

    // ---------------- oj-form-control max-width --------------
    /**
     * In the Redwood theme the default max width of a text field is 100%.
     * These max width convenience classes are available to create a medium or small field.<br>
     * The class is applied to the root element.
     * @ojstyleset form-control-max-width
     * @ojdisplayname Max Width
     * @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
     * @ojstylerelation exclusive
     * @memberof oj.ojSlider
     * @ojunsupportedthemes ['Alta']
     * @ojtsexample
     * &lt;oj-slider class="oj-form-control-max-width-md">&lt;/oj-slider>
     */
    /**
     * @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
     * @ojshortdesc Sets the max width for a small field
     * @ojdisplayname Small
     * @memberof! oj.ojSlider
     */
    /**
     * @ojstyleclass form-control-max-width.oj-form-control-max-width-md
     * @ojshortdesc Sets the max width for a medium field
     * @ojdisplayname Medium
     * @memberof! oj.ojSlider
     */

    // ---------------- oj-form-control width --------------
    /**
     * In the Redwood theme the default width of a text field is 100%.
     * These width convenience classes are available to create a medium or small field.<br>
     * The class is applied to the root element.
     * @ojstyleset form-control-width
     * @ojdisplayname Width
     * @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
     * @ojstylerelation exclusive
     * @memberof oj.ojSlider
     * @ojunsupportedthemes ['Alta']
     * @ojtsexample
     * &lt;oj-slider class="oj-form-control-width-md">&lt;/oj-slider>
     */
    /**
     * @ojstyleclass form-control-width.oj-form-control-width-sm
     * @ojshortdesc Sets the width for a small field
     * @ojdisplayname Small
     * @memberof! oj.ojSlider
     */
    /**
     * @ojstyleclass form-control-width.oj-form-control-width-md
     * @ojshortdesc Sets the width for a medium field
     * @ojdisplayname Medium
     * @memberof! oj.ojSlider
     */
    /**
     * @ojstylevariableset oj-slider-css-set1
     * @ojstylevariable oj-slider-thumb-width {description: "Slider thumb width", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-slider-thumb-height {description: "Slider thumb height", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-slider-thumb-border-radius {description: "Slider thumb border radius", formats: ["length","percentage"], help: "#css-variables"}
     * @ojstylevariable oj-slider-thumb-border-width {description: "Slider thumb border width", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-slider-track-thickness {description: "Slider track thickness", formats: ["length"], help: "#css-variables"}
     * @memberof oj.ojSlider
     */
    /**
     * CSS variables used by oj-slider when enabled
     * @ojstylevariableset oj-slider-css-set2
     * @ojdisplayname Enabled
     * @ojstylevariable oj-slider-thumb-bg-color {description: "Slider thumb background color when enabled", formats: ["color"], help: "#oj-slider-css-set2"}
     * @ojstylevariable oj-slider-thumb-border-color {description: "Slider thumb border color when enabled", formats: ["color"], help: "#oj-slider-css-set2"}
     * @ojstylevariable oj-slider-thumb-box-shadow {description: "Slider thumb box shadow when enabled", help: "#oj-slider-css-set2"}
     * @ojstylevariable oj-slider-track-bg-color {description: "Slider track background color when enabled", formats: ["color"], help: "#oj-slider-css-set2"}
     * @ojstylevariable oj-slider-value-bg-color {description: "Slider value background color when enabled", formats: ["color"], help: "#oj-slider-css-set2"}
     * @memberof oj.ojSlider
     */
    /**
     * CSS variables used by oj-slider when hovered
     * @ojstylevariableset oj-slider-css-set3
     * @ojdisplayname Hovered
     * @ojstylevariable oj-slider-thumb-bg-color-hover {description: "Slider thumb background color when hovered", formats: ["color"], help: "#oj-slider-css-set3"}
     * @ojstylevariable oj-slider-thumb-box-shadow-hover {description: "Slider thumb box shadow when hovered", help: "#oj-slider-css-set3"}
     * @memberof oj.ojSlider
     */
    /**
     * CSS variables used by oj-slider when active
     * @ojstylevariableset oj-slider-css-set4
     * @ojdisplayname Active
     * @ojstylevariable oj-slider-thumb-bg-color-active {description: "Slider thumb background color when active", formats: ["color"], help: "#oj-slider-css-set4"}
     * @ojstylevariable oj-slider-thumb-border-color-active {description: "Slider thumb border color when active", formats: ["color"], help: "#oj-slider-css-set4"}
     * @ojstylevariable oj-slider-thumb-box-shadow-active {description: "Slider thumb box shadow when active", help: "#oj-slider-css-set4"}
     * @ojstylevariable oj-slider-thumb-scale-active {description: "Slider thumb scale when active", formats: ["number"], help: "#oj-slider-css-set4"}
     * @memberof oj.ojSlider
     */
    /**
     * CSS variables used by oj-slider when disabled
     * @ojstylevariableset oj-slider-css-set5
     * @ojdisplayname Disabled
     * @ojstylevariable oj-slider-thumb-bg-color-disabled {description: "Slider thumb background color when disabled", formats: ["color"], help: "#oj-slider-css-set5"}
     * @ojstylevariable oj-slider-thumb-border-color-disabled {description: "Slider thumb border color when disabled", formats: ["color"], help: "#oj-slider-css-set5"}
     * @ojstylevariable oj-slider-track-bg-color-disabled {description: "Slider track background color when disabled", formats: ["color"], help: "#oj-slider-css-set5"}
     * @ojstylevariable oj-slider-value-bg-color-disabled {description: "Slider value background color when disabled", formats: ["color"], help: "#oj-slider-css-set5"}
     * @memberof oj.ojSlider
     */
    oj.__registerWidget('oj.ojSlider', $.oj.editableValue, {
      defaultElement: '<input>',
      version: '1.0.1',
      widgetEventPrefix: 'oj',

      options: {
        /**
         * <p>
         * The oj-label sets the labelledBy property programmatically on the form component
         * to make it easy for the form component to find its oj-label component (a
         * document.getElementById call.)
         * </p>
         * <p>
         * The application developer should use the 'for'/'id api
         * to link the oj-label with the form component;
         * the 'for' on the oj-label to point to the 'id' on the input form component.
         * This is the most performant way for the oj-label to find its form component.
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
         * &lt;oj-label for="sliderId">Name:&lt;/oj-label>
         * &lt;oj-slider id="sliderId">
         * &lt;/oj-slider>
         * // ojLabel then writes the labelled-by attribute on the oj-slider.
         * &lt;oj-label id="labelId" for="sliderId">Name:&lt;/oj-label>
         * &lt;oj-slider id="sliderId" labelled-by"labelId">
         * &lt;/oj-slider>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelledBy = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         *
         * @expose
         * @name labelledBy
         * @ojshortdesc The oj-label sets the labelledBy property
         * programmatically on the form component.
         * @type {string|null}
         * @default null
         * @public
         * @instance
         * @since 7.0.0
         * @memberof oj.ojSlider
         */
        /**
         * <p>
         * The oj-label sets the labelledBy property programmatically on the form component
         * to make it easy for the form component to find its oj-label component (a
         * document.getElementById call.)
         * </p>
         * <p>
         * The application developer should use the 'for'/'id api
         * to link the oj-label with the form component;
         * the 'for' on the oj-label to point to the 'id' on the input form component.
         * This is the most performant way for the oj-label to find its form component.
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
         * &lt;oj-label for="rangeSliderId">Name:&lt;/oj-label>
         * &lt;oj-range-slider id="rangeSliderId">
         * &lt;/oj-range-slider>
         * // ojLabel then writes the labelled-by attribute on the oj-range-slider.
         * &lt;oj-label id="labelId" for="rangeSliderId">Name:&lt;/oj-label>
         * &lt;oj-range-slider id="rangeSliderId" labelled-by"labelId">
         * &lt;/oj-range-slider>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelledBy = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         *
         * @expose
         * @name labelledBy
         * @ojshortdesc The oj-label sets the labelledBy property
         * programmatically on the form component.
         * @type {string|null}
         * @default null
         * @public
         * @instance
         * @since 8.2.0
         * @memberof oj.ojRangeSlider
         */
        labelledBy: null,

        /**
         * The maximum value of the slider.
         * The <code class="prettyprint">max</code> must not be less than the
         * <code class="prettyprint">min</code>, or else an Error is thrown during
         * initialization.
         * @expose
         * @name max
         * @memberof oj.ojSlider
         * @ojshortdesc The maximum value of the slider. See the Help documentation for more information.
         * @instance
         * @type {?number}
         * @default 100
         * @since 0.7.0
         * @example <caption>Initialize the slider with the
         * <code class="prettyprint">max</code> attribute:</caption>
         * &lt;oj-slider max=100>&lt;/oj-slider>
         * @example <caption>Get or set the <code class="prettyprint">max</code> property after initialization:</caption>
         * // Getter
         * var max = myComponent.max;
         *
         * // Setter
         * myComponent.max = 100;
         */
        /**
         * The maximum value of the range slider.
         * The <code class="prettyprint">max</code> must not be less than the
         * <code class="prettyprint">min</code>, or else an Error is thrown during
         * initialization.
         * @expose
         * @memberof oj.ojRangeSlider
         * @ojshortdesc The maximum value of the range slider. See the Help documentation for more information.
         * @instance
         * @type {?number}
         * @default 100
         * @since 8.2.0
         * @example <caption>Initialize the range slider with the
         * <code class="prettyprint">max</code> attribute:</caption>
         * &lt;oj-range-slider max=100>&lt;/oj-range-slider>
         * @example <caption>Get or set the <code class="prettyprint">max</code> property after initialization:</caption>
         * // Getter
         * var max = myComponent.max;
         *
         * // Setter
         * myComponent.max = 100;
         */
        max: 100,

        /**
         * The minimum value of the slider.
         * The <code class="prettyprint">min</code> must not be greater than the
         * <code class="prettyprint">max</code>, or else an Error is thrown during
         * initialization.
         * @expose
         * @name min
         * @memberof oj.ojSlider
         * @ojshortdesc The minimum value of the slider. See the Help documentation for more information.
         * @instance
         * @type {?number}
         * @default 0
         * @since 0.7.0
         * @example <caption>Initialize the slider with the
         * <code class="prettyprint">min</code> attribute:</caption>
         * &lt;oj-slider min=0>&lt;/oj-slider>
         * @example <caption>Get or set the <code class="prettyprint">min</code> property after initialization:</caption>
         * // Getter
         * var min = myComponent.min;
         *
         * // Setter
         * myComponent.min = 0;
         *
         */
        /**
         * The minimum value of the range slider.
         * The <code class="prettyprint">min</code> must not be greater than the
         * <code class="prettyprint">max</code>, or else an Error is thrown during
         * initialization.
         * @expose
         * @memberof oj.ojRangeSlider
         * @ojshortdesc The minimum value of the range slider. See the Help documentation for more information.
         * @instance
         * @type {?number}
         * @default 0
         * @since 8.2.0
         * @example <caption>Initialize the range slider with the
         * <code class="prettyprint">min</code> attribute:</caption>
         * &lt;oj-range-slider min=0>&lt;/oj-range-slider>
         * @example <caption>Get or set the <code class="prettyprint">min</code> property after initialization:</caption>
         * // Getter
         * var min = myComponent.min;
         *
         * // Setter
         * myComponent.min = 0;
         *
         */
        min: 0,

        /**
         * Specify the orientation of the slider.
         *
         * @expose
         * @name orientation
         * @memberof oj.ojSlider
         * @ojshortdesc Specifies the orientation of the slider.
         * @instance
         * @type {string}
         * @ojvalue {string} "horizontal" Orient the slider horizontally.
         * @ojvalue {string} "vertical" Orient the slider vertically.
         * @default "horizontal"
         * @since 0.7.0
         *
         * @example <caption>Initialize the slider with the
         * <code class="prettyprint">orientation</code> attribute:</caption>
         * &lt;oj-slider orientation="vertical">&lt;/oj-slider>
         *
         * @example <caption>Get or set the <code class="prettyprint">orientation</code>
         * property after initialization:</caption>
         * // Getter
         * var orientation = myComponent.orientation;
         *
         * // Setter
         * myComponent.orientation = "vertical";
         *
         */
        /**
         * Specify the orientation of the range slider.
         *
         * @expose
         * @name orientation
         * @memberof oj.ojRangeSlider
         * @ojshortdesc Specifies the orientation of the range slider.
         * @instance
         * @type {string}
         * @ojvalue {string} "horizontal" Orient the range slider horizontally.
         * @ojvalue {string} "vertical" Orient the range slider vertically.
         * @default "horizontal"
         * @since 8.2.0
         *
         * @example <caption>Initialize the range slider with the
         * <code class="prettyprint">orientation</code> attribute:</caption>
         * &lt;oj-range-slider orientation="vertical">&lt;/oj-range-slider>
         *
         * @example <caption>Get or set the <code class="prettyprint">orientation</code>
         * property after initialization:</caption>
         * // Getter
         * var orientation = myComponent.orientation;
         *
         * // Setter
         * myComponent.orientation = "vertical";
         *
         */
        orientation: 'horizontal',

        /**
         * readOnly is private - more UX design is necessary to support readonly across
         * components.
         * Whether the component is readOnly. The element's
         * <code class="prettyprint">readOnly</code>
         * attribute is used as its initial value if it exists, when the attribute is not explicitly
         * set. When neither is set, <code class="prettyprint">readOnly </code>
         * defaults to false.
         * <p>
         * The default value for readonly is false. However, if the form component is a descendent of
         * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
         * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
         * The <code class="prettyprint">oj-form-layout</code> uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">readonly</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the readonly property if an ancestor provides it and
         * it is not explicitly set.
         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
         * not have its readonly attribute set, the form component's readonly will be true.
         * </p>
         * @example <caption>Initialize component with <code class="prettyprint">readOnly</code>
         * attribute:</caption>
         * &lt;oj-slider readOnly="true">&lt;/oj-slider>
         * @example <caption>Get or set the <code class="prettyprint">readOnly</code> property after initialization:</caption>
         * // Getter
         * var readOnly = myComponent.readOnly;
         *
         * // Setter
         * myComponent.readOnly = true;
         *
         *
         * @private
         * @type {?boolean}
         * @default false
         * @instance
         * @memberof oj.ojSlider
         */
        /**
         * readOnly is private - more UX design is necessary to support readonly across
         * components.
         * Whether the component is readOnly. The element's
         * <code class="prettyprint">readOnly</code>
         * attribute is used as its initial value if it exists, when the attribute is not explicitly
         * set. When neither is set, <code class="prettyprint">readOnly </code>
         * defaults to false.
         *
         * @example <caption>Initialize component with <code class="prettyprint">readOnly</code>
         * attribute:</caption>
         * &lt;oj-range-slider readOnly="true">&lt;/oj-range-slider>
         * @example <caption>Get or set the <code class="prettyprint">readOnly</code> property after initialization:</caption>
         * // Getter
         * var readOnly = myComponent.readOnly;
         *
         * // Setter
         * myComponent.readOnly = true;
         *
         *
         * @private
         * @type {?boolean}
         * @default false
         * @instance
         * @memberof oj.ojRangeSlider
         */
        readOnly: false,

        /**
         * Whether the component is disabled. The
         * <code class="prettyprint">disabled</code> attribute is used as its initial
         * value if it exists, when the attribute is not explicitly set. When neither is set,
         * <code class="prettyprint">disabled </code>
         * defaults to false.
         *
         * @example <caption>Initialize the slider with
         * <code class="prettyprint">disabled</code> attribute:</caption>
         * &lt;oj-slider disabled="true">&lt;/oj-slider>
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // Getter
         * var disabled = myComponent.disabled;
         *
         * // Setter
         * myComponent.disabled = true;
         *
         * @ojshortdesc Specifies whether the component is disabled. The default is false.
         * @expose
         * @type {boolean}
         * @default false
         * @since 0.7.0
         * @instance
         * @memberof oj.ojSlider
         */
        /**
         * Whether the component is disabled. The
         * <code class="prettyprint">disabled</code> attribute is used as its initial
         * value if it exists, when the attribute is not explicitly set. When neither is set,
         * <code class="prettyprint">disabled </code>
         * defaults to false.
         *
         * @example <caption>Initialize the slider with
         * <code class="prettyprint">disabled</code> attribute:</caption>
         * &lt;oj-range-slider disabled="true">&lt;/oj-range-slider>
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // Getter
         * var disabled = myComponent.disabled;
         *
         * // Setter
         * myComponent.disabled = true;
         *
         * @ojshortdesc Specifies whether the component is disabled. The default is false.
         * @expose
         * @type {boolean}
         * @default false
         * @since 8.2.0
         * @instance
         * @memberof oj.ojRangeSlider
         */
        disabled: false,

        /**
         * Determines the size or amount of each interval or step the slider takes
         * between min and max.
         * The full specified value of the range (max - min) should be divisible by step.
         *
         * @expose
         * @name step
         * @instance
         * @type {?number}
         * @default 1
         * @since 0.7.0
         * @memberof oj.ojSlider
         * @ojshortdesc Specifies the amount to increase or decrease the value when moving in step increments. See the Help documentation for more information.
         *
         * @example <caption>Initialize the slider with the
         * <code class="prettyprint">step</code> attribute:</caption>
         * &lt;oj-slider step=10>&lt;/oj-slider>
         * @example <caption>Get or set the <code class="prettyprint">step</code> property after initialization:</caption>
         * // Getter
         * var step = myComponent.step;
         *
         * // Setter
         * myComponent.step = 10;
         *
         **/
        /**
         * Determines the size or amount of each interval or step the range slider takes
         * between min and max.
         * The full specified value of the range (max - min) should be divisible by step.
         *
         * @expose
         * @instance
         * @type {?number}
         * @default 1
         * @since 8.2.0
         * @memberof oj.ojRangeSlider
         * @ojshortdesc Specifies the amount to increase or decrease the value when moving in step increments. See the Help documentation for more information.
         *
         * @example <caption>Initialize the range slider with the
         * <code class="prettyprint">step</code> attribute:</caption>
         * &lt;oj-range-slider step=10>&lt;/oj-range-slider>
         * @example <caption>Get or set the <code class="prettyprint">step</code> property after initialization:</caption>
         * // Getter
         * var step = myComponent.step;
         *
         * // Setter
         * myComponent.step = 10;
         *
         **/
        step: 1,

        /**
         * The slider type determines how the value is represented in the UI.
         *
         * @expose
         * @name type
         * @type {?string}
         * @ojvalue {string} "fromMin" A single-thumb slider where the value bar goes from
         * the slider min to the slider thumb.
         * @ojvalue {string} "fromMax" A single-thumb slider where the value bar goes from
         * the slider thumb to the slider max.
         * @ojvalue {string} "single" A single-thumb slider where the value bar has no
         * additional styling.
         * @default "fromMin"
         * @since 0.7.0
         * @instance
         * @member
         * @memberof oj.ojSlider
         * @ojshortdesc The slider type specifies how the slider value is represented.
         *
         * @example <caption>Initialize component with <code class="prettyprint">type</code>
         * attribute set to "fromMax":</caption>
         * &lt;oj-slider type="fromMax">&lt;/oj-slider>
         * @example <caption>Get or set the <code class="prettyprint">type</code> property after initialization:</caption>
         * // Getter
         * var type = myComponent.type;
         *
         * // Setter
         * myComponent.type = "fromMax";
         *
         */
        type: 'fromMin',

        /**
         * The numerical value of the slider.
         *
         * <p> Note that the <code class="prettyprint">value</code> attribute should
         * be compatible with the <code class="prettyprint">type</code> attribute, as
         * described above.
         *
         * @example <caption>Initialize the slider with the
         * <code class="prettyprint">value</code> attribute:</caption>
         * &lt;oj-slider value=55>&lt;/oj-slider>
         * @example <caption>Get or set <code class="prettyprint">value</code> property
         * after initialization:</caption>
         * // Getter
         * var value = myComponent.value;
         *
         * // Setter
         * myComponent.value = 10;
         *
         * @member
         * @name value
         * @ojshortdesc The numerical value of the slider.
         * @expose
         * @access public
         * @instance
         * @default 0
         * @since 0.7.0
         * @ojwriteback
         * @ojeventgroup common
         * @memberof oj.ojSlider
         * @ojshortdesc The numerical value of the slider.
         * @type {?number}
         */
        /**
         * The numerical range value of the range-slider.
         *
         * @example <caption>Initialize the range-slider with the
         * <code class="prettyprint">value</code> attribute:</caption>
         * &lt;oj-range-slider value={start:10, end:40} >&lt;/oj-range-slider>
         * @example <caption>Get or set <code class="prettyprint">value</code> property
         * after initialization:</caption>
         * // Getter
         * var value = myComponent.value;
         *
         * // Setter
         * myComponent.value = {start:10, end: 40};
         *
         * @member
         * @name value
         * @ojshortdesc The numerical range value of the range-slider.
         * @expose
         * @access public
         * @instance
         * @default null
         * @since 8.2.0
         * @ojwriteback
         * @ojeventgroup common
         * @memberof oj.ojRangeSlider
         * @ojshortdesc The numerical value of the range-slider.
         * @type {Object|null}
         */
        // value: {
        /**
         * Start value of the range selected.
         *
         * @expose
         * @name value.start
         * @ojshortdesc Specifies the start value of the range selected.
         * @memberof! oj.ojRangeSlider
         * @instance
         * @type {number|null}
         * @default null
         * @since 8.2.0
         */
        // start: null,
        /**
         * End value of the range selected.
         *
         * @expose
         * @name value.end
         * @ojshortdesc Specifies the end value of the range selected.
         * @memberof! oj.ojRangeSlider
         * @instance
         * @type {number|null}
         * @default null
         * @since 8.2.0
         */
        // end: null
        // },
        value: 0,

        /**
         * <p>The  <code class="prettyprint">transientValue</code> is the read-only attribute for
         * retrieving the transient value from the slider.</p>
         * <p>
         * The <code class="prettyprint">transientValue</code> updates to display the transient
         * changes of the slider thumb value (subject to the step constraints). The difference
         * in behavior is <code class="prettyprint">transientValue</code> will be updated
         * as the thumb is sliding, where as <code class="prettyprint">value</code>
         * is updated only after the thumb is released (or after a key press).
         * </p>
         * <p>This is a read-only attribute so page authors cannot set or change it directly.</p>
         * @expose
         * @name transientValue
         * @ojshortdesc Read-only property used for retrieving the transient value from the component. See the Help documentation for more information.
         * @access public
         * @instance
         * @ojwriteback
         * @memberof oj.ojSlider
         * @type {number}
         * @since 5.0
         * @readonly
         *
         */
        /**
         * <p>The  <code class="prettyprint">transientValue</code> is the read-only attribute for
         * retrieving the transient value from the range slider.</p>
         * <p>
         * The <code class="prettyprint">transientValue</code> updates to display the transient
         * changes of the slider thumb value (subject to the step constraints). The difference
         * in behavior is <code class="prettyprint">transientValue</code> will be updated
         * as the thumb is sliding, where as <code class="prettyprint">value</code>
         * is updated only after the thumb is released (or after a key press).
         * </p>
         * <p>This is a read-only attribute so page authors cannot set or change it directly.</p>
         * @expose
         * @name transientValue
         * @ojshortdesc Read-only property used for retrieving the transient value from the component. See the Help documentation for more information.
         * @access public
         * @instance
         * @ojwriteback
         * @memberof oj.ojRangeSlider
         * @type {Object|null}
         * @since 8.2.0
         * @readonly
         *
         */
        /**
         * Start value of the range selected.
         *
         * @expose
         * @name transientValue.start
         * @ojshortdesc Specifies the start transientValue of the range selected.
         * @memberof! oj.ojRangeSlider
         * @instance
         * @type {number|null}
         * @default null
         * @since 8.2.0
         */
        // start: null,
        /**
         * End value of the range selected.
         *
         * @expose
         * @name transientValue.end
         * @ojshortdesc Specifies the end transientValue of the range selected.
         * @memberof! oj.ojRangeSlider
         * @instance
         * @type {number|null}
         * @default null
         * @since 8.2.0
         */
        rawValue: undefined
      },

      // number of pages in a slider
      // (how many times can you page up/down to go through the whole range)
      _numPages: 5,
      _defaultElementId: null,

      _sliderDisplayValue: null,

      _isRTL: function () {
        return DomUtils.getReadingDirection() === 'rtl';
      },

      _ComponentCreate: function () {
        this._super();

        // ojSlider could support both <div> and <input> tags
        this._inputtag = false;

        if (this.element.is('INPUT')) {
          this._inputtag = true;

          // Save the input tag style, apply to sliderWrapper later in the code.
          if (this.element[0].style) {
            this._styleFromInputTag = this.element[0].style.cssText;
          }

          this._inputElementOriginalDisplay = this.element[0].style.display;
          this.element[0].style.display = 'none';

          if (this.OuterWrapper) {
            this._elementWrapped = $(this.OuterWrapper);
          } else {
            var inputDiv = $(this.element).wrap('<div> </div>'); // @HTMLUpdateOK

            // _elementWrapped is the new wrapped input element.
            this._elementWrapped = inputDiv.parent();
          }
        } else {
          this._elementWrapped = this.element;
        }

        // use 'transientValue' for custom elements,
        // and use 'rawValue' for widget syntax.
        this._transientValueName = this._IsCustomElement() ? 'transientValue' : 'rawValue';
        this._componentCreateStyling();
        this._componentSetup();
      },

      /**
       * Convenience function to set the rawValue option. Overrides EditableValue _SetRawValue.
       * @param {String} val value to set rawValue to
       * @param {Event} event DOM event
       * @return {void}
       * @memberof oj.ojSlider
       * @instance
       * @override
       * @private
       */
      _SetRawValue: function (val, event) {
        var flags = {
          _context: { originalEvent: event, writeback: true, internalSet: true, readOnly: true }
        };
        if (!oj.Object.compareValues(this.options[this._transientValueName], val)) {
          this.option(this._transientValueName, val, flags);
        }
      },
      // Setup the component's styling during component creation.
      _componentCreateStyling: function () {
        var elementWrapped = this._elementWrapped[0];
        elementWrapped.classList.add('oj-slider', 'oj-component', 'oj-form-control');
        this._setOrientationStyles(true);
      },
      // sets the styling for vertical or horizontal orientation.
      // if init is true, then it doesn't try to remove the orientation
      // styling.
      _setOrientationStyles: function (init) {
        var elementWrapped = this._elementWrapped[0];

        if (this._isVertical()) {
          if (!init) {
            elementWrapped.classList.remove('oj-slider-horizontal');
          }
          elementWrapped.classList.add('oj-slider-vertical');
        } else {
          if (!init) {
            elementWrapped.classList.remove('oj-slider-vertical');
          }
          elementWrapped.classList.add('oj-slider-horizontal');
        }
      },
      //
      // Setup the component based on the current options.
      // Also create DOM elements for thumbs and bars.
      // Called during component creation and on option changes.
      //
      _componentSetup: function () {
        this._newMultiValue = [];
        this._thumbIndex = null;

        if (this._isCustomRangeSlider()) {
          this.options.type = 'range';
          if (typeof this.options.value === 'number') {
            this.options.value = {
              start: null,
              end: null
            };
          }
        }

        if (this.options.type === 'range') {
          this._multipleThumbs = true;
        } else {
          this._multipleThumbs = false;
        }

        this._calculateNewMax();

        this._createSliderContainer();
        this._createBarBackground();
        this._buildValueOption();
        this._createRange();
        this._createThumbs();
        this._updateUI();

        this._setupEvents();
      },

      _copyLabelledbyToThumb: function (labelId) {
        var thumb = this._elementWrapped.find(OJ_SLIDER_THUMB);
        var thumb2;
        if (this._isCustomRangeSlider()) {
          var labelEl = document.getElementById(labelId);
          var ariaLabelText = labelEl ? labelEl.textContent : '';
          var lowerValueThumbString = Translations.getTranslatedString('oj-ojSlider.lowerValueThumb');
          var higherValueThumbString = Translations.getTranslatedString(
            'oj-ojSlider.higherValueThumb'
          );
          thumb.attr(ARIA_LABEL, ariaLabelText + ' ' + lowerValueThumbString); // @HTMLUpdateOK
          thumb2 = thumb[1];
          $(thumb2).attr(ARIA_LABEL, ariaLabelText + ' ' + higherValueThumbString); // @HTMLUpdateOK
        } else {
          thumb.attr(ARIA_LABELLEDBY, labelId); // @HTMLUpdateOK
          if (thumb.length > 1) {
            thumb2 = thumb[1];
            $(thumb2).attr(ARIA_LABELLEDBY, String(labelId)); // @HTMLUpdateOK
          }
        }
      },

      _setAriaLabelToThumb: function (ariaLabel) {
        var thumb;
        if (this._isCustomRangeSlider()) {
          var lowerValueThumbString = Translations.getTranslatedString('oj-ojSlider.lowerValueThumb');
          var higherValueThumbString = Translations.getTranslatedString(
            'oj-ojSlider.higherValueThumb'
          );

          thumb = this._elementWrapped.find(OJ_SLIDER_THUMB);
          thumb.attr(ARIA_LABEL, ariaLabel + ' ' + lowerValueThumbString); // @HTMLUpdateOK
          var thumb2 = thumb[1];
          $(thumb2).attr(ARIA_LABEL, ariaLabel + ' ' + higherValueThumbString); // @HTMLUpdateOK
        } else {
          thumb = this.OuterWrapper.querySelector(OJ_SLIDER_THUMB);
          thumb.setAttribute(ARIA_LABEL, ariaLabel); // @HTMLUpdateOK
        }
      },

      _AfterCreate: function () {
        this._super();

        this._makeDraggable();
        this._setAriaInfo();
      },
      _setAriaInfo: function () {
        var ariaLabelString;
        var label;
        var ariaLabelledBy;
        var thumb;

        // for oj-slider, if labelled-by attribute is set, use that to
        // construct the aria-labelledby and put on the thumb
        // else use aria-label if it is there.
        if (this.OuterWrapper) {
          if (this.options.labelledBy) {
            var defaultLabelId = this.uuid + '_Label';
            ariaLabelledBy = ojeditablevalue.EditableValueUtils._getOjLabelAriaLabelledBy(
              this.options.labelledBy,
              defaultLabelId
            );
            this._copyLabelledbyToThumb(ariaLabelledBy);
          }
          // there is a use-case where aria-label is set on the component, and we write that to the
          // thumb.
          if (!this.options.labelledBy || document.getElementById(this.options.labelledBy)) {
            ariaLabelString = this.OuterWrapper.getAttribute(ARIA_LABEL);
            if (ariaLabelString) {
              this._setAriaLabelToThumb(ariaLabelString);
            }
          }
        } else {
          // do not change the code for widget
          label = this._GetLabelElementLocal();
          // Copy any labelled-by on the <input labelled-by="id"> to the slider thumb.
          //
          if (label) {
            //
            // this id should be on the thumb: aria-labelledby =
            //

            // Set the aria-labelledby attribute of the thumb to the returned id.
            var labelId = label.attr('id');
            if (!labelId) {
              labelId = label.attr('for');
            }

            if (labelId.length > 0) {
              this._copyLabelledbyToThumb(labelId);
            }
          } else {
            //
            // Check if the <input> has aria-label=""
            //
            ariaLabelString = this.element.attr(ARIA_LABEL);
            if (ariaLabelString) {
              thumb = this._elementWrapped.find(OJ_SLIDER_THUMB);

              // Set the aria-labelledby attribute of the thumb to the returned id
              thumb.attr(ARIA_LABEL, ariaLabelString); // @HTMLUpdateOK
            }
          }
        }
      },

      /**
       * Used by widget code
       * @memberof oj.ojSlider
       * @instance
       * @private
       */
      _GetLabelElementLocal: function () {
        // If <input> has aria-labelledby set, then look for label it is referring to.
        var queryResult = this._getAriaLabelledByElementLocal();
        if (queryResult !== null && queryResult.length !== 0) {
          return queryResult;
        }

        queryResult = this._getAriaLabelForElementLocal();
        if (queryResult !== null && queryResult.length !== 0) {
          return queryResult;
        }

        return null;
      },

      /**
       * Used by widget code
       * @memberof oj.ojSlider
       * @instance
       * @private
       */
      _getAriaLabelForElementLocal: function () {
        var id;
        id = this.element.prop('id');

        if (id !== undefined) {
          var labelQuery = "label[for='" + id + "']";

          var jqLabelQuery = $(labelQuery);
          if (jqLabelQuery.length > 0) return jqLabelQuery;

          var spanQuery = "span[for='" + id + "']";

          if ($(spanQuery).length !== 0) {
            return $(spanQuery);
          }
        }
        return null;
      },

      /**
       * Used by widget code
       * @memberof oj.ojSlider
       * @instance
       * @private
       */
      _getAriaLabelledByElementLocal: function () {
        // look for a label with an id equal to the value of aria-labelledby.
        // .prop does not work for aria-labelledby. Need to use .attr to find
        // aria-labelledby.

        var ariaId = this.element.attr(ARIA_LABELLEDBY);

        // Handle direct labelling case for custom elements
        // (this is not the common case, but still is supported)
        if (ariaId === undefined && this.OuterWrapper) {
          var ariaIdDirect = this._elementWrapped.attr(ARIA_LABELLEDBY);
          if (ariaIdDirect) {
            if (document.getElementById(ariaIdDirect) !== null) {
              return $(document.getElementById(ariaIdDirect));
            }
          }
        }

        if (ariaId !== undefined) {
          var jqLabelQuery = $("label[id='" + ariaId + "']");
          if (jqLabelQuery.length > 0) return jqLabelQuery;

          var jqSpanQuery = $("span[id='" + ariaId + "']");
          if (jqSpanQuery.length > 0) {
            return jqSpanQuery;
          }
        }
        return null;
      },

      widget: function () {
        return this._elementWrapped;
      },

      /**
       * Called when the display value on the element needs to be updated. This method updates the
       * (content) element value. Widgets can override this method to update the element
       * appropriately.
       *
       * @param {string} displayValue of the new string to be displayed
       *
       * @memberof oj.ojSlider
       * @instance
       * @protected
       */
      _SetDisplayValue: function (displayValue) {
        this._sliderDisplayValue = displayValue;
      },

      /**
       * Returns the display value that is ready to be passed to the converter.
       *
       * @return {string} usually a string display value
       *
       * @memberof oj.ojSlider
       * @instance
       * @protected
       */
      _GetDisplayValue: function () {
        return this._sliderDisplayValue;
      },

      _getElementId: function () {
        if (this.OuterWrapper) {
          if (!this._elementWrapped[0].id) {
            this._elementWrapped.uniqueId();
          }
          return this._elementWrapped[0].id;
        }

        if (!this.element[0].id) {
          this.element.uniqueId();
        }
        return this.element[0].id;
      },

      //
      // Return the id of the slider thumb at index.
      //
      _getThumbId: function (index) {
        var elementId = this._getElementId();
        return elementId + '-thumb' + index;
      },

      //
      // Return the id of the slider bar value.
      //
      _getBarValueId: function () {
        var elementId = this._getElementId();
        return elementId + '-barValue';
      },

      //
      // Return the id of the slider bar.
      //
      _getBarBackgroundId: function () {
        var elementId = this._getElementId();
        return elementId + '-barBack';
      },

      //
      // Return the id of the slider bar.
      //
      _getSliderWrapperId: function () {
        var elementId = this._getElementId();
        return elementId + '-sliderWrapper';
      },

      _createThumbs: function () {
        var i;
        var thumbCount;
        var ariaMin = "aria-valuemin = '" + this._valueMin() + "' ";
        var ariaMax = "aria-valuemax = '" + this._valueMax() + "' ";
        var thumb = '';
        var thumbSpanStart = '<span ';
        var thumbClasses =
          "class='oj-slider-thumb ui-state-default' tabindex='0' role='slider'" +
          ariaMin +
          ariaMax +
          '></span>';
        var thumbs = [];

        if (this._multipleThumbs) {
          thumbCount = 2; // limit number of thumbs to 2.
        } else {
          thumbCount = 1;
        }

        //
        // Assign each thumb a unique id based on the elementId and the thumb number.
        //
        for (i = 0; i < thumbCount; i++) {
          var thumbId = "id='" + this._getThumbId(i) + "' ";
          thumb = thumbSpanStart + thumbId + thumbClasses;
          thumbs.push(thumb);
        }

        this._thumbs = $(thumbs.join('')).appendTo(this._sliderContainer); // @HTMLUpdateOK
        this._thumb = this._thumbs.eq(0);

        this._refreshThumbOptions();
      },

      //
      // reapply disabled properties to each slider thumb.
      //
      _refreshThumbOptions: function () {
        var that = this;
        var i = 0;
        this._thumbs.each(function () {
          $(this).data(OJ_SLIDER_THUMB_INDEX, i);
          i += 1;

          if (that._isVertical()) {
            $(this).attr('aria-orientation', 'vertical');
          }

          if (that.options.disabled) {
            $(this).attr('aria-disabled', 'true');
            $(this).removeAttr('tabindex');
          } else {
            $(this).removeAttr('aria-disabled');
            $(this).attr('tabindex', '0');
          }
          // To support read only, we place set title = "read only" on the thumb.
          if (that.options.readOnly) {
            $(this).attr('title', 'read only');
            // $(this).removeAttr("tabindex")
          } else {
            $(this).removeAttr('title');
          }
        });
      },

      //
      // Create a containing div to group all component generated content.
      // This is used in messaging, so that we can apply margins/padding
      // between the inline message div and the pixels that make up the slider.
      //
      _createSliderContainer: function () {
        var sliderWrapperId = this._getSliderWrapperId();
        var existingSliderWrapper = this._elementWrapped.find('#' + sliderWrapperId);

        if (existingSliderWrapper.length) existingSliderWrapper.remove();

        this._sliderContainer = $(EMPTY_DIV);
        $(this._sliderContainer).attr('id', sliderWrapperId);
        this._sliderContainer.addClass('oj-slider-container').addClass('oj-form-control-container');

        this.element.after(this._sliderContainer); // @HTMLUpdateOK

        // copy all style properties from the input tag to the enclosing
        // slider div (sliderWrapper)
        this._sliderContainer[0].style.cssText = this._styleFromInputTag;
      },

      _createBarBackground: function () {
        var barId = this._getBarBackgroundId();

        var existingBarBack = this._elementWrapped.find('#' + barId);

        if (existingBarBack.length) existingBarBack.remove();

        this._barback = $(EMPTY_DIV);

        var classes = 'oj-slider-bar';

        $(this._barback).attr('id', barId);
        this._barback.addClass(classes);

        // Place the background bar element immediately after the hidden input tab.
        this._sliderContainer.append(this._barback); // @HTMLUpdateOK

        //
        // Clicking on the bar repositions the thumb.
        //
        this._barback.on('mousedown' + this.eventNamespace, this._reposition.bind(this));
      },

      _reposition: function (event) {
        this._repositionThumb(event);
        this._mouseStop(event);

        var thumb = this._getActiveThumb();
        thumb.focus();
      },

      //
      // Set the options.value to the correct type, based on whether the slider has
      // been set to a range slider (_multipleThumbs is true), or a single-thumbed slider.
      //
      // Handle cases when the values option was never set, or when the values
      // option was incorrectly set.
      //
      _buildValueOption: function () {
        var options = this.options;
        if (this._isCustomRangeSlider()) {
          if (options.value === null) {
            this.options.value = { start: this._valueMin(), end: this._valueMax() };
          } else {
            if (options.value.start === null || options.value.start === undefined) {
              this.options.value.start = this._valueMin();
            }

            if (options.value.end === null || options.value.end === undefined) {
              this.options.value.end = this._valueMax();
            }

            this.option('value', this.options.value, {
              _context: { writeback: true, internalSet: true }
            });
          }
        } else if (options.type) {
          if (this.options.value == null) {
            //
            // If the value options was never set,
            // then initialize the value using valueMin (for a single-thumbbed slider)
            // or [valueMin, valueMax] (for a two-thumbbed slider).
            //
            if (this._multipleThumbs) {
              this.options.value = [this._valueMin(), this._valueMax()];
            } else {
              this.options.value = this._valueMin();
            }

            this.option('value', this.options.value, {
              _context: { writeback: true, internalSet: true }
            });
          } else if (this._multipleThumbs) {
            if (this.options.value.length !== 2) {
              //
              // Transform to an array of two values if the user did not supply
              // the correct # of array values.
              //
              var firstValue;
              if (this.options.value.length > 0) firstValue = this.options.value[0];
              else firstValue = this._valueMin();

              this.options.value = [firstValue, this._valueMax()];
              this.option('value', this.options.value, {
                _context: { writeback: true, internalSet: true }
              });
            }
          }
        }
      },

      _createRange: function () {
        var options = this.options;
        var classes = '';

        if (options.type) {
          //
          // Define the range (value bar) div
          //
          this._range = $(EMPTY_DIV);
          // Give the bar an id.
          $(this._range).attr('id', this._getBarValueId());

          this._sliderContainer.append(this._range); // @HTMLUpdateOK
          classes = 'oj-slider-range oj-slider-bar-value';

          //
          // Like the bar background, clicking on the bar value also repositions the thumb.
          //

          this._range.on('mousedown' + this.eventNamespace, this._reposition.bind(this));

          this._range = this._sliderContainer.find('#' + this._getBarValueId());

          var newClass = '';
          if (options.type === 'fromMin') newClass = ' oj-slider-range-min';
          else if (options.type === 'fromMax') newClass = ' oj-slider-range-max';

          this._range.addClass(classes + newClass);
        } else {
          if (this._range) {
            this._range.remove();
          }
          this._range = null;
        }
      },

      _setupTouch: function (e) {
        this._touchProxy = oj._TouchProxy.addTouchListeners(e);
      },

      _tearDownTouch: function (e) {
        oj._TouchProxy.removeTouchListeners(e);
      },
      // The resizeObserver listens for when a user resizes the window and recalculates the slider’s
      // width and grid, so that when a user resizes the window, the thumb will still snap to the latest grid, whether
      // in a form-layout or not.
      _registerResizeListener: function (element) {
        this._resizeObserver = new ResizeObserver(this._makeDraggable.bind(this));
        this._resizeObserver.observe(element);
      },

      /**
       * Setup events for slider.
       *
       * @protected
       * @memberof oj.ojSlider
       * @instance
       */
      _setupEvents: function () {
        this._registerResizeListener(this._elementWrapped[0]);
        if (this._CanSetValue()) {
          this._AddHoverable(this._elementWrapped);
        }

        this._thumbs.toArray().forEach(function (current) {
          var thumb = $(current);

          // setup keyboard events on each thumb.
          this._UnregisterChildNode(thumb);
          this._on(thumb, this._thumbEvents);

          // setup touch events on each thumb
          this._setupTouch(thumb);

          // Each thumb can be focusable.
          this._focusable({
            element: thumb,
            applyHighlight: true
          });

          // We should double-check the need for hoverable on thumbs
          // once there is a more consistent cross-component story for hoverable
          // this._hoverable(thumb);
        }, this);
      },

      // This call is necessary in order to implement popup messaging properly.

      /**
       * Returns a jquery object of the launcher element representing the content nodes (slider).
       * @protected
       * @override
       * @memberof oj.ojSlider
       */
      _GetMessagingLauncherElement: function () {
        return this._elementWrapped;
      },

      /**
       * Returns a jquery object of the elements representing the content nodes (slider thumb).
       * @protected
       * @override
       * @memberof oj.ojSlider
       */
      _GetContentElement: function () {
        return this._getActiveThumb();
      },

      //
      // Destroy the slider DOM.
      // This is called both by _destroy and during an option change.
      // During option change, we do not unwrap - since we wish to maintain any
      // divs added for messaging, such as oj-messaging-inline-container.
      //
      _destroySliderDom: function () {
        this._resizeObserver.disconnect();
        // Tear down touch events for each thumb.
        this._thumbs.toArray().forEach(function (current) {
          var thumb = $(current);
          this._tearDownTouch(thumb);
        }, this);

        this._destroyDraggable();

        if (this._range) this._range.remove();
        if (this._sliderContainer) this._sliderContainer.remove();

        if (this.OuterWrapper) {
          this._elementWrapped.removeUniqueId();
          this._RemoveHoverable(this._elementWrapped);
        } else {
          this.element.removeUniqueId();
          this._RemoveHoverable(this.element);
        }
      },

      //
      // Unwrap the slider.
      // This is only called when we completely destroy the slider (_destroy).
      //
      _unwrapSlider: function () {
        DomUtils.unwrap(this.element, this._elementWrapped);
        this.element[0].style.display = this._inputElementOriginalDisplay;
        this._RestoreAttributes(this.element);
      },

      /**
       * Override of protected base class method.
       * Method name needn't be quoted since is in externs.js.
       * @protected
       * @memberof oj.ojSlider
       * @instance
       */
      _destroy: function () {
        this._destroySliderDom();
        this._unwrapSlider();

        return this._super();
      },

      //
      // Called when the user clicks on the bar in order to reposition the thumb.
      // Setup initial positions, distance.
      // The mouse position is used for bar clicks,
      // while the thumb position is used when dragging the thumb.
      //
      // Do not process mouse events if the slider is disabled (or readOnly).
      //
      _repositionThumb: function (event) {
        var position;
        var normValue;
        var distance;
        var o = this.options;
        var index = 0;
        var that = this;

        this._closestThumb = this._thumb;

        if (o.disabled) return false;
        if (o.readOnly) return false;

        //
        // Reposition, since when we clicked on a bar.
        //
        position = { x: event.pageX, y: event.pageY };
        normValue = this._getNormValueFromMouse(position);

        distance = this._valueMax() - this._valueMin() + 1;

        if (this._multipleThumbs) {
          this._thumbs.each(function (i) {
            var thisDistance = Math.abs(normValue - that._getMultiValues(i));
            if (
              distance > thisDistance ||
              (distance === thisDistance &&
                (i === that._lastChangedValueIndex || that._getMultiValues(i) === o.min))
            ) {
              distance = thisDistance;
              this._closestThumb = $(this);
              index = i;
            }
          });
        }

        this._thumbIndex = index;
        if (!this._closestThumb) return true;

        // This call is needed to support 'click-to-reposition' the thumb
        if (!this._thumbs.hasClass('ui-state-hover')) {
          this._slide(event, index, normValue);
        }

        var thumb = this._getActiveThumb();
        thumb.addClass('oj-active').focus();
        // For mobile theming, we need to change the color of the value bar when active.
        this._range.addClass('oj-active');

        return true;
      },

      //
      // Called by draggable start.
      // Ad the oj-active classes, place thumb in focus.
      //
      _initDragging: function (event, thumb) {
        var o = this.options;

        if (o.disabled) return false;
        if (o.readOnly) return false;

        // tabbing could have added oj-focus-highlight to the thumb,
        // if so, remove the class since we are moving the thumb via mouse interaction.
        thumb.removeClass('oj-focus-highlight');
        thumb.addClass('oj-active').focus();
        // For mobile theming, we need to change the color of the value bar when active.
        this._range.addClass('oj-active');

        return true;
      },

      _mouseDragInternal: function (event, thumb) {
        // Mirror the mouse drag with a pct change.

        //
        // Raw value update.
        //
        var normValue = this._getNormValueFromThumb(thumb);
        this._slide(event, this._thumbIndex, normValue, true);

        var pct = this._getFracFromThumb(thumb) * 100;

        if (this._multipleThumbs) {
          this._setRangeMultiThumb(pct, this._thumbIndex);
        } else {
          this._setRange(pct);
        }

        return false;
      },

      _mouseStop: function (event, thumb) {
        this._thumbs.removeClass('oj-active');
        this._range.removeClass('oj-active');

        var normValue = this._getNormValueFromThumb(thumb);
        this._slide(event, this._thumbIndex, normValue);
        // _change is needed for click positioning
        this._change(event, this._thumbIndex, false);

        this._thumbIndex = null;

        return false;
      },

      _isVertical: function () {
        return this.options.orientation === 'vertical';
      },
      //
      // Adjust the fraction for bounds limits and orientation.
      //
      _getOrientationAdjustedFrac: function (frac) {
        var fracReturn = frac;
        if (fracReturn > 1) {
          fracReturn = 1;
        }
        if (fracReturn < 0) {
          fracReturn = 0;
        }
        if (this._isVertical()) {
          fracReturn = 1 - fracReturn;
        }

        return fracReturn;
      },

      //
      // Return a normalized value (trimmed to step increments)
      // based on the passed mouse coordinates.
      //
      _getNormValueFromMouse: function (position) {
        var valueTotal;
        var valueMouse;

        var fracMouse = this._getFracFromMouse(position);

        valueTotal = this._valueMax() - this._valueMin();

        if (this._isRTL() && !this._isVertical()) {
          fracMouse = 1 - fracMouse;
        }

        valueMouse = this._valueMin() + fracMouse * valueTotal;

        return this._trimAlignValue(valueMouse);
      },

      //
      // Return the fraction (between 0 and 1)
      // that represents the bar value.
      // This is based on the mouse position parameter.
      //
      _getFracFromMouse: function (position) {
        var pixelTotal;
        var pixelMouse;
        var fracMouse;

        if (!this._isVertical()) {
          pixelTotal = this._barback.width();
          pixelMouse = position.x - this._barback.offset().left;
        } else {
          pixelTotal = this._barback.height();
          pixelMouse = position.y - this._barback.offset().top;
        }

        if (pixelTotal === 0) return 1;

        fracMouse = pixelMouse / pixelTotal;
        fracMouse = this._getOrientationAdjustedFrac(fracMouse);

        return fracMouse;
      },

      // Return the active thumb
      _getActiveThumb: function () {
        if (this._multipleThumbs) {
          return $(this._thumbs[this._thumbIndex ? this._thumbIndex : 0]);
        }
        return this._thumb;
      },

      //
      // Return the fraction (between 0 and 1)
      // that represents the bar value.
      // This is based on the current position of the thumb.
      //
      _getFracFromThumb: function (thumbParam) {
        var pixelTotal;
        var pixelMouse;
        var fracThumb;

        var thumb = thumbParam;
        if (!thumbParam) {
          thumb = this._getActiveThumb();
        }

        var pos;

        if (!this._isVertical()) {
          var halfThumbWidth = thumb.outerWidth() / 2;
          pos = thumb.offset().left + halfThumbWidth;
          pixelTotal = this._barback.width();
          pixelMouse = pos - this._barback.offset().left;
        } else {
          var halfThumbHeight = thumb.outerHeight() / 2;
          pos = thumb.offset().top + halfThumbHeight;
          pixelTotal = this._barback.height();
          pixelMouse = pos - this._barback.offset().top;
        }

        if (pixelTotal === 0) {
          return 1;
        }

        fracThumb = pixelMouse / pixelTotal;

        fracThumb = this._getOrientationAdjustedFrac(fracThumb);

        return fracThumb;
      },

      _getNormValueFromThumb: function (thumb) {
        var fracThumb;
        var valueTotal;
        var valueMouse;

        fracThumb = this._getFracFromThumb(thumb);

        valueTotal = this._valueMax() - this._valueMin();

        if (this._isRTL() && !this._isVertical()) {
          fracThumb = 1 - fracThumb;
        }

        valueMouse = this._valueMin() + fracThumb * valueTotal;

        return this._trimAlignValue(valueMouse);
      },

      // Return the value for the inactive thumb.
      _getOtherThumbValue: function (index) {
        return this._getMultiValues(index ? 0 : 1);
      },

      //
      // Return the new value, limited by the value of the other thumb.
      // (We ensure that we do not go past the value of the other thumb).
      //
      _getNewThumbValueLimited: function (index, newVal, otherVal) {
        var returnVal;
        if (this._isCustomRangeSlider()) {
          if (
            this.options.value.start !== null &&
            this.options.value.end !== null &&
            ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
          ) {
            returnVal = otherVal;
          } else {
            returnVal = newVal;
          }
        } else if (
          this.options.value.length === 2 &&
          ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
        ) {
          returnVal = otherVal;
        } else {
          returnVal = newVal;
        }
        return returnVal;
      },

      _slide: function (event, index, newValParam, rawOnly) {
        var otherVal;

        if (this._multipleThumbs) {
          otherVal = this._getOtherThumbValue(index);
          var newVal = this._getNewThumbValueLimited(index, newValParam, otherVal);
          this._setMultiValue(event, index, newVal, rawOnly);
        } else {
          // This case handles a single value
          // sets slider thumb value
          this._setSingleValue(event, newValParam, rawOnly);

          if (!rawOnly) {
            if (this._inputtag) {
              this.element.val(newValParam);
            }
          }
        }
      },

      _setSingleValue: function (event, newValue, rawOnly) {
        this._newValue = this._trimAlignValue(newValue);
        this._SetRawValue(this._newValue, event);
        if (!rawOnly) {
          this.options[this._transientValueName] = this._newValue;
          this._SetValue(this._newValue, event);
          this._updateUI();
        }
      },

      _change: function (event, index, rawOnly) {
        if (this._multipleThumbs) {
          // store the last change values for creating draggable containment
          this._lastChangedValues = this._getNewValues(index, this._newMultiValue[index]);
          this._SetRawValue(this._lastChangedValues, event);
          if (!rawOnly) {
            this._SetValue(this._lastChangedValues, event);
          }
        } else {
          this._SetRawValue(this._newValue, event);
          if (!rawOnly) {
            this._SetValue(this._newValue, event);
          }
        }

        // store the last changed value index for reference when thumbs overlap
        this._lastChangedValueIndex = index;
      },

      //
      // Return options.values with the new value copied in the array
      // Used to format the values argument to SetValue (for the case of multiple thumbs)
      //
      _getNewValues: function (index, newValue) {
        var vals;
        if (this._isCustomRangeSlider()) {
          vals = {};
          vals.start = this._trimAlignValue(this.options.value.start);
          vals.end = this._trimAlignValue(this.options.value.end);
          if (index === this._thumbIndex) {
            if (index === 0) {
              vals.start = newValue;
            }
            if (index === 1) {
              vals.end = newValue;
            }
          }
        } else {
          var i;
          vals = this.options.value.slice();
          for (i = 0; i < vals.length; i++) {
            vals[i] = this._trimAlignValue(vals[i]);
          }
          // assume newValue is trim aligned
          // Assign only if it is the thumb that is actually sliding
          if (index === this._thumbIndex) {
            vals[index] = newValue;
          }
        }
        return vals;
      },

      //
      // Return the value of a single thumbbed slider.
      //
      _getSingleValue: function () {
        return this._getValueAligned();
      },

      //
      // Return the value for the specified thumb.
      //
      _getMultiValues: function (index) {
        //
        // Parameter index is supplied.
        // Return the value for the specified thumb.
        //
        return this._getValuesAligned(index);
      },

      //
      // Internal setter for slider values.
      // Sets the value for the specifed thumb.
      // (index 0 is used for a single thumb,
      // for a range slider index 0 and index 1 are used).
      //
      _setMultiValue: function (event, index, newValue, rawOnly) {
        this._newMultiValue[index] = this._trimAlignValue(newValue);
        this._change(event, index, rawOnly);
        if (!rawOnly) this._updateUI();
      },

      _setOption: function (key, value, flags) {
        var coercedValue;

        if (key === 'value') {
          if (this._isCustomRangeSlider()) {
            if (value instanceof Object) {
              this._checkStartEnd(value.start, value.end);
              if (!isNaN(value.start)) {
                this._multipleThumbs = true;
                coercedValue = value;
                var keys = Object.keys(value);
                // verify that the values are all within range.
                for (var j = 0; j < keys.length; j++) {
                  this._checkValueBounds(coercedValue[keys[j]], this._valueMin(), this._valueMax());
                }
              } else {
                //
                // Don't set multipleThumbs if the value is not a number
                // (as would be the case for an error code)
                //
                coercedValue = this._parse(key, value.start);
                // verify that the new value is within range.
                this._checkValueBounds(coercedValue, this._valueMin(), this._valueMax());
              }
            } else {
              // Only coerce values for widget syntax,
              coercedValue = { start: this._valueMin(), end: this._valueMax() };
              this.options.value = { start: this._valueMin(), end: this._valueMax() };
              // verify that the new value is within range.
              // this._checkValueBounds(coercedValue, this._valueMin(), this._valueMax());
              var coercedValueKeys = Object.keys(coercedValue);
              // verify that the values are all within range.
              for (var index = 0; index < coercedValueKeys.length; index++) {
                this._checkValueBounds(
                  coercedValue[coercedValueKeys[index]],
                  this._valueMin(),
                  this._valueMax()
                );
              }
            }
          } else if (Array.isArray(value)) {
            if (!isNaN(value[0])) {
              this._multipleThumbs = true;
              coercedValue = value;
              // verify that the array values are all within range.
              for (var i = 0; i < coercedValue.length; i++) {
                this._checkValueBounds(coercedValue[i], this._valueMin(), this._valueMax());
              }
            } else {
              //
              // Don't set multipleThumbs if the value is not a number
              // (as would be the case for an error code)
              //
              this._multipleThumbs = false;
              coercedValue = this._parse(key, value[0]);
              // verify that the new value is within range.
              this._checkValueBounds(coercedValue, this._valueMin(), this._valueMax());
            }
          } else {
            this._multipleThumbs = false;
            // Only coerce values for widget syntax,
            if (!this._IsCustomElement()) {
              coercedValue = this._parse(key, value);
            } else {
              coercedValue = value;
            }
            // verify that the new value is within range.
            this._checkValueBounds(coercedValue, this._valueMin(), this._valueMax());
          }
        } else if (key === 'max' || key === 'min') {
          // Only coerce values for widget syntax,
          // since the framework handles this for custom elements.
          if (!this._IsCustomElement()) {
            coercedValue = this._parse(key, value);
          } else {
            coercedValue = value;
          }

          //
          // Note that coerce the value to be within the
          // min and max when we option change the min or max.
          //

          if (key === 'min') {
            this._checkMinMax(coercedValue, this._valueMax());
            // Coerce any out of bounds "value" attributes to be within the min bounds
            if (!this._multipleThumbs) {
              if (this._getSingleValue() < coercedValue) {
                this._super('value', coercedValue, flags);
              }
            } else {
              if (this._getMultiValues(0) < coercedValue) {
                if (this._isCustomRangeSlider()) {
                  this._super('value', { start: coercedValue, end: this._getMultiValues(1) }, flags);
                } else {
                  this._super('value', [coercedValue, this._getMultiValues(1)], flags);
                }
              }
              if (this._getMultiValues(1) < coercedValue) {
                if (this._isCustomRangeSlider()) {
                  this._super('value', { start: this._getMultiValues(0), end: coercedValue }, flags);
                } else {
                  this._super('value', [this._getMultiValues(0), coercedValue], flags);
                }
              }
            }
          } else if (key === 'max') {
            this._checkMinMax(this._valueMin(), coercedValue);
            // Coerce any out of bounds "value" attributes to be within the max bounds
            if (!this._multipleThumbs) {
              if (this._getSingleValue() > coercedValue) {
                this._super('value', coercedValue, flags);
              }
            } else {
              if (this._getMultiValues(0) > coercedValue) {
                if (this._isCustomRangeSlider()) {
                  this._super('value', { start: coercedValue, end: this._getMultiValues(1) }, flags);
                } else {
                  this._super('value', [coercedValue, this._getMultiValues(1)], flags);
                }
              }
              if (this._getMultiValues(1) > coercedValue) {
                if (this._isCustomRangeSlider()) {
                  this._super('value', { start: this._getMultiValues(0), end: coercedValue }, flags);
                } else {
                  this._super('value', [this._getMultiValues(0), coercedValue], flags);
                }
              }
            }
          }
        } else if (key === 'step') {
          coercedValue = this._parseStep(value);
        } else {
          coercedValue = value;
        }

        this._super(key, coercedValue, flags);
        // when a dom element supports readonly, use that, and not aria-readonly.
        // having both is an error

        // Note - for now, readOnly is private.
        if (key === 'readOnly') {
          this.options.readonly = coercedValue;
        }
        if (key === 'disabled') {
          this.options.disabled = coercedValue;
        }

        switch (key) {
          case 'disabled':
            this._refreshThumbOptions();
            // disable the dragging if disabled is true.
            if (this.options.disabled) {
              this._disableDraggable();
            } else {
              this._makeDraggable();
            }
            break;

          case 'value':
            this._updateUI();
            this._makeDraggable();
            break;

          case 'min':
          case 'max':
            this._calculateNewMax();
            this._updateUI();
            this._makeDraggable();
            break;

          case 'orientation':
            this._setOrientationStyles();
            this._reCreate();
            break;
          case 'readonly':
          case 'step':
          case 'type':
            this._reCreate();
            break;
          case 'labelledBy':
            this._setAriaInfo();
            break;
          default:
            break;
        }
      },

      //
      // Recreate the slider.
      // Destroy's everything except the wrapper.
      // Called after optionChange.
      //
      _reCreate: function () {
        this._destroySliderDom();
        this._componentSetup();
        if (this.OuterWrapper) {
          // When we programmatically recreate a custom element slider
          // (in order to implemement option change), we assert oj-complete.
          this._elementWrapped.addClass('oj-complete');
        }
        this._AfterCreate();
      },

      // internal value getter
      // _getValueAligned() returns value trimmed by min and max, aligned by step
      _getValueAligned: function () {
        var val = this.options.value;
        val = this._trimAlignValue(val);

        return val;
      },

      _isCustomRangeSlider: function () {
        if (this._IsCustomElement()) {
          var rootElem = this.element[0].parentNode;
          if (rootElem.tagName === 'OJ-RANGE-SLIDER') {
            return true;
          }
        }
        return false;
      },

      //
      // Internal values getter
      //
      // _getValuesAligned() returns array of values trimmed by min and max, aligned by step
      // _getValuesAligned( index ) returns single value trimmed by min and max, aligned by step
      //
      _getValuesAligned: function (index) {
        var result = null;
        if (this._isCustomRangeSlider()) {
          var val;
          if (index === 0) {
            if (this.options.value.start !== undefined && this.options.value.start !== null) {
              val = this.options.value.start;
            } else {
              val = this._valueMin();
            }
          } else if (this.options.value.end !== undefined && this.options.value.end !== null) {
            val = this.options.value.end;
          } else {
            val = this._valueMax();
          }
          result = this._trimAlignValue(val);
        } else {
          result = this._trimAlignValue(this.options.value[index]);
        }
        return result;
      },

      //
      // Return the step-aligned value that val is closest to, between (inclusive) min and max
      //
      _trimAlignValue: function (val) {
        if (val <= this._valueMin()) {
          return this._valueMin();
        }
        if (val >= this._valueMax()) {
          return this._valueMax();
        }
        var step = this.options.step > 0 ? this.options.step : 1;
        var valModStep = (val - this._valueMin()) % step;
        var alignValue = val - valModStep;

        if (Math.abs(valModStep) * 2 >= step) {
          alignValue += valModStep > 0 ? step : -step;
        }

        // Since JavaScript has problems with large floats, round
        // the final value to 5 digits after the decimal point (see #4124)
        return parseFloat(alignValue.toFixed(5));
      },

      _calculateNewMax: function () {
        var min = this._valueMin();
        if (((this.options.max - min) / this.options.step) % 1 !== 0) {
          var remainder = (this.options.max - min) % this.options.step;
          this.max = this.options.max - remainder + this.options.step;
        } else {
          this.max = this.options.max;
        }
      },

      _valueMin: function () {
        return this.options.min;
      },

      _valueMax: function () {
        return this.max;
      },

      //
      // Calculate the grid size passed to draggable.
      // This implements the drag to step increments.
      // For a horizontal grid, we would return an array of [pixelInterval, 1],
      // while a vertical grid returns [1, pixelInterval].
      //
      _getGrid: function () {
        var numIntervals;
        if (this.options.step > 0) {
          numIntervals = (this._valueMax() - this._valueMin()) / this.options.step;
        } else {
          numIntervals = 100; // this case should not occur.
        }

        var pixelTotal;

        if (!this._isVertical()) {
          pixelTotal = this._barback.width();
        } else {
          pixelTotal = this._barback.height();
        }

        var pixelInterval = pixelTotal / numIntervals;

        if (pixelInterval < 1) pixelInterval = 1;

        if (!this._isVertical()) {
          return [pixelInterval, 1];
        }
        return [1, pixelInterval];
      },

      _getThumbsValueFrac: function (index) {
        return (
          (this._getMultiValues(index) - this._valueMin()) / (this._valueMax() - this._valueMin())
        );
        // Note - (max - min) is checked in options to make sure that
        // it is non-zero and positive
        // Note - we always use aligned values.
      },

      //
      // Update the UI, reflecting the value.
      //
      _updateUI: function () {
        var valPercent;
        var value;
        var valueMin;
        var valueMax;

        var startThumb;
        var endThumb;

        //
        // Multiple thumbs case.
        //
        if (this._multipleThumbs) {
          this._thumbs.toArray().forEach(function (current, i) {
            var thumb = $(current);
            valPercent = this._getThumbsValueFrac(i) * 100;

            if (this._isRTL() && !this._isVertical()) {
              valPercent = 100 - valPercent;
            }

            if (!this._isVertical()) {
              thumb.css({ left: valPercent + '%' });
            } else {
              thumb.css({ top: 100 - valPercent + '%' });
            }

            if (i === 0) {
              startThumb = thumb;
              // if the min thumb is at the max, set its zindex to 1
              if (valPercent === 100) {
                thumb.css({ zIndex: 1 });
              } else {
                thumb.css({ zIndex: '' });
              }
            } else {
              endThumb = thumb;
            }

            if (!thumb.hasClass('oj-active')) {
              thumb.attr('aria-valuenow', this._getMultiValues(i));
              thumb.attr('aria-valuemin', valueMin);
              thumb.attr('aria-valuemax', valueMax);
            }
            this._setRangeMultiThumb(valPercent, i);
          }, this);
          if (startThumb.hasClass('oj-focus')) {
            startThumb.css({ zIndex: 1 });
            endThumb.css({ zIndex: '' });
          }

          if (endThumb.hasClass('oj-focus')) {
            startThumb.css({ zIndex: '' });
            endThumb.css({ zIndex: 1 });
          }
        } else {
          //
          // Scalar value (single thumb)
          //

          // We always want an aligned value here.
          value = this._getValueAligned();

          valueMin = this._valueMin();
          valueMax = this._valueMax();
          valPercent = valueMax !== valueMin ? ((value - valueMin) / (valueMax - valueMin)) * 100 : 0;

          if (this._isRTL() && !this._isVertical()) valPercent = 100 - valPercent;

          if (!this._isVertical()) {
            this._thumb.css({ left: valPercent + '%' });
          } else {
            this._thumb.css({ top: 100 - valPercent + '%' });
          }

          //
          // note - we don't want to continuously update aria values,
          // otherwise it causes unwanted screen reader chatter.
          // see .
          //
          if (!$(this._thumb).hasClass('oj-active')) {
            $(this._thumb).attr('aria-valuenow', value);
            $(this._thumb).attr('aria-valuemin', valueMin);
            $(this._thumb).attr('aria-valuemax', valueMax);
          }
          this._setRange(valPercent);
        }
      },

      // Set the range (bar value)
      _setRange: function (val) {
        var oRange = this.options.type;

        if (!this._isVertical()) {
          if (!this._isRTL()) {
            if (oRange === 'fromMin') {
              this._range.css({ width: val + '%' });
            }
            if (oRange === 'fromMax') {
              this._range.css({ width: 100 - val + '%' });
            }
          } else {
            if (oRange === 'fromMin') {
              this._range.css({ width: 100 - val + '%' });
            }
            if (oRange === 'fromMax') {
              this._range.css({ width: val + '%' });
            }
          }
        } else {
          if (oRange === 'fromMin') {
            this._range.css({ height: val + '%' });
          }
          if (oRange === 'fromMax') {
            this._range.css({ height: 100 - val + '%' });
          }
        }
      },

      //
      // set the range for a multi-thumb (range) slider
      //
      _setRangeMultiThumb: function (val, index) {
        var id = this._range.attr('id');

        if (index === 0) {
          var thumb1Pct = this._getThumbsValueFrac(1) * 100;

          switch (this.options.type) {
            case 'fromMin':
              if (!this._isVertical()) {
                this._range.css({ width: val + '%' });
              } else {
                this._range.css({ height: val + '%' });
              }
              break;

            case 'range':
              if (!this._isVertical()) {
                if (!this._isRTL()) {
                  this._range.css({ left: val + '%' });
                  this._range.css({ width: thumb1Pct - val + '%' });
                } else {
                  this._range.css({ left: 100 - thumb1Pct + '%' });
                  this._range.css({ width: thumb1Pct - (100 - val) + '%' });
                }
              } else {
                this._range.css({ top: 100 - thumb1Pct + '%' });
                this._range.css({ height: thumb1Pct - val + '%' });
              }
              break;

            default:
              break;
          }
        } else {
          var thumb0Pct = this._getThumbsValueFrac(0) * 100;

          switch (this.options.type) {
            case 'fromMax':
              if (!this._isVertical()) {
                this._range.css({ width: 100 - val + '%' });
              } else {
                this._range.css({ height: 100 - val + '%' });
              }
              break;

            case 'range':
              if (!this._isVertical()) {
                if (!this._isRTL()) {
                  if (document.getElementById(id)) {
                    var barLeft = parseInt(document.getElementById(id).style.left, 10);
                    this._range.css({ width: val - barLeft + '%' });
                  }
                } else if (document.getElementById(id)) {
                  this._range.css({ left: val + '%' });
                  this._range.css({ width: -val + 100 - thumb0Pct + '%' });
                }
              } else if (document.getElementById(id)) {
                this._range.css({ top: 100 - val + '%' });
                this._range.css({ height: val - thumb0Pct + '%' });
              }

              break;
            default:
              break;
          }
        }
      },

      _thumbEvents: {
        keydown: function (event) {
          var curVal;
          var newVal;
          var step;
          var tempVal;
          var index = $(event.target).data(OJ_SLIDER_THUMB_INDEX);

          this._thumbIndex = index;

          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
            case $.ui.keyCode.END:
            case $.ui.keyCode.PAGE_UP:
            case $.ui.keyCode.PAGE_DOWN:
            case $.ui.keyCode.UP:
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
            case $.ui.keyCode.LEFT:
              event.preventDefault();
              //
              // Note - while tabbing into the thumb will retain focus,
              // when clicking on the thumb we do not need to call focus()
              // (per Max's review)
              //
              $(event.target).addClass('oj-active');
              break;
            default:
              break;
          }

          step = this.options.step;

          if (this._multipleThumbs) {
            newVal = this._getMultiValues(index);
          } else {
            newVal = this._getSingleValue();
          }
          curVal = newVal;

          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
              newVal = this._valueMin();
              break;
            case $.ui.keyCode.END:
              newVal = this._valueMax();
              break;
            case $.ui.keyCode.PAGE_UP:
              newVal = this._trimAlignValue(
                curVal + (this._valueMax() - this._valueMin()) / this._numPages
              );
              break;
            case $.ui.keyCode.PAGE_DOWN:
              newVal = this._trimAlignValue(
                curVal - (this._valueMax() - this._valueMin()) / this._numPages
              );
              break;

            case $.ui.keyCode.UP:
              // upArrow always increments the value
              if (curVal === this._valueMax()) return;
              tempVal = curVal + step;
              newVal = this._trimAlignValue(tempVal);
              break;

            case $.ui.keyCode.RIGHT:
              if (!this._isRTL() || this._isVertical()) {
                if (curVal === this._valueMax()) return;
                tempVal = curVal + step;
              } else {
                if (curVal === this._valueMin()) return;
                tempVal = curVal - step;
              }

              newVal = this._trimAlignValue(tempVal);
              break;

            case $.ui.keyCode.DOWN:
              // Down arrow always decrements the value.
              if (curVal === this._valueMin()) return;
              tempVal = curVal - step;
              newVal = this._trimAlignValue(tempVal);

              break;

            case $.ui.keyCode.LEFT:
              if (!this._isRTL() || this._isVertical()) {
                if (curVal === this._valueMin()) return;
                tempVal = curVal - step;
              } else {
                if (curVal === this._valueMax()) return;
                tempVal = curVal + step;
              }

              newVal = this._trimAlignValue(tempVal);
              break;
            default:
              break;
          }

          this._slide(event, index, newVal);
        },

        keyup: function (event) {
          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
            case $.ui.keyCode.END:
            case $.ui.keyCode.PAGE_UP:
            case $.ui.keyCode.PAGE_DOWN:
            case $.ui.keyCode.UP:
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
            case $.ui.keyCode.LEFT:
              var index = $(event.target).data(OJ_SLIDER_THUMB_INDEX);
              this._thumbIndex = index;

              this._change(event, index, false);

              $(event.target).removeClass('oj-active');
              this._updateUI(true);

              this._thumbIndex = null;
              break;
            default:
              break;
          }
        }
      },

      // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

      // ***** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) ******

      /**
       * Called at component create time primarily to initialize options, often using DOM values.
       * This method is called before _ComponentCreate is called, so components that override this
       * method should be aware that the component has not been rendered yet. The element DOM is
       * available and can be relied on to retrieve any default values. <p>
       * @param {!Object} originalDefaults - original default options defined on the widget and
       * its ancestors.
       * @param {?Object} constructorOptions - options passed into the widget constructor
       *
       * @memberof oj.ojSlider
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        var opts = this.options;
        var self = this;

        this._superApply(arguments);
        var props = [
          { attribute: 'disabled', validateOption: true },
          //                 {attribute: "placeholder"},
          { attribute: 'value' },

          //
          // Once slider supports read-only, uncomment the following line.
          // {attribute: "readonly", option: "readOnly", validateOption: true},
          //

          { attribute: 'title' },
          { attribute: 'min' },
          { attribute: 'max' },
          { attribute: 'step' }
        ];

        if (!this._IsCustomElement()) {
          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(
            props,
            constructorOptions,
            this,
            // post-process callback
            function (_initializedOptions) {
              var initializedOptions = _initializedOptions;
              // coerce regardless of where the option value came from - dom/constructor
              var toParse = ['value', 'step', 'min', 'max'];

              for (var i = 0; i < toParse.length; i++) {
                var opt = toParse[i];
                var value = opt in initializedOptions ? initializedOptions[opt] : opts[opt];
                if (value != null) {
                  if (opt === 'step') {
                    initializedOptions[opt] = self._parseStep(value);
                  } else if (opt === 'min' || opt === 'max') {
                    initializedOptions[opt] = self._parse(opt, value);
                  } else if (opt === 'value') {
                    if (Array.isArray(value)) {
                      initializedOptions[opt] = value;
                    } else {
                      initializedOptions[opt] = self._parse(opt, value);
                    }
                  }
                }
              }
            }
          );
          if (opts.value === undefined) {
            throw new Error(this.getTranslatedString('noValue'));
          }
        }
        if (this._isCustomRangeSlider()) {
          this._checkStartEnd(opts.value.start, opts.value.end);
        }
        this._checkMinMax(opts.min, opts.max);

        // Make sure value is within min and max
        if (Array.isArray(opts.value)) {
          for (var index = 0; index < opts.value.length; index += 1) {
            this._checkValueBounds(opts.value[index], opts.min, opts.max);
          }
        } else {
          this._checkValueBounds(opts.value, opts.min, opts.max);
        }
      },

      // function that will throw an error if the value is not between min and max
      _checkValueBounds: function (value, min, max) {
        if (min != null) {
          if (value < min) {
            throw new Error(this.getTranslatedString('valueRange'));
          }
        }
        if (max != null) {
          if (value > max) {
            throw new Error(this.getTranslatedString('valueRange'));
          }
        }
      },

      // throw an error if min >= max
      _checkMinMax: function (min, max) {
        if (min != null && max != null) {
          if (min >= max) {
            throw new Error(this.getTranslatedString('maxMin'));
          }
        }
      },

      // throw an error if value.start > value.end
      _checkStartEnd: function (start, end) {
        if (start != null && end != null) {
          if (start > end) {
            throw new Error(this.getTranslatedString('startEnd'));
          }
        }
      },

      // @inheritdoc
      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element ? this.element[0] : null;
        }

        var subId = locator.subId;

        if (subId === 'oj-slider-thumb-0') {
          return this.widget().find(OJ_SLIDER_THUMB)[0];
        } else if (subId === 'oj-slider-thumb-1') {
          return this.widget().find(OJ_SLIDER_THUMB)[1];
        } else if (subId === OJ_SLIDER_BAR) {
          return this.widget().find('.' + subId)[0];
        } else if (subId === OJ_SLIDER_BAR_VALUE) {
          return this.widget().find('.' + subId)[0];
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      // @inheritdoc
      getSubIdByNode: function (node) {
        if (node != null) {
          if (node.id === this._getThumbId(0) && $(node).hasClass('oj-slider-thumb')) {
            return { subId: 'oj-slider-thumb-0' };
          } else if (node.id === this._getThumbId(1) && $(node).hasClass('oj-slider-thumb')) {
            return { subId: 'oj-slider-thumb-1' };
          } else if ($(node).hasClass(OJ_SLIDER_BAR)) {
            return { subId: OJ_SLIDER_BAR };
          } else if ($(node).hasClass(OJ_SLIDER_BAR_VALUE)) {
            return { subId: OJ_SLIDER_BAR_VALUE };
          }
        }

        return null;
      },

      // *********** END WIDGET FACTORY METHODS **********

      /**
       * Returns the default styleclass for the component.
       *
       * @return {string}
       * @memberof oj.ojSlider
       * @override
       * @protected
       */
      _GetDefaultStyleClass: function () {
        return 'oj-slider';
      },

      // The user can clear out min/max by setting the option to null, so we
      // do not coerce null.
      /**
       * @param {string} option name of the option. this will show up in the error if thrown
       * @param val value to parse
       * @throws {Error} if option value is invalid
       * @private
       */
      _parse: function (option, val) {
        var returnValue;
        if (val !== null) {
          returnValue = +val;
        } else {
          returnValue = val;
        }

        if (isNaN(returnValue)) {
          throw new Error(this.getTranslatedString('optionNum', { option: option }));
        }

        return returnValue;
      },
      /**
       * parse the step's value
       * We are following the behavior of HTML-5 the best we can. According
       * to the spec, it says step must be a number greater than 0.
       * Chrome defaults it to 1 if it is not.
       * @throws {Error} if option value is invalid
       * @private
       */
      _parseStep: function (val) {
        var defaultStep = 1;
        var parsedStep;
        if (val === null) {
          return defaultStep;
        }
        parsedStep = this._parse('step', val);
        if (parsedStep <= 0) {
          // throw an exception
          throw new Error(this.getTranslatedString('invalidStep'));
        }
        // DEFAULT to 1 if it isn't > 0
        if (parsedStep === null || parsedStep <= 0) {
          parsedStep = defaultStep;
        }
        return parsedStep;
      },

      // ///////////////////////////////////////////////////////////////////////////////////////
      //
      // Draggable - used to implement slider thumb dragging
      //
      // JQueryUI draggable is used to implement the dragging of slider thumbs.
      // Several draggable options are used:
      //
      // - Axis constaint
      //   The thumb is constrained to movement along the x-axis (for horizontal sliders)
      //   or movement along the y-axis (for vertical siders)
      //
      // - Range constraints
      //   The thumb is constrained to ranges along the axis using the draggable constraint
      //   option.
      //
      // - Step
      //   The granularity of movement is constrained to the step size using the grid
      //   option.
      //
      // ///////////////////////////////////////////////////////////////////////////////////////

      // return the endpoint of the bar
      _getEndInterval: function () {
        return this._barback.offset().left + this._barback.width();
      },

      // return the startpoint of the bar
      _getStartInterval: function () {
        return this._barback.offset().left;
      },

      //
      // Set up the draggable with the context, thumb, and containment parameters.
      // Use the axis method to ensure only horizontal or vertical movement.
      //
      _callDraggable: function (thumbParam) {
        var g = this._getGrid();
        var cachedStyle = thumbParam[0].style;

        var axisValue;
        if (!this._isVertical()) axisValue = 'x';
        else axisValue = 'y';

        var that = this;

        thumbParam.draggable({
          axis: axisValue,
          // grid: [8.8,1],
          grid: g,
          disabled: false,
          start: function (event) {
            //
            // Set current thumb
            //

            if (thumbParam[0] === $(that._thumbs)[0]) {
              that._thumbIndex = 0;
            } else if (thumbParam[0] === $(that._thumbs)[1]) {
              that._thumbIndex = 1;
            }

            that._initDragging(event, thumbParam);
          },

          drag: function (event, ui) {
            //
            // Compensate for a draggable bug.
            // The bug causes the thumb to drift off axis (for some .css thumb sizes).
            // The workaround address the problem by:
            //   When the thumb travels along the x-axis (horizontal slider),
            //   null out modifications made to top.
            // Handle this issue similarly for vertical sliders.
            //
            var pos = ui.position;

            if (!that._isVertical()) {
              cachedStyle.top = '';
              pos.top = '';
            } else {
              cachedStyle.left = '';
              pos.left = '';
            }

            that._mouseDragInternal(event, thumbParam);

            //
            // Enforce constraints (don't allow sliding past the end)
            //
            if (!that._isVertical()) {
              if (pos.left < 0) {
                pos.left = 0;
              }
              if (pos.left > that._barback.width()) {
                pos.left = that._barback.width();
              }
            } else {
              if (pos.top < 0) {
                pos.top = 0;
              }
              if (pos.top > that._barback.height()) {
                pos.top = that._barback.height();
              }
            }

            //
            // For range sliders, ensure that thumbs do not cross.
            //
            if (that._multipleThumbs) {
              var otherThumb;

              if (that._thumbIndex === 0) {
                otherThumb = $(that._thumbs[1]);
              } else {
                otherThumb = $(that._thumbs[0]);
              }

              //
              // parentLeft ensures that the offsets are calculated properly
              // for a slider embedded in a repositioned container (popup or dialog)
              //
              var pos2;
              if (!that._isVertical()) {
                var halfThumbWidth = thumbParam.outerWidth() / 2;
                var parentLeft = that._barback.offsetParent().offset().left;
                pos2 = otherThumb.offset().left + halfThumbWidth - parentLeft;
              } else {
                var halfThumbHeight = thumbParam.outerHeight() / 2;
                var parentTop = that._barback.offsetParent().offset().top;
                pos2 = otherThumb.offset().top + halfThumbHeight - parentTop;
              }

              if (that._thumbIndex === 0) {
                if (!that._isVertical()) {
                  if (!that._isRTL()) {
                    if (pos.left > pos2) pos.left = pos2;
                  } else if (pos.left < pos2) pos.left = pos2;
                } else if (pos.top < pos2) pos.top = pos2;
              } else if (!that._isVertical()) {
                if (!that._isRTL()) {
                  if (pos.left < pos2) pos.left = pos2;
                } else if (pos.left > pos2) pos.left = pos2;
              } else if (pos.top > pos2) pos.top = pos2;
            }
          },

          stop: function (event) {
            //
            // compensate for a firefox draggable bug.
            // without this code, thumbs with larger active sizes become oval on stop.
            //
            this.style.width = '';
            this.style.height = '';

            that._mouseStop(event, thumbParam);
          }
        });
      },

      //
      // Setup the draggable for each of the thumbs.
      //
      _makeDraggable: function () {
        // Do not allow dragging on a disabled thumb.
        if (this.options.disabled) return;

        if (this._multipleThumbs) {
          this._thumbs.toArray().forEach(function (current) {
            var thumb = $(current);
            this._callDraggable(thumb);
          }, this);
        } else {
          this._callDraggable(this._thumb);
        }
      },

      //
      // Call this if we change option to disabled.
      //
      _disableDraggable: function () {
        if (this._multipleThumbs) {
          this._thumbs.toArray().forEach(function (current) {
            var thumb = $(current);
            if (thumb.is(UI_DRAGGABLE)) {
              thumb.draggable('disable');
            }
          }, this);
        } else if (this._thumb.is(UI_DRAGGABLE)) {
          this._thumb.draggable('disable');
        }
      },

      //
      // Destroy the draggable that was instantiated on each slider thumb.
      //
      _destroyDraggable: function () {
        if (this._multipleThumbs) {
          this._thumbs.toArray().forEach(function (current) {
            var thumb = $(current);
            if (thumb.is(UI_DRAGGABLE)) {
              thumb.draggable('destroy');
            }
          }, this);
        } else if (this._thumb.is(UI_DRAGGABLE)) {
          this._thumb.draggable('destroy');
        }
      }

      // ///////////////////////////////////////////////////////////////////////////////////////
      // Draggable - end
      // ///////////////////////////////////////////////////////////////////////////////////////
    });
  })();

});


define('ojs/ojswitch',['ojs/ojcore', 'ojs/ojeditablevalue', 'ojs/ojcore-base', 'jquery', 'ojs/ojdomutils', 'ojs/ojfocusutils'], function (ojcore, ojeditablevalue, oj, $, DomUtils, FocusUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;

  (function () {
var __oj_switch_metadata = 
{
  "properties": {
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "converterHint": {
          "type": "Array<string>|string"
        },
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        },
        "validatorHint": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "switchOff": {
          "type": "string"
        },
        "switchOn": {
          "type": "string"
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "boolean",
      "writeback": true,
      "value": false
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {}
  },
  "extension": {}
};
    __oj_switch_metadata.extension._WIDGET_NAME = 'ojSwitch';
    __oj_switch_metadata.extension._INNER_ELEM = 'input';
    __oj_switch_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    __oj_switch_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['tabindex'];
    oj.CustomElementBridge.register('oj-switch', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_switch_metadata, {
        properties: {
          readonly: {
            binding: { consume: { name: 'readonly' } }
          },
          userAssistanceDensity: {
            binding: { consume: { name: 'userAssistanceDensity' } }
          },
          labelEdge: {
            binding: { consume: { name: 'labelEdge' } }
          }
        }
      })
    });
  })();

  const OJ_SWITCH_THUMB = 'oj-switch-thumb';
  const OJ_SWITCH_TRACK = 'oj-switch-track';
  const ARIA_LABEL = 'aria-label';
  const ARIA_DISABLED = 'aria-disabled';

  (function () {
    /*!
     * JET Switch @VERSION
     */
    /**
     * @ojcomponent oj.ojSwitch
     * @ojdisplayname Switch
     * @augments oj.editableValue
     * @ojimportmembers oj.ojDisplayOptions
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojSwitch extends editableValue<boolean, ojSwitchSettableProperties>"
     *               },
     *               {
     *                target: "Type",
     *                value: "ojSwitchSettableProperties extends editableValueSettableProperties<boolean>",
     *                for: "SettableProperties"
     *               }
     *              ]
     * @since 0.7.0
     * @ojshortdesc A switch toggles between two mutually exclusive states — on and off.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "disabled", "readonly"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 6
     * @ojvbmincolumns 2
     *
     * @ojoracleicon 'oj-ux-ico-switch-on'
     * @ojuxspecs ['switch']
     *
     * @classdesc
     * <p>
     * The oj-switch component enhances <code class="prettyprint">input</code>
     * element and manages the selection of Boolean values.
     * </p>
     * {@ojinclude "name":"validationAndMessagingDoc"}
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * The component is accessible; it sets and maintains the appropriate aria- attributes,
     * like aria-checked and aria-disabled.
     * </p>
     * <p>
     * {@ojinclude "name":"accessibilityLabelEditableValue"}
     * {@ojinclude "name":"accessibilityDisabledEditableValue"}
     * </p>
     *
     * <h3 id="state-section">
     *   Setting the Value Attribute
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
     * </h3>
     * <p>The value attribute should be Boolean. If the value attribute is undefined, then it is
     * <code class="prettyprint">false</code>.
     * </p>
     *
     * @example <caption>Initialize the switch with no attributes specified:</caption>
     * &lt;oj-switch>&lt;/oj-switch>
     *
     * @example <caption>Initialize the switch with some attributes specified:</caption>
     * &lt;oj-switch value=true disabled=false>&lt;/oj-switch>
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Switch Thumb</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Toggle switch value</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojSwitch
     */
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Switch Thumb</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Toggle switch value</td>
     *     </tr>
     *     <tr>
     *       <td>Switch Thumb</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the thumb. If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>Disabled items can not receive keyboard focus.
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojSwitch
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------
    /**
     * <p>Sub-ID for the switch's track.</p>
     *
     * @ojsubid oj-switch-track
     * @memberof oj.ojSwitch
     *
     * @example <caption>Get the node for the track:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-switch-track'});
     */

    /**
     * <p>Sub-ID for the switch's thumb.</p>
     *
     * @ojsubid oj-switch-thumb
     * @memberof oj.ojSwitch
     *
     * @example <caption>Get the node for the thumb:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-switch-thumb'});
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------
    // ---------------- oj-switch --------------
    /**
     * Top level switch class.
     * @ojstyleclass oj-switch
     * @ojdisplayname Switch
     * @memberof oj.ojSwitch
     */
    // ---------------- oj-focus-highlight --------------
    /**
     * Under normal circumstances this class is applied automatically.
     * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojSwitch
     * @ojtsexample
     * &lt;oj-switch class="oj-focus-highlight">
     *   &lt;!-- Content -->
     * &lt;/oj-switch>
     */
    /**
     * @ojstylevariableset oj-switch-css-set1
     * @ojstylevariable oj-switch-track-height {description: "Switch track height", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-switch-track-width {description: "Switch track width", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-switch-track-border-radius {description: "Switch track border radius", formats: ["length","percentage"], help: "#css-variables"}
     * @ojstylevariable oj-switch-thumb-to-track-horizontal-margin {description: "Switch thumb to track horizontal margin", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-switch-thumb-height {description: "Switch thumb height", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-switch-thumb-width {description: "Switch thumb width", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-switch-thumb-border-radius {description: "Switch thumb border radius", formats: ["length","percentage"], help: "#css-variables"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when enabled
     * @ojstylevariableset oj-switch-css-set2
     * @ojdisplayname Enabled
     * @ojstylevariable oj-switch-track-bg-color {description: "Switch track background color when enabled", formats: ["color"], help: "#oj-switch-css-set2"}
     * @ojstylevariable oj-switch-track-border-color {description: "Switch track border color when enabled", formats: ["color"], help: "#oj-switch-css-set2"}
     * @ojstylevariable oj-switch-thumb-bg-color {description: "Switch thumb background color when enabled", formats: ["color"], help: "#oj-switch-css-set2"}
     * @ojstylevariable oj-switch-thumb-border-color {description: "Switch thumb border color when enabled", formats: ["color"], help: "#oj-switch-css-set2"}
     * @ojstylevariable oj-switch-thumb-box-shadow {description: "Switch thumb box shadow when enabled", help: "#oj-switch-css-set2"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when hovered
     * @ojstylevariableset oj-switch-css-set3
     * @ojdisplayname Hovered
     * @ojstylevariable oj-switch-track-bg-color-hover {description: "Switch track background color when hovered", formats: ["color"], help: "#oj-switch-css-set3"}
     * @ojstylevariable oj-switch-track-border-color-hover {description: "Switch track border color when hovered",formats: ["color"], help: "#oj-switch-css-set3"}
     * @ojstylevariable oj-switch-track-border-color-hover {description: "Switch track border color when hovered",formats: ["color"], help: "#oj-switch-css-set3"}
     * @ojstylevariable oj-switch-thumb-bg-color-hover {description: "Switch thumb background color when hovered", formats: ["color"], help: "#oj-switch-css-set3"}
     * @ojstylevariable oj-switch-thumb-border-color-hover {description: "Switch thumb border color when hovered",formats: ["color"], help: "#oj-switch-css-set3"}
     * @ojstylevariable oj-switch-thumb-box-shadow-hover {description: "Switch thumb box shadow when hovered", help: "#oj-switch-css-set3"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when selected and hovered
     * @ojstylevariableset oj-switch-css-set4
     * @ojdisplayname Selected hovered
     * @ojstylevariable oj-switch-track-bg-color-selected-hover {description: "Switch track background color when selected and hovered", formats: ["color"],
     *  help: "#oj-switch-css-set4"}
     * @ojstylevariable oj-switch-track-border-color-selected-hover {description: "Switch track border color when selected and hovered", formats: ["color"],
     *  help: "#oj-switch-css-set4"}
     * @ojstylevariable oj-switch-thumb-bg-color-selected-hover {description: "Switch thumb background color when selected and hovered", formats: ["color"],
     *  help: "#oj-switch-css-set4"}
     * @ojstylevariable oj-switch-thumb-border-color-selected-hover {description: "Switch thumb border color when selected and hovered", formats: ["color"],
     *  help: "#oj-switch-css-set4"}
     * @ojstylevariable oj-switch-thumb-box-shadow-selected-hover {description: "Switch thumb box shadow when selected and hovered", help: "#oj-switch-css-set4"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when active
     * @ojstylevariableset oj-switch-css-set5
     * @ojdisplayname Active
     * @ojstylevariable oj-switch-track-bg-color-active {description: "Switch track background color when active", formats: ["color"], help: "#oj-switch-css-set5"}
     * @ojstylevariable oj-switch-track-border-color-active {description: "Switch track border color when active",formats: ["color"], help: "#oj-switch-css-set5"}
     * @ojstylevariable oj-switch-thumb-bg-color-active {description: "Switch thumb background color when active", formats: ["color"], help: "#oj-switch-css-set5"}
     * @ojstylevariable oj-switch-thumb-border-color-active {description: "Switch thumb border color when active",formats: ["color"], help: "#oj-switch-css-set5"}
     * @ojstylevariable oj-switch-thumb-box-shadow-active {description: "Switch thumb box shadow when active", help: "#oj-switch-css-set5"}
     * @ojstylevariable oj-switch-thumb-width-active {description: "Switch thumb width when active", formats: ["length"], help: "#oj-switch-css-set5"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when selected and active
     * @ojstylevariableset oj-switch-css-set6
     * @ojdisplayname Selected active
     * @ojstylevariable oj-switch-track-bg-color-selected-active {description: "Switch track background color when selected and active", formats: ["color"],
     *  help: "#oj-switch-css-set6"}
     * @ojstylevariable oj-switch-track-border-color-selected-active {description: "Switch track border color when selected and active ",formats: ["color"],
     *  help: "#oj-switch-css-set6"}
     * @ojstylevariable oj-switch-thumb-bg-color-selected-active {description: "Switch thumb background color when selected and active", formats: ["color"],
     *  help: "#oj-switch-css-set6"}
     * @ojstylevariable oj-switch-thumb-border-color-selected-active {description: "Switch thumb border color when selected and active",formats: ["color"],
     *  help: "#oj-switch-css-set6"}
     * @ojstylevariable oj-switch-thumb-box-shadow-selected-active {description: "Switch thumb box shadow when selected and active", help: "#oj-switch-css-set6"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when disabled
     * @ojstylevariableset oj-switch-css-set7
     * @ojdisplayname Disabled
     * @ojstylevariable oj-switch-track-bg-color-disabled {description: "Switch track background color when disabled", formats: ["color"], help: "#oj-switch-css-set7"}
     * @ojstylevariable oj-switch-track-border-color-disabled {description: "Switch track border color when disabled",formats: ["color"], help: "#oj-switch-css-set7"}
     * @ojstylevariable oj-switch-thumb-bg-color-disabled {description: "Switch thumb background color when disabled", formats: ["color"], help: "#oj-switch-css-set7"}
     * @ojstylevariable oj-switch-thumb-border-color-disabled {description: "Switch thumb border color when disabled",formats: ["color"], help: "#oj-switch-css-set7"}
     * @memberof oj.ojSwitch
     */
    /**
     * CSS variables used by oj-switch when selected and disabled
     * @ojstylevariableset oj-switch-css-set8
     * @ojdisplayname Selected disabled
     * @ojstylevariable oj-switch-track-bg-color-selected-disabled {description: "Switch track background color when selected and disabled", formats: ["color"],
     *  help: "#oj-switch-css-set8"}
     * @ojstylevariable oj-switch-track-border-color-selected-disabled {description: "Switch track border color when selected and disabled",formats: ["color"],
     *  help: "#oj-switch-css-set8"}
     * @ojstylevariable oj-switch-thumb-bg-color-selected-disabled {description: "Switch thumb background color when selected and disabled", formats: ["color"],
     *  help: "#oj-switch-css-set8"}
     * @ojstylevariable oj-switch-thumb-border-color-selected-disabled {description: "Switch thumb border color when selected and disabled",formats: ["color"],
     *  help: "#oj-switch-css-set8"}
     * @memberof oj.ojSwitch
     */
    // --------------------------------------------------- oj.ojSwitch Styling end -----------------------------------------------------------

    oj.__registerWidget('oj.ojSwitch', $.oj.editableValue, {
      version: '1.1.0',
      defaultElement: '<input>',
      widgetEventPrefix: 'oj',

      options: {
        /**
         * <p>
         * Whether the component is disabled. The element's
         * <code class="prettyprint">disabled</code>
         *  property is used as its initial
         * value if it exists, when the attribute is not explicitly set. When neither is set,
         * <code class="prettyprint">disabled </code>
         * defaults to false.
         *
         * @example <caption>Initialize the switch with
         * <code class="prettyprint">disabled</code> attribute:</caption>
         * &lt;oj-switch disabled="true">&lt;/oj-switch>
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // Getter
         * var disabled = myComponent.disabled;
         *
         * // Setter
         * myComponent.disabled = true;
         *
         * @expose
         * @ojshortdesc Specifies whether the component is disabled. The default is false.
         * @type {boolean}
         * @default false
         * @public
         * @instance
         * @memberof oj.ojSwitch
         */
        disabled: false,
        /**
         * <p>
         * The oj-label sets the labelledBy property programmatically on the form component
         * to make it easy for the form component to find its oj-label component (a
         * document.getElementById call.)
         * </p>
         * <p>
         * The application developer should use the 'for'/'id api
         * to link the oj-label with the form component;
         * the 'for' on the oj-label to point to the 'id' on the input form component.
         * This is the most performant way for the oj-label to find its form component.
         * </p>
         *
         * @example <caption>Initialize component with <code class="prettyprint">for</code> attribute:</caption>
         * &lt;oj-label for="switchId">Name:&lt;/oj-label>
         * &lt;oj-switch id="switchId">
         * &lt;/oj-switch>
         * // ojLabel then writes the labelled-by attribute on the oj-switch.
         * &lt;oj-label id="labelId" for="switchId">Name:&lt;/oj-label>
         * &lt;oj-switch id="switchId" labelled-by"labelId">
         * &lt;/oj-switch>
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelledBy = myComp.labelledBy;
         *
         * // setter
         * myComp.labelledBy = "labelId";
         * @ojshortdesc The oj-label sets the labelledBy property
         * programmatically on the form component.
         * @expose
         * @type {string|null}
         * @default null
         * @public
         * @instance
         * @since 7.0.0
         * @memberof oj.ojSwitch
         */
        labelledBy: null,
        /**
         * Whether the component is readonly. The readOnly property sets or returns whether an element is readOnly, or not.
         * A readOnly element cannot be modified. However, a user can tab to it, highlight it, focus on it, and copy the text from it.
         * If you want to prevent the user from interacting with the element, use the disabled property instead. The element's
         * <code class="prettyprint">readOnly</code> property is used as its initial value if it exists, when the attribute is not explicitly set.
         *  When neither is set, <code class="prettyprint">readOnly </code> defaults to false.
         * <p>
         * The default value for readonly is false. However, if the form component is a descendent of
         * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
         * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
         * The <code class="prettyprint">oj-form-layout</code> uses the
         * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
         * <code class="prettyprint">provide</code> property to provide its
         * <code class="prettyprint">readonly</code>
         * attribute value to be consumed by descendent components.
         * The form components are configured to consume the readonly property if an ancestor provides it and
         * it is not explicitly set.
         * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
         * not have its readonly attribute set, the form component's readonly will be true.
         * </p>
         * @example <caption>Initialize the switch with
         * <code class="prettyprint">readOnly</code> attribute:</caption>
         * &lt;oj-switch readonly="true">&lt;/oj-switch>
         * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
         * // Getter
         * var readonly = myComponent.readonly;
         *
         * // Setter
         * myComponent.readonly = true;
         *
         *
         * @expose
         * @ojshortdesc Specifies whether the component is read-only. A read-only element cannot be modified, but user interaction is allowed. See the Help documentation for more information.
         * @type {boolean}
         * @alias readonly
         * @default false
         * @instance
         * @memberof oj.ojSwitch
         */
        readOnly: false,

        /**
         * The boolean state of the switch component.
         *
         * @example <caption>Initialize component (switch is ON) with
         * <code class="prettyprint">value</code> attribute:</caption>
         * &lt;oj-switch value="true">&lt;/oj-switch>
         * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
         * // Getter
         * var value = myComponent.value;
         *
         * // Setter
         * myComponent.value = true;
         *
         * @expose
         * @type {boolean}
         * @default false
         * @ojwriteback
         * @public
         * @instance
         * @memberof oj.ojSwitch
         * @ojeventgroup common
         */
        value: false
      },

      // P U B L I C    M E T H O D S

      /**
       * Returns a jQuery object containing the element visually representing the switch.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @memberof oj.ojSwitch
       * @instance
       * @return {jQuery} the switch
       * @ignore
       */
      widget: function () {
        return this._element2;
      },

      // @inheritdoc
      getNodeBySubId: function (locator) {
        var node = this._super(locator);
        var subId;
        var rootElement = this.widget();

        if (!node) {
          node = locator == null || locator.subId == null ? rootElement : null;
          if (!node && locator) {
            subId = locator.subId;
            if (subId === OJ_SWITCH_THUMB || subId === OJ_SWITCH_TRACK) {
              return rootElement.find('.' + subId)[0];
            }
          }
        }

        return node || null;
      },

      /**
       * Returns the subId locator for the given child DOM node.
       * <p>
       * If DOM node is null then method returns null.
       * </p>
       * <p>
       * If DOM node is not a child of the current component then method returns null.
       * </p>
       *
       * @expose
       * @override
       * @ignore
       * @memberof oj.ojSwitch
       * @instance
       * @param {!Element} node - child DOM node
       * @return {Object|null} The subId for the DOM node, or null when none is found.
       */
      getSubIdByNode: function (node) {
        var originalId = $(this.element).attr('id');
        var nodeId;
        var result = this._super(node);

        if (node != null) {
          if ($(node).hasClass(OJ_SWITCH_TRACK) || $(node).hasClass(OJ_SWITCH_THUMB)) {
            nodeId = $(node).parents('div.oj-switch').find('input.oj-component-initnode').attr('id');
            if (originalId === nodeId && $(node).hasClass(OJ_SWITCH_TRACK)) {
              result = { subId: OJ_SWITCH_TRACK };
            } else if (originalId === nodeId && $(node).hasClass(OJ_SWITCH_THUMB)) {
              result = { subId: OJ_SWITCH_THUMB };
            }
          }
        }

        return result;
      },

      // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

      /**
       * oj-switch doesn't use .oj-text-field-readonly for the focusable readonly content,
       * so we need to use a different selector.
       * @memberof oj.ojSwitch
       * @instance
       * @override
       * @protected
       * @return {Element|null}
       */
      _GetReadonlyFocusElement: function () {
        return this.widget()[0].querySelector('.oj-switch-thumb');
      },

      /**
       * @private
       * @const
       */
      _BUNDLE_KEY: {
        _SWITCH_OFF: 'SwitchOFF',
        _SWITCH_ON: 'SwitchON'
      },

      /**
       * Overridden to set the options.value. When constructorOptions value is undefined,
       * we read the CHECKED, DISABLED, READONLY OPTIONS on the checkbox and
       * build the switch options from that.
       *
       * @memberof oj.ojSwitch
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        var props;
        var val;

        props = [
          { attribute: 'disabled', validateOption: true },
          { attribute: 'readonly', option: 'readOnly', validateOption: true },
          {
            attribute: 'checked',
            option: 'value',
            validateOption: false,
            coerceDomValue: function (domValue) {
              return !!domValue;
            }
          },
          { attribute: 'title' }
        ];

        // For translations, the oj-switch component has the following keys:
        // SwitchON and SwitchOFF. Due to this unconventional naming, it is impossible
        // to configure these through HTML attributes. In order to support having
        // translations.switch-on and translations.switch-off (which would result in the
        // properties switchOn and switchOff), we need to map the new properties to the
        // existing translation keys.
        let newConstructorOptions = constructorOptions;
        const translations = constructorOptions.translations;
        if (translations) {
          // Make a copy of the current translations. This is needed for
          // backwards compatibility of applications that are still using
          // undocument translations keys for setting the translations for
          // the swtich states (SwitchON and SwitchOFF). We should not be
          // overriding this unless the new documented properties are provided.
          const newTranslations = Object.assign({}, translations);
          if (translations.switchOn !== undefined) {
            newTranslations.SwitchON = translations.switchOn;
          }
          if (translations.switchOff !== undefined) {
            newTranslations.SwitchOFF = translations.switchOff;
          }
          newConstructorOptions = Object.assign({}, constructorOptions, {
            translations: newTranslations
          });
        }

        this._super(originalDefaults, newConstructorOptions);

        // Only needed for non new element style
        if (!this._IsCustomElement()) {
          ojeditablevalue.EditableValueUtils.initializeOptionsFromDom(props, constructorOptions, this);
          val = this.option('value');
          this.option({ value: !!val }, { _context: { writeback: true, internalSet: true } });
        }
      },

      /**
       * Create switch component
       *
       * @override
       * @protected
       * @memberof oj.ojSwitch
       * @instance
       */
      _ComponentCreate: function () {
        this._super();

        if (!this.element.is('input')) {
          throw new Error('ojSwitch can be bound to INPUT only.');
        }

        this._inputElementOriginalDisplay = this.element.css('display');
        this._inputElementTabIndex = this.element.attr('tabindex') || 0;
        this.element
          .css('display', 'none')
          .attr('type', 'checkbox')
          .attr('checked', this.option('value'))
          .attr('tabindex', '-1')
          .attr('disabled', this.option('disabled'))
          .attr('readonly', this.option('readOnly'));

        if (this.OuterWrapper) {
          this._element2 = $(this.OuterWrapper);
        } else {
          this._element2 = this.element.wrap('<div></div>').parent(); // @HTMLUpdateOK trusted string
        }
        this._element2.addClass('oj-switch oj-component oj-form-control');

        const switchContainerHTML = `
      <div class='oj-switch-container oj-form-control-container'>
        <div class='oj-switch-track'>
          <div class='oj-switch-thumb' tabIndex='${this._inputElementTabIndex}'></div>
        </div>
      </div>
      `;
        this._element2.append(switchContainerHTML); // @HTMLUpdateOK append or prepend trusted new DOM to switch elem

        this.switchThumb = this._element2.find('.oj-switch-thumb');
        this.switchThumb.attr('role', this._setSwitchRole());

        this.switchTrack = this._element2.find('.oj-switch-track');
      },

      _AfterCreate: function () {
        this._super();

        // Get aria-label and aria-labelledby attribute values from the component and move them to the thumb which is the dom that gets focus
        var target = this.switchThumb;
        this._SetAriaInfo(target);

        // Set this._ariaLabelElement so that we know where to go when setting aria-label from label-hint
        this._ariaLabelElement = this.switchThumb[0];

        this._setup();
      },

      /**
       * Set aria label information for the switch.  It will come from either aria-labelledby or aria-label
       * @protected
       * @memberof oj.ojSwitch
       * @ignore
       */
      _SetAriaInfo: function (target) {
        var component;

        // Grab the right component
        if (this.OuterWrapper) {
          component = this._element2[0];
        } else {
          component = this._element2[0].querySelector('input');
        }

        var labelElementId;
        if (this._IsCustomElement()) {
          // Custom element case
          if (this.options.labelledBy) {
            var defaultLabelId = this.uuid + '_Label';
            labelElementId = ojeditablevalue.EditableValueUtils._getOjLabelAriaLabelledBy(
              this.options.labelledBy,
              defaultLabelId
            );
          }
        } else {
          // Non custom element case
          var label = this._GetLabelElement();
          if (label) {
            labelElementId = label.attr('id');
          }
        }

        // Apply the label to the target
        if (labelElementId) {
          // Set the aria-labelledby attribute of the thumb to the returned id
          target.attr('aria-labelledby', labelElementId);
        } else {
          // Check if the element has aria-label
          var ariaLabelString = component.getAttribute(ARIA_LABEL);
          if (ariaLabelString) {
            // Set the aria-label of the thumb to the returned string
            target.attr(ARIA_LABEL, ariaLabelString); // @HTMLUpdateOK
            // And remove it from the component
            component.removeAttribute(ARIA_LABEL);
          }
        }
      },

      /**
       * Return the element on which aria-label can be found.
       * Usually this is the root element, but some components have aria-label as a transfer attribute,
       * and aria-label set on the root element is transferred to the inner element.
       * @memberof oj.ojSwitch
       * @instance
       * @protected
       */
      _GetAriaLabelElement: function () {
        return this._ariaLabelElement ? this._ariaLabelElement : this._super();
      },

      /**
       * _setup is called on create and refresh.
       *
       * @memberof oj.ojSwitch
       * @instance
       * @private
       */
      _setup: function () {
        var rootElement = $(this.widget());

        this._setupEvents();

        if (rootElement === undefined) return;
        this.element.attr('checked', this.option('value')); // Switch vs Input synchonization

        rootElement.removeClass('oj-disabled oj-read-only oj-selected oj-hover oj-active');
        $(this.switchThumb).attr('tabindex', this._inputElementTabIndex);
        $(this.switchThumb).html(''); // @HTMLUpdateOK

        if (this.option('disabled') || this.option('readOnly')) {
          if (this.option('disabled')) {
            rootElement.addClass('oj-disabled');
            $(this.switchThumb).removeAttr('tabindex');
          } else {
            rootElement.addClass('oj-read-only');
            let readonlyValue = this._setReadOnlyValue();
            $(this.switchThumb).html(readonlyValue); // @HTMLUpdateOK internal strings
          }
        }

        if (this.option('value')) {
          rootElement.addClass('oj-selected');
        }

        // Aria
        $(this.switchThumb).attr('aria-checked', this.option('value'));

        $(this.switchThumb).removeAttr(ARIA_DISABLED);
        $(this.switchThumb).removeAttr('aria-readonly');
        rootElement.removeAttr(ARIA_DISABLED);
        if (!this._CanSetValue()) {
          if (this.option('disabled')) {
            $(this.switchThumb).attr(ARIA_DISABLED, 'true'); // @HTMLUpdateOK
          } else {
            $(this.switchThumb).attr('aria-readonly', 'true');
          }
        }
      },

      /**
       * Translate On/Off switch
       *
       * @protected
       * @memberof oj.ojSwitch
       * @instance
       */
      _setReadOnlyValue: function () {
        var strReturn = this._BUNDLE_KEY._SWITCH_OFF;
        if (this.option('value')) {
          strReturn = this._BUNDLE_KEY._SWITCH_ON;
        }
        return this.getTranslatedString(strReturn);
      },

      /**
       * Binding events to the switch component
       *
       * @protected
       * @memberof oj.ojSwitch
       * @instance
       */
      _setupEvents: function () {
        this._off(this._element2, 'keydown keyup mouseup touchend');
        if (this._CanSetValue()) {
          this._on(this._element2, this._switchEvents);
          this._AddHoverable(this._element2);
          this._AddActiveable(this._element2);
        }
        this._focusable({
          element: this.switchTrack,
          applyHighlight: true
        });
      },

      /**
       * @override
       * @private
       */
      _switchEvents: {
        keydown: function (event) {
          const keyCode = event.which || event.keyCode;
          // ENTER and SPACE will change the switch
          if (keyCode === $.ui.keyCode.ENTER || keyCode === $.ui.keyCode.SPACE) {
            $(event.currentTarget).addClass('oj-active');
            event.preventDefault();
          }
        },
        keyup: function (event) {
          const keyCode = event.which || event.keyCode;
          // ENTER and SPACE will change the switch
          if (keyCode === $.ui.keyCode.ENTER || keyCode === $.ui.keyCode.SPACE) {
            this._SetValue(!this.option('value'), event);
          }
        },
        mouseup: function (event) {
          // We should only be reacting to the changes if one clicks on the switch track or thumb (child DOM of track)
          if (!DomUtils.isAncestorOrSelf(this.switchTrack[0], event.target)) {
            // Event not originated from the thumb or track, so do not react
            return;
          }

          // LEFT MOUSE BUTTON will change the switch and we want to ignore touch events here
          // so we don't toggle the value twice.
          if (event.button === 0 && this._isRealMouseEvent(event)) {
            this._SetValue(!this.option('value'), event);
          }

          // Click JET-37778 - Clicking switch track should move focus to thumb
          // This is to make sure that the component retains the focus after one toggles the
          // value by clicking on the track. Otherwise the Dynamic form may fail to update the
          // model, since the focus would not be inside the form
          FocusUtils.focusElement(this.switchThumb[0]);
        },
        touchend: function (event) {
          // We should only be reacting to the changes if one taps on the switch track or thumb (child DOM of track)
          if (!DomUtils.isAncestorOrSelf(this.switchTrack[0], event.target)) {
            // Event not originated from the thumb or track, so do not react
            return;
          }

          this._SetValue(!this.option('value'), event);

          // Click JET-37778 - Clicking switch track should move focus to thumb
          // This is to make sure that the component retains the focus after one toggles the
          // value by clicking on the track. Otherwise the Dynamic form may fail to update the
          // model, since the focus would not be inside the form
          FocusUtils.focusElement(this.switchThumb[0]);
        }
      },

      /**
       * Returns the default styleclass for the component. Currently this is
       * used to pass to the ojLabel component, which will append -label and
       * add the style class onto the label. This way we can style the label
       * specific to the input component. For example, for inline labels, the
       * checkboxset/checkboxset components need to have margin-top:0, whereas all the
       * other inputs need it to be .5em. So we'll have a special margin-top style
       * for .oj-label-inline.oj-checkboxset-label
       * All input components must override
       *
       * @return {string}
       * @memberof oj.ojSwitch
       * @override
       * @protected
       */
      _GetDefaultStyleClass: function () {
        return 'oj-switch';
      },
      /**
       * Whether the a value can be set on the component. For example, if the component is
       * disabled or readOnly then setting value on component is a no-op.
       *
       * @see #_SetValue
       * @return {boolean}
       * @memberof oj.ojSwitch
       * @override
       * @protected
       */
      _CanSetValue: function () {
        var readOnly;
        var superCanSetValue = this._super();

        if (!superCanSetValue) {
          return false;
        }

        readOnly = this.options.readOnly || false;
        return !readOnly;
      },
      /**
       * Returns switch role for ARIA
       * ToDo: for IE it should be role="cehckbox"
       *
       * @return {string}
       * @memberof oj.ojSwitch
       * @override
       * @protected
       */
      _setSwitchRole: function () {
        return 'switch';
      },

      /**
       * @ignore
       * @protected
       * @override
       */
      _destroy: function () {
        if (this._CanSetValue()) {
          this._RemoveHoverable(this._element2);
          this._RemoveActiveable(this._element2);
        }
        this._element2.find('.oj-switch-track').remove();
        DomUtils.unwrap(this.element);
        this._RestoreAttributes(this.element);
        return this._super();
      },

      /**
       * Returns a jquery object of the launcher element representing the content nodes (switch).
       * @protected
       * @override
       * @memberof oj.ojSwitch
       */
      _GetMessagingLauncherElement: function () {
        return this._element2;
      },

      /**
       * Returns a jquery object of the elements representing the content nodes (switch thumb).
       * @protected
       * @override
       * @memberof oj.ojSwitch
       */
      _GetContentElement: function () {
        return this.switchThumb;
      },
      /**
       * Performs post processing after _SetOption() is called. Different options when changed perform
       * different tasks. See _AfterSetOption[OptionName] method for details.
       *
       * @param {string} option
       * @param {Object|string=} previous
       * @param {Object=} flags
       * @protected
       * @override
       * @memberof oj.ojSwitch
       * @instance
       */
      // eslint-disable-next-line no-unused-vars
      _AfterSetOption: function (option, previous, flags) {
        this._superApply(arguments);
        if (option === 'readOnly') {
          this._AfterSetOptionDisabledReadOnly(option, ojeditablevalue.EditableValueUtils.readOnlyOptionOptions);
        }
      },

      /**
       * An override of the JQUI option method to set aliases for the oj-switch component's options.
       *
       * @param {string|Object=} optionName the option name (string, first two overloads), or the map (Object, last overload).
       *                                    Omitted in the third overload.
       * @param {Object=} value a value to set for the option.  Second overload only.
       *
       * @override
       * @memberof oj.ojSwitch
       * @instance
       * @ignore
       */
      // eslint-disable-next-line no-unused-vars
      option: function (optionName, value) {
        let args = arguments;
        let aliasedName = optionName;

        // Check if the optionName is one of the options that needs to be aliased
        if (optionName === 'translations.switchOn') {
          aliasedName = 'translations.SwitchON';
        } else if (optionName === 'translations.switchOff') {
          aliasedName = 'translations.SwitchOFF';
        }

        // replace the first arg with the aliasedName if it exists
        if (args.length > 0) {
          args[0] = aliasedName;
        }

        // Apply the new arguments
        return this._superApply(args);
      },

      /**
       * @override
       * @private
       */
      _setOption: function (key, value, flags) {
        var coercedValue;
        switch (key) {
          case 'disabled':
          case 'readOnly':
          case 'value':
            coercedValue = !!value;
            break;
          default:
            coercedValue = value;
        }
        // need to coerceValues first
        this._super(key, coercedValue, flags);

        if (key === 'labelledBy') {
          this._SetAriaInfo(this.switchThumb);
        }
      },

      /**
       * @private
       * @memberof oj.ojSwitch
       * @return {boolean} true if there is no touch detected within the last 500 ms
       */
      _isRealMouseEvent: function () {
        return !DomUtils.recentTouchEnd();
      },
      /**
       * Used for explicit cases where the component needs to be refreshed
       * (e.g., when the value option changes or other UI gestures).
       * @override
       * @protected
       * @memberof oj.ojSwitch
       */
      // eslint-disable-next-line no-unused-vars
      _Refresh: function (name, value, forceDisplayValueRefresh) {
        this._superApply(arguments);
        this._setup();
      }
    });
  })();

});


define('ojs/ojcolor',['ojs/ojcore-base'], function (oj) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  var trimLeft = /^\s+/;
  var trimRight = /\s+$/;
  var mathRound = Math.round;
  var mathMin = Math.min;
  var mathMax = Math.max;

  /**
   * @typedef {Object} Color.RGBA
   * @property {number} r the red value
   * @property {number} g the green value
   * @property {number} b the blue value
   * @property {number} [a] the optional alpha value
   */
  /**
   * @typedef {Object} Color.HSLA
   * @property {number} h the hue value
   * @property {number} s the saturation value
   * @property {number} l the luminosity or lightness value
   * @property {number} [a] the optional alpha value
   */
  /**
   * @typedef {Object} Color.HSVA
   * @property {number} h the hue value
   * @property {number} s the saturation value
   * @property {number} v the value
   * @property {number} [a] the optional alpha value
   */
  /**
     * @class Color
     * @since 3.0.0
     * @classdesc Immutable object representing a color.
     * @ojshortdesc Object representing a color definition.
     * @ojtsmodule
     * @desc Creates an object representing a color. The color may be defined using
     * the RGB, HSL, and HSV model values as an object, or as a CSS3 color specification string (refer to
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}, and also
     * {@link https://www.w3.org/TR/css3-color/#svg-color} for color visualization.  The
     * CSS3 named colors are available as Color constants (e.g. Color.ALICEBLUE)
     *
     * @example <caption>Typical color definitions</caption>
     *  Color.RED;
     *  Color.ALICEBLUE;
     *  new Color({r:30, g:128, b:201});
     *  new Color({r:30, g:128, b:201, a:0.8});
     *  new Color({h:310, s:50, l:80});
     *  new Color({h:310, s:50, l:80, a:0.8});
     *  new Color({h:310, s:50, v:80});
     *  new Color({h:310, s:50, v:80, a:0.8});
     *  new Color('#4bc');
     *  new Color('#44ccbb');
     *  new Color('rgb(27,128,254)');
     *  new Color('rgba(27,128,254,0.8)');
     *  new Color('hsl(87, 100%,50%)');
     *  new Color('hsla(87, 100%,50%, 0.5)');
     *  new Color('hsv(0, 100%, 100%)') ;
     *  Color.TRANSPARENT;
     *
     * @example <caption>Using a converter to obtain a different color format</caption>
     * var convHsl  = new ColorConverter({"format": "hsl"}) ;
     *
     * var c        = new Color('rgb(0, 191, 255)');
     * var s        = convHsl.format(c) ;            // returns "hsl(197, 71%, 73%)"

     * </p></br>
     * @param {string | Object} color
     * <ul><li> A valid CSS3 color specification string (refer to
     *  {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for syntax)</li>
     * <li>An object containing one of the following groups of fields:
     * <ul>
     *  <li>r: &nbsp; the red value</li>
     *  <li>g: &nbsp; the green value</li>
     *  <li>b: &nbsp; the blue value</li>
     *  <li>a: &nbsp; the alpha value (optional)</li>
     * </ul>
     * <br>
     * <ul>
     *  <li>h: &nbsp; the hue value</li>
     *  <li>s: &nbsp; the saturation value</li>
     *  <li>l: &nbsp; the luminosity or lightness value</li>
     *  <li>a: &nbsp; the alpha value (optional)</li>
     * </ul>
     * <br>
     * <ul>
     *  <li>h: &nbsp; the hue value</li>
     *  <li>s: &nbsp; the saturation value</li>
     *  <li>v: &nbsp; the value</li>
     *  <li>a: &nbsp; the alpha value (optional)</li>
     * </ul>
     * </li></ul>
     * @ojsignature {target: "Type",
     *               value: "string|Color.RGBA|Color.HSLA|Color.HSVA",
     *               for: "color",
     *               jsdocOverride: true}
     * @constructor
     * @final
     * @throws {Error} if the color specification cannot be parsed correctly.
     * @export
     */
  function Color(color) {
    var rgb;

    // eslint-disable-next-line no-param-reassign
    color = color || '';
    rgb = inputToRGB(color);

    this._r = rgb.r;
    this._g = rgb.g;
    this._b = rgb.b;
    this._a = Math.round(100 * rgb.a) / 100;
    Object.defineProperty(this, 'rgba', {
      writable: false,
      value: { r: rgb.r, g: rgb.g, b: rgb.b, a: Math.round(100 * rgb.a) / 100 }
    });
    Object.defineProperty(this, 'hsla', { writable: false, value: rgbaToHsla(this.rgba) });
    Object.defineProperty(this, 'hsva', { writable: false, value: rgbaToHsva(this.rgba) });
  }
  /**
   * Returns the red channel value of the color                            arise when a color is defined using the "hsl" format.)
   * @return {Color.RGBA} The RGBA value in the range [0,255].
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.getRGBA = function () {
    return this.rgba;
  };
  /**
   * Returns the red channel value of the color                            arise when a color is defined using the "hsl" format.)
   * @return {Color.HSLA} The HSLA value in the range [0,255].
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.getHSLA = function () {
    return this.hsla;
  };

  /**
   * Returns the red channel value of the color                            arise when a color is defined using the "hsl" format.)
   * @return {Color.HSVA} The HSLA value in the range [0,255].
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.getHSVA = function () {
    return this.hsva;
  };

  /**
   * Converts an RGB color value to HSL.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the h,s,l values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  r, g, b in [0, 255] or [0, 1]
   * @param {Object} co color object in rgba format
   * @returns {Object} Object with properties h, s, l, in [0, 1].
   * @memberof Color
   * @private
   */
  function rgbaToHsla(co) {
    // eslint-disable-next-line no-param-reassign
    let r = bound01(co.r, 255) * 255;
    // eslint-disable-next-line no-param-reassign
    let g = bound01(co.g, 255) * 255;
    // eslint-disable-next-line no-param-reassign
    let b = bound01(co.b, 255) * 255;
    // eslint-disable-next-line no-param-reassign
    let a = boundAlpha(co.a);
    var max = mathMax(r, g, b);
    var min = mathMin(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      // eslint-disable-next-line no-multi-assign
      h = s = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
      }
      h /= 6;
    }

    return { h: h, s: s, l: l, a: a };
  }

  /**
   * Converts an RGB color value to HSV.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the r,g,b values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  r, g, b,a in [0, 255] or [0, 1]
   * @returns {Object} Object with properties r, g, and b, in [0, 255].
   * @memberof Color
   * @private
   */
  function rgbaToHsva(co) {
    let h = 0;
    let rabs = co.r / 255;
    let gabs = co.g / 255;
    let babs = co.b / 255;
    let s = 0;
    let v = Math.max(rabs, gabs, babs);
    let diff = v - Math.min(rabs, gabs, babs);
    let diffc = (c) => (v - c) / 6 / diff + 1 / 2;

    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      let rr = diffc(rabs);
      let gg = diffc(gabs);
      let bb = diffc(babs);

      if (rabs === v) {
        h = bb - gg;
      } else if (gabs === v) {
        h = 1 / 3 + rr - bb;
      } else if (babs === v) {
        h = 2 / 3 + gg - rr;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return {
      h: bound01(h, 360) * 6,
      s: bound01(s, 100),
      v: bound01(v, 100),
      a: boundAlpha(co.a)
    };
  }

  /**
    }

    /**
     * Returns the red channel value of the color.
     * @ojdeprecated {since: '12.0.0', description: 'Use the getRGBA,getHSLA,getHSVA method instead for fetching color value in different format.'}
     * @param {boolean=} doNotRound  Omit or set to false to return an integer value.
     *                               Set to true to return the possible fractional value.
     *                               (Fractional values for the red, green, or blue channels can
     *                               arise when a color is defined using the "hsl" format.)
     * @return {number} The red channel value in the range [0,255].
     * @memberof Color
     * @instance
     * @export
     */
  Color.prototype.getRed = function (doNotRound) {
    return doNotRound ? this._r : mathRound(this._r);
  };

  /**
   * Returns the green channel value of the color.
   * @ojdeprecated {since: '12.0.0', description: 'Use the getRGBA,getHSLA,getHSVA method instead for fetching color value in different format.'}
   * @param {boolean=} doNotRound  Omit or set to false to return an integer value.
   *                               Set to true to return the possible fractional value.
   *                               (Fractional values for the red, green, or blue channels can
   *                               arise when a color is defined using the "hsl" format.)
   * @return {number} The green channel value contained in [0,255].
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.getGreen = function (doNotRound) {
    return doNotRound ? this._g : mathRound(this._g);
  };

  /**
   * Returns the blue channel value of the color.
   * @ojdeprecated {since: '12.0.0', description: 'Use the getRGBA,getHSLA,getHSVA method instead for fetching color value in different format.'}
   * @param {boolean=} doNotRound  Omit or set to false to return an integer value.
   *                               Set to true to return the possible fractional value.
   *                               (Fractional values for the red, green, or blue channels can
   *                               arise when a color is defined using the "hsl" format.)
   * @return {number} The blue channel value contained in [0,255].
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.getBlue = function (doNotRound) {
    return doNotRound ? this._b : mathRound(this._b);
  };

  /**
   * Returns the alpha channel of the color.
   * @ojdeprecated {since: '12.0.0', description: 'Use the getRGBA,getHSLA,getHSVA method instead for fetching color value in different format.'}
   * @return {number} The alpha channel value contained in [0,1].
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.getAlpha = function () {
    return this._a;
  };

  /**
   * Returns the color as an "rgb" or rgba" (if the alpha value is less than 1) CSS3 color
   * specification string.
   * @return {string} The color as an "rgb" or "rgba" CSS3 color specification string.
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.toString = function () {
    return toRgbString(this);
  };

  /**
   * Compares this color object with the supplied color specification, and returns true
   * if they represent the same color, else false.
   * @param {Color} color   The color to be compared.
   * @return {boolean} Returns true if the comperand represents the same color.
   * @memberof Color
   * @instance
   * @export
   */
  Color.prototype.isEqual = function (color) {
    var ret = false;

    if (color instanceof Color) {
      ret =
        this._r === color._r && this._g === color._g && this._b === color._b && this._a === color._a;
    }

    return ret;
  };

  /** CSS3 color <code class="prettyprint">aliceblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:aliceblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ALICEBLUE = null;
  /** CSS3 color <code class="prettyprint">antiquewhite</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:antiquewhite;"/>
   * </div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ANTIQUEWHITE = null;
  /** CSS3 color <code class="prettyprint">aqua</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:aqua;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.AQUA = null;
  /** CSS3 color <code class="prettyprint">aquamarine</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:aquamarine;"></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.AQUAMARINE = null;
  /** CSS3 color <code class="prettyprint">azure</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:azure;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.AZURE = null;
  /** CSS3 color <code class="prettyprint">beige</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:beige;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BEIGE = null;
  /** CSS3 color <code class="prettyprint">bisque</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:bisque;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BISQUE = null;
  /** CSS3 color <code class="prettyprint">black</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:black;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BLACK = null;
  /** CSS3 color <code class="prettyprint">blanchedalmond</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:blanchedalmond;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BLANCHEDALMOND = null;
  /** CSS3 color <code class="prettyprint">blue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:blue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BLUE = null;
  /** CSS3 color <code class="prettyprint">blueviolet</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:blueviolet;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BLUEVIOLET = null;
  /** CSS3 color <code class="prettyprint">brown</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:brown;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BROWN = null;
  /** CSS3 color <code class="prettyprint">burlywood</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:burlywood;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.BURLYWOOD = null;
  /** CSS3 color <code class="prettyprint">cadetblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:cadetblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CADETBLUE = null;
  /** CSS3 color <code class="prettyprint">chartreuse</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:chartreuse;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CHARTREUSE = null;
  /** CSS3 color <code class="prettyprint">chocolate</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:chocolate;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CHOCOLATE = null;
  /** CSS3 color <code class="prettyprint">coral</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:coral;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CORAL = null;
  /** CSS3 color <code class="prettyprint">cornflowerblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:cornflowerblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CORNFLOWERBLUE = null;
  /** CSS3 color <code class="prettyprint">cornsilk</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:cornsilk;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CORNSILK = null;
  /** CSS3 color <code class="prettyprint">crimson</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:crimson;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CRIMSON = null;
  /** CSS3 color <code class="prettyprint">cyan</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:cyan;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.CYAN = null;
  /** CSS3 color <code class="prettyprint">darkblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKBLUE = null;
  /** CSS3 color <code class="prettyprint">darkcyan</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkcyan;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKCYAN = null;
  /** CSS3 color <code class="prettyprint">darkgoldenrod</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkgoldenrod;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKGOLDENROD = null;
  /** CSS3 color <code class="prettyprint">darkgray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkgray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKGRAY = null;
  /** CSS3 color <code class="prettyprint">darkgrey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkgrey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKGREY = null;
  /** CSS3 color <code class="prettyprint">darkgreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkgreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKGREEN = null;
  /** CSS3 color <code class="prettyprint">darkkhaki</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkkhaki;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKKHAKI = null;
  /** CSS3 color <code class="prettyprint">darkmagenta</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkmagenta;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKMAGENTA = null;
  /** CSS3 color <code class="prettyprint">darkolivegreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkolivegreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKOLIVEGREEN = null;
  /** CSS3 color <code class="prettyprint">darkorange</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkorange;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKORANGE = null;
  /** CSS3 color <code class="prettyprint">darkorchid</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkorchid;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKORCHID = null;
  /** CSS3 color <code class="prettyprint">darkred</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkred;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKRED = null;
  /** CSS3 color <code class="prettyprint">darksalmon</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darksalmon;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKSALMON = null;
  /** CSS3 color <code class="prettyprint">darkseagreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkseagreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKSEAGREEN = null;
  /** CSS3 color <code class="prettyprint">darkslateblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkslateblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKSLATEBLUE = null;
  /** CSS3 color <code class="prettyprint">darkslategray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkslategray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKSLATEGRAY = null;
  /** CSS3 color <code class="prettyprint">darkslategrey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkslategrey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKSLATEGREY = null;
  /** CSS3 color <code class="prettyprint">darkturquoise</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkturquoise;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKTURQUOISE = null;
  /** CSS3 color <code class="prettyprint">darkviolet</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:darkviolet;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DARKVIOLET = null;
  /** CSS3 color <code class="prettyprint">deeppink</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:deeppink;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DEEPPINK = null;
  /** CSS3 color <code class="prettyprint">deepskyblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:deepskyblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DEEPSKYBLUE = null;
  /** CSS3 color <code class="prettyprint">dimgray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:dimgray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DIMGRAY = null;
  /** CSS3 color <code class="prettyprint">dimgrey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:dimgrey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DIMGREY = null;
  /** CSS3 color <code class="prettyprint">dodgerblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:dodgerblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.DODGERBLUE = null;
  /** CSS3 color <code class="prettyprint">firebrick</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:firebrick;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.FIREBRICK = null;
  /** CSS3 color <code class="prettyprint">floralwhite</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:floralwhite;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.FLORALWHITE = null;
  /** CSS3 color <code class="prettyprint">forestgreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:forestgreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.FORESTGREEN = null;
  /** CSS3 color <code class="prettyprint">fuchsia</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:fuchsia;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.FUCHSIA = null;
  /** CSS3 color <code class="prettyprint">gainsboro</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:gainsboro;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GAINSBORO = null;
  /** CSS3 color <code class="prettyprint">ghostwhite</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:ghostwhite;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GHOSTWHITE = null;
  /** CSS3 color <code class="prettyprint">gold</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:gold;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GOLD = null;
  /** CSS3 color <code class="prettyprint">goldenrod</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:goldenrod;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GOLDENROD = null;
  /** CSS3 color <code class="prettyprint">gray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:gray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GRAY = null;
  /** CSS3 color <code class="prettyprint">green</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:green;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GREEN = null;
  /** CSS3 color <code class="prettyprint">greenyellow</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:greenyellow;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GREENYELLOW = null;
  /** CSS3 color <code class="prettyprint">grey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:grey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.GREY = null;
  /** CSS3 color <code class="prettyprint">honeydew</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:honeydew;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.HONEYDEW = null;
  /** CSS3 color <code class="prettyprint">hotpink</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:hotpink;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.HOTPINK = null;
  /** CSS3 color <code class="prettyprint">indianred</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:indianred;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.INDIANRED = null;
  /** CSS3 color <code class="prettyprint">indigo</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:indigo;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.INDIGO = null;
  /** CSS3 color <code class="prettyprint">ivory</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:ivory;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.IVORY = null;
  /** CSS3 color <code class="prettyprint">khaki</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:khaki;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.KHAKI = null;
  /** CSS3 color <code class="prettyprint">lavender</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lavender;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LAVENDER = null;
  /** CSS3 color <code class="prettyprint">lavenderblush</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lavenderblush;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LAVENDERBLUSH = null;
  /** CSS3 color <code class="prettyprint">lawngreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lawngreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LAWNGREEN = null;
  /** CSS3 color <code class="prettyprint">lemonchiffon</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lemonchiffon;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LEMONCHIFFON = null;
  /** CSS3 color <code class="prettyprint">lightblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTBLUE = null;
  /** CSS3 color <code class="prettyprint">lightcoral</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightcoral;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTCORAL = null;
  /** CSS3 color <code class="prettyprint">lightcyan</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightcyan;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTCYAN = null;
  /** CSS3 color <code class="prettyprint">lightgoldenrodyellow</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightgoldenrodyellow;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTGOLDENRODYELLOW = null;
  /** CSS3 color <code class="prettyprint">lightgray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightgray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTGRAY = null;
  /** CSS3 color <code class="prettyprint">lightgreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightgreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTGREEN = null;
  /** CSS3 color <code class="prettyprint">lightgrey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightgrey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTGREY = null;
  /** CSS3 color <code class="prettyprint">lightpink</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightpink;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTPINK = null;
  /** CSS3 color <code class="prettyprint">lightsalmon</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightsalmon;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTSALMON = null;
  /** CSS3 color <code class="prettyprint">lightseagreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightseagreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTSEAGREEN = null;
  /** CSS3 color <code class="prettyprint">lightskyblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightskyblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTSKYBLUE = null;
  /** CSS3 color <code class="prettyprint">lightslategray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightslategray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTSLATEGRAY = null;
  /** CSS3 color <code class="prettyprint">lightslategrey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightslategrey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTSLATEGREY = null;
  /** CSS3 color <code class="prettyprint">lightsteelblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightsteelblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTSTEELBLUE = null;
  /** CSS3 color <code class="prettyprint">lightyellow</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lightyellow;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIGHTYELLOW = null;
  /** CSS3 color <code class="prettyprint">lime</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:lime;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIME = null;
  /** CSS3 color <code class="prettyprint">limegreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:limegreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LIMEGREEN = null;
  /** CSS3 color <code class="prettyprint">linen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:linen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.LINEN = null;
  /** CSS3 color <code class="prettyprint">magenta</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:magenta;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MAGENTA = null;
  /** CSS3 color <code class="prettyprint">maroon</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:maroon;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MAROON = null;
  /** CSS3 color <code class="prettyprint">mediumaquamarine</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumaquamarine;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMAQUAMARINE = null;
  /** CSS3 color <code class="prettyprint">mediumblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMBLUE = null;
  /** CSS3 color <code class="prettyprint">mediumorchid</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumorchid;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMORCHID = null;
  /** CSS3 color <code class="prettyprint">mediumpurple</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumpurple;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMPURPLE = null;
  /** CSS3 color <code class="prettyprint">mediumseagreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumseagreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMSEAGREEN = null;
  /** CSS3 color <code class="prettyprint">mediumslateblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumslateblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMSLATEBLUE = null;
  /** CSS3 color <code class="prettyprint">mediumspringgreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumspringgreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMSPRINGGREEN = null;
  /** CSS3 color <code class="prettyprint">mediumturquoise</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumturquoise;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMTURQUOISE = null;
  /** CSS3 color <code class="prettyprint">mediumvioletred</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mediumvioletred;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MEDIUMVIOLETRED = null;
  /** CSS3 color <code class="prettyprint">midnightblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:midnightblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MIDNIGHTBLUE = null;
  /** CSS3 color <code class="prettyprint">mintcream</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mintcream;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MINTCREAM = null;
  /** CSS3 color <code class="prettyprint">mistyrose</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:mistyrose;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MISTYROSE = null;
  /** CSS3 color <code class="prettyprint">moccasin</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:moccasin;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.MOCCASIN = null;
  /** CSS3 color <code class="prettyprint">navajowhite</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:navajowhite;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.NAVAJOWHITE = null;
  /** CSS3 color <code class="prettyprint">navy</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:navy;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.NAVY = null;
  /** CSS3 color <code class="prettyprint">oldlace</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:oldlace;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.OLDLACE = null;
  /** CSS3 color <code class="prettyprint">olive</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:olive;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.OLIVE = null;
  /** CSS3 color <code class="prettyprint">olivedrab</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:olivedrab;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.OLIVEDRAB = null;
  /** CSS3 color <code class="prettyprint">orange</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:orange;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ORANGE = null;
  /** CSS3 color <code class="prettyprint">orangered</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:orangered;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ORANGERED = null;
  /** CSS3 color <code class="prettyprint">orchid</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:orchid;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ORCHID = null;
  /** CSS3 color <code class="prettyprint">palegoldenrod</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:palegoldenrod;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PALEGOLDENROD = null;
  /** CSS3 color <code class="prettyprint">palegreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:palegreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PALEGREEN = null;
  /** CSS3 color <code class="prettyprint">paleturquoise</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:paleturquoise;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PALETURQUOISE = null;
  /** CSS3 color <code class="prettyprint">palevioletred</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:palevioletred;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PALEVIOLETRED = null;
  /** CSS3 color <code class="prettyprint">papayawhip</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:papayawhip;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PAPAYAWHIP = null;
  /** CSS3 color <code class="prettyprint">peachpuff</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:peachpuff;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PEACHPUFF = null;
  /** CSS3 color <code class="prettyprint">peru</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:peru;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PERU = null;
  /** CSS3 color <code class="prettyprint">pink</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:pink;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PINK = null;
  /** CSS3 color <code class="prettyprint">plum</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:plum;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PLUM = null;
  /** CSS3 color <code class="prettyprint">powderblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:powderblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.POWDERBLUE = null;
  /** CSS3 color <code class="prettyprint">purple</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:purple;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.PURPLE = null;
  /** CSS3 color <code class="prettyprint">rebeccapurple</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:rebeccapurple;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.REBECCAPURPLE = null;
  /** CSS3 color <code class="prettyprint">red</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:red;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.RED = null;
  /** CSS3 color <code class="prettyprint">rosybrown</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:rosybrown;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ROSYBROWN = null;
  /** CSS3 color <code class="prettyprint">royalblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:royalblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.ROYALBLUE = null;
  /** CSS3 color <code class="prettyprint">saddlebrown</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:saddlebrown;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SADDLEBROWN = null;
  /** CSS3 color <code class="prettyprint">salmon</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:salmon;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SALMON = null;
  /** CSS3 color <code class="prettyprint">sandybrown</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:sandybrown;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SANDYBROWN = null;
  /** CSS3 color <code class="prettyprint">seagreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:seagreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SEAGREEN = null;
  /** CSS3 color <code class="prettyprint">seashell</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:seashell;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SEASHELL = null;
  /** CSS3 color <code class="prettyprint">sienna</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:sienna;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SIENNA = null;
  /** CSS3 color <code class="prettyprint">silver</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:silver;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SILVER = null;
  /** CSS3 color <code class="prettyprint">skyblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:skyblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SKYBLUE = null;
  /** CSS3 color <code class="prettyprint">slateblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:slateblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SLATEBLUE = null;
  /** CSS3 color <code class="prettyprint">slategray</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:slategray;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SLATEGRAY = null;
  /** CSS3 color <code class="prettyprint">slategrey</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:slategrey;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SLATEGREY = null;
  /** CSS3 color <code class="prettyprint">snow</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:snow;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SNOW = null;
  /** CSS3 color <code class="prettyprint">springgreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:springgreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.SPRINGGREEN = null;
  /** CSS3 color <code class="prettyprint">steelblue</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:steelblue;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.STEELBLUE = null;
  /** CSS3 color <code class="prettyprint">tan</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:tan;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.TAN = null;
  /** CSS3 color <code class="prettyprint">teal</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:teal;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.TEAL = null;
  /** CSS3 color <code class="prettyprint">thistle</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:thistle;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.THISTLE = null;
  /** CSS3 color <code class="prettyprint">tomato</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:tomato;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.TOMATO = null;
  /** CSS3 color <code class="prettyprint">turquoise</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:turquoise;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.TURQUOISE = null;
  /** CSS3 color <code class="prettyprint">violet</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:violet;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.VIOLET = null;
  /** CSS3 color <code class="prettyprint">wheat</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:wheat;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.WHEAT = null;
  /** CSS3 color <code class="prettyprint">white</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:white;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.WHITE = null;
  /** CSS3 color <code class="prettyprint">whitesmoke</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:whitesmoke;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.WHITESMOKE = null;
  /** CSS3 color <code class="prettyprint">yellow</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:yellow;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.YELLOW = null;
  /** CSS3 color <code class="prettyprint">yellowgreen</code>
   * <div style="display:inline;padding-left:40px;margin-left:50px;height:15px;width:40px;background:yellowgreen;"/></div>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.YELLOWGREEN = null;
  /** CSS3 color <code class="prettyprint">transparent</code>
   * @type {Color}
   * @expose
   * @public
   * @static
   * @memberof Color
   */
  Color.TRANSPARENT = null;

  /*-----------------------------------------------------------------------*/
  /*     Internal supporting functions below this point                    */
  /*-----------------------------------------------------------------------*/
  /**
   * Converts a valid CSS3 color specification string (exc. named colors), or
   * an object of the forms {r:, g:, b:}, {h:, s:, l:}, or {h", s:, v:} with
   * optional "a" property, to an object with validated r,g,b properties.
   * Invalid syntax causes an error to be thrown.
   *
   * Example input:
   *  "#f00" or "f00"
   *  "#ff0000" or "ff0000"
   *  "rgb 255 0 0" or "rgb (255, 0, 0)"
   *  "rgb 1.0 0 0" or "rgb (1, 0, 0)"
   *  "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
   *  "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
   *  "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
   *  "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
   *  "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
   *
   *  Note: when converting from hsl or hsv, the resulting r,g,b components may be fractional
   *       e.g.  hsla(0, 97%,37%,0.851) will return the following
   *             r = 185.8695, g = 2.8305, b = 2.8305, a = 0.851
   * @memberof Color
   * @returns {Object} color object
   * @private
   */
  function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;

    if (typeof color === 'string') {
      // eslint-disable-next-line no-param-reassign
      color = stringInputToObject(color); // convert to {"r":, "g":, "b":} or {"h":, "s":, l}, or {"h":, "s":, "v":}
    }

    if (typeof color === 'object') {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
      }

      if (typeof color.a !== 'undefined') {
        a = color.a;
      }
    }

    if (!ok) {
      throw new Error('Invalid Color format');
    }

    a = boundAlpha(a);
    return {
      r: mathMin(255, mathMax(rgb.r, 0)),
      g: mathMin(255, mathMax(rgb.g, 0)),
      b: mathMin(255, mathMax(rgb.b, 0)),
      a: a
    };
  }

  /**
   * @param {Color} co The color object
   * @returns {string} rgb string
   * @memberof Color
   * @private
   */
  function toRgbString(co) {
    var b = co._a < 1;
    return (
      'rgb' +
      (b ? 'a(' : '(') +
      mathRound(co._r) +
      ', ' +
      mathRound(co._g) +
      ', ' +
      mathRound(co._b) +
      (b ? ', ' + co._a : '') +
      ')'
    );
  }

  /*---------------------------------------------------------------------------*/
  /*               Color conversion supporting functions                       */
  /*---------------------------------------------------------------------------*/
  /*  <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-                */
  /*                          color-model-conversion-algorithms-in-javascript> */
  /*---------------------------------------------------------------------------*/
  /**
   * Converts an RGB color value to RGB.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the r,g,b values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  r, g, b in [0, 255] or [0, 1]
   * @param {number} r the red value
   * @param {number} g the green value
   * @param {number} b the blue value
   * @returns {Object} Object with properties r, g, and b, in [0, 255].
   * @memberof Color
   * @private
   */
  function rgbToRgb(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  }

  /**
   * Converts an RGB color value to HSL.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the h,s,l values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  r, g, b in [0, 255] or [0, 1]
   * @param {number} r the red value
   * @param {number} g the green value
   * @param {number} b the blue value
   * @returns {Object} Object with properties h, s, l, in [0, 1].
   * @memberof Color
   * @private
   */
  /* Unused
    function rgbToHsl(r, g, b) {
      // eslint-disable-next-line no-param-reassign
      r = bound01(r, 255);
      // eslint-disable-next-line no-param-reassign
      g = bound01(g, 255);
      // eslint-disable-next-line no-param-reassign
      b = bound01(b, 255);

      var max = mathMax(r, g, b);
      var min = mathMin(r, g, b);
      var h;
      var s;
      var l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
      }

      return { h: h, s: s, l: l };
    }
    */

  /**
   * Converts an HSL color value to RGB.
   * Handle bounds/percentage checking to conform to CSS color spec, and returns
   * an object containg the r,g,b values.
   * <http://www.w3.org/TR/css3-color/>
   * Assumes:  h is contained in [0,1] or [0,360, and s an l are contained in [0, 1] or [0, 100]
   * @param {number} h the hue value
   * @param {number} s the saturation value
   * @param {number} l the lightness value
   * @returns {Object} Object with properties r, g, b, in [0, 255].
   * @memberof Color
   * @private
   */
  function hslToRgb(h, s, l) {
    var r;
    var g;
    var b;

    // eslint-disable-next-line no-param-reassign
    h = bound01(h, 360);
    // eslint-disable-next-line no-param-reassign
    s = bound01(s, 100);
    // eslint-disable-next-line no-param-reassign
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
      // eslint-disable-next-line no-param-reassign
      if (t < 0) t += 1;
      // eslint-disable-next-line no-param-reassign
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    if (s === 0) {
      // achromatic
      r = l;
      g = l;
      b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
  }

  /**
   * Converts an HSV color value to RGB.
   * Assumes: h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
   * @returns {Object} An object with properties  r, g, b  in the set [0,255]
   * @memberof Color
   * @private
   */
  function hsvToRgb(h, s, v) {
    // eslint-disable-next-line no-param-reassign
    h = bound01(h, 360) * 6;
    // eslint-disable-next-line no-param-reassign
    s = bound01(s, 100);
    // eslint-disable-next-line no-param-reassign
    v = bound01(v, 100);

    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
  }

  /**
   * @memberof Color
   * @private
   * @return {void}
   */
  function _initColorConstants() {
    Object.defineProperty(Color, 'ALICEBLUE', { writable: false, value: new Color('f0f8ff') });
    Object.defineProperty(Color, 'ANTIQUEWHITE', { writable: false, value: new Color('faebd7') });
    Object.defineProperty(Color, 'AQUA', { writable: false, value: new Color('0ff') });
    Object.defineProperty(Color, 'AQUAMARINE', { writable: false, value: new Color('7fffd4') });
    Object.defineProperty(Color, 'AZURE', { writable: false, value: new Color('f0ffff') });
    Object.defineProperty(Color, 'BEIGE', { writable: false, value: new Color('f5f5dc') });
    Object.defineProperty(Color, 'BISQUE', { writable: false, value: new Color('ffe4c4') });
    Object.defineProperty(Color, 'BLACK', { writable: false, value: new Color('000') });
    Object.defineProperty(Color, 'BLANCHEDALMOND', { writable: false, value: new Color('ffebcd') });
    Object.defineProperty(Color, 'BLUE', { writable: false, value: new Color('00f') });
    Object.defineProperty(Color, 'BLUEVIOLET', { writable: false, value: new Color('8a2be2') });
    Object.defineProperty(Color, 'BROWN', { writable: false, value: new Color('a52a2a') });
    Object.defineProperty(Color, 'BURLYWOOD', { writable: false, value: new Color('deb887') });
    Object.defineProperty(Color, 'CADETBLUE', { writable: false, value: new Color('5f9ea0') });
    Object.defineProperty(Color, 'CHARTREUSE', { writable: false, value: new Color('7fff00') });
    Object.defineProperty(Color, 'CHOCOLATE', { writable: false, value: new Color('d2691e') });
    Object.defineProperty(Color, 'CORAL', { writable: false, value: new Color('ff7f50') });
    Object.defineProperty(Color, 'CORNFLOWERBLUE', { writable: false, value: new Color('6495ed') });
    Object.defineProperty(Color, 'CORNSILK', { writable: false, value: new Color('fff8dc') });
    Object.defineProperty(Color, 'CRIMSON', { writable: false, value: new Color('dc143c') });
    Object.defineProperty(Color, 'CYAN', { writable: false, value: new Color('0ff') });
    Object.defineProperty(Color, 'DARKBLUE', { writable: false, value: new Color('00008b') });
    Object.defineProperty(Color, 'DARKCYAN', { writable: false, value: new Color('008b8b') });
    Object.defineProperty(Color, 'DARKGOLDENROD', { writable: false, value: new Color('b8860b') });
    Object.defineProperty(Color, 'DARKGRAY', { writable: false, value: new Color('a9a9a9') });
    Object.defineProperty(Color, 'DARKGREY', { writable: false, value: new Color('a9a9a9') });
    Object.defineProperty(Color, 'DARKGREEN', { writable: false, value: new Color('006400') });
    Object.defineProperty(Color, 'DARKKHAKI', { writable: false, value: new Color('bdb76b') });
    Object.defineProperty(Color, 'DARKMAGENTA', { writable: false, value: new Color('8b008b') });
    Object.defineProperty(Color, 'DARKOLIVEGREEN', { writable: false, value: new Color('556b2f') });
    Object.defineProperty(Color, 'DARKORANGE', { writable: false, value: new Color('ff8c00') });
    Object.defineProperty(Color, 'DARKORCHID', { writable: false, value: new Color('9932cc') });
    Object.defineProperty(Color, 'DARKRED', { writable: false, value: new Color('8b0000') });
    Object.defineProperty(Color, 'DARKSALMON', { writable: false, value: new Color('e9967a') });
    Object.defineProperty(Color, 'DARKSEAGREEN', { writable: false, value: new Color('8fbc8f') });
    Object.defineProperty(Color, 'DARKSLATEBLUE', { writable: false, value: new Color('483d8b') });
    Object.defineProperty(Color, 'DARKSLATEGRAY', { writable: false, value: new Color('2f4f4f') });
    Object.defineProperty(Color, 'DARKSLATEGREY', { writable: false, value: new Color('2f4f4f') });
    Object.defineProperty(Color, 'DARKTURQUOISE', { writable: false, value: new Color('00ced1') });
    Object.defineProperty(Color, 'DARKVIOLET', { writable: false, value: new Color('9400d3') });
    Object.defineProperty(Color, 'DEEPPINK', { writable: false, value: new Color('ff1493') });
    Object.defineProperty(Color, 'DEEPSKYBLUE', { writable: false, value: new Color('00bfff') });
    Object.defineProperty(Color, 'DIMGRAY', { writable: false, value: new Color('696969') });
    Object.defineProperty(Color, 'DIMGREY', { writable: false, value: new Color('696969') });
    Object.defineProperty(Color, 'DODGERBLUE', { writable: false, value: new Color('1e90ff') });
    Object.defineProperty(Color, 'FIREBRICK', { writable: false, value: new Color('b22222') });
    Object.defineProperty(Color, 'FLORALWHITE', { writable: false, value: new Color('fffaf0') });
    Object.defineProperty(Color, 'FORESTGREEN', { writable: false, value: new Color('228b22') });
    Object.defineProperty(Color, 'FUCHSIA', { writable: false, value: new Color('f0f') });
    Object.defineProperty(Color, 'GAINSBORO', { writable: false, value: new Color('dcdcdc') });
    Object.defineProperty(Color, 'GHOSTWHITE', { writable: false, value: new Color('f8f8ff') });
    Object.defineProperty(Color, 'GOLD', { writable: false, value: new Color('ffd700') });
    Object.defineProperty(Color, 'GOLDENROD', { writable: false, value: new Color('daa520') });
    Object.defineProperty(Color, 'GRAY', { writable: false, value: new Color('808080') });
    Object.defineProperty(Color, 'GREY', { writable: false, value: new Color('808080') });
    Object.defineProperty(Color, 'GREEN', { writable: false, value: new Color('008000') });
    Object.defineProperty(Color, 'GREENYELLOW', { writable: false, value: new Color('adff2f') });
    Object.defineProperty(Color, 'HONEYDEW', { writable: false, value: new Color('f0fff0') });
    Object.defineProperty(Color, 'HOTPINK', { writable: false, value: new Color('ff69b4') });
    Object.defineProperty(Color, 'INDIANRED', { writable: false, value: new Color('cd5c5c') });
    Object.defineProperty(Color, 'INDIGO', { writable: false, value: new Color('4b0082') });
    Object.defineProperty(Color, 'IVORY', { writable: false, value: new Color('fffff0') });
    Object.defineProperty(Color, 'KHAKI', { writable: false, value: new Color('f0e68c') });
    Object.defineProperty(Color, 'LAVENDER', { writable: false, value: new Color('e6e6fa') });
    Object.defineProperty(Color, 'LAVENDERBLUSH', { writable: false, value: new Color('fff0f5') });
    Object.defineProperty(Color, 'LAWNGREEN', { writable: false, value: new Color('7cfc00') });
    Object.defineProperty(Color, 'LEMONCHIFFON', { writable: false, value: new Color('fffacd') });
    Object.defineProperty(Color, 'LIGHTBLUE', { writable: false, value: new Color('add8e6') });
    Object.defineProperty(Color, 'LIGHTCORAL', { writable: false, value: new Color('f08080') });
    Object.defineProperty(Color, 'LIGHTCYAN', { writable: false, value: new Color('e0ffff') });
    Object.defineProperty(Color, 'LIGHTGOLDENRODYELLOW', {
      writable: false,
      value: new Color('fafad2')
    });
    Object.defineProperty(Color, 'LIGHTGRAY', { writable: false, value: new Color('d3d3d3') });
    Object.defineProperty(Color, 'LIGHTGREY', { writable: false, value: new Color('d3d3d3') });
    Object.defineProperty(Color, 'LIGHTGREEN', { writable: false, value: new Color('90ee90') });
    Object.defineProperty(Color, 'LIGHTPINK', { writable: false, value: new Color('ffb6c1') });
    Object.defineProperty(Color, 'LIGHTSALMON', { writable: false, value: new Color('ffa07a') });
    Object.defineProperty(Color, 'LIGHTSEAGREEN', { writable: false, value: new Color('20b2aa') });
    Object.defineProperty(Color, 'LIGHTSKYBLUE', { writable: false, value: new Color('87cefa') });
    Object.defineProperty(Color, 'LIGHTSLATEGRAY', { writable: false, value: new Color('789') });
    Object.defineProperty(Color, 'LIGHTSLATEGREY', { writable: false, value: new Color('789') });
    Object.defineProperty(Color, 'LIGHTSTEELBLUE', { writable: false, value: new Color('b0c4de') });
    Object.defineProperty(Color, 'LIGHTYELLOW', { writable: false, value: new Color('ffffe0') });
    Object.defineProperty(Color, 'LIME', { writable: false, value: new Color('0f0') });
    Object.defineProperty(Color, 'LIMEGREEN', { writable: false, value: new Color('32cd32') });
    Object.defineProperty(Color, 'LINEN', { writable: false, value: new Color('faf0e6') });
    Object.defineProperty(Color, 'MAGENTA', { writable: false, value: new Color('f0f') });
    Object.defineProperty(Color, 'MAROON', { writable: false, value: new Color('800000') });
    Object.defineProperty(Color, 'MEDIUMAQUAMARINE', { writable: false, value: new Color('66cdaa') });
    Object.defineProperty(Color, 'MEDIUMBLUE', { writable: false, value: new Color('0000cd') });
    Object.defineProperty(Color, 'MEDIUMORCHID', { writable: false, value: new Color('ba55d3') });
    Object.defineProperty(Color, 'MEDIUMPURPLE', { writable: false, value: new Color('9370db') });
    Object.defineProperty(Color, 'MEDIUMSEAGREEN', { writable: false, value: new Color('3cb371') });
    Object.defineProperty(Color, 'MEDIUMSLATEBLUE', { writable: false, value: new Color('7b68ee') });
    Object.defineProperty(Color, 'MEDIUMSPRINGGREEN', {
      writable: false,
      value: new Color('00fa9a')
    });
    Object.defineProperty(Color, 'MEDIUMTURQUOISE', { writable: false, value: new Color('48d1cc') });
    Object.defineProperty(Color, 'MEDIUMVIOLETRED', { writable: false, value: new Color('c71585') });
    Object.defineProperty(Color, 'MIDNIGHTBLUE', { writable: false, value: new Color('191970') });
    Object.defineProperty(Color, 'MINTCREAM', { writable: false, value: new Color('f5fffa') });
    Object.defineProperty(Color, 'MISTYROSE', { writable: false, value: new Color('ffe4e1') });
    Object.defineProperty(Color, 'MOCCASIN', { writable: false, value: new Color('ffe4b5') });
    Object.defineProperty(Color, 'NAVAJOWHITE', { writable: false, value: new Color('ffdead') });
    Object.defineProperty(Color, 'NAVY', { writable: false, value: new Color('000080') });
    Object.defineProperty(Color, 'OLDLACE', { writable: false, value: new Color('fdf5e6') });
    Object.defineProperty(Color, 'OLIVE', { writable: false, value: new Color('808000') });
    Object.defineProperty(Color, 'OLIVEDRAB', { writable: false, value: new Color('6b8e23') });
    Object.defineProperty(Color, 'ORANGE', { writable: false, value: new Color('ffa500') });
    Object.defineProperty(Color, 'ORANGERED', { writable: false, value: new Color('ff4500') });
    Object.defineProperty(Color, 'ORCHID', { writable: false, value: new Color('da70d6') });
    Object.defineProperty(Color, 'PALEGOLDENROD', { writable: false, value: new Color('eee8aa') });
    Object.defineProperty(Color, 'PALEGREEN', { writable: false, value: new Color('98fb98') });
    Object.defineProperty(Color, 'PALETURQUOISE', { writable: false, value: new Color('afeeee') });
    Object.defineProperty(Color, 'PALEVIOLETRED', { writable: false, value: new Color('db7093') });
    Object.defineProperty(Color, 'PAPAYAWHIP', { writable: false, value: new Color('ffefd5') });
    Object.defineProperty(Color, 'PEACHPUFF', { writable: false, value: new Color('ffdab9') });
    Object.defineProperty(Color, 'PERU', { writable: false, value: new Color('cd853f') });
    Object.defineProperty(Color, 'PINK', { writable: false, value: new Color('ffc0cb') });
    Object.defineProperty(Color, 'PLUM', { writable: false, value: new Color('dda0dd') });
    Object.defineProperty(Color, 'POWDERBLUE', { writable: false, value: new Color('b0e0e6') });
    Object.defineProperty(Color, 'PURPLE', { writable: false, value: new Color('800080') });
    Object.defineProperty(Color, 'REBECCAPURPLE', { writable: false, value: new Color('663399') });
    Object.defineProperty(Color, 'RED', { writable: false, value: new Color('f00') });
    Object.defineProperty(Color, 'ROSYBROWN', { writable: false, value: new Color('bc8f8f') });
    Object.defineProperty(Color, 'ROYALBLUE', { writable: false, value: new Color('4169e1') });
    Object.defineProperty(Color, 'SADDLEBROWN', { writable: false, value: new Color('8b4513') });
    Object.defineProperty(Color, 'SALMON', { writable: false, value: new Color('fa8072') });
    Object.defineProperty(Color, 'SANDYBROWN', { writable: false, value: new Color('f4a460') });
    Object.defineProperty(Color, 'SEAGREEN', { writable: false, value: new Color('2e8b57') });
    Object.defineProperty(Color, 'SEASHELL', { writable: false, value: new Color('fff5ee') });
    Object.defineProperty(Color, 'SIENNA', { writable: false, value: new Color('a0522d') });
    Object.defineProperty(Color, 'SILVER', { writable: false, value: new Color('c0c0c0') });
    Object.defineProperty(Color, 'SKYBLUE', { writable: false, value: new Color('87ceeb') });
    Object.defineProperty(Color, 'SLATEBLUE', { writable: false, value: new Color('6a5acd') });
    Object.defineProperty(Color, 'SLATEGRAY', { writable: false, value: new Color('708090') });
    Object.defineProperty(Color, 'SLATEGREY', { writable: false, value: new Color('708090') });
    Object.defineProperty(Color, 'SNOW', { writable: false, value: new Color('fffafa') });
    Object.defineProperty(Color, 'SPRINGGREEN', { writable: false, value: new Color('00ff7f') });
    Object.defineProperty(Color, 'STEELBLUE', { writable: false, value: new Color('4682b4') });
    Object.defineProperty(Color, 'TAN', { writable: false, value: new Color('d2b48c') });
    Object.defineProperty(Color, 'TEAL', { writable: false, value: new Color('008080') });
    Object.defineProperty(Color, 'THISTLE', { writable: false, value: new Color('d8bfd8') });
    Object.defineProperty(Color, 'TOMATO', { writable: false, value: new Color('ff6347') });
    Object.defineProperty(Color, 'TURQUOISE', { writable: false, value: new Color('40e0d0') });
    Object.defineProperty(Color, 'VIOLET', { writable: false, value: new Color('ee82ee') });
    Object.defineProperty(Color, 'WHEAT', { writable: false, value: new Color('f5deb3') });
    Object.defineProperty(Color, 'WHITE', { writable: false, value: new Color('fff') });
    Object.defineProperty(Color, 'WHITESMOKE', { writable: false, value: new Color('f5f5f5') });
    Object.defineProperty(Color, 'YELLOW', { writable: false, value: new Color('ff0') });
    Object.defineProperty(Color, 'YELLOWGREEN', { writable: false, value: new Color('9acd32') });

    Object.defineProperty(Color, 'TRANSPARENT', {
      writable: false,
      value: new Color('rgba(0,0,0,0)')
    });
  }

  /**
   * Returns a valid alpha value [0);1] with all invalid values being set to 1
   * @param {number} a alpha value
   * @returns {number} alpha value
   * @memberof Color
   * @private
   */
  function boundAlpha(a) {
    var _a = parseFloat(a);

    if (isNaN(_a) || _a < 0 || _a > 1) {
      _a = 1;
    }

    return _a;
  }

  /**
   * Take input from [0, n] and return it as [0, 1]
   * @param {string|number} n The input value
   * @param {number} max The max value
   * @returns {number}
   * @memberof Color
   * @private
   */
  function bound01(n, max) {
    var _n = n;
    if (isOnePointZero(_n)) {
      _n = '100%';
    }

    var processPercent = isPercentage(_n);
    _n = mathMin(max, mathMax(0, parseFloat(_n)));

    // Automatically convert percentage into number
    if (processPercent) {
      _n = parseInt(_n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if (Math.abs(_n - max) < 0.000001) {
      return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (_n % max) / parseFloat(max);
  }

  /**
   * Parse a base-16 hex value into a base-10 integer
   * @param {number} val The input value
   * @returns {number}
   * @memberof Color
   * @private
   */
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }

  /**
   * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
   * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
   * @param {string|number} n The input value
   * @returns {boolean}
   * @memberof Color
   * @private
   */
  function isOnePointZero(n) {
    return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
  }

  /**
   * Returns true if supplied string is a percentage
   * @param {string|number} n The input value
   * @returns {boolean} true if supplied string is a percentage
   * @memberof Color
   * @private
   */
  function isPercentage(n) {
    return typeof n === 'string' && n.indexOf('%') !== -1;
  }

  /**
   * Replace a decimal with it's percentage value
   * @memberof Color
   * @private
   */
  function convertToPercentage(n) {
    var _n = n;
    if (_n <= 1) {
      _n = _n * 100 + '%';
    }

    return _n;
  }
  /**
   * Converts a hex value to a decimal
   * @param {number} h The hex value
   * @memberof Color
   * @private
   */
  /*    Wait for CSS4
    function convertHexToDecimal(h) {
      return (parseIntFromHex(h) / 255);
    }
    */

  var matchers = (function () {
    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = '[-\\+]?\\d+%?';

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 =
      '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
    var PERMISSIVE_MATCH4 =
      '[\\s|\\(]+(' +
      CSS_UNIT +
      ')[,|\\s]+(' +
      CSS_UNIT +
      ')[,|\\s]+(' +
      CSS_UNIT +
      ')[,|\\s]+(' +
      CSS_UNIT +
      ')\\s*\\)?';

    return {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
      rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
      hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
      hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
      hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
      hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
  })();

  /**
   * Accepts a single string/number and checks to see if it looks like a CSS unit
   * (see `matchers` above for definition).
   * @param {string|number} color  The value to check.
   * @returns {boolean} true if valid CSS
   * @memberof Color
   * @private
   */
  function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
  }

  /**
   * Permissive color string parsing.  Takes in a number of formats, and outputs an object
   * based on detected format.
   * @param {string}  color  A CSS color specification string.
   * @return {Object | boolean}  Returns an object with properties r, g, b  or  h, s, l  or  h, s, v,
   *                             or false if parsing failed.
   * @memberof Color
   * @private
   */
  function stringInputToObject(color) {
    // eslint-disable-next-line no-param-reassign
    color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();

    if (color === 'transparent') {
      return { r: 0, g: 0, b: 0, a: 0 };
    }

    // Strategy:
    // 1) Try to match string input using regular expressions.
    // 2) Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // 3) Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the Color is initialized with string or object.
    var match = matchers.rgb.exec(color);
    if (match) {
      return { r: match[1], g: match[2], b: match[3] };
    }
    match = matchers.rgba.exec(color);
    if (match) {
      return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    match = matchers.hsl.exec(color);
    if (match) {
      return { h: match[1], s: match[2], l: match[3] };
    }
    match = matchers.hsla.exec(color);
    if (match) {
      return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    match = matchers.hsv.exec(color);
    if (match) {
      return { h: match[1], s: match[2], v: match[3] };
    }
    match = matchers.hsva.exec(color);
    if (match) {
      return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }

    match = matchers.hex6.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3])
      };
    }
    match = matchers.hex3.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1] + '' + match[1]),
        g: parseIntFromHex(match[2] + '' + match[2]),
        b: parseIntFromHex(match[3] + '' + match[3])
      };
    }
    /*    Wait for CSS4
    if ((match = matchers.hex8.exec(color)))
    {
      return {
               "a": convertHexToDecimal(match[1]),
               "r": parseIntFromHex(match[2]),
               "g": parseIntFromHex(match[3]),
               "b": parseIntFromHex(match[4])
             };
    }
  */

    // console.log("matchers false") ;
    return false;
  }

  _initColorConstants();

  oj._registerLegacyNamespaceProp('Color', Color);

  return Color;

});


define('ojs/ojfilepickerutils',['exports', 'ojs/ojcore-base'], function (exports, oj) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

    /**
     * Contains utility functions intended to be used to pick files
     * @ojmodulecontainer ojfilepickerutils
     * @ojtsmodule
     * @ojhidden
     * @since 10.0.0
     */
    /**
     * This method invokes the native file picking UI.  It invokes the specified callback with the result of the user's selection, if any.
     *
     * @ojexports
     * @memberof ojfilepickerutils
     * @param {Function} callback - Callback function invoked with the result of the user's selection, if any.
     * @param {Object} fileOptions - An object containing the file selection properties including accept, capture, and selection mode.
     * @ojsignature [{target: "Type", value: "FileOptions", jsdocOverride: true, for: "fileOptions"},
     *               {target: "Type", value: "(files:FileList) => void", jsdocOverride: true, for: "callback"}]
     * @method
     * @name pickFiles
     */

    /**
     * @ojexports
     * @typedef {Object} FileOptions
     * @memberof ojfilepickerutils
     * @property {Array.<string>} accept - An array of strings of allowed MIME types or file extensions that can be uploaded. If not specified, all file types will be accepted
     * @property {'user' | 'environment' | 'implementation' | 'none'} capture - Specifies the preferred facing mode for the device's media capture mechanism.  'user', 'environment', and 'implementation' indicates the user-facing, environment-facing, and the implementation-specific cameras will, respectively, be the preferred mode.  Specifying 'none', the default, will indicate that no capture mechanism is used.
     * @property {'single' | 'multiple'} selectionMode - Whether to allow single or multiple file selection.  Single is the default.
     */

    let input;
    const isIOS = oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS;
    const teardownInput = () => {
        if (isIOS)
            document.body.removeChild(input);
        input = null;
    };
    const setupInput = (fileOptions) => {
        if (input)
            teardownInput();
        input = document.createElement('input');
        input.type = 'file';
        if (fileOptions?.capture && fileOptions.capture != 'none') {
            input.capture = fileOptions.capture;
        }
        const acceptProp = fileOptions?.accept;
        const accept = acceptProp && acceptProp.length ? acceptProp.join(',') : null;
        input.accept = accept;
        input.multiple = fileOptions?.selectionMode == 'multiple';
        input.style.display = 'none';
        if (isIOS)
            document.body.appendChild(input);
    };
    function pickFiles(callback, fileOptions) {
        setupInput(fileOptions);
        input.onchange = function () {
            const files = input._pickerTestData ? input._pickerTestData : input.files;
            callback(files);
            teardownInput();
        };
        input.click();
    }

    exports.pickFiles = pickFiles;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojfilepicker',['exports', 'preact/jsx-runtime', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojvcomponent', 'preact', 'ojs/ojtranslation', 'ojs/ojfilepickerutils', 'ojs/ojfocusutils', 'jqueryui-amd/tabbable'], function (exports, jsxRuntime, oj, DomUtils, ojvcomponent, preact, Translations, ojfilepickerutils, FocusUtils, tabbable) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.FilePicker = class FilePicker extends preact.Component {
        constructor(props) {
            super(props);
            this.rootRef = preact.createRef();
            this._handleSelectingFiles = (event) => {
                if (event.type === 'click' ||
                    (event.type === 'keypress' && event.code === 'Enter')) {
                    this.selecting = true;
                    event.preventDefault();
                    const props = this.props;
                    ojfilepickerutils.pickFiles(this._handleFileSelected, {
                        accept: props.accept,
                        selectionMode: props.selectionMode,
                        capture: props.capture ?? 'none'
                    });
                    return true;
                }
                return false;
            };
            this._handleFileSelected = (files) => {
                this._fileSelectedHelper(files);
            };
            this._handleDragEnter = (event) => {
                event.preventDefault();
                event.stopPropagation();
            };
            this._handleDragOver = (event) => {
                event.preventDefault();
                event.stopPropagation();
                const dataTransfer = event.dataTransfer;
                if (this.inDropZone) {
                    return;
                }
                const ai = oj.AgentUtils.getAgentInfo();
                this.inDropZone = true;
                this.isDroppable = true;
                if (ai.browser !== oj.AgentUtils.BROWSER.SAFARI && ai.browser !== oj.AgentUtils.BROWSER.IE) {
                    const files = dataTransfer.items;
                    let messages = [];
                    const selectionModeValid = this._validateSelectionMode(files);
                    const droppable = this._validateTypes(files);
                    if (selectionModeValid && droppable.rejected.length === 0) {
                        this.setState({ validity: 'valid' });
                    }
                    else {
                        this.isDroppable = false;
                        if (selectionModeValid) {
                            messages = this._getMimeTypeValidationMessages(droppable.rejected);
                        }
                        else {
                            messages.push({
                                severity: 'error',
                                summary: Translations.getTranslatedString('oj-ojFilePicker.singleFileUploadError')
                            });
                        }
                        this._fireInvalidSelectAction(messages, event, true);
                    }
                }
                else {
                    this.setState({ validity: 'valid' });
                }
            };
            this._handleDragLeave = (event, mimeTypeDropFail = false) => {
                if (!this.inDropZone) {
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
                if (!this.rootRef.current.contains(event.relatedTarget)) {
                    this.inDropZone = false;
                    this.setState({ validity: 'NA' });
                    if (!this.isDroppable && !mimeTypeDropFail) {
                        this.dragPromiseResolver();
                        this.dragPromiseResolver = null;
                    }
                }
            };
            this._handleFileDrop = (event) => {
                if (this.inDropZone) {
                    event.preventDefault();
                    event.stopPropagation();
                    const files = this._createFileList(event.dataTransfer.files);
                    let mimeTypeDropFail = false;
                    if (this.isDroppable) {
                        let messages = [];
                        if (this._validateSelectionMode(files)) {
                            const droppable = this._validateTypes(files);
                            if (droppable.rejected.length > 0) {
                                messages = this._getMimeTypeValidationMessages(droppable.rejected);
                                mimeTypeDropFail = true;
                            }
                        }
                        else {
                            messages.push({
                                severity: 'error',
                                summary: Translations.getTranslatedString('oj-ojFilePicker.singleFileUploadError')
                            });
                        }
                        if (messages.length > 0) {
                            this.isDroppable = false;
                            this._fireInvalidSelectAction(messages, event, false);
                        }
                        if (this.isDroppable) {
                            this._handleFilesAdded(files, event);
                        }
                    }
                    this._handleDragLeave(event, mimeTypeDropFail);
                }
            };
            this._handleFocusIn = (event) => {
                if (event.target === event.currentTarget) {
                    this._handleFocus(event);
                }
                if (this.selecting) {
                    return;
                }
                this.setState({ focus: !DomUtils.recentPointer() });
            };
            this._handleFocusOut = (event) => {
                if (event.target === event.currentTarget) {
                    this._handleBlur(event);
                }
                if (this.selecting) {
                    return;
                }
                this.setState({ focus: false });
            };
            this._handleFocus = (event) => {
                this.rootRef.current?.dispatchEvent(new FocusEvent('focus', { relatedTarget: event.relatedTarget }));
            };
            this._handleBlur = (event) => {
                this.rootRef.current?.dispatchEvent(new FocusEvent('blur', { relatedTarget: event.relatedTarget }));
            };
            this.state = {
                focus: false,
                validity: 'NA'
            };
        }
        _fileSelectedHelper(files) {
            if (files.length > 0) {
                const rejected = this._validateTypes(files).rejected;
                if (rejected.length > 0) {
                    this._fireInvalidSelectAction(this._getMimeTypeValidationMessages(rejected), null, false);
                }
                else {
                    this._handleFilesAdded(files, null);
                }
            }
            this.selecting = false;
        }
        focus() {
            FocusUtils.focusFirstTabStop(this.rootRef.current);
        }
        blur() {
            const focusElement = document.activeElement;
            if (this.rootRef.current.contains(focusElement)) {
                focusElement.blur();
            }
        }
        render(props) {
            const triggerSlot = props.trigger;
            if (props.disabled) {
                return this._renderDisabled(props, triggerSlot);
            }
            const clickHandler = props.selectOn !== 'drop' ? this._handleSelectingFiles : undefined;
            return triggerSlot
                ? this._renderWithCustomTrigger(props, triggerSlot, clickHandler)
                : this._renderWithDefaultTrigger(props, clickHandler);
        }
        _renderDisabled(props, triggerSlot) {
            const rootClasses = triggerSlot ? 'oj-filepicker' : 'oj-filepicker oj-filepicker-no-trigger';
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: rootClasses, children: jsxRuntime.jsx("div", { class: "oj-filepicker-disabled oj-filepicker-container", children: triggerSlot || this._renderDefaultTriggerContent(props) }) }));
        }
        _renderWithCustomTrigger(props, triggerSlot, clickHandler) {
            const dndHandlers = this._getDndHandlers(props);
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: `oj-filepicker ${this._getFocusClass()}`, ref: this.rootRef, onfocusin: this._handleFocusIn, onfocusout: this._handleFocusOut, children: jsxRuntime.jsx("div", { onClick: clickHandler, onKeyPress: this._handleSelectingFiles, onDragEnter: dndHandlers.handleDragEnter, onDragOver: dndHandlers.handleDragOver, onDragLeave: dndHandlers.handleDragLeave, onDragEnd: dndHandlers.handleDragLeave, onDrop: dndHandlers.handleFileDrop, class: "oj-filepicker-container", "aria-label": this._getAriaLabel(props, clickHandler), role: this._getRole(props, clickHandler), children: triggerSlot }) }));
        }
        _renderWithDefaultTrigger(props, clickHandler) {
            const validity = this.state.validity;
            const validityState = validity === 'valid' ? 'oj-valid-drop' : validity === 'invalid' ? 'oj-invalid-drop' : '';
            const dndHandlers = this._getDndHandlers(props);
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: `oj-filepicker oj-filepicker-no-trigger ${this._getFocusClass()}`, onfocusin: this._handleFocusIn, onfocusout: this._handleFocusOut, ref: this.rootRef, children: jsxRuntime.jsx("div", { onClick: clickHandler, onKeyPress: this._handleSelectingFiles, class: 'oj-filepicker-container', tabIndex: 0, "aria-label": this._getAriaLabel(props, clickHandler), role: this._getRole(props, clickHandler), children: jsxRuntime.jsx("div", { class: `oj-filepicker-dropzone ${validityState}`, onDragEnter: dndHandlers.handleDragEnter, onDragOver: dndHandlers.handleDragOver, onDragLeave: dndHandlers.handleDragLeave, onDragEnd: dndHandlers.handleDragLeave, onDrop: dndHandlers.handleFileDrop, children: this._renderDefaultTriggerContent(props) }) }) }));
        }
        _renderDefaultTriggerContent(props) {
            return [
                jsxRuntime.jsx("div", { class: "oj-filepicker-text", children: this._getPrimaryText(props) }),
                jsxRuntime.jsx("div", { class: "oj-filepicker-secondary-text", children: this._getSecondaryText(props) })
            ];
        }
        _getRole(props, clickHandler) {
            const defaultRole = clickHandler ? 'button' : undefined;
            return props['role'] ? props['role'] : defaultRole;
        }
        _getAriaLabel(props, clickHandler) {
            const defaultLabel = clickHandler
                ? props.trigger
                    ? 'Add Files.'
                    : `Add Files. ${this._getPrimaryText(props)}. ${this._getSecondaryText(props)}`
                : undefined;
            return props['aria-label'] ? props['aria-label'] : defaultLabel;
        }
        _getPrimaryText(props) {
            const primary = props.primaryText;
            let primaryText;
            if (primary) {
                if (typeof primary === 'string') {
                    primaryText = primary;
                }
                else {
                    const primaryFunc = primary;
                    primaryText = primaryFunc();
                }
            }
            else {
                primaryText = Translations.getTranslatedString('oj-ojFilePicker.dropzonePrimaryText');
            }
            return primaryText;
        }
        _getSecondaryText(props) {
            const isSingle = props.selectionMode === 'single';
            const secondary = props.secondaryText;
            let secondaryText;
            if (secondary) {
                if (typeof secondary === 'string') {
                    secondaryText = secondary;
                }
                else {
                    const secondaryFunc = secondary;
                    secondaryText = secondaryFunc({ selectionMode: props.selectionMode });
                }
            }
            else {
                secondaryText = Translations.getTranslatedString(isSingle
                    ? 'oj-ojFilePicker.secondaryDropzoneText'
                    : 'oj-ojFilePicker.secondaryDropzoneTextMultiple');
            }
            return secondaryText;
        }
        _getDndHandlers(props) {
            return props.selectOn !== 'click'
                ? {
                    handleDragEnter: this._handleDragEnter,
                    handleDragOver: this._handleDragOver,
                    handleDragLeave: this._handleDragLeave,
                    handleFileDrop: this._handleFileDrop
                }
                : {};
        }
        _getFocusClass() {
            return this.state.focus ? 'oj-focus-highlight' : '';
        }
        _validateSelectionMode(files) {
            return this.props.selectionMode !== 'single' || files.length === 1;
        }
        _validateTypes(files) {
            const accepted = [];
            const rejected = [];
            let file;
            let type;
            if (files) {
                for (let i = 0; i < files.length; i++) {
                    file = files[i];
                    const name = file.name;
                    type = Translations.getTranslatedString('oj-ojFilePicker.unknownFileType');
                    if (name) {
                        let nameSplit = name.split('.');
                        type = nameSplit.length > 1 ? '.' + nameSplit.pop() : type;
                    }
                    type = file.type ? file.type : type;
                    if (accepted.indexOf(type) === -1 && rejected.indexOf(type) === -1) {
                        if (this._acceptFile(file)) {
                            accepted.push(type);
                        }
                        else {
                            rejected.push(type);
                        }
                    }
                }
            }
            return { accepted, rejected };
        }
        _getMimeTypeValidationMessages(rejected) {
            const messages = [];
            if (rejected.length === 1) {
                messages.push({
                    severity: 'error',
                    summary: Translations.getTranslatedString('oj-ojFilePicker.singleFileTypeUploadError', {
                        fileType: rejected[0]
                    })
                });
            }
            else {
                messages.push({
                    severity: 'error',
                    summary: Translations.getTranslatedString('oj-ojFilePicker.multipleFileTypeUploadError', {
                        fileTypes: rejected.join(Translations.getTranslatedString('oj-converter.plural-separator'))
                    })
                });
            }
            return messages;
        }
        _acceptFile(file) {
            const acceptProp = this.props.accept;
            if (!acceptProp || acceptProp.length === 0 || !file) {
                return true;
            }
            let accept;
            for (let i = 0; i < acceptProp.length; i++) {
                accept = oj.StringUtils.trim(acceptProp[i]);
                if (!accept) {
                    return true;
                }
                else if (accept.startsWith('.', 0)) {
                    if (!file.name || (file.name && file.name.toLowerCase().endsWith(accept.toLowerCase()))) {
                        return true;
                    }
                }
                else if (!file.type) {
                    return false;
                }
                else if (accept === 'image/*') {
                    if (file.type.startsWith('image/', 0)) {
                        return true;
                    }
                }
                else if (accept === 'video/*') {
                    if (file.type.startsWith('video/', 0)) {
                        return true;
                    }
                }
                else if (accept === 'audio/*') {
                    if (file.type.startsWith('audio/', 0)) {
                        return true;
                    }
                }
                else if (file.type === accept) {
                    return true;
                }
            }
            return false;
        }
        _handleFilesAdded(files, oEvent) {
            const list = this._createFileList(files);
            this.props.onOjBeforeSelect?.({ files: list, originalEvent: oEvent }).then(() => {
                this.props.onOjSelect?.({
                    files: list,
                    originalEvent: oEvent
                });
                if (this.elementPromiseResolver) {
                    this.elementPromiseResolver();
                    this.elementPromiseResolver = null;
                }
            }, (messages) => {
                this._fireInvalidSelectAction(messages, oEvent, false);
            });
        }
        _fireInvalidSelectAction(messages, oEvent, isDrag) {
            if (isDrag) {
                this.setState({ validity: 'invalid' });
            }
            const dragPromise = isDrag
                ? new Promise((resolve) => {
                    this.dragPromiseResolver = resolve;
                })
                : null;
            this.props.onOjInvalidSelect?.({
                messages,
                originalEvent: oEvent,
                until: dragPromise
            });
            if (this.elementPromiseResolver) {
                this.elementPromiseResolver();
                this.elementPromiseResolver = null;
            }
        }
        _createFileList(origList) {
            const descriptor = {
                length: { value: origList.length },
                item: {
                    value(index) {
                        return this[index];
                    }
                }
            };
            for (let i = 0; i < origList.length; i++) {
                descriptor[i] = { value: origList[i], enumerable: true };
            }
            return Object.create(FileList.prototype, descriptor);
        }
    };
    exports.FilePicker.defaultProps = {
        accept: null,
        capture: 'none',
        disabled: false,
        selectOn: 'auto',
        selectionMode: 'multiple'
    };
    exports.FilePicker._metadata = { "properties": { "accept": { "type": "Array<string>" }, "capture": { "type": "string", "enumValues": ["none", "environment", "user", "implementation"] }, "disabled": { "type": "boolean" }, "primaryText": { "type": "string|function" }, "secondaryText": { "type": "string|function" }, "selectOn": { "type": "string", "enumValues": ["auto", "click", "drop", "clickAndDrop"] }, "selectionMode": { "type": "string", "enumValues": ["multiple", "single"] } }, "slots": { "trigger": {} }, "events": { "ojBeforeSelect": { "cancelable": true }, "ojInvalidSelect": {}, "ojSelect": {} }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-label", "role"] }, "methods": { "focus": {}, "blur": {} } };
    exports.FilePicker = __decorate([
        ojvcomponent.customElement('oj-file-picker')
    ], exports.FilePicker);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojselectbase',['exports', 'ojs/ojeditablevalue', 'ojs/ojpopupcore', 'ojs/ojinputtext', 'ojs/ojlistview', 'ojs/ojhighlighttext', 'ojs/ojcore-base', 'jquery', 'ojs/ojdomutils', 'ojs/ojlogger', 'ojs/ojconfig', 'ojs/ojthemeutils', 'ojs/ojfocusutils', 'ojs/ojdataprovider', 'ojs/ojcontext', 'ojs/ojcomponentcore', 'ojs/ojkeyset', 'ojs/ojcustomelement-utils', 'ojs/ojdataproviderfactory', 'ojs/ojlistdataproviderview', 'ojs/ojtreedataproviderview', 'ojs/ojtimerutils'], function (exports, ojeditablevalue, ojpopupcore, ojinputtext, ojlistview, ojhighlighttext, oj, $, DomUtils, Logger, Config, ThemeUtils, FocusUtils, ojdataprovider, Context, ojcomponentcore, ojkeyset, ojcustomelementUtils, ojdataproviderfactory, ListDataProviderView, TreeDataProviderView, TimerUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  ListDataProviderView = ListDataProviderView && Object.prototype.hasOwnProperty.call(ListDataProviderView, 'default') ? ListDataProviderView['default'] : ListDataProviderView;
  TreeDataProviderView = TreeDataProviderView && Object.prototype.hasOwnProperty.call(TreeDataProviderView, 'default') ? TreeDataProviderView['default'] : TreeDataProviderView;

  /**
   * @private
   */
  const AbstractLovBase = function (options) {
    // {className, dataProvider, containerElem, fullScreenPopup,
    // idSuffix, lovMainField, filterInputText, lovDropdown, liveRegion, enabled, readOnly, value,
    // getTranslatedStringFunc, addBusyStateFunc, showMainFieldFunc, setFilterFieldTextFunc,
    // setUiLoadingStateFunc, isValueForPlaceholderFunc, isShowValueInFilterFieldFunc,
    // getFilterInputElemFunc, matchBy}
    this._minLength = 0;

    this._className = options.className;

    this._dataProvider = options.dataProvider;
    this._containerElem = options.containerElem;
    this._fullScreenPopup = options.fullScreenPopup;
    this._idSuffix = options.idSuffix;
    this._enabled = options.enabled;
    this._readonly = options.readOnly;
    this._value = options.value;
    this._getTranslatedStringFunc = options.getTranslatedStringFunc;
    this._addBusyStateFunc = options.addBusyStateFunc;
    this._lovMainField = options.lovMainField;
    this._filterInputText = options.filterInputText;
    this._lovDropdown = options.lovDropdown;
    this._liveRegion = options.liveRegion;
    this._showMainFieldFunc = options.showMainFieldFunc;
    this._setFilterFieldTextFunc = options.setFilterFieldTextFunc;
    this._setUiLoadingStateFunc = options.setUiLoadingStateFunc;
    this._isValueForPlaceholderFunc = options.isValueForPlaceholderFunc;
    this._isShowValueInFilterFieldFunc = options.isShowValueInFilterFieldFunc;
    this._getFilterInputElemFunc = options.getFilterInputElemFunc;
    this._matchBy = options.matchBy;

    this._lastDataProviderPromise = null;

    // support ko options-binding
    // init dataProvider fetchType
    this._fetchType = this.hasData() ? 'init' : null;

    // JET-44062 - add gap between field and dropdown
    var dropdownVerticalOffset =
      ThemeUtils.getCachedCSSVarValues(['--oj-private-core-global-dropdown-offset'])[0] || '0';
    this._dropdownVerticalOffset = parseInt(dropdownVerticalOffset, 10);
  };

  AbstractLovBase.prototype.setValue = function (value) {
    this._value = value;
  };

  AbstractLovBase.prototype.setMatchBy = function (matchBy) {
    this._matchBy = matchBy;
  };

  AbstractLovBase.prototype.getFetchType = function () {
    return this._fetchType;
  };

  AbstractLovBase.prototype.destroy = function () {
    var closeDelayTimer = this._closeDelayTimer;
    if (!isNaN(closeDelayTimer)) {
      delete this._closeDelayTimer;
      window.clearTimeout(closeDelayTimer);
    }

    this.closeDropdown();
  };

  AbstractLovBase.prototype.hasData = function () {
    return this._dataProvider != null;
  };

  AbstractLovBase.prototype.isDropdownOpen = function () {
    return $(this._containerElem).hasClass('oj-listbox-dropdown-open');
  };

  AbstractLovBase.prototype._usingHandler = function (pos, props) {
    // if the input part of the component is clipped in overflow, implicitly close the dropdown popup.
    if (oj.PositionUtils.isAligningPositionClipped(props)) {
      // add busy state
      var resolveBusyState = this._addBusyStateFunc('closing popup');
      // prettier-ignore
      this._closeDelayTimer = window.setTimeout( // @HTMLUpdateOK
        function () {
          this.closeDropdown();
          resolveBusyState();
        }.bind(this),
        1
      );
    } else {
      var $containerElem = $(this._containerElem);
      var dropdownElem = this._lovDropdown.getElement();
      var $dropdownElem = $(dropdownElem);

      // JET-34367 - remove code to update popup position on refresh
      // get the space available to the popup after the popup service has run its collision logic
      var availableSpace = oj.PositionUtils.calcAvailablePopupSize(pos, props);

      // constrain the dropdown size to the available space
      var dropdownElemStyle = dropdownElem.style;
      // don't change width if pos.left is < 0 because it can result in the dropdown flickering
      if (pos.left >= 0) {
        dropdownElemStyle.maxWidth = availableSpace.width + 'px';
      }
      dropdownElemStyle.maxHeight = availableSpace.height + 'px';

      // apply same position, because the popup service should put it in the same place after
      // running collision logic (exclude using callback, because we're already in it and we don't
      // need to loop again)
      var dropdownPosition = this.getDropdownPosition(true);
      // reposition the dropdown
      $dropdownElem.position(dropdownPosition);

      if (props.vertical === 'bottom') {
        $containerElem.addClass('oj-listbox-drop-above');
        $dropdownElem.addClass('oj-listbox-drop-above');
      } else {
        $containerElem.removeClass('oj-listbox-drop-above');
        $dropdownElem.removeClass('oj-listbox-drop-above');
      }
    }
  };

  AbstractLovBase.prototype.getDropdownPosition = function (excludeUsingHandler) {
    var position;
    var isRtl = DomUtils.getReadingDirection() === 'rtl';
    if (this._fullScreenPopup) {
      var scrollX = window.scrollX || window.pageXOffset;
      var scrollY = window.scrollY || window.pageYOffset;
      position = {
        my: 'start top',
        at: 'start top',
        of: window,
        offset: { x: scrollX, y: scrollY }
      };
      position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);
    } else {
      // The element on which we want to position the listbox-dropdown.  We don't
      // want it to be the container because we add the inline messages to the container
      // and if we line up to the container when it has inline messages, the dropdown
      // appears after the inline messages.  We want it to always appear next to the input,
      // which is the first child of the container.
      var defPosition = {
        my: 'start top',
        at: 'start bottom',
        of: this._lovMainField.getElement(),
        collision: 'flip',
        offset: { x: 0, y: this._dropdownVerticalOffset }
      };
      if (!excludeUsingHandler) {
        defPosition.using = this._usingHandler.bind(this);
      }
      position = oj.PositionUtils.normalizeHorizontalAlignment(defPosition, isRtl);
      // need to coerce to Jet and then JqUi in order for vertical offset to work
      position = oj.PositionUtils.coerceToJet(position);
      position = oj.PositionUtils.coerceToJqUi(position);
      // set the position.of again to be the element, because coerceToJet will change it to a
      // string selector, which can then result in an error being thrown from jqueryui
      // position.js getDimensions(elem) method if the element has been removed from the DOM
      position.of = defPosition.of;
    }
    return position;
  };

  AbstractLovBase.prototype.sizeDropdown = function () {
    var dropdownElem = this._lovDropdown.getElement();

    if (this._fullScreenPopup) {
      var ww = Math.min(window.innerWidth, window.screen.availWidth);
      var hh = Math.min(window.innerHeight, window.screen.availHeight);
      // in an iframe on a phone, need to get the available height of the parent window to account
      // for browser URL bar and bottom toolbar
      // (this depends on device type, not device render mode, because the fix is not needed on
      // desktop in the cookbook phone portrait mode)
      var deviceType = Config.getDeviceType();
      // window.parent is not supposed to be null/undefined, but checking that for safety;
      // in normal cases where the window doesn't have a logical parent, window.parent is supposed
      // to be set to the window itself;
      // when there is an iframe, like in the cookbook, the window.parent will actually be different
      // from the window
      if (deviceType === 'phone' && window.parent && window !== window.parent) {
        var parentHH = Math.min(window.parent.innerHeight, window.parent.screen.availHeight);
        var availContentHeight = Math.min(hh, parentHH);
        if (hh > availContentHeight) {
          var diffHeight = hh - availContentHeight;
          dropdownElem.style.paddingBottom = diffHeight + 'px';
        }
      }
      dropdownElem.style.width = ww + 'px';
      dropdownElem.style.height = hh + 'px';
    } else {
      dropdownElem.style.minWidth = $(this._containerElem).width() + 'px';
    }
  };

  /**
   * Opens the dropdown
   *
   * @return {boolean} whether or not dropdown was opened. This method will return false if, for example,
   * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
   * @ignore
   */
  AbstractLovBase.prototype.openDropdown = function (dontUpdateResults) {
    if (this.isDropdownOpen() || this._enabled === false || this._readonly === true) {
      return false;
    }

    if (this._fullScreenPopup) {
      var mainInputElem = this._lovMainField.getInputElem();
      var filterFieldText = this._isShowValueInFilterFieldFunc() ? mainInputElem.value : '';
      this._setFilterFieldTextFunc(filterFieldText);
    }

    $(this._containerElem).addClass('oj-listbox-dropdown-open');
    if (!dontUpdateResults) {
      this.updateResults(true, this._fullScreenPopup);
    }

    // this._toggleAriaDescribedBy(true);
    return true;
  };

  AbstractLovBase.prototype.closeDropdown = function () {
    if (!this.isDropdownOpen()) {
      return;
    }

    var $containerElem = $(this._containerElem);

    $containerElem.removeClass('oj-listbox-dropdown-open');

    if (!this._ariaExpanded) {
      return;
    }

    // clear the classes used to figure out the preference of where the dropdown should be opened
    $containerElem.removeClass('oj-listbox-drop-above');
    $(this._lovDropdown.getElement()).removeClass('oj-listbox-drop-above');

    this._lovDropdown.close();
    // this._toggleAriaDescribedBy(false);

    // select: accessibility
    this._ariaExpanded = false;
    this._lovMainField.getInputElem().setAttribute('aria-expanded', 'false');

    // We only add aria-expanded to the filter input elem if we're not rendering the full screen
    // popup on mobile.  On desktop, the filter input is part of the main text field with
    // role='combobox', so it does need aria-expanded to indicate whether the popup is open.
    // On mobile, the filter input is part of the full screen popup itself, so it does not have
    // role='combobox' and it does not control whether the popup is open.
    var filterInputElem = this._getFilterInputElemFunc();
    if (filterInputElem && !this._fullScreenPopup) {
      filterInputElem.setAttribute('aria-expanded', 'false');
    }

    //  - press escape after search in select causes select to become unresponsive
    this._lastSearchTerm = null;

    // if (!this._fullScreenPopup &&
    //     !DomUtils.isAncestor(this._containerElem, document.activeElement)) {
    //   this._showMainFieldFunc();
    // }
  };

  AbstractLovBase.prototype.updateResults = function (initial, focusFirstElem) {
    var term;

    // During the initial fetch (happens when the dropdown is opened), we need to use the display
    // text to filter the dropdown results
    if (initial === true) {
      // TODO: Get back to this once the design is confirmed for the component's
      //       behavior for rendering the results on opening the dropdown when a value
      //       is selected.
      // term = this._lovMainField.getInputText();
      term = '';
    } else {
      term = this._filterInputText.rawValue || '';
    }

    var lastTerm = this._lastSearchTerm;

    // prevent duplicate queries against the same term
    // not applying to multi select since user can search the same term after making selection
    // it's ok for single select since the last term will be updated after selection
    if (initial !== true && lastTerm && term === lastTerm) {
      return;
    }

    // In IE even for change of placeholder fires 'input' event,
    // so in such cases we don't need to query for results.
    // if (!lastTerm && !term && initial && initial.type === 'input') {
    //   return;
    // }

    // JET-38189 - IXD - Default Progressive Loading from 1 loading bar to 3 for default
    // apply min-height while the skeleton is showing, before the data is fetched
    var dropdownElem = this._lovDropdown.getElement();
    var dropdownClassList = dropdownElem.classList;
    if (initial === true) {
      dropdownClassList.add('oj-listbox-initial-open');
    } else {
      dropdownClassList.remove('oj-listbox-initial-open');
    }

    this._lastSearchTerm = term;

    if (term.length >= this._minLength) {
      if (!initial || initial === true) {
        this._runQuery(term, focusFirstElem, initial === true);
      } else {
        this._runQuery(term, focusFirstElem);
      }
    } else {
      this.closeDropdown();
    }
  };

  AbstractLovBase.prototype._runQuery = function (term, focusFirstElem, initial) {
    var lovDropdown = this._lovDropdown;

    if (this._minLength > term.length) {
      this.closeDropdown();
      return;
    }

    this.openDropdown(true);

    // lovDropdown.clearHighlight();

    if (this.hasData()) {
      if (!this._ariaExpanded) {
        lovDropdown.open();
        // select: accessibility
        this._ariaExpanded = true;
        this._lovMainField.getInputElem().setAttribute('aria-expanded', 'true');

        // We only add aria-expanded to the filter input elem if we're not rendering the full screen
        // popup on mobile.  On desktop, the filter input is part of the main text field with
        // role='combobox', so it does need aria-expanded to indicate whether the popup is open.
        // On mobile, the filter input is part of the full screen popup itself, so it does not have
        // role='combobox' and it does not control whether the popup is open.
        var filterInputElem = this._getFilterInputElemFunc();
        if (filterInputElem && !this._fullScreenPopup) {
          filterInputElem.setAttribute('aria-expanded', 'true');
        }
      }

      // if not on mobile, transfer focus into the dropdown now;  otherwise wait until after the
      // dropdown busy state resolves in _handleQueryResultsFetch below
      if (focusFirstElem && !this._fullScreenPopup) {
        FocusUtils.focusFirstTabStop(lovDropdown.getElement());
      }

      // lovDropdown.setSearchText(term);
      var fetchPromise = this._fetchFromDataProvider(term, initial);
      fetchPromise.then(
        function () {
          // ignore old responses
          if (fetchPromise === this._lastDataProviderPromise) {
            this._handleQueryResultsFetch(focusFirstElem);
          }
        }.bind(this),
        function (reason) {
          // ignore old responses
          if (fetchPromise === this._lastDataProviderPromise) {
            Logger.warn('Select: _fetchFromDataProvider promise was rejected: ' + reason);
            this._handleQueryResultsFetch(focusFirstElem);
          }
        }.bind(this)
      );
    }
  };

  AbstractLovBase.prototype._handleQueryResultsFetch = function (focusFirstElem) {
    // ignore a response if the oj-combobox has been closed before it was received
    if (!this.isDropdownOpen()) {
      return;
    }

    // JET-38189 - IXD - Default Progressive Loading from 1 loading bar to 3 for default
    // only need to apply min-height while the skeleton is showing, not after data has been fetched
    var dropdownElem = this._lovDropdown.getElement();
    var dropdownClassList = dropdownElem.classList;
    dropdownClassList.remove('oj-listbox-initial-open');

    // var results = this._lovDropdown.findHighlightableOptionElems();
    // var resultsCount = results ? results.length : 0;
    var fetchedDataCount = this._lovDropdown.getResultsCount();
    var resultsCount = fetchedDataCount ? fetchedDataCount.count : 0;
    var resultsCountDone = fetchedDataCount ? fetchedDataCount.done : true;
    var translation;
    if (resultsCount === 0) {
      translation = this._getTranslatedStringFunc('noMatchesFound');
    } else {
      this.sizeDropdown();
      // lovDropdown.postRenderResults();

      // TODO: need a way to get number of results from listView, and to know when to update it when
      // listView loads more on scroll (could count results in FilteringDataProviderView iterator
      // every time next is called?)
      // translation = (resultsCount === 1) ? this._getTranslatedStringFunc('oneMatchFound') :
      //   this._getTranslatedStringFunc('multipleMatchesFound', { num: ('' + resultsCount) });
      translation = resultsCountDone
        ? this._getTranslatedStringFunc('multipleMatchesFound', { num: String(resultsCount) })
        : this._getTranslatedStringFunc('nOrMoreMatchesFound', { num: String(resultsCount) });
    }
    this.updateLiveRegion(translation);

    // JET-39385 - SELECT SINGLE HAS NO OPTION TO SET TITLE IN MOBILE SEARCH
    // wait until the dropdown busy state resolves to transfer focus, otherwise the placeholder in
    // the mobile search field may not get rendered when the inside label animates
    if (focusFirstElem && this._fullScreenPopup) {
      FocusUtils.focusFirstTabStop(this._lovDropdown.getElement());
    }
  };

  AbstractLovBase.prototype.updateLiveRegion = function (translatedString) {
    $(this._liveRegion).text(translatedString);
  };

  AbstractLovBase.prototype.cancel = function () {
    this.closeDropdown();
    // this._lovMainField.focusCursorEndInputElem();
  };

  // eslint-disable-next-line no-unused-vars
  AbstractLovBase.prototype.handleDataProviderEvent = function (event) {
    // clear the saved last search term
    this._lastSearchTerm = null;
  };

  // add busy state
  // display an animated gif if it is fetch initially
  // fetch from the data provider
  // display message for furthur filtering if not all results are fetched
  // if multiple queries are in progress, discard all but the last query
  // returns a promise that resolves when the listview has finished rendering
  AbstractLovBase.prototype._fetchFromDataProvider = function (term, initial) {
    var bLoadingIndicatorAdded = false;

    // add busy context
    var fetchResolveFunc = this._addBusyStateFunc('fetching data');

    // display spinning icon only for the initial fetch
    if (this._fetchType === 'init') {
      if (!this.isDropdownOpen()) {
        bLoadingIndicatorAdded = true;
        this._setUiLoadingStateFunc('start');
      }
      this._fetchType = null;
    }

    var filterCriteria = null;
    if (term) {
      var matchBy;
      if (this._dataProvider) {
        var filterCapability = this._dataProvider.getCapability('filter');
        if (!filterCapability || !filterCapability.textFilter) {
          Logger.error(
            'Select: DataProvider does not support text filter.  ' +
              'Filtering results in dropdown may not work correctly.'
          );
        } else if (this._matchBy) {
          // JET-60725 - Add option to specify the matchBy behavior of the text filter
          // Find the first matchBy behavior in the array that the data provider supports.
          matchBy = this._matchBy.reduce((result, curr) => {
            // if we've already found a supported matchBy, use it
            if (result) {
              return result;
            }
            // if we've encountered 'unknown' in the array, return it because it's always supported
            if (curr === 'unknown') {
              return curr;
            }
            // if we haven't found a supported matchBy yet, see if the current one is supported and
            // return it if so; if not log a warning
            if (curr) {
              if (
                filterCapability.textFilterMatching &&
                filterCapability.textFilterMatching.matchBy &&
                filterCapability.textFilterMatching.matchBy.indexOf(curr) > -1
              ) {
                return curr;
              }
              Logger.warn(
                `Select: DataProvider does not support text filter "${curr}" matching.  ` +
                  'Filtering results in dropdown may not work as expected.'
              );
            }
            // if we haven't found a supported matchBy yet, return undefined and go on
            return undefined;
          }, null);
        }
      }

      // create filter using FilterFactory so that default local filtering will happen if
      // underlying DP doesn't support its own filtering
      var filterDef = matchBy ? { text: term, matchBy } : { text: term };
      filterCriteria = oj.FilterFactory.getFilter({ filterDef });
    }

    var retPromise = new Promise(
      function (resolve, reject) {
        // fetch data from dataProvider
        var renderPromise = this._lovDropdown.renderResults(
          term,
          filterCriteria,
          this._isValueForPlaceholderFunc(this._value) ? null : this._value,
          initial
        );

        var afterRenderPromiseFunc = function () {
          if (bLoadingIndicatorAdded) {
            this._setUiLoadingStateFunc('stop');
          }

          // clear busy context
          fetchResolveFunc();

          // ignore old responses
          if (retPromise === this._lastDataProviderPromise) {
            resolve();
          } else {
            reject('AbstractLovBase._fetchFromDataProvider: rejecting earlier promise');
          }
        }.bind(this);
        renderPromise.then(
          function () {
            afterRenderPromiseFunc();
          },
          function (reason) {
            // ignore old responses
            if (retPromise === this._lastDataProviderPromise) {
              Logger.warn('Select: renderResults promise was rejected: ' + reason);
            }
            afterRenderPromiseFunc();
          }
        );
      }.bind(this)
    );
    // save the most recent promise so we can ignore old data provider responses
    this._lastDataProviderPromise = retPromise;
    return retPromise;
  };

  /**
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  const FilteringDataProviderView = function (dataProvider) {
    this._fetchedDataCount = {
      count: 0,
      done: true
    };

    // FilteringDataProviderView
    this.setFilterCriterion = function (filterCriterion) {
      var oldFilterCriterion = this._filterCriterion;
      this._filterCriterion = filterCriterion;

      // only dispatch refresh event if the filterCriterion is different from the previous one
      if (!_compareFilterCriterion(oldFilterCriterion, this._filterCriterion)) {
        var event = new ojdataprovider.DataProviderRefreshEvent();
        // use defineProperty to create the filterCriterionChanged prop so that it's not enumerable
        Object.defineProperty(event, 'filterCriterionChanged', { value: true });
        this.dispatchEvent(event);
      }
    };

    // FilteringDataProviderView
    this.getFetchedDataCount = function () {
      return this._fetchedDataCount;
    };

    // FilteringDataProviderView
    this.setFetchedDataCount = function (fetchedDataCount) {
      this._fetchedDataCount = fetchedDataCount;
    };

    // FilteringDataProviderView
    function _compareFilterCriterion(fc1, fc2) {
      return fc1 === fc2 || (!fc1 && !fc2) || (fc1 && fc2 && fc1.text === fc2.text);
    }

    // FilteringDataProviderView
    function WrappingAsyncIterable(iterator, fetchedDataCount) {
      var _asyncIterator = new WrappingAsyncIterator(iterator, fetchedDataCount);
      this[Symbol.asyncIterator] = function () {
        return _asyncIterator;
      };
    }

    // FilteringDataProviderView
    function WrappingAsyncIterator(iterator, fetchedDataCount) {
      this.next = function () {
        var promise = iterator.next();
        return new Promise(function (resolve, reject) {
          promise.then(
            function (nextResults) {
              var nextValue = nextResults.value;
              if (nextValue.data) {
                // eslint-disable-next-line no-param-reassign
                fetchedDataCount.count += nextValue.data.length;
              }
              // eslint-disable-next-line no-param-reassign
              fetchedDataCount.done = nextResults.done;
              resolve(nextResults);
            },
            function (reason) {
              reject(reason);
            }
          );
        });
      };
    }

    // FilteringDataProviderView
    this.fetchFirst = function (params) {
      if (dataProvider) {
        // always pass filter criterion to underlying data provider because component will make sure
        // it is a ListDataProviderView and call the FilterFactory to do local filtering if needed
        if (this._filterCriterion) {
          // eslint-disable-next-line no-param-reassign
          params.filterCriterion = this._filterCriterion;
        }

        // return dataProvider.fetchFirst(params);

        // Reset the data counter
        this._fetchedDataCount.count = 0;
        this._fetchedDataCount.done = true;
        if (this._fetchedDataCount.childrenCountMap) {
          this._fetchedDataCount.childrenCountMap.clear();
        }

        var asyncIterable = dataProvider.fetchFirst(params);
        var asyncIterator = asyncIterable[Symbol.asyncIterator]();
        return new WrappingAsyncIterable(asyncIterator, this._fetchedDataCount);
      }
      var retObj = {};
      retObj[Symbol.asyncIterator] = function () {
        return {
          next: function () {
            return Promise.resolve({
              value: {
                data: [],
                fetchParameters: params,
                metadata: []
              },
              done: true
            });
          }
        };
      };
      return retObj;
    };

    // FilteringDataProviderView
    this.containsKeys = function (params) {
      if (dataProvider) {
        return dataProvider.containsKeys(params);
      }
      return Promise.resolve({
        containsParameters: params,
        results: new Set()
      });
    };

    // FilteringDataProviderView
    this.fetchByKeys = function (params) {
      if (dataProvider) {
        return dataProvider.fetchByKeys(params);
      }
      return Promise.resolve({
        fetchParameters: params,
        results: new Map()
      });
    };

    // FilteringDataProviderView
    this.fetchByOffset = function (params) {
      if (dataProvider) {
        // always pass filter criterion to underlying data provider because component will make sure
        // it is a ListDataProviderView and call the FilterFactory to do local filtering if needed
        if (this._filterCriterion) {
          // eslint-disable-next-line no-param-reassign
          params.filterCriterion = this._filterCriterion;
        }
        return dataProvider.fetchByOffset(params);
      }
      return Promise.resolve({
        done: true,
        fetchParameters: params,
        results: []
      });
    };

    // FilteringDataProviderView
    this.isEmpty = function () {
      if (dataProvider) {
        return dataProvider.isEmpty();
      }
      return 'yes';
    };

    // FilteringDataProviderView
    this.getTotalSize = function () {
      if (dataProvider) {
        return dataProvider.getTotalSize();
      }
      return Promise.resolve(0);
    };

    // FilteringDataProviderView
    this.addEventListener = function (eventType, listener) {
      if (dataProvider) {
        dataProvider.addEventListener(eventType, listener);
      }
    };

    // FilteringDataProviderView
    this.removeEventListener = function (eventType, listener) {
      if (dataProvider) {
        dataProvider.removeEventListener(eventType, listener);
      }
    };

    // FilteringDataProviderView
    this.dispatchEvent = function (evt) {
      if (dataProvider) {
        return dataProvider.dispatchEvent(evt);
      }
      return true;
    };

    // FilteringDataProviderView
    this.getCapability = function (capabilityName) {
      if (dataProvider) {
        return dataProvider.getCapability(capabilityName);
      }
      return null;
    };

    // If dataProvider is hierarchical, create getChildDataProvider for
    // ourselves to delegate to that provider's own call
    if (dataProvider && oj.DataProviderFeatureChecker.isTreeDataProvider(dataProvider)) {
      // Create a property in fetchedDataCount object that will store the count for
      // child nodes. We need this here in parent because, we will be creating a new
      // DP instance for child nodes whenever getChildDataProvider is called. So we
      // will be storing the count in parent node and restore it in child node after
      // creating a new instance.
      this._fetchedDataCount.childrenCountMap = new Map();

      // FilteringDataProviderView
      this.getChildDataProvider = function (parentKey) {
        let childDp = dataProvider.getChildDataProvider.apply(dataProvider, arguments);
        if (childDp) {
          childDp = new FilteringDataProviderView(childDp);
          // Pass our filter criterion onto the child right away
          if (this._filterCriterion) {
            childDp.setFilterCriterion(this._filterCriterion);
          }

          // Pass the stored data counter
          let childFetchedDataCount = this._fetchedDataCount.childrenCountMap.get(parentKey);

          if (!childFetchedDataCount) {
            // If we do not have a store counter yet, use the child's newly created
            // counter and store its ref in the parent to pass on later.
            childFetchedDataCount = childDp.getFetchedDataCount();
            this._fetchedDataCount.childrenCountMap.set(parentKey, childFetchedDataCount);
          } else {
            childDp.setFetchedDataCount(childFetchedDataCount);
          }
        }
        return childDp;
      }.bind(this);
    }
  };

  /**
   * @private
   */
  const LovUtils = {
    // LovUtils
    KEYS: {
      TAB: 9,
      ENTER: 13,
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      HOME: 36,
      END: 35,
      BACKSPACE: 8,
      DELETE: 46
    },

    // LovUtils
    _isControlKey: function (event) {
      // JET-44374 - qunit combobox ojselect tests fail with new jquery 3.6.0
      // e.which no longer gets populated when simulating events with keyCode specified, so
      // check both properties on the event
      var keyCode = event.which || event.keyCode;
      switch (keyCode) {
        case LovUtils.KEYS.SHIFT:
        case LovUtils.KEYS.CTRL:
        case LovUtils.KEYS.ALT:
          return true;
        default:
          return event.metaKey || event.ctrlKey;
      }
    },

    // LovUtils
    _isFunctionKey: function (event) {
      // JET-44374 - qunit combobox ojselect tests fail with new jquery 3.6.0
      // e.which no longer gets populated when simulating events with keyCode specified, so
      // check both properties on the event
      var keyCode = event.which || event.keyCode;
      var key = keyCode || event;
      return key >= 112 && key <= 123;
    },

    // LovUtils
    isControlOrFunctionKey: function (event) {
      return LovUtils._isControlKey(event) || LovUtils._isFunctionKey(event);
    },

    // LovUtils
    nextUid: (function () {
      var counter = 1;
      return function () {
        var ret = counter;
        counter += 1;
        return ret;
      };
    })(),

    // LovUtils
    killEvent: function (event) {
      event.preventDefault();
    },

    // LovUtils
    killEventWithAncestorExceptions: function (selectors, event) {
      // Do nothing, if the target has one of the ancestor selectors
      const target = $(event.target);
      if (selectors.some((selector) => target.closest(selector) !== 0)) {
        return;
      }
      // Only prevent default if the event target is not a descendent
      // of the element with the provided selector
      event.preventDefault();
    },

    // LovUtils
    stopEventPropagation: function (event) {
      event.stopPropagation();
    },

    // LovUtils
    addBusyState: function (elem, description) {
      var desc = "The component identified by '" + elem.id + "' " + description;
      var busyStateOptions = { description: desc };
      var busyContext = Context.getContext(elem).getBusyContext();
      return busyContext.addBusyState(busyStateOptions);
    },

    // LovUtils
    createValueItem: function (value, data, metadata) {
      return { key: value, data: data, metadata: metadata };
    },

    // LovUtils
    dispatchCustomEvent: function (elem, type, subtype, _detail) {
      var detail = _detail || {};
      detail.subtype = subtype;
      var params = { bubbles: false, cancelable: false, detail: detail };
      return elem.dispatchEvent(new CustomEvent(type, params));
    },

    // LovUtils
    copyAttribute: function (sourceElem, sourceAttr, targetElem, targetAttr) {
      var value = sourceElem.getAttribute(sourceAttr);
      if (value === null) {
        LovUtils.removeAttribute(targetElem, targetAttr);
      } else {
        targetElem.setAttribute(targetAttr, value); // @HTMLUpdateOK
      }
    },

    // LovUtils
    removeAttribute: function (elem, attr) {
      // JET-45699 - Select2 qunit tests fail using safari for master and v11 branches
      // it's a CSP violation in Safari 14.1 to remove the style attribute, so remove all of its
      // properties instead
      if (attr === 'style') {
        LovUtils._removeStyles(elem);
      } else {
        elem.removeAttribute(attr);
      }
    },

    // LovUtils
    _removeStyles: function (elem) {
      var style = elem.style;
      var numProps = style.length;
      var prop;
      for (var i = numProps - 1; i >= 0; i--) {
        prop = style.item(i);
        style.removeProperty(prop);
      }
    },

    // LovUtils
    isDataProvider: function (data) {
      return data && ojcomponentcore.DataProviderFeatureChecker
        ? ojcomponentcore.DataProviderFeatureChecker.isDataProvider(data)
        : false;
    },

    // LovUtils
    isTreeDataProvider: function (data) {
      return data && ojcomponentcore.DataProviderFeatureChecker
        ? ojcomponentcore.DataProviderFeatureChecker.isTreeDataProvider(data)
        : false;
    }
  };

  /**
   * @private
   */
  const LovDropdown = function () {};

  LovDropdown.prototype.init = function (options) {
    // {dataProvider, className, parentId, idSuffix, dropdownElemId, fullScreenPopup, inputType,
    //  bodyElem, itemTemplate, collectionTemplate,
    //  getTemplateEngineFunc, templateContextComponentElement,
    //  addBusyStateFunc, itemTextRendererFunc, filterInputText, afterDropdownInitFunc,
    //  getThrottlePromiseFunc, isValueItemForPlaceholderFunc, styleClassComponentName}
    this._dataProvider = options.dataProvider;
    this._fullScreenPopup = options.fullScreenPopup;
    this._bodyElem = $(options.bodyElem);
    this._itemTemplate = options.itemTemplate;
    this._collectionTemplate = options.collectionTemplate;
    this._getTemplateEngineFunc = options.getTemplateEngineFunc;
    this._templateContextComponentElement = options.templateContextComponentElement;
    this._addBusyStateFunc = options.addBusyStateFunc;
    this._itemTextRendererFunc = options.itemTextRendererFunc;
    this._filterInputText = options.filterInputText;
    this._getThrottlePromiseFunc = options.getThrottlePromiseFunc;
    this._isValueForPlaceholderFunc = options.isValueForPlaceholderFunc;
    this._isValueItemForPlaceholderFunc = options.isValueItemForPlaceholderFunc;

    this._currentFirstItem = null;
    this._firstResultForKeyboardFocus = null;
    this._templateEngine = null;
    this._resultsCount = null;
    this._NO_RESULTS_FOUND_CLASSNAME = 'oj-listbox-searchselect-no-results';

    var resolveBusyState = this._addBusyStateFunc('LovDropdown initializing');

    this._addDataProviderEventListeners();

    var containerElem = this._createInnerDom(options);
    this._containerElem = containerElem;

    // JET-34367 - remove code to update popup position on refresh
    // Position a proxy element instead of the real dropdown so that we don't have to
    // change the size of the dropdown before calculating the position, because changing
    // the size of the dropdown before positioning may reset the results' scroll position and
    // prevent the user from scrolling down.
    this._dropdownPositioningProxyContainer = this._createDropdownPositioningProxyElem(options);

    var renderPromiseResolve;
    var renderPromiseReject;
    var renderPromise = new Promise(function (resolve, reject) {
      renderPromiseResolve = resolve;
      renderPromiseReject = reject;
    });

    this._collectionContext = {
      parentElement: this._containerElem[0],
      idSuffix: options.idSuffix,
      renderDone: renderPromiseResolve,
      renderError: renderPromiseReject,
      data: this._dataProvider,
      searchText: undefined,
      selected: undefined,
      selectedItem: undefined,
      selectedItemChangedListener: this._HandleCollectionSelectedItemChanged.bind(this),
      currentRow: {
        rowIndex: undefined,
        rowKey: undefined
      },
      currentRowChangedListener: this._handleCollectionCurrentRowChanged.bind(this),
      currentRowKeyChangedListener: this._handleCollectionCurrentRowKeyChanged.bind(this),
      handleRowAction: this._handleRowAction.bind(this)
    };
    this._collectionRendererFunc = this._collectionTemplate
      ? this._templateCollectionRenderer.bind(this)
      : this._defaultCollectionRenderer.bind(this);
    this._collectionRendererFunc(this._collectionContext);

    containerElem.on('change', '.' + options.className + '-input', LovUtils.stopEventPropagation);

    // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is
    // listening for mouse events outside of itself so it can close itself. since the dropdown
    // is now outside the combobox's dom it will trigger the popup close, which is not what we
    // want
    containerElem.on(
      'click mouseup mousedown',
      function (event) {
        LovUtils.stopEventPropagation(event);
        if (event.type === 'mousedown') {
          // JET-50692 - focus lost from component when mouse down on dropdown between items
          // In the mobile dropdown, call event.preventDefault() (to prevent focus from transferring
          // to the body element temporarily) if the target of the mousedown event is one of:
          // 1) the dropdown container itself (for example if the user taps in the empty space
          // below the last item in a short list)
          // 2) a descendant element of the filter field except for the input itself
          if (
            this._fullScreenPopup &&
            (event.target === containerElem[0] ||
              (DomUtils.isAncestorOrSelf(this._filterInputText, event.target) &&
                event.target.tagName.toLowerCase() !== 'input'))
          ) {
            event.preventDefault();
          }
        }
      }.bind(this)
    );

    var afterRenderFunc = function () {
      if (options.afterDropdownInitFunc) {
        options.afterDropdownInitFunc(this._resultsElem[0]);
      }
      resolveBusyState();
    }.bind(this);
    renderPromise.then(afterRenderFunc, afterRenderFunc);

    containerElem.on('keydown', this._handleKeyDown.bind(this));

    // JET-61331 - Select one choice LOV dropdown flowing out of the browser and adjusting when the
    // page is scrolled up or down
    // add a resize listener to the desktop dropdown so that we can reposition it after the content
    // renders
    if (!this._fullScreenPopup) {
      this._addResizeListener(containerElem[0]);
    }

    // if updateLabel was called before now, execute the deferred call
    if (this._updateLabelFunc) {
      var updateLabelFunc = this._updateLabelFunc;
      this._updateLabelFunc = null;
      updateLabelFunc();
    }
  };

  LovDropdown.prototype._dispatchEvent = function (subtype, detail) {
    return LovUtils.dispatchCustomEvent(this._containerElem[0], 'lovDropdownEvent', subtype, detail);
  };

  LovDropdown.prototype.destroy = function () {
    // TODO: release resources in here, like cleaning elements create by template engine as part of
    // fixing  - CALL TEMPLATEENGINE.CLEAN() FOR HEADER/FOOTER TEMPLATES

    // only clean nodes if we actually have templates and have loaded the template engine to
    // execute them
    if (
      (this._itemTemplate || this._collectionTemplate) &&
      this._containerElem &&
      this._templateEngine
    ) {
      this._templateEngine.clean(this._containerElem[0], this._templateContextComponentElement);
    }

    this._removeDataProviderEventListeners();

    // JET-61331 - Select one choice LOV dropdown flowing out of the browser and adjusting when the
    // page is scrolled up or down
    // remove the resize listener from the desktop dropdown
    this._removeResizeListener(this._containerElem[0]);
  };

  LovDropdown.prototype.getElement = function () {
    // check whether the dropdown has been initialized
    if (this._containerElem) {
      return this._containerElem[0];
    }
    return null;
  };

  LovDropdown.prototype._createInnerDom = function (options) {
    var outerDiv = document.createElement('div');
    outerDiv.setAttribute('data-oj-containerid', options.parentId);
    outerDiv.setAttribute('data-oj-context', '');
    outerDiv.setAttribute('id', options.dropdownElemId);
    outerDiv.setAttribute(
      'class',
      'oj-listbox-drop oj-listbox-searchselect' +
        (' oj-listbox-' + options.styleClassComponentName) +
        (this._fullScreenPopup ? ' oj-listbox-fullscreen' : '')
    );
    outerDiv.style.display = 'none';
    outerDiv.setAttribute('role', 'presentation');

    if (this._fullScreenPopup) {
      outerDiv.appendChild(this._filterInputText);
    }

    var resultsPlaceholder = document.createElement('div');
    resultsPlaceholder.setAttribute('class', 'oj-searchselect-results-placeholder');
    outerDiv.appendChild(resultsPlaceholder); // @HTMLUpdateOK

    return $(outerDiv);
  };

  LovDropdown.prototype._createDropdownPositioningProxyElem = function (options) {
    var idSuffix = options.idSuffix;

    // JET-34367 - remove code to update popup position on refresh
    // Position a proxy element instead of the real dropdown so that we don't have to
    // change the size of the dropdown before calculating the position, because changing
    // the size of the dropdown before positioning may reset the results' scroll position and
    // prevent the user from scrolling down.
    // JET-42675 - combobox drop down not aligned correctly for wide browser windows in jet 10
    // Wrap everything in a non-overflowing absolute container. This will prevent
    // any unwanted overflow while calculating the position.
    var containerDiv = document.createElement('div');
    containerDiv.style.visibility = 'hidden';
    containerDiv.style.position = 'absolute';
    containerDiv.style.overflow = 'hidden';

    var outerDiv = document.createElement('div');
    outerDiv.setAttribute('data-oj-containerid', options.parentId);
    outerDiv.setAttribute('data-oj-context', '');
    outerDiv.setAttribute('id', 'lovDropdownPositioningProxy_' + idSuffix);
    outerDiv.setAttribute('class', 'oj-listbox-drop oj-listbox-searchselect');
    containerDiv.appendChild(outerDiv); // @HTMLUpdateOK

    var resultsProxyElem = document.createElement('div');
    resultsProxyElem.setAttribute('class', 'oj-select-results');
    outerDiv.appendChild(resultsProxyElem); // @HTMLUpdateOK

    return $(containerDiv);
  };

  LovDropdown.prototype._defaultItemRenderer = function (listViewItemContext) {
    // TODO: Can/should we expect to write directly to the <li> when using an item template or
    // collection template?
    var li = listViewItemContext.parentElement;
    // li.setAttribute('role', 'option');

    // var label = document.createElement('span');
    // label.setAttribute('id', 'oj-listbox-result-label-' + LovUtils.nextUid());

    // create label content
    var formatted = this._itemTextRendererFunc({
      key: listViewItemContext.key,
      data: listViewItemContext.data,
      metadata: listViewItemContext.metadata
    });
    // only highlight matches for leaf nodes when data is hierarchical
    // the leaf property will be absent for flat data
    var isParent = listViewItemContext.leaf === false;
    // JET-43702 - Special characters in oj-select-single dropdown are not escaped
    // set text content of node or use oj-highlight-text so that displayed text is correctly escaped
    var childNode;
    if (isParent) {
      // add text content directly
      childNode = document.createElement('span');
      $(childNode).text(formatted);
    } else {
      // create oj-highlight-text
      childNode = document.createElement('oj-highlight-text');
      childNode.setAttribute('text', formatted);
      childNode.setAttribute('match-text', this._collectionContext.searchText);
    }
    li.appendChild(childNode);

    // li.appendChild(label);
    // return li;
  };

  LovDropdown.prototype._templateItemRenderer = function (templateEngine, listViewItemContext) {
    var renderContext = $.extend({}, listViewItemContext);
    renderContext.componentElement = this._templateContextComponentElement;
    renderContext.searchText = this._collectionContext.searchText;

    // TODO: Can/should we expect to write directly to the <li> when using an item template or
    // collection template?
    var li = renderContext.parentElement;
    // li.setAttribute('role', 'option');

    // var label = document.createElement('span');
    // label.setAttribute('id', 'oj-listbox-result-label-' + LovUtils.nextUid());

    // create label content
    if (templateEngine) {
      var nodes = templateEngine.execute(
        renderContext.componentElement,
        this._itemTemplate,
        renderContext
      );
      for (var i = 0; i < nodes.length; i++) {
        // label.appendChild(nodes[i]);
        li.appendChild(nodes[i]);
      }
    }

    // li.appendChild(label);
    // return li;
  };

  LovDropdown.prototype.renderResults = function (
    searchText,
    filterCriteria,
    selectedValue,
    initial
  ) {
    var resolveBusyState = this._addBusyStateFunc('LovDropdown rendering results');

    // save most recent filterCriteria so we know whether we need to apply highlighting
    this._latestFilterCriteria = filterCriteria;

    // JET-37502 - REPEATED FETCHES / CONTAINSKEY CALLS COME IN FROM JET WHEN SEARCHING FOR TEXT WHEN
    // SELECT-SINGLE DROPDOWN IS OPEN
    // Initially clear both selected and currentRow so that the collection doesn't try to validate
    // and scroll to a row that isn't in the filtered data set.  We'll set both in _configureResults,
    // after the collection has rendered the filtered data.
    // Clear these before calling setFilterCriterion on data provider below, so that collection is
    // updated before the data provider refresh event is fired.
    this._ClearSelection();

    // ignore selection changed events during listView initialization
    this._duringListViewInitialization = true;

    var renderPromiseResolve;
    var renderPromiseReject;
    var renderPromise = new Promise(function (resolve, reject) {
      renderPromiseResolve = resolve;
      renderPromiseReject = reject;
    });

    var retPromise = new Promise(
      function (resolve, reject) {
        renderPromise.then(
          function () {
            // wait until the changes propagate to the collection and the collection handles the DP
            // refresh event due to filter criteria changing before resolving the promise
            var busyContext = Context.getContext(this._containerElem[0]).getBusyContext();
            // Once the collection is ready, call the configureResults
            // to set the selected and currentRow accordingly.
            busyContext.whenReady().then(
              function () {
                // JET-39227 - DYNAMIC FORM: USER NEEDS TO CLICK TWICE TO GET VALUE SELECTED FROM SINGLE
                // SELECT WHEN IT HAS ONLY ONE RECORD IN IT
                // don't call _configureResults unless this is the most recent render promise, because
                // otherwise the current item may not be present in the rendered list
                // ignore old responses
                if (retPromise === this._lastRenderResultsPromise) {
                  this._configureResults(searchText, selectedValue, initial).then(resolve, reject);
                } else {
                  resolve();
                }
              }.bind(this),
              reject
            );
          }.bind(this),
          reject
        );
      }.bind(this)
    );
    // save the most recent promise so we can ignore old responses
    this._lastRenderResultsPromise = retPromise;

    var collectionContext = this._collectionContext;
    collectionContext.data = this._dataProvider;
    collectionContext.searchText = searchText;

    // JET-37502 - REPEATED FETCHES / CONTAINSKEY CALLS COME IN FROM JET WHEN SEARCHING FOR TEXT WHEN
    // SELECT-SINGLE DROPDOWN IS OPEN
    // before rendering, let the _ClearSelection() call above process, which may
    // happen asynchronously when a collectionTemplate is specified because it relies on
    // ko observables under the covers
    this._getThrottlePromiseFunc().then(
      function () {
        // JET-34871 - FILTERING DANGLING BUSY STATE
        // if there is an existing, unresolved renderPromise, reject it now so that we don't end up with
        // orphaned busy states
        if (collectionContext.renderError) {
          var contextRenderError = collectionContext.renderError;
          this._clearContextRenderPromiseFunctions(collectionContext);
          contextRenderError('LovDropdown.renderResults: rejecting earlier promise');
        }
        collectionContext.renderDone = renderPromiseResolve;
        collectionContext.renderError = renderPromiseReject;

        this._dataProvider.setFilterCriterion(filterCriteria);

        this._collectionRendererFunc(collectionContext);
      }.bind(this)
    );

    var afterRetPromiseFunc = function () {
      // ignore old responses
      if (retPromise === this._lastRenderResultsPromise) {
        this._duringListViewInitialization = false;
      }
      resolveBusyState();
    }.bind(this);

    return retPromise.then(
      function () {
        afterRetPromiseFunc();
      },
      function (reason) {
        // ignore old responses
        if (retPromise === this._lastRenderResultsPromise) {
          Logger.warn('Select: LovDropdown.renderResults retPromise rejected: ' + reason);
        }
        afterRetPromiseFunc();
      }.bind(this)
    );
  };

  LovDropdown.prototype.updateLabel = function (ariaLabelId, ariaLabel) {
    var resultsElem = this._resultsElem;
    if (!resultsElem) {
      // if the dropdown hasn't been initialized yet, defer the updateLabel call until then
      this._updateLabelFunc = this.updateLabel.bind(this, ariaLabelId, ariaLabel);
    } else if (!this._collectionTemplate) {
      var listView = resultsElem[0];
      //  - oghag missing label for ojselect and ojcombobox
      if (ariaLabelId) {
        listView.setAttribute('aria-labelledby', ariaLabelId);
        // The attribute value only can be removed by setting it to an empty string
        listView.setAttribute('aria-label', '');
      } else if (ariaLabel) {
        listView.setAttribute('aria-label', ariaLabel);
        // The attribute value only can be removed by setting it to an empty string
        listView.setAttribute('aria-labelledby', '');
      }
    }
  };

  LovDropdown.prototype.updateItemTextRendererFunc = function (itemTextRendererFunc) {
    // JET-45922 - timing issue with select-single: lov drop-down doesn't have element
    // do a granular update if item-text changes instead of a general refresh
    this._itemTextRendererFunc = itemTextRendererFunc;
    if (!this._collectionTemplate && !this._itemTemplate && this._resultsElem) {
      var listView = this._resultsElem[0];
      // add busy state around the set so our unit tests know when the resulting render is done
      var resolveBusyState = this._addBusyStateFunc('LovDropdown setting new default item renderer');
      listView.setProperty('item.renderer', this._defaultItemRenderer.bind(this));
      var busyContext = Context.getContext(listView).getBusyContext();
      busyContext.whenReady().then(resolveBusyState, resolveBusyState);
    }
  };

  /**
   * Configures the results by doing the following operations:
   *   1. hides/shows the dropdown based on the availability of the results
   *   2. selects the first result if exists
   *   3. sets the first result as the current row if exists
   *
   * @param {string=} searchText The current text used for filtering the data
   * @param {V=} selectedValue The current selected value
   * @param {boolean} initial Flag indicating if this is an initial fetch
   *
   * @return {Promise} a promise that resolve once the operation is completed
   *
   * @memberof LovDropdown
   * @private
   * @instance
   */
  LovDropdown.prototype._configureResults = function (searchText, selectedValue, initial) {
    // get the busy context of the collection, so we can wait for it to be updated
    var busyContext = Context.getContext(this._containerElem[0]).getBusyContext();

    // Clear the current value item
    this._SetCurrentFirstItem(null);

    // JET-38215 - SELECT SINGLE - KEYBOARD NAVIGATION FOR COLLECTION TEMPLATE USAGE
    // Original logic updated for JET-49906 - IN ACCESSIBILITY MODE, THE FIRST DROPDOWN VALUE IS READ TWICE
    // remove the existing first result for keyboard focus
    this._firstResultForKeyboardFocus = null;

    // This method is called only after the collection fetched the data
    // get the result count and store them
    this._resultsCount = this._dataProvider.getFetchedDataCount() || {};

    // At this point, the data would have been fetched and we will have the fetched data count.
    // If the result count is 0, then we need to hide the dropdown.
    // Do not close the dropdown since we need to proceed as if the dropdown is open (which is used
    // in other places and we would want it to work as if the dropdown is open). So instead, we just need to
    // hide the dropdown.
    const isOpen = this._containerElem[0].offsetHeight > 0;
    if (this._resultsCount.count == null || this._resultsCount.count === 0) {
      this._containerElem.addClass(this._NO_RESULTS_FOUND_CLASSNAME);
      if (isOpen) {
        oj.Components.subtreeHidden(this._containerElem[0]);
      }
      return Promise.resolve();
    }

    // Now that we know that we have results to show, we need to make sure that the dropdown is being shown
    this._containerElem.removeClass(this._NO_RESULTS_FOUND_CLASSNAME);
    if (!isOpen) {
      oj.Components.subtreeShown(this._containerElem[0]);
    }

    if (initial) {
      return this._ConfigureResultsInitial(selectedValue, busyContext);
    }

    if (searchText == null || searchText === '') {
      return this._ConfigureResultsNoSearchText(selectedValue, busyContext);
    }

    return this._ConfigureResultsWithSearchText(selectedValue, busyContext);
  };

  /**
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  LovDropdown.prototype._ConfigureResultsInitial = function (selectedValue, busyContext) {
    oj.Assert.failedInAbstractFunction();
    return busyContext.whenReady();
  };

  /**
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  LovDropdown.prototype._ConfigureResultsNoSearchText = function (busyContext) {
    oj.Assert.failedInAbstractFunction();
    return busyContext.whenReady();
  };

  /**
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  LovDropdown.prototype._ConfigureResultsWithSearchText = function (busyContext) {
    oj.Assert.failedInAbstractFunction();
    return busyContext.whenReady();
  };

  /**
   * Fetches the first result from the data provider (first leaf for the tree data)
   *
   * @return {Promise<ItemContext>} returns a promise that resolves to ItemContext representing the first data
   *
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  LovDropdown.prototype._FetchFirstResult = function () {
    if (oj.DataProviderFeatureChecker.isTreeDataProvider(this._dataProvider)) {
      return this._fetchFirstLeafData();
    }

    return this._fetchFirstFlatData();
  };

  /**
   * Fetches the first data from flat data provider
   *
   * @return {Promise<ItemContext>} returns a promise that resolves to ItemContext representing the first data
   *
   * @memberof LovDropdown
   * @instance
   * @private
   */
  LovDropdown.prototype._fetchFirstFlatData = function () {
    // Filter criteria should already be set in the data provider, we just
    // need to fetch the first result
    const fetchPromise = this._dataProvider.fetchByOffset({ offset: 0, size: 1 });
    let result = null;
    const parseResults = function (fetchResults) {
      if (fetchResults != null) {
        const results = fetchResults.results;
        if (results.length > 0) {
          // Create value item from the first result item.
          result = this._createValueItemFromItem(results[0]);
        }
      }
      return Promise.resolve(result);
    }.bind(this);

    return fetchPromise.then(parseResults);
  };

  /**
   * Fetches the first leaf data from tree data provider
   *
   * @return {Promise<ItemContext>} returns a promise that resolves to ItemContext representing the first data
   *
   * @memberof LovDropdown
   * @instance
   * @private
   */
  LovDropdown.prototype._fetchFirstLeafData = function () {
    // Filter criteria should already be set in the data provider, we just
    // need to fetch the first result
    const rootDP = this._dataProvider;
    let done = false;

    /**
     * Fetches the data recursively through the tree data provider to find the first
     * matching leaf node.
     *
     * @param {DataProvider} dataProvider The current data provider instance (group/child)
     * @param {string|Array<string>|null} key An optional key for the current data provider instance
     *
     * @return {Promise<Object|null>} A promise that resolves to the first matched value-item or
     *                                null if no match is found.
     * @ignore
     */
    const fetchDataRecursively = function (dataProvider, key) {
      let offset = 0;
      let totalItems;
      if (key != null) {
        // Check if the count is stored in the root DP as list view calls the getChildDataProvider on the
        // root DP for all the child nodes at any depth. So the count will be stored in the root DP.
        const childCountMap = rootDP.getFetchedDataCount().childrenCountMap;
        if (childCountMap && childCountMap.has(key)) {
          totalItems = childCountMap.get(key).count;
        }
      }

      // If we are in the root node, the key will be null, so fetch the count directly from
      // the current DP instance. Also, if we are in a child node and it's count is not found in
      // the root DP, then also get it from the current DP instance.
      if (totalItems == null) {
        totalItems = dataProvider.getFetchedDataCount().count || 0;
      }

      // If there are no items fetched in this level, then there will not be any matching items,
      // so skip fetching further
      if (totalItems === 0) {
        return Promise.resolve(null);
      }

      /**
       * Processes the results from the fetchByOffset call to determine whether we are
       * at the last group node and fetches the first matching leaf node. If we are not at
       * the last group node, this recursively fetches the child nodes. If no match is found in
       * a group node, the next group node at the same level is processed until a match is found.
       *
       * @param {FetchByOffsetResults} fetchResults Results from the fetchByOffset call
       *
       * @return {Promise<Object|null>} A promise that resolves to the first matched value-item or
       *                                null if no match is found.
       * @ignore
       */
      const processChunk = function (fetchResults) {
        const results = fetchResults.results;
        // The total items count represents the number of items fetched at this level. Since
        // the item we need to select should have been fetched already, we can search only within the
        // range of this count. This would also make sure that we only search in the cache if available.
        let fetchDone = totalItems === 0 || totalItems === offset + 1;
        let processChunkPromise;

        if (results.length) {
          // Fetch return an item, check if the item is a leaf node and a match
          // or a group node.
          const item = results[0];
          const itemMetadata = item.metadata;

          // Check if child is present
          // List View gets the child DP from the RootDP, so we will be doing the same
          // to make sure we hit the cache
          const childDataProvider = rootDP.getChildDataProvider(itemMetadata.key);

          if (childDataProvider != null) {
            // The fetched item is a group node, so continue fetching recursively
            processChunkPromise = fetchDataRecursively(childDataProvider, itemMetadata.key);
          } else {
            // The fetched item is a leaf node and a match. Store it in result and
            // finish the process
            const result = this._createValueItemFromItem(item);
            done = true;
            processChunkPromise = Promise.resolve(result);
          }
        } else {
          // Fetch returned empty. Resolve the current process with null.
          processChunkPromise = Promise.resolve(null);
          // Set fetchDone flag irrespective of the current offset and total items count
          // as all the results are fetched.
          fetchDone = true;
        }

        // Once the processChunkPromise is resolved, check if the match is found.
        return processChunkPromise.then(function (result) {
          // If the fetch is done at the current level or if the match is found,
          // resolve the process with whatever available in the result. There is
          // nothing else to do.
          if (fetchDone || done) {
            return Promise.resolve(result);
          }

          // If the fetch is not done and a match is also not found, then get the next node
          // and do the same process.
          offset += 1;
          return dataProvider.fetchByOffset({ offset: offset, size: 1 }).then(processChunk);
        });
      }.bind(this);

      // Fetch the first result and start processing it.
      return dataProvider.fetchByOffset({ offset: offset, size: 1 }).then(processChunk);
    }.bind(this);

    // Recursively fetch the data to get the first matching leaf-node
    return fetchDataRecursively(rootDP, null);
  };

  /**
   * Clears the selection in the dropdown
   *
   * @memberof LovDropdown
   * @protected
   * @instance
   */
  LovDropdown.prototype._ClearSelection = function () {
    this._SetCollectionCurrentRow({ rowKey: null });
    this._SetCollectionSelectedKeySet(new ojkeyset.KeySetImpl([]));
  };

  LovDropdown.prototype._clearContextRenderPromiseFunctions = function (context) {
    // eslint-disable-next-line no-param-reassign
    context.renderDone = null;
    // eslint-disable-next-line no-param-reassign
    context.renderError = null;
  };

  /**
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  LovDropdown.prototype._GetDefaultCollectionRendererSelectionMode = function () {
    oj.Assert.failedInAbstractFunction();
    return null;
  };

  LovDropdown.prototype._defaultCollectionRenderer = function (context) {
    var listView;
    var busyContext;
    var contextRenderDone = context.renderDone;
    var contextRenderError = context.renderError;
    if (!this._resultsElem) {
      var $parentElem = $(context.parentElement);
      var placeholderElem = $parentElem.find('.oj-searchselect-results-placeholder')[0];
      var idSuffix = context.idSuffix;

      listView = document.createElement('oj-list-view');
      listView.setAttribute('data-oj-internal', '');
      listView.setAttribute('data-oj-binding-provider', 'none');
      listView.setAttribute('id', 'oj-searchselect-results-' + idSuffix);
      listView.setAttribute('selection-mode', this._GetDefaultCollectionRendererSelectionMode());
      listView.setAttribute('class', 'oj-select-results oj-group-header-sm');
      listView.setAttribute('drill-mode', 'none');
      listView.setAttribute('gridlines.item', 'hidden');

      // Add an empty noData container since we will be hiding the dropdown when
      // there is no data.
      // We need to have an empty noData container otherwise listView's default
      // template shows "No items to display" text which flashes for a brief period of time
      // before we hide the dropdown.
      var noDataTemplate = document.createElement('template');
      noDataTemplate.setAttribute('slot', 'noData');
      var noDataContainer = document.createElement('div');
      noDataContainer.setAttribute('class', 'oj-searchselect-no-results-container');
      // need to append to content documentFragment of template element instead of template itself
      // (the content doc fragment is undefined in IE11, so just append to the template itself)
      if (noDataTemplate.content) {
        noDataTemplate.content.appendChild(noDataContainer);
      } else {
        noDataTemplate.appendChild(noDataContainer);
      }
      listView.appendChild(noDataTemplate);

      context.parentElement.replaceChild(listView, placeholderElem);

      this._resultsElem = $(listView);
      this._resultsElem.on('click', LovUtils.killEvent);

      busyContext = Context.getContext(listView).getBusyContext();
      busyContext.whenReady().then(
        function () {
          listView.addEventListener('ojItemAction', context.handleRowAction);
          listView.addEventListener('currentItemChanged', function (event) {
            // Call the handler to update the collection context accordingly
            context.currentRowKeyChangedListener(event.detail.value);
          });
          if (
            context.data &&
            oj.DataProviderFeatureChecker &&
            oj.DataProviderFeatureChecker.isTreeDataProvider(context.data)
          ) {
            // Only allow leaf nodes to be focusable/selectable
            listView.setProperty('item.focusable', (fc) => fc.leaf);
            listView.setProperty('item.selectable', (sc) => sc.leaf);
          }

          if (this._itemTemplate) {
            this._getTemplateEngineFunc().then(
              function (templateEngine) {
                this._templateEngine = templateEngine;
                listView.setProperty(
                  'item.renderer',
                  this._templateItemRenderer.bind(this, templateEngine)
                );
                this._clearContextRenderPromiseFunctions(context);
                contextRenderDone();
              }.bind(this),
              function (reason) {
                Logger.warn(
                  'Select: template item renderer template engine promise rejected: ' + reason
                );
                this._clearContextRenderPromiseFunctions(context);
                contextRenderError(reason);
              }.bind(this)
            );
          } else {
            listView.setProperty('item.renderer', this._defaultItemRenderer.bind(this));
            this._clearContextRenderPromiseFunctions(context);
            contextRenderDone();
          }
        }.bind(this),
        function (reason) {
          Logger.warn('Select: creating default listView busyContext promise rejected: ' + reason);
          this._clearContextRenderPromiseFunctions(context);
          contextRenderError(reason);
        }.bind(this)
      );
    } else {
      listView = this._resultsElem[0];
      // Need to wait until _SetupResources is called asynchronously on listView so that when we
      // set properties on it, the internal listView.isAvailable() call returns true and
      // listView will process them
      busyContext = Context.getContext(listView).getBusyContext();
      busyContext.whenReady().then(
        function () {
          listView.data = context.data;
          listView.selected = context.selected;
          listView.currentItem = context.currentRow.rowKey;
          this._clearContextRenderPromiseFunctions(context);
          contextRenderDone();
        }.bind(this),
        function (reason) {
          Logger.warn(
            'Select: busyContext promise rejected before setting props on listView: ' + reason
          );
          this._clearContextRenderPromiseFunctions(context);
          contextRenderError(reason);
        }.bind(this)
      );
    }
  };

  LovDropdown.prototype._templateCollectionRenderer = function (context) {
    var contextRenderDone = context.renderDone;
    var contextRenderError = context.renderError;
    if (!this._resultsElem) {
      var $parentElem = $(context.parentElement);
      var placeholderElem = $parentElem.find('.oj-searchselect-results-placeholder')[0];
      this._getTemplateEngineFunc().then(
        function (templateEngine) {
          this._templateEngine = templateEngine;
          this._collectionTemplateContext = this._createCollectionTemplateContext(
            templateEngine,
            context
          );
          var nodes = templateEngine.execute(
            this._templateContextComponentElement,
            this._collectionTemplate,
            this._collectionTemplateContext
          );

          for (var i = 0; i < nodes.length; i++) {
            placeholderElem.parentNode.insertBefore(nodes[i], placeholderElem);
          }
          // remove the placeholder elem because it's no longer needed
          placeholderElem.parentNode.removeChild(placeholderElem);
          this._resultsElem = $parentElem.find('.oj-select-results'); // '.oj-listbox-results'
          this._resultsElem.on('click', LovUtils.killEvent);
          this._clearContextRenderPromiseFunctions(context);
          contextRenderDone();
        }.bind(this),
        function (reason) {
          Logger.warn(
            'Select: template collection renderer template engine promise rejected: ' + reason
          );
          this._clearContextRenderPromiseFunctions(context);
          contextRenderError(reason);
        }.bind(this)
      );
    } else {
      var templateContext = this._collectionTemplateContext;
      templateContext.data = context.data;
      templateContext.searchText = context.searchText;
      templateContext.selected = context.selected;
      this._clearContextRenderPromiseFunctions(context);
      contextRenderDone();
    }
  };

  LovDropdown.prototype._addDataProviderEventListeners = function () {
    var dataProvider = this._dataProvider;
    if (dataProvider) {
      var dataProviderEventHandler = this._handleDataProviderEvent.bind(this);
      this._savedDataProviderEH = dataProviderEventHandler;

      dataProvider.addEventListener('mutate', dataProviderEventHandler);
      dataProvider.addEventListener('refresh', dataProviderEventHandler);
    }
  };

  LovDropdown.prototype._removeDataProviderEventListeners = function () {
    var dataProvider = this._dataProvider;
    var dataProviderEventHandler = this._savedDataProviderEH;

    if (dataProvider && dataProviderEventHandler) {
      dataProvider.removeEventListener('mutate', dataProviderEventHandler);
      dataProvider.removeEventListener('refresh', dataProviderEventHandler);
    }
    this._savedDataProviderEH = undefined;
  };

  // eslint-disable-next-line no-unused-vars
  LovDropdown.prototype._handleDataProviderEvent = function (event) {
    // need to add busy state around potential listView animation
    var resolveBusyState = this._addBusyStateFunc('LovDropdown handling data provider event');

    var busyContext = Context.getContext(this._containerElem[0]).getBusyContext();
    busyContext.whenReady().then(
      function () {
        resolveBusyState();
      },
      function (reason) {
        Logger.warn(
          'Select: LovDropdown.handleDataProviderEvent busyContext promise rejected: ' + reason
        );
        resolveBusyState();
      }
    );
  };

  LovDropdown.prototype.close = function () {
    // this._dispatchEvent('currentItemChanged', { key: null });

    // JET-37797 - can't close dropdown while list is loading
    // clear the most recent promise because the dropdown is now closed and we don't need to update
    this._lastRenderResultsPromise = null;

    //  - firefox: can't arrow into dropdown after clicking outside lov
    // explicitly blur the focused element in the dropdown before closing it
    var activeElem = document.activeElement;
    if (DomUtils.isAncestor(this.getElement(), activeElem)) {
      activeElem.blur();
    }

    // Reset the selection
    this._ClearSelection();

    // JET-38215 - SELECT SINGLE - KEYBOARD NAVIGATION FOR COLLECTION TEMPLATE USAGE
    // Original logic updated for JET-49906 - IN ACCESSIBILITY MODE, THE FIRST DROPDOWN VALUE IS READ TWICE
    // remove the first result as we do not need it anymore
    this._firstResultForKeyboardFocus = null;

    // Add data-oj-suspend so that dropdown collections go into suspended mode when the dropdown is closed
    this._containerElem.attr('data-oj-suspend', '');

    /** @type {!Object.<oj.PopupService.OPTION, ?>} */
    var psOptions = {};
    psOptions[oj.PopupService.OPTION.POPUP] = this._containerElem;
    oj.PopupService.getInstance().close(psOptions);

    // this._containerElem.removeAttr('id');

    // JET-61331 - Select one choice LOV dropdown flowing out of the browser and adjusting when the
    // page is scrolled up or down
    // maintain a flag when the dropdown is open so we know when to handle resize events
    this._dropdownOpen = false;

    this._dispatchEvent('dropdownClosed');
  };

  LovDropdown.prototype.open = function () {
    var containerElem = this._containerElem;

    // JET-37797 - can't close dropdown while list is loading
    // remove the 'no results found' style class until we know it's needed
    this._containerElem.removeClass(this._NO_RESULTS_FOUND_CLASSNAME);

    // Remove data-oj-suspend so that dropdown collections come back from suspended mode when dropdown is opened
    this._containerElem.removeAttr('data-oj-suspend');

    // if (this._searchElem) {
    //   this._searchElem.val('');
    // }

    // TODO: we should use oj-popup instead of using the popup service directly, and then oj-popup
    // could handle some of the focus functionality, like trapping TABS
    var psEvents = {};
    psEvents[oj.PopupService.EVENT.POPUP_CLOSE] = function () {
      this._dispatchEvent('closeDropdown', { trigger: 'popupCloseEvent' });
    }.bind(this);
    psEvents[oj.PopupService.EVENT.POPUP_REMOVE] = this._surrogateRemoveHandler.bind(this);
    psEvents[oj.PopupService.EVENT.POPUP_AUTODISMISS] = this._clickAwayHandler.bind(this);
    psEvents[oj.PopupService.EVENT.POPUP_REFRESH] = function () {
      this._sizeAndAdjustPosition(containerElem[0]);
    }.bind(this);
    psEvents[oj.PopupService.EVENT.POPUP_AFTER_OPEN] = function (event) {
      var dropdownElem = event.popup[0];
      this._sizeAndAdjustPosition(dropdownElem);

      if (this._fullScreenPopup) {
        dropdownElem.scrollIntoView();
      }

      // JET-61331 - Select one choice LOV dropdown flowing out of the browser and adjusting when the
      // page is scrolled up or down
      // maintain a flag when the dropdown is open so we know when to handle resize events
      this._dropdownOpen = true;
    }.bind(this);

    /** @type {!Object.<oj.PopupService.OPTION, ?>} */
    var psOptions = {};
    psOptions[oj.PopupService.OPTION.POPUP] = containerElem;
    psOptions[oj.PopupService.OPTION.EVENTS] = psEvents;
    psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = 'oj-listbox-drop-layer';
    psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = true;
    if (this._fullScreenPopup) {
      psOptions[oj.PopupService.OPTION.MODALITY] = oj.PopupService.MODALITY.MODAL;
    }

    this._dispatchEvent('openPopup', { psOptions: psOptions });
  };

  // Size the dropdown and adjust its position
  LovDropdown.prototype._sizeAndAdjustPosition = function (dropdownElem) {
    this._dispatchEvent('sizeDropdown');

    // JET-34367 - remove code to update popup position on refresh
    // Position a proxy element instead of the real dropdown so that we don't have to
    // change the size of the dropdown before calculating the position, because changing
    // the size of the dropdown before positioning may reset the results' scroll position and
    // prevent the user from scrolling down.
    this._bodyElem.append(this._dropdownPositioningProxyContainer); // @HTMLUpdateOK
    this._dispatchEvent('adjustDropdownPosition', {
      popupElem: dropdownElem,
      positioningProxyElem: this._dropdownPositioningProxyContainer.children()[0]
    });
    this._dropdownPositioningProxyContainer.detach();
  };

  // JET-61331 - Select one choice LOV dropdown flowing out of the browser and adjusting when the
  // page is scrolled up or down
  // add a resize listener to the desktop dropdown so that we can reposition it after the content
  // renders
  LovDropdown.prototype._handleResize = function () {
    // don't handle the resize if the dropdown is no longer open or attached to the DOM
    if (
      !this._dropdownOpen ||
      !this._containerElem ||
      !this._containerElem[0] ||
      !this._containerElem[0].parentElement
    ) {
      return;
    }

    this._sizeAndAdjustPosition(this._containerElem[0]);
  };

  LovDropdown.prototype._addResizeListener = function (element) {
    if (element) {
      if (this._resizeHandler == null) {
        this._resizeHandler = this._handleResize.bind(this);
      }
      DomUtils.addResizeListener(element, this._resizeHandler, 30, true);
    }
  };

  LovDropdown.prototype._removeResizeListener = function (element) {
    if (element && this._resizeHandler) {
      DomUtils.removeResizeListener(element, this._resizeHandler);
      this._resizeHandler = null;
    }
  };

  LovDropdown.prototype._clickAwayHandler = function (event) {
    var containerElem = this._containerElem;

    //  - period character in element id prevents options box open/close;
    // escapeSelector handles special characters
    var $target = $(event.target);
    if (
      $target.closest(containerElem).length ||
      $target.closest('#' + $.escapeSelector(containerElem.attr('data-oj-containerid'))).length
    ) {
      return;
    }

    // if the target is in a popup nested within the open dropdown, like in the dropdown of
    // an oj-select or oj-combobox in the custom header, then keep the dropdown open
    var closestDropLayer = containerElem.closest('.oj-listbox-drop-layer');
    if (closestDropLayer.length > 0 && $target.closest(closestDropLayer).length > 0) {
      return;
    }

    if (containerElem.length > 0) {
      this._dispatchEvent('closeDropdown', { trigger: 'clickAway' });
    }
  };

  LovDropdown.prototype._surrogateRemoveHandler = function () {
    if (this._containerElem) {
      this._containerElem.remove();
    }
  };

  /**
   * Handle keydown event to process focusing to/from the drop down
   * @param {jQueryEvent} e The jQuery event object
   */
  LovDropdown.prototype._handleKeyDown = function (e) {
    // JET-44374 - qunit combobox ojselect tests fail with new jquery 3.6.0
    // e.which no longer gets populated when simulating events with keyCode specified, so
    // check both properties on the event
    var keyCode = e.which || e.keyCode;
    if (keyCode === LovUtils.KEYS.TAB) {
      // Dispatch event so that ojselect can react to this event
      // Do not kill the event as we want the focus to be moved to the next component
      this._dispatchEvent('tabOut');
    } else if (keyCode === LovUtils.KEYS.ESC) {
      this._dispatchEvent('closeDropdown', { trigger: 'escKeyDown' });
    }
  };

  /**
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  LovDropdown.prototype._HandleCollectionSelectedItemChanged = function (_valueItem, event) {
    // Subclasses can override to do something if necessary
  };

  /**
   * Performs actions that have to be done when the oj-table updates the currentRow
   * property.
   *
   * @param {oj.ojTable.CurrentRow<K>} currentRow The object containing the rowKey of the current selected row
   *
   * @memberof LovDropdown
   * @instance
   * @private
   */
  LovDropdown.prototype._handleCollectionCurrentRowChanged = function (currentRow) {
    // Do nothing if called during the initialization phase or when the currentRow is null,
    // or when we're pushing changes due to the collection receiving focus
    if (
      this._duringListViewInitialization ||
      currentRow == null ||
      this._handlingCollectionFocusinOnce
    ) {
      return;
    }
    // keep context up to date, make a copy since we do not want to modify the reference
    this._collectionContext.currentRow = {
      rowIndex: currentRow.rowIndex,
      rowKey: currentRow.rowKey
    };
    // Call the currentRow.rowKey handler with the current rowKey
    this._handleCollectionCurrentRowKeyChanged(currentRow.rowKey);
  };

  /**
   * Performs operations that have to be done when the collection updates the currentRow
   * property
   *
   * @param {K} rowKey The current selected item's key
   *
   * @memberof LovDropdown
   * @instance
   * @private
   */
  LovDropdown.prototype._handleCollectionCurrentRowKeyChanged = function (rowKey) {
    // Do nothing if called during the initialization phase or when the rowKey is null,
    // or when we're pushing changes due to the collection receiving focus
    if (this._duringListViewInitialization || rowKey == null || this._handlingCollectionFocusinOnce) {
      return;
    }
    // keep context up to date
    this._collectionContext.currentRow.rowKey = rowKey;
  };

  /**
   * Performs actions that have to be done when a row/item is selected from the collection
   *
   * @param {CustomEvent} event ojRowAction or ojItemAction event object
   * @param {ItemContext} context
   *
   * @memberof LovDropdown
   * @instance
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  LovDropdown.prototype._handleRowAction = function (event, context) {
    var valueItem = this._createValueItemFromItem(event.detail.context);
    this._handleSelection(valueItem, event);
  };

  LovDropdown.prototype._handleSelection = function (valueItem, event) {
    if (valueItem) {
      this._dispatchEvent('handleSelection', { valueItem: valueItem, event: event });
    }
  };

  LovDropdown.prototype._createCollectionTemplateContext = function (templateEngine, context) {
    var templateContext = {};
    if (templateEngine) {
      // if data changes, we recreate the whole dropdown and collection, so don't need this to be
      // trackable
      templateContext.data = context.data;
      // don't need searchText to be trackable because it's most likely only used in a row template,
      // which would get explicitly re-rendered when it changes
      templateContext.searchText = context.searchText;

      // make this trackable because we expect to push to it on each render
      templateEngine.defineTrackableProperty(templateContext, 'selected');

      // pass listener so we can react to writebacks made by the collection
      templateEngine.defineTrackableProperty(
        templateContext,
        'selectedItem',
        undefined,
        context.selectedItemChangedListener
      );

      // currentRow property is an object and we expect the collection to writeback
      // we need to consider two cases here:
      //  1. if oj-table is used as a collection template, it updates the currentRow
      //     property directly
      //  2. if oj-list-view is used as a collection template, it updates the rowKey
      //     property of the currentRow property
      // so, we need to define two trackable properties
      let currentRow = {};
      templateEngine.defineTrackableProperty(
        currentRow,
        'rowKey',
        undefined,
        context.currentRowKeyChangedListener
      );
      templateEngine.defineTrackableProperty(
        templateContext,
        'currentRow',
        currentRow,
        context.currentRowChangedListener
      );

      // this an event listener and so we don't expect a writeback for this property
      templateContext.handleRowAction = context.handleRowAction;
    } else {
      Logger.error(
        'JET Select: template engine not available when creating context for collectionTemplate'
      );
    }

    return templateContext;
  };

  /**
   * Creates the value item from the dataprovider item
   *
   * @param {Item} item the item fetched from the data provider
   * @returns {Object} the constructed value item
   *
   * @memberof LovDropdown
   * @private
   * @instance
   */
  LovDropdown.prototype._createValueItemFromItem = function (item) {
    if (item.data == null || item.metadata == null) {
      return null;
    }

    return {
      key: item.metadata.key,
      data: item.data,
      metadata: item.metadata
    };
  };

  /**
   * Setter function for selected property of the collectionTemplate context
   *
   * @param {KeySet} selected new selected keyset
   *
   * @memberof LovDropdown
   * @protected
   * @instance
   */
  LovDropdown.prototype._SetCollectionSelectedKeySet = function (selected) {
    // Keep the collection context in sync
    this._collectionContext.selected = selected;

    if (this._collectionTemplateContext != null) {
      this._collectionTemplateContext.selected = selected;
    } else if (this._collectionTemplate == null && this._resultsElem) {
      // If no collection template is present, that means default
      // list view is being used, set the property using this._resultsElem
      this._resultsElem[0].setProperty('selected', selected);
    }
  };

  /**
   * Sets the currentRow property of the collection template context
   *
   * @param {oj.ojTable.CurrentRow<K>} currentRow The object containing the rowKey of the current selected row
   *
   * @memberof LovDropdown
   * @protected
   * @instance
   */
  LovDropdown.prototype._SetCollectionCurrentRow = function (currentRow) {
    // keep context up to date, make a copy since we do not want to modify the reference
    this._collectionContext.currentRow = {
      rowIndex: currentRow.rowIndex,
      rowKey: currentRow.rowKey
    };

    if (this._collectionTemplateContext != null) {
      // Since the reference is changed, we will have to reinitialize listener to the
      // rowKey property
      this._addListenerForRowKeyProperty(currentRow);
      this._collectionTemplateContext.currentRow = currentRow;
    } else if (this._collectionTemplate == null && this._resultsElem) {
      // If no collection template is present, that means default
      // list view is being used, set the property using this._resultsElem
      this._resultsElem[0].setProperty('currentItem', currentRow.rowKey);
    }
  };

  /**
   * Retrives the current value item for selection
   *
   * @return {Object=} The current value item
   *
   * @memberof LovDropdown
   * @public
   * @instance
   * @ignore
   */
  LovDropdown.prototype.getValueItemForSelection = function () {
    var _rowKey = this._collectionContext.currentRow.rowKey;
    var _firstItem = this._currentFirstItem;
    var _selectedItem = this._collectionContext.selectedItem;

    // First check if current row exists
    if (_rowKey != null) {
      let returnValueItem = {};
      returnValueItem.key = _rowKey;
      // If the current row is the first item in the dropdown
      // we will already have the data
      if (_firstItem && _firstItem.key === _rowKey) {
        returnValueItem.data = _firstItem.data;
        returnValueItem.metadata = _firstItem.metadata;
      }
      return returnValueItem;
    }

    // If current row key does not exist, return the selected item
    return _selectedItem;
  };

  /**
   * Gets the result count shown in the dropdown
   *
   * @return {Object} The result count object of type { count: number, done: boolean}
   *
   * @memberof LovDropdown
   * @instance
   * @public
   * @ignore
   */
  LovDropdown.prototype.getResultsCount = function () {
    return this._resultsCount;
  };

  /**
   * Focuses the collection component.
   *
   * @return {Promise} A promise indicating that focus has been set on the collection component
   *
   * @memberof LovDropdown
   * @instance
   * @public
   * @ignore
   */
  LovDropdown.prototype.focus = function () {
    const resolveBusyState = this._addBusyStateFunc('LovDropdown focusing the collection component');
    return this._handleCollectionFocus().then(
      function () {
        FocusUtils.focusFirstTabStop(this.getElement());
        resolveBusyState();
      }.bind(this)
    );
  };

  /**
   * Sets the current first value item
   *
   * @param {Object=} valueItem The current value item
   *
   * @memberof LovDropdown
   * @protected
   * @instance
   */
  LovDropdown.prototype._SetCurrentFirstItem = function (valueItem) {
    this._currentFirstItem = valueItem;
  };

  /**
   * Adds listener for rowKey property of the currentRow property
   *
   * @param {oj.ojTable.CurrentRow<K>} currentRow The current row object
   *
   * @memberof LovDropdown
   * @private
   * @instance
   */
  LovDropdown.prototype._addListenerForRowKeyProperty = function (currentRow) {
    var context = this._collectionContext;
    var rowKey = currentRow.rowKey;
    // add trackable property rowKey
    if (this._templateEngine) {
      this._templateEngine.defineTrackableProperty(
        currentRow,
        'rowKey',
        rowKey,
        context.currentRowKeyChangedListener
      );
    }
  };

  // JET-38215 - SELECT SINGLE - KEYBOARD NAVIGATION FOR COLLECTION TEMPLATE USAGE
  // Original logic updated for JET-49906 - IN ACCESSIBILITY MODE, THE FIRST DROPDOWN VALUE IS READ TWICE
  /**
   * Fetches the first result from the data provider and sets it as the current row if the
   * collection gets keyboard focus.
   *
   * @return {Promise} returns a promise that resolves after the first result is fetched
   *
   * @memberof LovDropdown
   * @instance
   * @protected
   */
  LovDropdown.prototype._FetchFirstResultForKeyboardFocus = function () {
    var busyContext = Context.getContext(this._containerElem[0]).getBusyContext();
    this._firstResultForKeyboardFocus = null;
    return this._FetchFirstResult().then(
      function (data) {
        if (data != null) {
          // if there are results, save the data so that it can be used for setting the
          // current row when we need to focus the collection element.
          this._firstResultForKeyboardFocus = data;
        }
        return busyContext.whenReady();
      }.bind(this)
    );
  };

  // JET-38215 - SELECT SINGLE - KEYBOARD NAVIGATION FOR COLLECTION TEMPLATE USAGE
  // Original logic updated for JET-49906 - IN ACCESSIBILITY MODE, THE FIRST DROPDOWN VALUE IS READ TWICE
  /**
   * Setup collection component before focusing it. This sets the first result as the current row when
   * the LovDropdown.focus is called.
   *
   * @memberof LovDropdown
   * @instance
   * @private
   */
  LovDropdown.prototype._handleCollectionFocus = function () {
    var resolveBusyState = this._addBusyStateFunc('LovDropdown setting selected KeySet on focusin');

    // ignore if we do not have first row data
    if (!this._firstResultForKeyboardFocus) {
      // Return a Promise to be consistent with the else path. Make sure to set and resolve the busy context.
      return Promise.resolve().then(function () {
        resolveBusyState();
      });
    }

    // JET-39993 - Select2 options qunit tests fail using chrome and safari on Mac for master branch
    // set flag while we're setting the collection current row and selected key set because we don't
    // need to react to changes that we're pushing
    this._handlingCollectionFocusinOnce = true;

    this._SetCollectionCurrentRow({ rowKey: this._firstResultForKeyboardFocus.key });

    var busyContext = Context.getContext(this._containerElem[0]).getBusyContext();
    return busyContext.whenReady().then(
      function () {
        this._handlingCollectionFocusinOnce = false;
        this._firstResultForKeyboardFocus = null;
        resolveBusyState();
      }.bind(this)
    );
  };

  /**
   * @private
   */
  const LovMainField = function (options) {
    // {className, ariaLabel, ariaControls, componentId,
    //  inputType, enabled, readOnly, placeholder, addBusyStateFunc,
    //  forceReadOnly, endContent, createOrUpdateReadonlyDivFunc}
    this._addBusyStateFunc = options.addBusyStateFunc;
    this._forceReadOnly = options.forceReadOnly;
    this._createOrUpdateReadonlyDivFunc = options.createOrUpdateReadonlyDivFunc;

    this._containerElem = this._createInnerDom(options);
    var $containerElem = $(this._containerElem);
    var $inputElem = $containerElem.find('input.' + options.className + '-input');
    this._inputElem = $inputElem[0];
  };

  LovMainField.prototype.getElement = function () {
    return this._containerElem;
  };

  LovMainField.prototype.getInputElem = function () {
    return this._inputElem;
  };

  /**
   * Returns the value of the input element
   *
   * @return {string} the value of the input element
   *
   * @memberof LovMainField
   * @public
   * @instance
   * @ignore
   */
  LovMainField.prototype.getInputText = function () {
    return this._inputElem.value || '';
  };

  LovMainField.prototype._createInnerDom = function (options) {
    var className = options.className;
    var componentId = options.componentId;
    var inputType = options.inputType;
    var enabled = options.enabled;
    var readonly = options.readOnly;
    var ariaLabel = options.ariaLabel;
    var ariaControls = options.ariaControls;
    var cachedMainFieldInputElement = options.cachedMainFieldInputElement;

    var textFieldContainer = document.createElement('div');
    textFieldContainer.setAttribute(
      'class',
      'oj-text-field-container oj-searchselect-main-field oj-text-field-has-end-slot'
    );
    textFieldContainer.setAttribute('role', 'presentation');

    var labelValueDiv = document.createElement('div');
    labelValueDiv.setAttribute('class', 'oj-text-field-middle');
    textFieldContainer.appendChild(labelValueDiv); // @HTMLUpdateOK

    var input = cachedMainFieldInputElement || document.createElement('input');
    // use the same id convention as EditableValueUtils._initInputIdLabelForConnection
    input.setAttribute('id', componentId + '|input');
    // JET-37990 - oj-select-single: autocomplete is not disabled in chrome browser
    // Chrome used to ignore "off" value, but as of Chrome 81 it works more reliably
    // (https://stackoverflow.com/questions/57367813/2019-chrome-76-approach-to-autocomplete-off)
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    input.setAttribute('spellcheck', 'false');
    input.setAttribute('class', className + '-input oj-text-field-input');
    input.setAttribute('aria-autocomplete', 'list');
    input.setAttribute('placeholder', options.placeholder);
    input.disabled = !enabled && !readonly;
    if (readonly || (this._forceReadOnly && enabled)) {
      input.setAttribute('readonly', 'true');
    }
    if (!readonly) {
      input.setAttribute('role', 'combobox');
      input.setAttribute('aria-expanded', 'false');
    }
    if (ariaLabel) {
      input.setAttribute('aria-label', ariaLabel);
    }
    if (ariaControls) {
      input.setAttribute('aria-controls', ariaControls);
    }
    // apply virtualKeyboard input type to search field
    if (inputType !== null && inputType !== '') {
      input.setAttribute('type', inputType);
    } else {
      input.setAttribute('type', 'text');
    }
    labelValueDiv.appendChild(input);

    if (options.endContent) {
      textFieldContainer.appendChild(options.endContent);
    }
    // create readonly div and insert before input for consistency with other form comps.
    if (readonly) {
      this._createOrUpdateReadonlyDivFunc(input);
    }

    return textFieldContainer;
  };

  /**
   * Update the label associated with the field.
   * @param {string} labelledBy Id of the label
   * @param {string} ariaLabel The aria-label text
   */
  LovMainField.prototype.updateLabel = function (labelledBy, ariaLabel) {
    if (labelledBy) {
      this._inputElem.setAttribute('aria-labelledby', labelledBy);
      this._inputElem.removeAttribute('aria-label');
    } else if (ariaLabel) {
      this._inputElem.setAttribute('aria-label', ariaLabel);
      this._inputElem.removeAttribute('aria-labelledby');
    }
  };

  /**
   * @ojcomponent oj.ojSelectBase
   * @augments oj.editableValue
   * @since 8.0.0
   * @abstract
   * @hideconstructor
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "TextFilter"]}
   * @ojtsimport {module: "ojcommontypes", type: "AMD", importName: ["ojcommontypes"]}
   * @ojsignature [{
   *                target: "Type",
   *                value: "abstract class ojSelectBase<V, D, SP extends ojSelectBaseSettableProperties<V, D>> extends editableValue<V, SP>"
   *               },
   *               {
   *                target: "Type",
   *                value: "ojSelectBaseSettableProperties<V, D> extends editableValueSettableProperties<V>",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @classdesc
   */

  oj.__registerWidget('oj.ojSelectBase', $.oj.editableValue, {
    defaultElement: '<input>',
    widgetEventPrefix: 'oj',

    /**
     * Input types for virtual keyboard.
     * @private
     */
    _ALLOWED_INPUT_TYPES: ['email', 'number', 'search', 'tel', 'text', 'url'],

    /**
     * Options that require a refresh when changed.
     * @private
     */
    _OPTIONS_REQUIRING_REFRESH: new Set(['disabled', 'readOnly', 'placeholder', 'data']),

    options: {
      /**
       * The placeholder text to set on the element. The placeholder specifies a short hint that can
       * be displayed before user selects or enters a value.
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">placeholder</code> attribute specified:</caption>
       * &lt;oj-select-single placeholder="Please select ...">&lt;/oj-select-single>
       *
       * @example <caption>Get or set the <code class="prettyprint">placeholder</code> property after initialization:</caption>
       * // getter
       * var placeholderValue = mySelect.placeholder;
       *
       * // setter
       * mySelect.placeholder = "Select a value";
       *
       * @name placeholder
       * @ojshortdesc A short hint that can be displayed before user selects or enters a value.
       * @ojtranslatable
       * @expose
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       * @type {string}
       * @default ''
       * @ojtranslatable
       */
      placeholder: '',

      /**
       * {@ojinclude "name":"selectCommonData"}
       * @name data
       * @ojshortdesc The data for the Select.
       * @expose
       * @access public
       * @public
       * @instance
       * @type {Object | null}
       * @default null
       * @ojwebelementstatus {type: "deprecated", since: "14.0.0",
       *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
       * @ojsignature {target: "Type", value: "DataProvider<V, D>", jsdocOverride: true}
       * @ojmincapabilities {filter: {textFilter: true}}
       * @memberof oj.ojSelectBase
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">data</code> specified:</caption>
       * &lt;oj-select-single data="[[dataProvider]]">&lt;/oj-select-single>
       *
       * @example <caption>Initialize the Select with a data provider and data mapping:</caption>
       * &lt;oj-select-single data="[[dataProvider]]">&lt;/oj-select-single>
       */
      /**
       * The data for the Select.
       * <p>Note that the <code class="prettyprint">item-text</code> attribute and the
       * <code class="prettyprint">itemTemplate</code> and
       * <code class="prettyprint">collectionTemplate</code> slots allow for customizing the
       * rendering of each data item.  If those are not specified, then the component will
       * attempt to render as text the 'label' field in the data item by default.</p>
       * <ul>
       * <li>See also <a href="#perf-section">Improve page load performance</a></li>
       * </ul>
       *
       * @expose
       * @memberof oj.ojSelectBase
       * @instance
       * @ojfragment selectCommonData
       */
      data: null,

      /**
       * {@ojinclude "name":"selectCommonRequired"}
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">required</code> attribute:</caption>
       * &lt;oj-select-single required="[[isRequired]]">&lt;/oj-select-single>
       *
       * @example <caption>Get or set the <code class="prettyprint">required</code> property after initialization:</caption>
       * // getter
       * var requiredValue = mySelect.required;
       *
       * // setter
       * mySelect.required = true;
       *
       * @name required
       * @ojshortdesc Specifies whether the component is required or optional. See the Help documentation for more information.
       * @expose
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       * @type {boolean}
       * @default false
       * @see #translations
       */
      /**
       * <p>
       * This property set to <code class="prettyprint">false</code> implies that a value is not required to be provided by the user.
       * This is the default.
       * This property set to <code class="prettyprint">true</code> implies that a value is required to be provided by the user.
       * </p>
       * <p>
       * In the Redwood theme, by default, a Required text is rendered inline when the field is empty.
       * If user-assistance-density is 'compact', it will show on the label as an icon.
       * In the Alta theme the input's label will render a required icon.
       * </p>
       * <p>The Required error text is based on Redwood UX designs, and it is not recommended that
       * it be changed.
       * To override the required error message,
       * use the <code class="prettyprint">translations.required</code> attribute.
       * The component's label text is passed in as a token {label} and can be used in the message detail.
       * </p>
       * <p>When required is set to true, an implicit
       * required validator is created, i.e.,
       * <code class="prettyprint">new RequiredValidator()</code>. The required validator is the only
       * validator to run during initial render, and its error is not shown to the user at this time;
       * this is called deferred validation. The required validator also runs during normal validation;
       * this is when the errors are shown to the user.
       * See the <a href="#validation-section">Validation and Messaging</a> section for details.
       * </p>
       * <p>
       * When the <code class="prettyprint">required</code> property changes due to programmatic intervention,
       * the component may clear component messages and run validation, based on the current state it's in. </br>
       *
       * <h4>Running Validation when required property changes</h4>
       * <ul>
       * <li>if component is valid when required is set to true, then it runs deferred validation on
       * the value property. If the field is empty, the valid state is invalidHidden. No errors are
       * shown to the user.
       * </li>
       * <li>if component is invalid and has deferred messages when required is set to false, then
       * component messages are cleared (messages-custom messages are not cleared)
       * but no deferred validation is run because required is false.
       * </li>
       * <li>if component is invalid and currently showing invalid messages when required is set, then
       * component messages are cleared and normal validation is run using the current display value.
       * <ul>
       *   <li>if there are validation errors, then <code class="prettyprint">value</code>
       *   property is not updated and the error is shown.
       *   </li>
       *   <li>if no errors result from the validation, the <code class="prettyprint">value</code>
       *   property is updated; page author can listen to the <code class="prettyprint">valueChanged</code>
       *   event on the component to clear custom errors.</li>
       * </ul>
       * </li>
       * </ul>
       *
       * <h4>Clearing Messages when required property changes</h4>
       * <ul>
       * <li>Only messages created by the component, like validation messages, are cleared when the required property changes.</li>
       * <li><code class="prettyprint">messagesCustom</code> property is not cleared.</li>
       * </ul>
       *
       * </p>
       * @expose
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       * @see #translations
       * @ojfragment selectCommonRequired
       */
      required: false,

      /**
       * The type of virtual keyboard to display for entering a value on mobile browsers.
       * This attribute has no effect on desktop browsers.
       *
       * @example <caption>Initialize the component with the <code class="prettyprint">virtual-keyboard</code> attribute:</caption>
       * &lt;oj-select-single virtual-keyboard="number">&lt;/oj-select-single>
       *
       * @example <caption>Get or set the <code class="prettyprint">virtualKeyboard</code> property after initialization:</caption>
       * // Getter
       * var virtualKeyboard = myComp.virtualKeyboard;
       *
       * // Setter
       * myComp.virtualKeyboard = "number";
       *
       * @name virtualKeyboard
       * @expose
       * @instance
       * @memberof oj.ojSelectBase
       * @ojshortdesc The type of virtual keyboard to display for entering a value on mobile browsers. See the Help documentation for more information.
       * @type {string}
       * @ojvalue {string} "email" Use a virtual keyboard for entering email addresses.
       * @ojvalue {string} "number" Use a virtual keyboard for entering numbers.
       *                            <p>Note that on Android and Windows Mobile, the "number" keyboard
       *                            does not contain the minus sign.  This value should not be used
       *                            on fields that accept negative values.</p>
       * @ojvalue {string} "search" Use a virtual keyboard for entering search terms.
       * @ojvalue {string} "tel" Use a virtual keyboard for entering telephone numbers.
       * @ojvalue {string} "text" Use a virtual keyboard for entering text.
       * @ojvalue {string} "url" Use a virtual keyboard for URL entry.
       * @default "search"
       */
      virtualKeyboard: 'search',

      /**
       * Dictates element's readonly state.
       * <p>
       * The default value for readonly is false. However, if the form component is a descendent of
       * <code class="prettyprint">oj-form-layout</code>, the default value for readonly could come from the
       * <code class="prettyprint">oj-form-layout</code> component's readonly attribute.
       * The <code class="prettyprint">oj-form-layout</code> uses the
       * <a href="MetadataTypes.html#PropertyBinding">MetadataTypes.PropertyBinding</a>
       * <code class="prettyprint">provide</code> property to provide its
       * <code class="prettyprint">readonly</code>
       * attribute value to be consumed by descendent components.
       * The form components are configured to consume the readonly property if an ancestor provides it and
       * it is not explicitly set.
       * For example, if the oj-form-layout's readonly attribute is set to true, and a descendent form component does
       * not have its readonly attribute set, the form component's readonly will be true.
       * </p>
       * @example <caption>Initialize the select with the <code class="prettyprint">readonly</code> attribute:</caption>
       * &lt;oj-some-element readonly>&lt;/oj-some-element>
       *
       * @example <caption>Get or set the <code class="prettyprint">readonly</code> property after initialization:</caption>
       * // getter
       * var ro = myComp.readonly;
       *
       * // setter
       * myComp.readonly = false;
       *
       * @alias readonly
       * @expose
       * @ojshortdesc Specifies whether a value is readonly
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       * @type {boolean}
       * @default false
       */
      readOnly: false,

      /**
       * Specifies the text string to render for a data item.
       * This attribute can be set to either:
       * <ul>
       * <li>a string that specifies the name of a top level data field to render as text, or</li>
       * <li>a callback function that takes a context object and returns the text string to
       * display</li>
       * </ul>
       *
       * <p>By default, the component will attempt to render a 'label' data field as text.</p>
       *
       * <p>This text will be rendered for the selected value of the component.  It will also be
       * rendered for each data item in the dropdown if no itemTemplate or collectionTemplate is
       * provided.  When rendered for the dropdown items, default matching search term highlighting
       * will still be applied.</p>
       *
       * @name itemText
       * @ojshortdesc Specifies the text string to render for a data item.
       * @expose
       * @instance
       * @type {string|function(Object):string}
       * @ojsignature {
       *   target: "Type",
       *   value: "keyof D | ((itemContext: ojcommontypes.ItemContext<V, D>) => string)",
       *   jsdocOverride: true
       * }
       * @default 'label'
       *
       * @memberof oj.ojSelectBase
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">item-text</code> attribute specified:</caption>
       * &lt;oj-select-single item-text="FullName">&lt;/oj-select-single>
       *
       * @example <caption>Get or set the <code class="prettyprint">itemText</code> property after initialization:</caption>
       * // getter
       * var itemText = mySelect.itemText;
       *
       * // setter
       * mySelect.itemText = 'FullName';
       */
      itemText: 'label',

      /**
       * {@ojinclude "name":"selectCommonLabelledBy"}
       * @name labelledBy
       * @expose
       * @ojshortdesc The oj-label sets the labelledBy property
       * programmatically on the form component.
       * @type {string|null}
       * @default null
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       */
      /**
       * <p>
       * The oj-label sets the labelledBy property programmatically on the form component
       * to make it easy for the form component to find its oj-label component (a
       * document.getElementById call.)
       * </p>
       * <p>
       * The application developer should use the 'for'/'id api
       * to link the oj-label with the form component;
       * the 'for' on the oj-label to point to the 'id' on the input form component.
       * This is the most performant way for the oj-label to find its form component.
       * </p>
       *
       * // setter
       * myComp.labelledBy = "labelId";
       *
       * @expose
       * @ojshortdesc The oj-label sets the labelledBy property
       * programmatically on the form component.
       * @type {string|null}
       * @default null
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       * @ojfragment selectCommonLabelledBy
       */
      labelledBy: null,

      /**
       * The list of text filter matching behaviors to use when fetching data filtered by a user's
       * typed search text, in order of descending priority with the preferred behavior first.
       * If the preferred behavior is not supported by the DataProvider, then the component will
       * check the next behavior, and so on, until it finds one that is supported.
       * If none of the specified behaviors are supported or if this property is not specified,
       * then the behavior will effectively be "unknown".
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">match-by</code> attribute specified:</caption>
       * &lt;oj-select-single match-by="[[matchByValue]]">&lt;/oj-select-single>
       *
       * @example <caption>Get or set the <code class="prettyprint">matchBy</code> property after initialization:</caption>
       * // getter
       * var matchByValue = mySelect.matchBy;
       *
       * // setter
       * mySelect.matchBy = ["phrase", "fuzzy", "contains", "startsWith", "unknown"];
       *
       * @name matchBy
       * @ojshortdesc The ordered list of text filter matching behaviors to use when filtering data.
       * @expose
       * @access public
       * @instance
       * @memberof oj.ojSelectBase
       * @type {Array.<string>|null}
       * @ojsignature {target: "Type", value: "Array<TextFilter<D>['matchBy']>|null", jsdocOverride: true}
       * @default null
       * @since 16.0.2
       */
      matchBy: null
    },

    /**
     * Returns a jQuery object containing the element visually representing the Select.
     *
     * <p>This method does not accept any arguments.
     *
     * @memberof! oj.ojSelectBase
     * @instance
     * @public
     * @ignore
     * @return {jQuery} the Select
     */
    widget: function () {
      return $(this.OuterWrapper);
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     * @override
     */
    _ComponentCreate: function () {
      this._super();

      this._fullScreenPopup = Config.getDeviceRenderMode() === 'phone';
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     * @override
     */
    _AfterCreate: function () {
      this._super();

      this._initInputIdLabelForConnection(
        this._GetContentElement()[0],
        this.OuterWrapper.id,
        this.options.labelledBy
      );
    },

    /**
     * Returns if the element is a text field element or not.
     * @memberof oj.ojSelectBase
     * @instance
     * @protected
     * @return {boolean}
     */
    _IsTextFieldComponent: function () {
      return true;
    },

    /**
     * Returns the components wrapper under which label needs to be inserted in the inside strategy
     * For input number we need the label to go under the span so that it occupies the same width
     * as the input text giving way to the buttons.
     * @memberof oj.ojSelectBase
     * @instance
     * @protected
     * @override
     * @ignore
     * @return {Element|undefined}
     */
    _GetContentWrapper: function () {
      // return this._getRootElement().querySelector('.oj-text-field-middle');
      return this._lovMainField.getElement().querySelector('.oj-text-field-middle');
    },

    /**
     * If the dropdown is open and the afterToggle handler is called with focusout,
     * turn on the 'oj-focus' selector. This is needed for floating labels.  If focus
     * moves to the droplist, the label should be in the up position versus floating
     * down over the input on selection of a dropdown item.
     * @protected
     * @instance
     * @memberof! oj.ojSelectBase
     */
    _HandleAfterFocusToggle: function (element, eventType) {
      if (eventType === 'focusout') {
        if (this._abstractLovBase.isDropdownOpen()) {
          element.classList.add('oj-focus');
        }
      }
    },

    /**
     * Whether the component is required.
     *
     * @return {boolean} true if required; false
     *
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     * @override
     */
    _IsRequired: function () {
      return this.options.required;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _labelledByUpdatedForInputComp: ojeditablevalue.EditableValueUtils._labelledByUpdatedForInputComp,

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _initInputIdLabelForConnection: ojeditablevalue.EditableValueUtils._initInputIdLabelForConnection,
    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _linkLabelForInputComp: ojeditablevalue.EditableValueUtils._linkLabelForInputComp,

    /**
     * Performs post processing after required option is set by taking the following steps.
     *
     * - if component is invalid and has messgesShown -> required: false/true -> clear component errors;
     * run full validation with UI value (we don't know if the UI error is from a required validator
     * or something else);<br/>
     * &nbsp;&nbsp;- if there are validation errors, then value not pushed to model; messagesShown is
     * updated<br/>
     * &nbsp;&nbsp;- if no errors result from the validation, push value to model; author needs to
     * listen to optionChange(value) to clear custom errors.<br/>
     *
     * - if component is invalid and has messagesHidden -> required: false -> clear component
     * errors; no deferred validation is run.<br/>
     * - if component has no error -> required: true -> run deferred validation (we don't want to flag
     * errors unnecessarily)<br/>
     * - messagesCustom is never cleared<br/>
     *
     * @param {string} option
     *
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _AfterSetOptionRequired: ojeditablevalue.EditableValueUtils._AfterSetOptionRequired,

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _refreshRequired: ojeditablevalue.EditableValueUtils._refreshRequired,

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _setTabIndex: ojeditablevalue.EditableValueUtils._setTabIndex,

    /**
     * Called to find out if aria-required is unsupported.
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _AriaRequiredUnsupported: function () {
      return false;
    },

    /**
     * Override to do the delay connect/disconnect
     * @memberof oj.ojSelectBase
     * @override
     * @protected
     */
    _VerifyConnectedForSetup: function () {
      //  - temp moving element from one parent to another should not cause fetch
      return true;
    },

    /**
     * Set the type of the input element based on virtualKeyboard option.
     * @param {Array.<string>} allowedTypes an array of allowed types
     * @memberof oj.ojSelectBase
     * @override
     * @protected
     */
    _SetInputType: ojeditablevalue.EditableValueUtils._SetInputType,

    /**
     * Returns the name of the component to be used in a style class.
     *
     * @return {string}
     * @memberof! oj.ojSelectBase
     * @protected
     */
    _GetStyleClassComponentName: function () {
      oj.Assert.failedInAbstractFunction();
      return '';
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _GetTemplateSlot: function (name) {
      var slots = ojcustomelementUtils.CustomElementUtils.getSlotMap(this.OuterWrapper);
      var namedSlot = slots[name];
      return namedSlot && namedSlot[0] && namedSlot[0].tagName === 'TEMPLATE' ? namedSlot[0] : null;
    },

    /**
     * Sets up resources for select
     *
     * @param {HTMLElement=} cachedMainFieldInputElem An optional HTML input element to be
     *                                                used for main field element
     *
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _SetupSelectResources: function (cachedMainFieldInputElem) {
      this._loadingIndicatorCount = 0;
      var OuterWrapper = this.OuterWrapper;
      // JET-32835 - SINGLESELECT'S INLINE MESSAGES IS SOMETIMES BELOW AND SOMETIMES ABOVE COMPONENT.
      // save existing child nodes so we can append them at the end of our internal DOM
      var childNodes = OuterWrapper.childNodes;
      var existingChildren = [];
      for (var i = 0; i < childNodes.length; i++) {
        existingChildren.push(childNodes[i]);
      }

      var options = this.options;

      // JET-60725 - Add option to specify the matchBy behavior of the text filter
      // Make a copy of the array to use internally so that the application can't mutate it;
      // they have to set a new array if they want to change it.
      this._matchBy =
        options.matchBy && options.matchBy.length > 0 ? [...options.matchBy] : undefined;

      this._wrapDataProviderIfNeeded(options.data);
      this._addDataProviderEventListeners();

      // need to initially apply virtualKeyboard option
      this._SetInputType(this._ALLOWED_INPUT_TYPES);

      // need to use 'self' for getTranslatedStringFunc because it's called using func.apply(), which
      // would override the 'this' binding
      var self = this;
      var getTranslatedStringFunc = function () {
        return self.getTranslatedString.apply(self, arguments);
      };
      var addBusyStateFunc = function (description) {
        return this._AddBusyState(description);
      }.bind(this);

      var elemId = OuterWrapper.getAttribute('id');
      if (!elemId) {
        elemId = 'oj-' + this._GetStyleClassComponentName() + '-' + LovUtils.nextUid();
        OuterWrapper.setAttribute('id', elemId);
      }
      //  - ojselect id attribute on oj-select-choice div is not meaningful
      var idSuffix = elemId;
      this._idSuffix = elemId;

      var lovEnabled = !(options.disabled || false);
      this._lovEnabled = lovEnabled;
      var readonly = options.readOnly || false;
      var element = this.element;
      element.prop('disabled', !(lovEnabled && !readonly));

      var showIndicatorDelay = this._cssOptionDefaults.showIndicatorDelay;
      showIndicatorDelay = parseInt(showIndicatorDelay, 10);
      showIndicatorDelay = isNaN(showIndicatorDelay) ? 250 : showIndicatorDelay;
      this._showIndicatorDelay = showIndicatorDelay;

      var inputType = element.attr('type');
      var className = 'oj-searchselect';
      this._className = className;
      this._dropdownElemId = 'lovDropdown_' + idSuffix;

      this._initContainer(className, idSuffix, readonly);

      // Bug JET-35402 - help.instruction does not display after oj-select-single went from disabled
      // to enabled
      // Pass in the existing main field input element if it already exists.
      var outerWrapperAriaControls = OuterWrapper.getAttribute('aria-controls');
      var mainFieldAriaControls = outerWrapperAriaControls
        ? this._dropdownElemId + ' ' + outerWrapperAriaControls
        : this._dropdownElemId;
      var lovMainField = new LovMainField({
        className: className,
        ariaLabel: OuterWrapper.getAttribute('aria-label'),
        ariaControls: mainFieldAriaControls,
        componentId: elemId,
        inputType: inputType,
        enabled: lovEnabled,
        readOnly: readonly,
        placeholder: options.placeholder,
        addBusyStateFunc: addBusyStateFunc,
        forceReadOnly: this._fullScreenPopup,
        endContent: this._createMainFieldEndContent(lovEnabled, readonly),
        cachedMainFieldInputElement: cachedMainFieldInputElem,
        createOrUpdateReadonlyDivFunc: this._createOrUpdateReadonlyDiv.bind(this)
      });
      this._lovMainField = lovMainField;
      this._initLovMainField(lovMainField);

      var mainFieldElem = lovMainField.getElement();
      OuterWrapper.appendChild(mainFieldElem);

      var filterInputText = this._createFilterInputText(className, idSuffix);
      if (!this._fullScreenPopup) {
        filterInputText.style.visibility = 'hidden';
        OuterWrapper.appendChild(filterInputText);
      }
      this._filterInputText = filterInputText;

      var lovDropdown = this._CreateLovDropdown();
      // defer initialization of dropdown until we open it
      this._initLovDropdownFunc = function (afterInitFunc) {
        var afterDropdownInitFunc = function (resultsElem) {
          if (this._fullScreenPopup) {
            filterInputText.setAttribute('aria-controls', resultsElem.id);

            var dropdownFilterBusyContext = Context.getContext(filterInputText).getBusyContext();
            dropdownFilterBusyContext.whenReady().then(function () {
              if (afterInitFunc) {
                afterInitFunc();
              }
            });
          } else if (afterInitFunc) {
            afterInitFunc();
          }
        }.bind(this);
        this._initLovDropdown(
          idSuffix,
          inputType,
          elemId,
          getTranslatedStringFunc,
          addBusyStateFunc,
          afterDropdownInitFunc
        );

        var dropdownElem = lovDropdown.getElement();
        OuterWrapper.appendChild(dropdownElem);
        dropdownElem.addEventListener('lovDropdownEvent', this._handleLovDropdownEvent.bind(this));
        if (!this._fullScreenPopup) {
          dropdownElem.addEventListener(
            'mousedown',
            function () {
              this._mousedownOnDropdown = true;
            }.bind(this)
          );
        }
      }.bind(this);
      this._lovDropdown = lovDropdown;
      // this._initLovDropdownOld(lovDropdown, className);

      var abstractLovBase = new AbstractLovBase({
        className: className,
        dataProvider: this._wrappedDataProvider,
        containerElem: OuterWrapper,
        fullScreenPopup: this._fullScreenPopup,
        idSuffix: idSuffix,
        lovMainField: lovMainField,
        filterInputText: filterInputText,
        lovDropdown: lovDropdown,
        liveRegion: this._liveRegion,
        enabled: lovEnabled,
        readOnly: readonly,
        value: options.value,
        getTranslatedStringFunc: getTranslatedStringFunc,
        addBusyStateFunc: addBusyStateFunc,
        showMainFieldFunc: this._showMainField.bind(this),
        setFilterFieldTextFunc: this._SetFilterFieldText.bind(this),
        setUiLoadingStateFunc: this._setUiLoadingState.bind(this),
        isValueForPlaceholderFunc: this._IsValueForPlaceholder.bind(this),
        isShowValueInFilterFieldFunc: this._IsShowValueInFilterField.bind(this),
        getFilterInputElemFunc: this._getFilterInputElem.bind(this),
        matchBy: this._matchBy
      });
      this._abstractLovBase = abstractLovBase;

      // swap main field container for the element
      element.hide().attr('aria-hidden', true);

      // JET-46247 - Acc: described-by resets after changing the data provider
      // if we're refreshing, restore aria-describedby on the input
      if (cachedMainFieldInputElem) {
        // set describedby on the element as aria-describedby
        var describedBy = this.options.describedBy;
        if (describedBy) {
          this._describedByUpdated(null, describedBy);
        }
      }

      this._refreshRequired(options.required);

      // JET-46247 - Acc: described-by resets after changing the data provider
      // reconnect the input and label
      this._initInputIdLabelForConnection(
        this._GetContentElement()[0],
        OuterWrapper.id,
        this.options.labelledBy
      );

      this._updateLabel();

      // JET-45967 - tabindex does not propagate for select-single
      // transfer tabindex from hidden initnode input to appropriate inner DOM elements
      this._setTabIndex(element[0], lovMainField.getInputElem());
      if (readonly) {
        var readonlyElem = this._getReadonlyDiv();
        if (readonlyElem) {
          this._setTabIndex(element[0], readonlyElem);
        }
      }

      // JET-32835 - SINGLESELECT'S INLINE MESSAGES IS SOMETIMES BELOW AND SOMETIMES ABOVE COMPONENT.
      // append pre-existing child nodes at the end of our internal DOM
      for (var j = 0; j < existingChildren.length; j++) {
        OuterWrapper.appendChild(existingChildren[j]);
      }

      this._SetupInitialValue();
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _AddBusyState: function (description, elem) {
      var busyElem = elem || this.OuterWrapper;
      var busyStateResolve = LovUtils.addBusyState(busyElem, description);

      // JET-42413: while we're processing a value change, keep track of newly added busy states so
      // that we can wait until they resolve before processing any new changes
      if (this._makingInternalValueChange) {
        var promiseResolve = this._chainInternalValueChangePromise();
        var newResolveFunc = function () {
          busyStateResolve();
          promiseResolve();
        };
        return newResolveFunc;
      }

      return busyStateResolve;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _StartMakingInternalValueChange: function () {
      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change

      // get the current stored promise, if there is one
      var storedPromise = this._makingInternalValueChangePromise;

      // chain a new promise
      var promiseResolve = this._chainInternalValueChangePromise();

      // toggle the flag
      this._makingInternalValueChange = true;

      // if there wasn't already a stored promise, queue the very first deferred operation,
      // which will be to clear the flags
      if (!storedPromise) {
        this._queueValueChangeDeferredCallback(
          function () {
            this._makingInternalValueChange = false;
            this._makingInternalValueChangePromise = null;
            this._deferredMakingInternalValueChangeQueueCallback = null;
          }.bind(this)
        );
      }

      return promiseResolve;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _chainInternalValueChangePromise: function () {
      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change

      var promiseResolve = null;
      var promise = new Promise(function (resolve) {
        promiseResolve = resolve;
      });
      var busyStateResolve = LovUtils.addBusyState(this.OuterWrapper, 'Processing value change');
      // resolve busy state regardless of whether promise was resolved or rejected
      promise.then(busyStateResolve, busyStateResolve);

      var storedPromise = promise;
      if (this._makingInternalValueChangePromise) {
        // if we've already saved a promise, then wait until the saved one and the new one are
        // both resolved
        storedPromise = Promise.all([this._makingInternalValueChangePromise, promise]);
      }

      // check whether we need to execute the queue when the promise resolves
      var runQueueFunc = function () {
        // only execute the queued callbacks when this promise is the same as the latest one
        // that was saved
        if (storedPromise === this._makingInternalValueChangePromise) {
          this._deferredMakingInternalValueChangeQueueCallback();
        }
      }.bind(this);
      // run queue to resolve busy states regardless of whether promise was resolved or rejected
      storedPromise.then(runQueueFunc, runQueueFunc);

      // save the promise
      this._makingInternalValueChangePromise = storedPromise;

      return promiseResolve;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _queueValueChangeDeferredCallback: function (callback) {
      // JET-42413: while we're processing a value change, queue new changes to be processed later
      var busyStateResolve = LovUtils.addBusyState(
        this.OuterWrapper,
        'queueing deferred callback while making value change'
      );
      var currentQueueCallback = this._deferredMakingInternalValueChangeQueueCallback;
      var queuedCallback = function () {
        // wrap in try..finally so that busy state always gets resolved
        try {
          if (currentQueueCallback) {
            currentQueueCallback();
          }
          callback();
        } finally {
          busyStateResolve();
        }
      };
      this._deferredMakingInternalValueChangeQueueCallback = queuedCallback;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _SetupInitialValue: function () {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * Releases the resources created for select
     *
     * @param {boolean} shouldRetainMainFieldElem A flag to indicate if the main field
     *                                            element should be reatined
     *
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _ReleaseSelectResources: function (shouldRetainMainFieldElem) {
      // call to stop loading at least once to clear out an existing timer
      for (var i = this._loadingIndicatorCount; i >= 0; i--) {
        this._setUiLoadingState('stop');
      }
      this._loadingIndicatorCount = 0;
      this._savedLoadingIndicator = false;

      this._mousedownOnDropdown = false;
      this._deferredSetDisplayValue = null;

      // JET-44965 - SELECT SINGLE LOSING FOCUS LOST
      // only clear the focus timer if the component has been disconnected, because we still
      // want it to work if the component is just being refreshed
      if (this._bReleasedResources) {
        this._clearMainFieldFocusHandlerTimer();
      }

      $(this._filterInputText).remove();
      // If we will be reinserting the lov main field's input element
      // detach the element from the lov main field container to
      // retain all the data it holds before destroying the container
      if (shouldRetainMainFieldElem) {
        $(this._lovMainField.getInputElem()).detach();
        // Clean up the input element from all the previously set attributes
        this._cleanUpMainFieldInputElement();
        // Remove the event listeners assigned by us, as they will be added again when
        // the element is reattached.
        $(this._lovMainField.getInputElem()).off(this._lovMainFieldInputEventListeners);
      }
      $(this._lovMainField.getElement()).remove();
      $(this._liveRegion).remove();

      this._abstractLovBase.destroy();
      // only need to destroy dropdown if it was initialized
      if (this._lovDropdown.getElement()) {
        $(this._lovDropdown.getElement()).remove();
        this._lovDropdown.destroy();
      }

      var OuterWrapper = this.OuterWrapper;
      // need to remove classes one by one because IE11 doesn't support passing multiple
      // arguments to a single remove() call
      var owClassList = OuterWrapper.classList;
      owClassList.remove(this._className);
      owClassList.remove('oj-form-control');
      owClassList.remove('oj-component');
      owClassList.remove('oj-read-only');
      owClassList.remove('oj-enabled');
      owClassList.remove('oj-disabled');
      $(OuterWrapper)
        .off('change', '.' + this._className + '-input', LovUtils.stopEventPropagation)
        .off(this._containerEventListeners);
      this._containerEventListeners = null;

      this.element.removeAttr('aria-hidden').show();

      this._removeDataProviderEventListeners();
      this._wrappedDataProvider = null;

      this._liveRegion = null;
      this._abstractLovBase = null;
      this._lovMainField = null;
      this._filterInputText = null;
      this._lovDropdown = null;
    },

    /**
     * Cleans up the main field input element for reuse. This removes all the attributes
     * set by us on the main field input element.
     *
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _cleanUpMainFieldInputElement: function () {
      var mainFieldInputElem = this._lovMainField.getInputElem();
      // TODO: IE 11 does not support Element.attributes which is what we will
      // be relying on for other browsers. Once, we stop supporting IE 11
      // clean up this part
      var agentInfo = oj.AgentUtils.getAgentInfo();
      if (agentInfo.browser === oj.AgentUtils.BROWSER.IE) {
        // Clean up attributes set during the initialization of lovMainField
        // See LovMainField._createInnerDom for the attributes set
        // It is enough to remove the attributes that are conditionally set
        mainFieldInputElem.removeAttribute('readonly');
        mainFieldInputElem.removeAttribute('role');
        mainFieldInputElem.removeAttribute('type');

        // Remove all the aria attributes set by us
        // See ojSelect._updateLabel method for the attributes set
        mainFieldInputElem.removeAttribute('aria-controls');
        mainFieldInputElem.removeAttribute('aria-expanded');
        mainFieldInputElem.removeAttribute('aria-label');
        mainFieldInputElem.removeAttribute('aria-labelledby');
      } else if (mainFieldInputElem.hasAttributes()) {
        // Loop through all the attributes and remove them
        var attrs = mainFieldInputElem.attributes;
        var attrName;
        for (var i = attrs.length - 1; i >= 0; i--) {
          attrName = attrs[i].name;
          LovUtils.removeAttribute(mainFieldInputElem, attrName);
        }
      }

      // value will not be in the attributes collection, so reset it separately
      mainFieldInputElem.value = '';
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _updateLabel: function () {
      var options = this.options;
      var lovMainField = this._lovMainField;
      var lovDropdown = this._lovDropdown;
      var filterInputText = this._filterInputText;

      var labelId;
      if (options.labelledBy) {
        labelId = options.labelledBy;
      }

      // element.attr('aria-labelledby', labelId);

      //  - oghag missing label for ojselect and ojcombobox
      var labelText;
      var alabel = this.OuterWrapper.getAttribute('aria-label');
      if (alabel) {
        labelText = alabel;
      }

      lovDropdown.updateLabel(labelId, labelText);
      lovMainField.updateLabel(labelId, labelText);

      if (labelId) {
        filterInputText.setAttribute('labelled-by', labelId);
        // The attribute value only can be removed by setting it to an empty string
        filterInputText.setAttribute('aria-label', '');
      } else if (labelText) {
        filterInputText.setAttribute('aria-label', labelText);
        // The attribute value only can be removed by setting it to an empty string
        filterInputText.setAttribute('labelled-by', '');
      }

      // JET-39385 - SELECT SINGLE HAS NO OPTION TO SET TITLE IN MOBILE SEARCH
      // set the component's label-hint as the mobile search field label
      // (don't use the text of an external label because: 1) multiple controls could be labelled
      // by it, and 2) in non-ko environments, the label may not have been been rendered by now)
      if (this._fullScreenPopup) {
        // only affect label-hint attribute if on mobile;  otherwise there are several unit test
        // failures because we're setting label-hint to ''
        if (options.labelHint) {
          filterInputText.setAttribute('label-hint', options.labelHint);
          filterInputText.setAttribute('label-edge', 'inside');
          filterInputText.setAttribute('labelled-by', '');
        } else {
          filterInputText.setAttribute('label-hint', '');
        }
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _UpdateItemText: function () {
      // JET-45922 - timing issue with select-single: lov drop-down doesn't have element
      // do a granular update if item-text changes instead of a general refresh
      this._lovDropdown.updateItemTextRendererFunc(this._ItemTextRenderer.bind(this));
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _initContainer: function (className, idSuffix, readonly) {
      var elem = this.OuterWrapper;
      var $elem = $(elem);

      // need to add classes one by one because IE11 doesn't support passing multiple
      // arguments to a single add() call
      var elemClassList = elem.classList;
      elemClassList.add(className);
      elemClassList.add('oj-form-control');
      elemClassList.add('oj-component');
      if (!readonly) {
        elemClassList.add(this._lovEnabled ? 'oj-enabled' : 'oj-disabled');
      } else {
        elemClassList.add('oj-read-only');
      }
      if (this._fullScreenPopup) {
        // elemClassList.add('oj-searchselect-fullscreen');
        elemClassList.add('oj-searchselect-mobile');
      } else {
        // elemClassList.remove('oj-searchselect-fullscreen');
        elemClassList.remove('oj-searchselect-mobile');
      }

      this._toggleNoValueStyleClass();

      var liveRegion = document.createElement('div');
      liveRegion.setAttribute('id', 'oj-listbox-live-' + idSuffix);
      liveRegion.setAttribute('class', 'oj-helper-hidden-accessible oj-listbox-liveregion');
      liveRegion.setAttribute('aria-live', 'polite');
      elem.appendChild(liveRegion);

      // do not propagate change event from the search field out of the component
      $elem.on('change', '.' + className + '-input', LovUtils.stopEventPropagation);

      this._containerEventListeners = {
        // JET-48083 - clicking help-hints.source link does nothing
        // Do not kill events originating from user-assistance-container
        click: LovUtils.killEventWithAncestorExceptions.bind(null, [
          '.oj-user-assistance-inline-container'
        ]),
        // keyup: function (event) {
        //   if (event.keyCode === 10 || event.keyCode === 13) {
        //     $elem.removeClass('oj-focus');
        //   }
        // },
        keydown: this._handleContainerKeyDown.bind(this),
        mouseup: function () {
          $elem.removeClass('oj-active');
        }
      };
      $elem.on(this._containerEventListeners);

      this._liveRegion = liveRegion;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _toggleNoValueStyleClass: function () {
      var classList = this.OuterWrapper.classList;
      if (this._IsValueForPlaceholder(this.options.value)) {
        classList.add('oj-searchselect-no-value');
      } else {
        classList.remove('oj-searchselect-no-value');
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _SetFilterFieldText: function (text) {
      this._ignoreFilterFieldRawValueChanged = true;

      this._filterInputText.value = text;
      // if the filter field is in the mobile dropdown and the dropdown is not currently in
      // the DOM, remove any oj-label elems from the field before refreshing because the
      // refresh will not be able to find them to remove them and will simply add a new
      // oj-label elem, resulting in multiple duplicate label elems
      if (this._fullScreenPopup) {
        var dropdownElem = this._lovDropdown.getElement();
        if (!dropdownElem.parentElement) {
          var $filterInputElemLabels = $(this._filterInputText).find('oj-label');
          $filterInputElemLabels.remove();
        }
      }
      // if the value is same and focus stays in the field, the rawValue will not be updated.
      // So, the filter text has to be refreshed to reflect the changes.
      if (this._filterInputText) {
        // JET-42413: don't try to refresh the oj-input-text if it hasn't been upgraded yet due
        // to an LOV refresh
        var busyContext = Context.getContext(this._filterInputText).getBusyContext();
        if (busyContext.isReady()) {
          this._filterInputText.refresh();
        }
      }

      this._ignoreFilterFieldRawValueChanged = false;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _IsShowValueInFilterField: function () {
      return false;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _ShowFilterField: function (preserveState) {
      if (this._fullScreenPopup) {
        return;
      }

      var filterInputText = this._filterInputText;
      if (filterInputText.style.visibility === 'hidden') {
        var lovMainField = this._lovMainField;
        var mainInputElem = lovMainField.getInputElem();
        if (!preserveState) {
          var filterFieldText = this._IsShowValueInFilterField() ? mainInputElem.value : '';
          this._SetFilterFieldText(filterFieldText);

          LovUtils.copyAttribute(mainInputElem, 'aria-describedby', filterInputText, 'described-by');
        }

        // TODO: figure out how to do this through oj-input-text API
        var filterInputElem = this._getFilterInputElem();
        if (filterInputElem) {
          filterInputElem.setAttribute('role', 'combobox');

          LovUtils.copyAttribute(mainInputElem, 'aria-controls', filterInputElem, 'aria-controls');
          LovUtils.copyAttribute(mainInputElem, 'aria-expanded', filterInputElem, 'aria-expanded');

          if (!preserveState) {
            LovUtils.copyAttribute(mainInputElem, 'aria-required', filterInputElem, 'aria-required');
            LovUtils.copyAttribute(mainInputElem, 'aria-invalid', filterInputElem, 'aria-invalid');
          }
        }

        lovMainField.getInputElem().style.visibility = 'hidden';
        filterInputText.style.visibility = '';
        this.OuterWrapper.appendChild(filterInputText);
      }
      if (!preserveState) {
        //  - help.instruction text not always shown
        // in IE11, defer focusing the filter field so that the help.instruction text has time to show
        var agentInfo = oj.AgentUtils.getAgentInfo();
        if (agentInfo.browser === oj.AgentUtils.BROWSER.IE) {
          var resolveBusyContext = this._AddBusyState('Select transferring focus to filter field');
          setTimeout(function () {
            filterInputText.focus();
            resolveBusyContext();
          }, 0);
        } else {
          filterInputText.focus();
        }
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _showMainField: function () {
      if (this._fullScreenPopup) {
        return;
      }

      var filterInputText = this._filterInputText;
      if (filterInputText.style.visibility !== 'hidden') {
        var mainInputElem = this._lovMainField.getInputElem();

        // JET-34889 - WHEN OJ-SELECT-SINGLE GETS FOCUS, SELECT THE INPUT TEXT TO ALLOW
        // TYPING WITHOUT CLEARING FIRST
        // reset the selection range to put the cursor at the end of the text
        // (Without this, all or part of the old selection gets maintained.
        // One example is if you tab into the field the first time, all the text gets highlighted.
        // If you then click outside somewhere, and then click on the dropdown arrow to open the
        // dropdown, all the text is still highlighted instead of the cursor being at the end of the
        // field.
        // Another example is if you tab into the field the first time, then click outside, and then
        // click on the text to open the dropdown, all the text from the start to where you clicked
        // is highlighted instead of the cursor just being where you clicked.)
        // JET-40032 - SELECT SINGLE - TRAILING PART SHOWN ON LOW WIDTH INPUT FIELD - FIREFOX
        // We used to set (1000000, 1000000), but that resulted in the end of long text being
        // shown in Firefox instead of the beginning.
        mainInputElem.setSelectionRange(0, 0);

        mainInputElem.style.visibility = '';
        filterInputText.style.visibility = 'hidden';
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _IsFilterInputTextCleared: function () {
      var filterInputText = this._filterInputText;
      var searchText = filterInputText.rawValue;
      return searchText == null || searchText === '';
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _handleContainerKeyDown: function (event) {
      if (!this._lovEnabled || this.options.readOnly) {
        return;
      }

      // ignore control key and function key
      if (LovUtils.isControlOrFunctionKey(event)) {
        return;
      }

      // JET-44374 - qunit combobox ojselect tests fail with new jquery 3.6.0
      // e.which no longer gets populated when simulating events with keyCode specified, so
      // check both properties on the event
      var keyCode = event.which || event.keyCode;
      if (keyCode === LovUtils.KEYS.PAGE_UP || keyCode === LovUtils.KEYS.PAGE_DOWN) {
        // prevent the page from scrolling
        event.preventDefault();
        return;
      }

      var abstractLovBase = this._abstractLovBase;
      var lovDropdown = this._lovDropdown;
      var outerWrapper = this.OuterWrapper;

      switch (keyCode) {
        case LovUtils.KEYS.UP:
        case LovUtils.KEYS.DOWN:
          if (abstractLovBase.isDropdownOpen()) {
            // lovDropdown.transferHighlight((keyCode === LovUtils.KEYS.UP) ? -1 : 1);
            lovDropdown.focus().then(function () {
              // keep oj-focus on root so that inside label is still shifted up and field looks focused
              // while dropdown is open.
              // And since we are dealing with asynchronism here, make sure if the focus is still in the
              // dropdown.
              const dropdownElement = lovDropdown.getElement();
              if (dropdownElement && dropdownElement.contains(document.activeElement)) {
                outerWrapper.classList.add('oj-focus');
              }
            });

            // if tabbing into dropdown, continue showing filter field as it was before tabbing
            //  - ie11: filter field hidden when you arrow into dropdown
            // in IE11, defer showing filter field until after focus transfer into dropdown has
            // happened
            var agentInfo = oj.AgentUtils.getAgentInfo();
            if (agentInfo.browser === oj.AgentUtils.BROWSER.IE) {
              var resolveBusyContext = this._AddBusyState(
                'Select showing filter field while arrowing into dropdown'
              );
              // prettier-ignore
              setTimeout( // @HTMLUpdateOK
                function () {
                  this._ShowFilterField(true);
                  resolveBusyContext();
                }.bind(this),
                0
              );
            } else {
              this._ShowFilterField(true);
            }
          } else {
            this._openDropdown();
            // if opening dropdown just after selecting an item, when main field selection elem is
            // focused, then focus main input field so that filter field gets shown
            // if (!this._fullScreenPopup) {
            //   $(this._lovMainField.getInputElem()).focus();
            // }
          }
          //  - select and combobox stop keyboard event propegation
          event.preventDefault();
          break;

        case LovUtils.KEYS.ENTER:
          // lovDropdown.activateHighlightedElem();
          //  - select and combobox stop keyboard event propegation
          event.preventDefault();

          this._HandleContainerKeyDownEnter(event);
          break;

        case LovUtils.KEYS.TAB:
          this._HandleContainerKeyDownTab(event);
          break;

        case LovUtils.KEYS.ESC:
          if (abstractLovBase.isDropdownOpen()) {
            abstractLovBase.cancel();
            // prevent the page from scrolling
            event.preventDefault();
          }
          break;

        default:
          break;
      }
    },

    /**
     * Handle Enter key down on the container.
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _HandleContainerKeyDownEnter: function (event) {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * Handle Tab key down on the container.
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _HandleContainerKeyDownTab: function (event) {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _handleContainerMouseDown: function (event) {
      var abstractLovBase = this._abstractLovBase;
      this._mousedownOnDropdown = false;

      // prevent user from focusing on disabled select
      if (!this._lovEnabled) {
        event.preventDefault();
      }

      // if select box gets focus ring via keyboard event previously, clear it now
      // $(this._lovMainField.getSelectionElem()).removeClass('oj-focus-highlight');

      var OuterWrapper = this.OuterWrapper;
      var $OuterWrapper = $(OuterWrapper);

      // only open dropdown on left (main) button click
      var mainButton = event.button === 0;
      var skipPreventDefault = false;

      var mainInputElem = this._lovMainField.getInputElem();

      if (mainButton && !this.options.readOnly) {
        if (this._fullScreenPopup) {
          var clearValueElem = OuterWrapper.querySelector('.oj-searchselect-clear-value');
          if (clearValueElem && DomUtils.isAncestorOrSelf(clearValueElem, event.target)) {
            return;
          }
        }

        if (this._lovEnabled) {
          if (!abstractLovBase.isDropdownOpen()) {
            // JET-40032 - SELECT SINGLE - TRAILING PART SHOWN ON LOW WIDTH INPUT FIELD - FIREFOX
            // if clicking the dropdown icon, move the cursor to the end of the text (otherwise it
            // may remain at the beginning)
            var mainFieldElem = this._lovMainField.getElement();
            var mainDropdownIcon = mainFieldElem.querySelector('.oj-searchselect-arrow');
            var clickedMainIcon = DomUtils.isAncestorOrSelf(mainDropdownIcon, event.target);
            if (!this._fullScreenPopup && clickedMainIcon) {
              mainInputElem.setSelectionRange(1000000, 1000000);
            }
            this._openDropdown();
            // prevent the focus from moving back or to whatever happens to be under the mouse/touch
            // point when the dropdown opens
            if (this._fullScreenPopup) {
              event.preventDefault();
            }
          } else if (!this._fullScreenPopup && abstractLovBase.isDropdownOpen()) {
            // JET-38253 - OJ-SELECT-SINGLE POPUP DOES NOT GO AWAY AFTER CLICKING EXPAND WIDGET
            // if the dropdown is open on desktop, clicking on the dropdown arrow should close it
            var filterDropdownIcon = this._filterInputText.querySelector('.oj-searchselect-arrow');
            if (DomUtils.isAncestorOrSelf(filterDropdownIcon, event.target)) {
              this._CloseDropdown();
            }
          }
        }
      }

      $OuterWrapper.addClass('oj-active');

      if (mainButton) {
        if (!this._fullScreenPopup && this._lovEnabled) {
          var filterInputElem = this._getFilterInputElem();
          //  - help.instruction text not always shown
          // if the filter field is hidden, focus the main field instead of directly showing the
          // filter field so that help.instruction text will be shown
          // if the filter field is already shown, call _ShowFilterField directly anyway to do
          // whatever other processing it needs to do, because the main input elem is hidden and
          // can't receive focus
          if (this._filterInputText.style.visibility === 'hidden') {
            // don't call preventDefault() because it prevents the cursor from moving to where
            // the mouse was clicked
            // JET-40451 - oj-select-single inside oj-table: dropdown immediately closes when
            // clicking arrow
            // only skip calling preventDefault() if the event target is an input element, otherwise
            // we do want to prevent default so that the containing component, like oj-table, doesn't
            // grab focus and cause the dropdown to immediately close
            if (event.target === filterInputElem || event.target === mainInputElem) {
              skipPreventDefault = true;
            }
            mainInputElem.focus();
          } else if (!this.options.readOnly) {
            // don't call preventDefault() because it prevents the cursor from moving to where
            // the mouse was clicked when inside the filter input, but if the click was outside
            // the filter input (for example over the dropdown arrow), then we do want to call
            // preventDefault() so that the filter input doesn't lose focus
            if (event.target === filterInputElem) {
              skipPreventDefault = true;
            }
            this._ShowFilterField();
          }
        }

        //  - clicking on component does not always focus input
        // prevent focus from transferring back
        if (!skipPreventDefault) {
          // JET-31848 - MOVING THE CURSOR BY CLICKING ON THE INPUT FIELD TOGGLES THE DROPDOWN
          // don't call preventDefault(), otherwise clicking in the field doesn't move the cursor
          event.preventDefault();
        }
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _handleLovDropdownEvent: function (event) {
      var detail = event.detail;
      var abstractLovBase = this._abstractLovBase;
      if (!abstractLovBase) {
        return;
      }
      // var lovMainField = this._lovMainField;
      switch (detail.subtype) {
        case 'closeDropdown':
          this._mousedownOnDropdown = false;
          if (detail.trigger === 'escKeyDown') {
            this._filterInputText.focus();
          } else if (detail.trigger === 'clickAway') {
            // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
            // clear flag that the user has typed filter text so that we can override it when setting
            // the selected label
            this._userHasTypedFilterText = false;

            // explicitly show main field again in case focus is in the dropdown
            this._showMainField();
            this.OuterWrapper.classList.remove('oj-focus');
          }
          this._CloseDropdown();
          break;
        case 'tabOut':
          this._HandleLovDropdownEventTabOut(event);
          break;
        case 'sizeDropdown':
          abstractLovBase.sizeDropdown();
          break;
        case 'adjustDropdownPosition':
          //  - oj-select-single stays sticky when scrolled outside the drop down
          // need to position popup again before adjusting its position
          var position = abstractLovBase.getDropdownPosition();
          if (this._fullScreenPopup) {
            $(detail.popupElem).position(position);
          } else {
            // JET-34367 - remove code to update popup position on refresh
            // Position the proxy element instead of the real dropdown so that we don't have to
            // change the size of the dropdown before calculating the position, because changing
            // the size of the dropdown here may reset the results' scroll position and prevent the
            // user from scrolling down.
            var proxyElem = detail.positioningProxyElem;
            var proxyResultsElem = $(proxyElem).find('.oj-select-results')[0];
            var $popupElem = $(detail.popupElem);
            var $resultsElem = $popupElem.find('.oj-select-results');
            // size the proxy elem width the same as the dropdown width
            proxyElem.style.width = '' + $popupElem.outerWidth() + 'px';
            // size the proxy results elem height the same as the dropdown results max-height
            proxyResultsElem.style.height = $resultsElem.css('max-height');
            $(proxyElem).position(position);
          }
          break;
        case 'openPopup':
          var psOptions = detail.psOptions;
          psOptions[oj.PopupService.OPTION.LAUNCHER] = this.element;
          psOptions[oj.PopupService.OPTION.POSITION] = abstractLovBase.getDropdownPosition();
          oj.PopupService.getInstance().open(psOptions);
          break;
        case 'handleSelection':
          this._HandleLovDropdownEventSelection(event);
          break;
        case 'dropdownClosed':
          this._HandleLovDropdownClosed(event);
          break;
        default:
          break;
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _HandleLovDropdownClosed: function (event) {
      //  - LIST FILTERED ON SELECTED ITEM WHEN IT PROBABLY SHOULDN'T BE
      // clear the stored value when the dropdown closes
      this._searchTextOnKeyDown = undefined;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _HandleLovDropdownEventTabOut: function (event) {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _HandleLovDropdownEventSelection: function (event) {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _CloseDropdown: function () {
      this._mousedownOnDropdown = false;
      // only need to do anything if dropdown had been initialized
      var dropdownElem = this._lovDropdown.getElement();
      if (dropdownElem != null) {
        // JET-37797 - can't close dropdown while list is loading
        // explicitly blur the focused element in the dropdown before closing it
        var activeElem = document.activeElement;
        if (activeElem && DomUtils.isAncestor(dropdownElem, activeElem)) {
          activeElem.blur();
        }

        //  - edge, safari: kb focus transfer only works the first time
        // JET-35346 - Multiple select2 qunit tests fail on Mac using different browsers for master
        // branch
        // let the listView in the dropdown handle the blur event before closing the dropdown
        this._abstractLovBase.closeDropdown();
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _createMainFieldEndContent: function (enabled, readonly) {
      var span = document.createElement('span');
      span.setAttribute('class', 'oj-text-field-end');

      var dropdownIcon = this._createDropdownIcon(enabled, readonly);
      span.appendChild(dropdownIcon);

      if (this._fullScreenPopup) {
        var clearValueIcon = this._createClearValueIcon();
        span.appendChild(clearValueIcon);
      }

      return span;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _createDropdownIcon: function (enabled, readonly) {
      var className = this._className;

      var span = document.createElement('span');
      var styleClasses =
        className +
        '-arrow ' +
        className +
        '-open-icon ' +
        className +
        '-icon oj-component-icon oj-clickable-icon-nocontext';
      if (!readonly && !enabled) {
        styleClasses += ' oj-disabled';
      }
      span.setAttribute('class', styleClasses);
      span.setAttribute('aria-hidden', 'true');

      return span;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _createClearValueIcon: function () {
      var className = this._className;

      var a = document.createElement('a');
      var styleClasses =
        className +
        '-clear-value ' +
        className +
        '-clear-value-icon ' +
        className +
        '-icon oj-component-icon oj-clickable-icon-nocontext';
      a.setAttribute('class', styleClasses);
      a.setAttribute('role', 'button');
      var strClear = this.getTranslatedString('labelAccClearValue');
      a.setAttribute('aria-label', strClear);

      a.addEventListener('click', this._HandleClearValueIconClick.bind(this));

      return a;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _HandleClearValueIconClick: function () {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * Called when the filter field is blurred.
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _HandleFilterFieldBlur: function () {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _GetDefaultValueItemForPlaceholder: function () {
      oj.Assert.failedInAbstractFunction();
      return null;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _initLovMainField: function (lovMainField) {
      this._lovMainFieldInputEventListeners = {
        focus: function (event) {
          LovUtils.killEvent(event);
          if (!this._fullScreenPopup && !this.options.readOnly) {
            // JET-34889 - WHEN OJ-SELECT-SINGLE GETS FOCUS, SELECT THE INPUT TEXT TO ALLOW TYPING
            // WITHOUT CLEARING FIRST
            // set a timer to handle the focus so that the main input has the correct selection range
            // and we can transfer it from the main input to the filter input
            // (Trying to listen to the main input 'select' event for this instead of using a timer
            // doesn't seem to work. Clicking on the dropdown arrow doesn't show a cursor at the end
            // of the text. Maybe it only works when there's a range involved, not just moving the
            // cursor.)
            this._clearMainFieldFocusHandlerTimer();
            var resolveBusyContext = this._AddBusyState(
              'Select showing filter field after focusing main field'
            );
            this._mainFieldFocusHandlerTimer = TimerUtils.getTimer(0);

            // JET-44965 - SELECT SINGLE LOSING FOCUS LOST
            // save the selection range now, because the component could be refreshed before
            // the focus timer promise resolves
            var mainInputElem = this._lovMainField.getInputElem();
            var selectionRange = {
              selectionStart: mainInputElem.selectionStart,
              selectionEnd: mainInputElem.selectionEnd,
              selectionDirection: mainInputElem.selectionDirection
            };

            this._mainFieldFocusHandlerTimer.getPromise().then(
              function (pending) {
                // only act on the timer if it hasn't been cleared
                if (pending) {
                  this._mainFieldFocusHandlerTimer = null;
                  this._ShowFilterField();
                  // JET-45389 - if this is the same input elem as before the timer fired, get its
                  // current selection range now that it has had time to process getting focus
                  var currMainInputElem = this._lovMainField.getInputElem();
                  if (mainInputElem === currMainInputElem) {
                    selectionRange = {
                      selectionStart: mainInputElem.selectionStart,
                      selectionEnd: mainInputElem.selectionEnd,
                      selectionDirection: mainInputElem.selectionDirection
                    };
                  }
                  // JET-34889 - WHEN OJ-SELECT-SINGLE GETS FOCUS, SELECT THE INPUT TEXT TO ALLOW
                  // TYPING WITHOUT CLEARING FIRST
                  // transfer the selection range from the main input to the filter input
                  var filterInputElem = this._getFilterInputElem();
                  if (filterInputElem) {
                    filterInputElem.setSelectionRange(
                      selectionRange.selectionStart,
                      selectionRange.selectionEnd,
                      selectionRange.selectionDirection
                    );
                  }
                }
                resolveBusyContext();
              }.bind(this)
            );
          }
        }.bind(this)
      };
      $(lovMainField.getInputElem()).on(this._lovMainFieldInputEventListeners);

      // assign event listeners
      $(lovMainField.getElement()).on({
        mousedown: this._handleContainerMouseDown.bind(this)
      });
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _clearMainFieldFocusHandlerTimer: function () {
      if (this._mainFieldFocusHandlerTimer) {
        this._mainFieldFocusHandlerTimer.clear();
        this._mainFieldFocusHandlerTimer = null;
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _getFilterInputElem: function () {
      var $filterInputElem = $(this._filterInputText).find('input');
      if ($filterInputElem.length > 0) {
        return $filterInputElem[0];
      }
      return null;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _createFilterInputText: function (className, idSuffix) {
      var ariaLabel = this.OuterWrapper.getAttribute('aria-label');
      var options = this.options;

      var filterInputText = document.createElement('oj-input-text');
      filterInputText.setAttribute('display-options.messages', 'none');
      filterInputText.setAttribute('user-assistance-density', 'compact');
      filterInputText.setAttribute('id', className + '-filter-' + idSuffix);
      filterInputText.setAttribute('class', className + '-filter');
      filterInputText.setAttribute('clear-icon', this._fullScreenPopup ? 'conditional' : 'never');
      // JET-37990 - oj-select-single: autocomplete is not disabled in chrome browser
      // Chrome used to ignore "off" value, but as of Chrome 81 it works more reliably
      // (https://stackoverflow.com/questions/57367813/2019-chrome-76-approach-to-autocomplete-off)
      filterInputText.setAttribute('autocomplete', 'off');
      filterInputText.setAttribute('aria-autocomplete', 'list');
      filterInputText.setAttribute('data-oj-internal', '');
      filterInputText.setAttribute('data-oj-context', '');
      filterInputText.setAttribute('data-oj-binding-provider', 'none');
      if (options.placeholder) {
        filterInputText.setAttribute('placeholder', options.placeholder);
      }
      // disable the oj-input-text when oj-select-single is disabled
      filterInputText.setAttribute('disabled', options.disabled);
      // if (options.labelEdge) {
      //   filterInputText.setAttribute('label-edge', options.labelEdge);
      // }
      // if (options.labelHint) {
      //   filterInputText.setAttribute('label-hint', options.labelHint);
      // }
      if (ariaLabel) {
        filterInputText.setAttribute('aria-label', ariaLabel);
      }
      // apply virtualKeyboard input type to search field
      filterInputText.setAttribute('virtual-keyboard', options.virtualKeyboard);

      if (!this._fullScreenPopup) {
        // create a hidden icon in the end slot to account for the dropdown open icon in the main
        // field on desktop
        var a = document.createElement('a');
        a.setAttribute(
          'class',
          className +
            '-arrow ' +
            className +
            '-open-icon ' +
            className +
            '-icon oj-component-icon oj-clickable-icon-nocontext'
        );
        a.setAttribute('slot', 'end');
        filterInputText.appendChild(a);
      } else {
        var strCancel = this.getTranslatedString('cancel');
        var backIcon = document.createElement('span');
        backIcon.setAttribute('id', 'cancelButton_' + this._idSuffix);
        backIcon.setAttribute('slot', 'start');
        backIcon.setAttribute('class', className + '-back-button');
        backIcon.setAttribute('aria-label', strCancel);
        backIcon.setAttribute('role', 'button');
        backIcon.addEventListener(
          'click',
          function () {
            // focus the input element after canceling on mobile because we want the focus to
            // go back to the main part of the component, and the user can tab out or reopen the
            // dropdown
            this._lovMainField.getInputElem().focus();
            this._abstractLovBase.cancel();
          }.bind(this)
        );

        filterInputText.appendChild(backIcon);
        var innerIcon = document.createElement('span');

        innerIcon.setAttribute(
          'class',
          className +
            '-back-icon ' +
            className +
            '-icon oj-component-icon oj-clickable-icon-nocontext'
        );
        backIcon.appendChild(innerIcon);
      }

      var $elem = $(this.OuterWrapper);
      filterInputText.addEventListener(
        'rawValueChanged',
        function (event) {
          if (!this._ignoreFilterFieldRawValueChanged) {
            // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
            // maintain flag that the user has typed filter text so that we don't override it with
            // the selected label if a data fetch comes in afterwards
            this._userHasTypedFilterText = true;

            this._updateResults(event);
          }
        }.bind(this)
      );
      filterInputText.addEventListener('focus', function () {
        $elem.addClass('oj-focus');
        this._mousedownOnDropdown = false;
      });
      filterInputText.addEventListener(
        'blur',
        function (event) {
          $elem.removeClass('oj-focus');
          if (!this._fullScreenPopup) {
            // don't hide the filter field if:
            // * tabbing into the dropdown, or
            // * clicking on an empty area of the dropdown, or
            // * JET-47185 - Acc: SelectSingle loses focus if we switch to other windows - Potential
            //   Keyboard trap in a dialog
            //   Alt+Tabbing to other application windows, in which case the document.activeElement
            //   will still be in the filter field
            var focusInDropdown =
              event.relatedTarget &&
              DomUtils.isAncestor(this._lovDropdown.getElement(), event.relatedTarget);
            var focusInFilterField =
              document.activeElement && DomUtils.isAncestor(filterInputText, document.activeElement);
            if (!focusInDropdown && !this._mousedownOnDropdown && !focusInFilterField) {
              // JET-65757 - Empty value rejected when not confirmed by Enter/Tab
              // clear the value after deleting all the filter text and clicking outside the
              // component
              this._HandleFilterFieldBlur();

              this._showMainField();
            }
          }
          this._mousedownOnDropdown = false;
        }.bind(this)
      );

      // Add mousedown event listener only on desktop, since we do not want to toggle
      // dropdown when tapped on filter input text when using in mobile
      if (!this._fullScreenPopup) {
        filterInputText.addEventListener('mousedown', this._handleContainerMouseDown.bind(this));
      }

      return filterInputText;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _CreateLovDropdown: function () {
      oj.Assert.failedInAbstractFunction();
      return null;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _initLovDropdown: function (
      idSuffix,
      inputType,
      containerId,
      getTranslatedStringFunc,
      addBusyStateFunc,
      afterDropdownInitFunc
    ) {
      this._lovDropdown.init({
        dataProvider: this._wrappedDataProvider,
        className: 'oj-select',
        parentId: containerId,
        idSuffix: idSuffix,
        dropdownElemId: this._dropdownElemId,
        fullScreenPopup: this._fullScreenPopup,
        inputType: inputType,
        bodyElem: $(this.OuterWrapper).closest('body')[0],
        itemTemplate: this._GetTemplateSlot('itemTemplate'),
        collectionTemplate: this._GetTemplateSlot('collectionTemplate'),
        getTemplateEngineFunc: this._loadTemplateEngine.bind(this),
        templateContextComponentElement: this.OuterWrapper,
        getTranslatedStringFunc: getTranslatedStringFunc,
        addBusyStateFunc: addBusyStateFunc,
        itemTextRendererFunc: this._ItemTextRenderer.bind(this),
        filterInputText: this._filterInputText,
        afterDropdownInitFunc: afterDropdownInitFunc,
        getThrottlePromiseFunc: this._GetThrottlePromise.bind(this),
        isValueForPlaceholderFunc: this._IsValueForPlaceholder.bind(this),
        isValueItemForPlaceholderFunc: this._IsValueItemForPlaceholder.bind(this),
        styleClassComponentName: this._GetStyleClassComponentName()
      });
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _openDropdown: function () {
      this._mousedownOnDropdown = false;

      // defer initialization of dropdown until we open it
      if (this._initLovDropdownFunc) {
        var initLovDropdownFunc = this._initLovDropdownFunc;
        this._initLovDropdownFunc = null;
        initLovDropdownFunc(
          function () {
            // JET-41568 - Select single in data grid causes console error when opening second before
            // exiting edit mode on first
            // Since this function is executed asynchronously after initializing the dropdodwn, we need
            // to make sure that the component itself has not been released.
            if (this._abstractLovBase) {
              this._abstractLovBase.openDropdown();
            }
          }.bind(this)
        );
      } else {
        this._abstractLovBase.openDropdown();
      }
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _updateResults: function (event) {
      // defer initialization of dropdown until we open it
      if (this._initLovDropdownFunc) {
        var initLovDropdownFunc = this._initLovDropdownFunc;
        this._initLovDropdownFunc = null;
        initLovDropdownFunc(
          function () {
            // JET-41568 - Select single in data grid causes console error when opening second before
            // exiting edit mode on first
            // Since this function is executed asynchronously after initializing the dropdodwn, we need
            // to make sure that the component itself has not been released.
            if (this._abstractLovBase) {
              this._abstractLovBase.updateResults(event);
            }
          }.bind(this)
        );
      } else {
        this._abstractLovBase.updateResults(event);
      }
    },

    /**
     * Initiate loading of the template engine.  An error is thrown if the template engine failed to
     * load.
     * @return {Promise} resolves to the template engine, or null if no item template is specified
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _loadTemplateEngine: function () {
      if (!this._templateEngine) {
        var resolveBusyContext = this._AddBusyState('Select loading template engine');
        return new Promise(
          function (resolve, reject) {
            const templateOptions = {
              customElement: this._GetCustomElement(),
              needsTrackableProperties: true
            };
            Config.__getTemplateEngine(templateOptions).then(
              function (engine) {
                this._templateEngine = engine;
                resolve(engine);
                resolveBusyContext();
              }.bind(this),
              function (reason) {
                reject(new Error('Error loading template engine: ' + reason));
                resolveBusyContext();
              }
            );
          }.bind(this)
        );
      }

      return Promise.resolve(this._templateEngine);
    },

    /**
     * Refreshes the Select.
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof oj.ojSelectBase
     * @instance
     * @return {void}
     * @public
     */
    refresh: function () {
      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      if (this._makingInternalValueChange) {
        this._queueValueChangeDeferredCallback(
          function () {
            this.refresh();
          }.bind(this)
        );

        return;
      }

      var mainFieldInputElem = this._lovMainField.getInputElem();
      // JET-34351 - OJ-SELECT-SINGLE DOES NOT SHOW VALUE IF OPTIONS ARE UPDATED ASYNC
      // set this flag while calling superclass refresh so that we can defer handling any
      // _SetDisplayValue calls until after we've setup again
      this._bSuperRefreshing = true;
      this._super();
      this._bSuperRefreshing = false;

      // Bug JET-35402 - help.instruction does not display after oj-select-single went from disabled to enabled
      // We will be reusing the main field's input element, so we need to retain it along
      // with the data it holds.
      this._ReleaseSelectResources(true);

      this._SetupSelectResources(mainFieldInputElem);

      this._initComponentMessaging();

      // JET-34351 - OJ-SELECT-SINGLE DOES NOT SHOW VALUE IF OPTIONS ARE UPDATED ASYNC
      // after we've setup again, now process any deferred _SetDisplayValue calls
      if (this._deferredSetDisplayValue) {
        this._deferredSetDisplayValue();
      }
    },

    /**
     * Override to setup resources needed by this component.
     * @memberof oj.ojSelectBase
     * @override
     * @protected
     */
    _SetupResources: function () {
      this._super();

      // only do something if _ReleaseResources was called, because _SetupResources will be called
      // after _ComponentCreate and _AfterCreate during initialization, in which case we will have
      // already called _SetupSelectResources during _ComponentCreate
      if (this._bReleasedResources) {
        this._bReleasedResources = false;

        this._SetupSelectResources();

        this._initComponentMessaging();
      }
    },

    /**
     * Override to release resources held by this component.
     * @memberof oj.ojSelectBase
     * @override
     * @protected
     */
    _ReleaseResources: function () {
      this._super();

      this._bReleasedResources = true;

      this._ReleaseSelectResources();

      this._superSetOptions = null;
      this._setOptionsQueue = null;
    },

    /**
     * <ol>
     * <li>All messages are cleared, including custom messages added by the app. </li>
     * <li>The implicit required validator is run if the component is marked required.</li>
     * <li>At the end of validation if there are errors, the messages are shown.
     * If there were no errors, then the
     * <code class="prettyprint">value</code> option is updated.</li>
     * </ol>
     *
     * @example <caption>Validate component using its current value.</caption>
     * myComp.validate();
     *
     * @example <caption>Validate component and use the Promise's resolved state.</caption>
     * myComp.validate().then(
     *  function(result) {
     *    if(result === "valid")
     *    {
     *      submitForm();
     *    }
     *  });
     * @return {Promise} Promise resolves to "valid" if the component passed all validations.
     * The Promise resolves to "invalid" if there were validation errors.
     * @ojshortdesc Validates the component's display value using all validators registered on the component. If there are no validation errors, then the value is updated. See the Help documentation for more information.
     * @method
     * @access public
     * @expose
     * @instance
     * @memberof oj.ojSelectBase
     */
    validate: function () {
      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      if (this._makingInternalValueChange) {
        var resolveFunc;
        var rejectFunc;
        var promise = new Promise(function (resolve, reject) {
          resolveFunc = resolve;
          rejectFunc = reject;
        });
        this._queueValueChangeDeferredCallback(
          function () {
            this.validate().then(resolveFunc, rejectFunc);
          }.bind(this)
        );

        return promise;
      }

      return this._ValidateHelper();
    },

    /**
     * @memberof oj.ojSelectBase
     * @instance
     * @protected
     */
    _ValidateHelper: function () {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * @memberof oj.ojSelectBase
     * @instance
     * @protected
     */
    _GetValueItemPropertyName: function () {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * skeep value in sync with valueItem
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _SyncValueWithValueItem: function (valueItem, value, context) {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * update display label(s) and valueItem(s) after value was set
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _UpdateValueItem: function (value) {
      oj.Assert.failedInAbstractFunction();
    },

    /**
     * Queue a microtask to finish processing a _setOptions call.
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _queueSetOptionsMicrotask: function () {
      // In vdom architecture, there are multiple issues with value and valueItem properties,
      // as well as other properties, that we need to handle.
      //
      // JET-51307 - Wrapping select single with value item and value integrations going into loop
      // with multiple instances of LOV in a page
      // If we're wrapped by a VComponent and there are multiple instances on the page
      // all bound to the same valueItem, then if the user selects a new value in one instance,
      // the page can go into an infinite loop.
      // If we synchronously update the value on our DOM element here, then when the next preact
      // render compares the stale vcomp value property against the new value in the DOM, preact
      // determines it must push the stale value property back down onto us, which then causes
      // the valueItem to get sync'ed again, and the loop goes on.
      //
      // JET-55775 - oj-select-single initiates fetch even when valueItem is provided in preact
      // wrapper
      // In preact, when value & valueItem are set at the same time, we will receive them one after
      // the other.  So, if we process the value when we get it, then we might initiate an
      // unnecessary fetch as we will later get the data from valueItem.
      //
      // JET-64359 - select - single handling of mutation on both value and valueItem properties
      // coming from preact
      // Also, when either value or valueItem property is ignored when updating props in the wrapper
      // vcomponent, we will get a setOption call with a null / default value for that property.
      // In these cases, depending on the order we receive the call, we might incorrectly end up
      // setting the null / default value.
      //
      // JET-66896 - Value is not displayed when provider and value are set together
      // When value and data were set together, the valueItem ended up with null data and metadata,
      // so the label for the selected value was not displayed.
      //
      // JET-65611 - Form is in invalid state though the values are populated correctly
      // This bug was related to the fact that the framework introduced changes in JET 16 so that
      // the component gets batched property sets in VDOM, similar to knockout.js, whereas before
      // each property was set individually.  For some property sets, like readonly, the code
      // internally does a refresh.  For a valueItem change, in VDOM only, the code processed it
      // in a microtask (to fix other issues encountered in VDOM).  With the previous, individual
      // property setting behavior in VDOM, an internal refresh would happen before the new
      // valueItem was even set on the component.  With the batching property setting behavior,
      // the valueItem started to be processed before the internal refresh and then finished after
      // the refresh, such that the changes were interfering with each other.
      //
      // In order to address all these cases, if we know we are in VDOM, we will queue a
      // microtask to process the options.  Since preact calls setOptions synchronously for each
      // option, our microtask callback will have access to all the accumulated options at once,
      // similar to what would happen in MVVM.

      var microtaskFunc = () => {
        // reset the queue first so that any new _setOptions calls made during processing of
        // this microtask will start a new queue
        var setOptionsQueue = this._setOptionsQueue;
        this._setOptionsQueue = null;

        // JET-66038 - REGRESSION FOR EXPENSETYPEID FIELD 'GETINPUTELEM' ERROR
        // When this function is executed in a microtask, it's possible that the element has been
        // removed from the DOM and its resources released since the microtask was queued.  If so,
        // simply return without doing anything; otherwise we may throw an NPE because we've
        // already destroyed our internal structures.
        if (this._bReleasedResources) {
          // Ideally we would let the set proceed and simply guard against NPE due to released
          // internal structures so that if we're ever reconnected, we can re-establish the
          // previous state.
          return;
        }

        // Collapse the individual _setOptions calls into a single options object so we can process
        // all the properties at once.
        // Use the first flags object because we shouldn't need to accumulate different flags across
        // the _setOptions calls.  Preact doesn't pass any flags, and any that we use internally
        // would not be intermingled with other _setOptions calls in the same microtask.
        var queuedOptions = setOptionsQueue.reduce((accum, curr, index) => {
          return {
            options: { ...accum.options, ...curr.options },
            flags: index === 0 ? curr.flags : accum.flags
          };
        }, {});
        var options = queuedOptions.options;
        var flags = queuedOptions.flags;

        // eslint-disable-next-line no-prototype-builtins
        var hasValue = options.hasOwnProperty('value');
        // eslint-disable-next-line no-prototype-builtins
        var hasValueItem = options.hasOwnProperty(this._GetValueItemPropertyName());
        // Get the latest value and valueItem
        const _valueItem = options[this._GetValueItemPropertyName()];
        const _value = options.value;
        // Determine empty states
        // Note that _Is*****ForPlaceholder simply checks whether the value/valueItem
        // represents the empty/null state.
        const isEmptyValue = this._IsValueForPlaceholder(_value);
        const isEmptyValueItem = this._IsValueItemForPlaceholder(_valueItem);
        // If both value and valueItem are provided, then compare them to decide what to do
        if (hasValue && hasValueItem) {
          // if valueItem and value are not null, and they are conflicting then throw an error
          if (!isEmptyValue && !isEmptyValueItem && _valueItem.key !== _value) {
            throw new Error('Select Single: conflicting value-item and value');
          }

          // At this point, either one of them is empty or they both have the same
          // key. So, if valueItem is not empty, use it (and delete the value from the options).
          // Otherwise, use the value (and delete the valueItem from the options).
          if (!isEmptyValueItem) {
            delete options.value;
          } else {
            delete options[this._GetValueItemPropertyName()];
          }
        }

        this._setOptionsHelper(options, flags, this._superSetOptions);
      };

      window.queueMicrotask(microtaskFunc);
    },

    /**
     * Sets multiple options
     * @param {Object} options the options object
     * @param {Object} flags additional flags for option
     * @override
     * @protected
     * @memberof! oj.ojSelectBase
     */
    _setOptions: function (options, flags) {
      const elemState = ojcustomelementUtils.CustomElementUtils.getElementState(this.OuterWrapper);
      if (elemState.getBindingProviderType() === 'preact') {
        // If we're in preact and we haven't already queued a microtask to process the options,
        // queue one now.  We will handle all the accumulated options at once in the microtask.
        if (!this._setOptionsQueue) {
          this._setOptionsQueue = [];
          this._superSetOptions = this._super.bind(this);
          this._queueSetOptionsMicrotask();
        }
        this._setOptionsQueue.push({ options: { ...options }, flags: { ...flags } });
      } else {
        this._setOptionsHelper(options, flags, this._super.bind(this));
      }
    },

    /**
     * Helper function to set options.
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _setOptionsHelper: function (options, flags, superSetOptions) {
      // JET-50116: Styles error in oj-select-single
      // If the component is already destroyed, we would have released all the internal resources.
      // If so, simply return without doing anything; otherwise we may throw an NPE because we've
      // already destroyed our internal structures.
      if (this._bReleasedResources) {
        // Ideally we would let the set proceed and simply guard against NPE due to released
        // internal structures so that if we're ever reconnected, we can re-establish the
        // previous state.
        // But, we are not sure how often this happens or if these options sets while detached are
        // unintentional. So, if we ever get a bug filed for this, we can revisit this fix.
        return;
      }

      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      if (this._makingInternalValueChange) {
        this._queueValueChangeDeferredCallback(
          function () {
            // JET-46247 - Acc: described-by resets after changing the data provider
            // don't re-set the same labelledBy again because it can affect whether the label
            // actually gets read out by the screen reader (because it may change how the label is
            // configured between the main and filter inputs)
            var newOptions = Object.assign({}, options);
            if (
              // eslint-disable-next-line no-prototype-builtins
              newOptions.hasOwnProperty('labelledBy') &&
              newOptions.labelledBy === this.options.labelledBy
            ) {
              delete newOptions.labelledBy;
              if (Object.entries(newOptions).length === 0) {
                return;
              }
            }
            this._setOptions(newOptions, flags);
          }.bind(this)
        );

        return;
      }

      // JET-34601 - SELECT SINGLE- CHANGING DISABLED PROPERTY GIVES A GLOWING EFFECT
      // Create a temporary object for individual _setOption calls to store things, so that we can
      // process them in a particular order, if necessary.
      // Push an object for this _setOptions call.  There may be nested _setOptions calls if
      // 'labelEdge' is being set, because it in turn may set 'labelledBy'.  If we used a single
      // object, not an array of objects, then the nested call would clear the single object, and
      // when the outer call tries to access it below, it will be null.
      if (!this._processSetOptions) {
        this._processSetOptions = [];
      }
      this._processSetOptions.push({});

      // JET-37550 - REGRESSION : OJ-SELECT-SINGLE NOT DISPLAYING DEFAULT VALUE
      // if setting both data and value at the same time, defer setting the value until after the
      // data has been set
      var resolveBusyState;
      var needToUpdateValueItem = false;
      // eslint-disable-next-line no-prototype-builtins
      var hasData = options.hasOwnProperty('data');
      // eslint-disable-next-line no-prototype-builtins
      var hasValue = options.hasOwnProperty('value');
      // eslint-disable-next-line no-prototype-builtins
      var hasValueItem = options.hasOwnProperty(this._GetValueItemPropertyName());
      // JET-38612 - Select Single | Value, disable bug
      // check whether any of the options being set will require a refresh
      var requiresRefresh = false;
      // iterate over the set of options being applied because that set is most likely smaller than
      // the set of options that would require a refresh, so the loop iterates fewer times
      var keys = Object.keys(options);
      for (var i = 0; i < keys.length; i++) {
        if (this._OPTIONS_REQUIRING_REFRESH.has(keys[i])) {
          requiresRefresh = true;
          break;
        }
      }
      if (requiresRefresh) {
        if (hasValue) {
          // JET-38612 - Select Single | Value, disable bug
          // if the options require a refresh and a new value is being set that requires a fetch,
          // defer setting the new value until after the refresh
          this._deferSettingValue = true;
          // maintain a busy state until we've at least started to process all changes
          resolveBusyState = this._AddBusyState('Defer setting value');
        } else if (hasData && !hasValueItem) {
          // JET-38441 - WHEN GENERATOR VARIABLE OF TYPE 'OJS/OJARRAYDATAPROVIDER' IS BOUND TO
          // SELECT-SINGLE, IT FAILS TO SHOW THE SELECTED VALUE
          // if setting new data and the current valueItem was set internally, then it needs to be
          // updated for the new data
          needToUpdateValueItem = this._valueItemSetInternally;
        }
      }

      // JET-42353 - SELECT SINGLE FOCUS LOST ON CHANGE OF THE DEPENDENT VALUE
      // remember whether the filter field is shown before processing the new options so that
      // we can restore it afterwards, if necessary
      var showFilterField = false;
      if (
        !this._fullScreenPopup &&
        this._lovEnabled &&
        this._filterInputText.style.visibility !== 'hidden'
      ) {
        showFilterField = true;
      }

      try {
        superSetOptions(options, flags);

        // grab the latest processSetOptions object and remove it from the array
        var processSetOptions = this._processSetOptions.pop();

        // JET-34601 - SELECT SINGLE- CHANGING DISABLED PROPERTY GIVES A GLOWING EFFECT
        // if we need to refresh, do that before setting a new value
        if (processSetOptions.forRefresh) {
          processSetOptions.forRefresh();
        }

        // turn off the flag now, after refreshing but before processing the new value,
        // only if we set the flag during this call to _setOptions
        if (resolveBusyState) {
          this._deferSettingValue = false;
        }

        if (processSetOptions.value) {
          processSetOptions.value();
        } else if (needToUpdateValueItem) {
          // JET-42413: set flag while we're processing a value change so that if an app makes
          // changes to the component from within the change listener, we can defer processing the
          // new change until after we're done processing the current change
          var resolveValueChangeFunc = this._StartMakingInternalValueChange();

          // JET-38441 - WHEN GENERATOR VARIABLE OF TYPE 'OJS/OJARRAYDATAPROVIDER' IS BOUND TO
          // SELECT-SINGLE, IT FAILS TO SHOW THE SELECTED VALUE
          // if setting new data and the current valueItem was set internally, then it needs to be
          // updated for the new data, which will happen when we re-set the existing value
          this._setOption('value', this.options.value);

          resolveValueChangeFunc();
        }

        // JET-42353 - SELECT SINGLE FOCUS LOST ON CHANGE OF THE DEPENDENT VALUE
        // if the filter field was shown before processing the new options, but is no longer shown,
        // show it again
        if (showFilterField && this._filterInputText.style.visibility === 'hidden') {
          // need to wait for the new filter oj-input-text to be upgraded
          var busyContext = Context.getContext(this._filterInputText).getBusyContext();
          busyContext.whenReady().then(
            function () {
              this._ShowFilterField();
            }.bind(this)
          );
        }
      } finally {
        if (resolveBusyState) {
          resolveBusyState();
        }
      }
    },

    /**
     * Handles options specific to Select.
     * @override
     * @protected
     * @memberof! oj.ojSelectBase
     */
    _setOption: function (key, value, flags) {
      var abstractLovBase = this._abstractLovBase;

      if (key === this._GetValueItemPropertyName()) {
        // JET-44210 - throw an error when a value-item is set externally that contains the key
        // but not the data
        if (!this._IsValueItemForPlaceholder(value) && value.data == null) {
          throw new Error('Select Single: value-item contains key but no data');
        }
      }

      // JET-64632 - DataProvider refresh event can wipe out currently selected value
      // If we get a DP refresh event we may re-set the currently selected value so that we fetch
      // new data for it, in which case we don't want to fire a change event, so don't call the
      // superclass.
      var bSkipSuperclassCall = key === 'value' && this.options.value === value;

      if (!bSkipSuperclassCall) {
        this._super(key, value, flags);
      }

      var processSetOptions;
      if (this._processSetOptions && this._processSetOptions.length > 0) {
        // use the last processSetOptions object, which is the one for the current _setOptions call
        processSetOptions = this._processSetOptions[this._processSetOptions.length - 1];
      }

      //  - need to be able to specify the initial value of select components bound to dprv
      if (key === this._GetValueItemPropertyName()) {
        this._valueItemSetInternally = false;
        this._SyncValueWithValueItem(value, this.options.value);
      } else if (key === 'value') {
        // JET-34601 - SELECT SINGLE- CHANGING DISABLED PROPERTY GIVES A GLOWING EFFECT
        // save the processing function for execution in _setOptions
        var processSetOptionValue = function () {
          abstractLovBase.setValue(value);

          //  - placeholder is not displayed after removing selections from select many
          //  - resetting value when value-item and placeholder are set throws exception
          if (this._IsValueForPlaceholder(value)) {
            this._SetValueItem(this._GetDefaultValueItemForPlaceholder());
          } else {
            // update valueItem
            this._UpdateValueItem(value);
          }

          // need to update display value again after valueItem is set correctly
          this._SetDisplayValue();
        }.bind(this);
        if (processSetOptions) {
          processSetOptions.value = processSetOptionValue;
        } else {
          processSetOptionValue();
        }
      } else if (this._OPTIONS_REQUIRING_REFRESH.has(key)) {
        // JET-34601 - SELECT SINGLE- CHANGING DISABLED PROPERTY GIVES A GLOWING EFFECT
        // save the processing function for execution in _setOptions
        var processSetOptionForRefresh = function () {
          this.refresh();
        }.bind(this);
        if (processSetOptions) {
          processSetOptions.forRefresh = processSetOptionForRefresh;
        } else {
          processSetOptionForRefresh();
        }
      } else if (key === 'labelledBy') {
        if (this.options.labelledBy) {
          var id = this._GetContentElement()[0].id;
          this._labelledByUpdatedForInputComp(this.options.labelledBy, id);
        }

        // TODO: need to do a targeted update here, because calling refresh clears any custom
        // messages that should be shown on first display (because EditableValue may asynchronously
        // set labelled-by attr on our custom element after we've been initialized)
        // this.refresh();
        this._updateLabel();
      } else if (key === 'itemText') {
        // JET-45922 - timing issue with select-single: lov drop-down doesn't have element
        // do a granular update if item-text changes instead of a general refresh
        this._UpdateItemText();
      } else if (key === 'matchBy') {
        // JET-60725 - Add option to specify the matchBy behavior of the text filter
        // Make a copy of the array to use internally so that the application can't mutate it;
        // they have to set a new array if they want to change it.
        this._matchBy = value && value.length > 0 ? [...value] : undefined;
        if (this._abstractLovBase) {
          this._abstractLovBase.setMatchBy(this._matchBy);
        }
      }
    },

    /**
     * Performs post processing after _SetOption() is called. Different options when changed perform
     * different tasks. See _AfterSetOption[OptionName] method for details.
     *
     * @param {string} option
     * @param {Object|string=} previous
     * @param {Object=} flags
     * @protected
     * @memberof! oj.ojSelectBase
     * @instance
     * @override
     */
    // eslint-disable-next-line no-unused-vars
    _AfterSetOption: function (name, flags) {
      this._superApply(arguments);
      switch (name) {
        case 'required':
          this._AfterSetOptionRequired(name);
          break;
        case 'virtualKeyboard':
          this._SetInputType(this._ALLOWED_INPUT_TYPES);
          this.refresh();
          break;
        case 'labelHint':
        case 'labelEdge':
          // Changing labelHint and labelEdge might have updated
          // aria-label on the root element. Check if it is needed to
          // update the aria-label on inner elements.
          this._updateLabel();
          break;
        default:
          break;
      }
    },

    /**
     * Performs post processing after value option changes.
     *
     * @param {string} option
     * @param {Object=} flags
     *
     * @protected
     * @memberof! oj.ojSelectBase
     * @instance
     * @override
     */
    // eslint-disable-next-line no-unused-vars
    _AfterSetOptionValue: function (option, flags) {
      this._superApply(arguments);
      if (option === 'value') {
        this._toggleNoValueStyleClass();
      }
    },

    // 19670748, dropdown popup should be closed on subtreeDetached notification.
    /**
     * @protected
     * @memberof! oj.ojSelectBase
     * @instance
     * @override
     */
    _NotifyDetached: function () {
      this._superApply(arguments);
      this._CloseDropdown();
    },

    // 19670748, dropdown popup should be closed on subtreeHidden notification.
    /**
     * @protected
     * @memberof! oj.ojSelectBase
     * @instance
     * @override
     */
    _NotifyHidden: function () {
      this._superApply(arguments);
      this._CloseDropdown();
    },

    /**
     * @override
     * @protected
     * @memberof! oj.ojSelectBase
     *
     * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
     * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
     * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
     */
    _NotifyContextMenuGesture: function (menu, event, eventType) {
      // The default baseComponent behavior in _OpenContextMenu assumes this.element for the
      // launcher. In this case, the original element the component is bound to is
      // hidden (display: none). Pass in an openOption override.
      var launcher = this._GetMessagingLauncherElement();
      this._OpenContextMenu(event, eventType, { launcher: launcher });
    },

    /**
     * @protected
     * @memberof! oj.ojSelectBase
     * @instance
     */
    _NotifyMessagingStrategyQueueAction: function (promise) {
      // JET-46567 - JAWS is reading out error message even after selecting correct value
      // this will be called from InlineMessagingStrategy._queueAction before the
      // timer to update messages is fired so that we can defer processing until after
      // the DOM has been changed
      this._messagingStrategyQueueActionPromise = promise;
      promise.then(
        function () {
          this._messagingStrategyQueueActionPromise = null;
        }.bind(this)
      );
    },

    /**
     * Returns the jquery element that represents the content part of the component.
     * This is usually the component that user sets focus on (tabindex is set 0) and
     * where aria attributes like aria-required, aria-labelledby etc. are set. This is
     * also the element where the new value is updated. Usually this is the same as
     * the _GetMessagingLauncherElement.
     *
     * @override
     * @protected
     * @memberof! oj.ojSelectBase
     * @return {jQuery} jquery element which represents the content.
     */
    _GetContentElement: function () {
      // if a non-empty string placeholder is set, then EditableValue calls this from within its
      // _ComponentCreate, which is before the abstractLovBase is created
      if (this._lovMainField) {
        return $(this._lovMainField.getInputElem());
      }
      return this.element;
    },

    /**
     * save the new wrapper or the original data provider
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _wrapDataProviderIfNeeded: function (dataProvider) {
      if (LovUtils.isDataProvider(dataProvider)) {
        var wrapper = dataProvider;
        // make sure data provider is an instance of *DataProviderView, and wrap it with one if it
        // isn't, so that we can use the FilterFactory to create filter criterion and have the DP
        // do local filtering if needed
        if (LovUtils.isTreeDataProvider(dataProvider)) {
          if (!(dataProvider instanceof TreeDataProviderView)) {
            wrapper = new TreeDataProviderView(dataProvider);
          }
        } else if (!(dataProvider instanceof ListDataProviderView)) {
          wrapper = new ListDataProviderView(dataProvider);
        }

        // Wrap the data provider in the CachingDataProvider first
        wrapper = ojdataproviderfactory.getEnhancedDataProvider(wrapper, {
          fetchFirst: { caching: 'visitedByCurrentIterator' },
          // dedup: { type: 'iterator' },
          eventFiltering: { type: 'iterator' }
        });

        wrapper = new FilteringDataProviderView(wrapper);
        // save the data provider or wrapper
        this._wrappedDataProvider = wrapper;
      } else {
        this._wrappedDataProvider = new FilteringDataProviderView(null);
      }
    },

    /**
     * Add data provider event listeners
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _addDataProviderEventListeners: function () {
      var dataProvider = this._wrappedDataProvider;
      if (dataProvider) {
        this._removeDataProviderEventListeners();

        var dataProviderEventHandler = this._HandleDataProviderEvent.bind(this);
        this._savedDataProviderEH = dataProviderEventHandler;

        dataProvider.addEventListener('mutate', dataProviderEventHandler);
        dataProvider.addEventListener('refresh', dataProviderEventHandler);
      }
    },

    /**
     * Remove data provider event listeners
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _removeDataProviderEventListeners: function () {
      var dataProvider = this._wrappedDataProvider;
      var dataProviderEventHandler = this._savedDataProviderEH;

      if (dataProvider && dataProviderEventHandler) {
        dataProvider.removeEventListener('mutate', dataProviderEventHandler);
        dataProvider.removeEventListener('refresh', dataProviderEventHandler);

        this._savedDataProviderEH = undefined;
      }
    },

    /**
     * Handle data provider events
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _HandleDataProviderEvent: function (event) {
      // to be implemented by subclass
    },

    /**
     * Renders text representing a data item.
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _ItemTextRenderer: function (valueItem) {
      var formatted;
      if (valueItem && valueItem.data) {
        var itemText = this.options.itemText;
        if (typeof itemText === 'string') {
          formatted = valueItem.data[itemText];
        } else {
          formatted = itemText(valueItem);
        }
      }
      return formatted;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _IsValueItemForPlaceholder: function (valueItem) {
      oj.Assert.failedInAbstractFunction();
      return false;
    },

    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _IsValueForPlaceholder: function (value) {
      oj.Assert.failedInAbstractFunction();
      return false;
    },

    //  - need to be able to specify the initial value of select components bound to dprv
    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    // eslint-disable-next-line no-unused-vars
    _SetValueItem: function (valueItem) {
      oj.Assert.failedInAbstractFunction();
    },

    // fetch the data row by its key("value")
    // returns a promise that resolves to an object with one property: results
    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @protected
     */
    _FetchByKeysFromDataProvider: function (arKeys) {
      //  - sdp.fetchbykeys method is being called twice for a single value
      // Stored the selected value in this._cachedFetchByKeys, it will be cleared when the
      // promise is resolved or rejected. When this method is called again with the same selected
      // value, don't make another call to dataProvider.fetchByKeys because the previous one is in
      // flight.
      var fetchPromise;
      if (
        this._cachedFetchByKeys &&
        this._cachedFetchByKeys.promise &&
        oj.Object.compareValues(arKeys, this._cachedFetchByKeys.key)
      ) {
        fetchPromise = this._cachedFetchByKeys.promise;
      } else {
        // add busy context
        var fetchResolveFunc = this._AddBusyState('fetching selected data');
        //  - display loading indicator when fetching label for initial value is slow
        var bLoadingIndicatorAdded = false;
        if (this._abstractLovBase.getFetchType() === 'init') {
          if (!this._abstractLovBase.isDropdownOpen()) {
            bLoadingIndicatorAdded = true;
            this._setUiLoadingState('start');
          }
        }

        fetchPromise = new Promise(
          function (resolve, reject) {
            // fetch the data row by its key("value")
            var dpPromise = this._wrappedDataProvider.fetchByKeys({ keys: new Set(arKeys) });
            dpPromise.then(
              function (fetchResults) {
                var data = [];
                var metadata = [];
                fetchResults.results.forEach(function (val) {
                  data.push(val.data);
                  metadata.push(val.metadata);
                });

                resolve({
                  data: data,
                  metadata: metadata
                });
              },
              function (reason) {
                reject(reason);
              }
            );
          }.bind(this)
        );

        // save key and promise
        // eslint-disable-next-line no-param-reassign
        this._cachedFetchByKeys = {
          key: arKeys,
          promise: fetchPromise
        };

        var afterFetchPromiseFunc = function () {
          // JET-34713 Error updating array dataprovider of ojSelectSingle while its hidden
          // Abort if select single has been disconnected
          if (!this._bReleasedResources) {
            //  - sdp.fetchbykeys method is being called twice for a single value
            // eslint-disable-next-line no-param-reassign
            this._cachedFetchByKeys = undefined;

            if (bLoadingIndicatorAdded) {
              this._setUiLoadingState('stop');
            }
          }
          fetchResolveFunc();
        }.bind(this);
        fetchPromise.then(
          function () {
            afterFetchPromiseFunc();
          },
          function (reason) {
            Logger.warn('Select: fetchByKeys promise was rejected: ' + reason);
            afterFetchPromiseFunc();
          }
        );
      }

      return fetchPromise;
    },

    /**
     * Set the UI loading state of the component. After a delay, this function displays
     * a loading indicator on the component.
     * @param {string} state The state value to set; can be one of "start" or "stop"
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _setUiLoadingState: function (state) {
      if (state === 'start') {
        // Clear out any existing timer
        if (this._loadingIndicatorTimer) {
          this._loadingIndicatorTimer.clear();
        }
        this._loadingIndicatorTimer = TimerUtils.getTimer(this._showIndicatorDelay);
        this._loadingIndicatorTimer.getPromise().then(
          function (pending) {
            // Only add the loading indicator if loading request is still pending
            // (not cleared out by request finishing)
            if (pending) {
              this._addLoadingIndicator();
            }
          }.bind(this)
        );
      } else if (state === 'stop') {
        if (this._loadingIndicatorTimer) {
          this._loadingIndicatorTimer.clear();
          this._loadingIndicatorTimer = null;
        }
        this._removeLoadingIndicator();
      }
    },

    // Add a loading indicator to the select box
    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _addLoadingIndicator: function () {
      //  - display loading indicator when fetching label for initial value is slow
      this._loadingIndicatorCount += 1;

      // check if it's already added
      if (this._savedLoadingIndicator) {
        return;
      }

      this._SetLoading();

      this._savedLoadingIndicator = true;
    },

    // Remove the loading indicator
    /**
     * @memberof! oj.ojSelectBase
     * @instance
     * @private
     */
    _removeLoadingIndicator: function () {
      // don't decrement count below 0
      if (this._loadingIndicatorCount > 0) {
        this._loadingIndicatorCount -= 1;
      }
      //  - display loading indicator when fetching label for initial value is slow
      // remove the loading indicator when reference count down to 0
      if (this._loadingIndicatorCount === 0 && this._savedLoadingIndicator) {
        this._ClearLoading();
        this._savedLoadingIndicator = false;
      }
    }

    // Superclass Doc Overrides
    /**
     * @ojslot contextMenu
     * @ignore
     * @memberof oj.ojSelectBase
     */
  });

  exports.AbstractLovBase = AbstractLovBase;
  exports.FilteringDataProviderView = FilteringDataProviderView;
  exports.LovDropdown = LovDropdown;
  exports.LovMainField = LovMainField;
  exports.LovUtils = LovUtils;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojselectsingle',['ojs/ojselectbase', 'ojs/ojcore-base', 'ojs/ojkeyset', 'jquery', 'ojs/ojcomponentcore', 'ojs/ojthemeutils', 'ojs/ojlogger', 'ojs/ojcustomelement-utils'], function (ojselectbase, oj, ojkeyset, $, Components, ThemeUtils, Logger, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  (function () {
var __oj_select_single_metadata = 
{
  "properties": {
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "deprecated",
              "since": "14.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "helpInstruction": {
          "type": "Array<string>|string",
          "value": [
            "notewindow"
          ]
        },
        "messages": {
          "type": "Array<string>|string"
        }
      }
    },
    "help": {
      "type": "object",
      "properties": {
        "instruction": {
          "type": "string",
          "value": ""
        }
      }
    },
    "helpHints": {
      "type": "object",
      "properties": {
        "definition": {
          "type": "string",
          "value": ""
        },
        "source": {
          "type": "string",
          "value": ""
        }
      }
    },
    "itemText": {
      "type": "string|function",
      "value": "label"
    },
    "labelEdge": {
      "type": "string",
      "enumValues": [
        "inside",
        "none",
        "provided"
      ]
    },
    "labelHint": {
      "type": "string",
      "value": ""
    },
    "labelledBy": {
      "type": "string"
    },
    "matchBy": {
      "type": "Array<string>"
    },
    "messagesCustom": {
      "type": "Array<Object>",
      "writeback": true,
      "value": []
    },
    "placeholder": {
      "type": "string",
      "value": ""
    },
    "readonly": {
      "type": "boolean",
      "value": false
    },
    "required": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "cancel": {
          "type": "string"
        },
        "labelAccClearValue": {
          "type": "string"
        },
        "labelAccOpenDropdown": {
          "type": "string"
        },
        "multipleMatchesFound": {
          "type": "string"
        },
        "nOrMoreMatchesFound": {
          "type": "string"
        },
        "noMatchesFound": {
          "type": "string"
        },
        "noResultsLine1": {
          "type": "string"
        },
        "noResultsLine2": {
          "type": "string"
        },
        "oneMatchFound": {
          "type": "string"
        },
        "required": {
          "type": "object",
          "properties": {
            "hint": {
              "type": "string"
            },
            "messageDetail": {
              "type": "string"
            },
            "messageSummary": {
              "type": "string"
            }
          }
        }
      }
    },
    "userAssistanceDensity": {
      "type": "string",
      "enumValues": [
        "compact",
        "efficient",
        "reflow"
      ],
      "value": "reflow"
    },
    "valid": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "invalidHidden",
        "invalidShown",
        "pending",
        "valid"
      ],
      "readOnly": true
    },
    "value": {
      "type": "any",
      "writeback": true
    },
    "valueItem": {
      "type": "object",
      "writeback": true,
      "value": {
        "key": null,
        "data": null,
        "metadata": null
      }
    },
    "virtualKeyboard": {
      "type": "string",
      "enumValues": [
        "email",
        "number",
        "search",
        "tel",
        "text",
        "url"
      ],
      "value": "search"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "reset": {},
    "setProperties": {},
    "setProperty": {},
    "showMessages": {},
    "validate": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojValueAction": {}
  },
  "extension": {}
};
    __oj_select_single_metadata.extension._WIDGET_NAME = 'ojSelectSingle';
    __oj_select_single_metadata.extension._INNER_ELEM = 'input';
    __oj_select_single_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['tabindex'];
    __oj_select_single_metadata.extension._ALIASED_PROPS = { readonly: 'readOnly' };
    oj.CustomElementBridge.register('oj-select-single', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_select_single_metadata, {
        properties: {
          readonly: {
            binding: { consume: { name: 'readonly' } }
          },
          userAssistanceDensity: {
            binding: { consume: { name: 'userAssistanceDensity' } }
          },
          labelEdge: {
            binding: { consume: { name: 'labelEdge' } }
          }
        }
      })
    });
  })();

  /**
   * @private
   */
  const LovDropdownSingle = function () {};

  oj.Object.createSubclass(LovDropdownSingle, ojselectbase.LovDropdown, 'LovDropdownSingle');

  LovDropdownSingle.prototype.init = function (options) {
    LovDropdownSingle.superclass.init.call(this, options);
  };

  /**
   * @memberof LovDropdownSingle
   * @instance
   * @private
   */
  LovDropdownSingle.prototype._createKeySetImpl = function (selectedValue) {
    if (selectedValue === null || selectedValue === undefined) {
      return new ojkeyset.KeySetImpl([]);
    }
    return new ojkeyset.KeySetImpl([selectedValue]);
  };

  /**
   * @memberof LovDropdownSingle
   * @instance
   * @protected
   * @override
   */
  LovDropdownSingle.prototype._ConfigureResultsInitial = function (selectedValue, busyContext) {
    // If it is the initial fetch, set both selection and currentRow, because both were cleared
    // initially.

    // if there is a selected value, then the collection would have
    // filtered the data using the display text initially. Set the current row only if the
    // fetched data is not empty.
    // TODO: Implement a better way to determine if the selectedValue is present in
    //       the fetched data.
    if (!this._isValueForPlaceholderFunc(selectedValue)) {
      this._SetCollectionCurrentRow({ rowKey: selectedValue });
      var selectedKeySet = this._createKeySetImpl(selectedValue);
      this._SetCollectionSelectedKeySet(selectedKeySet);
      return busyContext.whenReady();
    }
    if (!this._fullScreenPopup) {
      // JET-38215 - SELECT SINGLE - KEYBOARD NAVIGATION FOR COLLECTION TEMPLATE USAGE
      // prepare for getting keyboard focus so that the first row of the table body will be focused
      // instead of the header
      return this._FetchFirstResultForKeyboardFocus();
    }
    return busyContext.whenReady();
  };

  /**
   * @memberof LovDropdownSingle
   * @instance
   * @protected
   * @override
   */
  LovDropdownSingle.prototype._ConfigureResultsNoSearchText = function (selectedValue, busyContext) {
    // If no search text is present, clear current row
    this._SetCollectionCurrentRow({ rowKey: null });
    var selectedKeySet = this._createKeySetImpl(selectedValue);
    this._SetCollectionSelectedKeySet(selectedKeySet);
    // Wait for the collection to be updated and resolve the operation
    if (!this._fullScreenPopup) {
      // JET-38215 - SELECT SINGLE - KEYBOARD NAVIGATION FOR COLLECTION TEMPLATE USAGE
      // prepare for getting keyboard focus so that the first row of the table body will be focused
      // instead of the header
      return this._FetchFirstResultForKeyboardFocus();
    }
    return busyContext.whenReady();
  };

  /**
   * @memberof LovDropdownSingle
   * @instance
   * @protected
   * @override
   */
  LovDropdownSingle.prototype._ConfigureResultsWithSearchText = function (
    selectedValue,
    busyContext
  ) {
    // If search text is present, the first option should be highlighted
    // TODO: This call modifies the fetchedDataCount in the dataProvider,
    //       should this be reset to the initial value? For now, the count is stored
    //       in the LovDropdown and can be retrieved by calling LovDropdown.prototype.getResultsCount
    //       method.
    return this._FetchFirstResult().then(
      function (data) {
        if (data == null) {
          this._SetCurrentFirstItem(null);
          this._ClearSelection();
          // Return the busy context promise
          return busyContext.whenReady();
        }

        // Set the current value item
        var rowKey = data.key;
        this._SetCurrentFirstItem(data);
        this._SetCollectionCurrentRow({ rowKey: rowKey });
        // During initial render the handlers will be short-circuited, so we
        // need to call selected separately
        var selectedKeySet = this._createKeySetImpl(selectedValue);
        this._SetCollectionSelectedKeySet(selectedKeySet);

        // Return the busy context promise
        return busyContext.whenReady();
      }.bind(this)
    );
  };

  /**
   * @memberof LovDropdownSingle
   * @instance
   * @protected
   * @override
   */
  LovDropdownSingle.prototype._HandleCollectionSelectedItemChanged = function (_valueItem, event) {
    // Do nothing if called during the initialization phase or when we're pushing changes due to the
    // collection receiving focus
    if (this._duringListViewInitialization || this._handlingCollectionFocusinOnce) {
      return;
    }

    var valueItem = !this._isValueItemForPlaceholderFunc(_valueItem) ? _valueItem : null;

    // keep context up to date
    this._collectionContext.selectedItem = valueItem;

    this._handleSelection(valueItem, event);
  };

  /**
   * @memberof LovDropdownSingle
   * @instance
   * @protected
   * @override
   */
  LovDropdownSingle.prototype._GetDefaultCollectionRendererSelectionMode = function () {
    return 'single';
  };

  /**
   * @ojcomponent oj.ojSelectSingle
   * @augments oj.ojSelectBase
   * @ojimportmembers oj.ojDisplayOptionsNoConverterValidatorHints
   * @since 8.0.0
   * @ojdisplayname Select (Single)
   * @ojshortdesc A select single is a dropdown list that supports single selection and search filtering.
   * @ojrole combobox
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "ItemMetadata"]}
   * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["KeySet"]}
   * @ojtsimport {module: "ojcommontypes", type: "AMD", importName: ["ojcommontypes"]}
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojSelectSingle<V, D> extends ojSelectBase<V, D, ojSelectSingleSettableProperties<V, D>>",
   *                genericParameters: [{"name": "V", "description": "Type of value of the component/key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojSelectSingleSettableProperties<V, D> extends ojSelectBaseSettableProperties<V, D>",
   *                for: "SettableProperties"
   *               }
   *              ]
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["labelHint", "placeholder", "required", "disabled", "virtualKeyboard"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data", "value"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-select'
   * @ojuxspecs ['select-single-item']
   *
   * @classdesc
   * <h3 id="selectSingleOverview-section">
   *   JET Select Single
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectSingleOverview-section"></a>
   * </h3>
   * <p>Description: JET Select Single provides support for single-select and search filtering.</p>
   *
   * <p>A JET Select Single can be created with the following markup.</p>
   *
   * <pre class="prettyprint"><code>
   * &lt;oj-select-single data="[[dataProvider]]">
   * &lt;/oj-select-single>
   * </code></pre>
   *
   * <h4>Data</h4>
   * <p>The only way to provide data to JET Select Single is through a
   * <a href="DataProvider.html">DataProvider</a>.  Using
   * <a href="oj.ojOption.html">&lt;oj-option></a> and
   * <a href="oj.ojOptgroup.html">&lt;oj-optgroup></a> child tags is not supported.  For cases with
   * a small set of fixed data, use an <a href="ArrayDataProvider.html">ArrayDataProvider</a>.</p>
   *
   * {@ojinclude "name":"selectComboDifferences"}
   *
   * {@ojinclude "name":"validationAndMessagingDoc"}
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * {@ojinclude "name":"migrationDoc"}
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Page Load</h4>
   * <p>If there is an initially selected value, setting the <a href="#valueItem">valueItem</a> attribute initially can improve page load performance because the element will not have to fetch the selected label from the data provider.</p>
   * <p>The dropdown data isn't fetched until the user opens the dropdown.</p>
   *
   * {@ojinclude "name":"selectCommon"}
   */
  // --------------------------------------------------- oj.ojSelectSingle Styling Start ------------------------------------------------------------
  // ---------------- oj-select-results ----------------------
  /**
   * Apply this class to the collection element (e.g. an &lt;oj-list-view>) in the collectionTemplate.
   * @ojstyleclass oj-select-results
   * @ojdisplayname Collection Element
   * @ojstyleselector oj-select-single oj-table, oj-select-single oj-list-view
   * @memberof oj.ojSelectSingle
   */
  /**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   * The form control style classes can be applied to the component, or an ancestor element. <br/>
   * When applied to an ancestor element, all form components that support the style classes will be affected.
   */
  // ---------------- oj-form-control max-width --------------
  /**
   * In the Redwood theme the default max width of a text field is 100%.
   * These max width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-max-width
   * @ojdisplayname Max Width
   * @ojstylesetitems ["form-control-max-width.oj-form-control-max-width-sm", "form-control-max-width.oj-form-control-max-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojSelectSingle
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-select-single class="oj-form-control-max-width-md">
   * &lt;/oj-select-single>
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-sm
   * @ojshortdesc Sets the max width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojSelectSingle
   */
  /**
   * @ojstyleclass form-control-max-width.oj-form-control-max-width-md
   * @ojshortdesc Sets the max width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojSelectSingle
   */

  // ---------------- oj-form-control width --------------
  /**
   * In the Redwood theme the default width of a text field is 100%.
   * These width convenience classes are available to create a medium or small field.<br>
   * The class is applied to the root element.
   * @ojstyleset form-control-width
   * @ojdisplayname Width
   * @ojstylesetitems ["form-control-width.oj-form-control-width-sm", "form-control-width.oj-form-control-width-md"]
   * @ojstylerelation exclusive
   * @memberof oj.ojSelectSingle
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-select-single class="oj-form-control-width-md">
   * &lt;/oj-select-single>
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-sm
   * @ojshortdesc Sets the width for a small field
   * @ojdisplayname Small
   * @memberof! oj.ojSelectSingle
   */
  /**
   * @ojstyleclass form-control-width.oj-form-control-width-md
   * @ojshortdesc Sets the width for a medium field
   * @ojdisplayname Medium
   * @memberof! oj.ojSelectSingle
   */
  // ---------------- oj-form-control-text-align- --------------
  /**
   * Classes that help align text of the element.
   * @ojstyleset text-align
   * @ojdisplayname Text Alignment
   * @ojstylesetitems ["text-align.oj-form-control-text-align-right", "text-align.oj-form-control-text-align-start", "text-align.oj-form-control-text-align-end"]
   * @ojstylerelation exclusive
   * @memberof oj.ojSelectSingle
   * @ojtsexample
   * &lt;oj-select-single class="oj-form-control-text-align-right">
   * &lt;/oj-select-single>
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-right
   * @ojshortdesc Aligns the text to the right regardless of the reading direction. This is normally used for right aligning numbers.
   * @ojdisplayname oj-form-control-text-align-start
   * @memberof! oj.ojSelectSingle
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-start
   * @ojshortdesc Aligns the text to the left in LTR and to the right in RTL.
   * @ojdisplayname oj-form-control-text-align-start
   * @memberof! oj.ojSelectSingle
   */
  /**
   * @ojstyleclass text-align.oj-form-control-text-align-end
   * @ojshortdesc Aligns the text to the right in LTR and to the left in RTL.
   * @ojdisplayname oj-form-control-text-align-end
   * @memberof! oj.ojSelectSingle
   */
  // --------------------------------------------------- oj.ojSelectSingle Styling end ------------------------------------------------------------

  /**
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET element, in the unusual case that the directionality (LTR or RTL) changes post-init, the Select must be <code class="prettyprint">refresh()</code>ed.</p>
   *
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p>
   * The element will decorate its associated label with required and help
   * information, if the <code>required</code> and <code>help</code> attributes are set.
   * </p>
   * <p>
   * {@ojinclude "name":"accessibilityLabelEditableValue"}
   * {@ojinclude "name":"accessibilityPlaceholderEditableValue"}
   * {@ojinclude "name":"accessibilityDisabledEditableValue"}
   * </p>
   *
   * @ojfragment selectCommon
   * @memberof oj.ojSelectSingle
   */
  /**
   * <h3 id="diff-section">
   *   Differences between Select and Combobox components
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#diff-section"></a>
   * </h3>
   *
   * <p>
   * oj-select-* components and oj-combobox-* components may look and feel similar,
   * but these components are different and are intended for very different use cases.
   * </p>
   *
   * <p>
   * While oj-select-* components allow one to filter the data in the dropdown,
   * it is not possible to enter values that are not available in the data.
   * This makes oj-select-* components ideal for usecases where the user can only
   * select values that are available in the dropdown, but not provide custom
   * values of their own.
   * </p>
   *
   * <p>
   * In contrast, oj-combobox-* components allow one to enter new values that are
   * not available in the data in addition to using the text field for filtering dropdown data.
   * This makes oj-combobox-* components ideal for usecases where the users can provide
   * custom values in addition to those that are already available in the dropdown data.
   * </p>
   *
   * <p>
   * Application developers should consider the above differences when choosing between
   * Select and Combobox components.
   * Additionally, applications are advised to use oj-select-single instead of the deprecated oj-select-one.
   * </p>
   *
   * @ojfragment selectComboDifferences
   * @memberof oj.ojSelectSingle
   */
  oj.__registerWidget('oj.ojSelectSingle', $.oj.ojSelectBase, {
    options: {
      /**
       * The <code class="prettyprint">valueItem</code> is similar to the
       * <code class="prettyprint">value</code>, but is a
       * <a href="ojcommontypes.html#ItemContext">ItemContext&lt;V, D></a> object which
       * contains both a key and data, and optional metadata.
       * The key will be set as the <code class="prettyprint">value</code> of the element.
       * The <code class="prettyprint">value</code> and <code class="prettyprint">valueItem</code>
       * are kept in sync, both during programmatic property sets as well as during interactive user
       * selection.
       * If initially both are set, the selected value in the <code class="prettyprint">value</code>
       * attribute has precedence.
       * <p>Note: If there is an initial selection, setting it via the
       * <code class="prettyprint">valueItem</code> attribute initially can improve page load
       * performance because the element will not have to fetch the selected data from the data
       * provider.</p>
       * <p>If <code class="prettyprint">valueItem</code> is not specified or the selected value is
       * missing, then the selected data will be fetched from the data provider.</p>
       *
       * @name valueItem
       * @ojshortdesc The current value of the element and its associated data.
       * @expose
       * @instance
       * @type {null | Object}
       * @ojsignature {target:"Type", value:"ojcommontypes.ItemContext<V,D>", jsdocOverride:true}
       * @default { key: null, data: null, metadata: null }
       * @ojwriteback
       *
       * @memberof oj.ojSelectSingle
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">value-item</code> attribute specified:</caption>
       * &lt;oj-select-single value-item="[[valueItem]]">&lt;/oj-select-single>
       *
       * @example <caption>Object with key and data properties:</caption>
       * var valueItem = {'key': 'val1', 'data': {'value': 'val1', 'label': 'Label 1'}};
       *
       * @example <caption>Get or set the <code class="prettyprint">valueItem</code> property after initialization:</caption>
       * // getter
       * var valueItem = mySelect.valueItem;
       *
       * // setter
       * mySelect.valueItem = valueItem;
       */
      valueItem: { key: null, data: null, metadata: null }

      /**
       * The value of the element. The type must be the same as the type of keys in the data provider.
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">value</code> attribute specified:</caption>
       * &lt;oj-select-single value="option1">&lt;/oj-select-single>
       *
       * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
       * // getter
       * var value = mySelect.value;
       *
       * // setter
       * mySelect.value = "option1";
       *
       * @member
       * @name value
       * @ojshortdesc The value of the element.
       * @access public
       * @instance
       * @memberof oj.ojSelectSingle
       * @type {null | any}
       * @ojsignature {target: "Type",
       *               value: "V | null",
       *               genericParameters: [{"name": "V", "description": "Key in Data Provider"}],
       *               jsdocOverride: true}
       * @ojwriteback
       * @ojeventgroup common
       */

      /**
       * Triggered when a value is submitted by the user, even if the value is the same as the
       * previous value.
       * Submission is triggered by selecting a value from the dropdown using the keyboard, mouse,
       * or a touch gesture.  Note that the <a href="#value">value</a> property is guaranteed to be
       * up-to-date at the time the ojValueAction event is dispatched.
       *
       * @expose
       * @event
       * @name valueAction
       * @memberof oj.ojSelectSingle
       * @since 10.0.0
       * @instance
       * @ojshortdesc Event triggered when a value is submitted by the user, even if the value
       *   hasn't changed.
       * @property {any | null} value The selected value.
       * @property {Object} itemContext The data provider context for the value.
       * @property {any | null} previousValue The previous selected value.
       * @ojsignature [
       *   {target: "Type", value:"<V, D>", for:"genericTypeParameters" },
       *   {target: "Type", value: "V | null", for: "value"},
       *   {target: "Type", value: "V | null", for: "previousValue"},
       *   {target: "Type", value: "ojcommontypes.ItemContext<V, D>", for: "itemContext"}
       * ]
       */
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _ComponentCreate: function () {
      this._super();

      // JET-44210 - throw an error when a value-item is set externally that contains the key
      // but not the data
      var valueItem = this.options.valueItem;
      if (!this._IsValueItemForPlaceholder(valueItem) && valueItem.data == null) {
        throw new Error('Select Single: value-item contains key but no data');
      }

      this._cssOptionDefaults =
        ThemeUtils.parseJSONFromFontFamily('oj-searchselect-option-defaults') || {};

      this._defaultValueForPlaceholder = null;
      this._defaultValueItemForPlaceholder = { key: null, data: null, metadata: null };

      this._SetupSelectResources();
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _AfterCreate: function () {
      this._super();

      // need to apply the oj-focus marker selector for control of the floating label.
      var rootElement = this._getRootElement();
      this._focusable({
        element: rootElement,
        applyHighlight: false,
        afterToggle: this._HandleAfterFocusToggle.bind(this, rootElement)
      });

      // If labelEdge is set to none, aria-label would have been set to the root element
      // so, we need to update the aria-label elsewhere
      if (this.options.labelEdge === 'none') {
        this._updateLabel();
      }
    },

    /**
     * @protected
     * @override
     * @instance
     * @memberof! oj.ojSelectSingle
     */
    _GetTranslationsSectionName: function () {
      return 'oj-ojSelectSingle';
    },

    /**
     * Sets up resources for select single
     *
     * @param {HTMLElement=} cachedMainFieldInputElem An optional HTML input element to be
     *                                                used for main field element
     *
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _SetupSelectResources: function (cachedMainFieldInputElem) {
      this._resolveValueItemLater = false;

      this._super(cachedMainFieldInputElem);
    },

    /**
     * Releases the resources created for select single
     *
     * @param {boolean} shouldRetainMainFieldElem A flag to indicate if the main field
     *                                            element should be reatined
     *
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _ReleaseSelectResources: function (shouldRetainMainFieldElem) {
      this._bReleasingSelectResources = true;

      this._super(shouldRetainMainFieldElem);

      this._bReleasingSelectResources = false;
    },

    /**
     * Handles selection for select-single. If the data is not present, it is fetched and
     * then the selection is made
     *
     * @param {Object} valueItem
     * @param {CustomEvent} event
     *
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _fetchDataAndSelect: function (valueItem, event, skipShowingFilterField) {
      // Check if the data has to be fetched
      if (valueItem.data != null) {
        // Make selection if data exists
        this._handleSelection(valueItem, event, skipShowingFilterField);
      } else {
        // Fetch the data using the key
        var keys = [valueItem.key];
        var failedFetch = function () {
          this._handleSelection(this._defaultValueItemForPlaceholder, null, skipShowingFilterField);
        }.bind(this);
        var afterFetch = function (fetchResults) {
          // Check if the data is available for the provided key
          if (fetchResults.data.length > 0) {
            var _valueItem = {};
            _valueItem.key = valueItem.key;
            _valueItem.data = fetchResults.data[0];
            _valueItem.metadata = fetchResults.metadata[0];

            this._handleSelection(_valueItem, event, skipShowingFilterField);
          } else {
            failedFetch();
          }
        }.bind(this);

        this._FetchByKeysFromDataProvider(keys).then(afterFetch, failedFetch);
      }
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleClearValueIconClick: function () {
      // TODO: After selecting a new value, then clearing it, and then opening the dropdown again,
      // I can't select the same value.  It gets highlighted, but doesn't close the dropdown and
      // doesn't get set as the component value.  It looks like we're not getting a
      // firstSelectedItemChanged event from listView in that case.  I think the firstSelectedItem
      // is still for the last selected value, even though we've cleared it and set the listView
      // selected attribute to an empty KeySetImpl.
      // (Filed JET-33592 - FIRST-SELECTED-ITEM-CHANGED NOT FIRED AFTER CLEARING AND SELECTING
      // SAME ITEM against listView.)
      // (This may not be a bug after listView implements JET-32345 - COLLECTION ENHANCEMENTS FOR
      // LOV USECASE.)
      this._handleSelection(this._GetDefaultValueItemForPlaceholder());
    },

    /**
     * Called when the filter field is blurred.
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleFilterFieldBlur: function () {
      // JET-65757 - Empty value rejected when not confirmed by Enter/Tab
      // clear the value after deleting all the filter text and clicking outside the
      // component;
      // check whether placeholder valueItem is already set so that we don't trigger
      // validation unnecessarily
      if (
        !this._fullScreenPopup &&
        !this._bReleasingSelectResources &&
        this._IsFilterInputTextCleared()
      ) {
        if (
          !this._IsValueForPlaceholder(this.options.value) ||
          !this._IsValueItemForPlaceholder(this.options.valueItem)
        ) {
          // on desktop, if the user clears all the text and clicks out, clear the LOV value
          this._handleSelection(this._defaultValueItemForPlaceholder, null, true);
        }
      }
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _handleSelection: function (valueItem, event, skipShowingFilterField) {
      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      var resolveValueChangeFunc = this._StartMakingInternalValueChange();

      var context;

      // if (!this._fullScreenPopup) {
      //   this._showMainField();
      // }

      // When there is validation error, the value option may retain the previous value
      // although the display value is different. In that case, user should be able to still
      // select the previous valid value to get rid off the invalid style and message.
      /* if (!(old === LovUtils.getOptionValue(data)))*/
      var newValueItem = this._IsValueItemForPlaceholder(valueItem)
        ? this._defaultValueItemForPlaceholder
        : valueItem;

      var configureInputFieldsFunc = function () {
        // JET-46874 - Select single busy state not cleared properly causing spectra test to fail
        // don't try to do anything other than resolve the busy state if the component has been
        // removed from the DOM
        if (!this._bReleasedResources) {
          if (!event || event.type !== 'blur') {
            // this._lovMainField.focusCursorEndInputElem();
            var inputElem = this._lovMainField.getInputElem();
            if (!this._fullScreenPopup) {
              if (this._IsValueItemForPlaceholder(newValueItem)) {
                inputElem.value = '';
              }
              this._SetFilterFieldText(inputElem.value);
              // JET-44746 - focus pulled back again after pressing Tab with DelayingDataProvider
              // only show the filter field if the component should still have focus
              if (!skipShowingFilterField) {
                // show the filter field after selecting an item on desktop because we want the focus
                // to go back to the main part of the component, and the user can tab out or reopen
                // the dropdown or filter again
                this._ShowFilterField();
              }
            } else {
              // focus the input element after selecting an item on mobile because we want the focus
              // to go back to the main part of the component, and the user can tab out or reopen the
              // dropdown
              inputElem.focus();
            }
          }

          this._CloseDropdown();
        }

        resolveValueChangeFunc();
      }.bind(this);

      var afterHandleFunc = function () {
        // JET-46567 - JAWS is reading out error message even after selecting correct value
        // wait until after the inline messages DOM has been updated before finishing processing
        // so that when we change focus to the input element the screen reader will read out the
        // new messages/invalid state instead of old state
        if (this._messagingStrategyQueueActionPromise) {
          this._messagingStrategyQueueActionPromise.then(
            configureInputFieldsFunc,
            configureInputFieldsFunc
          );
        } else {
          configureInputFieldsFunc();
        }
      }.bind(this);

      this._handleUserSelectedValueItem(newValueItem, event, context).then(
        afterHandleFunc,
        afterHandleFunc
      );
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _handleUserSelectedValueItem: function (valueItem, event, context) {
      var previousValue = this.options.value;
      var abstractLovBase = this._abstractLovBase;
      //  - selected value got replaced once the label for initial value is available
      if (this._cachedFetchByKeys) {
        this._valueHasChanged = true;
        // remove loading indicator
        this._setUiLoadingState('stop');
      }

      this._resolveValueItemLater = true;

      var value = null;
      if (!this._IsValueItemForPlaceholder(valueItem)) {
        value = valueItem.key;
      }

      // need to set value on AbstractLovBase first because it needs to be up-to-date within
      // call to _SetValue in order to update display label
      abstractLovBase.setValue(value);

      // temporarily store valueItem so that we can set it from within _SetValue call instead of
      // having to call fetchByKeys on the data provider
      this._userSelectedValueItem = valueItem;
      //  - select needs implementation fixes...
      var ret = this._SetValue(value, event, { doValueChangeCheck: false, _context: context });
      var afterSetValue = function (valueSet) {
        // After the _SetValue call is completed, clear the
        // user selected value item
        this._userSelectedValueItem = null;

        // JET-36443 - fire an ojValueAction event whenever the user selects a value, even if the
        // value is the same as the previous value
        if (valueSet) {
          this._fireValueActionEvent(valueItem, previousValue);
        }

        // Resolve the fetchDataAndSelect promise if it exists
        // This is used by the WebElement APIs
        if (this._resolveFetchDataAndSelectPromise) {
          this._resolveFetchDataAndSelectPromise();
          this._resolveFetchDataAndSelectPromise = null;
        }
      }.bind(this);

      if (ret instanceof Promise) {
        return ret.then(afterSetValue, function () {
          afterSetValue(false);
        });
      }

      var afterFunc = function () {
        afterSetValue(ret);
      };
      return Promise.resolve().then(afterFunc, afterFunc);
    },

    /**
     * Updates display value of Select.
     * @override
     * @protected
     * @memberof! oj.ojSelectSingle
     */
    _SetDisplayValue: function (displayValue) {
      // JET-37550 - REGRESSION : OJ-SELECT-SINGLE NOT DISPLAYING DEFAULT VALUE
      // if setting both data and value at the same time, defer setting the value until after the
      // data has been set
      if (this._deferSettingValue) {
        return;
      }

      // JET-34351 - OJ-SELECT-SINGLE DOES NOT SHOW VALUE IF OPTIONS ARE UPDATED ASYNC
      // while calling superclass refresh, defer handling any _SetDisplayValue calls until after
      // we've setup again
      if (this._bSuperRefreshing) {
        this._deferredSetDisplayValue = function () {
          this._deferredSetDisplayValue = null;
          this._SetDisplayValue(displayValue);
        }.bind(this);
        return;
      }

      //  - need to be able to specify the initial value of select components bound to dprv
      if (!this._applyValueItem(this.options.valueItem)) {
        this._initSelectedValue();
      }
      this._resolveValueItemLater = false;
    },

    /**
     * @override
     * @protected
     * @memberof! oj.ojSelectSingle
     */
    _ValidateHelper: function () {
      // JET-40458 - ISSUES WITH OJ-SELECT-SINGLE INSIDE A EDITABLE TABLE
      // maintain flag so we know we're validating from within _SetValue
      this._isInValidate = true;

      var displayValueForSetValue = $(this._lovMainField.getInputElem()).val();

      // returns Promise that resolves to true|false or boolean
      var returnValue = this._SetValue(displayValueForSetValue, null, this._VALIDATE_METHOD_OPTIONS);

      if (returnValue === false && !this._CanSetValue()) {
        // FIX JET-45885, validate() returns 'invalid' for readonly or disabled on valid value.
        // In _SetValue/_AsyncValidate, validation is skipped when !this._CanSetValue(), and _SetValue returns false.
        // We want validate() to return 'valid' when validation is skipped.
        returnValue = true;
      }

      if (!(returnValue instanceof Promise)) {
        returnValue = Promise.resolve(returnValue ? 'valid' : 'invalid');
      } else {
        returnValue = returnValue.then(function (booleanSetValueReturn) {
          return Promise.resolve(booleanSetValueReturn ? 'valid' : 'invalid');
        });
      }

      this._isInValidate = false;

      return returnValue;
    },

    /**
     * @override
     * @protected
     * @memberof! oj.ojSelectSingle
     */
    _SetValue: function (newValue, event, options) {
      var displayValue = this._GetDisplayValue();
      if (newValue === displayValue) {
        if (this._isInValidate && newValue === '' && !this.isValid()) {
          // JET-40458 - ISSUES WITH OJ-SELECT-SINGLE INSIDE A EDITABLE TABLE
          // if we're validating a cleared field and we're already in an invalid state, then we need
          // to attempt to set a null value instead of whatever the existing value is, because the
          // existing value may be valid
          // eslint-disable-next-line no-param-reassign
          newValue = null;
        } else {
          // we don't want to set the displayValue as the value, so if the newValue being set matches
          // the displayValue, use the currently set value instead
          // eslint-disable-next-line no-param-reassign
          newValue = this.options.value;
        }

        // JET-35455 - OJ-SELECT-SINGLE NOT SHOWING VISUAL ERROR STATE AFTER ITS VALIDATE() METHOD
        // RETURNS INVALID DETERMINATION
        // EditableValue always returns 'invalid' when validating a value of undefined, but the
        // error message doesn't get shown for a required LOV with no initial value, so make sure
        // we set null instead of undefined.
        if (newValue === undefined) {
          // eslint-disable-next-line no-param-reassign
          newValue = null;
        }
      }

      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      var resolveValueChangeFunc = this._StartMakingInternalValueChange();

      var ret = this._super(newValue, event, options);

      resolveValueChangeFunc();

      return ret;
    },

    /**
     * Returns the default styleclass for the component.
     *
     * @return {string}
     * @expose
     * @memberof! oj.ojSelectSingle
     * @override
     * @protected
     */
    _GetDefaultStyleClass: function () {
      return 'oj-searchselect';
    },

    /**
     * Returns the name of the component to be used in a style class.
     *
     * @return {string}
     * @memberof! oj.ojSelectSingle
     * @override
     * @protected
     */
    _GetStyleClassComponentName: function () {
      return 'selectsingle';
    },

    /**
     * merge value and valueItem, value wins if both are specified
     * return true if the value is specified and it's not contained in valueItem
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _mergeValueAndValueItem: function (value, valueItem) {
      var resolveLater = false;

      // value specified
      if (!this._IsValueForPlaceholder(value)) {
        // both value and valueItem specified, find the option for the value
        if (valueItem) {
          // may need to find out the label and setValueItem later
          resolveLater = !oj.Object.compareValues(value, valueItem.key);
        }
      } else if (valueItem && !this._deferSettingValue) {
        // JET-38612 - Select Single | Value, disable bug
        // if the value is not specified, and we have a value item, and we are not deferring setting
        // a new value, then sync the value with the value item
        // JET-43200 - initializing select-single with both value-item and messages-custom does
        // not render the messages
        // don't clear custom-messages when set initially with value-item
        this._SyncValueWithValueItem(valueItem, value, { doNotClearMessages: true });
      }

      return resolveLater;
    },

    /**
     * single selection: keep value in sync with valueItem
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _SyncValueWithValueItem: function (valueItem, value, context) {
      var abstractLovBase = this._abstractLovBase;

      var newVal;
      //  - resetting value when value-item and placeholder are set throws exception
      if (this._IsValueItemForPlaceholder(valueItem)) {
        if (this._IsValueForPlaceholder(value)) {
          newVal = value;
        } else {
          newVal = this._defaultValueForPlaceholder;
        }
      } else {
        newVal = valueItem ? valueItem.key : null;
      }

      if (!oj.Object.compareValues(newVal, value)) {
        // JET-42413: set flag while we're processing a value change so that if an app makes
        // changes to the component from within the change listener, we can defer processing the
        // new change until after we're done processing the current change
        var resolveValueChangeFunc = this._StartMakingInternalValueChange();

        var flagsContext = { internalSet: true, writeback: true };
        // JET-43200 - initializing select-single with both value-item and messages-custom does
        // not render the messages
        // don't clear custom-messages when set initially with value-item
        if (context) {
          Object.assign(flagsContext, context);
        }
        var flags = {
          doValueChangeCheck: false,
          _context: flagsContext
        };
        this.option('value', newVal, flags);

        abstractLovBase.setValue(newVal);
        // When internalSet is true _setOption->_AfterSetOptionValue->_Refresh isn't called.
        // We still need the displayValue to be refreshed, so call this._AfterSetOptionValue
        // explicitly.
        this._AfterSetOptionValue('value', flags);

        resolveValueChangeFunc();
      }
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _initSelectedValue: function (valueItem) {
      //  - need to be able to specify the initial value of select components bound to dprv
      // Even when _deferSettingValue is true, we're not short-circuiting in this method if either:
      // - we have a complete value-item, or
      // - the value represents the placeholder
      // because in those cases we can process setting the value without having to fetch from the
      // data provider.
      if (!this._applyValueItem(valueItem)) {
        var value = !this._IsValueItemForPlaceholder(valueItem) ? valueItem.key : this.options.value;
        // JET-37550 - REGRESSION : OJ-SELECT-SINGLE NOT DISPLAYING DEFAULT VALUE
        // if setting both data and value at the same time, defer setting a non-placeholder value
        // until after the data has been set
        var isPlaceholderValue = this._IsValueForPlaceholder(value);
        if (isPlaceholderValue || !this._deferSettingValue) {
          this._initSelectionHelper(value, this._updateSelectedOption.bind(this), valueItem);
        }
      }
    },

    /**
     *  - need to be able to specify the initial value of select components bound to dprv
     * If both dataProvider and valueItem[s] are specified, use valueItem[s] for display values.
     * If valueItem[s] is not specified or a selected value is missing then we will fetch the real
     * data from the dataProvider like before.
     * return true if valueItem[s] is applied, false otherwise
     *
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _applyValueItem: function (valueItem) {
      //  - resetting value when value-item and placeholder are set throws exception
      //  - placeholder is not displayed after removing selections from select many
      if (!this._resolveValueItemLater && !this._IsValueItemForPlaceholder(valueItem)) {
        this._updateInputElemValue(valueItem);
        return true;
      }
      return false;
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _updateSelectedOption: function (valueItem) {
      this._updateInputElemValue(valueItem);
      //  - need to be able to specify the initial value of select components bound
      // to dprv
      this._SetValueItem(valueItem);
    },

    //  - need to be able to specify the initial value of select components bound to dprv
    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _SetValueItem: function (valueItem) {
      this._valueItemSetInternally = true;
      var newValueItem = valueItem;
      //  - resetting value when value-item and placeholder are set throws exception
      if (valueItem && !this._IsValueItemForPlaceholder(valueItem)) {
        newValueItem = ojselectbase.LovUtils.createValueItem(valueItem.key, valueItem.data, valueItem.metadata);
      }
      var context = { internalSet: true, changed: true, writeback: true };

      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      var resolveValueChangeFunc = this._StartMakingInternalValueChange();

      this.option(this._GetValueItemPropertyName(), newValueItem, { _context: context });

      resolveValueChangeFunc();
    },

    /**
     * update display label(s) and valueItem(s) after value was set
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _UpdateValueItem: function (value) {
      // TODO: does value need to be normalized?
      // var value = LovUtils.normalizeValue(_value);
      this._initSelectionHelper(
        value,
        function (valueItem) {
          this._SetValueItem(valueItem);
          this._updateSelectedOption(valueItem);
        }.bind(this)
      );
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _updateInputElemValue: function (valueItem) {
      var $inputElem = $(this._lovMainField.getInputElem());
      var text = null;
      if (valueItem && valueItem.data) {
        var formatted = this._ItemTextRenderer(valueItem);
        var inputElemText = $inputElem.val();
        if (formatted !== undefined && inputElemText !== formatted) {
          text = formatted;
        }
      } else {
        // data will be null only when user set it programmatically.
        text = '';
      }
      if (text !== null) {
        $inputElem.val(text);
        // keep readonly div's content in sync
        if (this.options.readOnly) {
          let readonlyElem = this._getReadonlyDiv();
          if (readonlyElem) {
            readonlyElem.textContent = text;
          }
        }
        // JET-37621 - DYNAMIC FORM - SELECT SINGLE COMPONENT DOESN'T REFLECT THE VALUE UNTIL USER
        // CLICKS OUTSIDE THE FORM
        // if the filter field is visible, update its text, too...
        // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
        // ...unless the user has already typed some filter text
        if (
          ((!this._fullScreenPopup && this._filterInputText.style.visibility !== 'hidden') ||
            (this._fullScreenPopup && this._abstractLovBase.isDropdownOpen())) &&
          !this._userHasTypedFilterText
        ) {
          this._SetFilterFieldText(text);
        }
      }
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _UpdateItemText: function () {
      this._super();

      // JET-45922 - timing issue with select-single: lov drop-down doesn't have element
      // do a granular update if item-text changes instead of a general refresh
      var currValueItem = this.options.valueItem;
      this._updateInputElemValue(currValueItem);
    },

    // install default initSelection when applied to hidden input
    // and getting data from remote
    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _initSelectionHelper: function (value, initSelectionCallback, valueItem) {
      // ojselect set initial selected value
      if (this._IsValueForPlaceholder(value)) {
        // JET-45563 - Value item change listener is triggering on load while setting up initially
        // if the value-item is initialized with an object equivalent to the default placeholder
        // value-item, then use the given object so that no valueItemChanged event is fired
        var placeholderValueItem =
          valueItem && oj.Object.compareValues(valueItem, this._defaultValueItemForPlaceholder)
            ? valueItem
            : this._defaultValueItemForPlaceholder;
        initSelectionCallback(placeholderValueItem);
      } else if (this._abstractLovBase.hasData()) {
        // if user has selected a new value in the UI, use the saved valueItem instead of calling
        // fetchByKeys on the data provider
        if (this._userSelectedValueItem) {
          var userSelectedValueItem = this._userSelectedValueItem;
          this._initSelectionFetchByKey(
            {
              data: [userSelectedValueItem.data],
              metadata: [userSelectedValueItem.metadata]
            },
            value,
            initSelectionCallback
          );
        } else if (this.options.data) {
          // JET-34351 - OJ-SELECT-SINGLE DOES NOT SHOW VALUE IF OPTIONS ARE UPDATED ASYNC
          // if we were showing the loading indicator while waiting for data to be set, stop
          // showing it now
          if (this._loadingAwaitingData) {
            this._loadingAwaitingData = false;
            this._setUiLoadingState('stop');
          }
          // JET-34351 - OJ-SELECT-SINGLE DOES NOT SHOW VALUE IF OPTIONS ARE UPDATED ASYNC
          // only init selected value if options.data not null, otherwise the valueItem may
          // get set containing only the key, which means no label will be shown in the field
          this._FetchByKeysFromDataProvider([value]).then(
            function (fetchResults) {
              // JET-34713 Error updating array dataprovider of ojSelectSingle while its hidden
              // Abort if select single has been disconnected
              if (!this._bReleasedResources) {
                this._initSelectionFetchByKey(fetchResults, value, initSelectionCallback);
              }
            }.bind(this),
            function () {
              if (!this._bReleasedResources) {
                this._initSelectionFetchByKey(null, value, initSelectionCallback);
              }
            }.bind(this)
          );
        } else if (!this._loadingAwaitingData) {
          // JET-34351 - OJ-SELECT-SINGLE DOES NOT SHOW VALUE IF OPTIONS ARE UPDATED ASYNC
          // if we can't fetch right now because we're waiting for data to be set, show the
          // loading indicator
          this._loadingAwaitingData = true;
          this._setUiLoadingState('start');
        }
      }
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _initSelectionFetchByKey: function (fetchResults, value, initSelectionCallback) {
      //  - While fetching the label for the initial value,
      // user can still interact the component and pick a new value.
      if (oj.Object.compareValues(value, this.options.value) && !this._valueHasChanged) {
        var data = null;
        var metadata = null;
        if (fetchResults && fetchResults.data && fetchResults.data.length > 0) {
          data = fetchResults.data[0];
          metadata = fetchResults.metadata[0];
        } else {
          Logger.warn('SelectSingle: could not fetch data for selected value: ' + value);
        }
        initSelectionCallback(ojselectbase.LovUtils.createValueItem(value, data, metadata));
        this._valueHasChanged = undefined;
      }
    },

    /**
     * Fire an ojValueAction event.
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _fireValueActionEvent: function (valueItem, previousValue) {
      var detail = {
        value: valueItem.key,
        itemContext: valueItem,
        previousValue: previousValue
      };

      var valueActionEvent = new CustomEvent('ojValueAction', { detail: detail });

      var element = this.OuterWrapper;

      // JET-42413: set flag while we're processing a value change so that if an app makes
      // changes to the component from within the change listener, we can defer processing the
      // new change until after we're done processing the current change
      var resolveValueChangeFunc = this._StartMakingInternalValueChange();

      element.dispatchEvent(valueActionEvent);

      resolveValueChangeFunc();
    },

    // Private methods used by WebElement
    /**
     * This method imitates an option selection from the dropdown by using a key of an item
     * from the options. This is used by the WebElement implementation of ojSelectSingle
     *
     * @param {V} value The value that has to be selected
     * @param {Event} event
     *
     * @return {Promise} A Promise that resolve once the operation is completed
     *
     * @memberof! oj.ojSelectSingle
     * @instance
     * @private
     */
    _selectItemByValue: function (value, event) {
      const fetchDataAndSelectPromise = new Promise(
        function (resolve) {
          this._resolveFetchDataAndSelectPromise = resolve;
        }.bind(this)
      );

      if (value != null) {
        const valueItem = { key: value };
        this._fetchDataAndSelect(valueItem, event);
      } else {
        this._handleSelection(this._defaultValueItemForPlaceholder);
      }

      return fetchDataAndSelectPromise;
    },

    /**
     * Handle data provider events
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleDataProviderEvent: function (event) {
      if (event.filterCriterionChanged) {
        return;
      }

      var newVal = this.options.value;
      var origVal = this.options.value;
      if (event.type === 'mutate') {
        if (event.detail.remove != null) {
          var keys = event.detail.remove.keys;

          keys.forEach(
            function (key) {
              if (oj.Object.compareValues(key, newVal)) {
                newVal = this._defaultValueForPlaceholder;
                Logger.warn('Select: selected value removed from data provider');
              }
            }.bind(this)
          );
        }
      }

      var resolveBusyState = this._AddBusyState('ojSelectSingle processing DataProvider event');

      // JET-64632 - DataProvider refresh event can wipe out currently selected value
      // defer handling the event until the throttle promise (which is hooked into JET's Knockout
      // throttling timeout) resolves so that we can correctly handle the case where we get both a
      // new value set and a DP event
      var throttlePromise = this._GetThrottlePromise();
      throttlePromise.then(
        function () {
          // if the component was released before the promise resolved, simply resolve the busy
          // state and return
          if (this._bReleasedResources) {
            resolveBusyState();
            return;
          }

          // if the event wasn't dispatched internally, and if the value has not been changed since
          // the event was received, need to re-set the value now that the label may be available,
          // or because a mutation event removed a selected value
          if (origVal === this.options.value) {
            // JET-42413: set flag while we're processing a value change so that if an app makes
            // changes to the component from within the change listener, we can defer processing the
            // new change until after we're done processing the current change
            var resolveValueChangeFunc = this._StartMakingInternalValueChange();

            this._setOption('value', newVal);

            resolveValueChangeFunc();
          }

          this._abstractLovBase.handleDataProviderEvent(event);

          resolveBusyState();
        }.bind(this)
      );
    },

    /**
     * Handle Enter key down on the container.
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleContainerKeyDownEnter: function (event) {
      // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
      // clear flag that the user has typed filter text so that we can override it when setting
      // the selected label
      this._userHasTypedFilterText = false;

      // on desktop, if the user clears all the text and presses Enter, clear the LOV value
      if (!this._fullScreenPopup && this._IsFilterInputTextCleared()) {
        this._handleSelection(this._defaultValueItemForPlaceholder);
      } else if (!this._fullScreenPopup && this._abstractLovBase.isDropdownOpen()) {
        // on the desktop if there is text in the input field and there is a selected item in the
        // dropdown and the user presses Enter, set that as the value

        // don't call lovDropdown.getValueItemForSelection() to get the currentSelectedItem until
        // after the dropdown has been initialized
        var currentSelectedItem = this._lovDropdown.getValueItemForSelection();
        if (currentSelectedItem != null) {
          this._fetchDataAndSelect(currentSelectedItem, event);
        }
      }
    },

    /**
     * Handle Tab key down on the container.
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleContainerKeyDownTab: function (event) {
      // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
      // clear flag that the user has typed filter text so that we can override it when setting
      // the selected label
      this._userHasTypedFilterText = false;

      if (!this._fullScreenPopup) {
        if (event.shiftKey) {
          var filterInputText = this._filterInputText;
          var parentElem = filterInputText.parentNode;

          // As discussed in JET-49016, the appendChild calls below end up being
          // short-circuited by our Preact slot management workarounds.  As a
          // result, the appendChild calls are treated as no-ops and we end up in an
          // infinite while loop.  To avoid this fate, we temporarily disable the slot
          // management workarounds.
          ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(true);

          try {
            // move all the siblings before the filterInputText to the end, so that focus won't go
            // to the main input field and will instead go to the previous tabbable elem on the page
            // (can't just move the filterInputText because it's involved in the focus change and
            // the browser throws an error)
            while (parentElem.firstChild !== filterInputText) {
              parentElem.appendChild(parentElem.firstChild);
            }
          } finally {
            ojcustomelementUtils.CustomElementUtils.allowSlotRelocation(false);
          }
        }
        // JET-44700 - <OJ-SELECT-SINGLE> AND <OJ-INPUT-NUMBER/DATE/TEXT> ARE NOT BEHAVING
        // UNIFORMLY FOR REQUIRED FIELDS
        // check whether placeholder valueItem is already set so that we don't trigger
        // validation unnecessarily
        if (this._IsFilterInputTextCleared()) {
          if (
            !this._IsValueForPlaceholder(this.options.value) ||
            !this._IsValueItemForPlaceholder(this.options.valueItem)
          ) {
            // on desktop, if the user clears all the text and Tabs out, clear the LOV value
            this._handleSelection(this._defaultValueItemForPlaceholder, null, true);
          }
        } else if (this._abstractLovBase.isDropdownOpen()) {
          // don't call lovDropdown.getValueItemForSelection() to get the currentSelectedItem until
          // after the dropdown has been initialized
          var currentSelectedItem = this._lovDropdown.getValueItemForSelection();
          if (currentSelectedItem != null) {
            // on the desktop if there is text in the input field and there is a selected item in the
            // dropdown and the user presses Tab, set that as the value
            this._fetchDataAndSelect(currentSelectedItem, event, true);
          }
        }
      }
      this._CloseDropdown();
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleLovDropdownEventTabOut: function (event) {
      // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
      // clear flag that the user has typed filter text so that we can override it when setting
      // the selected label
      this._userHasTypedFilterText = false;

      // If no control item focused and going forward, then put focus on the
      // input so that it can naturally go to the next focusable item, but don't
      // kill the event so that it can go to the next field.
      // lovMainField.getInputElem().focus();
      this._filterInputText.focus();
      // on the desktop if there is a selected item in the dropdown
      // and the user presses Tab, set that as the value
      if (!this._fullScreenPopup) {
        let currentSelectedItem = this._lovDropdown.getValueItemForSelection();
        if (currentSelectedItem != null) {
          this._fetchDataAndSelect(currentSelectedItem, event, true);
        }
      }
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _HandleLovDropdownEventSelection: function (event) {
      var detail = event.detail;
      // JET-40375 - SELECT SINGLE - DEFAULTED VALUE OVERRIDES USER INPUT
      // clear flag that the user has typed filter text so that we can override it when setting
      // the selected label
      this._userHasTypedFilterText = false;

      this._handleSelection(detail.valueItem, detail.event);
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _GetDefaultValueItemForPlaceholder: function () {
      return this._defaultValueItemForPlaceholder;
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _IsValueItemForPlaceholder: function (valueItem) {
      return valueItem == null || this._IsValueForPlaceholder(valueItem.key);
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _IsValueForPlaceholder: function (value) {
      return value === null || value === undefined;
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _IsShowValueInFilterField: function () {
      return true;
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _SetupInitialValue: function () {
      var options = this.options;
      if (this._abstractLovBase.hasData()) {
        this._initSelectedValue(options.valueItem);
      }

      //  - need to be able to specify the initial value of select components bound to
      // dprv
      this._resolveValueItemLater = this._mergeValueAndValueItem(options.value, options.valueItem);
    },

    /**
     * @memberof oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _GetValueItemPropertyName: function () {
      return 'valueItem';
    },

    /**
     * @memberof! oj.ojSelectSingle
     * @instance
     * @protected
     * @override
     */
    _CreateLovDropdown: function () {
      return new LovDropdownSingle();
    }

    // TODO: Jeanne. Need a _ValidateReturnPromise function as well. And I need a test, because
    // right now we should have a test that fails, but ojselect tests all pass, and so do
    // ojformcontrols. so we must not have a test.

    /**
     * <p>The <code class="prettyprint">collectionTemplate</code> slot is used to specify the template
     * for rendering the items in the dropdown. The slot must be a &lt;template> element containing
     * a child collection element (e.g. <code class="prettyprint">&lt;oj-table></code>) supporting single selection.
     * The <code class="prettyprint">data</code>, <code class="prettyprint">selected</code>, and
     * <code class="prettyprint">selectedItem</code> properties should be set on the appropriate collection component
     * attributes, e.g. <code class="prettyprint">data</code>, <code class="prettyprint">selected</code>, and
     * <code class="prettyprint">first-selected-item</code> for <code class="prettyprint">oj-list-view</code> and
     * <code class="prettyprint">data</code>, <code class="prettyprint">selected.row</code>, and
     * <code class="prettyprint">first-selected-row</code> for <code class="prettyprint">oj-table</code>.
     * Note as well that the <code class="prettyprint">selectedItem</code> must be bound using a writeback expression
     * (i.e. <code class="prettyprint">{{$current.selectedItem}}</code>) so that it can be updated when the user
     * selects a new value.
     * The <code class="prettyprint">oj-select-results</code> class must also be applied to the collection
     * element in the template.
     * <p>When the template is executed, it will have access to the binding context
     * containing the following properties:</p>
     * <ul>
     *   <li>$current - an object that contains information for the collection. (See the table
     * below for a list of properties available on $current)</li>
     *  <li>alias - if the data-oj-as attribute was specified on the template, the value will be used
     * to provide an application-named alias for $current.</li>
     * </ul>
     * <p>If no <code class="prettyprint">collectionTemplate</code> is specified, the component will
     * check whether an <code class="prettyprint">itemTemplate</code> is specified.  Otherwise,
     * the component will render based on the value of the <code class="prettyprint">itemText</code>
     * property.</p>
     *
     * @ojslot collectionTemplate
     * @ojmaxitems 1
     * @ojshortdesc Slot for a collection element to render the items in the dropdown instead of the
     * default list.
     * @memberof oj.ojSelectSingle
     * @ojtemplateslotprops oj.ojSelectSingle.CollectionTemplateContext
     * @ojpreferredcontent ["ListViewElement", "TableElement"]
     *
     * @example <caption>Initialize the Select with an inline collectionTemplate specified:</caption>
     * &lt;oj-select-single>
     *   &lt;template slot='collectionTemplate'>
     *     &lt;oj-table>...&lt;/oj-table>
     *   &lt;template>
     * &lt;/oj-select-single>
     */
    /**
     * @typedef {Object} oj.ojSelectSingle.CollectionTemplateContext
     * @property {Object} data The data for the collection.
     * @property {string} searchText Search text.
     * @property {Object} selectedItem The selected item context.
     * @property {Object} selected
     *           <p>The <code class="prettyprint">selected</code> property is used to push the current
     *           selected option to the collection. This is also used to highlight the option when
     *           navigating through the dropdown.</p>
     *           <p>This should be bound to the <code class="prettyprint">selected</code> attribute of
     *           <code class="prettyprint">oj-list-view</code> if it is used for the collectionTemplate.</p>
     *           <p>When using <code class="prettyprint">oj-table</code> as the collectionTemplate this should
     *           be bound to the <code class="prettyprint">selected.row</code> attribute of the
     *           <code class="prettyprint">oj-table</code> instead.</p>
     * @property {Object} currentRow
     *           <p>The <code class="prettyprint">currentRow</code> property is used to set the focus to
     *           current active row in the <code class="prettyprint">oj-table</code>. This is also used to
     *           get the key for the current row when navigating through the options in the dropdown. Since,
     *           this property is used to listen to the changes made by the <code class="prettyprint">oj-table</code>,
     *           it should be bound to the <code class="prettyprint">current-row</code> attribute of the
     *           <code class="prettyprint">oj-table</code></p> using a <b>writable</b> expression.
     *           <p>Example:</p>
     *           <pre>
     *            <code>
     *              &lt;oj-table
     *                ...
     *                current-row="{{$current.currentRow}}"
     *                ...&gt;
     *            </code>
     *           </pre>
     * @property {any} currentRow.rowKey
     *           <p>When using <code class="prettyprint">oj-list-view</code>, this sub-property of the
     *           <code class="prettyprint">currentRow</code> property should be used instead. This should
     *           be bound to the <code class="prettyprint">current-item</code> attribute of the
     *           <code class="prettyprint">oj-list-view</code></p> using a <b>writable</b> expression.
     *           <p>Example:</p>
     *           <pre>
     *            <code>
     *              &lt;oj-list-view
     *                ...
     *                current-item="{{$current.currentRow.rowKey}}"
     *                ...&gt;
     *            </code>
     *           </pre>
     * @property {Function} handleRowAction
     *           <p>The <code class="prettyprint">handleRowAction</code> property is used to make selection
     *           for <code class="prettyprint">oj-select-single</code> when <code class="prettyprint">ojItemAction</code>
     *           is triggered in the <code class="prettyprint">oj-list-view</code> (<code class="prettyprint">ojRowAction</code>
     *           if <code class="prettyprint">oj-table</code> is used).
     *           <p>This should be bound to the <code class="prettyprint">on-oj-item-action</code> attribute of
     *           <code class="prettyprint">oj-list-view</code> if it is used for the collectionTemplate.</p>
     *           <p>When using <code class="prettyprint">oj-table</code> as the collectionTemplate this should
     *           be bound to the <code class="prettyprint">on-oj-row-action</code> attribute of the
     *           <code class="prettyprint">oj-table</code> instead.</p>
     * @ojsignature [{target: "Type", value: "DataProvider<V, D>", for: "data",
     *                jsdocOverride:true},
     *               {target:"Type", value:"KeySet<V>", for: "selected", jsdocOverride:true},
     *               {target:"Type", value:"ojcommontypes.ItemContext<V, D>", for: "selectedItem",
     *                jsdocOverride:true},
     *               {target:"Type", value:"V", for: "currentRow.rowKey", jsdocOverride: true},
     *               {target:"Type", value:"((event: Event, context: ojcommontypes.ItemContext<V, D>) => void)",
     *                for: "handleRowAction", jsdocOverride: true},
     *               {target: "Type", value: "<V, D>", for: "genericTypeParameters"}]
     * @ojdeprecated {target: "property", for: "selectedItem", since: "9.0.0",
     *                description: "The selectedItem property is deprecated in favor of currentRow and handleRowAction properties, which provide additional functionalities."}
     */

    /**
     * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template
     * for rendering each item in the dropdown list when an external
     * <code class="prettyprint">collectionTemplate</code> is not provided.
     * The slot must be a &lt;template> element.
     * <p>When the template is executed for each item, it will have access to the binding context
     * containing the following properties:</p>
     * <ul>
     *   <li>$current - an object that contains information for the current item. (See the table
     * below for a list of properties available on $current)</li>
     *  <li>alias - if the data-oj-as attribute was specified on the template, the value will be used
     * to provide an application-named alias for $current.</li>
     * </ul>
     * <p>If no <code class="prettyprint">itemTemplate</code> or
     * <code class="prettyprint">collectionTemplate</code> is specified, the component will render based
     * on the value of the <code class="prettyprint">itemText</code> property.</p>
     * <p>Note that the properties <code class="prettyprint">depth, leaf,
     * parentKey</code>, are only available when the supplied dataProvider is a
     * {@link TreeDataProvider}.
     *
     *
     * @ojslot itemTemplate
     * @ojmaxitems 1
     * @memberof oj.ojSelectSingle
     * @ojtemplateslotprops oj.ojSelectSingle.ItemTemplateContext
     *
     * @example <caption>Initialize the Select with an inline itemTemplate specified:</caption>
     * &lt;oj-select-single>
     *   &lt;template slot='itemTemplate'>
     *     &lt;div>&lt;oj-bind-text value='[[$current.data.name]]'>&lt;/oj-bind-text>&lt;/div>
     *   &lt;template>
     * &lt;/oj-select-single>
     */

    /**
     * @typedef {Object}oj.ojSelectSingle.ItemTemplateContext
     * @property {Element} componentElement The Select custom element
     * @property {Object} data The data for the current item being rendered
     * @property {number} index The zero-based index of the current item
     * @property {any} key The key of the current item being rendered
     * @property {Object} metadata The metadata for the current item being rendered
     * @property {string} searchText The search text entered by the user
     * @property {number} depth (TreeDataProvider only) The depth of the current
     * item (available when hierarchical data is provided) being rendered. The depth
     * of the first level children under the invisible root is 1.
     * @property {boolean} leaf (TreeDataProvider only) True if the current item
     * is a leaf node (available when hierarchical data is provided).
     * @property {any} parentKey (TreeDataProvider only) The key of the parent
     * item (available when hierarchical data is provided). The parent key is null
     * for root nodes.
     * @ojsignature [{target: "Type", value: "D", for: "data",
     *                jsdocOverride:true},
     *               {target:"Type", value:"V", for: "key", jsdocOverride:true},
     *               {target:"Type", value:"oj.ItemMetadata<V>", for: "metadata", jsdocOverride:true},
     *               {target:"Type", value:"V", for: "parentKey", jsdocOverride:true},
     *               {target: "Type", value: "<V, D>", for: "genericTypeParameters"}]
     */

    // Fragments:

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input Field</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.
     *       If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *     <tr>
     *       <td>Arrow Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the drop down is not open, expand the drop down list. Otherwise, close the drop down list.</td>
     *     </tr>
     *     <tr>
     *       <td>Option Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Tap on an option item in the drop down list to select.</td>
     *     </tr>
     *   </tbody>
     *  </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojSelectSingle
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *      <td>Option item</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td> Select the highlighted choice from the drop down.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Set the input text as the value.</td>
     *     </tr>
     *     <tr>
     *      <td>Drop down</td>
     *       <td><kbd>UpArrow or DownArrow</kbd></td>
     *       <td> Highlight the option item on the drop down list in the direction of the arrow.
     *         If the drop down is not open, expand the drop down list.</td>
     *     </tr>
     *     <tr>
     *      <td>Drop down</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
     *     </tr>
     *     <tr>
     *      <td>Select</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the Select. If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *   </tbody>
     *  </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojSelectSingle
     */
    /**
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     *
     * <p>
     * To migrate from oj-select-single to oj-c-select-single, you need to revise the import statement
     * and references to oj-c-select-single in your app. Please note the changes between the two
     * components below.
     * </p>
     * <h5>Global attributes</h5>
     * <p>
     * The following global attributes are no longer supported:
     * <ul>
     * <li>tabindex - not considered accessible</li>
     * </ul>
     * </p>
     *
     * <h5>ItemText attribute</h5>
     * <p>
     * This attribute is required to specify how to get the text string to render for a data item.
     * </p>
     *
     * <h5>LabelEdge attribute</h5>
     * <p>
     * The enum values for the label-edge attribute have been changed from 'inside', 'provided' and 'none' to 'start', 'inside', 'top' and 'none'.
     * If you are using this component in a form layout and would like the form layout to drive the label edge of this component, leave this attribute
     * unset. The application no longer has to specify 'provided' for this attribute. If you want to override how the label is positioned, set this
     * attribute to the corresponding value.
     * </p>
     *
     * <h5>MessagesCustom attribute</h5>
     * <p>
     * The type of the <code class="prettyprint">severity</code> property of the messages in the
     * array has changed from
     * <code class="prettyprint">Message.SEVERITY_TYPE | Message.SEVERITY_LEVEL</code>,
     * essentially <code class="prettyprint">string | number</code>, to simply
     * <code class="prettyprint">'error' | 'confirmation' | 'info' | 'warning'</code>.  These
     * values are the same as the previously supported string values.
     * The application can no longer specify severity as a number, including hardcoded numbers,
     * one of the <code class="prettyprint">Message.SEVERITY_LEVEL</code> constants, or the value
     * returned from a call to the <code class="prettyprint">Message.getSeverityLevel</code> method.
     * </p>
     *
     * <h5>TextAlign attribute</h5>
     * <p>
     * The usage of the style classes: oj-form-control-text-align-right, oj-form-control-text-align-start and oj-form-control-text-align-end is now
     * replaced with this attribute. The value of this attribute maps to these style classes as shown below:
     * <ul>
     *   <li>
     *   .oj-form-control-text-align-right maps to 'right'
     *   </li>
     *   <li>
     *   .oj-form-control-text-align-start maps to 'start'
     *   </li>
     *   <li>
     *   .oj-form-control-text-align-end maps to 'end'
     *   </li>
     * </ul>
     * </p>
     *
     * <h5>Translations</h5>
     * <p>
     * The instance level translations are not supported anymore for the following translation properties. These need to be configured
     * in the translation bundle.
     * <ul>
     *  <li>cancel</li>
     *  <li>label-acc-clear-value</li>
     *  <li>multiple-matches-found</li>
     *  <li>n-or-more-matches-found</li>
     *  <li>no-matches-found</li>
     *  <li>one-match-found</li>
     * </ul>
     *
     * The 'required' translation property can still be configured at the instance level, but this API is simplied to take a single
     * string instead of an object. To show a different required message detail, the application can now set the `required-message-detail`
     * attribute to the desired translated string.
     *
     * <h5>ValueItem</h5>
     * <p>
     * The default value of the valueItem property is changed to <code class="prettyprint">null</code> instead of <code class="prettyprint">{ key: null, data: null, metadata: null }</code>.
     * Also, when clearing out the value of the component, this property will be set to <code class="prettyprint">null</code> instead of the object mentioned above.
     * </p>
     *
     * <h5>Refresh method</h5>
     * <p>
     * The refresh method is no longer supported. The application should no longer need to use this method. If the application
     * wants to reset the component (remove messages and reset the value of the component), please use the reset method.
     * </p>
     *
     * <h5>Animation Events</h5>
     * <p>
     * ojAnimateStart and ojAnimateEnd events are no longer supported.
     * </p>
     *
     * <h5>ojValueAction Event</h5>
     * <p>
     * When clearing out the value, the <code class="prettyprint">itemContext</code> property of the <code class="prettyprint">event.detail</code>
     * object will be set to <code class="prettyprint">null</code> instead of <code class="prettyprint">{ key: null, data: null, metadata: null }</code>.
     *
     * <h5>Custom Label</h5>
     * <p>
     * Adding a custom &lt;oj-label> for the form component is no longer supported. The application should use the
     * label-hint attribute to add a label for the form component.
     * </p>
     * <p>
     * The application should no longer need to use the &lt;oj-label-value> component to layout the form component. The application
     * can use the label-edge attribute and label-start-width attribute to customize the label position and label width (only when using start label).
     * </p>
     *
     * <h5>DescribedBy attribute</h5>
     * <p>
     * The described-by attribute is not meant to be set by an application developer directly as stated in the attribute documentation.
     * This attribute is not carried forward to the core pack component.
     * </p>
     *
     * <h5>Formatted messages</h5>
     * <p>
     * Formatting messages using html tags is not supported in the core pack component.
     * </p>
     *
     * <h5>Usage in Dynamic Form</h5>
     * <p>
     * Using the component in oj-dyn-form is not supported in this release, use oj-dynamic-form instead.
     * </p>
     *
     * <h5>Limitations</h5>
     * <p>
     * Note that oj-c-select-single supports a limited feature set in JET 16. It does not support:
     * </p>
     * <ul>
     * <li>hierarchical data</li>
     * <li>customizing dropdown content by providing a customized collection component (no collectionTemplate)</li>
     * </ul>
     * @ojfragment migrationDoc
     * @memberof oj.ojSelectSingle
     */
  });

  Components.setDefaultOptions({
    // converterHint is defaulted to placeholder and notewindow in EditableValue.
    // For ojSelectSingle, we don't want a converterHint.
    ojSelectSingle: {
      // properties for all ojSelectSingle components
      displayOptions: {
        converterHint: ['none']
      }
    }
  });

});


define("bundles/ojformbundle", function(){});
