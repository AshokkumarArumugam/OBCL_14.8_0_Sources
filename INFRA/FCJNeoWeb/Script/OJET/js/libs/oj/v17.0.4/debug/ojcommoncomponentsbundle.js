/**
 * @license
 * Copyright (c) 2014, 2024, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

define('ojs/ojoption',['ojs/ojcore-base', 'ojs/ojcomponentcore', 'jquery', 'ojs/ojcustomelement', 'ojs/ojcustomelement-utils'], function (oj, ojcomponentcore, $, ojcustomelement, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * @constructor
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  function ojOption(context) {
    /**
     * Append each node to the element.
     * @private
     */
    function _appendNodes(elem, nodes) {
      $.each(nodes, function (i, node) {
        elem.appendChild(node);
      });
    }

    /**
     * Remove node from the element.
     * @private
     */
    function _removeNodes(elem, nodes) {
      $.each(nodes, function (i, node) {
        elem.removeChild(node);
      });
    }

    /**
     * Rearrange slots in the right order and remove unwanted slots.
     * @private
     */
    function _arrangeSlots(elem) {
      // get the slotMap
      var slots = ojcustomelementUtils.CustomElementUtils.getSlotMap(elem);
      var supportedSlots = ['startIcon', '', 'endIcon'];

      // remove unwanted slots
      $.each(slots, function (slotName, nodes) {
        if (supportedSlots.indexOf(slotName) === -1) {
          _removeNodes(elem, nodes);
        }
      });

      // rearrange slots
      $.each(supportedSlots, function (i, slotName) {
        if (slots[slotName]) {
          _appendNodes(elem, slots[slotName]);
        }
      });
    }

    this.updateDOM = function () {
      var customRenderer = context.element.customOptionRenderer;

      // reorder the slots and remove unwanted slots
      _arrangeSlots(context.element);

      if (customRenderer && typeof customRenderer === 'function') {
        customRenderer(context.element);
      }
    };
  }

  /**
   * @protected
   * @ignore
   */
  (function () {
    // not documented
var __oj_option_metadata = 
{
  "properties": {
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "value": {
      "type": "any"
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_option_metadata.properties.customOptionRenderer = {};
    __oj_option_metadata.extension._CONSTRUCTOR = ojOption;
    oj.CustomElementBridge.register('oj-option', { metadata: __oj_option_metadata });
  })();

  /**
   * @ojcomponent oj.ojOption
   * @since 4.0.0
   * @ojshortdesc An option represents a value for JET elements that display a list of values.
   * @ojrole option
   *
   * @ojsignature class ojOption extends JetElement<ojOptionSettableProperties>
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["value", "disabled"]}
   *
   * @ojoracleicon 'oj-ux-ico-get-options'
   *
   * @classdesc
   * <h3 id="optionOverview-section">
   *   JET Option
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#optionOverview-section"></a>
   * </h3>
   * <p>The oj-option element is used to declare values for JET elements that display list of values.
   * It's supported by the following elements:
   * <ul>
   * <li>oj-buttonset-one</li>
   * <li>oj-buttonset-many</li>
   * <li>oj-checkboxset</li>
   * <li>oj-combobox-one</li>
   * <li>oj-combobox-many</li>
   * <li>oj-menu</li>
   * <li>oj-radioset</li>
   * <li>oj-select-one</li>
   * <li>oj-select-many</li>
   * <li>oj-menu-select-many</li>
   * <li>oj-swipe-actions</li>
   * </ul>
   * </p>
   * <p>For example:
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-select-one>
   *   &lt;oj-option value="option 1">option 1&lt;/oj-option>
   *   &lt;oj-option value="option 2">option 2&lt;/oj-option>
   *   &lt;oj-option value="option 3">option 3&lt;/oj-option>
   *   &lt;oj-option value="option 4">option 4&lt;/oj-option>
   * &lt;/oj-select-one>
   * </code></pre>
   */

  /**
   * <p>Disables the oj-option if set to <code class="prettyprint">true</code>.
   *
   * @name disabled
   * @ojshortdesc Disables the option if set to true.
   * @expose
   * @memberof oj.ojOption
   * @instance
   * @type {boolean}
   * @default false
   *
   * @example <caption>Initialize the oj-option with the <code class="prettyprint">disabled</code> attribute specified:</caption>
   * &lt;oj-option disabled="[[isDisabled]]" value="option1">Option1&lt;/oj-option>
   *
   * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
   * // getter
   * var disabledValue = myOption.disabled;
   *
   * // setter
   * myOption.disabled = true;
   */

  /**
   * <p>Specifies the oj-option's value. The value is associated with the oj-option element whose display value may be different.
   *
   * @name value
   * @ojshortdesc The value of the option.
   * @expose
   * @memberof oj.ojOption
   * @instance
   * @type {any}
   *
   * @example <caption>Initialize the oj-option with the <code class="prettyprint">value</code> attribute specified:</caption>
   * &lt;oj-option value="option1">Option1&lt;/oj-option>
   *
   * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
   * // getter
   * var optionValue = myOption.value;
   *
   * // setter
   * myOption.value = 'option1';
   */

  /**
   * <p>Child content for oj-option. This is normally the text node that displays for oj-option.</p>
   *
   * @ojchild Default
   * @ojshortdesc The default slot for the option's content.
   * @memberof oj.ojOption
   *
   * @example <caption>Initialize the oj-option with child content specified:</caption>
   * &lt;oj-option>
   *   Option label
   * &lt;/oj-option>
   */

  /**
   * <p>Named slot for the oj-option's start icon.</p>
   *
   * @ojslot startIcon
   * @ojshortdesc The slot for the option's start icon.
   * @memberof oj.ojOption
   *
   * @example <caption>Initialize the oj-option with the <code class="prettyprint">startIcon</code> slot specified:</caption>
   * &lt;oj-option>
   *   &lt;span slot='startIcon'>&lt;img src='start.png' alt='Start'>&lt;/span>
   * &lt;/oj-option>
   */

  /**
   * <p>Named slot for the oj-option's end icon.</p>
   *
   * @ojslot endIcon
   * @ojshortdesc The slot for the option's end icon.
   * @memberof oj.ojOption
   *
   * @example <caption>Initialize the oj-option with the <code class="prettyprint">endIcon</code> slot specified:</caption>
   * &lt;oj-option>
   *   &lt;span slot='endIcon'>&lt;img src='end.png' alt='End'>&lt;/span>
   * &lt;/oj-option>
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   *
   * @expose
   * @memberof oj.ojOption
   * @instance
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   *
   * @expose
   * @memberof oj.ojOption
   * @instance
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Refreshes the visual state of the component.
   *
   * @function refresh
   * @return {void}
   * @expose
   * @memberof oj.ojOption
   * @instance
   */
  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   *
   * @expose
   * @memberof oj.ojOption
   * @instance
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */

});


define('ojs/ojchildmutationobserver',['ojs/ojcustomelement', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry'], function (ojcustomelement, ojcustomelementUtils, ojcustomelementRegistry) { 'use strict';

  /**
   * Child mutation observer.
   * The implementation of the class is based on DOM MutationObserver and it is intended
   * for watching mutations for a custom element registered in JET.
   * The observer will watch for 'childList', 'attributes' and 'subtree' mutation types.
   * All received mutations will be filtered using metadata.extension._TRACK_CHILDREN
   * option on the watched element.
   * The specified handler will be called for the relevant mutations.
   * Valid _TRACK_CHILDREN settings:
   *  - none - (default) no tracking is done for child elements
   *  - immediate -  tracking is performed for the immediate level of custom elements
   *  - nearestCustomElement - the element will be searched for nearest custom
   *                           elements and tracking will be performed for them
   *                           if they are present.
   * @param {Element} element Custom DOM element registered in custom element registry for JET.
   * @param {function} handler A handler for relevant child mutations
   * @class
   * @since 6.0.0
   * @ignore
   */

  const ChildMutationObserver = function (element, handler) {
    var _element = element;
    var _handler = handler;
    var _trackOption = ojcustomelementRegistry.isElementRegistered(element.tagName)
      ? ojcustomelementUtils.CustomElementUtils.getElementState(element).getTrackChildrenOption()
      : 'none';
    /**
     * Filter DOM mutations.
     * @param {Array} mutations all DOM mutations for the element
     * @return {Array} filtered DOM mutaions
     */
    var _filterMutations = function (mutations) {
      var filteredMutations = [];

      for (var i = 0; i < mutations.length; i++) {
        var mutation = mutations[i];
        var testElement =
          mutation.type === 'childList' ? mutation.target : mutation.target.parentNode;
        while (testElement) {
          if (testElement === _element) {
            // the mutation is relevant - push it to the array and stop the search
            filteredMutations.push(mutation);
            testElement = null;
          } else if (
            _trackOption === 'nearestCustomElement' &&
            !ojcustomelementUtils.ElementUtils.isValidCustomElementName(testElement.localName)
          ) {
            // we search for the nearest custom element, the mutation might be relevant, walk the DOM up to find out
            testElement = testElement.parentNode;
          } else {
            // the mutation is not relevant - skip it
            testElement = null;
          }
        }
      }
      return filteredMutations;
    };

    var _internalHandler = function (mutations) {
      var filteredMutations = _filterMutations(mutations);
      if (filteredMutations.length > 0) {
        _handler(filteredMutations);
      }
    };

    var _mutationObserver = new MutationObserver(_internalHandler);

    return {
      /**
       * Start watching for DOM mutations for a JET custom element. The mutation handler will be called
       * when a relevant mutation is detected - any relevant mutations should meet
       * the criteria provided by the metadata.extension._TRACK_CHILDREN option on the element.
       * @ignore
       */
      observe: function () {
        if (_trackOption !== 'none') {
          _mutationObserver.observe(_element, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });
        }
      },
      /**
       * Stop watching for DOM mutations.
       * Calling disconnect() might trigger child mutations handler
       * if there are any pending mutations.
       * @ignore
       */
      disconnect: function () {
        var records = _mutationObserver.takeRecords();
        if (records && records.length > 0) {
          _internalHandler(records);
        }
        _mutationObserver.disconnect();
      }
    };
  };

  return ChildMutationObserver;

});


define('ojs/ojjquery-hammer',['ojs/ojlogger', 'hammerjs', 'jquery'], function (Logger, Hammer, $) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  if (Hammer) {
    /** @export */
    $.fn.ojHammer = function (options) {
      switch (options) {
        // $(...).ojHammer("instance") returns the Hammer instance previously instantiated on this element via $(...).ojHammer(options), or undefined if none.
        case 'instance':
          return this.data('ojHammer');

        // $(...).ojHammer("destroy") destroys the Hammer instance and removes it from the node's data store.
        case 'destroy':
          return this.each(function () {
            var $el = $(this);
            var hammer = $el.data('ojHammer');
            if (hammer) {
              hammer.destroy();
              $el.removeData('ojHammer');
            }
            $el.off('remove.ojHammer');
          });

        default:
          // $(...).ojHammer(options) instantiates Hammer on this element, and stores it for later retrieval via $(...).ojHammer("instance")
          return this.each(function () {
            var $el = $(this);
            if (!$el.data('ojHammer')) {
              const mgr = new Hammer.Manager($el[0], options);
              $el.on('remove.ojHammer', (evt) => {
                if (evt.target === $el[0]) {
                  mgr.destroy();
                }
              });
              $el.data('ojHammer', mgr);
            }
          });
      }
    };

    // extend the emit method to also trigger jQuery events
    Hammer.Manager.prototype.emit = (function (originalEmit) {
      return function (type, data) {
        originalEmit.call(this, type, data);
        $(this.element).trigger({
          type: type,
          gesture: data
        });
      };
    })(Hammer.Manager.prototype.emit);
  } else {
    Logger.warn('Hammer jQuery extension loaded without Hammer.');
  }

});


define('ojs/ojpopup',['ojs/ojpopupcore', 'ojs/ojcore-base', 'jquery', 'ojs/ojcontext', 'ojs/ojdomutils', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojanimation', 'ojs/ojfocusutils', 'ojs/ojcustomelement-utils'], function (ojpopupcore, oj, $, Context, DomUtils, ThemeUtils, Components, AnimationUtils, FocusUtils, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;

  (function () {
    /**
     * List of all pseudo marker selectors that defines rules for where a tail is aligned.
     * @private
     * @const
     */
    var _TAIL_STYLES = ['oj-left', 'oj-center', 'oj-right', 'oj-top', 'oj-middle', 'oj-bottom'];

    /**
     * Mapping of horizontal-vertical (x,y) positon using alignment to jet tail pseudo marker
     * selectors.
     *
     * horizontal: right, left, center
     * vertical: top, bottom, middle
     *
     * @private
     * @const
     */
    var _TAIL_ALIGN_RULES = {
      'right-top': 'oj-right oj-top',
      'right-middle': 'oj-right oj-middle',
      'right-bottom': 'oj-right oj-bottom',
      'left-top': 'oj-left oj-top',
      'left-middle': 'oj-left oj-middle',
      'left-bottom': 'oj-left oj-bottom',
      'center-top': 'oj-center oj-top',
      'center-middle': 'oj-left oj-middle',
      'center-bottom': 'oj-center oj-bottom'
    };

    /**
     * @typedef {Object} oj.ojPopup.PositionAlign
     * @property {"top"|"bottom"|"center"} [vertical] Vertical alignment.
     * @property {"start"|"end"|"left"|"center"|"right"} [horizontal] Horizontal alignment. <p>
     * <ul>
     *  <li><b>"start"</b> evaluates to "left" in LTR mode and "right" in RTL mode.</li>
     *  <li><b>"end"</b> evaluates to "right" in LTR mode and "left" in RTL mode.</li>
     * </ul>
     *
     */

    /**
     * @typedef {Object} oj.ojPopup.PositionPoint
     * @property {number} [x] Horizontal alignment offset.
     * @property {number} [y] Vertical alignment offset.
     */

    /**
     * @typedef {Object} oj.ojPopup.Position
     * @property {Object} [my] Defines which edge on the popup to align with the target ("of") element.
     * @property {Object} [at] Defines which position on the target element ("of") to align the positioned element
     *                                  against.
     * @property {Object} [offset] Defines a point offset in pixels from the ("my") alignment.
     * @property {string|Object} [of] Which element to position the popup against.  The default is the
     * <code class="prettyprint">launcher</code> argument passed to the
     * <code class="prettyprint">open</code> method. <p>
     *
     * If the value is a string, it should be a selector or the literal string value
     * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
     * is used, the values are relative to the whole document.  Page horizontal and vertical
     * scroll offsets need to be factored into this point - see UIEvent
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
     *
     * @property {"flip"|"fit"|"flipfit"|"flipcenter"|"none"} [collision] Rule for alternate alignment. <p>
     * <ul>
     *  <li><b>"flip"</b> the element to the opposite side of the target and the
     *             collision detection is run again to see if it will fit. Whichever side
     *             allows more of the element to be visible will be used. </li>
     * <li><b>"fit"</b> shift the element away from the edge of the window. </li>
     * <li><b>"flipfit"</b> first applies the flip logic, placing the element
     *  on whichever side allows more of the element to be visible. Then the fit logic
     *  is applied to ensure as much of the element is visible as possible.</li>
     * <li><b>flipcenter</b> first applies the flip rule and follows with center alignment.</li>
     * <li><b>"none"</b> no collision detection.</li>
     * </ul>
     * @ojsignature [{target:"Type", value:"oj.ojPopup.PositionAlign", for:"my", jsdocOverride:true},
     *               {target:"Type", value:"oj.ojPopup.PositionAlign", for:"at", jsdocOverride:true},
     *               {target:"Type", value:"oj.ojPopup.PositionPoint", for:"offset", jsdocOverride:true},
     *               {target:"Type", value:"string|oj.ojPopup.PositionPoint", for:"of", jsdocOverride:true}]
     */

    /**
     * @ojcomponent oj.ojPopup
     * @augments oj.baseComponent
     *
     * @since 1.1.0
     * @ojdisplayname Popup
     * @ojshortdesc A popup temporarily 'pops up' content in the foreground.
     * @ojrole tooltip
     * @ojrole dialog
     * @ojrole alertdialog
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["initalFocus", "modality", "autoDismiss", "tail",
     *                                                     "position.at.horizontal", "position.at.vertical",
     *                                                     "position.collision", "position.my.horizontal",
     *                                                     "position.my.vertical", "position.of",
     *                                                     "position.offset.x", "position.offset.y", "style"]}
     * @ojvbdefaultcolumns 2
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-popup-oj'
     * @ojuxspecs ['popup']
     *
     * @classdesc
     * <h3 id="popupOverview-section">
     *   JET Popup Component
     *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#popupOverview-section"></a></h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant popup that can display arbitrary content.</p>
     *
     * <p>A JET popup can be created from custom element
     * <code class="prettyprint">&lt;oj-popup&gt;</code> syntax. This element will become the
     * root - outer chrome of the popup.  The content of the popup will be relocated under an
     * element marked with the <code class="prettyprint">.oj-popup-content</code> selector.
     * Dynamic content can be inserted under the element identified by the
     * <code class="prettyprint">.oj-popup-content</code> selector.  However, page developers
     * are encouraged to create their own content element to anchor dynamic content changes
     * versus using <code class="prettyprint">.oj-popup-content</code> as the marker selector.</p>
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-popup id="popup"&gt;
     *   &lt;span class="mycontent"&gt;
     *     Hello World!
     *   &lt;/span class="mycontent"&gt;
     * &lt;/oj-popup&gt;
     * </code></pre>
     *
     * <p>The following is an example of dynamically changing the content of the popup defined above.
     * </p>
     *
     * <pre class="prettyprint">
     * <code>var content = popup.querySelector( ".mycontent" );
     * content.textContent = "Hello Universe!";
     * </code></pre>
     *
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     *  <p>To migrate from oj-popup to oj-c-popup, you need to revise the import statement and references to oj-c-popup in your app.</p>
     *  <p>In addition, please note the changes between the two components below.</p>
     *  <h5>position</h5>
     *  <p>The <code class="prettyprint">position</code> property and its subproperties are replaced with a collection of new top-level attributes.
     *  </p>
     *  <h5>position.at, position.my</h5>
     *  <p>These properties are replaced with the <code class="prettyprint">placement</code> property. The placement value defines the relative position of the popup to its anchor. For example, the following position specification</p>
     *  <pre class="prettyprint"><code>
     *     position.at.horizontal="end"
     *     position.at.vertical="top"
     *     position.my.horizontal="start"
     *     position.my.vertical="bottom"
     *  </code></pre>
     *  <p>can be specified as</p>
     *  <pre class="prettyprint"><code>
     *     placement="end-top-corner"
     *  </code></pre>
     *  <h5>position.of</h5>
     *  <p>This property is replaced with the <code class="prettyprint">anchor</code> attribute in oj-c-popup.</p>
     *  <h5>position.offset, position.collision</h5>
     *  <p>These properties are moved to the top-level as the <code class="prettyprint">offset</code> and <code class="prettyprint">collision</code> attributes.</p>
     *  <h5>open method</h5>
     *  <p>The <code class="prettyprint">open</code> method is no longer supported. Visibility of the popup is controlled using the <code class="prettyprint">opened</code> property in oj-c-popup.
     *     The <code class="prettyprint">launcher</code> parameter is replaced with the new <code class="prettyprint">launcher</code> attribute.
     *  </p>
     *  <h5>close method</h5>
     *  <p>The <code class="prettyprint">close</code> method is no longer supported. Use <code class="prettyprint">opened="false"</code> to close the popup.</p>
     *  <h5>isOpen method</h5>
     *  <p>The <code class="prettyprint">isOpen</code> method is no longer supported. Use the <code class="prettyprint">opened</code> property to determine the state of the popup.</p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <br/><br/>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For WAI-ARIA compliance, JET automatically adds
     * <code class="prettyprint">role="tooltip"</code> to the non-modal popup root dom element, or
     * <code class="prettyprint">role="dialog"</code> to the modal popup root dom element, if not
     * already specificed. This is not a component property but rather the standard html
     * <a href="https://www.w3.org/WAI/PF/aria/roles">role</a> attribute. Depending on how the
     * popup is used in the page, the page developer should choose from the following when overriding
     * the default values:
     * <ul>
     *   <li>"tooltip" defines contextual popup that displays a description for an element.
     *       Although this is the default role for non-modal popups, it should only be used
     *       for popups that include simple textual content and no interactive elements.
     *       The "tooltip" role should never be used with modal popups.</li>
     *   <li>"dialog" defines an application window that is designed to interrupt the current
     *       processing of an application in order to prompt the user to enter information or
     *       require a response. It is the default role for modal popups, but can (and should) be used
     *       for non-modal windows too, if the popup includes interactive content.</li>
     *   <li>"alertdialog" defines type of popup that contains an alert message, where initial focus
     *       goes to an element within the popup.</li>
     * </ul>
     * </p>
     * <p>
     * The non-modal (modeless) popup with the "tooltip" role automatically adds the <code class="prettyprint">aria-describedby="popup-id"</code>
     * attribute to the associated launcher while the popup is open.
     * </p>
     * <p>
     * For popups with the "dialog" and "alertdialog" the page developer should consider adding the aria-haspopup="dialog" to the launcher element.
     * </p>
     * <p>
     * Depending on the aria role and popup content, the page developer may also need to
     * set the <code class="prettyprint">aria-labelledby</code> and (optionally)
     * <code class="prettyprint">aria-describedby</code> attributes on the oj-popup
     * element in order to make the popup and its content accessible.
     * </p>
     *
     * On platforms that support voice over mode (VO), the popup injects anchor tags "skip links"
     * into the document for navigation. Skip links are not visible but read in VO mode.
     * Two skip links are injected into the document when a popup is disclosed:
     *  <ul>
     *    <li>A close link, {@link oj.ojPopup#translations.ariaCloseSkipLink}, is injected as a
     *        sibling to the popup's content. Activation of this link will close the popup.</li>
     *    <li>For cases where the non-modal popup doesn't steal focus when it's open, a content navigation
     *        skip link, {@link oj.ojPopup#translations.ariaFocusSkipLink}, is injected as a
     *        sibling to the launcher (first required argument of the open method). If the launcher
     *        selector targets a sub-element of the launcher, the skip link could be injected under
     *        the launcher, which can be problematic for oj-button as skip link activation will
     *        also activate the associated launcher. The focus skip link is not injected for modal popups.</li>
     *  </ul>
     *
     * <p>One point often overlooked is making the gestures that launch a popup accessible.
     *   There are no constraints to what events a page developer might choose to trigger opening a
     *   popup.  The choice should be accessible for screen reader users.  Page
     *   developers should take care when using mouse events to trigger opening of a popup.
     *   This is especially important if the content of the popup can't be derived from other
     *   visible areas on the page. In cases that mouseover, mouseout, mouseenter, mouseleave and
     *   hover events are used to launch popups, there needs to be a keyboard functional equivalency.
     * </p>
     *
     * <p>See also the <a href="#styling-section">oj-focus-highlight</a> discussion.
     *
     * <h3 id="reparenting-section">
     *   Reparenting
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
     * </h3>
     *
     *  <p id="reparenting-strategy">
     *     When popups are open, they will be reparented in the document and reparented back when
     *     closed. When open, the location of the popup within the document will be in context of
     *     how it's used. Popups open from other popups will be relocated in the document into the
     *     nearest parent popup's layer. The popups layer defines its z-index weight "stacking
     *     context".  The ojPopup's layer is marked with the "oj-popup-layer" style.
     *     The context of opening is defined by the launcher argument passed to the open method.  If
     *     not open from another popup, the popup will be reparented to a container in the document
     *     body. Popups of the same type are assigned the same z-index values.  The layering between
     *     peer popups reflect the opening order. The popup that has active focus will be assigned a
     *     greater z-index value. This is applied to the popup's layer by way of the "oj-focus-within"
     *     pseudo selector applied with "oj-popup-layer" selector. The page author has control over
     *     z-index weights by way of the "oj-popup-layer" selector.
     *  </p>
     *  <p>
     *     There are known caveats with this design. However, these scenarios are considered "bad use"
     *     based on our JET popup strategy.
     *  </p>
     *  <ol>
     *    <li>Events raised within the popup will not bubble up to the popup's original ancestors.
     *        Instead, listeners for popup events should be applied to either the popup's root
     *        element, or the document.</li>
     *    <li>Likewise, developers should not use CSS descendant selectors, or similar logic, that
     *        assumes that the popup will remain a child of its original parent.</li>
     *    <li>Popups containing iframes are problematic.  The iframe elements "may" fire a HTTP GET
     *        request for its src attribute each time the iframe is reparented in the document.</li>
     *    <li>If an iframe is added to the popup's content, it must not be the first or last tab stop
     *        within the popup or keyboard and VoiceOver navigation will not remain within the popup.</li>
     *    <li>In some browsers, reparenting a popup that contains elements having overflow, will cause
     *        these overflow elements to reset their scrollTop.</li>
     *  </ol>
     *
     * <h3 id="eventHandling-section">
     *   Event Handling
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
     * </h3>
     * <ul>
     *  <li>ojBeforeClose(event) - Triggered before a popup closes. Event can prevent closing the
     *      popup; However, there are cases the framework must veto, such as when the popup is
     *      destroyed.</li>
     *  <li>ojBeforeOpen(event) - Triggered before a popup opens. Event can prevent opening the
     *      popup.</li>
     *  <li>ojClose(event) - Triggered after the popup has closed.</li>
     *  <li>ojFocus(event) - Triggered when initial focus is established on opening, depending on
     *      the value of the initalFocus property, or <kbd>F6</kbd> focus toggle from the associated
     *      launcher.</li>
     *  <li>ojOpen(event) - Triggered after the popup has been made visible.</li>
     * </ul>
     */

    //-----------------------------------------------------
    //                   Slots
    //-----------------------------------------------------

    /**
     * <p>The <code class="prettyprint">&lt;oj-popup></code> accepts
     * any DOM elements in its Default slot but only tracks the validity
     * state of any JET custom element descendents that contain the valid property.
     * @ojchild Default
     * @memberof oj.ojPopup
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Outside popup or launcher</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Close the popup.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>Disabled items do not allow any touch interaction.
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojPopup
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "3">Focus within Popup</td>
     *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
     *       <td>Navigate the content of the popup. Close the open popup if there are no tab stops in
     *           the popup.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>F6</kbd></td>
     *       <td>Move focus to the launcher for a popup with modeless modality.  Close the open popup
     *           if the modality is modal.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Close the open popup.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan = "1">Popup Launcher</td>
     *       <td><kbd>F6</kbd></td>
     *       <td>Move focus to the first tab stop within the open popup.  If there is not a tab stop
     *           within the content, focus is established on the popup.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojPopup
     */

    //-----------------------------------------------------
    //                   Styles
    //-----------------------------------------------------

    // ---------------- oj-focus-highlight --------------
    /**
     * Under normal circumstances this class is applied automatically.
     * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojPopup
     * @ojtsexample
     * &lt;oj-popup class="oj-focus-highlight">
     *   &lt;!-- Content -->
     * &lt;/oj-popup>
     */
    /**
     * @ojstylevariableset oj-popup-css-set1
     * @ojstylevariable oj-popup-bg-color {description: "Popup background color", formats: ["color"],help: "#css-variables"}
     * @ojstylevariable oj-popup-border-color {description: "Popup border color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-popup-border-radius {description: "Popup border radius", formats: ["length","percentage"], help: "#css-variables"}
     * @ojstylevariable oj-popup-box-shadow {description: "Popup box shadow", help: "#css-variables"}
     * @ojstylevariable oj-popup-padding {description: "Popup padding", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-popup-tail-height {description: "Popup tail height", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-popup-tail-width {description: "Popup tail width", formats: ["length"], help: "#css-variables"}
     * @memberof oj.ojPopup
     */
    // --------------------------------------------------- oj.ojPopup Styling end -----------------------------------------------------------

    oj.__registerWidget('oj.ojPopup', $.oj.baseComponent, {
      widgetEventPrefix: 'oj',
      options: {
        /**
         *
         * @private
         * @memberof oj.ojPopup
         * @instance
         */
        animation: null,
        /**
         * Defines conditions that will cause an open popup to auto close dismiss.  A value of
         * <code class="prettyprint">focusLoss</code> defines the dismissal condition where focus
         * has left the content of the popup or from the associated launcher or if what the popup
         * is aligned to is not fully visible within an overflow area.
         *
         * @expose
         * @memberof oj.ojPopup
         * @ojshortdesc Specifies the auto dismissal behavior.
         * @instance
         * @type {string}
         * @default 'focusLoss'
         * @ojvalue {string} "none" disables auto dismissal behaviors.
         * @ojvalue {string} "focusLoss" defines auto dismissal behavior when focus leaves the
         *   content of the popup or associated launcher.  In addition, if what the popup is
         *   positioned to is not visible within an overflow area, the popup will auto close
         *   dismiss.
         *
         * @example <caption>Initialize the popup with
         *          <code class="prettyprint">auto-dismiss</code> attribute specified:</caption>
         * &lt;oj-popup auto-dismiss="focusLoss" &gt;&lt;/oj-popup&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">autoDismiss</code> property,
         *          after initialization:</caption>
         * // getter
         * var autoDismiss = myPopup.autoDismiss;
         * // setter
         * myPopup.autoDismiss = "none";
         */
        autoDismiss: 'focusLoss',
        /**
         * Defines the presence of border, shadow and background color of the root popup dom.
         * Value of <code class="prettyprint">none</code> applies the
         * <code class="prettyprint">oj-popup-no-chrome</code> selector defined by the active
         * theme to the root dom of the popup to remove the default chrome.
         *
         * @expose
         * @memberof oj.ojPopup
         * @ojshortdesc Specifies whether to use the border, shadow, and background colors from the active theme.
         * @ojdeprecated {since: "17.0.0", description: "This is not recommended in the Redwood design system."}
         * @instance
         * @type {string}
         * @default 'default'
         * @ojvalue {string} "default" describes the popups border, shadow, and background color
         *           defined by the active theme.
         * @ojvalue {string} "none" turns off the outer chrome defined by the active theme.
         *
         * @example <caption>Initialize the popup with <code class="prettyprint">chrome</code>
         *          attribute specified:</caption>
         * &lt;oj-popup chrome="none" &gt;&lt;/oj-popup&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">chrome</code> property, after
         *          initialization:</caption>
         * // getter
         * var chrome = myPopup.chrome;
         *
         * // setter
         * myPopup.chrome = "none";
         */
        chrome: 'default',
        /**
         * Determines if the popup should steal focus to its content when initially open. A value
         * of <code class="prettyprint">none</code> prevents the popup from grabbing focus when
         * open.
         *
         * @expose
         * @memberof oj.ojPopup
         * @ojshortdesc Specifies whether the popup steals focus to its content when initially opened.
         * @instance
         * @type {string}
         * @default 'auto'
         * @ojvalue {string} "auto" is derived from the values of the modality and
         *          autoDismiss properties
         * @ojvalue {string} "none" prevents the popup from stealing focus when open.
         * @ojvalue {string} "firstFocusable" defines that a popup should grab focus to the first
         *          focusable element within the popup's content.
         * @ojvalue {string} "popup" focus to the root popup container (good choice for touch
         *          platforms).
         *
         * @example <caption>Initialize the popup with
         *           <code class="prettyprint">initial-focus</code> attribute specified:</caption>
         * &lt;oj-popup initial-focus="none" &gt;&lt;/oj-popup&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">initialFocus</code> property,
         *          after initialization:</caption>
         * // getter
         * var initialFocus = myPopup.initialFocus;
         *
         * // setter
         * myPopup.initialFocus = "none";
         */
        initialFocus: 'auto',

        /**
         * <p>Position property is used to establish the location the popup will appear relative to
         * another element. {@link oj.ojPopup.Position} defines "my" alignment "at" the alignment
         * "of" some other thing which can be "offset" by so many pixels.</p>
         *
         * <p>The "my" and "at" properties defines alignment points relative to the popup and other
         * element.  The "my" property represents the popups alignment where the "at" property
         * represents the other element that can be identified by "of" or defauts to the launcher
         * when the popup opens.  The values of these properties describe horizontal and
         * vertical alignments.</p>
         *
         * <b>Deprecated v3.0.0 jQuery UI position syntax; Use of a percent unit with
         * "my" or "at" is not supported.</b>
         *
         * @expose
         * @memberof oj.ojPopup
         * @instance
         * @type {Object}
         * @ojsignature { target: "Type",
         *                value: "oj.ojPopup.Position",
         *                jsdocOverride: true}
         * @name position
         * @ojshortdesc Specifies the position of a popup when launched. See the Help documentation for more information.
         * @example <caption>Initialize the popup with <code class="prettyprint">position</code>
         *           attribute specified:</caption>
         * &lt;oj-popup position.my.horizontal="left"
         *           position.my.vertical="top"
         *           position.at.horizontal="right"
         *           position.at.vertical="top" &gt;&lt;/oj-popup&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">position</code> property,
         *          after initialization:</caption>
         * // getter
         * var position = myPopup.position;
         *
         * // setter
         * myPopup.position =
         *    {"my": {"horizontal": "start", "vertical": "bottom"},
         *     "at": {"horizontal": "end", "vertical": "top" },
         *     "offset": {"x": 0, "y":5}};
         */
        position: {
          /**
           * Defines which edge on the popup to align with the target ("of") element.
           *
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @name position.my
           * @type {{horizontal:string, vertical:string}}
           */
          my: {
            /**
             * Defines the horizontal alignment of the popup.
             * @expose
             * @memberof! oj.ojPopup
             * @instance
             * @name position.my.horizontal
             * @type {string}
             * @default 'start'
             * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
             * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
             * @ojvalue {string} "left"
             * @ojvalue {string} "center"
             * @ojvalue {string} "right"
             */
            horizontal: 'start',
            /**
             * Defines the vertical alignment of the popup.
             * @expose
             * @memberof! oj.ojPopup
             * @instance
             * @name position.my.vertical
             * @type {string}
             * @default 'top'
             * @ojvalue {string} "top"
             * @ojvalue {string} "center"
             * @ojvalue {string} "bottom"
             */
            vertical: 'top'
          },
          /**
           * Defines a point offset in pixels from the ("my") alignment.
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @name position.offset
           * @type {{x:number, y:number}}
           */
          offset: {
            /**
             * Horizontal alignment offset.
             * @expose
             * @memberof! oj.ojPopup
             * @instance
             * @name position.offset.x
             * @type {number}
             * @default 0
             */
            x: 0,
            /**
             * Vertical alignment offset.
             * @expose
             * @memberof! oj.ojPopup
             * @instance
             * @name position.offset.y
             * @type {number}
             * @default 0
             */
            y: 0
          },
          /**
           * Defines which position on the target element ("of") to align the positioned element
           * against.
           *
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @name position.at
           * @type {{horizontal:string, vertical:string}}
           */
          at: {
            /**
             * Defines the horizontal alignment of what the popup is aligned to.
             * @expose
             * @memberof! oj.ojPopup
             * @instance
             * @name position.at.horizontal
             * @type {string}
             * @default 'start'
             * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
             * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
             * @ojvalue {string} "left"
             * @ojvalue {string} "center"
             * @ojvalue {string} "right"
             */
            horizontal: 'start',
            /**
             * Defines the vertical alignment of what the popup is aligned to.
             * @expose
             * @memberof! oj.ojPopup
             * @instance
             * @name position.at.vertical
             * @type {string}
             * @default 'bottom'
             * @ojvalue {string} "top"
             * @ojvalue {string} "center"
             * @ojvalue {string} "bottom"
             */
            vertical: 'bottom'
          },
          /**
           * Which element to position the popup against.  The default is the
           * <code class="prettyprint">launcher</code> argument passed to the
           * <code class="prettyprint">open</code> method.
           *
           * If the value is a string, it should be a selector or the literal string value
           * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
           * is used, the values are relative to the whole document.  Page horizontal and vertical
           * scroll offsets need to be factored into this point - see UIEvent
           * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
           * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
           *
           * @example <caption>Finding the point for an svg element:</caption>
           * var rect = svgDom.getBoundingClientRect();
           * var position = {of:{x:rect.left + window.pageXOffset, y:rect.top + window.pageYOffset}};
           *
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @name position.of
           * @ojshortdesc Which element to position the popup against. See the Help documentation for more information.
           * @type {string|{x: number, y: number}}
           */
          of: undefined,
          /**
           * Rule for alternate alignment.
           *
           * @expose
           * @memberof! oj.ojPopup
           * @instance
           * @name position.collision
           * @type {string}
           * @default 'flip'
           * @ojvalue {string} "flip" the element to the opposite side of the target and the
           *  collision detection is run again to see if it will fit. Whichever side
           *  allows more of the element to be visible will be used.
           * @ojvalue {string} "fit" shift the element away from the edge of the window.
           * @ojvalue {string} "flipfit" first applies the flip logic, placing the element
           *  on whichever side allows more of the element to be visible. Then the fit logic
           *  is applied to ensure as much of the element is visible as possible.
           * @ojvalue {string} "flipcenter" first applies the flip rule and follow with center
           *  alignment.
           * @ojvalue {string} "none" no collision detection.
           */
          collision: 'flip'
        },
        /**
         * Determines if a decoration will be displayed from the popup that points to the element
         * the popup is aligned to. The <code class="prettyprint">simple</code> value enables the
         * tail defined by the current theme.  In addtion, the
         * <code class="prettyprint">oj-popup-tail-simple</code> selector will be applied to the
         * root dom element.  This is to allow the box-shadow, z-index and other chrome styling to
         * vary per tail decoration.
         *
         * @expose
         * @memberof oj.ojPopup
         * @ojshortdesc Specifies whether to display a decoration pointing from the popup to the launching element. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @default 'none'
         * @ojvalue {string} "none" no decoration will be displayed from the popup pointing to the
         *          launcher.
         * @ojvalue {string} "simple" enables showing the tail defined by the current theme.
         *
         * @example <caption>Initialize the popup with <code class="prettyprint">tail</code>
         *          attribute specified:</caption>
         * &lt;oj-popup tail="simple" &gt;&lt;/oj-popup&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">tail</code> property, after
         *          initialization:</caption>
         * // getter
         * var tail = myPopup.tail;
         *
         * // setter
         * myPopup.tail = "simple";
         */
        tail: 'none',
        /**
         * Determines if the popup should block user input of the page behind with a blocking
         * overlay pane.
         *
         * <p>The default modality varies by theme.
         *
         * @expose
         * @memberof oj.ojPopup
         * @ojshortdesc Specifies whether the popup should block user input to the page.
         * @instance
         * The modality of the popup. Valid values are:
         * @ojvalue {string} "modeless" defines a modeless popup.
         * @ojvalue {string} "modal" The popup is modal. Interactions with other page elements are
         *          disabled. Modal popups overlay other page elements.
         * @type {string}
         * @default 'modeless'
         * @example <caption>Initialize the popup to have modality
         *          <code class="prettyprint">modality</code></caption>
         * &lt;oj-popup modality="modal" &gt;&lt;/oj-popup&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">modality</code> property,
         *          after initialization:</caption>
         * // getter
         * var modality = myPopup.modality;
         *
         * // setter
         * myPopup.modality = "modal";
         *
         */
        modality: 'modeless',
        /**
         * @private
         * @memberof oj.ojPopup
         * @instance
         * @type {string}
         */
        role: 'tooltip',
        // Events
        /**
         * Triggered before the popup is launched via the <code class="prettyprint">open()</code>
         * method. The open can be cancelled by calling
         * <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered before the popup is launched.
         * @instance
         * @ojcancelable
         * @ojbubbles
         */
        beforeOpen: null,
        /**
         * Triggered after the popup is launched via the <code class="prettyprint">open()</code>
         * method.
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered after the popup is launched.
         * @instance
         * @ojbubbles
         */
        open: null,
        /**
         * Triggered before the popup is dismissed via the
         * <code class="prettyprint">close()</code> method. The close can be cancelled by calling
         * <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered before the popup is dismissed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         */
        beforeClose: null,
        /**
         * Triggered after the popup is dismissed via the
         * <code class="prettyprint">close()</code> method.
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered after the popup is dismissed.
         * @instance
         * @ojbubbles
         */
        close: null,
        /**
         * Triggered after focus has been transferred to the popup. This will occur after the
         * <code class="prettyprint">open()</code> method is called, depending on the value
         * of the <code class="prettyprint">initialFocus</code> property.  It's also triggered
         * when using the <kbd>F6</kbd> key to toggle focus from the associated launcher element
         * to the content of the popup.
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered after focus has been transferred to the popup.
         * @instance
         * @ojbubbles
         */
        focus: null,
        /**
         * Triggered when a default animation is about to start, such as when the component is
         * being opened/closed or a child item is being added/removed. The default animation can
         * be cancelled by calling <code class="prettyprint">event.preventDefault</code>.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered when a default animation is about to start, such as when the component is being opened/closed or a child item is being added/removed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {"open"|"close"} action The action that triggers the animation.<br><br>
         *            The number of actions can vary from component to component.
         *            Suggested values are:
         *                    <ul>
         *                      <li>"open" - when a popup component is opened</li>
         *                      <li>"close" - when a popup component is closed</li>
         *                    </ul>
         * @property {!Element} element target of animation
         * @property {!function():void} endCallback If the event listener calls
         *            event.preventDefault to cancel the default animation, It must call the
         *            endCallback function when it finishes its own animation handling and any
         *            custom animation has ended.
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateStart</code> event to override the default
         *          "close" animation:</caption>
         * myPopup.addEventListener("ojAnimateStart", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is close
         *     if (event.detail.action == "close") {
         *       event.preventDefault();
         *       oj.AnimationUtils.slideOut(event.detail.element).then(event.detail.endCallback);
         *   });
         *
         * @example <caption>The default open and close animations are controlled via the theme
         *          (SCSS) :</caption>
         * $popupOpenAnimation: ((effect: "zoomIn"), "fadeIn")  !default;
         * $popupCloseAnimation: ((effect: "zoomOut"), "fadeOut")  !default;
         */
        animateStart: null,
        /**
         * Triggered when a default animation has ended, such as when the component is being
         * opened/closed or a child item is being added/removed. This event is not triggered if
         * the application has called preventDefault on the animateStart
         * event.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojPopup
         * @ojshortdesc Triggered when a default animation had ended, such as when the component is being opened/closed or a child item is being added/removed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {!Element} element target of animation
         * @property {"open"|"close"} action The action that triggered the animation.<br><br>
         *                   The number of actions can vary from component to component.
         *                   Suggested values are:
         *                    <ul>
         *                      <li>"open" - when a popup component is opened</li>
         *                      <li>"close" - when a popup component is closed</li>
         *                    </ul>
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateEnd</code> event to listen for the "close"
         *          ending animation:</caption>
         * myPopup.addEventListener("ojAnimateEnd", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is close
         *     if (event.detail.action == "close") {}
         *   });
         *
         * @example <caption>The default open and close animations are controlled via the theme
         *          (SCSS) :</caption>
         * $popupOpenAnimation: (effect: "zoomIn", fade: true)  !default;
         * $popupCloseAnimation: (effect: "zoomOut", fade: true)  !default;
         */
        animateEnd: null
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @override
       */
      _ComponentCreate: function () {
        this._super();

        var rootStyle = this._getRootStyle();
        var element = this.element;
        element.hide().addClass(rootStyle).attr('aria-hidden', 'true');
        element.addClass('oj-component');

        // Creates a content element and moves the children of the root to the content element
        // and then appends the content element to the root element.
        var content = $('<div>');
        content.addClass([rootStyle, 'content'].join('-'));
        content.attr('role', 'presentation');
        content.attr('data-oj-context', '');
        content.append(element[0].childNodes); // @HTMLUpdateOK move app defined children to content wrapper
        content.appendTo(element); // @HTMLUpdateOK attach programmaticly generated node
        this._content = content;

        this._setChrome();
        this._setupFocus(element);

        this._setDescribedByOnLauncher = false;

        // fixup the position option set via the widget constructor
        var options = this.options;
        options.position = oj.PositionUtils.coerceToJet(options.position);
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @override
       */
      _AfterCreate: function () {
        // first apply rootAttributes that might define an id if unspecified
        this._super();

        // aria-describedby needs an id.  Assign an id to the popup root if not already defined.
        this.element.uniqueId();

        // create the tail with a subid
        this._createTail();
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @override
       */
      _destroy: function () {
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._closeImplicitly();
        }

        this._setWhenReady('none');
        this._destroyTail();
        delete this._popupServiceEvents;

        // make sure the root element is hidden
        var element = this.element;
        element.hide().attr('aria-hidden', 'true').removeUniqueId();

        // Move the children back under the root node removing the content node.
        var content = this._content;
        delete this._content;
        element.append(content[0].childNodes); // @HTMLUpdateOK destructor move children back under root
        content.remove();

        var closeDelayTimer = this._closeDelayTimer;
        if (closeDelayTimer) {
          delete this._closeDelayTimer;
          closeDelayTimer();
        }

        this._super();
      },
      /**
       * Opens the popup. This method accepts two arguments. The first argument "launcher" is
       * required but the second "position" is optional.
       *
       * @expose
       * @method
       * @name oj.ojPopup#open
       * @ojshortdesc Opens the popup.
       * @memberof oj.ojPopup
       * @instance
       * @param {!(string|Element)} launcher selector or dom element that is associated with the
       *        popup. Defines the context of how the popup is used. The argument is required.
       * @param {Object=} position {@link oj.ojPopup.Position} an element relative to another
       * @return {void}
       * @ojsignature { target: "Type",
       *                value: "oj.ojPopup.Position",
       *                for: "position",
       *                jsdocOverride: true}
       * @fires oj.ojPopup#ojBeforeOpen
       * @fires oj.ojPopup#ojOpen
       *
       * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
       * var open = myPopup.open("#launcher");
       */
      open: function (launcher, position) {
        if (this._isOperationPending('open', [launcher, position])) {
          return;
        }

        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._closeImplicitly(); // synchronous close
        }

        var element = this.element;
        var status = oj.ZOrderUtils.getStatus(element);
        if (!(status === oj.ZOrderUtils.STATUS.CLOSE || status === oj.ZOrderUtils.STATUS.UNKNOWN)) {
          return;
        }

        // status change is needed to prevent calling open from an on before open
        // handler.  The _isOperationPending doens't gurard until this._setWhenReady('open');
        oj.ZOrderUtils.setStatus(element, oj.ZOrderUtils.STATUS.BEFORE_OPEN);
        if (this._trigger('beforeOpen') === false) {
          oj.ZOrderUtils.setStatus(this.element, status);
          return;
        }

        // activates the _isOperationPending gatekeeper
        this._setWhenReady('open');

        this._setLauncher(launcher);
        var _launcher = this._launcher;

        var options = this.options;
        // eslint-disable-next-line no-param-reassign
        position = position || options.position;
        if (!position.of) {
          this._hasPositionOfLauncherOverride = true;
          // eslint-disable-next-line no-param-reassign
          position.of = _launcher;
        }

        this._setPosition(position);

        this._setAutoDismiss(options.autoDismiss);

        if (!this._IsCustomElement() || !element[0].hasAttribute('role')) {
          const role = options.modality === 'modal' ? 'dialog' : options.role;
          element.attr('role', role);
        }

        if (options.modality !== 'modal' && element.attr('role') === 'tooltip') {
          this._addDescribedBy();
        }

        // convert to the jquery ui position format
        var _position = this._getPositionAsJqUi();

        // build layer class selectors applied to the popup layer
        var rootStyle = this._getRootStyle();
        var layerClass = [rootStyle, 'layer'].join('-');
        var tailDecoration = options.tail;
        if (tailDecoration !== 'none') {
          layerClass += ' ' + [rootStyle, 'tail', tailDecoration].join('-');
        }

        /** @type {!Object.<oj.PopupService.OPTION, ?>} */
        var psOptions = {};
        psOptions[oj.PopupService.OPTION.POPUP] = element;
        psOptions[oj.PopupService.OPTION.LAUNCHER] = _launcher;
        psOptions[oj.PopupService.OPTION.POSITION] = _position;
        psOptions[oj.PopupService.OPTION.EVENTS] = this._getPopupServiceEvents();
        psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = layerClass;
        psOptions[oj.PopupService.OPTION.MODALITY] = options.modality;
        psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = this._IsCustomElement();
        oj.PopupService.getInstance().open(psOptions);
      },
      /**
       * Before open callback is called after the popup has been reparented into the
       * zorder container. Open animation is performed here.
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the popup
       * @return {Promise|void}
       */
      _beforeOpenHandler: function (psOptions) {
        var element = psOptions[oj.PopupService.OPTION.POPUP];
        var position = psOptions[oj.PopupService.OPTION.POSITION];

        element.show();
        element.position(position);

        // note the initial popup width/height
        this.initialWidth = element.width();
        this.initialHeight = element.height();

        this._initVoiceOverAssist();

        // JET-58635: set initial focus as soon as possible
        this._initialFocus(false);

        // TODO might want to add fadeIn for the modal overlay in the future.
        var animationOptions = this.options.animation;
        if (animationOptions && animationOptions.open) {
          var actionPrefix = animationOptions.actionPrefix;
          var action = actionPrefix ? [actionPrefix, 'open'].join('-') : 'open';
          // eslint-disable-next-line no-undef
          return AnimationUtils.startAnimation(
            element[0],
            action,
            oj.PositionUtils.addTransformOriginAnimationEffectsOption(element, animationOptions.open),
            this
          );
        }

        return undefined;
      },
      /**
       * Called after the popup is shown. Perform open finalization.
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the popup
       * @return {void}
       */
      _afterOpenHandler: function (psOptions) {
        var element = psOptions[oj.PopupService.OPTION.POPUP];
        var launcher = psOptions[oj.PopupService.OPTION.LAUNCHER];

        if (this.initialWidth !== element.width() || this.initialHeight !== element.height()) {
          // if the popup width/height changed during opening, re-apply position constraints
          this._reposition();
        }
        delete this.initialWidth;
        delete this.initialHeight;

        // set up a listener for future size changes
        this._registerResizeListener(element[0]);

        this._trigger('open');

        this._on(element, { keydown: this._keyHandler });
        if (launcher && launcher.length > 0) {
          this._on(launcher, { keydown: this._keyHandler });
        }
      },
      /**
       * Override to retrieve the context menu element from the context area of the popup
       * versus the root.
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @override
       */
      _GetContextMenu: function () {
        if (this._IsCustomElement()) {
          var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(this._content[0]);
          var slot = slotMap.contextMenu;
          if (slot && slot.length > 0) {
            return slot[0];
          }
        } else {
          return this._super();
        }
        return undefined;
      },
      /**
       * Closes the popup. This method does not accept any arguments.
       *
       * @expose
       * @method
       * @name oj.ojPopup#close
       * @ojshortdesc Closes the popup.
       * @memberof oj.ojPopup
       * @instance
       * @return {void}
       * @fires oj.ojPopup#ojBeforeClose
       * @fires oj.ojPopup#ojClose
       *
       * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
       * myPopup.close();
       */
      close: function () {
        if (this._isOperationPending('close', [])) {
          return;
        }

        var element = this.element;
        var status = oj.ZOrderUtils.getStatus(element);
        if (status !== oj.ZOrderUtils.STATUS.OPEN) {
          return;
        }

        // Status toggle is needed to prevent a recursive closed callled from a
        // beforeClose handler. The _isOperationPending gatekeeper isn't activated
        // until after the _setWhenReady('close'|'open') call.
        oj.ZOrderUtils.setStatus(element, oj.ZOrderUtils.STATUS.BEFORE_CLOSE);
        if (this._trigger('beforeClose') === false && !this._ignoreBeforeCloseResultant) {
          oj.ZOrderUtils.setStatus(element, status);
          return;
        }

        // activates the _isOperationPending gatekeeper
        this._setWhenReady('close');

        var launcher = this._launcher;
        this._off(element, 'keydown');
        if (launcher && launcher.length > 0) {
          this._off(launcher, 'keydown');
        }

        // if the content has focus, restore the the launcher
        this._restoreFocus();

        // clean up voice over assist
        this._destroyVoiceOverAssist();

        /** @type {!Object.<oj.PopupService.OPTION, ?>} */
        var psOptions = {};
        psOptions[oj.PopupService.OPTION.POPUP] = element;
        oj.PopupService.getInstance().close(psOptions);
      },
      /**
       * Before callback is invoked while the popup is still visible and still parented in the
       * zorder container. Close animation is performed here.
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the popup
       * @return {Promise|void}
       */
      _beforeCloseHandler: function (psOptions) {
        var element = psOptions[oj.PopupService.OPTION.POPUP];

        this._unregisterResizeListener(element[0]);

        // TODO might want to add fadeOut for the modal overlay in the future.
        var animationOptions = this.options.animation;

        if (!this._ignoreBeforeCloseResultant && animationOptions && animationOptions.close) {
          var actionPrefix = animationOptions.actionPrefix;
          var action = actionPrefix ? [actionPrefix, 'close'].join('-') : 'close';

          /** @type {?} */
          // eslint-disable-next-line no-undef
          var promise = AnimationUtils.startAnimation(
            element[0],
            action,
            oj.PositionUtils.addTransformOriginAnimationEffectsOption(
              element,
              animationOptions.close
            ),
            this
          ).then(function () {
            element.hide();
          });
          return promise;
        }

        element.hide();
        return undefined;
      },
      /**
       * Close finalization callback.
       *
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the popup
       * @return {void}
       */
      // eslint-disable-next-line no-unused-vars
      _afterCloseHandler: function (psOptions) {
        this._removeDescribedBy();
        this._setAutoDismiss();

        delete this._launcher;
        this._trigger('close');

        if (this._hasPositionOfLauncherOverride) {
          var options = this.options;
          options.position.of = null;
          delete this._hasPositionOfLauncherOverride;
        }
      },
      /**
       * <p>Returns the state of whether the popup is currently open. This method does not accept
       * any arguments.</p>
       *
       * The "open" state reflects the period of time the popup is visible, including open and
       * close animations.
       *
       * @expose
       * @method
       * @name oj.ojPopup#isOpen
       * @ojshortdesc Returns the state of whether the popup is currently visible.
       * @memberof oj.ojPopup
       * @instance
       * @return {boolean} <code>true</code> if the popup is open.
       *
       * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
       * var isOpen = myPopup.isOpen();
       */
      isOpen: function () {
        var status = oj.ZOrderUtils.getStatus(this.element);
        // the window is visible and reparented to the zorder container for these statuses
        return (
          status === oj.ZOrderUtils.STATUS.OPENING ||
          status === oj.ZOrderUtils.STATUS.OPEN ||
          status === oj.ZOrderUtils.STATUS.BEFORE_CLOSE ||
          status === oj.ZOrderUtils.STATUS.CLOSING
        );
      },
      /**
       * Causes the popup to reevaluate its position.  Call this function after
       * the content of the popup has dynamically changed while the popup is open.
       *
       * <p>This method does not accept any arguments.</p>
       *
       * @expose
       * @method
       * @name oj.ojPopup#refresh
       * @ojshortdesc Refreshes the popup, causing it to reevaluate its position.
       * @memberof oj.ojPopup
       * @instance
       * @return {void}
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myPopup.refresh();
       */
      refresh: function () {
        this._super();

        if (oj.ZOrderUtils.getStatus(this.element) !== oj.ZOrderUtils.STATUS.OPEN) {
          return;
        }

        if (!this._reposition()) {
          return;
        }

        // trigger refresh of descendents if reposition was successful
        var element = this.element;
        oj.PopupService.getInstance().triggerOnDescendents(
          element,
          oj.PopupService.EVENT.POPUP_REFRESH
        );
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @param {string} key option name
       * @param {?Object} value of the target option identified by the key
       * @override
       */
      _setOption: function (key, value) {
        var options = this.options;
        switch (key) {
          case 'tail':
            if (value !== options.tail) {
              this._setTail(value);
            }
            break;
          case 'chrome':
            if (value !== options.chrome) {
              this._setChrome(value);
            }
            break;
          case 'position':
            this._setPosition(value);
            this.refresh();
            // don't call super because setPosition sets the option after creating a new
            // instance.  This prevents the same position instance from getting registered
            // with multiple component instances.
            return;
          case 'autoDismiss':
            if (
              oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN &&
              value !== options.autoDismiss
            ) {
              this._setAutoDismiss(value);
            }
            break;
          case 'modality':
            if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
              var element = this.element;
              /** @type {!Object.<oj.PopupService.OPTION, ?>} */
              var psOptions = {};
              psOptions[oj.PopupService.OPTION.POPUP] = element;
              psOptions[oj.PopupService.OPTION.MODALITY] = value;
              oj.PopupService.getInstance().changeOptions(psOptions);
            }
            break;
          default:
            break;
        }

        this._superApply(arguments);
      },
      /**
       * Returns the root selector prefix for the popup components.  In the future if the popup is
       * subcassed, this method can be made protected and override to change the root selector names
       * for the target component.
       *
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @return {string}
       */
      _getRootStyle: function () {
        return 'oj-popup';
      },
      /**
       * Handles setting up the target tail.
       *
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string} tail option value
       */
      _setTail: function (tail) {
        this._destroyTail();
        this._createTail(tail);
        this._reposition();
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string} tail option value
       */
      _createTail: function (tail) {
        var tailDecoration = tail || this.options.tail;
        if (tailDecoration === 'none') {
          return;
        }

        var rootStyle = this._getRootStyle();
        var tailMarkerStyle = [rootStyle, 'tail'].join('-');
        var tailStyle = [tailMarkerStyle, tailDecoration].join('-');

        var tailDom = $('<div>').hide();
        tailDom.addClass(tailMarkerStyle).addClass(tailStyle);
        tailDom.attr('role', 'presentation');

        // id over "marker style" due to nesting popups in popups
        this._tailId = tailDom.attr('id', this._getSubId('tail')).attr('id');
        var element = this.element;
        tailDom.appendTo(element); // @HTMLUpdateOK attach programmaticly generated node

        // tail "value" style is applied to the root dom for shadow and z-index adjustments
        element.addClass(tailStyle);

        // The tail can change the z-index of the layer that defines the stacking context
        // of the popup.  If the popup is open, update the layers class.
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          var layerClass = [rootStyle, 'layer'].join('-');
          layerClass += ' ' + tailStyle;

          /** @type {!Object.<oj.PopupService.OPTION, ?>} */
          var options = {};
          options[oj.PopupService.OPTION.POPUP] = element;
          options[oj.PopupService.OPTION.LAYER_SELECTORS] = layerClass;
          oj.PopupService.getInstance().changeOptions(options);
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @return {jQuery}
       */
      _getTail: function () {
        var tailId = this._tailId;
        if (!tailId) {
          return null;
        }

        return $(document.getElementById(tailId));
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _destroyTail: function () {
        var tail = this._getTail();
        if (tail) {
          tail.remove();
        }

        delete this._tailId;

        var tailDecoration = this.options.tail;
        var rootStyle = this._getRootStyle();
        var tailStyle = [rootStyle, 'tail', tailDecoration].join('-');

        var element = this.element;
        element.removeClass(tailStyle);

        // if the popup is open, reseed the layer class removing the
        // tail style.
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          var layerClass = [rootStyle, 'layer'].join('-');
          /** @type {!Object.<oj.PopupService.OPTION, ?>} */
          var options = {};
          options[oj.PopupService.OPTION.POPUP] = element;
          options[oj.PopupService.OPTION.LAYER_SELECTORS] = layerClass;
          oj.PopupService.getInstance().changeOptions(options);
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string} chrome option value
       */
      _setChrome: function (chrome) {
        var chromeDecoration = chrome || this.options.chrome;
        var noChromeStyle = [this._getRootStyle(), 'no-chrome'].join('-');
        var element = this.element;

        if (chromeDecoration === 'default' && element.hasClass(noChromeStyle)) {
          element.removeClass(noChromeStyle);
        } else if (chromeDecoration === 'none' && !element.hasClass(noChromeStyle)) {
          element.addClass(noChromeStyle);
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string|Node|jQuery|null} _launcher provided when the popup is open
       */
      _setLauncher: function (_launcher) {
        var launcher = _launcher;
        if (!launcher) {
          launcher = $(document.activeElement);
        } else if ($.type(launcher) === 'string') {
          // id jquery selector
          launcher = $(launcher);
        } else if (launcher.nodeType === 1) {
          // dom element
          launcher = $(launcher);
        }

        // if a jquery collection, select the first dom node not in the popups content
        if (launcher instanceof $ && launcher.length > 1) {
          var element = this.element;

          for (var i = 0; i < launcher.length; i++) {
            var target = launcher[0];
            if (!DomUtils.isAncestorOrSelf(element[0], target)) {
              launcher = $(target);
              break;
            }
          }
        } else if (
          !(launcher instanceof $) || // object is not a jq
          (launcher instanceof $ && launcher.length === 0)
        ) {
          // empty jq collection
          launcher = $(document.activeElement);
        }

        this._launcher = launcher;
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {?Object} position object set as an option or passed as an argument to the open
       *                  method.
       */
      _setPosition: function (position) {
        var options = this.options;

        // new position extends the existing object
        // covert to jet internal position format
        if (position) {
          options.position = oj.PositionUtils.coerceToJet(position, options.position);
        }
      },

      /**
       * Returns a jQuery UI position object from the internal object.
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @returns {Object}
       */
      _getPositionAsJqUi: function () {
        var options = this.options;
        var position = oj.PositionUtils.coerceToJqUi(options.position);
        var isRtl = this._GetReadingDirection() === 'rtl';
        position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);

        var origUsing = position.using;
        origUsing = $.isFunction(origUsing) ? origUsing : null;

        // override with our proxy to handle positioning of the tail
        // overload the callback arguments forcing the original using as the first argument
        position.using = this._usingHandler.bind(this, origUsing);

        return position;
      },

      /**
       * Resolves a busy state blocking delayed call to implicitly close
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {Function} busyStateResolver
       */
      _resolveBusyStateAndCloseImplicitly: function (busyStateResolver) {
        busyStateResolver();
        delete this._closeDelayTimer;
        this._closeImplicitly();
      },
      /**
       * Cancels the delayed implicit closure.
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {number} timer
       * @param {Function} busyStateResolver
       */
      _resolveBusyStateAndCancelDelayedClosure: function (timer, busyStateResolver) {
        window.clearTimeout(timer);
        busyStateResolver();
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {Function} origUsing position using hander if already provided
       * @param {Object} pos "my" element associated with the position object
       * @param {Object} props directions as to where the element should be moved
       */
      _usingHandler: function (origUsing, pos, props) {
        var element = props.element.element;

        // do nothing if the position is the same
        if (pos.top === element.css('top') && pos.left === element.css('left')) {
          return;
        }

        var tail = this._getTail();
        if (!tail) {
          element.css(pos);
        } else {
          tail.hide();
          for (var i = 0; i < _TAIL_STYLES.length; i++) {
            tail.removeClass(_TAIL_STYLES[i]);
            element.removeClass(_TAIL_STYLES[i]);
          }
          tail.removeAttr('style');

          // 
          // Check if "of" alignment is to a x,y versus a dom element.  The horizontal
          // rule returned from jquery UI position defaults to "left" or "right".  The height and
          // width of the target will be zero when the "of" is not a DOM element.
          // Use the position.my alignment rules over what jquery returns when aligned to a point.
          //
          // jQuery 3.1 made changes to the offset.  The basic refactor was to switch over to using
          // "Element.getBoundingClientRect()".  Part of this refactor will return a offset rect of
          // {top: 0, left: 0} for any element that doesn't have a bounding box
          // "Element.getClientRects()". Many types of SVG elements such as <g> fall into this
          // category.  The popup will appear in the top left of the browser.
          //
          if (props.target && props.target.height === 0 && props.target.width === 0) {
            var isRtl = this._GetReadingDirection() === 'rtl';
            var position = oj.PositionUtils.normalizeHorizontalAlignment(
              this.options.position,
              isRtl
            );
            var myrule = position.my;
            if (!oj.StringUtils.isEmptyOrUndefined(myrule)) {
              // If the original horizontal rule is center, use it; otherwise, use the calculated
              // hint. The left/right rules reflect the actual positioning but center is never
              // represented correctly aligned to a point even though the alignment is correct.
              var suggestedHrule =
                myrule.horizontal === 'center' ? myrule.horizontal : props.horizontal;
              var suggestedVrule = myrule.vertical === 'center' ? 'middle' : myrule.vertical;
              // eslint-disable-next-line no-param-reassign
              props.horizontal = suggestedHrule;
              // eslint-disable-next-line no-param-reassign
              props.vertical = suggestedVrule;
            }
          }

          var alignMnemonic = [props.horizontal, props.vertical].join('-');
          var tailStyle = _TAIL_ALIGN_RULES[alignMnemonic];
          tail.addClass(tailStyle);
          element.addClass(tailStyle);
          tail.show();

          // adjust the vertical and horizontal positioning to account for the tail
          // so that the page developer doesn't have to factor that in
          var borderFactor = 2; // factor in a little extra so the borders overlap
          var tailHOffset;
          if (props.horizontal === 'left') {
            tailHOffset = tail.outerWidth();
            tailHOffset -= tailHOffset + DomUtils.getCSSLengthAsInt(tail.css('left'));
            // eslint-disable-next-line no-param-reassign
            pos.left += tailHOffset - borderFactor;
          } else if (props.horizontal === 'right') {
            tailHOffset = tail.outerWidth();
            tailHOffset -= tailHOffset + DomUtils.getCSSLengthAsInt(tail.css('right'));
            // eslint-disable-next-line no-param-reassign
            pos.left -= tailHOffset - borderFactor;
          }

          var tailVOffset;
          // tail adjustments when the offset of the image is not the total size of the image
          if (props.vertical === 'top') {
            tailVOffset = tail.outerHeight();
            tailVOffset -= tailVOffset + DomUtils.getCSSLengthAsInt(tail.css(props.vertical));
            // eslint-disable-next-line no-param-reassign
            pos.top += tailVOffset - borderFactor;
          } else if (props.vertical === 'bottom') {
            tailVOffset = tail.outerHeight();
            tailVOffset -= tailVOffset + DomUtils.getCSSLengthAsInt(tail.css(props.vertical));
            // eslint-disable-next-line no-param-reassign
            pos.top -= tailVOffset - borderFactor;
          }
          element.css(pos);

          // adjustments to the vertical or horizontal centering.  The 50% alignment is from
          // the edge of the tail versus the center of the image.  The tail can't be located
          // at "center, middle". In this case (dead center), horizintal center looks better
          // on small viewports (_TAIL_ALIGN_RULES["center-middle"] === 'oj-left oj-middle')
          if (props.horizontal === 'center' && props.vertical !== 'middle') {
            var rootWidth = element.width();
            var leftPercent = Math.round(((rootWidth / 2 - tail.outerWidth() / 2) / rootWidth) * 100);
            tail.css({
              left: leftPercent + '%'
            });
          } else if (props.vertical === 'middle') {
            var rootHeight = element.height();
            var topPercent = Math.round(
              ((rootHeight / 2 - tail.outerHeight() / 2) / rootHeight) * 100
            );
            tail.css({
              top: topPercent + '%'
            });
          }
        }

        oj.PositionUtils.captureTransformOriginAnimationEffectsOption(element, props);

        // call on the original using regardless of the tail
        if (origUsing) {
          origUsing(pos, props);
        }

        var options = this.options;

        // The "origUsing" could alter the positon.  This check needs to be last.
        // When focusLoss auto dismissal is enabled, implicitly close the popup when the
        // position.of is clipped in an overflow container.
        if (options.autoDismiss === 'focusLoss') {
          if (oj.PositionUtils.isAligningPositionClipped(props)) {
            // Ignore focus back to what had focus before the popup was open. Focus
            // restore could fight scroll if the popup was closed due to the aligning
            // element being clipped.
            this._ignoreRestoreFocus = true;

            // operation needs to happen in the next stacking frame and guarded by a
            // busy state.
            var busyContext = Context.getContext(this.element[0]).getBusyContext();
            var bsOptions = {
              description: [
                "ojPopup identified by '",
                this.element.attr('id'),
                "' is pending implicit closure."
              ].join('')
            };
            var resolver = busyContext.addBusyState(bsOptions);
            // prettier-ignore
            var delayTimer = window.setTimeout( // @HTMLUpdateOK
              this._resolveBusyStateAndCloseImplicitly.bind(this, resolver),
              0
            );

            this._closeDelayTimer = this._resolveBusyStateAndCancelDelayedClosure.bind(
              this,
              delayTimer,
              resolver
            );
          }
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @return {boolean} <code>false</code> if the position was skipped
       */
      _reposition: function () {
        var element = this.element;
        var position = this._getPositionAsJqUi();

        // verify selector is valid; otherwise, skip the reposition
        if (oj.StringUtils.isString(position.of)) {
          var jqOf = $(position.of);
          if (jqOf.length === 0) {
            return false;
          }

          position.of = jqOf;
        }

        if (this.element.width() > window.innerWidth || this.element.height() > window.innerHeight) {
          return false;
        }

        element.position(position);
        return true;
      },

      /**
       * Unregister event listeners for resize the popup element.
       * @param {Element} element  DOM element
       * @private
       */
      _unregisterResizeListener: function (element) {
        if (element && this._resizeHandler) {
          // remove existing listener
          DomUtils.removeResizeListener(element, this._resizeHandler);
          this._resizeHandler = null;
        }
      },

      /**
       * Register event listeners for resize the popup element.
       * @param {Element} element  DOM element
       * @private
       */
      _registerResizeListener: function (element) {
        if (element) {
          if (this._resizeHandler == null) {
            this._resizeHandler = this._handleResize.bind(this);
          }
          DomUtils.addResizeListener(element, this._resizeHandler, 30, true);
        }
      },

      /**
       * Resize handler to adjust popup position when the size changes after
       * initial render.
       *
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _handleResize: function () {
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._reposition();
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {boolean=} waiAriaAssisted focus established via keyboard or voice over versus from
       *        open API
       */
      _initialFocus: function (waiAriaAssisted) {
        // postpone setting focus until the content has been upgraded
        var busyContext = oj.Context.getContext(this._content[0]).getBusyContext();
        busyContext.whenReady().then(
          function () {
            var initialFocus = this._deriveInitialFocus();
            if (waiAriaAssisted || initialFocus !== 'none') {
              var element = this.GetFocusElement();
              element.focus();
              this._trigger('focus');
            }
          }.bind(this)
        );
      },

      /**
       * Returns the current focusable element for this component which can be the root custom element
       * or an HTML element like an input or select.
       * @return {Element}
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @override
       */
      GetFocusElement: function () {
        var activeElement = document.activeElement;
        if (activeElement && this._isFocusInPopup(activeElement)) {
          return activeElement;
        }

        var initialFocus = this._deriveInitialFocus();

        if (initialFocus === 'none') {
          initialFocus = 'popup';
        }

        var element;
        if (initialFocus === 'firstFocusable') {
          var content = this._content;
          var nodes = content.find(':focusable');

          for (var i = 0; i < nodes.length; i++) {
            if (FocusUtils.isFocusable(nodes[i])) {
              element = $(nodes[i]);
              break;
            }
          }

          if (!element) {
            // nothing to set focus to, default to "popup"
            initialFocus = 'popup';
          }
        }

        // Establish focus to the root element of the popup.  It's not a natural focus stop
        if (initialFocus === 'popup') {
          var closeSkipLink = this._closeSkipLink;
          if (closeSkipLink) {
            element = closeSkipLink.getLink();
          } else {
            element = this.element;
            element.attr('tabindex', '-1');
          }
        }

        return element[0];
      },

      /**
       * @memberof oj.ojPopup
       * @private
       * @return {string} derives the target initialFocus option when the default is auto
       */
      _deriveInitialFocus: function () {
        var options = this.options;
        var initialFocus = options.initialFocus;

        if (initialFocus === 'auto') {
          var modality = options.modality;
          if (modality === 'modal') {
            if (DomUtils.isTouchSupported()) {
              initialFocus = 'popup';
            } else {
              initialFocus = 'firstFocusable';
            }
          } else {
            initialFocus = 'none';
          }
        }

        return initialFocus;
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {Element} activeElement from the event being handled
       * @param {boolean!} includeChildren when true the focus test will include the scope of any
       *                   child popups.
       * @return {boolean} <code>true</code> if the active element is within the content of the
       *                   popup
       */
      _isFocusInPopup: function (activeElement, includeChildren) {
        if (!activeElement) {
          // eslint-disable-next-line no-param-reassign
          activeElement = document.activeElement;
        }

        // added to avoid automation issues where an active element is not established
        if (!activeElement) {
          return false;
        }

        var element = this.element;

        // popups that are children are siblings to the parent popup within the
        // layer that defines the stacking context.
        if (includeChildren) {
          element = element.parent();
        }

        return DomUtils.isAncestorOrSelf(element[0], activeElement);
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {Element} activeElement from the event being handled
       * @return {boolean} <code>true</code> if the active element the launcher or a decedent of the
       *         launcher
       */
      _isFocusInLauncher: function (activeElement) {
        if (!activeElement) {
          // eslint-disable-next-line no-param-reassign
          activeElement = document.activeElement;
        }

        var launcher = this._launcher;
        return DomUtils.isAncestorOrSelf(launcher[0], activeElement);
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _restoreFocus: function () {
        if (this._ignoreRestoreFocus) {
          delete this._ignoreRestoreFocus;
          return;
        }

        // extend the focus check to include popups that are children
        if (this._isFocusInPopup(null, true)) {
          var launcher = this._launcher;
          launcher.focus();
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {jQuery.Event|Event} event keydown
       */
      _keyHandler: function (event) {
        if (event.isDefaultPrevented()) {
          return;
        }

        var content = this._content;
        var options;
        var launcher;

        /** @type {?} */
        var target = event.target;
        if (
          event.keyCode === $.ui.keyCode.ESCAPE &&
          (this._isFocusInPopup(target) || this._isFocusInLauncher(target))
        ) {
          event.preventDefault();
          event.stopPropagation();
          this.close();
        } else if (event.keyCode === 117 || event.key === 'F6') {
          // F6 - toggle focus to launcher or popup
          // keyCode is deprecated and it's not supported on some browsers.
          if (this._isFocusInPopup(target)) {
            // If this is a modeless popup, toggle focus to the launcher;
            // otherwise, close the popup as we can't set focus under the
            // modal glass pane.
            options = this.options;
            if (options.modality === 'modeless') {
              event.preventDefault();
              launcher = this._launcher;
              launcher.focus();
            } else {
              this.close();
            }
          } else if (this._isFocusInLauncher(target)) {
            event.preventDefault();
            this._initialFocus(true);
          }
        } else if (event.keyCode === $.ui.keyCode.TAB && this._isFocusInPopup(target)) {
          // TAB within popup
          var nodes = content.find(':tabbable');
          if (nodes.length > 0) {
            var firstNode = nodes[0];
            var lastNode = nodes[nodes.length - 1];
            var element = this.element;

            if ((firstNode === target || element[0] === target) && event.shiftKey) {
              // tabbing backwards, cycle focus to last node
              event.preventDefault();
              // If the first and last tab stops are the same,
              // force focus to the root popup dom.  This will
              // cause the blur to fire on any input components.
              // If we are back tabbing on the popup dom, jump to the
              // last tab stop.
              if (firstNode === lastNode && firstNode === target) {
                element.attr('tabindex', '-1');
                element.focus();
              } else {
                $(lastNode).focus(); // tabbing backwards, cycle focus to last node
              }
            } else if (lastNode === target && !event.shiftKey) {
              event.preventDefault();
              // If the first and last tab stops are the same,
              // force focus to the root popup dom.  This will
              // cause the blur to fire on any input components.
              if (lastNode === firstNode) {
                element.attr('tabindex', '-1');
                element.focus();
              } else {
                $(firstNode).focus(); // tabbing forwards, cycle to the first node
              }
            }
          } else {
            event.preventDefault();
            options = this.options;
            if (options.modality === 'modeless') {
              // if there is nothing in the popup that is tabbable, handle as a F6
              // toggle to the launcher
              launcher = this._launcher;
              launcher.focus();
            } else {
              // Modal popup can't set focus to something under the overlay,
              // implicitly close.
              this.close();
            }
          }
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string|null} autoDismiss option value
       */
      _setAutoDismiss: function (autoDismiss) {
        // unregister any existing handlers, might need to add mouseOut in the future
        var focusLossCallback = this._focusLossCallback;
        var events = this._getPopupServiceEvents();
        if (focusLossCallback) {
          delete events[oj.PopupService.EVENT.POPUP_AUTODISMISS];
          delete this._focusLossCallback;
        }

        if (autoDismiss === 'focusLoss') {
          focusLossCallback = this._dismissalHandler.bind(this);
          this._focusLossCallback = focusLossCallback;
          events[oj.PopupService.EVENT.POPUP_AUTODISMISS] = focusLossCallback;
        }

        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          var element = this.element;
          /** @type {!Object.<oj.PopupService.OPTION, ?>} */
          var options = {};
          options[oj.PopupService.OPTION.POPUP] = element;
          options[oj.PopupService.OPTION.EVENTS] = events;
          oj.PopupService.getInstance().changeOptions(options);
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {Event} event native doc
       */
      _dismissalHandler: function (event) {
        if (oj.ZOrderUtils.getStatus(this.element) !== oj.ZOrderUtils.STATUS.OPEN) {
          return;
        }

        var launcher = this._launcher;
        var element = this.element;

        // child popups are siblings to the parent in the layer.
        var layer = element.parent();

        /** @type {?} */
        var target = event.target;

        // if the target is on the focus skip link next to the launcher, ignore.
        var focusSkipLink = this._focusSkipLink;
        if (focusSkipLink) {
          var link = focusSkipLink.getLink();
          if (link && DomUtils.isAncestorOrSelf(link[0], target)) {
            return;
          }
        }

        // if event target is not under the laucher or popup root dom subtrees, dismiss
        if (
          !DomUtils.isAncestorOrSelf(launcher[0], target) &&
          !DomUtils.isAncestorOrSelf(layer[0], target)
        ) {
          var tabindexAttr = target.getAttribute('tabindex');
          if (FocusUtils.isFocusable(target) && tabindexAttr !== '-1') {
            // If the dismissal event target can take focus and the
            // event type is a mousedown or touchstart, wait for the focus event
            // to trigger dismissal.  This allows the blur to happen
            // on input components which triggers validation.
            if (event.type === 'mousedown' || event.type === 'touchstart') {
              return;
            }

            this._ignoreRestoreFocus = true;
          }

          // invoke standard close dismissal that can be canceled via the beforeclose
          // event.
          this.close();
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _addDescribedBy: function () {
        var launcher = this._launcher;
        var element = this.element;

        var popupId = element.attr('id');
        var describedby = launcher.attr('aria-describedby');
        var tokens = describedby ? describedby.split(/\s+/) : [];
        tokens.push(popupId);
        describedby = $.trim(tokens.join(' '));
        launcher.attr('aria-describedby', describedby);
        this._setDescribedByOnLauncher = true;
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _removeDescribedBy: function () {
        if (!this._setDescribedByOnLauncher) {
          return;
        }

        var launcher = this._launcher;
        var element = this.element;

        if (!launcher || launcher.length === 0) {
          return;
        }

        var popupId = element.attr('id');
        var describedby = launcher.attr('aria-describedby');
        var tokens = describedby ? describedby.split(/\s+/) : [];
        var index = $.inArray(popupId, tokens);
        if (index !== -1) {
          tokens.splice(index, 1);
        }

        describedby = $.trim(tokens.join(' '));
        if (describedby) {
          launcher.attr('aria-describedby', describedby);
        } else {
          launcher.removeAttr('aria-describedby');
        }
        this._setDescribedByOnLauncher = false;
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _initVoiceOverAssist: function () {
        var isModal = this.options.modality === 'modal';
        var isVOSupported =
          oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS ||
          oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;
        var message;

        if (!isModal) {
          // for non-modal popups install the live region for keybard/VO navigation
          var liveRegion = this._liveRegion;
          if (!liveRegion) {
            liveRegion = new ojpopupcore.PopupLiveRegion();
            this._liveRegion = liveRegion;
          }
          var initialFocus = this._deriveInitialFocus();
          if (isVOSupported) {
            message = this.getTranslatedString(
              initialFocus === 'none'
                ? 'ariaLiveRegionInitialFocusNoneTouch'
                : 'ariaLiveRegionInitialFocusFirstFocusableTouch'
            );
          } else {
            message = this.getTranslatedString(
              initialFocus === 'none'
                ? 'ariaLiveRegionInitialFocusNone'
                : 'ariaLiveRegionInitialFocusFirstFocusable'
            );
          }
          liveRegion.announce(message);
        }

        if (isVOSupported) {
          var callback;

          if (!isModal) {
            var focusSkipLinkId = this._getSubId('focusSkipLink');
            var launcher = this._launcher;
            callback = this._initialFocus.bind(this, true);
            message = this.getTranslatedString('ariaFocusSkipLink');
            this._focusSkipLink = new ojpopupcore.PopupSkipLink(launcher, message, callback, focusSkipLinkId);
          }

          var content = this._content;
          var closeSkipLinkId = this._getSubId('closeSkipLink');
          callback = this._closeImplicitly.bind(this);
          message = this.getTranslatedString('ariaCloseSkipLink');
          this._closeSkipLink = new ojpopupcore.PopupSkipLink(content, message, callback, closeSkipLinkId);
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _destroyVoiceOverAssist: function () {
        var liveRegion = this._liveRegion;
        if (liveRegion) {
          liveRegion.destroy();
          delete this._liveRegion;
        }

        var focusSkipLink = this._focusSkipLink;
        if (focusSkipLink) {
          focusSkipLink.destroy();
          delete this._focusSkipLink;
        }

        var closeSkipLink = this._closeSkipLink;
        if (closeSkipLink) {
          closeSkipLink.destroy();
          delete this._closeSkipLink;
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string} sub id that will become a composite id prefixed with the components uuid
       * @return {string}
       */
      _getSubId: function (sub) {
        /** @type {?} */
        var id = this.element.attr('id');
        if (oj.StringUtils.isEmptyOrUndefined(id)) {
          id = this.uuid;
        }
        return [id, sub].join('_');
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _surrogateRemoveHandler: function () {
        // In all cases except when the dialog is already open, removal of the
        // surrogate during opening or closing will result in implicit removal.
        // 1) CLOSING: Handled in oj.ZOrderUtils.removeFromAncestorLayer.  If the
        //    surrogate doesn't exist the layer containing the popup dom is detached.
        // 2) OPENING: in the PopupServiceImpl#open _finalize, if the surrogate doesn't
        //    exist after in the open state, this remove callback is invoked.
        //
        // Custom element will call _NotifyDetached after element.remove but
        // but jquery UI instances will invoke the _destory method.

        var element = this.element;
        var status = oj.ZOrderUtils.getStatus(element);
        if (status === oj.ZOrderUtils.STATUS.OPEN) {
          ojcustomelementUtils.CustomElementUtils.cleanComponentBindings(element[0]);
          element.remove();
        }
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @return {!Object.<oj.PopupService.EVENT, function(...)>}
       */
      _getPopupServiceEvents: function () {
        if (!this._popupServiceEvents) {
          /** @type {!Object.<oj.PopupService.EVENT, function(...)>} **/
          var events = {};
          this._popupServiceEvents = events;
          events[oj.PopupService.EVENT.POPUP_CLOSE] = this._closeImplicitly.bind(this);
          events[oj.PopupService.EVENT.POPUP_REMOVE] = this._surrogateRemoveHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_REFRESH] = this.refresh.bind(this);
          events[oj.PopupService.EVENT.POPUP_BEFORE_OPEN] = this._beforeOpenHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_AFTER_OPEN] = this._afterOpenHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_BEFORE_CLOSE] = this._beforeCloseHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_AFTER_CLOSE] = this._afterCloseHandler.bind(this);
        }
        return this._popupServiceEvents;
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _closeImplicitly: function () {
        this._ignoreBeforeCloseResultant = true;
        this.close();
        delete this._ignoreBeforeCloseResultant;
      },
      /**
       * Creates a Promise exposed by the {@link oj.ojPopup#whenReady} method.
       *
       * @param {string} operation valid values are "open", "close" or "none"
       * @memberof oj.ojPopup
       * @instance
       * @private
       */
      _setWhenReady: function (operation) {
        /** @type {PopupWhenReadyMediator} */
        var mediator = this._whenReadyMediator;
        if (mediator) {
          mediator.destroy();
          delete this._whenReadyMediator;
        }

        // operation === none
        if (['open', 'close'].indexOf(operation) < 0) {
          return;
        }

        this._whenReadyMediator = new ojpopupcore.PopupWhenReadyMediator(
          this.element,
          operation,
          'ojPopup',
          this._IsCustomElement()
        );
      },

      /**
       * Checks to see if there is a pending "open" or "close" operation.  If pending and it
       * is the same as the requested operation, the request silently fails.  If the current
       * operation is the inverse operation, we queue the current operation after the pending
       * operation is resolved.
       *
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {string} operation currently requested
       * @param {Array} args passed to a queue operation
       * @returns {boolean} <code>true</code> if a close or open operation is pending completion.
       */
      _isOperationPending: function (operation, args) {
        /** @type {oj.PopupWhenReadyMediator} **/
        var mediator = this._whenReadyMediator;
        if (mediator) {
          return mediator.isOperationPending(this, operation, operation, args);
        }
        return false;
      },
      /**
       * @memberof oj.ojPopup
       * @instance
       * @private
       * @param {jQuery} elem to manage the focus ring on
       */
      _setupFocus: function (elem) {
        var self = this;
        this._focusable({
          applyHighlight: true,
          setupHandlers: function (focusInHandler, focusOutHandler) {
            self._on(elem, {
              focus: function (event) {
                focusInHandler($(event.currentTarget));
              },
              blur: function (event) {
                focusOutHandler($(event.currentTarget));
              }
            });
          }
        });
      },
      /**
       * Notifies the component that its subtree has been removed from the document
       * programmatically after the component has been created.
       *
       * @memberof oj.ojPopup
       * @instance
       * @protected
       * @override
       */
      _NotifyDetached: function () {
        // detaching an open popup results in implicit dismissal
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._closeImplicitly();
        }

        this._super();
      }
    });

    const animationVars = {
      open: '--oj-private-popup-global-open-animation-default',
      close: '--oj-private-popup-global-close-animation-default'
    };
    // sets the default modality option from the current theme
    Components.setDefaultOptions({
      ojPopup: {
        modality: Components.createDynamicPropertyGetter(function () {
          return ThemeUtils.getCachedCSSVarValues(['--oj-private-popup-global-modality-default'])[0];
        }),
        animation: Components.createDynamicPropertyGetter(function () {
          const animationDefaultOptions = {};
          const keys = Object.keys(animationVars);
          const vars = keys.map((key) => animationVars[key]);
          const values = ThemeUtils.getCachedCSSVarValues(vars);
          keys.forEach((key, i) => {
            animationDefaultOptions[key] = JSON.parse(values[i]);
          });
          return animationDefaultOptions;
        })
      }
    });
  })();

  (function () {
var __oj_popup_metadata = 
{
  "properties": {
    "autoDismiss": {
      "type": "string",
      "enumValues": [
        "focusLoss",
        "none"
      ],
      "value": "focusLoss"
    },
    "chrome": {
      "type": "string",
      "enumValues": [
        "default",
        "none"
      ],
      "value": "default"
    },
    "initialFocus": {
      "type": "string",
      "enumValues": [
        "auto",
        "firstFocusable",
        "none",
        "popup"
      ],
      "value": "auto"
    },
    "modality": {
      "type": "string",
      "enumValues": [
        "modal",
        "modeless"
      ],
      "value": "modeless"
    },
    "position": {
      "type": "object",
      "properties": {
        "at": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ],
              "value": "start"
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ],
              "value": "bottom"
            }
          }
        },
        "collision": {
          "type": "string",
          "enumValues": [
            "fit",
            "flip",
            "flipcenter",
            "flipfit",
            "none"
          ],
          "value": "flip"
        },
        "my": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ],
              "value": "start"
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ],
              "value": "top"
            }
          }
        },
        "of": {
          "type": "string|object"
        },
        "offset": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "value": 0
            },
            "y": {
              "type": "number",
              "value": 0
            }
          }
        }
      }
    },
    "tail": {
      "type": "string",
      "enumValues": [
        "none",
        "simple"
      ],
      "value": "none"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaCloseSkipLink": {
          "type": "string"
        },
        "ariaFocusSkipLink": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusFirstFocusable": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusFirstFocusableTouch": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusNone": {
          "type": "string"
        },
        "ariaLiveRegionInitialFocusNoneTouch": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "close": {},
    "getProperty": {},
    "isOpen": {},
    "open": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeClose": {},
    "ojBeforeOpen": {},
    "ojClose": {},
    "ojFocus": {},
    "ojOpen": {}
  },
  "extension": {}
};
    __oj_popup_metadata.extension._WIDGET_NAME = 'ojPopup';
    __oj_popup_metadata.extension._CONTROLS_SUBTREE_HIDDEN = true;
    oj.CustomElementBridge.register('oj-popup', { metadata: __oj_popup_metadata });
  })();

});


define('ojs/ojlabel',['ojs/ojcore', 'ojs/ojjquery-hammer', 'ojs/ojcomponentcore', 'ojs/ojpopup', 'ojs/ojcore-base', 'jquery', 'hammerjs', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojdomutils'], function (ojcore, ojjqueryHammer, ojcomponentcore, ojpopup, oj, $, hammerjs, ojlogger, Context, DomUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  (function () {
    /**
     * String used in the id on the span that surrounds the help icon.
     * @const
     * @private
     * @type {string}
     */
    const _HELP_ICON_ID = '_helpIcon';
    /**
     * String used in the id on the span that surrounds the required icon.
     * @const
     * @private
     * @type {string}
     */
    const _REQUIRED_ICON_ID = '_requiredIcon';

    /**
     * aria-describedby
     * @const
     * @private
     * @type {string}
     */
    const _ARIA_DESCRIBEDBY = 'aria-describedby';
    /**
     * described-by
     * @const
     * @private
     * @type {string}
     */
    const _DESCRIBED_BY = 'described-by';
    /**
     * aria-labelledby
     * @const
     * @private
     * @type {string}
     */
    const _ARIA_LABELLEDBY = 'aria-labelledby';
    /**
     * labelled-by
     * @const
     * @private
     * @type {string}
     */
    const _LABELLED_BY = 'labelled-by';

    /**
     * time to close the popup
     * @const
     * @private
     * @type {number}
     */
    const _CLOSE_POPUP_TIME = 200;

    /**
     * @const
     * @private
     * @type {string}
     */
    const _DATA_OJ_INPUT_ID = 'data-oj-input-id';

    /**
     * @const
     * @private
     * @type {string}
     */
    const _ARIA_LABEL = 'aria-label';

    /**
     * @const
     * @private
     * @type {string}
     */
    const OJ_LABEL_HELP_ICON_CLASS = '.oj-label-help-icon';

    /*!
     * JET oj-label. @VERSION
     */
    /**
     * <p>
     * The oj-label component decorates the label text with a required icon and help icon. The user
     * can interact with the help icon (on hover, on focus, etc) to display help description text
     * or to navigate to an url for more help information.
     * </p>
     * <p>For accessibility reasons, you need to associate the oj-label component to its
     * JET form component. For most JET form components you do this
     * using the oj-label's <code class="prettyprint">for</code> attribute and
     * the JET form component's <code class="prettyprint">id</code> attribute.
     * For a few JET form components
     * (oj-radioset, oj-checkboxset, oj-color-palette, and oj-color-spectrum)
     * you associate the oj-label component to its JET form component using
     * the oj-label's <code class="prettyprint">id</code> attribute and the
     * JET form component's <code class="prettyprint">labelled-by</code> attribute.
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-label for="inputtextid" show-required="[[isRequired]]"
     * help.definition="[[helpDef]]" help.source="[[helpSource]]">input label&lt;/oj-label>
     * &lt;oj-input-text id="inputtextid" required="[[isRequired]]">&lt;//oj-input-text>
     *
     * &lt;oj-label id="radiosetlabel" show-required="[[isRequired]]">radioset&lt;/oj-label>
     * &lt;oj-radioset required="[[isRequired]]" labelled-by="radiosetlabel">
     *   &lt;oj-option name="color" value="red">Red&lt;/oj-option>
     *   &lt;oj-option name="color" value="blue">Blue&lt;/oj-option>
     * &lt;/oj-radioset>
     *
     * &lt;!--  You can bind the text as a child comment node or on a span element, but not on the
     * oj-label element. The knockout text binding is not supported on a JET custom element; -->
     * &lt;oj-label for="input2">&lt;!--ko text: input2Label -->&lt;!--/ko-->&lt;/oj-label>
     * </code>
     * </pre>
     * <p>
     * </p>
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>For accessibility reasons, you need to associate the oj-label component to its
     * JET form component. For most JET form components you do this
     * using the oj-label's <code class="prettyprint">for</code> attribute and
     * the JET form component's <code class="prettyprint">id</code> attribute. For more examples,
     * refer to the JET form component's API jsdoc.
     * </p>

     *
     * @ojcomponent oj.ojLabel
     * @ojshortdesc A label is a short description of requested input.
     * @since 4.0.0
     * @augments oj.baseComponent
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["for", "showRequired"]}
     * @ojvbdefaultcolumns 3
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-label'
     * @ojuxspecs ['label']
     */

    /**
     * Removes the label functionality completely.
     * This will return the element back to its pre-init state.
     *
     * <p>This method does not accept any arguments.
     *
     * @method
     * @name oj.ojLabel#destroy
     * @memberof oj.ojLabel
     * @instance
     * @ignore
     *
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojLabel( "destroy" );
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan=2>Help Icon</td>
     *       <td><kbd>Tap and Hold</kbd></td>
     *       <td>Show the help definition in a popup</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tap</kbd></td>
     *       <td>If no help source, show the help definition in a popup.
     *       If help source, navigate to the url.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojLabel
     * @instance
     */
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan=2>Help Icon</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>If there is an url associated with help icon, navigate to the url.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Show the help definition in a popup.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojLabel
     * @instance
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the label's help icon.</p>
     *
     * @ojsubid oj-label-help-icon
     * @memberof oj.ojLabel
     *
     * @example <caption>Get the node for the help icon:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-label-help-icon'});
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------

    // ---------------- oj-focus-highlight --------------
    /**
     * Under normal circumstances this class is applied automatically.
     * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojLabel
     * @ojtsexample
     * &lt;oj-label class="oj-focus-highlight">
     *   &lt;!-- Content -->
     * &lt;/oj-label>
     */
    // ---------------- oj-label-accesskey --------------
    /**
     * Use this in a span around a single text character in the oj-label's text. It styles the character in a way that indicates to the user that this character is the accesskey. <br/>
     * Use this in conjunction with the HTML accesskey attribute on the oj-label element.<br/>
     * @ojstyleclass oj-label-accesskey
     * @ojdisplayname AccessKey
     * @memberof oj.ojLabel
     * @ojdeprecated [{since: "6.0.0", description: "JET's accessibility team discourages access keys, so this styleclass has been deprecated."}]
     * @ojtsexample
     * &lt;oj-label class="oj-label-accesskey">
     *   &lt;!-- Content -->
     * &lt;/oj-label>
     */
    // ---------------- oj-label-nowrap --------------
    /**
     * Place on the oj-label element to have it not wrap when you don't want to use the responsive design classes (e.g., oj-md-labels-nowrap or oj-md-label-nowrap).
     * @ojstyleclass oj-label-nowrap
     * @ojdisplayname No Wrap
     * @memberof oj.ojLabel
     * @ojtsexample
     * &lt;oj-label class="oj-label-nowrap">
     *   &lt;!-- Content -->
     * &lt;/oj-label>
     */
    // ---------------- oj-label-inline --------------
    /**
     * Place on the oj-label element to inline the label with the sibling DOM element when you don't want to use the responsive design classes (e.g., oj-md-labels-inline).
     * @ojstyleclass oj-label-inline
     * @ojdisplayname Inline
     * @ojdeprecated [{since: "9.0.0", description: "This class is not supported in the Redwood theme, and will be removed from the JET API in a future release. Use a JET oj-label-value with label-edge='start' instead."}]
     * @memberof oj.ojLabel
     * @ojtsexample
     * &lt;oj-label class="oj-label-inline">
     *   &lt;!-- Content -->
     * &lt;/oj-label>
     */
    // ---------------- oj-label-inline-top --------------
    /**
     * Place on the oj-label element together with oj-label-inline to inline the label with the sibling DOM element and have zero margin-top.
     * @ojstyleclass oj-label-inline-top
     * @ojdisplayname Inline Top
     * @ojdeprecated [{since: "9.0.0", description: "This class is not supported in the Redwood theme, and will be removed from the JET API in a future release. Use a JET oj-label-value with label-edge='start' instead."}]
     * @memberof oj.ojLabel
     * @ojtsexample
     * &lt;oj-label class="oj-label-inline-top">
     *   &lt;!-- Content -->
     * &lt;/oj-label>
     */
    /**
     * @ojstylevariableset oj-label-css-set1
     * @ojstylevariable oj-label-font-size {description: "Label font size", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-label-font-weight {description: "Label font weight", formats: ["font_weight"], help: "#css-variables"}
     * @ojstylevariable oj-label-line-height {description: "Label line height", formats: ["number"], help: "#css-variables"}
     * @ojstylevariable oj-label-color {description: "Label font color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-label-color-disabled {description: "Disabled label font color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-label-required-char-font-size {description: "Label required char font size", formats: ["length"], help: "css-variables"}
     * @ojstylevariable oj-label-required-icon-color {description: "Label required icon color", formats: ["color"], help: "#css-variables"}
     * @memberof oj.ojLabel
     */
    /**
     * @ojstylevariableset oj-label-css-set2
     * @ojdisplayname Inside label CSS
     * @ojstylevariable oj-label-inside-edge-font-size {description: "Inside label font size", formats: ["length"], help: "#oj-label-css-set2"}
     * @ojstylevariable oj-label-inside-edge-font-weight {description: "Inside label font weight", formats: ["font_weight"], help: "oj-label-css-set2"}
     * @ojstylevariable oj-label-inside-edge-line-height {description: "Inside label edge line height", formats: ["number"], help: "#oj-label-css-set2"}
     * @ojstylevariable oj-label-inside-edge-position-top {description: "Inside label edge position top", formats: ["length"], help: "#oj-label-css-set2"}
     * @ojstylevariable oj-label-inside-edge-color {description: "Inside label edge color", formats: ["color"], help: "#oj-label-css-set2"}
     * @memberof oj.ojLabel
     */
    oj.__registerWidget('oj.ojLabel', $.oj.baseComponent, {
      version: '1.0.0',
      defaultElement: '<label>',
      widgetEventPrefix: 'oj',
      options: {
        /**
         * <p>
         * The <code class="prettyprint">for</code> attribute refers to the id of the
         * element this oj-label element is associated with.
         * Some JET form components support using oj-label's <code class="prettyprint">for</code>
         *  attribute to point to its <code class="prettyprint">id</code> attribute
         * (e.g., oj-input-text, oj-slider), and others do not (e.g., oj-checkboxset).
         * <p>
         * For the oj-radioset, oj-checkboxset, oj-color-palette, and oj-color-spectrum components,
         * instead of the <code class="prettyprint">for</code> attribute, use the
         * <code class="prettyprint">id</code> attribute on oj-label
         * with JET's form element's <code class="prettyprint">labelled-by</code> attribute.
         * </p>
         * <p>
         * Refer to the JET's form element's documentation for more examples showing the
         * use of <code class="prettyprint">for</code>/<code class="prettyprint">id</code>
         * and the use of <code class="prettyprint">id</code>/<code class="prettyprint">labelled-by</code>.
         * </p>
         *
         * @expose
         * @memberof oj.ojLabel
         * @ojshortdesc Specifies the form element associated with this label. See the Help documentation for more information.
         * @instance
         * @type {string|null}
         * @default null
         * @since 4.0.0
         *
         * @example <caption>Associate oj-label to the oj-input-text using the
         * <code class="prettyprint">for</code> attribute on oj-label and the
         * <code class="prettyprint">id</code> attribute on oj-input-text during initialization.</caption>
         * &lt;oj-label for="inputId">Name:&lt;/oj-label>
         * &lt;oj-input-text id="inputId">&lt;/oj-input-text>
         *
         */
        for: null,
        /**
         * The help information that goes on the oj-label.  The help attributes are:
         * <ul>
         * <li><code class="prettyprint">definition</code> - this is the help definition text.
         * It is what shows up
         * when the user hovers over the help icon, or tabs into the help icon, or press
         * and holds the help icon on a mobile device. No formatted text is available for
         * help definition attribute.</li>
         * <li><code class="prettyprint">source</code> - this is the help source url.
         * If present, a help icon will
         * render next to the label. For security reasons
         *  we only support urls with protocol http: or https:.
         * If the url doesn't comply we ignore it and throw an error.
         * Pass in an encoded URL since we do not encode the URL.
         * </ul>
         *
         * @expose
         * @memberof oj.ojLabel
         * @ojshortdesc Help information associated with this label.
         * @instance
         * @type {Object|null}
         * @default {'definition' :null, 'source': null}
         * @since 4.0.0
         *
         * @example <caption>Initialize the label with the help definition and help source:</caption>
         * &lt;!-- Using dot notation -->
         * &lt;oj-label help.definition="some help definition" help.source="some external url">Name:&lt;/oj-label>
         * &lt;!-- Using JSON notation -->
         * &lt;oj-label help='{"definition":"some value", "source":"someurl"}'>Name:&lt;/oj-label>
         * @example <caption>Set the <code class="prettyprint">help</code> attribute, after initialization:</caption>
         *
         * // Set one, leaving the others intact. Use the setProperty API for
         * // subproperties so that a property change event is fired.
         * myComponent.setProperty('help.definition', 'some new value');
         * // Get all
         * var values = myComponent.help;
         * // Set all.  Must list every key, as those not listed are lost.
         * myComponent.help = {
         *   definition: 'some new value',
         *   source: 'some new url'
         * };
         * @property {(string|null)=} definition help definition text
         * @property {(string|null)=} source help source url
         */
        help: {
          definition: null,
          source: null
        },
        /**
         * <code class="prettyprint">label-id</code> sets the <code class="prettyprint">id</code>
         * attribute on the internal label element.  The use case where this may be needed
         * is if you are using a <code class="prettyprint">&lt;div aria-labelledby></code>
         * and for accessibility reasons you need to point to the
         * oj-label's <code class="prettyprint">label</code>
         * element. This should be a corner case. Most often you'd use oj-label's
         * <code class="prettyprint">for</code> attribute to
         * associate with a form component's id attribute or use oj-label's
         * <code class="prettyprint">id</code> attribute to
         * associate with a JET form component's <code class="prettyprint">labelled-by</code> attribute.
         * @expose
         * @type {string|null}
         * @default null
         * @public
         * @instance
         * @since 4.0.0
         * @memberof oj.ojLabel
         * @ojshortdesc Specifies the id to set on the internal label element, if required. See the Help documentation for more information.
         *
         * @example <caption>Initialize the label with the
         * <code class="prettyprint">label-id</code> attribute:</caption>
         * &lt;oj-label label-id="labelId">Name:&lt;/oj-label>
         * @example <caption>Set the attribute, after initialization:</caption>
         * // getter
         * var labelid = myOjLabel.labelId;
         * // setter
         * myOjLabel.labelId = "myLabelId";
         */
        labelId: null,
        /**
         * Whether this label should have a required icon. It is recommended that you
         * bind the <code class="prettyprint">show-required</code> attribute to the same binding
         * as the <code class="prettyprint">required</code> attribute on the
         * associated JET form component to make sure they are in sync.
         * @expose
         * @type {?boolean}
         * @default false
         * @public
         * @instance
         * @memberof oj.ojLabel
         * @ojshortdesc Specifies whether the label should render an icon indicating that the associated form field requires a value. See the Help documentation for more information.
         * @since 4.0.0
         *
         * @example <caption>Initialize the oj-label with the
         * <code class="prettyprint">show-required</code> attribute, binding form component's
         * <code class="prettyprint">required</code> attribute to the same value.</caption>
         * &lt;oj-label show-required="[[isRequired]]">Name:&lt;/oj-label>
         * &lt;oj-input-text required="[[isRequired]]">&lt;/oj-input-text>
         * @example <caption>Set the attribute, after initialization:</caption>
         * // getter
         * var showRequired = myOjLabel.showRequired;
         * // setter
         * myOjLabel.showRequired = false;
         */
        showRequired: false,
        /**
         * Allows you to set certain attributes on the root dom element.
         * For ojLabel, we use 'class' only. The input components (via
         * EditableValue) set a styleclass on the ojLabel's root in case
         * component-specific label styling is needed. For example, ojradioset
         * would pass class: 'oj-radioset-label'. ojinputtext would pass class:
         * 'oj-inputtext-label'.
         *
         * @example <caption>Initialize root dom element with the set of
         * <code class="prettyprint">rootAttributes</code>:</caption>
         * $(".selector").ojLabel("option", "rootAttributes", {
         *   'class': 'oj-inputtext-label'
         * });
         *
         * @expose
         * @access public
         * @memberof oj.ojLabel
         * @instance
         * @type {Object}
         * @default {'id': null, 'class': null, 'style':null}
         * @ignore
         */
        rootAttributes: null
      },
      /**
       * @private
       * @memberof oj.ojLabel
       * @const
       */
      _BUNDLE_KEY: {
        _TOOLTIP_HELP: 'tooltipHelp',
        _TOOLTIP_REQUIRED: 'tooltipRequired'
      },
      /** ** start Public APIs ****/

      /**
       * Returns a jQuery object containing the root dom element of the label
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @memberof oj.ojLabel
       * @instance
       * @return {jQuery} the label
       * @ignore
       */
      widget: function () {
        return this.uiLabel;
      },
      /**
       * Refreshes the component with all the current attributes.
       * <p>
       * Call refresh if the <code class="prettyprint">id</code> changes, though
       * changing the <code class="prettyprint">id</code> shouldn't be needed.
       * </p>
       * <p>
       * Also, call refresh after <code class="prettyprint">required</code>
       * or <code class="prettyprint">help</code> changes.
       * The locale could have changed in the meantime, and refresh is needed to update the
       * <code class="prettyprint">required</code> and
       * <code class="prettyprint">help</code> tooltips.
       * </p>
       * There should be no need to call refresh for other attribute changes.
       *
       * @example document.getElementById("label1").setProperty("id","label2");
       * document.getElementById("label2").refresh();
       * @access public
       * @instance
       * @return {void}
       * @expose
       * @memberof oj.ojLabel
       * @ojshortdesc Refreshes the component.
       */
      refresh: function () {
        this._super();
        this._refreshRequired();
        this._refreshHelp();
        this._addIdsToDom();
      },
      /** ** end Public APIs ****/

      /** ** start internal widget functions ****/
      /**
       * Overridden to make sure describedById option is set
       *
       * @memberof oj.ojLabel
       * @instance
       * @protected
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        this._super(originalDefaults, constructorOptions);
        this._isCustomElement = this._IsCustomElement();
        this._checkRequiredOption();
      },
      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @override
       * @protected
       * @instance
       * @memberof oj.ojLabel
       */
      _ComponentCreate: function () {
        this._super();

        this._touchEatClickNamespace = this.eventNamespace + 'TouchEatClick';
        this._touchEatContextMenuNamespace = this.eventNamespace + 'TouchEatContextMenu';
        this._helpDefPopupNamespace = this.eventNamespace + 'HelpDefPopup';
        this._bTouchSupported = DomUtils.isTouchSupported();

        this._drawOnCreate();
      },
      /**
       * @protected
       * @override
       * @instance
       * @memberof oj.ojLabel
       */
      _AfterCreate: function () {
        var self = this;
        var forOption = this.options.for;
        var showRequiredOption = this.options.showRequired;
        var inputIdOption;
        var setIdOption;
        var targetElement;

        if (this.OuterWrapper) {
          inputIdOption = this.OuterWrapper.getAttribute(_DATA_OJ_INPUT_ID);
          setIdOption = this.OuterWrapper.getAttribute('data-oj-set-id');
        }

        // To get the 'for' on the <label>, what we do is set labelled-by on the
        // form component (simple document.getElementById search; we want to avoid
        // attribute searches since the performance isn't very good.),
        // which in turn sets the data-oj-input-id on the label, which
        // in turn sets its <label> element
        //
        if (inputIdOption) {
          // get internal label element and set its 'for'
          var labelElement = this.element[0];
          labelElement.setAttribute('for', inputIdOption);
        } else if (setIdOption) {
          // This is set by oj-radioset, oj-checkboxset, etc, so the oj-label can find it fast.
          this._targetElement = document.getElementById(setIdOption);
          targetElement = this._targetElement;
          if (targetElement) {
            if (this._needsHelpIcon()) {
              self._addHelpSpanIdOnTarget(self.helpSpanId, targetElement);
            }
            if (self.options.showRequired) {
              self._addRequiredDescribedByOnCustomFormElement(targetElement);
            }
          }
        }

        // find the target element using document.getElementById, then set described-by
        // on it for helpIcon and requiredIcon accessibility.
        // And if there isn't an data-oj-input-id attribute set on oj-label yet,
        // set that.
        if (forOption && this._isCustomElement) {
          // get the targetElement
          // do this in next tick, otherwise there can be timing issues with bindings resolving
          // and the 'id' on the form component may not be resolved in time for oj-label to find
          // it - if oj-label is before the oj form component.
          // or setting labelled-by on form component which immediately
          // sets data-oj-input-id on oj-label.
          // If we do not do it in a setTimeout, then what we were observing is the data-oj-input-id
          // attribute would be set on the form component, but it wasn't getting the setOption
          // call. E.g., a test case is ojLabel with knockout where order is input and label
          var busyContext = Context.getContext(this.OuterWrapper).getBusyContext();
          var labelledByResolved = busyContext.addBusyState({
            description:
              "The oj-label id='" +
              this.OuterWrapper.id +
              "' is looking for its form component with id " +
              forOption
          });
          Promise.resolve().then(() => {
            self._targetElement = document.getElementById(forOption);
            if (self._targetElement) {
              targetElement = self._targetElement;
              var helpSpan = document.getElementById(self.helpSpanId);
              if (self._needsHelpIcon()) {
                self._addHelpSpanIdOnTarget(self.helpSpanId, targetElement);
              } else if (!helpSpan && targetElement.getAttribute(_DESCRIBED_BY) === self.helpSpanId) {
                self._removeHelpSpanIdOnTarget(self.helpSpanId, targetElement);
              }
              if (showRequiredOption) {
                self._addRequiredDescribedByOnCustomFormElement(targetElement);
              }
              if (!inputIdOption) {
                if (self._isElementCustomElement(targetElement)) {
                  var ojLabelId = self.OuterWrapper.id;
                  self._addElementAttribute(targetElement, ojLabelId, _LABELLED_BY);
                } else {
                  self.element[0].setAttribute('for', forOption);
                }
              }
            } else {
              ojlogger.info('could not find an element with forOption ' + forOption);
            }
            labelledByResolved();
          });
        } else if (this._isCustomElement && this.options.labelId) {
          // no 'for' option.
          // look for aria-labelledby to support using
          // <oj-label> with a non-JET component, e.g., <div>
          // and this only works if aria-labelledby has only one id.
          // corner-case. For the JET components that link via id/labelled-by, not for/id,
          // the form component writes 'for' on the label, which in turn writes 'described-by'
          // on the JET form component.
          this._targetElement = this._getTargetElementFromLabelledAttr(
            _ARIA_LABELLEDBY,
            this.options.labelId
          );
          targetElement = this._targetElement;
          if (targetElement) {
            if (this._needsHelpIcon()) {
              this._addHelpSpanIdOnTarget(this.helpSpanId, targetElement);
            }
          }
        }
      },
      /**
       * <p>Save only the 'class' attribute since that is what
       * we manipulate. We don't have to save all the attributes.
       * N/A for custom element oj-label, so if custom element, this returns right away.
       *
       * @param {Object} element - jQuery selection to save attributes for
       * @protected
       * @memberof oj.ojLabel
       * @instance
       * @override
       */
      _SaveAttributes: function (element) {
        // _SaveAttributes is called before _InitOptions, so we can't use our global _isCustomElement
        // variable here.
        if (this._IsCustomElement()) {
          return;
        }

        this._savedClasses = element.attr('class');
      },
      /**
       * <p>Restore what was saved in _SaveAttributes.
       * N/A for custom element oj-label, so if custom element, this returns right away.
       * </p>
       *
       * @protected
       * @memberof oj.ojLabel
       * @instance
       * @override
       */
      _RestoreAttributes: function () {
        if (this._IsCustomElement()) {
          return;
        }

        // restore the saved "class" attribute. Setting class attr to undefined is a no/op, so
        // if this._savedClasses is undefined we explicitly remove the 'class' attribute.
        if (this._savedClasses) {
          this.element.attr('class', this._savedClasses);
        } else {
          this.element.removeAttr('class');
        }
      },
      /**
       * Notifies the component that its subtree has been removed from the document programmatically
       * after the component has been created
       * @memberof! oj.ojLabel
       * @instance
       * @protected
       */
      _NotifyDetached: function () {
        this._superApply(arguments);
        this._handleCloseHelpDefPopup();
      },
      /**
       * Notifies the component that its subtree has been made hidden programmatically
       * after the component has been created
       * @memberof! oj.ojLabel
       * @instance
       * @protected
       */
      _NotifyHidden: function () {
        this._superApply(arguments);
        this._handleCloseHelpDefPopup();
      },
      /**
       * @memberof! oj.ojLabel
       * @instance
       * @protected
       */
      _ReleaseResources: function () {
        this._super();
        // Hammer events must be cleaned up otherwise it will result in detached dom.
        this._removeHelpDefIconEventListeners();

        // Remove the click event we registered on the label element
        this.element.off('click');
      },
      /**
       * Gets called when component is created and when dom is reconnnected. E.g., oj-form-layout
       * moves dom around, and _ReleaseResources/_SetupResources gets called then, even though
       * the component is already created and ComponentCreate does not get called again.
       * @memberof! oj.ojLabel
       * @instance
       * @protected
       */
      _SetupResources: function () {
        this._super();
        this._addShowHelpDefinitionEventHandlers();

        // Core Pack Compatibility
        // In order to support having custom oj-label elements for the core-pack components
        // we will be using aria-labelledby instead of the labelled-by attribute. This way
        // we can keep the core-pack components free from the handshake mechanism. But, to
        // get all the functionality including the label-input interaction (clicking on the label
        // should focus the form component), we will use click event handler to focus the input
        // field manually.
        this.element.on(
          'click',
          function () {
            if (this._targetElement) {
              this._targetElement.focus();
            }
          }.bind(this)
        );
      },
      /**
       * The translation section name for the private ojLabel() is oj-ojLabel.
       * In 4.0.0 and the introduction of the oj-label custom element,
       *  the translation section name is oj-ojLabel.
       * @protected
       * @override
       * @instance
       * @memberof oj.ojLabel
       */
      _GetTranslationsSectionName: function () {
        return 'oj-ojLabel';
      },
      /**
       * Method for components to override in order to handle changes to watched attributes.
       * @param {string} attr The name of the watched attribute
       * @param {string} oldValue The old attribute value
       * @param {string} newValue The new attribute value
       * @protected
       * @override
       * @instance
       * @memberof oj.ojLabel
       */
      // eslint-disable-next-line no-unused-vars
      _WatchedAttributeChanged: function (attr, oldValue, newValue) {
        this._superApply(arguments);

        switch (attr) {
          case _DATA_OJ_INPUT_ID:
            // set 'for' on the label element to be the value of this inputId.
            this.element[0].setAttribute('for', newValue);
            break;
          case 'data-oj-set-id':
            // This is set by set components like oj-radioset, oj-checkboxset, etc.
            if (oldValue && !newValue) {
              // remove 'data-oj-set-id' from the label so remove the describedby info too.
              let previousTarget = document.getElementById(oldValue);
              this._removeDescribedByWithPrefix(previousTarget, this.OuterWrapper.id);
            } else {
              this._targetElement = document.getElementById(newValue);
              var targetElement = this._targetElement;
              // we need to wait a tick because for oj-radioset,
              // it sets 'data-oj-set-id' on oj-label
              // which in turn sets 'described-by' on oj-radioset. And if we didn't wait a
              // tick, the attribute is written fine, but the describedBy option change is lost.
              // The testcase is this:
              // create an ojLabel with knockout where order is label and wrapped radioset
              var needsHelpIcon = this._needsHelpIcon();
              var needsRequiredIcon = this.options.showRequired;
              if (needsHelpIcon || needsRequiredIcon) {
                var busyContext = Context.getContext(this.OuterWrapper).getBusyContext();
                var describedByResolved = busyContext.addBusyState({
                  description: 'The oj-label is writing described-by on its target.'
                });
                var self = this;
                Promise.resolve().then(() => {
                  if (needsHelpIcon) {
                    self._addHelpSpanIdOnTarget(self.helpSpanId, targetElement);
                  }
                  if (self.options.showRequired) {
                    self._addRequiredDescribedByOnCustomFormElement(targetElement);
                  }
                  describedByResolved();
                });
              }
            }
            break;
          default:
            break;
        }
      },
      /**
       * Remove the id that starts with the prefix from the element's described-by attribute.
       * @param {Element} element the element, like oj-radioset
       * @param {string} prefix prefix of the described-by value to remove.
       * @private
       * @memberof oj.ojLabel
       */
      _removeDescribedByWithPrefix: function (element, prefix) {
        var describedBy;
        var tokens;

        describedBy = element.getAttribute(_DESCRIBED_BY);
        // split into tokens
        tokens = describedBy ? describedBy.split(/\s+/) : [];
        tokens = tokens.filter(function (item) {
          return item.indexOf(prefix) === -1;
        });
        // join the tokens back together and trim whitespace
        describedBy = tokens.join(' ').trim();
        if (describedBy) {
          element.setAttribute(_DESCRIBED_BY, describedBy); // @HTMLUpdateOK
        } else {
          element.removeAttribute(_DESCRIBED_BY);
        }
      },
      /**
       * set up dom and styles on create
       * @private
       * @memberof oj.ojLabel
       */
      _drawOnCreate: function () {
        var helpSpan = null;
        var labelElementId;

        // custom element is <oj-label>. this.element is the <label> element.
        // <oj-label class="oj-label oj-component">
        //    <div class="oj-label-group">(helpandrequired spans)<label></label>
        // </oj-label>
        if (this.OuterWrapper) {
          // prettier-ignore
          this.uiLabel = $(this.OuterWrapper).append( // @HTMLUpdateOK
            this.element.wrap(this._createOjLabelGroupDom()).parent() // @HTMLUpdateOK
          );
          this.uiLabel.addClass('oj-label oj-component');
        } else {
          // wrap the label with a root dom element (oj-label) and its child
          // (oj-label-group). Then point this.uiLabel to the root dom element <div class=oj-label>
          this.uiLabel = this.element
            .wrap(this._createRootDomElement()) // @HTMLUpdateOK
            .closest('.oj-component');
        }

        // adds id to the label element from label-id or id or generates one (in that order).
        // used for both ojLabel and oj-label.
        this._addIdsToDom();

        // use the label element's id to create the help span and required span ids
        labelElementId = this.element[0].id;
        this.helpSpanId = labelElementId + _HELP_ICON_ID;
        this.requiredSpanId = labelElementId + _REQUIRED_ICON_ID;

        // move any oj-label styles off of this.element, and put on the
        // root dom element. They are restored in _destroy
        if (!this._isCustomElement) {
          this._moveLabelStyleClassesToRootDom();
        }

        // we put a span with an id on it around the help icon and
        // a span with an id on it around the required icon so that
        // the input's aria-describedby can point to it, if needed. Then the screen reader will
        // read the aria-label on the images when focus is on the input, so the user knows
        // that there is help and/or required icons.
        if (this.options.showRequired) {
          this._createRequiredIconSpanDom();
        }
        if (this._needsHelpIcon()) {
          helpSpan = this._createIconSpan(this.helpSpanId, true);
          this._createHelp(helpSpan);
        }
      },
      /**
       * Add described-by for the required icon on the custom form element.
       * This will be oj-checkboxset or oj-radioset only.
       * For all form controls except radioset
       * and checkboxset, aria-required on the form control reads required. So no need to
       * put aria-describedby on those for required icon.
       * @private
       * @memberof oj.ojLabel
       * @instance
       *
       */
      _addRequiredDescribedByOnCustomFormElement: function (targetElement) {
        if (targetElement && this._isElementCustomElementAriaRequiredUnsupported(targetElement)) {
          this._addElementAttribute(targetElement, this.requiredSpanId, _DESCRIBED_BY);
        }
      },
      /**
       * @private
       * @instance
       * @memberof oj.ojLabel
       *
       */
      _removeRequiredDescribedByOnCustomFormElement: function (targetElement) {
        if (targetElement && this._isElementCustomElementAriaRequiredUnsupported(targetElement)) {
          this._removeElementAttribute(targetElement, this.requiredSpanId, _DESCRIBED_BY);
        }
      },
      /**
       * Call for custom oj-label element only. Adds aria-describedby on native form element or
       * described-by on JET form element with the help icon span's id or aria-labelledby on
       * div role='group'..
       * @private
       * @instance
       * @memberof oj.ojLabel
       * @param {string} helpSpanId The id of the help span
       *
       */
      _addHelpSpanIdOnTarget: function (helpSpanId, targetElement) {
        var attributeName;

        attributeName = this._getAriaAttributeForTarget(targetElement);
        this._addElementAttribute(targetElement, helpSpanId, attributeName);
      },
      /**
       * Call for custom oj-label element only. Removes aria-describedby on native form element or
       * described-by on JET form element with the help icon span's id or aria-labelledby on
       * div role='group'.
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _removeHelpSpanIdOnTarget: function (helpSpanId, targetElement) {
        var attributeName;

        attributeName = this._getAriaAttributeForTarget(targetElement);
        this._removeElementAttribute(targetElement, helpSpanId, attributeName);
      },
      /**
       * Based on the targetElement, this figures out which attribute we need to write onto
       * the target to make it be able to read out the help definition. E.g., described-by for
       * JET form control, aria-describedby for input, aria-labelled-by for div role='group'
       * @param {Element} targetElement
       * @return {string|null} the attribute, aria-describedby, aria-labelledby, or described-by
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _getAriaAttributeForTarget: function (targetElement) {
        var attributeName;

        if (!this._isElementCustomElement(targetElement)) {
          // We handle the one label to role='group' differently.
          // If a <div aria-labelledby role='group'> points to the
          // <oj-label>'s label-id, then add/remove aria-labelledby, not aria-describedby, since
          // screenreaders don't read aria-describedby on divs.
          if (targetElement.getAttribute('role') === 'group') {
            attributeName = _ARIA_LABELLEDBY;
          } else {
            attributeName = _ARIA_DESCRIBEDBY;
          }
        } else {
          attributeName = _DESCRIBED_BY;
        }

        return attributeName;
      },
      /**
       * Return the element with by using a querySelector to search for the attribute with the id.
       * e.g., aria-labelledby attribute set to labelId.
       * @private
       * @instance
       * @memberof oj.ojLabel
       * @param attrName the attribute name to look for. e.g., labelled-by or aria-labelledby
       * @param {string} id
       * @return {Element|null} is a reference to an Element object,
       * or null if the element is not found.
       *
       */
      _getTargetElementFromLabelledAttr: function (attrName, id) {
        var attributeSearchString;

        // The ~ means to look to see if the id is in a list of whitespace-separated
        // values, one of which is exactly equal to id, and labelled-by could have a
        // list of whitespace-separated ids.
        attributeSearchString = '[' + attrName + "~='" + id + "']";
        return document.querySelector(attributeSearchString);
      },
      /**
       * If targetElement's tagName has a "-", return true, else return false.
       * @param {Element} targetElement the HTML element the 'for' attribute is pointing to
       * @private
       * @memberof oj.ojLabel
       * @instance
       * @return {boolean} return true if targetElement's tagName contains "-". Else return false.
       *
       */
      _isElementCustomElement: function (targetElement) {
        oj.Assert.assertDomElement(targetElement);
        return targetElement.tagName.indexOf('-') !== -1;
      },
      /**
       * Checks the targetElement's tagname against oj-checkboxset or oj-radioset, because these
       * are the only components that do not support aria-required.
       * @param {Element} targetElement the HTML element the 'for' attribute is pointing to
       * @private
       * @memberof oj.ojLabel
       * @instance
       * @return {boolean} true if targetElement's tagName is oj-radioset or oj-checkboxset.
       *
       */
      _isElementCustomElementAriaRequiredUnsupported: function (targetElement) {
        oj.Assert.assertDomElement(targetElement);

        var componentName;
        var componentNames = ['oj-radioset', 'oj-checkboxset'];
        var length = componentNames.length;
        var tagName;
        var found = false;

        tagName = targetElement.tagName.toLowerCase();

        for (var i = 0; i < length && !found; i++) {
          componentName = componentNames[i];
          if (tagName.indexOf(componentName) === 0) {
            found = true;
          }
        }

        return found;
      },
      /**
       * Generic function to add a value to the element's attribute. For example, you can
       * add "foo" to the elem's aria-describedby attribute. It will not overwrite
       * any current aria-describedby values already there.
       *
       * @param {Element} elem the HTML element on which to add the attribute
       * @param {string} id the id to add to the attribute
       * @param {string} attr the attribute to add to. e.g., "aria-describedby"
       * @private
       * @memberof oj.ojLabel
       * @instance
       *
       */
      _addElementAttribute: function (elem, id, attr) {
        var index;
        var currentAttributeValue = elem.getAttribute(attr);
        var newAttributeValue;
        var tokens;

        tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : [];
        // Get index that id is in the tokens, if at all.
        index = tokens.indexOf(id);
        // add id if it isn't already there
        if (index === -1) {
          tokens.push(id);
        }
        newAttributeValue = tokens.join(' ').trim();
        elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
      },
      /**
       * Generic function to remove a value to the element's attribute. For example, you can
       * remove "foo" from the elem's aria-describedby attribute. It will not remove
       * any other aria-describedby values already there.
       * @param {Element} elem the HTML element
       * @param {string} id the id to remove from the attr
       * @param {string} attr the attribute to remove from. e.g., "aria-describedby"
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _removeElementAttribute: function (elem, id, attr) {
        var currentAttributeValue = elem.getAttribute(attr);
        var newAttributeValue;
        var index;
        var tokens;

        // get aria-describedby that is on the element
        // split into tokens
        tokens = currentAttributeValue ? currentAttributeValue.split(/\s+/) : [];
        // Get index that id is in the tokens, if at all.
        index = tokens.indexOf(id);
        // remove that from the tokens array
        if (index !== -1) {
          tokens.splice(index, 1);
        }
        // join the tokens back together and trim whitespace
        newAttributeValue = tokens.join(' ').trim();
        if (newAttributeValue) {
          elem.setAttribute(attr, newAttributeValue); // @HTMLUpdateOK
        } else {
          elem.setAttribute(attr, ''); // @HTMLUpdateOK
        }
      },
      /**
       * Create help.
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createHelp: function (helpSpan) {
        var helpDef = this.options.help.definition;
        var helpSource = this.options.help.source;
        var helpIconAnchor = this._createHelpIconAnchorDomElement(helpDef, helpSource);
        // .prepend: Insert content, specified by the parameter, to the beginning of each element
        // prettier-ignore
        $(helpSpan).prepend( // @HTMLUpdateOK
          helpIconAnchor
        );
        this._attachHelpDefToIconAnchor();
        this._focusable({ element: helpIconAnchor, applyHighlight: true });
      },
      /**
       * Create required icon span dom and its contents
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createRequiredIconSpanDom: function () {
        // _createIconSpan creates the span and adds it in the oj-label-group dom
        var requiredSpan = this._createIconSpan(this.requiredSpanId, false);
        requiredSpan.appendChild(this._createRequiredIconDomElement()); // @HTMLUpdateOK
      },
      /**
       * @throws error if showRequired is not a boolean
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _checkRequiredOption: function () {
        var showRequired = this.options.showRequired;

        if (typeof showRequired !== 'boolean') {
          throw new Error("Option 'showRequired' has invalid value set: " + showRequired);
        }
      },
      /**
       * Add an id to the label element if there isn't one already there.
       * Called during init and refresh.
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _addIdsToDom: function () {
        var labelElementId;

        // Use label-id to set label element's id. If label-id doesn't exist, this uses oj-label's
        // id to generate a sub-id on label.
        if (this._isCustomElement) {
          if (!this.OuterWrapper.id) {
            $(this.OuterWrapper).uniqueId();
          }
          this._refreshLabelId();
        }

        // if no id on the label element, generate one.
        // this will be used to wrap the helpIcon and the requiredIcon and
        // then for the aria-describedby on the input.
        labelElementId = this.element.attr('id');
        if (labelElementId == null) {
          this.element.uniqueId();
        }
      },
      /**
       * Called if NOT a custom element.
       * move oj-label* classes from label element onto the root dom element
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _moveLabelStyleClassesToRootDom: function () {
        var arrayOfClasses;
        var classes = this.element.attr('class');
        var className;
        var numClasses;

        if (classes) {
          arrayOfClasses = classes.split(/\s+/);
          numClasses = arrayOfClasses.length;

          for (var i = 0; i < numClasses; i++) {
            className = arrayOfClasses[i];
            // if class name has -label- in it, then move it
            // (e.g., oj-label, oj-label-inline, oj-md-label-nowrap,
            // oj-md-labels-inline)
            if (className.includes('-label')) {
              this.uiLabel.addClass(className);
              this.element.removeClass(className);
            }
          }
        }
      },
      /**
       * create and return the span with an id that we'll use to put around the help
       * icon or required icon. The order of the dom of oj-label-group's children should always be:
       * <helpIcon span/><requiredIcon span/><label element>
       * @param {string} id the id of the span
       * @param {boolean} isHelp if true, prepend icon span to oj-label-group, else
       * add before the label element.
       * This is needed because we always want the help dom to come before the required dom and
       * we always want the label element to come last.
       * @returns {Element}
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createIconSpan: function (id, isHelp) {
        var ojLabelGroupDom;
        var span = document.createElement('span');
        span.setAttribute('id', id);

        if (isHelp) {
          ojLabelGroupDom = this.uiLabel.find('.oj-label-group');
          ojLabelGroupDom.prepend(span); // @HTMLUpdateOK
        } else {
          this.element.before(span); // @HTMLUpdateOK
        }
        return span;
      },
      /**
       * For ojLabel component only, not oj-label.
       * return the dom node for the root dom element
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createRootDomElement: function () {
        var inputLabelClass;
        var rootAttributes = this.options.rootAttributes;
        var rootDomNode;
        var rootDomNodeClasses = 'oj-label oj-component';

        if (rootAttributes) {
          inputLabelClass = rootAttributes.class;
        }
        if (inputLabelClass) {
          rootDomNodeClasses = rootDomNodeClasses + ' ' + inputLabelClass;
        }

        rootDomNode = document.createElement('div');
        rootDomNode.className = rootDomNodeClasses;
        rootDomNode.appendChild(this._createOjLabelGroupDom()); // @HTMLUpdateOK

        return rootDomNode;
      },
      /**
       * return the dom node for the oj-label-group node
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createOjLabelGroupDom: function () {
        var labelGroupNode;

        labelGroupNode = document.createElement('div');
        labelGroupNode.className = 'oj-label-group';

        return labelGroupNode;
      },
      /**
       * return the dom node for the span with oj-label-required-icon
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createRequiredIconDomElement: function () {
        var requiredTooltip = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_REQUIRED);
        var requiredDom = document.createElement('span');

        requiredDom.className = 'oj-label-required-icon oj-component-icon';
        requiredDom.setAttribute('role', 'img');
        requiredDom.setAttribute('title', requiredTooltip);
        // title isn't being read by the screen reader. this is only needed for radioset/checkboxset.
        requiredDom.setAttribute(_ARIA_LABEL, requiredTooltip); // @HTMLUpdateOK
        return requiredDom;
      },
      /**
       * return the dom node for the help icon anchor.
       * if (_needsHelpIcon) , show help icon
       * if (helpSource), add href
       * if (helpDef), add 'aria-label'=helpDef on help icon.
       * @private
       * @memberof oj.ojLabel
       * @instance
       */
      _createHelpIconAnchorDomElement: function (helpDef, source) {
        var helpIconAnchor;
        // construct the help html
        // if source (external url) or helpDef, then render a clickable help icon

        // From our Accessibility expert - You must not put role of img on a link.
        // This will make it so it is not a link any more to AT.
        // It is ok to leave it off the the <a> tag and do the following.
        // helpIconAnchor =
        //  $( "<a tabindex='0' target='_blank' class='oj-label-help-icon-anchor oj-label-help-icon oj-component-icon oj-clickable-icon-nocontext'></a>",
        //  this.document[0] );

        // The above is not reading anything when it has focus if it doesn't have an href. So if
        // it doesn't have an href, it needs some kind of role on it.

        helpIconAnchor = document.createElement('a');
        helpIconAnchor.setAttribute('tabindex', '0');
        helpIconAnchor.setAttribute('target', '_blank');
        helpIconAnchor.className =
          'oj-label-help-icon-anchor oj-label-help-icon oj-component-icon oj-clickable-icon-nocontext';
        if (source) {
          try {
            DomUtils.validateURL(source);
            helpIconAnchor.setAttribute('href', source);
          } catch (e) {
            throw new Error(e + '. The source option (' + source + ') is invalid.');
          }
        } else {
          // if there is no href, then we need a role that the screen reader/voiceover will read.
          helpIconAnchor.setAttribute('role', 'img');
        }

        if (helpDef) {
          helpIconAnchor.setAttribute(_ARIA_LABEL, helpDef); // @HTMLUpdateOK
        } else {
          // prettier-ignore
          helpIconAnchor.setAttribute( // @HTMLUpdateOK
            _ARIA_LABEL,
            this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_HELP)
          );
        }

        return helpIconAnchor;
      },
      /**
       * To accomodate keyboard and touch users,
       * show a popup on hover, on tabbing in or touch press that shows the
       * help definition text on the help icon.
       *
       * press is recognized when the
       * pointer is down for x ms without any movement. In other words, you press with your finger and
       * don't let up and then after x ms the Help Def window shows up. You can then let go of your finger
       * the help def window stays up.
       * On Android, when you press and hold you see touchstart. When you finally let up, you see touchend
       * On ios, when you press and hold you see touchstart. When you finally let up, sometimes you
       * see touchend only. Other times, you see touchend mousedown mouseup click all
       * consecutively.
       * On ios, a quick tap shows touchstart touchend mousedown mouseup click (I only register those events)
       * all right after another.
       * @private
       * @memberof oj.ojLabel
       */
      _attachHelpDefToIconAnchor: function () {
        var $helpDefPopupDiv;
        var $helpIcon;
        var position;
        var self = this;

        $helpIcon = this.widget().find('.oj-label-help-icon-anchor');

        // before we do any of this work, make sure there is a help icon
        if ($helpIcon.length === 0) {
          return;
        }

        // Create the popup div where we will display the help def text, add a unique id onto it and save
        // that id so we can use it to popup.

        // 1. Build display:none div with help definition text. This will be our popup.
        // 2. Register click/touch event on label which will call a callback to open the popup on
        // PRESS

        if (this._bTouchSupported) {
          // this is code to be extra careful: Check if the _eatClickOnHelpIconListener exists.
          // If it does exist, call 'off'. We don't want this click listener
          // that eats clicks lying around.
          if (this._eatClickOnHelpIconListener) {
            this.widget().off(this._touchEatClickNamespace);
          }
          // The pressHold gesture also fires a click event on iphone on touchend.  Prevent that here.
          // This event is added to the widget on click in the function _handleOpenPopupForHelpDef
          this._eatClickOnHelpIconListener = function () {
            // changing colors is a good way to debug if the handler is being called. this changes
            // the label color.
            // if (this.style.color === "aqua")
            // this.style.color = "yellow";
            // else
            // this.style.color = "aqua";
            return false;
          };

          $helpIcon.on('contextmenu' + this._touchEatContextMenuNamespace, false);
        }

        // For touch device, press with finger on helpIcon to show the help def in a popup.
        // If there is no help source, you can also tap with finger on the helpIcon to show the help
        // def in a popup.
        // For keyboard users, tab in to helpIcon to show the help def in a popup.
        // For mouse users, hovering on helpIcon shows the help def in a popup.
        // ------------------------------------------------------------------------------------

        // ENTERING CALLBACK TO OPEN THE POPUP IF NEEDED
        // (focusin from tab, mouseenter, OR press from touch)

        this._openPopupForHelpDefCallbackListener = function (event) {
          if ($helpDefPopupDiv == null) {
            // create popup's div
            $helpDefPopupDiv = self._createHelpDefPopupDiv();
            // Once we have created the popup, we can now set an event
            // listener on it.
            $helpDefPopupDiv.on(
              'mouseleave' + self._helpDefPopupNamespace,
              self._mouseleaveClosePopupForHelpDefListener
            );
            $helpDefPopupDiv.on(
              'mouseenter' + self._helpDefPopupNamespace,
              self._clearTimeoutOnPopupMouseEnterListener
            );
            position = {
              my: 'start bottom',
              at: 'end top',
              collision: 'flipcenter',
              of: $helpIcon
            };
            $helpDefPopupDiv.ojPopup({
              position: position,
              modality: 'modeless',
              animation: { open: null, close: null }
            });
          }
          self._handleOpenHelpDefPopup(event, $helpDefPopupDiv, $helpIcon);
        };
        // END CALLBACK TO OPEN POPUP
        //

        // CALLBACK TO CLOSE POPUP
        // According to WCAG 2.1 - 1.4.13 Content on Hover or Focus:
        // If pointer hover can trigger the additional content,
        // then the pointer can be moved over the additional content without the additional content
        // disappearing.
        // So here we close the popup when we have left the help icon
        // or the popup, but we give it 500ms
        // to let the user move the mouse between the two, in which case
        // we cancel the timeout and do not close the popup.
        this._mouseleaveClosePopupForHelpDefListener = function (e) {
          // Note: the mouseleave event handler is registered on both the help icon
          // and the popup.
          if (self._helpDefPopupDivId != null) {
            const targetIsHelpIcon = e.currentTarget === $helpIcon[0];
            const targetIsPopupDiv = e.currentTarget === $helpDefPopupDiv[0];

            if (targetIsHelpIcon || targetIsPopupDiv) {
              const busyContext = Context.getContext(self.element[0]).getBusyContext();
              self.helpDefClosePopupBCResolved = busyContext.addBusyState({
                description: "The oj-label is closing the help popup.'"
              });
              self.closePopupTimer = setTimeout(function () {
                $helpDefPopupDiv.ojPopup('close');
                self._resolveHelpDefClosePopupTimoutBC();
              }, _CLOSE_POPUP_TIME);
            }
          }
        };
        // END CALLBACK TO CLOSE POPUP

        // Callback when the mouse enters the popup. We do not want
        // to close the popup so that a user, a low-vision user especially,
        // could zoom into it.
        this._clearTimeoutOnPopupMouseEnterListener = function () {
          if (self.closePopupTimer) {
            clearTimeout(self.closePopupTimer);
            self._resolveHelpDefClosePopupTimoutBC();
          }
        };

        // Add event handlers to open the help definition popup will happen in _SetupResources
      },
      /**
       * Create the div that will be used as the popup for the help definition.
       * @private
       * @memberof oj.ojLabel
       */
      _createHelpDefPopupDiv: function () {
        var contentDiv;
        var $contentDiv;
        var helpDef = this.options.help.definition;
        var helpDefPopupDiv;
        var $helpDefPopupDiv;
        var helpDefText;

        if (helpDef) {
          helpDefText = helpDef;
        } else {
          helpDefText = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_HELP);
        }

        if (!this._helpDefPopupDivId) {
          // create a root node to bind to the popup
          helpDefPopupDiv = document.createElement('div');
          helpDefPopupDiv.className = 'oj-label-help-popup';
          helpDefPopupDiv.style.display = 'none';
          $helpDefPopupDiv = $(helpDefPopupDiv);
          $helpDefPopupDiv.uniqueId();
          this._helpDefPopupDivId = $helpDefPopupDiv.prop('id');

          // create a content node
          contentDiv = document.createElement('div');
          contentDiv.className = 'oj-label-help-popup-container';
          helpDefPopupDiv.appendChild(contentDiv); // @HTMLUpdateOK created contentDiv ourselves
          $contentDiv = $(contentDiv);

          $contentDiv.text(helpDefText);
          this.uiLabel.append($helpDefPopupDiv); // @HTMLUpdateOK content created by us
        } else {
          // Find the div with the id, and then update the text of it.
          $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));
          if ($helpDefPopupDiv.length) {
            $contentDiv = $helpDefPopupDiv.find('.oj-label-help-popup-container').first();
            $contentDiv.text(helpDefText);
          }
        }
        return $helpDefPopupDiv;
      },
      /**
       * Add the event listeners to show the helpDefinition text in a popup
       * @returns {undefined}
       * @instance
       * @memberof oj.ojLabel
       * @private
       */
      _addShowHelpDefinitionEventHandlers: function () {
        const $helpIcon = this.uiLabel.find(OJ_LABEL_HELP_ICON_CLASS);
        if ($helpIcon.length === 0) {
          return;
        }

        // Open the popup on focusin and mousenter.
        // *I have logic in the listener to ignore these when these trigger as a result of
        // the user touching the screen.
        $helpIcon.on(
          'focusin' + this._helpDefPopupNamespace + ' mouseenter' + this._helpDefPopupNamespace,
          this._openPopupForHelpDefCallbackListener
        );

        // close the popup when you leave the help icon
        $helpIcon.on(
          'mouseleave' + this._helpDefPopupNamespace,
          this._mouseleaveClosePopupForHelpDefListener
        );

        this._setupHammerEventHandlers($helpIcon);
      },
      /**
       * Add the Hammer event listeners to show the helpDefinition text in a popup
       * @returns {undefined}
       * @instance
       * @memberof oj.ojLabel
       * @private
       */
      _setupHammerEventHandlers: function () {
        const $helpIcon = this.uiLabel.find(OJ_LABEL_HELP_ICON_CLASS);
        if (this._bTouchSupported && $helpIcon.length !== 0) {
          // And if touch is supported, the user can also open the popup on press or,
          //  if no help source, on tap.
          if (this.options.help.source) {
            let hammerOptions = {
              recognizers: [[hammerjs.Press, { time: DomUtils.PRESS_HOLD_THRESHOLD }]]
            };
            $helpIcon.ojHammer(hammerOptions);
            // JET components are encouraged to use JQUI's _on() method, giving all the conveniences
            // of the _on method, like automatic cleanup.
            this._on($helpIcon, { press: this._openPopupForHelpDefCallbackListener });
          } else {
            let hammerOptions = {
              recognizers: [[hammerjs.Tap], [hammerjs.Press, { time: DomUtils.PRESS_HOLD_THRESHOLD }]]
            };
            $helpIcon.ojHammer(hammerOptions);
            this._on($helpIcon, {
              press: this._openPopupForHelpDefCallbackListener,
              tap: this._openPopupForHelpDefCallbackListener
            });
          }
        }
      },
      /**
       * Release the Hammer event listeners
       * @returns {undefined}
       * @instance
       * @memberof oj.ojLabel
       * @private
       */
      _releaseHammerEventHandlers: function () {
        const $helpIcon = this.uiLabel.find(OJ_LABEL_HELP_ICON_CLASS);
        if (this._bTouchSupported && $helpIcon.length !== 0) {
          // helpIcon is same element on which we originally called ojHammer()
          // the listeners are automatically removed since we used jqueryui's _on
          $helpIcon.ojHammer('destroy');
        }
      },
      /**
       * Resolve the close popup timer busy context
       * @instance
       * @memberof oj.ojLabel
       * @private
       */
      _resolveHelpDefClosePopupTimoutBC: function () {
        this.closePopupTimer = null;
        // this busy context was set during the setTimeout popup close call
        // and needs to be resolved whenever we clear the timeout.
        if (this.helpDefClosePopupBCResolved) {
          this.helpDefClosePopupBCResolved();
          delete this.helpDefClosePopupBCResolved;
        }
      },
      /**
       * Handle open popup for help definition.
       * @instance
       * @memberof oj.ojLabel
       * @private
       */
      _handleOpenHelpDefPopup: function (event, helpDefPopupDiv, helpIcon) {
        // before handling open, clear the timer that closes the popup to make sure we
        // do not close it after we think it is still open.
        if (this.closePopupTimer) {
          clearTimeout(this.closePopupTimer);
          this._resolveHelpDefClosePopupTimoutBC();
        }

        var isOpen = helpDefPopupDiv.ojPopup('isOpen');

        if (isOpen) {
          return;
        }

        // touch supported does not mean only touch. It could be a touch-enabled laptop like Windows10
        if (this._bTouchSupported) {
          // For a press, we want to show the popup with the help def,
          // but we do not want to navigate to the source url. So we eat the click.
          if (event.type === 'press') {
            var widget = this.widget();
            widget.on('click' + this._touchEatClickNamespace, this._eatClickOnHelpIconListener);
            var self = this;
            helpDefPopupDiv.on('ojclose', function () {
              widget.off(self._touchEatClickNamespace);
            });
          } else {
            helpDefPopupDiv.off('ojclose');
          }

          // Open the popup if I get a 'press' event, a 'tap' event, a 'focusin' event if
          // it wasn't a touch, and a 'mouseenter' event if it wasn't a touch.
          // I look for a recent touchstart event and use this to filter out
          // the focusin and mouseevent events. I use touchstart and not touchend because while
          // pressing I get the touchstart, but I don't get the touchend until the finger lets up.
          if (
            event.type === 'press' ||
            event.type === 'tap' ||
            (!DomUtils.recentTouchStart() &&
              (event.type === 'focusin' || event.type === 'mouseenter'))
          ) {
            helpDefPopupDiv.ojPopup('open', helpIcon);
          }
          // end touch code
        } else {
          // non-touch devices. focusin/mouseenter are the only ways to open the popup.
          helpDefPopupDiv.ojPopup('open', helpIcon);
        }
      },
      /**
       * Close helpDef popup. This is called from _NotifyDetached and _NotifyHidden.
       * @private
       * @memberof oj.ojLabel
       */
      _handleCloseHelpDefPopup: function () {
        var $helpDefPopupDiv;

        if (this._helpDefPopupDivId != null) {
          $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));
          $helpDefPopupDiv.ojPopup('close');
        }
      },
      /**
       * Remove the event listeners for opening a popup on the help def icon and for eating
       * the clicks on the 'press' event. Called from destroy and when we remove the help icon.
       * @private
       * @memberof oj.ojLabel
       */
      _removeHelpDefIconEventListeners: function () {
        const helpIcon = this.uiLabel.find(OJ_LABEL_HELP_ICON_CLASS);

        if (this._bTouchSupported) {
          this.widget().off(this._touchEatClickNamespace);
          helpIcon.off(this._touchEatContextMenuNamespace);
        }
        this._releaseHammerEventHandlers();
        helpIcon.off(this._helpDefPopupNamespace);
        if (this._helpDefPopupDivId != null) {
          let $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));
          $helpDefPopupDiv.off(this._helpDefPopupNamespace);
        }
      },
      /**
       * removes the help def popup dom and variables
       * @returns {undefined}
       * @private
       * @memberof oj.ojLabel
       */
      _removeHelpDefPopup: function () {
        var $helpDefPopupDiv;

        if (this._helpDefPopupDivId != null) {
          $helpDefPopupDiv = $(document.getElementById(this._helpDefPopupDivId));
          if ($helpDefPopupDiv.length > 0) {
            $helpDefPopupDiv.ojPopup('destroy');
            $helpDefPopupDiv.remove();
          }
          this._helpDefPopupDivId = null;
        }
      },
      /**
       * @private
       * @memberof oj.ojLabel
       * @returns {boolean}
       */
      _needsHelpIcon: function () {
        var options = this.options;
        var helpDef;
        var helpSource = options.help.source;
        var needsIcon;

        // "", or null, or undefined all mean help.source is not specified.
        needsIcon = helpSource !== '' && helpSource != null;
        if (!needsIcon) {
          // Now check helpDef: "", or null, or undefined all mean help.definition is not specified.
          helpDef = options.help.definition;
          needsIcon = helpDef !== '' && helpDef != null;
        }

        return needsIcon;
      },
      /**
       * refresh the help dom --
       * find the help root dom node and remove it if it is there
       * and add back the help html. Helpful if a help option changed.
       * @private
       * @memberof oj.ojLabel
       */
      _refreshHelp: function () {
        var helpSpanId = this.helpSpanId;
        var helpSpan;
        var $helpIcon;
        var needsHelpIcon;
        var targetElement = this._targetElement;

        // remove the help info if it is there.
        $helpIcon = this.uiLabel.find(OJ_LABEL_HELP_ICON_CLASS);

        if ($helpIcon.length === 1) {
          // remove things we added in _attachHelpDefToIconAnchor
          this._removeHelpDefIconEventListeners();
          this._removeHelpDefPopup();
          $helpIcon.remove();
        }
        helpSpan = document.getElementById(helpSpanId);
        needsHelpIcon = this._needsHelpIcon();

        // ok, we removed the helpIcon (but not the span) at the start of this method,
        // so we need to add it back if we needHelpIcon
        if (needsHelpIcon) {
          if (helpSpan == null) {
            helpSpan = this._createIconSpan(helpSpanId, true);
          }
          this._createHelp(helpSpan);
          this._addShowHelpDefinitionEventHandlers();
          if (this._isCustomElement && targetElement) {
            this._addHelpSpanIdOnTarget(helpSpanId, targetElement);
          }
        } else if (helpSpan !== null) {
          helpSpan.parentNode.removeChild(helpSpan);
          if (this._isCustomElement && targetElement) {
            this._removeHelpSpanIdOnTarget(helpSpanId, targetElement);
          }
        }
      },
      /**
       * refresh the required dom --
       * if required is true, then add the required dom if it isn't already there
       * if required is false, remove the required dom if it is there.
       * Helpful if the required option changed.
       * @private
       * @memberof oj.ojLabel
       */
      _refreshRequired: function () {
        var $requiredDom;
        var requiredSpanId = this.requiredSpanId;
        var requiredSpan;
        var requiredTooltip;

        requiredSpan = document.getElementById(requiredSpanId);

        if (this.options.showRequired) {
          // add required if it wasn't already there
          if (!requiredSpan) {
            this._createRequiredIconSpanDom();

            if (this._isCustomElement) {
              this._addRequiredDescribedByOnCustomFormElement(this._targetElement);
            }
          } else {
            // required is there, so we need to refresh the translated value in case it changed.
            requiredTooltip = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_REQUIRED);
            $requiredDom = this.uiLabel.find('.oj-label-required-icon');
            $requiredDom.attr('title', requiredTooltip);
          }
        } else {
          // not required, so remove it
          requiredSpan = document.getElementById(requiredSpanId);
          if (requiredSpan !== null) {
            requiredSpan.parentNode.removeChild(requiredSpan);
          }

          if (this._isCustomElement) {
            this._removeRequiredDescribedByOnCustomFormElement(this._targetElement);
          }
        }
      },
      /**
       * This gets called during component initialization and when the 'for' option changes.
       * And this should find the targetElement, set labelledBy on it and describedBy.
       * @private
       * @memberof oj.ojLabel
       */
      _refreshFor: function (oldValue, newValue) {
        var labelElement = this.element[0];
        var ojLabelId = this.OuterWrapper.id;

        if (oldValue) {
          // If someone removes 'for', the labelled-by is removed and the
          // internal 'for' is removed and data-oj-input-id is removed.
          labelElement.removeAttribute('for');
          this.OuterWrapper.removeAttribute(_DATA_OJ_INPUT_ID);
          var oldTarget = document.getElementById(oldValue);
          if (oldTarget) {
            var labelledBy = oldTarget.getAttribute(_LABELLED_BY);
            if (labelledBy) {
              if (labelledBy === ojLabelId) {
                oldTarget.removeAttribute(_LABELLED_BY);
              } else {
                // remove the ojLabelId from the labelledBy
                var splitArray = labelledBy.split(/\s+/);
                // remove ojLabelId from the splitArray and rejoin
                var newArray = splitArray.filter(function (item) {
                  return item !== ojLabelId;
                });

                var newLabelledBy = newArray.join(' ');
                oldTarget.setAttribute(_LABELLED_BY, newLabelledBy); // @HTMLUpdateOK
              }
            }
          }
        }

        this._targetElement = document.getElementById(this.options.for);
        if (this._targetElement) {
          var targetElement = this._targetElement;
          if (this._isElementCustomElement(targetElement)) {
            this._addElementAttribute(targetElement, ojLabelId, _LABELLED_BY);
            if (this._needsHelpIcon()) {
              this._addHelpSpanIdOnTarget(this.helpSpanId, targetElement);
            }
            if (this.options.showRequired) {
              this._addRequiredDescribedByOnCustomFormElement(targetElement);
            }
          } else {
            labelElement.setAttribute('for', newValue);
          }
        }
      },
      /**
       * refresh label-id which is only for oj-label custom element.
       * Set the label element's id to label-id. If label-id is not set,
       * then use the <oj-label>'s id attribute to set a sub-id on the label element.
       * @private
       * @memberof oj.ojLabel
       */
      _refreshLabelId: function () {
        var labelIdOption;
        var customElementId;

        labelIdOption = this.options.labelId;
        if (labelIdOption) {
          this.element.attr('id', labelIdOption);
        } else {
          // for custom elements, this.uiLabel is <oj-label>.
          customElementId = this.uiLabel.attr('id');
          if (customElementId) {
            // create sub-id on the label element
            this.element.attr('id', customElementId + '|label');
          }
        }
      },

      /**
       * Note that _setOption does not get called during create. it only gets called
       * when the component has already been created.
       * @override
       * @protected
       * @memberof oj.ojLabel
       * @instance
       */
      // eslint-disable-next-line no-unused-vars
      _setOption: function (key, value) {
        var oldValue = this.options[key];
        this._superApply(arguments);

        switch (key) {
          case 'showRequired':
            this._refreshRequired();
            break;
          case 'help':
            this._refreshHelp();
            break;
          case 'for':
            // todo: what happens if 'for' changes? I can see that being very unlikely.
            // but what it can do is use its id to search for labelledBy target, and
            // remove the labelledBy target, then add 'for' and start again.
            // it can look at this.options.for for 'old value' and value for new value
            if (this._isCustomElement) {
              // refreshes for, which is only for oj-label custom element, not ojLabel.
              // targetElement is the element with id === oj-label's for option
              this._refreshFor(oldValue, value);
            }
            break;
          case 'labelId':
            // refreshes label-id, which is only for oj-label custom element, not ojLabel.
            this._refreshLabelId();
            break;
          default:
            break;
        }
      },
      // @inheritdoc
      getNodeBySubId: function (locator) {
        var node;
        var subId;

        node = this._super(locator);
        if (!node) {
          subId = locator.subId;
          if (subId === 'oj-label-help-icon') {
            node = this.widget().find(OJ_LABEL_HELP_ICON_CLASS)[0];
          }
        }
        // Non-null locators have to be handled by the component subclasses
        return node || null;
      },
      // @inheritdoc
      getSubIdByNode: function (node) {
        var subId = null;

        if (node != null) {
          if (node === this.widget().find(OJ_LABEL_HELP_ICON_CLASS)[0]) {
            subId = { subId: 'oj-label-help-icon' };
          }
        }

        return subId || this._superApply(arguments);
      },
      /**
       *
       * @override
       * @protected
       * @memberof oj.ojLabel
       * @instance
       */
      _destroy: function () {
        // remove things we added in _attachHelpDefToIconAnchor
        this._removeHelpDefIconEventListeners();
        this._removeHelpDefPopup();
        this.helpSpanId = null;
        this.requiredSpanId = null;
        this._isCustomElement = null;
        // DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout
        DomUtils.unwrap(this.element, this.uiLabel);

        return this._super();
      }
    });
  })();

  (function () {
var __oj_label_metadata = 
{
  "properties": {
    "for": {
      "type": "string"
    },
    "help": {
      "type": "object",
      "value": {
        "definition": null,
        "source": null
      },
      "properties": {
        "definition": {
          "type": "string"
        },
        "source": {
          "type": "string"
        }
      }
    },
    "labelId": {
      "type": "string"
    },
    "showRequired": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "tooltipHelp": {
          "type": "string"
        },
        "tooltipRequired": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_label_metadata.extension._WIDGET_NAME = 'ojLabel';
    __oj_label_metadata.extension._INNER_ELEM = 'label';
    __oj_label_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['accesskey'];
    __oj_label_metadata.extension._WATCHED_ATTRS = ['data-oj-input-id', 'data-oj-set-id'];
    oj.CustomElementBridge.register('oj-label', { metadata: __oj_label_metadata });
  })();

});


define('ojs/ojlabelledbyutils',['ojs/ojlabel'], function (ojlabel) { 'use strict';

  /**
   * @class oj.LabelledByUtils
   * @classdesc JET Labelled Component Utils
   * @export
   * @since 7.1.0
   * @hideconstructor
   * @ignore
   *
   */
  const LabelledByUtils = {};

  // S T A T I C    V A R S

  /**
   * String used in the label element's id for custom &lt;oj-label>
   * @const
   * @ignore
   * @type {string}
   */
  LabelledByUtils.CUSTOM_LABEL_ELEMENT_ID = '|label';

  /**
   * On form component initialization and when form component's 'labelledBy' property changes,
   * call this function to update aria-labelledby on the rootElement of the 'set' component
   * and update aria-describedby on the inputs when labelledBy changes.
   * For custom element only.
   * Only call for the 'set' components, like oj-radioset, oj-color-palette.
   *
   * Background of how oj-label and 'set' components are linked together for accessibility:
   * --------------------------------------------------------------------------------------
   * An application developer links oj-label with a 'set' component like this:
   * <oj-label id='foo'> to <oj-checkboxset labelled-by='foo'>
   *
   * We render the aria and data-oj- attributes on the correct dom like this:
   * <oj-label id='foo' data-oj-set-id='cb'><span id="foo|label_helpIcon"<label id='foo|label'>
   * <oj-checkboxset id='cb' labelled-by='foo' aria-labelledby='foo|label' described-by='foo|label_helpIcon'>
   * <input aria-describedby='foo|label_helpIcon'>
   *
   * In steps:
   * 1. App developer adds labelled-by on its set form component to link them
   * 2. On init, set form component calls _labelledByUpdatedForSet
   * 2a. this writes labelledBy to aria-labelledby on $focusElem,
   * making sure not to override any existing ids
   * 2b. this writes data-oj-set-id onto oj-label
   * 3. oj-label gets notified of data-oj-set-id change and uses it to find the form component
   * using document.getElementById (we want to avoid dom attribute searches for performance reasons)
   * 4. if it has a required/help icon oj-label writes described-by on the set form component,
   * which in turn calls _describedByUpdated.
   * 4a. writes aria-describedby onto its content element to point
   * to the icon text via _describedByUpdated
   * ---------------------------------------------------------------------------------------
   * Note: input form components are linked to the label via for/id. In that case, oj-label
   * finds the form component with document.getElementById(for), writes labelled-by on the form
   * component which in turn writes data-oj-input-id on the label to let the oj-label know what to
   * write for 'for' on its internal label element.
   * this does not happen here. It happens in EditableValueUtils.
   * @param {string} componentId id of the form component.
   * @param {string|null} originalLabelledBy the old value of the labelledBy option
   * @param {string|null} newLabelledBy the new value of the labelledBy option.
   * @param {jQuery} $focusElem jquery Object containing the node(s)
   * to add/remove aria-labelledby to.
   * For 'set' components this is the root element, not the individual inputs.
   * @private
   * @ignore
   */
  LabelledByUtils._labelledByUpdatedForSet = function (
    componentId,
    originalLabelledBy,
    newLabelledBy,
    $focusElem
  ) {
    if (!originalLabelledBy && !newLabelledBy) {
      // nothing to update. return
      return;
    }

    if (!this._IsCustomElement()) {
      return;
    }
    var _updateLabelledBySetAdd = function ($el, labelId, args) {
      const suffix = LabelledByUtils.CUSTOM_LABEL_ELEMENT_ID;
      LabelledByUtils._addAriaLabelledBy($el, labelId + suffix);
      LabelledByUtils._addSetIdOnLabel(labelId, args.componentId);
    };

    var _updateLabelledBySetRemove = function ($el, labelId, args) {
      const suffix = LabelledByUtils.CUSTOM_LABEL_ELEMENT_ID;
      LabelledByUtils._removeAriaLabelledBy($el, labelId + suffix);
      LabelledByUtils._removeSetIdOnLabel(labelId, args.componentId);
    };

    // callbacks for what needs to happen when the set form component's labelledBy property changes.
    var callbackObj = {
      callbackAdd: _updateLabelledBySetAdd,
      callbackRemove: _updateLabelledBySetRemove,
      args: { componentId: componentId }
    };

    LabelledByUtils._byUpdatedTemplate(originalLabelledBy, newLabelledBy, $focusElem, callbackObj);
  };

  /**
   * On initialization and when form component's 'describedBy' property changes,
   * call this function to update the aria-describedby attribute on the content elements.
   * oj-label writes described-by onto the form component if it has a help icon or required icon
   * for set components.
   * @param {string|null} originalDescribedBy the old value of the 'describedBy' property.
   * This can be a space-delimited list of ids.
   * @param {string|null} newDescribedBy the new value of the 'describedBy' property. This can
   * be a space-delimited list of ids.
   * @param {jQuery} $focusElem jquery Object containing the node(s)
   * to add/remove aria-describedby to. This is the content element usually.
   * @private
   * @ignore
   */
  LabelledByUtils._describedByUpdated = function (
    originalDescribedBy,
    newDescribedBy,
    $focusElem = this._GetContentElement()
  ) {
    if (!originalDescribedBy && !newDescribedBy) {
      // nothing to update. return
      return;
    }
    var _addAriaDescribedBy = function ($elems, id) {
      LabelledByUtils._addRemoveAriaBy($elems, 'aria-describedby', id, true);
    };
    var _removeAriaDescribedBy = function ($elems, id) {
      LabelledByUtils._addRemoveAriaBy($elems, 'aria-describedby', id, false);
    };

    // callbacks for what needs to happen when the form compnent's describedBy property changes.
    var callbackObj = {
      callbackAdd: _addAriaDescribedBy,
      callbackRemove: _removeAriaDescribedBy
    };

    LabelledByUtils._byUpdatedTemplate(originalDescribedBy, newDescribedBy, $focusElem, callbackObj);
  };

  // Helper functions only called from within this file.

  /**
   * Code that gets called when labelledBy or describedBy is updated that does the parsing
   * of the space-delimited attributes and figures out what ids are added and what ids are removed
   * from the originalValue to the newValue. Then it calls the callbackObj's functions to do the
   * particular work.
   * This function's main purpose is to reduce code duplication in this file in _describedByUpdated
   * and _LabelledByUpdated.
   * @param {string|null} originalValue the old value of the labelledBy/describedBy option
   * @param {string|null} newValue the new value of the labelledBy/describedBy option.
   * @param {jQuery} $focusElem jquery Object containing the node(s)
   * to add/remove aria-* to to.
   * @param {Object} callbackObj with parameters 'callbackAdd', 'callbackRemove' and optional 'args'
   * for additional arguments the callback function may need.
   * @private
   * @ignore
   *
   */
  LabelledByUtils._byUpdatedTemplate = function (originalValue, newValue, $focusElem, callbackObj) {
    var byId;
    var tokens;
    var originalTokens;
    var i;

    // The most likely use case if originalLabelledBy is null. Check for that first.
    if (!originalValue && newValue) {
      // newValue can be a space-separated list of ids, so we need to split it and add the suffix
      // to each one and put it back into a space-separated list.
      tokens = newValue.split(/\s+/);
      for (i = 0; i < tokens.length; i++) {
        byId = tokens[i];
        callbackObj.callbackAdd.call(this, $focusElem, byId, callbackObj.args);
      }
    } else if (originalValue && !newValue) {
      // remove all
      tokens = originalValue.split(/\s+/);
      for (i = 0; i < tokens.length; i++) {
        byId = tokens[i];
        callbackObj.callbackRemove.call(this, $focusElem, byId, callbackObj.args);
      }
    } else if (originalValue && newValue) {
      // if both have values, then we should figure out which are the
      // same and ignore them, and remove the ones from originalLabelledBy that are unique and
      // add the ones for newLabelledBy that are unique.
      tokens = newValue.split(/\s+/);
      originalTokens = originalValue.split(/\s+/);
      for (i = 0; i < originalTokens.length; i++) {
        byId = originalTokens[i];
        if (newValue.indexOf(byId) === -1) {
          // not in both, so remove it (add the suffix)
          callbackObj.callbackRemove.call(this, $focusElem, byId, callbackObj.args);
        }
      }
      for (i = 0; i < tokens.length; i++) {
        byId = tokens[i];
        if (originalValue.indexOf(byId) === -1) {
          // not in both, so add it (add the suffix)
          callbackObj.callbackAdd.call(this, $focusElem, byId, callbackObj.args);
        }
      }
    }
  };

  /**
   * Add the id to the widget's aria-labelledby attribute.
   * @param {jQuery} $elems the jquery element(s) that represents the node on which aria-labelledby is
   * @param {string} id id to add to aria-labelledby
   * @private
   * @ignore
   */
  LabelledByUtils._addAriaLabelledBy = function ($elems, id) {
    LabelledByUtils._addRemoveAriaBy($elems, 'aria-labelledby', id, true);
  };

  /**
   * Remove the id from the widget's aria-labelledby attribute.
   * @param {jQuery} $elems the jquery element(s) that represents the node on which aria-labelledby is
   * @param {string} id id to remove from aria-labelledby
   * @private
   * @ignore
   */
  LabelledByUtils._removeAriaLabelledBy = function ($elems, id) {
    LabelledByUtils._addRemoveAriaBy($elems, 'aria-labelledby', id, false);
  };

  /**
   * Add 'data-oj-set-id' on oj-label, which in turn will
   * set described-by back on the Form component.
   * @param {string} ojLabelId the oj-label element's id.
   * @param {string} formComponentId the id of the form component
   * @private
   * @ignore
   */
  LabelledByUtils._addSetIdOnLabel = function (ojLabelId, formComponentId) {
    var ojLabel = document.getElementById(ojLabelId);
    if (ojLabel) {
      if (!ojLabel.getAttribute('data-oj-set-id')) {
        ojLabel.setAttribute('data-oj-set-id', formComponentId);
      }
    }
  };

  /**
   * Remove 'data-oj-set-id' on oj-label, which in turn will
   * set described-by back on the Form component.
   * @param {string} ojLabelId the oj-label element's id.
   * @param {string} formComponentId the id of the form component
   * @param {boolean} add true if you want to add, false if you want to remove.
   * @private
   * @ignore
   */
  LabelledByUtils._removeSetIdOnLabel = function (ojLabelId) {
    var ojLabel = document.getElementById(ojLabelId);
    if (ojLabel) {
      if (ojLabel.getAttribute('data-oj-set-id')) {
        ojLabel.removeAttribute('data-oj-set-id');
      }
    }
  };

  /**
   * Add or remove the aria- from the element(s).
   * @param {JQuery} $elems jquery Object containing the node(s) to add/remove ariaAttr to.
   * @param {string} ariaAttr aria attribute name 'aria-describedby' or 'aria-labelledby'
   * @param {string} id one id to add or remove to 'aria-describedby' or 'aria-labelledby'
   * @param {boolean} add if true, it will add the id, otherwise it will remove it.
   * @private
   * @ignore
   *
   */
  LabelledByUtils._addRemoveAriaBy = function ($elems, ariaAttr, id, add) {
    $elems.each(function () {
      // get ariaAttr that is on the content element(s)
      let ariaAttributeValue = this.getAttribute(ariaAttr);
      // split into tokens
      let tokens = ariaAttributeValue ? ariaAttributeValue.split(/\s+/) : [];
      // Get index that id is in the tokens, if at all.
      let index = tokens.indexOf(id);
      // add id if it isn't already there, remove id if it is there.
      if (add && index === -1) {
        tokens.push(id);
      } else if (!add && index !== -1) {
        // remove that from the tokens array
        tokens.splice(index, 1);
      }
      let newValue = tokens.join(' ').trim();
      if (newValue) {
        this.setAttribute(ariaAttr, newValue); // @HTMLUpdateOK
      } else {
        this.removeAttribute(ariaAttr);
      }
    });
  };

  return LabelledByUtils;

});


define('ojs/ojmenu',['jquery', 'ojs/ojjquery-hammer', 'ojs/ojpopupcore', 'ojs/ojoption', 'ojs/ojcore-base', 'hammerjs', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojanimation', 'ojs/ojlogger', 'ojs/ojconfig', 'ojs/ojcustomelement-utils', 'ojs/ojcustomelement-registry'], function ($, ojjqueryHammer, ojpopupcore, ojoption, oj, Hammer, Context, ThemeUtils, Components, AnimationUtils, Logger, Config, ojcustomelementUtils, ojcustomelementRegistry) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  (function () {
    // -----------------------------------------------------------------------------
    // "private static members" shared by all menus
    // -----------------------------------------------------------------------------

    // Array to track all opened menu popups. All the menus opened by Menu Buttons/ Context Menu/using menu.open() and standalone menus having open submenus, will be added to list
    // and later will be removed on __dismiss()/_close() on menu popup/standalone menu.
    var _openPopupMenus = [];

    // See usage for explanation.  Can be boolean (doesn't need to be re-entrant int), since
    // baseComponent.touchendMousedownThreshold is much less than baseComponent.pressHoldThreshold.
    var _contextMenuPressHoldJustEnded = false;

    /**
     * Key used to store the menu's position object as a jQuery data property.
     * @const
     * @private
     * @type {string}
     */
    var _POSITION_DATA = 'oj-menu-position';

    const _OJ_MENU_SELECT_MANY = 'OJ-MENU-SELECT-MANY';

    const _OJ_MENU_ITEM_CLASS = '.oj-menu-item';
    const _OJ_FOCUS_ANCESTOR = '.oj-focus-ancestor';
    const _OJ_MENU_DIVIDER = '.oj-menu-divider';
    const _OJ_DISABLED_CLASS = '.oj-disabled';
    const _OJ_DISABLED = 'oj-disabled';

    const _ARIA_EXPANDED = 'aria-expanded';
    const _ARIA_HIDDEN = 'aria-hidden';
    const _ARIA_DISABLED = 'aria-disabled';
    const _ARIA_ACTIVEDESCENDANT = 'aria-activedescendant';
    const _DATA_OJ_DEFAULT_MARGIN = 'data-oj-default-margin';
    const _MARGIN_LEFT = 'margin-left';
    const _MARGIN_RIGHT = 'margin-right';
    const _OJ_MENU_ITEM_BEFORE_DIVIDER = 'oj-menu-item-before-divider';
    const _OJ_MENU_CSS_VARS = {
      animation: {
        dropdown: {
          open: '--oj-private-menu-global-drop-down-open-animation',
          close: '--oj-private-menu-global-drop-down-close-animation'
        },
        sheet: {
          open: '--oj-private-menu-global-sheet-open-animation',
          close: '--oj-private-menu-global-sheet-close-animation'
        },
        submenu: {
          open: '--oj-private-menu-global-submenu-open-animation',
          close: '--oj-private-menu-global-submenu-close-animation'
        }
      }
    };

    var _SHEETS_HAVE_CANCEL_ITEM =
      ThemeUtils.getCachedCSSVarValues(['--oj-private-menu-global-sheet-cancel-affordance'])[0] ===
      'menuItem';
    var _SHEETS_HAVE_SWIPE_DOWN_TO_DISMISS =
      ThemeUtils.getCachedCSSVarValues(['--oj-private-menu-global-sheet-swipe-down-behavior'])[0] ===
      'dismiss';
    var _DROPDOWN_MODALITY =
      ThemeUtils.getCachedCSSVarValues(['--oj-private-menu-global-drop-down-modality'])[0] ||
      'modeless'; // backward-compatible value
    var _SHEET_MODALITY =
      ThemeUtils.getCachedCSSVarValues(['--oj-private-menu-global-sheet-modality'])[0] || 'modal';

    // "bottom-0", "bottom-12", or "bottom-10%", per standard JQUI position utility syntax. Put the
    // minus on position's "at", not "my", so that %'s (which we're not using, but themers might) are relative to window,
    // not menu, thus closer to behavior of using % margin in CSS.  SCSS code comment on our $var says we use "at".
    var _SHEET_POSITION_AT =
      'bottom-' +
      (ThemeUtils.getCachedCSSVarValues(['oj-private-menu-global-sheet-margin-bottom'])[0] || 0);

    var _HAMMER_OPTIONS = _SHEETS_HAVE_SWIPE_DOWN_TO_DISMISS && {
      recognizers: [[Hammer.Swipe, { direction: Hammer.DIRECTION_HORIZONTAL }]]
    };

    var _SUBID_CANCEL = 'oj-menu-cancel-command';

    // Submenu's y offset is equal to 0.5rem margin + 1px border of menu divider
    let remInPixels = parseInt(window.getComputedStyle(document.documentElement).fontSize, 10);
    const Y_SUBMENU_OFFSET = -(0.5 * remInPixels + 1);

    function _findImmediateMenuItems(activeMenu) {
      var menuItems = [];
      var deferredChild = activeMenu.children('oj-defer').first();
      var children;
      if (deferredChild.length > 0) {
        children = deferredChild.children('.oj-menu-item, oj-menu-select-many');
      } else {
        children = activeMenu.children('.oj-menu-item, oj-menu-select-many');
      }
      for (var i = 0; i < children.length; i++) {
        var child = $(children[i]);
        if (child.is(_OJ_MENU_ITEM_CLASS)) {
          menuItems.push(child[0]);
        } else if (child[0].nodeName === _OJ_MENU_SELECT_MANY) {
          menuItems = $.merge(menuItems, child.children(_OJ_MENU_ITEM_CLASS));
        }
      }
      return menuItems;
    }

    /**
     * @typedef {Object} oj.ojMenu.PositionAlign
     * @property {"top"|"bottom"|"center"} [vertical] Vertical alignment.
     * @property {"start"|"end"|"left"|"center"|"bottom"} [horizontal] Horizontal alignment. <p>
     * <ul>
     *  <li><b>"start"</b> evaluates to "left" in LTR mode and "right" in RTL mode.</li>
     *  <li><b>"end"</b> evaluates to "right" in LTR mode and "left" in RTL mode.</li>
     * </ul>
     *
     */

    /**
     * @typedef {Object} oj.ojMenu.PositionPoint
     * @property {number} [x] Horizontal alignment offset.
     * @property {number} [y] Vertical alignment offset.
     */

    /**
     * @typedef {Object} oj.ojMenu.Position
     * @property {Object} [my] Defines which edge on the menu to align with the target ("of") element.
     * @property {Object} [at] Defines which position on the target element ("of") to align the positioned element
     *                                  against.
     * @property {Object} [offset] Defines a point offset in pixels from the ("my") alignment.
     * @property {string|Object} [of] Which element to position the menu against.  The default is the
     * <code class="prettyprint">launcher</code> argument passed to the
     * <code class="prettyprint">open</code> method. <p>
     *
     * If the value is a string, it should be a selector or the literal string value
     * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
     * is used, the values are relative to the whole document.  Page horizontal and vertical
     * scroll offsets need to be factored into this point - see UIEvent
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
     *
     * @property {"flip"|"fit"|"flipfit"|"flipcenter"|"none"} [collision] Rule for alternate alignment. <p>
     * <ul>
     *  <li><b>"flip"</b> the element to the opposite side of the target and the
     *             collision detection is run again to see if it will fit. Whichever side
     *             allows more of the element to be visible will be used. </li>
     * <li><b>"fit"</b> shift the element away from the edge of the window. </li>
     * <li><b>"flipfit"</b> first applies the flip logic, placing the element
     *  on whichever side allows more of the element to be visible. Then the fit logic
     *  is applied to ensure as much of the element is visible as possible.</li>
     * <li><b>flipcenter</b> first applies the flip rule and follows with center alignment.</li>
     * <li><b>"none"</b> no collision detection.</li>
     * </ul>
     * @ojsignature [{target:"Type", value:"oj.ojMenu.PositionAlign", for:"my", jsdocOverride:true},
     *               {target:"Type", value:"oj.ojMenu.PositionAlign", for:"at", jsdocOverride:true},
     *               {target:"Type", value:"oj.ojMenu.PositionPoint", for:"offset", jsdocOverride:true},
     *               {target:"Type", value:"string|oj.ojMenu.PositionPoint", for:"of", jsdocOverride:true}]
     */

    /**
     * @typedef {Object} oj.ojMenu.OpenOptions
     * @property {string} [display] Determines whether the menu is displayed as a drop down menu or a sheet menu.
     * @property {string} [initialFocus] Determines focus behavior when the menu is initially opened.
     * @property {string|Element} [launcher] The DOM node (which may or may not be a JET element) that launches this menu.
     * @property {Object} [position] Determines the position of a drop down menu when launched. Ignored for sheet menus.
     * @ojsignature {target:"Type", value:"oj.ojMenu.Position", for:"position", jsdocOverride:true}
     */

    /**
     * @ojcomponent oj.ojMenu
     * @ojdisplayname Menu
     * @augments oj.baseComponent
     * @ojrole menu
     * @since 0.6.0
     * @ojshortdesc A menu displays a list of options in a popup.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["openOptions.display", "openOptions.initialFocus", "disabled"]}
     * @ojvbdefaultcolumns 2
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-menu-modal'
     * @ojuxspecs ['menu']
     *
     * @classdesc
     * <h3 id="menuOverview-section">
     *   JET Menu
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#menuOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant popup menu with touch, mouse and keyboard interactions for navigation.
     *
     * <p>A JET Menu is created using an ( <code class="prettyprint">&lt;oj-menu></code> ) tag with an ( <code class="prettyprint">&lt;oj-option></code> ) tag representing each menu item:
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-menu id="menu" style="display:none" aria-label="Order Edit">
     *   &lt;oj-option value="item1">Item 1&lt;/oj-option>
     *   &lt;oj-option value="item2">Item 2&lt;/oj-option>
     *   &lt;oj-option>Item 3
     *     &lt;oj-menu id="submenu">
     *       &lt;oj-option value="item3-1">Item 3-1&lt;/oj-option>
     *       &lt;oj-option value="item3-2">Item 3-2&lt;/oj-option>
     *       &lt;oj-option value="item3-3">Item 3-3&lt;/oj-option>
     *       &lt;oj-option value="item3-4">Item 3-4&lt;/oj-option>
     *       &lt;oj-option value="item3-5">Item 3-5&lt;/oj-option>
     *     &lt;/oj-menu>
     *   &lt;/oj-option>
     *   &lt;oj-option>Item 4&lt;/oj-option>
     *   &lt;oj-option>Item 5&lt;/oj-option>
     * &lt;/oj-menu>
     * </code></pre>
     *
     *
     * <h3 id="popup-section">
     *   Popup Menus
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#popup-section"></a>
     * </h3>
     *
     * <p>JET Menu is a popup component, for use with [context menu]{@link oj.baseComponent#contextMenu}, [menu button]{@link oj.ojMenuButton},
     * or similar functionality.  It is not intended to sit inline on the page.  See also the [JET NavigationList]{@link oj.ojNavigationList} component.
     *
     * <p>For this reason, the component is automatically hidden until it is opened.  However, this styling is not applied until the component is initialized.
     *
     * <h3 id="submenus-section">
     *   Submenus
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#submenus-section"></a>
     * </h3>
     *
     * <p>Submenus can be created by specifying nested <code class="prettyprint">oj-menu</code> elements under the desired <code class="prettyprint">oj-option</code> elements.
     *
     * <p>When a submenu is present, a default submenu icon will be automatically added to the parent menu item (see <a href="#itemIcons-section">Menu Item Icons</a>).
     *
     * <p>Sheet menus are not appropriate when submenus are present. Therefore, submenus and there parent menus are always displayed as a drop down regardless of the
     * <code class="prettyprint">open-options.display</code> attribute's value.
     *
     *
     * <h3 id="dividers-section">
     *   Dividers
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dividers-section"></a>
     * </h3>
     *
     * <p>Divider elements can be created by including menu items that contain only spaces and/or dashes, or nothing at all:
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-menu id="menu" style="display:none" aria-label="Order Edit">
     *   &lt;oj-option value="item1">Item 1&lt;/oj-option>
     *   &lt;oj-option>---&lt;/oj-option>
     *   &lt;oj-option value="item2">Item 2&lt;/oj-option>
     * &lt;/oj-menu>
     * </code></pre>
     *
     * <p>For WAI-ARIA compliance, JET automatically adds <code class="prettyprint">role="separator"</code> to the divider element.
     *
     *
     * <h3 id="itemIcons-section">
     *   Menu Item Icons
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#itemIcons-section"></a>
     * </h3>
     *
     * <p>Menu items currently support the rendering of start and end icons. Submenu icons are inserted automatically. To replace the default
     * submenu icon with a custom icon, the <code class="prettyprint">endIcon</code> slot should be specified. To render additional start
     * or end icons for a menu item, the <code class="prettyprint">startIcon</code> or <code class="prettyprint">endIcon</code> slot of the
     * <code class="prettyprint">oj-option</code> should be specified. Icon only menus are not supported, providing menu item label using oj-option is required.
     * See the <code class="prettyprint">oj-option</code> doc for details about
     * accepted children and slots.</p>
     *
     *
     * <h3 id="scrolling-section">
     *   Scrolling
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#scrolling-section"></a>
     * </h3>
     *
     * <p>JET Menus is scrollable when the menu is long. However, scrolling isn't supported on below scenarios: </p>
     * <ul>
     * <li>Scrolling is not supported on phone due to some themes supporting downward swipe dismissal on Sheet Menus.</li>
     * </ul>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>The app should supply either an <code class="prettyprint">aria-label</code> or <code class="prettyprint">aria-labelledby</code>
     * attribute on the menu's root element, except possibly for menu buttons as discussed below. These attributes should not be supplied
     * for submenus, which are labeled automatically.
     *
     * <p>If a menu is shared by different launchers, and should have a different label for each launcher, then a
     * <a href="#event:beforeOpen">ojBeforeOpen</a> listener can be used to set a different label per launch.
     *
     * <p>For a menu launched exclusively by one or more [menu buttons]{@link oj.ojMenuButton}, these attributes are optional.  When the
     * menu is opened via the menu button UI, if neither attribute is present after all <a href="#event:beforeOpen">ojBeforeOpen</a>
     * listeners have been called, then <code class="prettyprint">aria-labelledby</code> will be set on the menu, referencing the menu
     * button, and will be removed when the menu is closed.  This approach provides a useful default label, while allowing the app to
     * supply a different label if desired, and while allowing the menu to be shared by several menu buttons and/or other launchers.
     *
     * <p>Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.<p>
     *
     *
     * <h3 id="reparenting-section">
     *   Reparenting
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
     * </h3>
     *
     *  <p id="reparenting-strategy">
     *     When a menu is opened, it will be reparented in the document and reparented back when closed.
     *     The goal of this design is to maintain as much of the page author's document structure as possible, while
     *     avoiding most of the clipping and positioning issues of a completely inline design.
     *  </p>
     *  <p>
     *     If opened from another popup, the menu will be reparented to the nearest parent popup.
     *     Otherwise, the menu will be reparented to a container in the document body.
     *  </p>
     *  <p>
     *     The context of opening is defined by the resolved <code class="prettyprint">openOptions.launcher</code> value,
     *     which can be set via the <a href="#openOptions.launcher">attribute</a>, via the argument to the <a href="#open">open()</a>
     *     method, or via a <a href="#event:beforeOpen">ojBeforeOpen</a> listener.
     *  <p>
     *     All menus are assigned the same z-index values. The layering between peer popups reflects the opening order.
     *     In addition, the page author has control over z-index weights by way of the menu's layer.
     *     The menu's layer defines the "stacking context" and assignd the "oj-menu-layer" style.
     *  </p>
     *  <p>
     *     Some notable consequences of this design:
     *  </p>
     *  <ul>
     *    <li>Events raised within the menu will not bubble up to the menu's original ancestors.  Instead, listeners for menu events should
     *        be applied to either the menu's root element, or the document.</li>
     *    <li>Likewise, developers should not use CSS descendant selectors, or similar logic, that assumes that the menu will remain a child
     *        of its original parent.</li>
     *  </ul>
     *
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <p>If a menu launcher (such as a [menu button]{@link oj.ojMenuButton} or item with a [context menu]{@link oj.baseComponent#contextMenu})
     * is stamped inside a table, dataGrid, or other container, the resulting set of launchers should share a single menu defined outside the container.
     *
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
     * is changed post-init, the menu must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
     *
     *
     * <h3 id="binding-section">
     *   Declarative Binding
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
     * </h3>
     *
     * <p>For components like Menu and Buttonset that contain a number of like items, applications may wish to use an <code class="prettyprint">oj-bind-for-each</code> Knockout binding
     * to stamp out the contents as follows:
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-menu id="menu" style="display:none" aria-label="Order Edit">
     *     &lt;oj-bind-for-each data="[[menuItems]]">
     *         &lt;template>
     *             &lt;oj-option value="[[$current.data.label]]" :id="[[$current.data.id]]" :disabled="[[$current.data.disabled]]">
     *                 &lt;span>
     *                     &lt;oj-bind-text value="[[$current.data.label]]">&lt;/oj-bind-text>
     *                 &lt;/span>
     *             &lt;/oj-option>
     *         &lt;/template>
     *     &lt;/oj-bind-for-each>
     * &lt;/oj-menu>
     * </code></pre>
     */
    // Override contextMenu slot definition to remove it from the jsdoc as it is not supported for menus

    /**
     * @ojslot contextMenu
     * @memberof oj.ojMenu
     * @ignore
     */

    //-----------------------------------------------------
    //                   Slots
    //-----------------------------------------------------

    /**
     * <p>The &lt;oj-menu> element accepts <code class="prettyprint">oj-option</code> and <code class="prettyprint">oj-menu-select-many</code> as child elements.  See
     * the [oj-option]{@link oj.ojOption} documentation for details about accepted children and slots.</p>
     *
     * @ojchild Default
     * @memberof oj.ojMenu
     * @ojshortdesc The oj-menu element accepts oj-option and oj-menu-select-many as child elements.
     * @ojpreferredcontent ["OptionElement", "MenuSelectManyElement"]
     *
     * @example <caption>Initialize the Menu with child content specified:</caption>
     * &lt;oj-menu>
     *   &lt;oj-option value="option1">Option 1&lt;/oj-option>
     *   &lt;oj-option value="option2">Option 2&lt;/oj-option>
     *   &lt;oj-option value="option3">Option 3&lt;/oj-option>
     * &lt;/oj-menu>
     */

    /**
     * @ojslot contextMenu
     * @memberof oj.ojMenu
     * @ignore
     */

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the root element of the Menu component.
     *
     * @method
     * @name oj.ojMenu#widget
     * @memberof oj.ojMenu
     * @instance
     * @ignore
     * @return {jQuery} the root element of the component
     */

    /**
     * Removes the menu functionality completely. This will return the element back to its pre-init state.
     *
     * @method
     * @name oj.ojMenu#destroy
     * @memberof oj.ojMenu
     * @instance
     * @ignore
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Menu Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Invoke the menu item's action.</td>
     *     </tr>
     *     <tr>
     *       <td>Menu</td>
     *       <td><kbd>Swipe Down</kbd></td>
     *       <td>Dismiss the menu, if "swipe to dismiss" is enabled by the application.</td>
     *     </tr>
     *     <tr>
     *       <td>JET Component or HTML Element having a JET Context Menu</td>
     *       <td><kbd>Press & Hold</kbd></td>
     *       <td>Open the context menu.</td>
     *     </tr>
     *     <tr>
     *       <td>Outside of Menu</td>
     *       <td><kbd>Touch</kbd></td>
     *       <td>Close the menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>Disabled items do not allow any touch interaction.
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojMenu
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "5">Menu Item</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Invoke the focused menu item's action.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus to the previous menu item, wrapping around at the top.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus to the next menu item, wrapping around at the bottom.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Home</kbd></td>
     *       <td>Move focus to the first menu item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>End</kbd></td>
     *       <td>Move focus to the last menu item.</td>
     *     </tr>
     *     <tr>
     *       <td>Menu Item in Top-level Menu</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Close the menu and move focus to the launcher.</td>
     *     </tr>
     *     <tr>
     *       <td>JET Component or HTML Element having a JET Context Menu</td>
     *       <td><kbd>Shift + F10</kbd></td>
     *       <td>Open the context menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>* RTL refers to pages written in a right-to-left language such as Arabic.
     *
     * <p>Typing a letter moves focus to the first item whose title starts with that character. Repeating the same character cycles through matching items.
     * Typing more characters within the one second timer matches those characters.
     *
     * <p>Note that the "Search for text when I start typing" feature in Firefox can interfere with web content that accepts keystrokes, such as this "type a letter" feature of JET Menu.
     *
     * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojMenu
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the <a href="#dismissal-section">"Cancel"</a> menu item.</p>
     *
     * @ojsubid oj-menu-cancel-command
     * @memberof oj.ojMenu
     * @since 2.1.0
     *
     * @example <caption>Get the node for the "Cancel" menu item:</caption>
     * var node = myMenu.getNodeBySubId( {'subId': 'oj-menu-cancel-command'} );
     */
    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------
    /**
     * @ojstylevariableset oj-menu-css-set1
     * @ojstylevariable oj-menu-icon-size {description: "Menu icon size", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-icon-to-edge-padding {description: "Padding between icon and menu edge",formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-text-to-start-icon-padding {description: "Padding between text and start icon", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-text-to-end-icon-padding {description: "Padding between text and end icon", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-text-to-edge-padding {description: "Padding between text and menu edge",formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-divider-margin {description: "Menu divider margin", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-sheet-margin-horizontal {description: "Menu horizontal margin when displayed as a sheet", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-menu-item-text-color {description: "Menu item text color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-menu-icon-color {description: "Menu icon color", formats: ["color"], help: "#css-variables"}
     * @memberof oj.ojMenu
     */
    oj.__registerWidget('oj.ojMenu', $.oj.baseComponent, {
      defaultElement: '<ul>', // added to externs.js, since this is an override of a superclass member.  (That's the rule for public methods, what about protected fields?)  TODO: Would @override do the job and be better than externing?
      delay: 300, // Doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it unquoted for now.  TBD: This is private, but do NOT rename to _delay since there's an inherited instance method by that name, so rename so something else prefixed with _.
      role: 'menu', // private.  I moved from options to here since no longer public option.  Leave unquoted so gets renamed by GCC as desired.
      widgetEventPrefix: 'oj',
      options: {
        // options is in externs.js, so no need for quotes
        /**
         * Disables the menu if set to <code class="prettyprint">true</code>.
         *
         * @member
         * @name disabled
         * @memberof oj.ojMenu
         * @instance
         * @type {boolean}
         * @default false
         *
         * @example <caption>Initialize the menu with the <code class="prettyprint">disabled</code> attribute specified:</caption>
         * &lt;oj-menu disabled='true'>&lt;/oj-menu>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabledValue = myMenu.disabled;
         *
         * // setter
         * myMenu.disabled = true;
         */
        // disabled option declared in superclass, but we still want the above API doc

        // Deprecated in release 2.1.0.  Should be removed when that release End-of-Lifes.
        // At that time, update the "if not ul" check in _ComponentCreate per comment there, and update non-ul unit tests to ensure we throw in that case.
        /**
         * Selector for the elements that serve as the menu container, including submenus.
         *
         * <p>Note: The <code class="prettyprint">menuSelector</code> attribute should not be changed after initialization. Existing submenus will not be updated.
         *
         * @expose
         * @memberof oj.ojMenu
         * @instance
         * @ignore
         * @type {string}
         * @default "ul"
         * @deprecated 2.1.0 Menus should always be created from an unordered list ( <code class="prettyprint">&lt;ul></code> ).
         *   This API will be removed in a future release.
         */
        menuSelector: 'ul',

        /**
         * <p>A collection of settings impacting the launch of a menu.  These <code class="prettyprint">openOptions</code>
         * may be accessed and overridden individually or collectively, as seen in the examples.
         *
         * <p>The values set here can be overridden on a per-launch basis by passing the corresponding params into the
         * <a href="#open">open</a> method.  Those per-launch values can be further customized by a
         * <a href="#event:beforeOpen">ojBeforeOpen</a> listener.
         *
         * <p>The built-in [menu button]{@link oj.ojMenuButton} and [context menu]{@link oj.baseComponent#contextMenu} functionality
         * overrides some of the Menu's <code class="prettyprint">openOptions</code>, for WAI-ARIA compliance and other reasons.
         * Thus, if the app really wants to customize
         * those values, it must do so in a <code class="prettyprint">ojBeforeOpen</code> listener.  If the built-in menu button
         * or context menu functionality is modified in this way, it is the app's responsibility to ensure that the result is
         * both correct and accessible.
         *
         * @expose
         * @memberof oj.ojMenu
         * @ojshortdesc Specifies settings for launching a menu. See the Help documentation for more information.
         * @instance
         * @type {Object}
         * @ojsignature { target: "Type",
         *                value: "oj.ojMenu.OpenOptions",
         *                jsdocOverride: true }
         *
         * @example <caption>Initialize the menu, setting some <code class="prettyprint">openOptions</code> values.</caption>
         * &lt;oj-menu open-options.initial-focus='true' open-options.launcher='myLauncher'>&lt;/oj-menu>
         *
         * @example <caption>Get or set the <code class="prettyprint">openOptions</code> attribute, after initialization:</caption>
         * // Get one
         * var value = myMenu.openOptions.launcher;
         *
         * // Get all
         * var values = myMenu.openOptions;
         *
         * // Set one, leaving the others intact
         * myMenu.setProperty('openOptions.initialFocus', 'none');
         *
         * // Set many.  Any existing openOptions not listed are lost
         * myMenu.openOptions = { 'launcher': 'myLauncher',
         *                        'initialFocus': 'firstItem',
         *                        'position': myPositionObj };
         */
        openOptions: {
          /**
           * <p>Determines whether the menu is displayed as a drop down menu or a sheet menu.
           *
           * <p>The default value is <code class="prettyprint">"auto"</code>, in which case the behavior depends on the
           * type of device, as determined by the <code class="prettyprint">Config.getDeviceRenderMode</code> method.
           * If the application is running on a phone device, the menu will display as a sheet.
           * Otherwise, the menu will display as a drop down.
           *
           * <p>Sheet menus are not appropriate when submenus are present.  Thus, menus having submenus are always displayed as
           * a drop down, regardless of the values of this option.
           *
           * @expose
           * @name openOptions.display
           * @ojshortdesc Specifies whether the menu displays as a drop down or as a sheet. See the Help documentation for more information.
           * @memberof! oj.ojMenu
           * @instance
           * @since 2.1.0
           *
           * @type {string}
           * @default "auto"
           * @ojvalue {string} "auto" Displays the menu as a sheet or drop down, depending on the screen width.
           * @ojvalue {string} "dropDown" Displays the menu as a drop down.
           * @ojvalue {string} "sheet" Displays the menu as a sheet.
           *
           * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.display</code> sub-option specified:</caption>
           * &lt;oj-menu open-options.display='dropDown'>&lt;/oj-menu>
           *
           * @example <caption>Get or set the <code class="prettyprint">openOptions.display</code> sub-option, after initialization:</caption>
           * // getter
           * var display = myMenu.openOptions.display;
           *
           * // setter:
           * myMenu.setProperty('openOptions.display', 'sheet');
           */
          display: 'auto',

          /**
           * Determines focus behavior when the menu is initially opened.
           *
           * @expose
           * @name openOptions.initialFocus
           * @ojshortdesc Specifies focus behavior when the menu is initially opened.
           * @memberof! oj.ojMenu
           * @instance
           * @type {string}
           * @default "menu"
           * @ojvalue {string} "none" Leaves focus where it is, e.g. on the launching component.  The application must verify that the result is accessible.
           * @ojvalue {string} "menu" Focuses the menu itself, with no menu item focused (e.g. typical Context Menu behavior).
           * @ojvalue {string} "firstItem" Focuses the first menu item (e.g. MenuButton <kbd>DownArrow</kbd> behavior).
           *
           * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.initialFocus</code> sub-option specified:</caption>
           * &lt;oj-menu open-options.initial-focus='firstItem'>&lt;/oj-menu>
           *
           * @example <caption>Get or set the <code class="prettyprint">openOptions.initialFocus</code> sub-option, after initialization:</caption>
           * // getter
           * var initialFocus = myMenu.openOptions.initialFocus;
           *
           * // setter:
           * myMenu.setProperty('openOptions.initialFocus', 'none');
           */
          initialFocus: 'menu',

          /**
           * <p>The DOM node (which may or may not be a JET element) that launches this menu.
           * This node must be focusable, as focus is returned to it upon menu dismissal.
           *
           * <p>The launcher must either be specified in this component option, or on each menu launch -- see <a href="#open">open()</a>
           * and <a href="#event:beforeOpen">ojBeforeOpen</a>.
           *
           * @expose
           * @name openOptions.launcher
           * @ojshortdesc Specifies the DOM node that launches this menu. See the Help documentation for more information.
           * @memberof! oj.ojMenu
           * @instance
           * @type {string|Element}
           * @default null
           *
           * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.launcher</code> sub-option specified:</caption>
           * &lt;oj-menu open-options.launcher='myLauncher'>&lt;/oj-menu>
           *
           * @example <caption>Get or set the <code class="prettyprint">openOptions.launcher</code> sub-option, after initialization:</caption>
           * // getter
           * var launcher = myMenu.openOptions.launcher;
           *
           * // setter:
           * myMenu.setProperty('openOptions.launcher', 'myLauncher');
           */
          launcher: null,

          /**
           * <p>Determines the position of a drop down menu when launched via the <code class="prettyprint">open()</code> method or via menu button or
           * context menu functionality.  Ignored for sheet menus.
           *
           * <p>The "my" and "at" properties define alignment points relative to the menu and other element.  The "my" property represents the menu's
           * alignment where the "at" property represents the other element that can be identified by "of" or defauts to the launcher when the menu
           * opens.  The values of these properties describe horizontal and vertical alignments.</p>
           *
           * <ul>
           * <li>JET supports <code class="prettyprint">start</code> and <code class="prettyprint">end</code> values wherever <code class="prettyprint">left</code>
           * and <code class="prettyprint">right</code> are supported.  The <code class="prettyprint">start</code> value means "left in LTR; right in RTL",
           * while the <code class="prettyprint">end</code> value means "right in LTR; left in RTL."</li>
           * </ul>
           *
           * <p>Menu also supports the following extended syntax for the <code class="prettyprint">of</code> field:
           *
           * <ul>
           * <li>The <code class="prettyprint">"event"</code> keyword means "position the menu relative to the UI event that opened the menu."</li>
           * <li>The <code class="prettyprint">"launcher"</code> keyword means "position the menu relative to the launcher element."</li>
           * </ul>
           *
           * <p>By default, when the <code class="prettyprint">of</code> field is not set, the menu is positioned relative to the launcher.</p>
           *
           * <p>The default position value varies between menus and submenus as follows:
           * <ul>
           *   <li>Top level menu default: <code class="prettyprint">{ my: { horizontal: "start", vertical: "top" }, at: { horizontal: "start", vertical: "bottom" }, offset: { x: 0, y: 0 }, collision: "flipfit" }</code></li>
           *   <li>Submenu default: <code class="prettyprint">{ my: { horizontal: "start", vertical:  "top" }, at: { horizontal: "end", vertical: "top" }, offset: { x: 0, y: 0 }, collision: "flipfit" }</code></li>
           * </ul>
           *
           * <b>Deprecated v5.0.0 jQuery UI position syntax; Use of a percent unit with "my" or "at" is not supported.</b>
           *
           * @expose
           * @name openOptions.position
           * @ojshortdesc Specifies the position of a drop down menu when launched. See the Help documentation for more information.
           * @memberof! oj.ojMenu
           * @instance
           * @type {Object}
           *
           * @example <caption>Initialize the menu with the <code class="prettyprint">openOptions.position</code> option specified:</caption>
           * &lt;oj-menu open-options.position.my.horizontal='start'>&lt;/oj-menu>
           *
           * @example <caption>Get or set the <code class="prettyprint">openOptions.position</code> sub-option, after initialization:</caption>
           * // Get one field of position object
           * var position = myMenu.openOptions.position.my;
           *
           * // Get entire position object
           * var position = myMenu.openOptions.position;
           *
           * // Set one field of position object, leaving the others intact
           * myMenu.setProperty('openOptions.position.at.horizontal', 'right');
           *
           * // Set entire position object. Any fields not listed are lost.
           * myMenu.setProperty('openOptions.position', {"my": {"horizontal": "start", "vertical": "bottom"},
           *                                             "at": {"horizontal": "end", "vertical": "top" },
           *                                             "offset": {"x": 0, "y":5}});
           */
          position: {
            /**
             * Defines which edge on the menu to align with the target ("of") element.
             *
             * @expose
             * @memberof! oj.ojMenu
             * @instance
             * @name openOptions.position.my
             * @type {{horizontal:string, vertical:string}}
             */
            my: {
              /**
               * Defines the horizontal alignment of the menu.
               * @expose
               * @memberof! oj.ojMenu
               * @instance
               * @name openOptions.position.my.horizontal
               * @type {string}
               * @default 'start'
               * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
               * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
               * @ojvalue {string} "left"
               * @ojvalue {string} "center"
               * @ojvalue {string} "right"
               */
              horizontal: 'start',
              /**
               * Defines the vertical alignment of the menu.
               * @expose
               * @memberof! oj.ojMenu
               * @instance
               * @name openOptions.position.my.vertical
               * @type {string}
               * @default 'top'
               * @ojvalue {string} "top"
               * @ojvalue {string} "center"
               * @ojvalue {string} "bottom"
               */
              vertical: 'top'
            },
            /**
             * Defines a point offset in pixels from the ("my") alignment.
             * @expose
             * @memberof! oj.ojMenu
             * @instance
             * @name openOptions.position.offset
             * @type {{x:number, y:number}}
             */
            offset: {
              /**
               * Horizontal alignment offset.
               * @expose
               * @memberof! oj.ojMenu
               * @instance
               * @name openOptions.position.offset.x
               * @type {number}
               * @default 0
               */
              x: 0,
              /**
               * Vertical alignment offset.
               * @expose
               * @memberof! oj.ojMenu
               * @instance
               * @name openOptions.position.offset.y
               * @type {number}
               * @default 0
               */
              y: 0
            },
            /**
             * Defines which position on the target element ("of") to align the positioned element
             * against.
             *
             * @expose
             * @memberof! oj.ojMenu
             * @instance
             * @name openOptions.position.at
             * @type {{horizontal:string, vertical:string}}
             */
            at: {
              /**
               * Defines the horizontal alignment of what the menu is aligned to. For top-level menus, the default value is "start". For submenus, the default value is "end".
               * @expose
               * @memberof! oj.ojMenu
               * @ojshortdesc Defines the horizontal alignment of what the menu is aligned to. See the Help documentation for more information.
               * @instance
               * @name openOptions.position.at.horizontal
               * @type {string}
               * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
               * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
               * @ojvalue {string} "left"
               * @ojvalue {string} "center"
               * @ojvalue {string} "right"
               */
              horizontal: 'start',
              /**
               * Defines the vertical alignment of what the menu is aligned to. For top-level menus, the default value is "bottom". For submenus, the default value is "top".
               * @expose
               * @memberof! oj.ojMenu
               * @ojshortdesc Defines the vertical alignment of what the menu is aligned to. See the Help documentation for more information.
               * @instance
               * @name openOptions.position.at.vertical
               * @type {string}
               * @ojvalue {string} "top"
               * @ojvalue {string} "center"
               * @ojvalue {string} "bottom"
               */
              vertical: 'bottom'
            },
            /**
             * Which element to position the menu against.  The default is the
             * <code class="prettyprint">launcher</code> argument passed to the
             * <code class="prettyprint">open</code> method.
             *
             * If the value is a string, it should be a selector or the literal string value
             * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
             * is used, the values are relative to the whole document.  Page horizontal and vertical
             * scroll offsets need to be factored into this point - see UIEvent
             * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
             * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
             *
             * @example <caption>Finding the point for an svg element:</caption>
             * var rect = svgDom.getBoundingClientRect();
             * var position = {of:{x:rect.left + window.pageXOffset, y:rect.top + window.pageYOffset}};
             *
             * @expose
             * @memberof! oj.ojMenu
             * @ojshortdesc Which element to position the menu against. See the Help documentation for more information.
             * @instance
             * @name openOptions.position.of
             * @type {string|{x: number, y: number}}
             */
            of: undefined,
            /**
             * Rule for alternate alignment.
             *
             * @expose
             * @memberof! oj.ojMenu
             * @instance
             * @name openOptions.position.collision
             * @type {string}
             * @default 'flipfit'
             * @ojvalue {string} "flip" the element to the opposite side of the target and the
             *  collision detection is run again to see if it will fit. Whichever side
             *  allows more of the element to be visible will be used.
             * @ojvalue {string} "fit" shift the element away from the edge of the window.
             * @ojvalue {string} "flipfit" first applies the flip logic, placing the element
             *  on whichever side allows more of the element to be visible. Then the fit logic
             *  is applied to ensure as much of the element is visible as possible.
             * @ojvalue {string} "flipcenter" first applies the flip rule and follows with center alignment.
             * @ojvalue {string} "none" no collision detection.
             */
            // : Ensure menu stays onscreen (hence no autoscrolling/jumping the page to move it back onscreen), even when when
            // the screen is very small (phones, small desktop browser windows).  If the menu height is less than the viewport height, but
            // greater than the viewport height y-above and y-below the launcher, then with the default "flip" policy, the menu will appear
            // y-above or y-below the launcher, and the window will autoscroll vertically to display the menu, while with the "flipfit" policy, the
            // menu will appear z-above the launcher as needed to stay onscreen, so the window does not need to autoscroll vertically. Likewise horizontally.
            collision: 'flipfit'
          }
        },

        // Omitting the usual verbiage about whether the "other" sub-options are clobbered by a given setter syntax,
        // since only one sub-option currently.
        // TBD: restore that verbiage (copy from openOptions) if gain 2nd sub-option.
        /**
         * <p>A collection of settings impacting the launch of submenus.
         *
         * <p>This option affects submenus, while the similar <code class="prettyprint">openOptions</code> affects the top-level menu.
         *
         * @expose
         * @memberof oj.ojMenu
         * @instance
         * @ignore
         * @type {Object}
         */
        submenuOpenOptions: {
          /**
           * <p>Determines the position of submenus.
           *
           * <p>Please refer to the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility for details about the various choices.
           * In addition to that syntax, note that JET supports the following reading direction-aware extended syntax in the
           * <code class="prettyprint">my</code> and <code class="prettyprint">at</code> fields:
           *
           * <ul>
           * <li>JET supports <code class="prettyprint">start</code> and <code class="prettyprint">end</code> values wherever <code class="prettyprint">left</code>
           * and <code class="prettyprint">right</code> are supported.  The <code class="prettyprint">start</code> value means "left in LTR; right in RTL",
           * values in the <code class="prettyprint">my</code> and <code class="prettyprint">at</code> fields wherever <code class="prettyprint">left</code>
           * and <code class="prettyprint">right</code> are supported.  The <code class="prettyprint">start</code> value means "left in LTR; right in RTL",
           * while the <code class="prettyprint">end</code> value means "right in LTR; left in RTL."</li>
           *
           * <li>Similarly, JET supports <code class="prettyprint">></code> and <code class="prettyprint">&lt;</code> operators wherever <code class="prettyprint">+</code>
           * and <code class="prettyprint">-</code> are supported.  The <code class="prettyprint">></code> value means "+ in LTR; - in RTL",
           * while the <code class="prettyprint">&lt;</code> value means "- in LTR; + in RTL."  E.g. a <code class="prettyprint">my</code> value
           * of <code class="prettyprint">"start>40"</code> shifts the submenu 40px "endward," while a <code class="prettyprint">my</code> value
           * of <code class="prettyprint">"start&lt;40"</code> shifts the submenu 40px "startward."</li>
           * </ul>
           *
           * <p>By default, the submenu is positioned relative to the parent menu item, but if a value is set on
           * the <code class="prettyprint">of</code> field, then the submenu is positioned relative to that element or position instead.
           *
           * @expose
           * @name submenuOpenOptions.position
           * @memberof! oj.ojMenu
           * @instance
           * @ignore
           * @type {Object}
           * @default { "my": "start top", "at": "end top", "collision": "flipfit" }
           */
          position: {
            /** @expose */
            my: 'start top',
            /** @expose */
            at: 'end top',
            collision: 'flipfit' // see comments on openOptions.position.collision
          }
        },

        // Events

        /**
         * Triggered when a default animation is about to start, such as when the component is
         * being opened/closed or a child item is being added/removed. The default animation can
         * be cancelled by calling <code class="prettyprint">event.preventDefault</code>.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @ojshortdesc Triggered when a default animation is about to start, such as when the component is
         * being opened/closed or a child item is being added/removed. The default animation can
         * be cancelled by calling event.preventDefault.
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @ojshortdesc Triggered when a default animation is about to start, such as when the component is being opened/closed or a child item is being added/removed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {"open"|"close"} action The action that triggers the animation.<br><br>
         *            The number of actions can vary from element to element.
         *            Suggested values are:
         *                    <ul>
         *                      <li>"open" - when a menu element is opened</li>
         *                      <li>"close" - when a menu element is closed</li>
         *                    </ul>
         * @property {!Element} element target of animation
         * @property {!function():void} endCallback If the event listener calls
         *            event.preventDefault to cancel the default animation, it must call the
         *            endCallback function when it finishes its own animation handling and any
         *            custom animation has ended.
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateStart</code> event to override the default
         *          "open" animation:</caption>
         * myMenu.addEventListener("ojAnimateStart", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is open
         *     if (event.detail.action == "open") {
         *       event.preventDefault();
         *       oj.AnimationUtils.fadeIn(event.detail.element).then(event.detail.endCallback);
         *   });
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateStart</code> event to override the default
         *          "close" animation:</caption>
         * myMenu.addEventListener("ojAnimateStart", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is close
         *     if (event.detail.action == "close") {
         *       event.preventDefault();
         *       oj.AnimationUtils.fadeOut(event.detail.element).then(event.detail.endCallback);
         *   });
         */
        animateStart: null,

        /**
         * Triggered when a default animation has ended, such as when the component is being
         * opened/closed or a child item is being added/removed. This event is not triggered if
         * the application has called preventDefault on the animateStart
         * event.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @ojshortdesc Triggered when a default animation has ended, such as when the component is being opened/closed or a child item is being added/removed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {!Element} element target of animation
         * @property {"open"|"close"} action The action that triggered the animation.<br><br>
         *                   The number of actions can vary from element to element.
         *                   Suggested values are:
         *                    <ul>
         *                      <li>"open" - when a menu element is opened</li>
         *                      <li>"close" - when a menu element is closed</li>
         *                    </ul>
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateEnd</code> event to listen for the "open"
         *          ending animation:</caption>
         * myMenu.addEventListener("ojAnimateEnd", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is open
         *     if (event.detail.action == "open") {}
         *   });
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateEnd</code> event to listen for the "close"
         *          ending animation:</caption>
         * myMenu.addEventListener("ojAnimateEnd", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is close
         *     if (event.detail.action == "close") {}
         *   });
         */
        animateEnd: null,

        // Benefit of making openOptions live is this:
        //
        // - For MenuButton and ContextMenu, the app doesn't control the call to Menu.open().
        // - Our internal call to this method may pass in overrides to things like "initialFocus", in cases where the Right Thing for (say) MenuButtons differs
        //   from Menu's default option value (which may be tailored to, say, contextMenus).
        //     - This way, we don't have to rely on the app to set these things correctly, and we don't have to permanently set the Menu's options, which may be
        //       shared between (say) a MenuButton, a ContextMenu, and some custom app usage of the menu.
        // - The remaining piece of the puzzle is to give the app a way to override the values set in our internal call to open().  A live payload field handles this.
        //
        // If ever needed, we can add a "submenuOpenOptions" payload field alongside the "openOptions" field.
        /**
         * <p>Triggered before this menu is launched via the <a href="#open">open</a> method or via menu button or context menu functionality.
         * The launch can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         *
         * <p>The <code class="prettyprint">event.detail.openOptions</code> payload field contains the settings being used for this menu launch,
         * resulting from merging the <code class="prettyprint">openOptions</code> passed to <code class="prettyprint">open()</code>, if any,
         * with the <code class="prettyprint">openOptions</code> component option.
         *
         * <p>This field is "live", meaning that the listener can alter fields such as <code class="prettyprint">position</code> to affect this launch without
         * affecting the component option.  Since these changes are applied to the merged object, they supersede both the <code class="prettyprint">openOptions</code>
         * passed to <code class="prettyprint">open()</code> and the <code class="prettyprint">openOptions</code> component option.
         *
         * <p>If any of the above techniques are used to alter the built-in [menu button]{@link oj.ojMenuButton} or [context menu]{@link oj.baseComponent#contextMenu}
         * functionality, it is the app's responsibility to ensure that the result is both correct and accessible.
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @ojshortdesc Triggered before this menu is launched. See the Help documentation for more information.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {Object} openOptions effecting the open operation
         * @ojsignature {target:"Type", value:"oj.ojMenu.OpenOptions", for:"openOptions", jsdocOverride:true}
         */
        beforeOpen: null,

        /**
         * <p>Triggered after this menu is closed.
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @instance
         * @since 2.0.0
         * @property {Event} event a custom event
         */
        close: null,

        /**
         * Triggered when the menu is created.
         *
         * @event
         * @name create
         * @memberof oj.ojMenu
         * @instance
         * @ignore
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Currently empty
         */
        // create event declared in superclass, but we still want the above API doc

        /**
         * <p>Triggered when the active menu item changes.  Private; do not use.
         *
         * <p>Internal notes:
         *
         * <p>We've replaced JQUI's focus/blur events with this internal event, and made their focus/blur methods internal.
         * It's been agreed with the architects that if we ever need any of this API
         * to be public, we'll have a focusedItem option, read-only or R/W, with an optionChange event, instead
         * of the removed API.  (Exact name TBD, but they favored focusedRow, with "ed",  for Table if it had an option rather than
         * a method.)  If for some reason we keep a separate event instead of an optionChange event, do NOT call this event
         * "focusedItem", since that will prevent ever having an "focusedItem" option since same namespace.  Instead, call this
         * "focusedItemChange" in that case.
         *
         * <p>In the meantime, we'll keep firing this private event, since it's used so extensively and usefully in the unit tests to make sure
         * other stuff works, and since keeping this working and tested means that we can just change the name to optionChange if
         * we ever need the public event.
         *
         * <p>The difference between this method and JQUI's focus event is that it fires for blurs too, it doesn't fire if the old
         * and new active item are the same, and we fire a single event, not both a blur and focus, when the active state moves from item A to
         * item B.
         *
         * @event
         * @name _activeItem
         * @memberof oj.ojMenu
         * @instance
         * @private
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.previousItem the previously focused menu item
         * @property {jQuery} ui.item the currently focused menu item
         *
         * @example <caption>Initialize the menu with the <code class="prettyprint">_activeItem</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "_activeItem": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">oj_activeitem</code> event:</caption>
         * // $( ".selector" ) must select either the menu root, or the document, due to reparenting
         * $( ".selector" ).on( "oj_activeitem", function( event, ui ) {} );
         */

        /**
         * <p>Triggered after this menu is launched via the <a href="#open">open</a> method or via menu button or context menu functionality.
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @ojshortdesc Triggered after this menu is launched.
         * @instance
         * @since 2.0.0
         * @property {Event} event a custom event
         */
        open: null,

        /**
         * <p>Triggered when a menu item (other than the built-in <a href="#dismissal-section">"Cancel"</a> item) is selected.
         *
         * <p>To ensure keyboard accessibility, the only correct, supported way to react to the selection of a menu item is to listen
         * for this event.  Click listeners should not be used.
         *
         * <p>To find the value of the menu item that triggered an action event, the event.target.value should be used.
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @ojshortdesc Triggered when a menu item is selected. To ensure keyboard accessibility, the only correct, supported way to react to the selection of a menu item is to listen for this event. See the Help documentation for more information.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @ojeventgroup common
         * @since 4.0.0
         * @ojdeprecated [{since: "10.0.0", description: "This event is no longer supported, use the ojMenuAction event instead."}]
         * @example <caption>Find the value of the selected menu item:</caption>
         *   myMenu.addEventListener("ojAction", function( event )
         *   {
         *     // the target of the action event is the selected &lt;oj-option> element
         *     var itemSelected = event.target;
         *
         *     // find the 'value' of the selected &lt;oj-option> element
         *     var selectedValue = itemSelected.value;
         *   });
         */
        action: null,

        /**
         * <p>Triggered when a menu item (other than the built-in <a href="#dismissal-section">"Cancel"</a> item) is selected.
         *
         * <p>To ensure keyboard accessibility, the only correct, supported way to react to the selection of a menu item is to listen
         * for this event.  Click listeners should not be used.
         *
         * <p>To find the value of the menu item that triggered an menu action event, the event.detail.selectedValue should be used.
         *
         * @expose
         * @event
         * @memberof oj.ojMenu
         * @ojshortdesc Triggered when a menu item is selected. To ensure keyboard accessibility, the only correct, supported way to react to the selection of a menu item is to listen for this event. See the Help documentation for more information.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @ojeventgroup common
         * @since 10.0.0
         * @property {any} selectedValue The value of current selected menu item.
         */
        menuAction: null
      },

      /**
       * @memberof oj.ojMenu
       * @instance
       * @protected
       * @override
       */
      _ComponentCreate: function () {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this._super();

        // Create aliases, that won't be renamed, for the private methods that are called by unit tests.  These unit tests come
        // from JQUI, in which these methods were actually public.  With these aliases, we don't have to @expose private method names
        // (which prevents renaming and bloats minified code), and our internal calls to these methods can be this._focus rather than this["_focus"].
        // TBD: perhaps the unit tests could simulate keyboard events rather than calling these methods.
        this._focusForTesting = this._focus;
        this._nextForTesting = this._next;
        this._selectForTesting = this._select;

        // Cancel menu item is supported for custom elements, so we only need the following check for the old syntax
        if (!this._IsCustomElement()) {
          this._createAsTopLevelMenu();
        } else {
          this.element.hide(); // insist menu is initially hidden
          // fixup the position option if custom element menu or submenu
          var options = this.options;
          options.openOptions.position = oj.PositionUtils.coerceToJet(options.openOptions.position);

          var deferredChild = this.element[0].querySelector('oj-defer');
          if (deferredChild) {
            // oj-menu supports only one oj-defer as immediate child of the menu
            // Adding data-oj-context in order to ensure all components within the oj-defer
            // are upgraded and rendered before positioning the menu ()
            // TODO: Consider a general solution to handle busy context of menu children
            // to handle asynchronous initialization of menu items beyond this case
            deferredChild.setAttribute('data-oj-context', true);
          }
        }
      },

      _preventDefault: function (event) {
        if (this.options.disabled) {
          event.preventDefault();
        }
      },

      _createAsTopLevelMenu: function () {
        var self = this;
        this.activeMenu = this.element;

        // flag used to prevent firing of the click handler as the event bubbles up through nested menus
        this.mouseHandled = false;

        this._setupSwipeBehavior();

        this.element.uniqueId().addClass('oj-menu oj-component').hide().attr({
          role: this.role,
          tabIndex: '0',
          'aria-hidden': 'true'
        });

        // pass true to catch these events on all menus, not just enabled menus
        this._on(true, {
          // Required to stick the focus on disabled menu.
          'mousedown .oj-menu-item': this._preventDefault,
          click: this._preventDefault,
          // On Esc key focus should be shifted to launcher and dismiss menu.
          // the TAB key should also implicitly dismiss the menu
          keydown: function (event) {
            if (this.options.disabled) {
              if (event.keyCode === $.ui.keyCode.ESCAPE || event.keyCode === $.ui.keyCode.TAB) {
                if (event.keyCode === $.ui.keyCode.TAB) {
                  event.preventDefault();
                }

                this._focusLauncherAndDismiss(event);
              }
            }
          }
        });

        // needed since _setOption() is not automatically called at create time.
        // TBD: Would be a little better to toggle these 2 things rather than only setting them if true, as in superclass _setOption().
        if (this.options.disabled) {
          this.element.addClass(_OJ_DISABLED).attr(_ARIA_DISABLED, 'true'); // @HTMLUpdateOK
        }

        var handleMouseEnterMenuItem = function (event) {
          // the focusHandled var ensures that this handler only runs for the target
          // menu item, not for the parent menu items to which the event bubbles. Without it, submenu item becomes
          // non-selectable if mouse outside menu on way from parent item to sub (), and flakiness
          // where sometimes a tap on a menu item inside the submenu doesn't "take" in touch scenarios.
          if (this.focusHandled) {
            return;
          }
          this.focusHandled = true;

          var target = $(event.currentTarget);

          try {
            this._focusIsFromPointer = true;
            this._focus(event, target);
          } finally {
            this._focusIsFromPointer = false;
          }
        }.bind(this);

        var handleMouseLeave = function (event) {
          // Only handle mouseleave if the mouse is leaving the menu, not if
          // the menu is disappearing out from under the mouse.  The latter
          // happens when the mouse is over a submenu, and the submenu is closed
          // via the keyboard (e.g. leftArrow, Esc).  If the callee is called at
          // that time, then a timer clears this.active, which breaks KB nav.
          if (!$(event.target).is(':visible')) {
            return;
          }
          this._collapse(event, 'eventSubtree');
        }.bind(this);

        this._touchStartHandler = function (event) {
          // when the touchstart event bubbles out of the root menu element, we're done with it, so
          // reset this flag to its initial value of false in preparation for the next touch
          this.focusHandled = false;
          var target = $(event.currentTarget);
          this._focus(event, target);
        }.bind(this);

        this.element[0].addEventListener('touchstart', this._touchStartHandler, { passive: true });

        this._delegatedHandleMouseEnterMenuItem = function (event) {
          const selector = _OJ_MENU_ITEM_CLASS;
          const container = event.currentTarget;
          const targetElement = event.target.closest(selector);
          if (targetElement && container.contains(targetElement)) {
            handleMouseEnterMenuItem(
              $.Event(event, {
                currentTarget: targetElement
              })
            );
          }
        };

        // : Bad touch device behavior because the JQUI code relies on the above mouseenter handler to call _focus(),
        // but for parent menu items on touch devices, mouseenter is called only if the previous tap was somewhere outside the
        // parent menu item, not if it was in the submenu.  So call that mouseenter handler on touchstart:
        this.element[0].addEventListener('touchstart', this._delegatedHandleMouseEnterMenuItem, {
          passive: true
        });

        this._on({
          // Prevent focus from sticking to links inside menu after clicking
          // them (focus should always stay on UL during navigation).
          // 'mousedown .oj-menu-item > a': function (event) {
          //  event.preventDefault();
          // },
          'click .oj-disabled > a': function (event) {
            event.preventDefault();
          },
          click: function () {
            // when the click event bubbles out of the root menu element, we're done with it, so
            // reset this flag to its initial value of false in preparation for the next click
            this.mouseHandled = false;
          },
          mouseover: function () {
            // when the mouseover event bubbles out of the root menu element, we're done with it, so
            // reset this flag to its initial value of false in preparation for the next mouse hover.
            // Note that this flag is reset in mouseover event and not in a mouseenter event; mouseover
            // bubbles to the root element, but mouseenter does not.
            this.focusHandled = false;
          },
          'click .oj-menu-item:has(a)': function (event) {
            var target = $(event.target).closest(_OJ_MENU_ITEM_CLASS);
            // the mouseHandled var ensures that the click is handled only for the originally clicked
            // menu item, not for the parent menu items to which it bubbles.
            if (!this.mouseHandled && target.not(_OJ_DISABLED_CLASS).length) {
              this.mouseHandled = true;

              // prevent page scrolling and appending # to page URL, which can interfere with routing, etc.
              // Do this before the bailout so these things are prevented when user clicks a 2nd time on parent menu item.
              // No need to additionally do this for Enter/Space handler, because menu root, not the anchor, has browser focus
              // in that case, so anchor click behavior doesn't happen, so doesn't need to be prevented.
              event.preventDefault();

              if (
                this.active &&
                this.active.closest(target).length &&
                this.active.get(0) !== target.get(0)
              ) {
                // If current active menu item  is decendent of (and not equal to) target menu item then
                // sub menu of the curent target is already open and hence no need to
                // 1. expand the sub menu
                // 2. as current target is a menu item having sub menu no need to invoke this._select(event).
                return;
              }
              // Open submenu on click
              if (target.has('.oj-menu').length) {
                this._expand(event);
              } else {
                // Invoke _select() only for leaf menu items
                this._select(event);
                if (!this.element.is(':focus')) {
                  // If the active item is on the top level, let it stay active.
                  // Otherwise, blur the active item since it is no longer visible.
                  if (this.active && this.active.parents('.oj-menu').length === 1) {
                    if (this._clearTimer) {
                      this._clearTimer();
                    }
                  }
                }
              }
            }
          },
          'mouseenter .oj-menu-item': handleMouseEnterMenuItem,
          mouseleave: handleMouseLeave,
          'mouseleave .oj-menu': handleMouseLeave,
          focus: function (event, keepActiveItem) {
            if (
              !keepActiveItem &&
              event.target !== this.element[0] &&
              !(this._focusSkipLink && event.target === this._focusSkipLink.getLink()[0])
            ) {
              // If there's already an active item, keep it active
              // If not, make the first item active
              // TBD: is there a reason that JQUI needed to redundantly call _focus() on this.active when this.active was already set?
              //      Or should we only call it when it's not set and we're calling it on the first menu item?
              var item = this.active || $(_findImmediateMenuItems(this.element)).first(0);
              this._focus(event, item);
            }
          },
          keydown: this._keydown,
          keyup: function (event) {
            if (event.keyCode === $.ui.keyCode.ENTER || event.keyCode === $.ui.keyCode.SPACE) {
              this.__spaceEnterDownInMenu = false;
            }
          }
        });

        this._focusable({
          applyHighlight: true,
          recentPointer: function () {
            return self._focusIsFromPointer;
          },
          setupHandlers: function (focusInHandler, focusOutHandler) {
            self._focusInHandler = focusInHandler;
            self._focusOutHandler = focusOutHandler;
          }
        });

        // callback that overrides the position['using'] for auto dismissal when aligning element is cropped.
        this._usingCallback = $.proxy(this._usingHandler, this);
        this._setup();
      },

      _createAsSubmenu: function () {
        // set special container name as this should have submenu defaults
        this.element.attr(Components._OJ_CONTAINER_ATTR, this.widgetName); // @HTMLUpdateOK

        this.element
          .uniqueId()
          .addClass('oj-menu oj-component oj-menu-submenu oj-menu-dropdown') // submenus are always dropdown
          .hide()
          .attr({
            role: this.role,
            tabIndex: '0',
            'aria-hidden': 'true'
          });
        this._setup();
      },

      // Resolves a Mobile Safari issue that occurs because mousedown fires after the touchend.
      // To be called only by baseComponent's contextMenu logic, which explains the issue more fully.
      // Gets/sets a static var, since the listener that needs to know whether to bail out is static
      // (shared by all menu instances).
      __contextMenuPressHoldJustEnded: function (val) {
        if (arguments.length) {
          _contextMenuPressHoldJustEnded = val;
          return undefined;
        }
        return _contextMenuPressHoldJustEnded;
      },

      _processOjOptions: function () {
        function _findImmediateOptions(activeMenu) {
          var menuItems = [];
          var deferredChild = activeMenu.children('oj-defer').first();
          var children;
          if (deferredChild.length > 0) {
            children = deferredChild.children('oj-option, oj-menu-select-many');
          } else {
            children = activeMenu.children('oj-option, oj-menu-select-many');
          }
          for (var i = 0; i < children.length; i++) {
            var child = $(children[i]);
            if (child[0].nodeName === 'OJ-OPTION') {
              menuItems.push(child[0]);
            } else if (child[0].nodeName === _OJ_MENU_SELECT_MANY) {
              menuItems = $.merge(menuItems, child.children('oj-option'));
            }
          }
          return $(menuItems);
        }

        this._maxEndIconCount = 0;
        this._maxStartIconCount = 0;
        this._startIconWidth = 0;
        this._endIconWidth = 0;

        var ojOptions = _findImmediateOptions(this.element);
        // clear out any roles or classes that we may have previously set
        this._clearOption(ojOptions);
        for (var i = 0; i < ojOptions.length; i++) {
          var option = ojOptions[i];
          option.customOptionRenderer = this._customOptionRenderer.bind(this);
        }
      },

      _customOptionRenderer: function (optionDom) {
        function getPrevSibling(element) {
          if (
            element.previousElementSibling &&
            element.previousElementSibling.nodeName === 'OJ-OPTION'
          ) {
            return element.previousElementSibling;
          } else if (
            element.previousElementSibling &&
            element.previousElementSibling.nodeName === _OJ_MENU_SELECT_MANY
          ) {
            var node = element.previousElementSibling.lastElementChild;
            if (node.nodeName === 'OJ-OPTION') {
              return node;
            } else if (node.previousElementSibling) {
              return node.previousElementSibling;
            }
            return getPrevSibling(node);
          } else if (
            !element.previousElementSibling &&
            element.parentElement.nodeName === _OJ_MENU_SELECT_MANY
          ) {
            return getPrevSibling(element.parentElement);
          }
          return undefined;
        }
        function getNextSibling(element) {
          if (element.nextElementSibling && element.nextElementSibling.nodeName === 'OJ-OPTION') {
            return element.nextElementSibling;
          } else if (
            element.nextElementSibling &&
            element.nextElementSibling.nodeName === _OJ_MENU_SELECT_MANY
          ) {
            return element.nextElementSibling.firstElementChild;
          } else if (
            (!element.nextElementSibling || element.nextElementSibling.nodeName !== 'OJ-OPTION') &&
            element.parentElement.nodeName === _OJ_MENU_SELECT_MANY
          ) {
            return getNextSibling(element.parentElement);
          }
          return undefined;
        }
        function initDividerNeighbors(dividerDom) {
          var sibling = getPrevSibling(dividerDom);
          if (sibling) {
            $(sibling).addClass(_OJ_MENU_ITEM_BEFORE_DIVIDER);
          }
          sibling = getNextSibling(dividerDom);
          if (sibling) {
            $(sibling).addClass('oj-menu-item-after-divider');
          }
        }
        function initLogicalFirstLastChildOverride(element) {
          // if the menu item is the .oj-menu-item:first-child of the oj-menu-select-many and
          // logical top, add a marker selector
          if (!element.previousElementSibling && !getPrevSibling(element)) {
            $(element).addClass('oj-top');
          }
          // if the menu item is the .oj-menu-item:last-child of the oj-select-many and
          // the logical bottom, add the marker class.  the oj-select-many can have a hidden
          // storage node as the last item due to the oj-bind-if in the view template
          if (
            (!element.nextElementSibling || element.nextElementSibling.nodeName !== 'OJ-OPTION') &&
            !getNextSibling(element)
          ) {
            $(element).addClass('oj-bottom');
          }
        }

        // Implement custom rendering here...
        var ojOption = $(optionDom);
        var isCheckableMenuItem = ojOption.parent().prop('nodeName') === _OJ_MENU_SELECT_MANY;
        var self = this;

        this._hasSubmenus = false;

        // if 'a' tag already exists, we need to remove it and re-render content
        var anchors = ojOption.children('a[ojmenu="opt"]');
        var customAnchor;
        for (var i = 0; i < anchors.length; i++) {
          customAnchor = $(anchors[i]);
          // reset existing slots, and remove the custom anchor
          customAnchor
            .children()
            .removeClass('oj-menu-item-icon')
            .removeClass('oj-menu-item-end-icon');

          customAnchor.replaceWith(customAnchor.contents()); // @HTMLUpdateOK replace previous anchor with trusted new DOM
        }

        // remove generated checkbox icons
        ojOption.children('span[ojmenu="opt"]').remove();

        // test to see if this is a divider
        if (!/[^\-\u2014\u2013\s]/.test(ojOption.text()) && ojOption.children().length === 0) {
          this._initDividers(ojOption);
          initDividerNeighbors(optionDom);
        } else {
          this._initMenuItems(ojOption);

          // create 'a' tag
          var a = document.createElement('a');
          a.setAttribute('href', '#');

          // tag with ojmenu attribute to identify it later
          a.setAttribute('ojmenu', 'opt');
          customAnchor = $(a);

          customAnchor.uniqueId().attr({
            tabIndex: '-1',
            role: this._itemRole(ojOption)
          });

          if (isCheckableMenuItem) {
            customAnchor.attr('aria-checked', 'false');
            initLogicalFirstLastChildOverride(optionDom);
          }

          ojOption.prepend(a); // @HTMLUpdateOK append trusted new DOM to menu item

          // reparent the slots, and make sure any necessary styling is applied
          var slots = ojcustomelementUtils.CustomElementUtils.getSlotMap(optionDom);

          // handle startIcon slot
          var startIcons = slots.startIcon;
          if (startIcons || isCheckableMenuItem) {
            if (isCheckableMenuItem) {
              var checkedIcon = document.createElement('span');
              checkedIcon.setAttribute('slot', 'startIcon');
              checkedIcon.setAttribute('ojmenu', 'opt');
              checkedIcon.setAttribute('class', 'oj-menucheckbox-icon');
              if (!startIcons) {
                startIcons = [checkedIcon];
              } else {
                startIcons.splice(0, 0, checkedIcon);
              }
            }

            var startIconCount = startIcons.length;
            self._maxStartIconCount = Math.max(self._maxStartIconCount, startIconCount);

            $.each(startIcons, function (_i, node) {
              $(node).addClass('oj-menu-item-icon');
              customAnchor.append(node); // @HTMLUpdateOK reparent trusted child DOM in menu item

              // positioning logic doesn't need to run if there is only 1 start icon
              if (startIconCount > 1) {
                self._positionStartIcon(node, _i, startIconCount);
              }
            });
          }

          // check number of endIcons before handling default slots in case there are submenu icons specified
          var endIconCount = 0;
          var endIcons = slots.endIcon;
          if (endIcons) {
            endIconCount = endIcons.length;
            self._maxEndIconCount = Math.max(self._maxEndIconCount, endIconCount);
          }

          // handle default slot
          var defaultSlots = slots[''];

          $.each(defaultSlots, function (_i, node) {
            // handle the submenu case
            if ($(node).is('oj-menu')) {
              self._setupSubmenu(customAnchor, $(node), endIconCount === 0);
              self._hasSubmenus = true;
            } else {
              customAnchor.append(node); // @HTMLUpdateOK reparent trusted child DOM in menu item
            }
          });

          // handle endIcon slot
          if (endIcons) {
            $.each(endIcons, function (_i, node) {
              $(node).addClass('oj-menu-item-end-icon');
              customAnchor.append(node); // @HTMLUpdateOK reparent trusted child DOM in menu item

              // positioning logic doesn't need to run if there is only 1 end icon
              if (endIconCount > 1) {
                self._positionEndIcon(node, _i, endIconCount);
              }
            });
          }

          // check for disabled state in case all we need to do is update disabled attribute
          if (optionDom.disabled) {
            ojOption.addClass(_OJ_DISABLED);
            customAnchor.attr(_ARIA_DISABLED, 'true'); // @HTMLUpdateOK
          } else {
            ojOption.removeClass(_OJ_DISABLED);
            customAnchor.removeAttr(_ARIA_DISABLED);
          }
        }
        // Update menu padding each time an ojOption is updated
        this._updateMenuPadding(this.element);
      },

      // Helper method to position start icons
      _positionStartIcon: function (node, index, count) {
        var marginProperty;
        if (this.isRtl) {
          marginProperty = _MARGIN_RIGHT;
        } else {
          marginProperty = _MARGIN_LEFT;
        }
        var margin = Number($(node).attr(_DATA_OJ_DEFAULT_MARGIN));
        if (isNaN(margin)) {
          margin = parseInt($(node).css(marginProperty), 10);
          $(node).attr(_DATA_OJ_DEFAULT_MARGIN, margin); // @HTMLUpdateOK
        }
        // margins are negative for start icons
        this._startIconWidth = -1 * margin;
        $(node).css(marginProperty, margin * (count - index) + 'px');
      },

      // Helper method to position end icons
      _positionEndIcon: function (node, index, count) {
        var marginProperty;
        var widthProperty;
        if (this.isRtl) {
          marginProperty = _MARGIN_LEFT;
          widthProperty = _MARGIN_RIGHT;
        } else {
          marginProperty = _MARGIN_RIGHT;
          widthProperty = _MARGIN_LEFT;
        }
        var margin = Number($(node).attr(_DATA_OJ_DEFAULT_MARGIN));
        if (isNaN(margin)) {
          margin = parseInt($(node).css(marginProperty), 10);
          $(node).attr(_DATA_OJ_DEFAULT_MARGIN, margin); // @HTMLUpdateOK
        }
        // margins are negative for end icons
        this._endIconWidth = -1 * parseInt($(node).css(widthProperty), 10);
        $(node).css(marginProperty, margin + this._endIconWidth * (count - index - 1) + 'px');
      },

      // Helper method to handle menu item padding updates
      _updateMenuPadding: function ($menu) {
        var anchors = $(_findImmediateMenuItems($menu)).children();
        anchors.each(function () {
          let startIconCount = $(this).children(
            '.oj-menu-item-icon:not(.oj-menu-cancel-icon)'
          ).length;
          let endIconCount =
            $(this).children('.oj-menu-item-end-icon').length ||
            $(this).children('.oj-menu-submenu-icon').length;
          if (startIconCount === 0 && endIconCount === 0) {
            $(this).addClass('oj-menu-option-text-only');
          } else {
            if (startIconCount > 0) {
              $(this).addClass('oj-menu-option-start-icon');
            }
            if (endIconCount > 0) {
              $(this).addClass('oj-menu-option-end-icon');
            }
          }
        });

        if (this._maxStartIconCount && this._maxStartIconCount > 1) {
          this._applyAnchorIconPadding(anchors, this._startIconWidth, this._maxStartIconCount, true);
        }

        if (this._maxEndIconCount && this._maxEndIconCount > 1) {
          this._applyAnchorIconPadding(anchors, this._endIconWidth, this._maxEndIconCount, false);
        }
      },

      // Helper method to apply icon padding to menu item anchors
      _applyAnchorIconPadding: function (anchors, iconWidth, count, isStart) {
        var paddingProperty;
        if ((this.isRtl && isStart) || (!this.isRtl && !isStart)) {
          paddingProperty = 'padding-right';
        } else {
          paddingProperty = 'padding-left';
        }

        anchors.each(function () {
          var padding = Number($(this).attr('data-oj-default-padding'));
          if (isNaN(padding)) {
            padding = parseInt($(this).css(paddingProperty), 10);
            $(this).attr('data-oj-default-padding', padding);
          }
          $(this).css(paddingProperty, padding + iconWidth * (count - 1) + 'px');
        });
      },

      /**
       * @instance
       * @private
       * @param {!jQuery.Event|Event} event
       */
      _clickAwayHandler: function (event) {
        // Focus event needs to be captured because, in case of menu button (where focus is still on menu button instead of open menu), if user does
        // a taboff to another element then menu should be closed. With this we also no need to have additional "blur" handler on menu to close the menu/submenus.

        // Despite of focus/mousedown, still keydown listener is required for contextmenu events especially for menubutton with browser default context menu
        // and user pressed contextmenu keyboard key(not right mouse click).

        if (
          event.type === 'focus' ||
          event.type === 'mousedown' ||
          event.type === 'touchstart' ||
          (event.keyCode === 121 && event.shiftKey) ||
          event.keyCode === 93
        ) {
          // Windows contextMenu key (93) or Shift-F10 (121)
          // Resolves a Mobile Safari issue that occurs because mousedown fires after the touchend.
          // baseComponent's contextMenu logic explains the issue more fully.
          if (event.type === 'mousedown' && _contextMenuPressHoldJustEnded) {
            return;
          }

          var self = this;

          // Clone _openPopupMenus as __dismiss() will remove the open menu from _openPopupMenus list
          var openPopupMenus = _openPopupMenus.slice(0, _openPopupMenus.length);
          $.each(openPopupMenus, function (index, menu) {
            // This logic dismisses/collapses the menu if event is outside the menu and any of the following are true:
            // - Event is a touchstart (which may or may not become a pressHold) or left/middle mousedown, unless (event is in launcher and this is not a context menu).  "Unless" clause needed for menuButton.
            // - Event is focusing something outside of both the menu and launcher.
            // - Event is a context-menu-launching event other than pressHold.  (i.e. right-click or CM keys)
            if (
              !$(event.target).closest(menu.element).length && // if event target is outside of menu element AND one of the following is true then close the menu.
              (event.type === 'keydown' ||
                (event.type === 'mousedown' && event.which === 3) || // 1. if it's a context-menu-launching event other than pressHold (see event.which on outer if)
                !$(event.target).closest(menu._launcher).length || // 2. When focus is moved on to other than launcher or left/middle mousedown or touchstart on element other than launcher
                (menu._isContextMenu &&
                  ((event.type === 'mousedown' && event.which !== 3) || event.type === 'touchstart')))
            ) {
              // 3. If event is a (left/middle-mousedown or touchstart) on launcher and current menu is contextmenu (see )
              // Don't do it again if the menu is already being dismissed
              if (!menu._dismissEvent) {
                // eslint-disable-next-line no-param-reassign
                menu._dismissEvent = event;

                var promise = menu._collapse(event, 'eventSubtree'); // "eventSubtree" is effectively "all" since we check that event is outside menu.  "all" would be clearer, but just in case, leaving it as is.

                // Wait for subtree to be collapsed before dismissing self.
                // There is no default close animation, but this allows app to define
                // cascading close animation if it wants to.
                self._runOnPromise(promise, function () {
                  menu.__dismiss(event);
                  // eslint-disable-next-line no-param-reassign
                  menu._dismissEvent = null;
                });
              }
            }
          });
        }
      },

      /**
       * @memberof oj.ojMenu
       * @instance
       * @protected
       * @param {string} key option name
       * @param {?Object} value of the target option identified by the key
       * @override
       */
      // eslint-disable-next-line no-unused-vars
      _setOption: function (key, value) {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this._superApply(arguments); // TBD: consider calling super at end, so that optionChange (fired at end of super) is fired at very end
        // no refresh() needed to just change text of existing inited menu item
        if (key === 'translations' && this._cancelAnchor) {
          this._cancelAnchor.text(this.options.translations.labelCancel);
        }
      },

      /**
       * @memberof oj.ojMenu
       * @instance
       * @protected
       * @override
       */
      _destroy: function () {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        if (this.element.is(':visible')) {
          this.__dismiss();
        }

        this._setWhenReady('none');

        if (this._clearTimer) {
          this._clearTimer();
        }
        delete this._clearTimer;

        this.element[0].removeEventListener('touchstart', this._touchStartHandler, { passive: true });
        delete this._touchStartHandler;

        this.element[0].removeEventListener('touchstart', this._delegatedHandleMouseEnterMenuItem, {
          passive: true
        });
        delete this._delegatedHandleMouseEnterMenuItem;

        // Destroy (sub)menus
        this.element
          .removeAttr(_ARIA_ACTIVEDESCENDANT)
          .removeClass('oj-component')
          .find('.oj-menu')
          .addBack()
          .removeClass('oj-menu oj-menu-submenu oj-menu-icons oj-menu-end-icons oj-menu-text-only')
          .removeAttr('role')
          .removeAttr('tabIndex')
          .removeAttr('aria-labelledby')
          .removeAttr(_ARIA_HIDDEN)
          .removeAttr(_ARIA_DISABLED)
          .removeUniqueId()
          .show();

        // Destroy menu items
        this.element
          .find(_OJ_MENU_ITEM_CLASS)
          .removeClass('oj-menu-item')
          .removeAttr('role')
          .children('a')
          .removeAttr(_ARIA_DISABLED)
          .removeUniqueId()
          .removeClass('oj-hover')
          .removeAttr('tabIndex')
          .removeAttr('role')
          .removeAttr('aria-haspopup')
          .children()
          .each(function () {
            var elem = $(this);
            if (elem.data('oj-ojMenu-submenu-icon')) {
              elem.remove();
            }
          });

        // Destroy anchors
        this.element.find('a').removeAttr(_ARIA_EXPANDED);

        // Destroy menu dividers
        this.element.find(_OJ_MENU_DIVIDER).removeClass('oj-menu-divider').removeAttr('role');

        delete this._popupServiceEvents;
        delete this._usingCallback;

        var clearCloseDelayTimer = this._clearCloseDelayTimer;
        delete this._clearCloseDelayTimer;
        if (clearCloseDelayTimer) {
          clearCloseDelayTimer();
        }

        this.element.ojHammer('destroy');

        this._super();
      },

      _keydown: function (event) {
        /* jshint maxcomplexity:20*/
        var preventDefault = true;

        function escape(value) {
          // eslint-disable-next-line no-useless-escape
          return value.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        }

        switch (event.keyCode) {
          case $.ui.keyCode.HOME:
            this._move('first', 'first', event);
            break;
          case $.ui.keyCode.END:
            this._move('last', 'last', event);
            break;
          case $.ui.keyCode.UP:
            this._previous(event);
            break;
          case $.ui.keyCode.DOWN:
            this._next(event);
            break;
          case $.ui.keyCode.LEFT:
          case $.ui.keyCode.RIGHT:
            var isExpand = (event.keyCode === $.ui.keyCode.RIGHT) !== this.isRtl;
            if (isExpand) {
              if (this.active && !this.active.is(_OJ_DISABLED_CLASS)) {
                this._expand(event);
              }
            } else {
              this._collapse(event, 'active');
            }
            break;
          case $.ui.keyCode.ENTER:
          case $.ui.keyCode.SPACE:
            this._handleEnterSpace(event);

            this.__spaceEnterDownInMenu = true;
            var self = this;

            // The spaceEnterDelay and __spaceEnterDownInMenu code addresses an issue where closing a menu, from within the menu via
            // Space or Enter, can immediately reopen the menu, because the keyUp can happen after focus has jumped to the button,
            // which clicks the button, which reopens the menu.  Repros most readily (only??) in Firefox.
            // TODO: try calling preventDefault() on the event in Menu (which is good practice anyway since it's handling the event), and
            // checking isDefaultPrevented() in Button.  If works, should be cleaner / more reliable than this existing fix.
            var spaceEnterDelay = 100; // 1 not enough in FF; 100 seems to do it.  If continued problems, try increasing this value.

            setTimeout(function () {
              self.__spaceEnterDownInMenu = false;
            }, spaceEnterDelay);

            break;
          // tab within a menu will implicitly dismiss
          case $.ui.keyCode.TAB:
            event.preventDefault();
            this._focusLauncherAndDismiss(event);
            break;
          // this handles enabled menus.  For disabled menus, see this handler: this._on(true, {...});
          case $.ui.keyCode.ESCAPE:
            if (this._launcher) {
              // if menu is currently open
              // <a> or nothing.  Always the same as this.active now that we change them in lockstep.
              var activeItemId = this.element.attr(_ARIA_ACTIVEDESCENDANT);
              var closestParentMenu = $(document.getElementById(activeItemId))
                .parents('.oj-menu')
                .first();
              var submenuOpen =
                closestParentMenu.length > 0 && closestParentMenu[0] !== this.element[0];

              if (submenuOpen) {
                this._collapse(event, 'active');
              } else {
                this._focusLauncherAndDismiss(event);
              }
            } else {
              this._collapse(event, 'active');
            }
            break;
          default:
            preventDefault = false;
            var prev = this.previousFilter || '';
            var character = String.fromCharCode(event.keyCode);
            var skip = false;

            clearTimeout(this.filterTimer);

            if (character === prev) {
              skip = true;
            } else {
              character = prev + character;
            }

            var regex = new RegExp('^' + escape(character), 'i');
            var match = $(_findImmediateMenuItems(this.activeMenu)).filter(function () {
              return regex.test($(this).children('a').text());
            });
            match =
              skip && match.index(this.active.next()) !== -1
                ? this.active.nextAll(_OJ_MENU_ITEM_CLASS)
                : match;

            // If no matches on the current filter, reset to the last character pressed
            // to move down the menu to the first item that starts with that character
            if (!match.length) {
              character = String.fromCharCode(event.keyCode);
              regex = new RegExp('^' + escape(character), 'i');
              match = $(_findImmediateMenuItems(this.activeMenu)).filter(function () {
                return regex.test($(this).children('a').text());
              });
            }

            if (match.length) {
              this._focus(event, match);
              if (match.length > 1) {
                this.previousFilter = character;
                // prettier-ignore
                this.filterTimer = setTimeout( // @HTMLUpdateOK
                  function () {
                    delete this.previousFilter;
                  }.bind(this),
                  1000
                );
              } else {
                delete this.previousFilter;
              }
            } else {
              delete this.previousFilter;
            }
        }

        if (preventDefault) {
          event.preventDefault();
        }
      },

      /*
       * Called for Space and Enter
       */
      _handleEnterSpace: function (event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.active && !this.active.is(_OJ_DISABLED_CLASS)) {
          if (this.active.children("a[aria-haspopup='true']").length) {
            this._expand(event);
          } else {
            this._select(event);
          }
        }
      },

      /**
       * Refreshes the disclosed state of the menu. JET elements require a <code class="prettyprint">refresh()</code>
       * after the DOM is programmatically changed underneath the component.  The menu will implicitly refresh each
       * time it is open. Calling refresh before the menu is open will trigger any content contained within an
       * <code class="prettyprint">oj-defer</code> to disclose before the menu is actually open.
       *
       * @expose
       * @memberof oj.ojMenu
       * @ojshortdesc Refreshes the disclosed state of the menu. See the Help documentation for more information.
       * @instance
       * @return {void}
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myMenu.refresh();
       */
      refresh: function () {
        // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
        function createInitializedSubmenus(self) {
          var submenus = self.element.find('oj-menu:not(.oj-menu-submenu)');
          for (var i = 0; i < submenus.length; i++) {
            // element might not be upgraded so just toggle its visibility and wait to be upgraded
            $(submenus[i]).attr(_ARIA_HIDDEN, 'true').hide(); // @HTMLUpdateOK

            var busyContext = Context.getContext(submenus[i]).getBusyContext();
            busyContext.whenReady().then(
              function (submenu) {
                submenu.refresh();
              }.bind(self, submenus[i])
            );
          }
        }

        this._super();

        // custom element menus are not create-initialized until they are first open
        if (this._IsCustomElement() && !this._wasCreated) {
          var parentOption = this.element.parent();
          if (parentOption.is('oj-option')) {
            // If the menu is located under an option, it's a submenu.  Checking for
            // a parent menu is just validation that would require a negative test
            // for code coverage.
            this._isSubmenu = true;
            this._createAsSubmenu();
          }

          if (!this._isSubmenu) {
            // triggers nested oj-defer to disclose content
            Components.subtreeShown(this.element[0]);

            this._createAsTopLevelMenu();
            createInitializedSubmenus(this);
          }

          this._wasCreated = true;
        } else {
          // top-level menu has been create initialized
          // look for sub-menus that might have been added to the dom after the top-level menu
          // was created that have not been create-initialized
          createInitializedSubmenus(this);
          this._setup();
        }
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._reposition();
        }
      },

      _reposition: function () {
        function isMenuLargerThanViewport(domElement) {
          var rect = domElement.getBoundingClientRect();
          return (
            rect.width > document.documentElement.clientWidth ||
            /* Submenus don't change their maxHeight since we don't support scrolling on menus that have submenus
            For those case where we don't want menu to keep "shifting" we add this logic */
            rect.height > document.documentElement.clientHeight
          );
        }

        var element = this.element;
        if (!element.is(':visible') || isMenuLargerThanViewport(element[0])) {
          // skip if the menu is hidden or larger than the viewport
          return;
        }

        // reevaluate open menu positions
        var position = element.data(_POSITION_DATA);
        element[0].style.maxHeight = '';
        element[0].style.overflowY = '';
        this._updateMenuMaxHeight();
        element.position(position);

        // Do the same for open submenus.  Don't bother with the position.of check this time, since
        // their position.of is essentially always the parent menu, not some other thing on the page.
        var subMenus = element.find('.oj-menu');
        subMenus.each(function () {
          var menu = $(this);
          if (menu.is(':visible')) {
            position = menu.data(_POSITION_DATA);
            menu.position(position);
          }
        });
      },

      _setup: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.isRtl = this._GetReadingDirection() === 'rtl';

        if (!this._IsCustomElement()) {
          this._setupWidgetMenus();
        } else {
          this._processOjOptions();

          if (this._isSubmenu) {
            this.options.openOptions.launcher = this.element.parent();
          }

          // ensure menu padding is updated
          this._updateMenuPadding(this.element);
        }

        // If the active item has been removed, blur the menu
        if (this.active && !$.contains(this.element[0], this.active[0])) {
          this._blur();
        }
      },

      _setupWidgetMenus: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var self = this;

        var submenus = this.element.find(this.options.menuSelector); // <ul>'s except root <ul>

        var menus = submenus.add(this.element); // <ul>'s including root <ul>
        var children = menus.children(); // <li>'s in root menu and submenus

        this._hasSubmenus = !!submenus.length;

        // Anything that used to be a divider, but now has an "a", should become a menu element.
        children
          .filter(_OJ_MENU_DIVIDER)
          .has('a')
          .removeClass('oj-menu-divider oj-menu-item') // remove oj-menu-item if somehow present to ensure that it enters following block
          .removeAttr('role');

        // Don't refresh list items that are already adapted
        // TBD: .has prob has better perf than :has
        var uninitedItems = children.filter(':not(.oj-menu-item):has(a)');
        var uninitedAnchors = uninitedItems.children('a');

        this._initMenuItems(uninitedItems);
        this._initAnchors(uninitedAnchors);

        var dividers = children.filter(function (index, item) {
          // menu items without anchors containing spaces and/or dashes only
          // this test relies on the fact that _initMenuItems() has already been called
          var $item = $(item);
          return $item.is(':not(.oj-menu-item)') && !/[^\-\u2014\u2013\s]/.test($item.text()); // hyphen, em dash, en dash
        });
        this._initDividers(dividers);

        // ensure "before/after-divider" classes are applied iff appropriate
        this._initDividerNeighbors(children, dividers);

        // Add aria-disabled to any disabled menu item, and remove it from any recently enabled menu item
        children.filter(_OJ_DISABLED_CLASS).children('a').attr(_ARIA_DISABLED, 'true'); // @HTMLUpdateOK
        children.filter(':not(.oj-disabled)').children('a').removeAttr(_ARIA_DISABLED);

        // Initialize nested menus
        submenus
          .filter(':not(.oj-menu)')
          .addClass('oj-menu oj-menu-submenu oj-menu-dropdown') // submenus are always dropdown
          .hide()
          .attr({
            role: this.role,
            'aria-hidden': 'true'
          })
          .each(function () {
            var menu = $(this); // <ul>
            self._setupSubmenu(self._getSubmenuAnchor(menu), menu, true);
          });

        menus.each(function () {
          // For each menu incl. submenus, apply either "oj-menu-icons" or "oj-menu-text-only" to that menu, depending on whether that menu
          // (excluding its submenus) contains at least one menu item having an icon.
          // This facilitates leaving space for a "column" of icons iff at least one icon is present, and doing so for each menu/submenu independently.
          // We exclude the cancel item's icon from the count, as that icon is always present if the cancel item is, but it's themed to show up iff
          // oj-menu-icons is present, i.e. iff at least one other icon is present.
          self._updateMenuPadding($(this));
        });
      },

      // helper method to create and add a submenu icon to the item provided
      _setupSubmenu: function (item, submenu, addIcon) {
        var isIconAdded =
          item[0].querySelectorAll('.oj-menu-submenu-icon.oj-component-icon').length !== 0;
        item.attr('aria-haspopup', 'true').attr('role', 'menuitem').attr(_ARIA_EXPANDED, 'false'); // @HTMLUpdateOK // per a11y team, live on <a>, not <ul> like JQUI
        if (addIcon && !isIconAdded) {
          var submenuIcon = $('<span>');
          submenuIcon // separate stmt rather than chaining, since GCC can't tell that this is the setter overload of .data().
            .addClass('oj-menu-submenu-icon oj-component-icon')
            .data('oj-ojMenu-submenu-icon', true); // TODO: can't we just look for the class at destroy time rather than adding this data?
          item.append(submenuIcon); // @HTMLUpdateOK append trusted new DOM to menu item
        }
        // if the oj-option (launcher of submenu) is disabled, disable every menu item of submenu
        // so they can not be selected
        this._clearTimer = this._setTimer(
          function () {
            delete this._clearTimer;
            if (item[0].parentElement && item[0].parentElement.disabled) {
              submenu.find('oj-option').attr('disabled', true);
            }
          },
          this._getSubmenuBusyStateDescription('enable or disable submenu'),
          0
        );
        submenu.attr('aria-labelledby', item.attr('id'));
      },

      /**
       * @private
       * @param {jQuery} items - non-divider <li>'s that haven't already been inited.
       */
      _initMenuItems: function (items) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        items.addClass('oj-menu-item').attr('role', 'presentation');
      },

      /**
       * @private
       * @param {jQuery} anchors - <a>'s that haven't already been inited.
       */
      _initAnchors: function (anchors) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        for (var i = 0; i < anchors.length; i++) {
          var anchor = $(anchors[i]);
          anchor.uniqueId().attr({
            tabIndex: '-1',
            role: this._itemRole(anchor.parent())
          });
        }
      },

      /**
       * @private
       * @param {jQuery} dividers - divider <li>'s.
       */
      _initDividers: function (dividers) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        dividers.addClass('oj-menu-divider').attr('role', 'separator');
      },

      /**
       * @private
       * @param {jQuery} dividers - divider <li>'s.
       */
      _initDividerNeighbors: function (items, dividers) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        items.removeClass('oj-menu-item-before-divider oj-menu-item-after-divider');
        dividers.prev().addClass(_OJ_MENU_ITEM_BEFORE_DIVIDER);
        dividers.next().addClass('oj-menu-item-after-divider');
      },

      /**
       * @private
       */
      _clearOption: function (option) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        option
          .removeClass(
            'oj-menu-item-before-divider oj-menu-item-after-divider oj-menu-divider oj-menu-item'
          )
          .removeAttr('role');
      },

      /*
       * Given a list of one or more submenus (typically <ul>'s), finds the <a>'s that are their labels.
       */
      _getSubmenuAnchor: function (submenu) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return submenu.prev('a');
      },

      _getSubmenuWidget: function (submenu) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var constructor = Components.__GetWidgetConstructor(submenu, 'ojMenu');
        return constructor('instance');
      },

      _itemRole: function (option) {
        if (option.parent().prop('nodeName') === _OJ_MENU_SELECT_MANY) {
          return 'menuitemcheckbox';
        }
        return 'menuitem';
      },

      // given a menu item, returns JQ object with any adjacent group dividers and optionally, that item
      _getAdjacentDividers: function (menuItem, includeItem) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var result = menuItem.prev(_OJ_MENU_DIVIDER).add(menuItem.next(_OJ_MENU_DIVIDER));

        if (includeItem) {
          result = result.add(menuItem);
        }

        return result;
      },

      /**
       * Focuses the specified menu item and triggers the menu's <code class="prettyprint">_activeItem</code> event.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event} event - What triggered the menu item to gain focus.  May be <code class="prettyprint">null</code>, but may not be omitted.
       * @param {!jQuery} item - The menu item to focus.  Its containing submenu, if any, must already be expanded. Must not be null or length 0.
       */
      _focus: function (event, item) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var previousItem = this.active ? this.active : $();
        if (item.is(previousItem)) {
          return; // if item already has focus do nothing
        }

        // JQUI called blur() here.  This "if blah clear timer" is the only thing from that call that we (presumably) still want to do here.
        if (!(event && event.type === 'focus')) {
          if (this._clearTimer) {
            this._clearTimer();
          }
        }

        // eslint-disable-next-line no-param-reassign
        item = item.first(); // li.  Length 1.
        this._makeActive(item, event);

        var containingMenu = item.parents('.oj-menu').first(); // ul.  Length-1.  Might be top or submenu.
        var parentMenuItem = containingMenu.closest(_OJ_MENU_ITEM_CLASS); // li. Length 0 iff item is in top menu.

        // Remove oj-focus-ancestor class from all menu items and group dividers in the newly focused menu item's menu and submenus of that menu
        containingMenu.find(_OJ_FOCUS_ANCESTOR).removeClass('oj-focus-ancestor');

        // Highlight active parent menu item, if any, and adjacent group dividers, if any
        this._getAdjacentDividers(parentMenuItem, true).addClass('oj-focus-ancestor');

        if (event && event.type === 'keydown') {
          this._close();
        } else {
          this._clearTimer = this._setTimer(
            function () {
              delete this._clearTimer;
              return this._close();
            },
            this._getSubmenuBusyStateDescription('closing'),
            this.delay
          );
        }

        var nested = this._IsCustomElement() ? item.children('oj-menu') : item.children('.oj-menu'); // immediately nested submenu.  length 0 or 1.
        var previousFocusInSubmenu =
          nested.length > 0 && previousItem.length > 0 && $.contains(nested[0], previousItem[0]);
        if (nested.length && event && /^mouse|click/.test(event.type) && !previousFocusInSubmenu) {
          this._startOpening(event, nested);
        }
        this.activeMenu = item.parents('.oj-menu').first();
      },

      /*
       * Sets this.active (<li>), aria-activedescendant (<a>), and oj-focus (<li> and adjacent group dividers) in lockstep.
       * Never set those things outside of _makeActive() and _removeActive(), so they stay in synch!
       *
       * param item length-1 JQ object containing the <li> to focus
       */
      _makeActive: function (item, event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        function isClippedInViewport(domElement) {
          var menuClosestParent = domElement.closest('[role=menu]');

          var rect = domElement.getBoundingClientRect();
          var menuRect = menuClosestParent.getBoundingClientRect();

          return (
            rect.top < 0 ||
            rect.bottom > document.documentElement.clientHeight ||
            menuRect.top > rect.top ||
            menuRect.bottom < rect.bottom ||
            rect.left < 0 ||
            rect.right > document.documentElement.clientWidth
          );
        }

        // don't need to check for "both items null/empty", and don't need to null-check item, since item required to be length-1 JQ object
        var same = item.is(this.active);
        if (same) {
          return;
        }

        var previousItem = this.active ? this.active : $();
        var anchor = item.children('a');

        this.active = item;
        this.element.attr(_ARIA_ACTIVEDESCENDANT, anchor.attr('id')); // @HTMLUpdateOK

        this._focusOutHandler(previousItem);
        this._focusInHandler(item);
        this._getAdjacentDividers(previousItem).removeClass('oj-focus');
        this._getAdjacentDividers(item).addClass('oj-focus');

        // see private API doc on the private _activeItem event declaration in this file
        this._trigger('_activeItem', event, {
          previousItem: previousItem,
          item: item,
          privateNotice: 'The _activeItem event is private.  Do not use.'
        });

        if (event && /^key/.test(event.type) && isClippedInViewport(anchor[0])) {
          // if the event is a key event, force the target menu item to scroll into view if it is clipped in the viewport
          anchor[0].scrollIntoView();
        }
      },

      /*
       * Unsets this.active (<li>), aria-activedescendant (<a>), and oj-focus (<li> and adjacent group dividers) in lockstep.
       * Never set those things outside of _makeActive() and _removeActive(), so they stay in synch!
       *
       * Don't call this if you are immediately going to call _makeActive, to avoid firing the event twice (and redundant work).
       */
      _removeActive: function (event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.active) {
          // then there is definitely a change, from "something focused" to "nothing focused", so proceed.
          var previousItem = this.active; // non-null, so don't need null-check

          this.active = null;
          this.element.removeAttr(_ARIA_ACTIVEDESCENDANT);

          this._focusOutHandler(previousItem);
          this._getAdjacentDividers(previousItem).removeClass('oj-focus');

          // see private API doc on the private _activeItem event declaration in this file
          this._trigger('_activeItem', event, {
            previousItem: previousItem,
            item: $(),
            privateNotice: 'The _activeItem event is private.  Do not use.'
          });
        }
      },

      /**
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event=} event - What triggered the menu item to blur.  May be <code class="prettyprint">null</code> or omitted.
       */
      _blur: function (event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._clearTimer) {
          this._clearTimer();
        }
        this._removeActive(event);
      },

      /*
       * param {Event} event - What triggered the menu to close. Payload for select (if applicable) and close events.
       * param {Object} selectUi - Payload for select event.  Non-null iff close caused by a menu item selection.
       */
      _focusLauncherAndDismiss: function (event, selectUi) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // if the focus fails because the launcher has disappeared, e.g. due to a responsive layout change,
        // no warnings are logged, and the document body winds up focused during the subsequent reparenting,
        // which per the architects is the right thing (i.e. don't introduce any fancy handling for this case).
        if (this._launcher) {
          // restore focus
          this._launcher.focus();
        }

        this.__dismiss(event, selectUi);
      },

      /**
       * Closes the menu. This method does not accept any arguments.
       *
       * @expose
       * @method
       * @name oj.ojMenu#close
       * @ojshortdesc Closes the menu.
       * @memberof oj.ojMenu
       * @instance
       * @return {void}
       *
       * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
       * myMenu.close();
       */
      close: function () {
        this.__dismiss();
      },

      /*
       * Internal method, e.g. called by Button for MenuButton functionality.
       * Could make it public if ever needed.
       * param {Event} event - What triggered the menu to close. Payload for select (if applicable) and close events.
       * param {Object} selectUi - Payload for select event.  Non-null iff close caused by a menu item selection.
       */
      __dismiss: function (event, selectUi) {
        // Internal visibility; called by Button's MenuButton functionality.  Not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._isOperationPending('close', '__dismiss', [event, selectUi])) {
          return;
        }

        // no-op for a closed menu
        var status = oj.ZOrderUtils.getStatus(this.element);
        if (status !== oj.ZOrderUtils.STATUS.OPEN) {
          return;
        }

        var isOpen = this.element.is(':visible');
        this._setWhenReady('close');

        /** @type {!Object.<oj.PopupService.OPTION, ?>} */
        var psOptions = {};
        psOptions[oj.PopupService.OPTION.POPUP] = this.element;

        // capture local state in a context used by the after close callback
        psOptions[oj.PopupService.OPTION.CONTEXT] = {
          event: event,
          selectUi: selectUi,
          isOpen: isOpen
        };

        oj.PopupService.getInstance().close(psOptions);
      },

      /**
       * Get the default animation for a menu
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {string} menuType - The menu type (dropdown or sheet)
       * @param {string} action - The action to animate (open, close)
       * @return {Object} The default animation for the menu type
       */
      _getDefaultAnimation: function (menuType, action) {
        var defaults = _OJ_MENU_CSS_VARS.animation;
        var animationEffects = ThemeUtils.getCachedCSSVarValues([defaults[menuType][action]])[0];
        return JSON.parse(animationEffects);
      },

      /**
       * Return a boolean to indicate if animation is disabled
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @return {boolean} true if animation is disabled; false otherwise.
       */
      _isAnimationDisabled: function () {
        // Disable animation if this is not custom element, or the menu is being
        // dismissed and immediately reopened.
        return !this._IsCustomElement() || this._disableAnimation;
      },

      /**
       * Replace animation options with runtime property values
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {any} effects - The animation options
       * @param {Object} propertyMap - The runtime property values
       * @return {any} The resolved animation effects
       */
      _replaceAnimationOptions: function (effects, propertyMap) {
        var resultEffects = effects;
        if (propertyMap && effects && typeof effects !== 'string') {
          var effectsAsString = JSON.stringify(effects);

          var keys = Object.keys(propertyMap);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            effectsAsString = effectsAsString.replace(new RegExp(key, 'g'), propertyMap[key]);
          }

          resultEffects = JSON.parse(effectsAsString);
        }

        return resultEffects;
      },

      /**
       * Utility method to run a task when a promise is resolved, or run it
       * immediately if there is no promise.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Promise|null} promise - The promise to wait on
       * @param {function()} task - The task to run
       * @return {IThenable|null} A new promise or null
       */
      _runOnPromise: function (promise, task) {
        if (promise) {
          return promise.then(task);
        }

        return task();
      },

      /**
       * Before callback is invoked while the menu is still visible and still parented in the zorder
       * container. Close animation is performed here.
       * @memberof! oj.ojMenu
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the menu
       * @return {Promise|void}
       */
      _beforeCloseHandler: function (psOptions) {
        var rootElement = psOptions[oj.PopupService.OPTION.POPUP];

        // For custom element:
        // Fire action event before menu closed, so that app action handlers can do their thing
        // without waiting for the animation to finish.
        if (this._IsCustomElement()) {
          var context = psOptions[oj.PopupService.OPTION.CONTEXT];
          var selectUi = context.selectUi;

          // trigger action event on the oj-option element
          if (selectUi && selectUi.item.length) {
            // the following event construction is taken from the '_triggerCustomEvent' logic, but we can't
            // use that method since the child <oj-option> is not a full fledged JET element.
            var detail = {};
            var itemElement = selectUi.item[0];
            var event = context.event;
            detail.originalEvent = event.originalEvent;
            var params = { detail: detail };
            params.cancelable = true;
            params.bubbles = true;
            // dispatch old ojAction(deprecated)
            var ojActionEvent = new CustomEvent('ojAction', params);
            itemElement.dispatchEvent(ojActionEvent);

            // dispatch new ojMenuAction with selecteValue in the payload
            params.detail.selectedValue = itemElement.value;
            var ojMenuActionEvent = new CustomEvent('ojMenuAction', params);
            this.element[0].dispatchEvent(ojMenuActionEvent);

            context.event = ojMenuActionEvent; // Use the action event as the close event's originalEvent
          }
        }

        if (this._isAnimationDisabled()) {
          rootElement.attr(_ARIA_HIDDEN, 'true').hide(); // @HTMLUpdateOK
          return undefined;
        }

        var animationOptions = this._getDefaultAnimation(
          this._sheetMenuIsOpen ? 'sheet' : 'dropdown',
          'close'
        );
        var promise = AnimationUtils.startAnimation(
          rootElement[0],
          'close',
          oj.PositionUtils.addTransformOriginAnimationEffectsOption(rootElement, animationOptions),
          this
        );

        promise.then(function () {
          rootElement.attr(_ARIA_HIDDEN, 'true').hide(); // @HTMLUpdateOK
        });

        return promise;
      },

      /**
       * Close finalization callback.
       *
       * @memberof! oj.ojMenu
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the menu
       * @return {void}
       */
      _afterCloseHandler: function (psOptions) {
        // restore local variable state from #__dismiss
        var context = psOptions[oj.PopupService.OPTION.CONTEXT];
        var event = context.event;
        var selectUi = context.selectUi;
        var isOpen = context.isOpen;

        this.element.removeData(_POSITION_DATA);

        this._launcher = null;
        this._sheetMenuIsOpen = false;

        // Preserve original logic for old-style component:
        // Fire select event after menu closed, so that app select handlers can do their thing
        // without worrying about the fact that the menu is still sitting there.
        // Fire select event before close event, because logical, and so that it can be the close event's
        // originalEvent.
        if (!this._IsCustomElement() && selectUi) {
          var selectResults = this._trigger2('select', event, selectUi);
          event = selectResults.event; // Use the select event as the close event's originalEvent
        }

        // just in case it's possible for __dismiss() to get called when menu is already closed, avoid firing spurious event:
        if (isOpen) {
          var busyContext = Context.getContext(this.element[0]).getBusyContext();
          var resolveBusyState = busyContext.addBusyState({
            description: 'close event about to be triggered'
          });
          // JET-28150: popupservice is calling _afterCloseHandler when the popup is still open
          // using requestAnimationFrame to trigger close event asynchronously once current repaint is done
          requestAnimationFrame(() => {
            resolveBusyState();
            this._trigger('close', event, {});
          });
        }

        this._currentOpenOptions = null;

        // Remove menu from openPopupMenus list
        var i = _openPopupMenus.indexOf(this);
        _openPopupMenus.splice(i, 1);

        this._destroyVoiceOverAssist();
      },

      /**
       * <p>Returns a copy of the <code class="prettyprint">openOptions</code> object applicable to the current launch, or the <a href="#openOptions">option</a>
       * value otherwise.
       *
       * <p>If the menu is shared among several launchers, this API can be used to find out what element launched the menu, as seen in the example below.
       *
       * <p>Detailed semantics:
       *
       * <table class="keyboard-table">
       *   <thead>
       *     <tr>
       *       <th>Menu state</th>
       *       <th>Value</th>
       *     </tr>
       *   </thead>
       *   <tbody>
       *     <tr>
       *       <td>Menu is open, or transitioning between open and closed, including when this method is called from an <a href="#event:open">open</a>,
       *           <a href="#event:action">action</a>, or <a href="#event:close">close</a>  listener. (For <a href="#event:beforeOpen">ojBeforeOpen</a>, see next row.)</td>
       *       <td>A copy of the object used for the most recent launch is returned.  See the <a href="#openOptions">openOptions</a>
       *           option, the <a href="#open">open()</a> method, and the <a href="#event:beforeOpen">ojBeforeOpen</a> event for details on how that
       *           object is constructed.</td>
       *     </tr>
       *     <tr>
       *       <td>This method is called from a <a href="#event:beforeOpen">ojBeforeOpen</a> listener.</td>
       *       <td>A copy of the merged object "so far" is returned. The object ultimately used for the launch may differ if it is changed by
       *           a <code class="prettyprint">ojBeforeOpen</code> listener after this method is called.  Unlike the original copy passed to the
       *           <code class="prettyprint">ojBeforeOpen</code> listener, the copy returned by this method is not "live" and cannot be used to affect the launch.</td>
       *     </tr>
       *     <tr>
       *       <td>Menu is closed.  (All states not listed above.)</td>
       *       <td>A copy of the <a href="#openOptions">option</a> value is returned.</td>
       *     </tr>
       *   </tbody>
       * </table>
       *
       * @expose
       * @memberof oj.ojMenu
       * @instance
       * @ignore
       * @since 2.0.0
       *
       * @return {!Object} the <code class="prettyprint">openOptions</code> object
       */
      getCurrentOpenOptions: function () {
        // Public, not an override (not in base class), so use @expose with unquoted method name.
        return $.extend(true, {}, this._currentOpenOptions || this.options.openOptions); // return a deep copy
      },

      /**
       * Close menu if already open.
       *
       * @memberof! oj.ojMenu
       * @instance
       * @private
       * @return {void}
       */
      _closeMenuIfOpen: function (oldOpenOptions, beforeOpenResults, menuOpenOptions) {
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          // Disable animation since we'll be reopening the menu
          this._disableAnimation = true;

          // if getCurrentOpenOptions() is called during the close event marking the end of the previous launch,
          // then it should return the details for the old launch
          this._currentOpenOptions = oldOpenOptions;

          // Use the beforeOpen event as the close event's originalEvent
          this.__dismiss(beforeOpenResults.event); // sets this._currentOpenOptions to null

          // In case the menu is being opened by a different launcher, we don't
          // want the _clickAwayHandler for the old launcher to dismiss it.
          this._dismissEvent = null;

          this._currentOpenOptions = menuOpenOptions; // restore this launch's value
        }
      },

      /**
       * <p>Launches this menu after firing the <a href="#event:beforeOpen">ojBeforeOpen</a> event.  Listeners to that event can cancel the launch
       * via <code class="prettyprint">event.preventDefault()</code>.  If the launch is not canceled, then the the <a href="#event:open">open</a> event
       * is fired after the launch.
       *
       * <p>This method's optional <code class="prettyprint">openOptions</code>param can be used to specify per-launch values for the settings in the
       * corresponding component options, without altering those options.  Those per-launch values can be further customized by a
       * <code class="prettyprint">ojBeforeOpen</code> listener.
       *
       * <p>Menus launched manually (as opposed to those launched by built-in functionality such as the [menu button]{@link oj.ojMenuButton} and
       * [context menu]{@link oj.baseComponent#contextMenu} functionality) must be launched via this API, not by simply unhiding the Menu DOM (such as
       * via jQuery's <code class="prettyprint">show()</code> API.
       *
       * @expose
       * @memberof oj.ojMenu
       * @ojshortdesc Launches this menu after firing the ojBeforeOpen event. See the Help documentation for more information.
       * @instance
       * @return {void}
       * @ojsignature { target: "Type",
       *                value: "oj.ojMenu.OpenOptions",
       *                for: "openOptions",
       *                jsdocOverride: true }
       * @fires oj.ojMenu#ojBeforeOpen
       * @fires oj.ojMenu#ojOpen
       *
       * @param {Event=} event What triggered the menu launch.  May be <code class="prettyprint">null</code>.  May be omitted if subsequent params are omitted.
       * @param {Object=} openOptions Options to merge with the <code class="prettyprint">openOptions</code> option.  May be <code class="prettyprint">null</code>.  May be omitted if subsequent params are omitted.
       *
       * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
       * // override the launcher for this launch only, without affecting the other
       * // openOptions, and without affecting the component's openOptions option
       * myMenu.open(myEvent, {'launcher': 'myLauncher'});
       */
      open: function (event, openOptions) {
        // Public, not an override (not in base class), so use @expose with unquoted method name.
        var submenuOpenOptions = arguments[2];
        if (this._isOperationPending('open', 'open', [event, openOptions, submenuOpenOptions])) {
          return;
        }

        // The remaining menu open actions should proceed only when any autodismiss actions for the same menu have completed
        var menuOpenActions = function (menuEvent, menuOpenOptions) {
          if (this._IsCustomElement()) {
            this.refresh();
          }
          this.element.removeAttr(_ARIA_ACTIVEDESCENDANT);
          this.element.find('.oj-focus').removeClass('oj-focus');
          this.focusHandled = false;
          this._focusIsFromPointer = false;
          this.mouseHandled = false;
          this.activeMenu = this.element;
          this.active = null;

          //
          // Important:  Merge [submenu]openOptions *before* calling _trigger(), and don't use the merged values until *after* the call.
          // Reason:  Per doc on open() and beforeOpen event, we pass the merged openOptions to beforeOpen listeners as a "live" object,
          // so the listener can both read and write the values used for this launch.  We may eventually pass submenuOpenOptions too, either to
          // beforeOpen or to beforeSubmenuOpen, if we ever have that.
          //
          // Merge needs 2 steps:
          // 1) Shallow merge (i.e. don't pass true as first arg to extend) of the 2 openOptions objects, into a new object.  Shallow so that the per-launch position object completely overrides the
          // component option's position object rather than merging with it.
          // 2) Then a deep copy of all object-valued fields in the merged object.  Position is the only such field, and it doesn't contain any objects of its own,
          // so this is actually just a shallow copy of position.  This is so that if beforeOpen listener mutates the position object, the position object in the component option remains unchanged.
          // Step 2 isn't needed for submenuOptions, since it isn't passed to beforeOpen.
          // $.fn.position copies the object passed to it before modifying it, so Step 2 isn't needed for that reason.
          // eslint-disable-next-line no-param-reassign
          menuOpenOptions = $.extend({}, this.options.openOptions, menuOpenOptions);
          // eslint-disable-next-line no-param-reassign
          menuOpenOptions.position = $.extend({}, menuOpenOptions.position);
          if (menuEvent && menuEvent.type === 'keydown' && menuEvent.which === 121) {
            // eslint-disable-next-line no-param-reassign
            menuOpenOptions.initialFocus = 'firstItem';
          }
          if (this._IsCustomElement()) {
            this._setPosition(menuOpenOptions.position);
          }

          submenuOpenOptions = $.extend({}, this.options.submenuOpenOptions, submenuOpenOptions);

          // getCurrentOpenOptions() returns a deep copy of this._currentOpenOptions if set.  Put the live copy in the ivar, and have that method make the copy, so that the method picks up
          // beforeOpen listeners' changes to the live copy.  The old value of the ivar is non-null iff the menu is already open from a previous launch.  Grab the old value so we can restore it
          // if this (new) launch is cancelled, in which case the old launch stays up and subsequent calls to the method should return the old value.
          var oldOpenOptions = this._currentOpenOptions;
          this._currentOpenOptions = menuOpenOptions;

          oj.PositionUtils._normalizeEventForPosition(menuEvent); // see callee doc

          // Hack:  __openingContextMenu is set and unset by baseComponent._OpenContextMenu(), since Menu needs to know whether the
          // menu is open as a context menu vs. some other kind of menu including menu button,
          // as this affects whether subsequent mousedown/touchstart on launcher should dismiss menu.  IIRC, the upcoming Popup Fmwk
          // will address this need, but if not, fix it separately, perhaps by adding a new openOptions sub-option so it can be passed to menu.open().
          this._isContextMenu = this.element[0].slot && this.element[0].slot === 'contextMenu';

          // TBD: if we ever pass submenuOpenOptions to a listener, must copy its position object first like we do for openOptions, above.
          var beforeOpenResults = this._trigger2('beforeOpen', menuEvent, {
            openOptions: menuOpenOptions
          });

          if (!beforeOpenResults.proceed) {
            this._currentOpenOptions = oldOpenOptions; // see comment above
            this._disableAnimation = false;
            return;
          }

          this._closeMenuIfOpen(oldOpenOptions, beforeOpenResults, menuOpenOptions);

          var launcher = menuOpenOptions.launcher;
          if (!this._IsCustomElement()) {
            launcher = $.type(launcher) === 'string' ? $(launcher) : launcher;
          } else {
            launcher =
              $.type(launcher) === 'string' ? $(document.getElementById(launcher)) : $(launcher);
          }

          if (!launcher || !launcher.length) {
            // need launcher so can return focus to it.
            Logger.warn(
              'When calling Menu.open(), must specify openOptions.launcher via the component option, method param, or beforeOpen listener.  Ignoring the call.'
            );
            this._currentOpenOptions = null;
            this._disableAnimation = false;
            return;
          }

          var isDropDown = this._isDropDown(menuOpenOptions.display);
          this._toggleCancelDom(isDropDown);
          var position;
          var modality;

          if (isDropDown) {
            // always true if there are submenus
            // .oj-menu-dropdown already added to any submenus in _setup, since dropdown/sheet status can't
            // vary by launch when there are submenus.
            this.element.addClass('oj-menu-dropdown').removeClass('oj-menu-sheet');
            modality = _DROPDOWN_MODALITY;
            var openOptionsPosition = oj.PositionUtils.normalizeHorizontalAlignment(
              menuOpenOptions.position,
              this.isRtl
            );

            if (
              !openOptionsPosition.of &&
              openOptionsPosition.offset &&
              openOptionsPosition.offset.x === 0 &&
              openOptionsPosition.offset.y === 0
            ) {
              const verticalOffset =
                ThemeUtils.getCachedCSSVarValues(['--oj-private-core-global-dropdown-offset'])[0] ||
                0;
              openOptionsPosition.offset = { x: 0, y: verticalOffset };
            }

            // convert the position option back to JQuery format if custom element menu or submenu
            if (this._IsCustomElement()) {
              // fixup the position option if custom element menu or submenu
              openOptionsPosition = oj.PositionUtils.coerceToJet(
                openOptionsPosition,
                this.options.openOptions.position
              );
              this._referenceOpenPosition = openOptionsPosition;
              position = oj.PositionUtils.coerceToJqUi(openOptionsPosition);
            } else {
              this._referenceOpenPosition = openOptionsPosition;
              position = openOptionsPosition;
            }
            position.of = oj.PositionUtils.normalizePositionOf(position.of, launcher, menuEvent);
          } else {
            // sheet menu, implying no submenus
            this.element.addClass('oj-menu-sheet').removeClass('oj-menu-dropdown');
            modality = _SHEET_MODALITY;

            position = {
              my: 'bottom',
              at: _SHEET_POSITION_AT,
              of: window,
              collision: 'flipfit'
            };
          }

          // Close all other open menus
          var currentMenu = this.element[0];
          // Clone _openPopupMenus as __dismiss() will remove the open menu from _openPopupMenus list
          var openPopupMenus = _openPopupMenus.slice(0, _openPopupMenus.length);
          $.each(openPopupMenus, function (index, menu) {
            if (menu.element[0] !== currentMenu) {
              menu._collapse(menuEvent, 'eventSubtree'); // TBD: should this be "all"?
              menu.__dismiss(menuEvent);
            }
          });

          // cache the merged value for use while the (outer) menu is still open
          this._submenuPosition = oj.PositionUtils.normalizeHorizontalAlignment(
            submenuOpenOptions.position,
            this.isRtl
          );

          var usingCallback = this._usingCallback;

          // if they provided a using function that is not our callback, stash it
          // away so that we can delegate to it in our proxy.
          if ($.isFunction(position.using)) {
            position.origUsing = position.using;
          }

          // override with our proxy to handle positioning of the tail
          position.using = usingCallback;

          this.element.data(_POSITION_DATA, position);

          this._setWhenReady('open');

          /** @type {!Object.<oj.PopupService.OPTION, ?>} */
          var psOptions = {};
          psOptions[oj.PopupService.OPTION.POPUP] = this.element;
          psOptions[oj.PopupService.OPTION.LAUNCHER] = launcher;
          psOptions[oj.PopupService.OPTION.POSITION] = position;
          psOptions[oj.PopupService.OPTION.EVENTS] = this._getPopupServiceEvents();
          psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = 'oj-menu-layer';
          psOptions[oj.PopupService.OPTION.MODALITY] = modality;

          // local variables passed to the before and after open callbacks.
          psOptions[oj.PopupService.OPTION.CONTEXT] = {
            event: menuEvent,
            initialFocus: menuOpenOptions.initialFocus,
            launcher: launcher,
            isDropDown: isDropDown
          };
          psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = this._IsCustomElement();

          var popupService = oj.PopupService.getInstance();
          var openCallback = popupService.open.bind(popupService, psOptions);
          var deferredChild = this.element[0].querySelector('oj-defer');
          if (deferredChild) {
            // oj-defer was scoped as a dom level busy context in the component create.
            // Wait until all components within oj-defer have been upgraded and rendered
            // before trying to show and then position the popup. The busy state guarding
            // open animation, created by _setWhenReady above, is scoped to an ancestor
            // busy context. The oj-defer busy context and busy states associated with
            // contained components will be tracked via this sub context.
            var busyContext = oj.Context.getContext(deferredChild).getBusyContext();
            busyContext.whenReady().then(openCallback);
          } else {
            openCallback();
          }

          this._disableAnimation = false;
        }.bind(this, event, openOptions);

        // If autodismiss is in progress for this same menu
        if (this._dismissEvent) {
          // Wait for autoDismiss to complete before proceeding to open the menu
          var busyContext = Context.getContext(this.element[0]).getBusyContext();
          busyContext.whenReady().then(menuOpenActions);
        } else {
          menuOpenActions();
        }
      },

      /**
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {?Object} position object set as an option or passed as an argument to the open
       *                  method.
       */
      _setPosition: function (position) {
        var options = this.options;

        // new position extends the existing object
        // covert to jet internal position format

        options.openOptions.position = oj.PositionUtils.coerceToJet(
          position,
          options.openOptions.position
        );
      },

      /**
       * Before open callback is called after the menu has been reparented into the
       * zorder container. Open animation is performed here.
       * @memberof! oj.ojMenu
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the menu
       * @return {Promise|void}
       */
      _beforeOpenHandler: function (psOptions) {
        var promise;
        var rootElement = psOptions[oj.PopupService.OPTION.POPUP];
        var position = psOptions[oj.PopupService.OPTION.POSITION];
        var context = psOptions[oj.PopupService.OPTION.CONTEXT];
        var event = context.event;
        var isDropDown = context.isDropDown;
        var initialFocus = context.initialFocus;
        // Clear out css value before each open to make sure correct calculation of overflow
        // Needs to happen before show()
        rootElement[0].style.maxHeight = '';
        rootElement[0].style.overflowY = '';
        rootElement.show();
        // If the menu is dropdown, check if we need to re-calculate the position.
        if (isDropDown) {
          position = this._checkBrowserVerticalScollBar(context, position);
        }
        // get menu height and launcher height before adjusting max height so we don't need to get it from every reposition call
        this.rootHeight = rootElement[0].offsetHeight;
        if (position.of.type === 'click') {
          this.launcherHeight = position.of.clientY;
        } else {
          this.launcherHeight = context.launcher[0].getBoundingClientRect().bottom;
        }
        this._updateMenuMaxHeight();
        rootElement.position(position);

        // note the initial menu width/height
        this.initialWidth = rootElement.width();
        this.initialHeight = rootElement.height();

        // establish this._focusSkipLink, if iOS or Android
        this._initVoiceOverAssist(initialFocus);
        if (initialFocus === 'firstItem') {
          // Establish "logical" focus ( aria-activedescendant) before open animation so mouseover
          // is not negated by initial focus after the menu is fully open.
          var firstItem = this._getFirstItem();
          this._focus(event, firstItem);
        }

        if (!this._isAnimationDisabled()) {
          var animationOptions = this._getDefaultAnimation(isDropDown ? 'dropdown' : 'sheet', 'open');
          promise = AnimationUtils.startAnimation(
            rootElement[0],
            'open',
            oj.PositionUtils.addTransformOriginAnimationEffectsOption(rootElement, animationOptions),
            this
          );
        }

        return promise;
      },
      // If the browser has vertical scroll bar, we need to reserve the scrollbar width before position calculation
      // since jqueryui position api does not calculate scrollbar correctly
      _checkBrowserVerticalScollBar: function (context, position) {
        var launcher = context.launcher;
        var scrollbarWidth = $.position.scrollbarWidth();
        // check if browser has vertical scroll bar
        var hasBrowserOverflowY = window.innerWidth > document.documentElement.clientWidth;
        // check if the space for menu is enough
        var isOverflowSmallerThanScrollbar =
          window.innerWidth - launcher[0].offsetLeft - this.element[0].offsetWidth < scrollbarWidth;
        if (!hasBrowserOverflowY || !isOverflowSmallerThanScrollbar) {
          return position;
        }
        this._referenceOpenPosition.offset.x = scrollbarWidth * -1;
        if (this._IsCustomElement()) {
          var newPo = oj.PositionUtils.coerceToJqUi(this._referenceOpenPosition);
          return Object.assign(position, { my: newPo.my });
        }
        return Object.assign(position, { offset: { my: scrollbarWidth * -1 } });
      },
      // JET-36321: Scroll fix for v9.x. Needs to update when implementing redwood scrolling(JET-32432)
      // Not supported for submenu
      _updateMenuMaxHeight: function (menu) {
        var elem = menu ? menu[0] : this.element[0];
        var isDropdown = this._isDropDown(this.options.openOptions.display);

        const isSafari = oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.SAFARI;
        // Max height will apply will only certain condition
        // In this case maxHeight is not updated if menu is not dropdown and if its height is smaller than viewport one.
        // Not supported on safari for now. 
        if (
          !isDropdown ||
          elem.offsetHeight < window.innerHeight ||
          (isSafari && elem.querySelectorAll('oj-menu').length)
        ) {
          return;
        }
        // Leave some space between menu and viewport edge
        var bottomPadding = 25;

        const isSubmenu = elem.parentNode.nodeName === 'OJ-OPTION';

        // If the menu is submenu we need to get position of the submenu item, if not position of the launcher
        const launcherHeight = isSubmenu
          ? elem.parentNode.getBoundingClientRect().bottom
          : this.launcherHeight;
        var menuHeight = window.innerHeight - launcherHeight - bottomPadding;
        // MaxHeight will be at least bottomPadding
        if (menuHeight < bottomPadding) {
          menuHeight = bottomPadding;
        }
        elem.style.maxHeight = menuHeight + 'px';
        elem.style.overflowY = 'auto';
      },

      /**
       * Called after the menu is shown. Perform open finalization.
       * @memberof! oj.ojMenu
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the menu
       * @return {Promise|void}
       */
      _afterOpenHandler: function (psOptions) {
        var rootElement = psOptions[oj.PopupService.OPTION.POPUP];
        // From the context passed from the open restore local variable state.
        var context = psOptions[oj.PopupService.OPTION.CONTEXT];
        var event = context.event;
        var launcher = context.launcher;
        var isDropDown = context.isDropDown;
        var initialFocus = context.initialFocus;

        // store launcher so we can return focus to it, e.g. if Esc pressed.  Ivar is non-null iff
        // menu is currently open.
        this._launcher = launcher;
        this._sheetMenuIsOpen = !isDropDown;

        // Add current menu to openPopupMenus so that it will be closed on focus lost/click away.
        _openPopupMenus.push(this);

        // JET-44685: iOS may reveal address bar during open animation, need to make sure the position is set
        // properly after the animation completes. Also if the menu width/height changed during opening, re-apply position constraints
        if (
          this.initialWidth !== rootElement.width() ||
          this.initialHeight !== rootElement.height() ||
          oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS
        ) {
          this._reposition();
        }
        delete this.initialWidth;
        delete this.initialHeight;

        if (initialFocus === 'firstItem' || initialFocus === 'menu') {
          var focusElement;
          if (this._focusSkipLink && initialFocus === 'menu') {
            // iOS and Android VO support.  Focus is not switched unless the aria-activedescendant
            // is set (aka 'firstItem') or dom focus is to an anchor tag.
            focusElement = this._focusSkipLink.getLink();
          } else {
            focusElement = this.element;
          }

          // Delay stealing focus "next-tick" so if the event triggering the menu to open has time
          // to finish the normal sequence on the launcher.  Otherwise, a rogue event could be
          // dispatched to the menu outside the normal sequence. For example, if the menu was open on
          // mousedown, the mouseup and click could be fired on the menu.  Or, open on keydown and
          // keypress and keyup targeted at the menu instead of the launcher.
          if (this._IsCustomElement()) {
            window.setImmediate(function () {
              focusElement.focus();
            });
          } else {
            // For jquery ui components, move immediate focus.  The synchronous button qunit tests expect this behavior.
            focusElement.focus();
          }
        }

        this._trigger('open', event, {});
      },

      _initVoiceOverAssist: function (initialFocus) {
        if (initialFocus !== 'menu') {
          return;
        }

        var isVOSupported =
          oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS ||
          oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;
        if (!isVOSupported) {
          return;
        }

        var firstItem = this._getFirstItem();
        if (firstItem.length < 1) {
          // couldn't find a valid menu item
          return;
        }

        // get a sub-id
        var id = this.element.attr('id');
        if (oj.StringUtils.isEmptyOrUndefined(id)) {
          id = this.uuid;
        }
        var focusSkipLinkId = [id, 'focusSkipLink'].join('_');

        var callback = function () {
          // force focus to the anchor of the first item in the "next-tick"
          // to give a sticky double tap long touch hold time to target the
          // original launcher for the touchend event
          window.setImmediate(
            function (self, first) {
              first.find('a').first().focus();
              self._focus(null, first);
            }.bind(this, this, firstItem)
          );
        }.bind(this);

        var message = this.options.translations.ariaFocusSkipLink;
        var options = { insertBefore: true, preventKeyEvents: false };
        this._focusSkipLink = new ojpopupcore.PopupSkipLink(
          firstItem,
          message,
          callback,
          focusSkipLinkId,
          options
        );
      },

      _destroyVoiceOverAssist: function () {
        if (this._focusSkipLink) {
          this._focusSkipLink.destroy();
          delete this._focusSkipLink;
        }
      },

      _getFirstItem: function () {
        return this.element.find(_OJ_MENU_ITEM_CLASS).first();
      },

      _startOpening: function (event, submenu) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._clearTimer) {
          this._clearTimer();
        }

        if (this._IsCustomElement()) {
          submenu[0].refresh();
        }

        this._clearTimer = this._setTimer(
          function () {
            delete this._clearTimer;
            return this._close().then(
              function () {
                this._open(event, submenu);
              }.bind(this)
            );
          },
          this._getSubmenuBusyStateDescription('closing and opening'),
          this.delay
        );
      },

      // opens a *sub*menu
      _open: function (event, submenu) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // Don't open if already open.
        // Calling position() again when the submenu is animating will mess up
        // the calculation and make the submenu appear in different positions.
        if (submenu.attr(_ARIA_HIDDEN) !== 'true' || !this.active) {
          return;
        }

        var position;
        if (this._IsCustomElement()) {
          var submenuWidget = this._getSubmenuWidget(submenu);
          var beforeOpenResults = submenuWidget._trigger2('beforeOpen', event);

          if (!beforeOpenResults.proceed) {
            return;
          }
          let submenuPosition = Object.assign(submenuWidget.options.openOptions.position, {
            offset: { x: 0, y: Y_SUBMENU_OFFSET }
          });

          position = oj.PositionUtils.coerceToJqUi(submenuPosition);
          position = oj.PositionUtils.normalizeHorizontalAlignment(position, this.isRtl);
        } else {
          position = this._submenuPosition;
        }

        position = $.extend({ of: this.active }, position); // normalizeHorizontalAlignment() was already called on the ivar

        if (this._clearTimer) {
          this._clearTimer();
        }
        this.element
          .find('.oj-menu')
          .not(submenu.parents('.oj-menu'))
          .hide()
          .attr(_ARIA_HIDDEN, 'true') // @HTMLUpdateOK
          .removeData(_POSITION_DATA);
        submenu.show().removeAttr(_ARIA_HIDDEN).position(position).data(_POSITION_DATA, position);

        this._getSubmenuAnchor(submenu).attr(_ARIA_EXPANDED, 'true'); // @HTMLUpdateOK

        this._updateMenuMaxHeight(submenu);
        // Important to reposition submenu since if its taking all the height its position starting point will not be the correct
        submenu.position(submenu.data(_POSITION_DATA));

        if (!this._isAnimationDisabled()) {
          var busyContext = Context.getContext(this.element[0]).getBusyContext();
          var resolveBusyState = busyContext.addBusyState({
            description: this._getSubmenuBusyStateDescription('opening')
          });

          var animation = this._getDefaultAnimation('submenu', 'open');

          // JET-49108: create a clone of position.my for animation to avoid overwriting the original
          var myPosition = position.my.slice();

          // if space is not enough, submenu will be opened on the opposite side,
          // so we need to change the animation direction
          if (!this.isRtl && parseFloat(submenu[0].style.left) < 0) {
            myPosition = 'right top';
          } else if (this.isRtl && parseFloat(submenu[0].style.left) > 0) {
            myPosition = 'left top';
          }

          animation = this._replaceAnimationOptions(animation, { '#myPosition': myPosition });
          AnimationUtils.startAnimation(submenu[0], 'open', animation, this).then(resolveBusyState);
        }
      },

      /*
       * Same as calling _collapse(event, "eventSubtree") or _collapse(event, "all"), except that, if delay param is not passed, it collapses the menu immediately.
       */
      __collapseAll: function (event, all, delay) {
        var promise;

        if (this._clearTimer) {
          this._clearTimer();
        }
        var self = this;
        var collapseMenu = function () {
          delete self._clearTimer;
          // If we were passed an event, look for the submenu that contains the event
          var currentMenu = all
            ? self.element
            : $(event && event.target).closest(self.element.find('.oj-menu'));

          // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
          if (!currentMenu.length) {
            currentMenu = self.element;
          }

          var closePromise = self._close(currentMenu);

          closePromise = self._runOnPromise(closePromise, function () {
            self._blur(event);
            self.activeMenu = currentMenu;
          });

          return closePromise;
        };
        if (delay) {
          if (this._isAnimationDisabled()) {
            self._clearTimer = self._setTimer(
              collapseMenu,
              self._getSubmenuBusyStateDescription('closing'),
              delay
            );
          } else {
            promise = new Promise(function (resolve) {
              self._clearTimer = self._setTimer(
                collapseMenu,
                self._getSubmenuBusyStateDescription('closing'),
                delay,
                function () {
                  resolve(true);
                }
              );
            });
          }
        } else {
          promise = collapseMenu();
        }

        if (promise) {
          // Need to add busy state since submenu animation doesn't go through PopupService events
          var resolveBusyState = Context.getContext(this.element[0])
            .getBusyContext()
            .addBusyState({ description: 'closing submenus' });

          // IMPORTANT: Do not change promise to the one returned by then().  Doing
          // so will introduce an additional delay and disrupt the continuity of
          // busy state with any subsequent operation.
          promise.then(resolveBusyState);
        }

        return promise;
      },

      // With no arguments, closes the currently active menu - if nothing is active
      // it closes all menus.  If passed an argument, it will search for menus BELOW
      _close: function (startMenu) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var closePromise;

        // TODO: Consider refatoring _close moving into the __dismiss logic.  The _close logic
        //      will hide levels of nested menus.  The __dismiss knocks down the root
        //      menu.  Both _close and _dismiss are called from _closeAll which closes
        //      all submenus and the main menu.

        if (!startMenu) {
          // eslint-disable-next-line no-param-reassign
          startMenu = this.active ? this.active.parents('.oj-menu').first() : this.element;
        }

        var self = this;
        var defaultAnimation = self._getDefaultAnimation('submenu', 'close');
        var menus = startMenu.find('.oj-menu');
        var hideSubmenus = function (submenus) {
          submenus
            .hide()
            .attr(_ARIA_HIDDEN, 'true') // @HTMLUpdateOK
            .removeData(_POSITION_DATA);
          self._getSubmenuAnchor(submenus).attr(_ARIA_EXPANDED, 'false'); // @HTMLUpdateOK
        };

        if (this._isAnimationDisabled()) {
          // If animation is hard-disabled, just hide all submenus at once
          hideSubmenus(menus);
          startMenu.find(_OJ_FOCUS_ANCESTOR).removeClass('oj-focus-ancestor');
          closePromise = Promise.resolve(true);
        } else {
          // If there is animation, recursively hide submenus level by level,
          // starting from the innermost level.
          // There is no default close animation, but this allows app to define
          // cascading close animation if it wants to.

          // Define a recurive function that close all submenus of a menu
          var closeSubmenus = function (currentMenu) {
            var masterPromise = null;

            // Get <li> child elements of the current menu.  Submenus are rendered as
            // <ul> children of <li> elements.
            var items = $(_findImmediateMenuItems(currentMenu));

            // Find all the immediate child menus and iterate through them
            var childMenus = items.children('.oj-menu');
            childMenus.each(function (index, submenu) {
              var jSubmenu = $(submenu);

              // Define a function that animate the closing and hiding of the iterated menu
              var animateMenuClose = function () {
                var position = jSubmenu.data(_POSITION_DATA);
                var animation = self._replaceAnimationOptions(defaultAnimation, {
                  '#myPosition': position.my
                });
                return AnimationUtils.startAnimation(submenu, 'close', animation, self).then(
                  function () {
                    hideSubmenus(jSubmenu);
                  }
                );
              };

              if (jSubmenu.is(':visible')) {
                // If the iterated menu is visible, try to close its child menus first
                var promise = closeSubmenus(jSubmenu);

                // Wait for child menus to close before closing the iterated menu.
                //
                // Keep track of the closing promise for each menu that is visible
                // There should be at most one visible submenu at each level
                masterPromise = self._runOnPromise(promise, animateMenuClose);
              } else {
                // If the iterated menu is not visible, just hide it and set other attributes
                hideSubmenus(jSubmenu);
                masterPromise = Promise.resolve(true);
              }
            });

            // After iterating through all child menus, return a master promise
            return masterPromise;
          };

          // Start calling the recursive function from the outermost menu
          closePromise = closeSubmenus(startMenu);

          closePromise = this._runOnPromise(closePromise, function () {
            startMenu.find(_OJ_FOCUS_ANCESTOR).removeClass('oj-focus-ancestor');
          });
        }

        return closePromise;
      },

      /**
       * Closes one or more open submenus.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event=} event - What triggered the menu to collapse.  May be <code class="prettyprint">null</code>.
       *                         May be omitted if the <code class="prettyprint">which</code> parameter is omitted.
       * @param {string=} which - Optional; defaults to <code class="prettyprint">"active"</code>.  Values are the following <code class="prettyprint">string</code>s:
       *     <ul>
       *       <li><code class="prettyprint">"active"</code>: Closes the currently active submenu.</li>
       *       <li><code class="prettyprint">"all"</code>: Closes all submenus.</li>
       *       <li><code class="prettyprint">"eventSubtree"</code>: Closes submenus below but not including the menu that is or contains the target of the triggering event.</li>
       *     </ul>
       */
      _collapse: function (event, which) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var promise;

        if (which == null || which === 'active') {
          var newItem = this.activeMenu && this.activeMenu.closest(_OJ_MENU_ITEM_CLASS, this.element);
          if (newItem && newItem.length) {
            var self = this;
            promise = this._close();
            promise = this._runOnPromise(promise, function () {
              self._focus(event, newItem);
            });
          }
        } else if (which === 'all' || which === 'eventSubtree') {
          promise = this.__collapseAll(event, which === 'all', this.delay);
        } else {
          Logger.warn('Invalid param ' + which + ' passed to Menu._collapse().  Ignoring the call.');
        }

        return promise;
      },

      /**
       * Opens the submenu below the currently focused item, if one exists.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event=} event - What triggered the menu to expand.  May be <code class="prettyprint">null</code> or omitted.
       */
      _expand: function (event) {
        var newItem;
        var submenu;

        if (this.active) {
          submenu = this.active.children('.oj-menu ').first();
          var childMenuItems = _findImmediateMenuItems(submenu);
          if (childMenuItems.length > 0) {
            newItem = $(childMenuItems[0]);
          }
        }

        if (newItem && newItem.length) {
          this._open(event, submenu);

          if (this._clearTimer) {
            this._clearTimer();
          }

          // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
          this._clearTimer = this._setTimer(function () {
            delete this._clearTimer;
            this._focus(event, newItem);
          }, this._getBusyStateDescription('focusing an item'));
        }
      },

      /**
       * Focuses the next menu item, wrapping at the bottom, as if <kbd>DownArrow</kbd> had been pressed.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event=} event - What triggered the focus to move.  May be <code class="prettyprint">null</code> or omitted.
       */
      _next: function (event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this._move('next', 'first', event);
      },

      /**
       * Focuses the previous menu item, wrapping at the top, as if <kbd>UpArrow</kbd> had been pressed.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event=} event - What triggered the focus to move.  May be <code class="prettyprint">null</code> or omitted.
       */
      _previous: function (event) {
        this._move('prev', 'last', event);
      },

      _move: function (direction, filter, event) {
        var next;
        var menuItems = _findImmediateMenuItems(this.activeMenu);
        var i = menuItems.indexOf(this.active ? this.active[0] : null);
        if (i > -1) {
          if (direction === 'first') {
            next = menuItems[0];
          } else if (direction === 'last') {
            next = menuItems[menuItems.length - 1];
          } else if (direction === 'next') {
            // if next and not beyond the last menu item, choose next; otherwise, choose first.
            if (i + 1 < menuItems.length) {
              next = menuItems[i + 1];
            } else {
              next = menuItems[0];
            }
          } else if (direction === 'prev') {
            // if prev and not before the first, choose prev; otherwise, choose last.
            if (i - 1 > -1) {
              next = menuItems[i - 1];
            } else {
              next = menuItems[menuItems.length - 1];
            }
          }
        } else if (filter === 'first') {
          next = menuItems[0];
        } else {
          next = menuItems[menuItems.length - 1];
        }

        this._focus(event, $(next));
      },

      /* TODO: update JSdoc to be something like this revised version, once todo's in code are resolved.
       * Let selectItem be the currently focused menu item if any, else the menu item containing the target of the supplied event if any, else null.
       *
       * If selectItem is non-null, this method selects that item, collapses all submenus, and triggers the menu's
       * <code class="prettyprint">select</code> event.
       *
       * Internally, this method should not be invoked for parent menu items or disabled menu items. But still there is a chance of
       * invoking _select() externally. (Not anymore now that it's private.) In that case, if focused menu item is a disabled or parent menu item then a warning message will be logged.
       */
      /**
       * Selects the currently focused menu item, collapses all submenus and triggers the menu's <code class="prettyprint">select</code> event.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {Event=} event - What triggered the selection.  May be <code class="prettyprint">null</code> or omitted.
       */
      _select: function (event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // If no menu item is focused, then infer one from the event if possible.  TBD: still need this now that not public?  Or is this.active always set?
        if (!this.active && event && event.target) {
          var menuItem = $(event.target).closest(_OJ_MENU_ITEM_CLASS);
          if (menuItem.closest(this.element).length) {
            this._makeActive(menuItem, event);
          }
        }

        // payload for select event
        var ui = this.active.is(this._cancelItem)
          ? undefined // don't fire select for Cancel item
          : { item: this.active }; // must grab this.active before calling __collapseAll, which clears this.active

        // The menu item has been selected, so we can collapse all menus immediately with no timeout via __collapseAll.
        // If we call the version with a timeout, _collapse(event, "all"), then mouseleave event handler will invoke _collapse(event, "eventSubtree") on event.target
        // which will clear our scheduled _collapse(event, "all") on this.element, so that submenu will not be collapsed,
        // which means that when the menu is later re-launched, the submenu is already open.
        var promise = this.__collapseAll(event, true);

        this._runOnPromise(
          promise,
          function () {
            this._focusLauncherAndDismiss(event, ui);
          }.bind(this)
        );
      },

      /**
       * @instance
       * @private
       */
      _surrogateRemoveHandler: function () {
        // In all cases except when the dialog is already open, removal of the
        // surrogate during opening or closing will result in implicit removal.
        // 1) CLOSING: Handled in oj.ZOrderUtils.removeFromAncestorLayer.  If the
        //    surrogate doesn't exist the layer containing the popup dom is detached.
        // 2) OPENING: in the PopupServiceImpl#open _finalize, if the surrogate doesn't
        //    exist after in the open state, this remove callback is invoked.
        //
        // Custom element will call _NotifyDetached after element.remove but
        // but jquery UI instances will invoke the _destory method.

        var element = this.element;
        var status = oj.ZOrderUtils.getStatus(element);
        if (status === oj.ZOrderUtils.STATUS.OPEN) {
          ojcustomelementUtils.CustomElementUtils.cleanComponentBindings(element[0]);
          element.remove();
        }
      },

      /**
       * @instance
       * @private
       * @return {!Object.<oj.PopupService.EVENT, function(...)>}
       */
      _getPopupServiceEvents: function () {
        if (!this._popupServiceEvents) {
          /** @type {!Object.<oj.PopupService.EVENT, function(...)>} **/
          var events = {};
          this._popupServiceEvents = events;
          events[oj.PopupService.EVENT.POPUP_CLOSE] = this._closeAll.bind(this);
          events[oj.PopupService.EVENT.POPUP_REMOVE] = this._surrogateRemoveHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_REFRESH] = this._reposition.bind(this);
          events[oj.PopupService.EVENT.POPUP_AUTODISMISS] = this._clickAwayHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_BEFORE_OPEN] = this._beforeOpenHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_AFTER_OPEN] = this._afterOpenHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_BEFORE_CLOSE] = this._beforeCloseHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_AFTER_CLOSE] = this._afterCloseHandler.bind(this);
        }
        return this._popupServiceEvents;
      },

      /**
       * @instance
       * @private
       */
      _closeAll: function () {
        // TODO: Don't want to animate when force close a menu. This flag is not
        // hooked in the beforeCloseHandler.  There is only a custom element check. Doesn't
        // currently matter because the menu doesn't support custom element syntax yet.
        this._disableAnimation = true;

        this._close(this.element);
        this.__dismiss(null);
        // Forced menu dismissal doesn't queue the close event for some reason. The busy
        // state is resolved on the close event from the mediator.  Force the busy state to release.
        this._setWhenReady('none');
      },

      /**
       * @private
       * @param {Object} pos "my" element associated with the position object
       * @param {Object} props directions as to where the element should be moved
       */
      _usingHandler: function (pos, props) {
        var rootMenu = props.element.element;
        rootMenu.css(pos);

        // Capture the position data so that we can set transform-origin later on
        oj.PositionUtils.captureTransformOriginAnimationEffectsOption(rootMenu, props);

        // call on the original using
        var position = rootMenu.data(_POSITION_DATA);
        var origUsing = position.origUsing;
        if (origUsing) {
          origUsing(pos, props);
        }

        // implicitly dismiss the menu when the position.of is clipped in an overflow container.
        if (oj.PositionUtils.isAligningPositionClipped(props)) {
          this._clearCloseDelayTimer = this._setTimer(
            this._closeAll,
            this._getSubmenuBusyStateDescription('closing'),
            1
          );
        }
      },

      // @inheritdoc
      getNodeBySubId: function (locator) {
        if (locator && locator.subId === _SUBID_CANCEL) {
          // only return it if it's currently in the DOM, never when it's detached
          return this._cancelDomAttached ? this._cancelItem[0] : null;
        }
        return this._super(locator);
      },

      /**
       * {@ojinclude "name":"getSubIdByNodeDesc"}
       *
       * @expose
       * @ignore
       * @memberof oj.ojMenu
       * @instance
       * @since 2.1.0
       *
       * @param {!Element} node {@ojinclude "name":"getSubIdByNodeNodeParam"}
       * @return {Object|null} {@ojinclude "name":"getSubIdByNodeReturn"}
       *
       * @example <caption>{@ojinclude "name":"getSubIdByNodeCaption"}</caption>
       * {@ojinclude "name":"getSubIdByNodeExample"}
       */
      getSubIdByNode: function (node) {
        return this._cancelItem && this._cancelItem.is($(node).parents().addBack(node))
          ? { subId: _SUBID_CANCEL }
          : this._super(node);
      },

      /**
       * Called on menu open.
       * @private
       * @param {string} display - the display value for the current launch, before resolving "auto"
       */
      _isDropDown: function (display) {
        if (this._hasSubmenus) {
          return true;
        }

        switch (display) {
          case 'dropDown':
            return true;
          case 'sheet':
            return false;
          default:
            return Config.getDeviceRenderMode() !== 'phone';
        }
      },

      /**
       * Called on menu open. Adds or removes the Cancel menu item and its divider, as needed.
       * @private
       * @param {boolean} isDropDown
       */
      _toggleCancelDom: function (isDropDown) {
        function getItemBeforeDivider(menu, cancelDom) {
          var menuItems = _findImmediateMenuItems(menu);
          var i = menuItems.indexOf(cancelDom[1]); // find the divider
          return $(menuItems[i - 1]);
        }

        if (!_SHEETS_HAVE_CANCEL_ITEM) {
          return; // shouldn't add cancel DOM, and no need to remove it since it could never have been added
        }

        if (isDropDown) {
          if (this._cancelDomAttached) {
            getItemBeforeDivider(this.element, this._getCancelDom()).removeClass(
              _OJ_MENU_ITEM_BEFORE_DIVIDER
            );
            this._getCancelDom().detach();
            this._cancelDomAttached = false;
          }
        } else {
          // if detached, adds it.  If attached, ensures it's at the end of the menu where it belongs,
          // even if app or component has appended menu items.
          var cancelDom = this._getCancelDom();
          cancelDom.appendTo(this.element); // @HTMLUpdateOK trusted string per annotations in callee
          getItemBeforeDivider(this.element, cancelDom).addClass(_OJ_MENU_ITEM_BEFORE_DIVIDER);
          this._cancelDomAttached = true;
        }
      },

      /**
       * Called on menu open when menu needs to add a cancel item for this launch.
       * @private
       * @return {jQuery} JQ object with Cancel divider and Cancel menu item in correct order
       */
      _getCancelDom: function () {
        if (!this._cancelDom) {
          var divider = $('<li></li>', this.document[0]); // trusted string
          var a = $("<a href='#'></a>", this.document[0]) // trusted string
            .text(this.options.translations.labelCancel);
          $(
            "<span class='oj-menu-item-icon oj-component-icon oj-menu-cancel-icon'></span>",
            this.document[0]
          ).prependTo(a); // @HTMLUpdateOK trusted string
          var li = $('<li></li>', this.document[0])
            .addClass('oj-menu-item-cancel oj-menu-item-after-divider')
            .append(a); // @HTMLUpdateOK trusted string

          this._initDividers(divider);
          this._initAnchors(a);
          this._initMenuItems(li);

          this._cancelAnchor = a;
          this._cancelItem = li;
          this._cancelDom = $([divider[0], li[0]]); // need array-of-elem syntax to guarantee order
        }

        return this._cancelDom;
      },

      /**
       * Called at create. Sets up Hammer swipe-down-to-dismiss-menu listener when
       * --oj-private-menu-global-sheet-swipe-down-behavior value is "dismiss"
       * @private
       */
      _setupSwipeBehavior: function () {
        if (!_SHEETS_HAVE_SWIPE_DOWN_TO_DISMISS) {
          return;
        }

        this.element.ojHammer(_HAMMER_OPTIONS);
        this._on({
          swipedown: function (event) {
            // important to check "sheet menu currently open", not "last launch was sheet menu",
            // since a single swipe can fire 2 swipe events, and the 2nd one finds the menu already
            // closed and NPE's if it enters the "if" block
            if (this._sheetMenuIsOpen && event.gesture.pointerType === 'touch') {
              // Hammer events fire for mouse too
              this.__collapseAll(event, true);
              this._focusLauncherAndDismiss(event);
            }
          }
        });
      },

      /**
       * Creates a Promise exposed by the {@link oj.ojMenu#whenReady} method.
       *
       * @param {string} operation valid values are "open", "close" or "none"
       * @memberof oj.ojMenu
       * @instance
       * @private
       */
      _setWhenReady: function (operation) {
        /** @type {PopupWhenReadyMediator} */
        var mediator = this._whenReadyMediator;
        if (mediator) {
          mediator.destroy();
          delete this._whenReadyMediator;
        }

        // operation === none
        if (['open', 'close'].indexOf(operation) < 0) {
          return;
        }

        this._whenReadyMediator = new ojpopupcore.PopupWhenReadyMediator(
          this.element,
          operation,
          'ojMenu',
          this._IsCustomElement()
        );
      },

      /**
       * Checks to see if there is a pending "open" or "close" operation.  If pending and it
       * is the same as the requested operation, the request silently fails.  If the current
       * operation is the inverse operation, we queue the current operation after the pending
       * operation is resolved.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {string} operation currently requested
       * @param {string} methodName to invoke to trigger the target operation
       * @param {Array} methodArgs passed to a queue operation
       * @return {boolean} <code>true</code> if a close or open operation is pending completion.
       */
      _isOperationPending: function (operation, methodName, methodArgs) {
        /** @type {oj.PopupWhenReadyMediator} **/
        var mediator = this._whenReadyMediator;
        if (mediator) {
          return mediator.isOperationPending(this, operation, methodName, methodArgs);
        }
        return false;
      },

      /**
       * Adds a busy state with the specified description.
       *
       * Asynchronously, after the specified delay in ms, calls callback with "this" bound to this menu instance,
       * and then resolves the busy state.
       *
       * Returns a "cancel" function that if called:
       * - Cancels the timer, so that the callback is never called (unless it has already been called).
       * - Resolves the busy state.
       *
       * @memberof oj.ojMenu
       * @instance
       * @private
       * @param {function()} callback
       * @param {string} description
       * @param {number=} delay in ms. Defaults to 0.
       * @param {function()=} notifier - A function to notify the caller of several conditions so that it can clean up:
       *                                 1. The timer is cancelled before "callback" is called
       *                                 2. "callback" is called and doesn't return a promise
       *                                 3. "callback" is called, returns a promise, and the promise is resolved
       * @return {function()} a "cancel" function as described above
       */
      _setTimer: function (callback, description, delay, notifier) {
        // Call this line each time rather than caching busyContext
        var resolve = Context.getContext(this.element[0])
          .getBusyContext()
          .addBusyState({ description: description });

        // resolve() bombs if called a 2nd time, so prevent that possibility by wrapping it in a function that can't call
        // it twice, and never calling resolve() directly. If that "bombs 2nd time" behavior is removed from the BusyContext
        // framework, can remove this "resolveOnce" wrapper var, and just call resolve() below.
        var resolveOnce = function () {
          if (resolve) {
            resolve();
            resolve = null;
            if (notifier) {
              notifier();
            }
          }
        };

        var self = this;

        var id = setTimeout(function () {
          var result = callback.bind(self)();
          if (result && result instanceof Promise) {
            // If the callback returns a promise, resolve busy state when the promise resolves.
            result.then(resolveOnce);
          } else {
            // If the callback doesn't return a promise, just resolve the busy state
            resolveOnce();
          }
        }, delay || 0);

        return function () {
          clearTimeout(id);
          resolveOnce();
        };
      },

      // action is "focusing an item", ...
      _getBusyStateDescription: function (action) {
        return "Menu with id '" + this.element.attr('id') + "' is busy " + action + '.';
      },

      // action is "opening", "closing", "closing and opening", ...
      _getSubmenuBusyStateDescription: function (action) {
        return this._getBusyStateDescription(action + ' a submenu');
      },
      /**
       * Notifies the component that its subtree has been removed from the document
       * programmatically after the component has been created.
       *
       * @memberof oj.ojMenu
       * @instance
       * @protected
       * @override
       */
      _NotifyDetached: function () {
        // detaching an open menu results in implicit dismissal
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._closeAll();
        }

        this._super();
      }
    });

    Components.setDefaultOptions({
      // properties for all menu components
      ojMenu: {
        openOptions: Components.createDynamicPropertyGetter(function (context) {
          var position;
          if (ojcustomelementRegistry.isElementRegistered(context.element.tagName)) {
            if (context.containers.indexOf('ojMenu') >= 0) {
              position = {
                my: { horizontal: 'start', vertical: 'top' },
                at: { horizontal: 'end', vertical: 'top' },
                offset: { x: 0, y: 0 },
                collision: 'flipfit'
              };
            } else {
              position = {
                my: { horizontal: 'start', vertical: 'top' },
                at: { horizontal: 'start', vertical: 'bottom' },
                offset: { x: 0, y: 0 },
                collision: 'flipfit'
              };
            }
          } else {
            position = {
              my: 'start top',
              at: 'start bottom',
              collision: 'flipfit'
            };
          }

          return { position: position };
        })
      }
    });
  })();

  (function () {
var __oj_menu_metadata = 
{
  "properties": {
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "openOptions": {
      "type": "object",
      "properties": {
        "display": {
          "type": "string",
          "enumValues": [
            "auto",
            "dropDown",
            "sheet"
          ],
          "value": "auto"
        },
        "initialFocus": {
          "type": "string",
          "enumValues": [
            "firstItem",
            "menu",
            "none"
          ],
          "value": "menu"
        },
        "launcher": {
          "type": "string|Element"
        },
        "position": {
          "type": "object",
          "properties": {
            "at": {
              "type": "object",
              "properties": {
                "horizontal": {
                  "type": "string",
                  "enumValues": [
                    "center",
                    "end",
                    "left",
                    "right",
                    "start"
                  ]
                },
                "vertical": {
                  "type": "string",
                  "enumValues": [
                    "bottom",
                    "center",
                    "top"
                  ]
                }
              }
            },
            "collision": {
              "type": "string",
              "enumValues": [
                "fit",
                "flip",
                "flipcenter",
                "flipfit",
                "none"
              ],
              "value": "flipfit"
            },
            "my": {
              "type": "object",
              "properties": {
                "horizontal": {
                  "type": "string",
                  "enumValues": [
                    "center",
                    "end",
                    "left",
                    "right",
                    "start"
                  ],
                  "value": "start"
                },
                "vertical": {
                  "type": "string",
                  "enumValues": [
                    "bottom",
                    "center",
                    "top"
                  ],
                  "value": "top"
                }
              }
            },
            "of": {
              "type": "string|object"
            },
            "offset": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "value": 0
                },
                "y": {
                  "type": "number",
                  "value": 0
                }
              }
            }
          }
        }
      }
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaFocusSkipLink": {
          "type": "string"
        },
        "labelCancel": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "close": {},
    "getProperty": {},
    "open": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAction": {},
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeOpen": {},
    "ojClose": {},
    "ojMenuAction": {},
    "ojOpen": {}
  },
  "extension": {}
};
    __oj_menu_metadata.extension._WIDGET_NAME = 'ojMenu';
    oj.CustomElementBridge.register('oj-menu', { metadata: __oj_menu_metadata });
  })();

});


define('ojs/ojvmenu',['exports', 'preact/jsx-runtime', 'ojs/ojmenu', 'preact'], function (exports, jsxRuntime, ojmenu, preact) { 'use strict';

    class VMenu extends preact.Component {
        constructor(props) {
            super(props);
            this._rootRef = null;
        }
        render(props) {
            return (jsxRuntime.jsx("div", { style: { display: 'none' }, ref: (elem) => (this._rootRef = elem), children: props.children }));
        }
        componentDidMount() {
            if (!this._menuElement) {
                this._menuElement = this._getMenu();
                if (this._menuElement !== null) {
                    this._openMenu();
                }
            }
        }
        _getMenu() {
            const menu = this._rootRef.childNodes[0];
            return menu;
        }
        _openMenu() {
            const openOption = this._getOpenOptions();
            this._menuElement['__openingContextMenu'] = true;
            try {
                this._menuElement.open(this.props.eventObj.event, openOption);
                this._addCloseListener();
            }
            catch (error) {
                throw error;
            }
            finally {
                this._menuElement['__openingContextMenu'] = false;
            }
        }
        _addCloseListener() {
            if (!this.props.onCloseCallback) {
                return;
            }
            this._menuElement.addEventListener('ojClose', this.props.onCloseCallback);
        }
        _getOpenOptions() {
            const eventType = this.props.eventObj.eventType || 'keyboard';
            const openOption = {
                launcher: this.props.launcherElement,
                position: {
                    ...VMenu._MENU_POSITION[eventType],
                    of: eventType === 'keyboard' ? this.props.launcherElement : this.props.eventObj.event
                },
                initialFocus: 'menu'
            };
            return openOption;
        }
        componentWillUnmount() {
            this._removeCloseListener();
        }
        _removeCloseListener() {
            if (this._menuElement && this.props.onCloseCallback) {
                this._menuElement.removeEventListener('ojClose', this.props.onCloseCallback);
            }
        }
    }
    VMenu._MENU_POSITION = {
        mouse: {
            my: 'start top',
            at: 'start bottom',
            collision: 'flipfit'
        },
        touch: {
            my: 'start>40 center',
            at: 'start bottom',
            collision: 'flipfit'
        },
        keyboard: {
            my: 'start top',
            at: 'start bottom',
            collision: 'flipfit'
        }
    };

    exports.VMenu = VMenu;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbutton2',['exports', 'preact/jsx-runtime', 'ojs/ojdomutils', 'ojs/ojgestureutils', 'ojs/ojvcomponent', 'preact', 'ojs/ojvmenu', 'ojs/ojvcomponent-binding', 'ojs/ojthemeutils'], function (exports, jsxRuntime, DomUtils, GestureUtils, ojvcomponent, preact, ojvmenu, ojvcomponentBinding, ThemeUtils) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var Button2_1;
    function getChromingDefault() {
        return ThemeUtils.getCachedCSSVarValues(['--oj-private-button-global-chroming-default'])[0];
    }
    exports.Button2 = Button2_1 = class Button2 extends preact.Component {
        constructor(props) {
            super(props);
            this._rootRef = preact.createRef();
            this._handleContextMenuGesture = (event, eventType) => {
                const contextMenuEvent = {
                    event: event,
                    eventType: eventType
                };
                event.preventDefault();
                this.setState({ contextMenuTriggerEvent: contextMenuEvent });
            };
            this._handleTouchstart = (event) => {
                this.setState({ active: true });
            };
            this._handleTouchend = (event) => {
                this.setState({ active: false });
            };
            this._handleFocusIn = (event) => {
                if (event.target === event.currentTarget) {
                    this._handleFocus(event);
                }
                this.setState({ focus: true });
                if (this._rootRef.current) {
                    this.focusInHandler(this._rootRef.current);
                }
            };
            this._handleFocusOut = (event) => {
                if (event.target === event.currentTarget) {
                    this._handleBlur(event);
                }
                this.setState({ focus: false });
                if (this._rootRef.current) {
                    this.focusOutHandler(this._rootRef.current);
                }
            };
            this._handleMouseenter = (event) => {
                if (!DomUtils.recentTouchEnd()) {
                    if (this === Button2_1._lastActive) {
                        this.setState({ active: true });
                    }
                    this.setState({ hover: true });
                }
            };
            this._handleMouseleave = (event) => {
                this.setState({ hover: false, active: false });
            };
            this._handleMousedown = (event) => {
                if (event.which === 1 && !DomUtils.recentTouchEnd()) {
                    this.setState({ active: true });
                    Button2_1._lastActive = this;
                    const docMouseupListener = () => {
                        Button2_1._lastActive = null;
                        document.removeEventListener('mouseup', docMouseupListener, true);
                    };
                    document.addEventListener('mouseup', docMouseupListener, true);
                }
            };
            this._handleMouseup = (event) => {
                this.setState({ active: false });
            };
            this._handleClick = (event) => {
                if (event.detail <= 1) {
                    this.props.onOjAction?.({ originalEvent: event });
                }
            };
            this._handleKeydown = (event) => {
                if (event.keyCode === 32 || event.keyCode === 13) {
                    this.setState({ active: true });
                }
            };
            this._handleKeyup = (event) => {
                this.setState({ active: false });
            };
            this._handleFocus = (event) => {
                this._rootRef?.current?.dispatchEvent(new FocusEvent('focus', { relatedTarget: event.relatedTarget }));
            };
            this._handleBlur = (event) => {
                this.setState({ active: false });
                this._rootRef?.current.dispatchEvent(new FocusEvent('blur', { relatedTarget: event.relatedTarget }));
            };
            this._onCloseCallback = (event) => {
                if (this.state.contextMenuTriggerEvent) {
                    this.setState({ contextMenuTriggerEvent: null });
                }
            };
            this.state = {};
            this.uniquePrefix = props.id ? props.id + ojvcomponent.getUniqueId() : ojvcomponent.getUniqueId();
        }
        render(props, state) {
            const defaultSlot = props.children;
            let startIconContent = this._processIcon(props.startIcon, 'oj-button-icon oj-start');
            let endIconContent = this._processIcon(props.endIcon, 'oj-button-icon oj-end');
            let ariaLabel = props['aria-label'];
            let ariaLabelledBy = props['aria-labelledby'];
            let ariaDescribedBy = props['aria-describedby'];
            const hasDefaultAriaAttribute = ariaLabel || ariaLabelledBy;
            let defaultContent = null;
            let clickHandler = null;
            let ariaLabelledById = null;
            let title = props.title;
            const buttonLabel = props.label || defaultSlot;
            if (buttonLabel) {
                title = this.state.derivedTitle || title || props.label;
                if (props.display === 'icons' && (startIconContent || endIconContent)) {
                    if (props.label) {
                        if (!hasDefaultAriaAttribute) {
                            ariaLabel = props.label;
                        }
                        defaultContent = (jsxRuntime.jsx("span", { ref: (elem) => (this._defaultSlotRef = elem), children: defaultContent }));
                    }
                    else {
                        if (!hasDefaultAriaAttribute) {
                            ariaLabelledById = this.uniquePrefix + '|text';
                            ariaLabelledBy = ariaLabelledById;
                        }
                        defaultContent = (jsxRuntime.jsx("span", { ref: (elem) => (this._defaultSlotRef = elem), class: "oj-button-text oj-helper-hidden-accessible", id: ariaLabelledById, children: buttonLabel }));
                    }
                }
                else if (props.display === 'label') {
                    if (props.startIcon) {
                        startIconContent = this._processIcon(props.startIcon, 'oj-button-icon oj-helper-hidden oj-start');
                    }
                    if (props.endIcon) {
                        endIconContent = this._processIcon(props.endIcon, 'oj-button-icon oj-helper-hidden oj-end');
                    }
                    if (!hasDefaultAriaAttribute) {
                        ariaLabelledById = this.uniquePrefix + '|text';
                        ariaLabelledBy = ariaLabelledById;
                    }
                    defaultContent = (jsxRuntime.jsx("span", { ref: (elem) => (this._defaultSlotRef = elem), class: "oj-button-text", id: ariaLabelledById, children: buttonLabel }));
                }
                else {
                    if (!hasDefaultAriaAttribute) {
                        ariaLabelledById = this.uniquePrefix + '|text';
                        ariaLabelledBy = ariaLabelledById;
                    }
                    defaultContent = (jsxRuntime.jsx("span", { ref: (elem) => (this._defaultSlotRef = elem), class: "oj-button-text", id: ariaLabelledById, children: buttonLabel }));
                }
            }
            else {
                defaultContent = (jsxRuntime.jsx("span", { ref: (elem) => (this._defaultSlotRef = elem), children: defaultContent }));
            }
            const labelContent = (jsxRuntime.jsxs("div", { class: "oj-button-label", children: [startIconContent, defaultContent, endIconContent] }));
            let buttonContent;
            if (props.disabled) {
                buttonContent = (jsxRuntime.jsx("button", { class: "oj-button-button", "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-label": ariaLabel, disabled: true, children: labelContent }));
            }
            else {
                clickHandler = this._handleClick;
                buttonContent = (jsxRuntime.jsx("button", { class: "oj-button-button", ref: (elem) => (this._buttonRef = elem), "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-label": ariaLabel, onTouchStart: this._handleTouchstart, onTouchEnd: this._handleTouchend, onTouchCancel: this._handleTouchend, onMouseEnter: this._handleMouseenter, onMouseLeave: this._handleMouseleave, onMouseDown: this._handleMousedown, onMouseUp: this._handleMouseup, onfocusin: this._handleFocusIn, onfocusout: this._handleFocusOut, onKeyDown: this._handleKeydown, onKeyUp: this._handleKeyup, children: labelContent }));
            }
            const rootClasses = this._getRootClasses(startIconContent, endIconContent);
            return (jsxRuntime.jsxs(ojvcomponent.Root, { class: rootClasses, id: props.id, title: title, onClick: clickHandler, "aria-describedby": ariaDescribedBy, ref: this._rootRef, children: [buttonContent, this._renderContextMenu()] }));
        }
        _renderContextMenu() {
            if (!this.state.contextMenuTriggerEvent || !this.props.contextMenu) {
                return null;
            }
            return (jsxRuntime.jsx(ojvmenu.VMenu, { eventObj: this.state.contextMenuTriggerEvent, launcherElement: this._buttonRef, onCloseCallback: this._onCloseCallback, children: [this.props.contextMenu] }));
        }
        _processIcon(icon, slotClass) {
            let iconContent;
            if (Array.isArray(icon)) {
                iconContent = icon.map((elem) => {
                    return this._processIcon(elem, slotClass);
                });
            }
            else if (icon) {
                iconContent = jsxRuntime.jsx("span", { class: slotClass, children: icon });
            }
            return iconContent;
        }
        _getRootClasses(startIconContent, endIconContent) {
            let defaultState = true;
            let classList = 'oj-button ' + Button2_1._chromingMap[this.props.chroming];
            classList += ' ' + this._getDisplayOptionClass(startIconContent, endIconContent);
            if (this.props.disabled) {
                defaultState = false;
                classList += ' oj-disabled';
            }
            else {
                classList += ' oj-enabled';
                if (this.state.hover) {
                    defaultState = false;
                    classList += ' oj-hover';
                }
                if (this.state.active) {
                    defaultState = false;
                    classList += ' oj-active';
                }
            }
            if (defaultState) {
                classList += ' oj-default';
            }
            return classList;
        }
        _getDisplayOptionClass(startIconContent, endIconContent) {
            const multipleIcons = startIconContent && endIconContent;
            const atLeastOneIcon = startIconContent || endIconContent;
            const displayIsIcons = this.props.display === 'icons';
            const displayIsLabel = this.props.display === 'label';
            let buttonClass;
            if (displayIsLabel) {
                buttonClass = 'oj-button-text-only';
            }
            else if (atLeastOneIcon) {
                if (displayIsIcons) {
                    if (multipleIcons) {
                        buttonClass = 'oj-button-icons-only';
                    }
                    else {
                        buttonClass = 'oj-button-icon-only';
                    }
                }
                else if (multipleIcons) {
                    buttonClass = 'oj-button-text-icons';
                }
                else if (startIconContent) {
                    buttonClass = 'oj-button-text-icon-start';
                }
                else {
                    buttonClass = 'oj-button-text-icon-end';
                }
            }
            else {
                buttonClass = 'oj-button-text-only';
            }
            return buttonClass;
        }
        _addMutationObserver() {
            if (this._mutationObserver) {
                return;
            }
            const config = {
                subtree: true,
                characterData: true
            };
            const callback = () => {
                const title = this._getTextContent();
                if (title != this.state.derivedTitle) {
                    this.setState({ derivedTitle: title });
                }
            };
            this._mutationObserver = new MutationObserver(callback);
            this._mutationObserver.observe(this._defaultSlotRef, config);
        }
        _needsContextMenuDetection(props) {
            return props.contextMenu && !props.disabled;
        }
        componentDidMount() {
            this._updateDerivedTitle();
            if (this._needsContextMenuDetection(this.props)) {
                GestureUtils.startDetectContextMenuGesture(this._rootRef.current, this._handleContextMenuGesture);
            }
            this._rootRef.current.addEventListener('touchstart', this._handleTouchstart, { passive: true });
            this._rootRef.current.addEventListener('touchend', this._handleTouchend, { passive: false });
            this._rootRef.current.addEventListener('touchcancel', this._handleTouchend, {
                passive: true
            });
            DomUtils.makeFocusable({
                applyHighlight: true,
                setupHandlers: (focusInHandler, focusOutHandler) => {
                    let noJQHandlers = DomUtils.getNoJQFocusHandlers(focusInHandler, focusOutHandler);
                    this.focusInHandler = noJQHandlers.focusIn;
                    this.focusOutHandler = noJQHandlers.focusOut;
                }
            });
        }
        componentDidUpdate(oldProps) {
            if (oldProps.display != this.props.display) {
                this._updateDerivedTitle();
            }
            this._updateContextMenuDetection(oldProps);
            if (this.props.disabled && oldProps.disabled != this.props.disabled) {
                this.setState({ hover: false });
            }
        }
        _updateDerivedTitle() {
            const props = this.props;
            let title;
            if (props.display === 'icons' &&
                (props.startIcon || props.endIcon) &&
                !props.label &&
                !props.title) {
                title = this._getTextContent();
                this._addMutationObserver();
            }
            if (title != this.state.derivedTitle) {
                this.setState({ derivedTitle: title });
            }
        }
        _updateContextMenuDetection(oldProps) {
            const oldNeedsDetect = this._needsContextMenuDetection(oldProps);
            const newNeedsDetect = this._needsContextMenuDetection(this.props);
            if (oldNeedsDetect != newNeedsDetect) {
                if (newNeedsDetect) {
                    GestureUtils.startDetectContextMenuGesture(this._rootRef.current, this._handleContextMenuGesture);
                }
                else {
                    GestureUtils.stopDetectContextMenuGesture(this._rootRef.current);
                }
            }
        }
        static getDerivedStateFromProps(props) {
            if (props.disabled) {
                return { contextMenuTriggerEvent: null };
            }
            return null;
        }
        _getTextContent() {
            let content = this._defaultSlotRef.textContent;
            content = content.trim();
            if (content !== '') {
                return content;
            }
            return null;
        }
        componentWillUnmount() {
            if (this._mutationObserver) {
                this._mutationObserver.disconnect();
                this._mutationObserver = null;
            }
            GestureUtils.stopDetectContextMenuGesture(this._rootRef.current);
        }
        refresh() {
            this.setState({ active: false });
        }
        focus() {
            this._buttonRef?.focus();
        }
        blur() {
            this._buttonRef?.blur();
        }
    };
    exports.Button2._chromingMap = {
        solid: 'oj-button-full-chrome',
        outlined: 'oj-button-outlined-chrome',
        borderless: 'oj-button-half-chrome',
        full: 'oj-button-full-chrome',
        half: 'oj-button-half-chrome',
        callToAction: 'oj-button-cta-chrome',
        danger: 'oj-button-danger-chrome oj-button-full-chrome'
    };
    exports.Button2.defaultProps = {
        disabled: false,
        display: 'all',
        chroming: getChromingDefault()
    };
    exports.Button2._metadata = { "slots": { "": {}, "startIcon": {}, "endIcon": {}, "contextMenu": {} }, "properties": { "disabled": { "type": "boolean" }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "label": { "type": "string" }, "translations": { "type": "object" }, "chroming": { "type": "string", "enumValues": ["full", "solid", "borderless", "callToAction", "danger", "half", "outlined"], "binding": { "consume": { "name": "containerChroming" } } } }, "events": { "ojAction": { "bubbles": true } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["id", "title", "aria-label", "aria-labelledby", "aria-describedby"] }, "methods": { "refresh": {}, "focus": {}, "blur": {} } };
    exports.Button2 = Button2_1 = __decorate([
        ojvcomponent.customElement('oj-button')
    ], exports.Button2);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojbutton',['ojs/ojoption', 'ojs/ojcore-base', 'jquery', 'ojs/ojdomutils', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojchildmutationobserver', 'ojs/ojlabelledbyutils', 'ojs/ojcustomelement-utils', 'ojs/ojbutton2'], function (ojoption, oj, $, DomUtils, ThemeUtils, Components, ChildMutationObserver, LabelledByUtils, ojcustomelementUtils, ojbutton2) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  ChildMutationObserver = ChildMutationObserver && Object.prototype.hasOwnProperty.call(ChildMutationObserver, 'default') ? ChildMutationObserver['default'] : ChildMutationObserver;
  LabelledByUtils = LabelledByUtils && Object.prototype.hasOwnProperty.call(LabelledByUtils, 'default') ? LabelledByUtils['default'] : LabelledByUtils;

var __oj_menu_button_metadata = 
{
  "properties": {
    "chroming": {
      "type": "string",
      "enumValues": [
        "borderless",
        "full",
        "half",
        "outlined",
        "solid"
      ]
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "display": {
      "type": "string",
      "enumValues": [
        "all",
        "icons",
        "label"
      ],
      "value": "all"
    },
    "label": {
      "type": "string"
    },
    "translations": {
      "type": "object",
      "value": {}
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAction": {}
  },
  "extension": {}
};
  /* global __oj_menu_button_metadata */
  (function () {
    __oj_menu_button_metadata.extension._WIDGET_NAME = 'ojButton';
    __oj_menu_button_metadata.extension._TRACK_CHILDREN = 'nearestCustomElement';
    __oj_menu_button_metadata.extension._GLOBAL_TRANSFER_ATTRS = [
      'href',
      'aria-label',
      'aria-labelledby',
      'aria-describedby'
    ];
    oj.CustomElementBridge.register('oj-menu-button', {
      metadata: __oj_menu_button_metadata,
      innerDomFunction: function (element) {
        return element.getAttribute('href') ? 'a' : 'button';
      }
    });
  })();

var __oj_buttonset_one_metadata = 
{
  "properties": {
    "chroming": {
      "type": "string",
      "enumValues": [
        "borderless",
        "full",
        "half",
        "outlined",
        "solid"
      ]
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "display": {
      "type": "string",
      "enumValues": [
        "all",
        "icons",
        "label"
      ],
      "value": "all"
    },
    "focusManagement": {
      "type": "string",
      "enumValues": [
        "none",
        "oneTabstop"
      ],
      "value": "oneTabstop"
    },
    "labelledBy": {
      "type": "string"
    },
    "translations": {
      "type": "object",
      "value": {}
    },
    "value": {
      "type": "any",
      "writeback": true
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_buttonset_one_metadata */
  (function () {
    __oj_buttonset_one_metadata.extension._WIDGET_NAME = 'ojButtonset';
    __oj_buttonset_one_metadata.extension._ALIASED_PROPS = { value: 'checked' };
    oj.CustomElementBridge.register('oj-buttonset-one', {
      metadata: __oj_buttonset_one_metadata
    });
  })();

var __oj_buttonset_many_metadata = 
{
  "properties": {
    "chroming": {
      "type": "string",
      "enumValues": [
        "borderless",
        "full",
        "half",
        "outlined",
        "solid"
      ]
    },
    "describedBy": {
      "type": "string"
    },
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "display": {
      "type": "string",
      "enumValues": [
        "all",
        "icons",
        "label"
      ],
      "value": "all"
    },
    "focusManagement": {
      "type": "string",
      "enumValues": [
        "none",
        "oneTabstop"
      ],
      "value": "oneTabstop"
    },
    "labelledBy": {
      "type": "string"
    },
    "translations": {
      "type": "object",
      "value": {}
    },
    "value": {
      "type": "Array<any>",
      "writeback": true
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_buttonset_many_metadata */
  (function () {
    __oj_buttonset_many_metadata.extension._WIDGET_NAME = 'ojButtonset';
    __oj_buttonset_many_metadata.extension._ALIASED_PROPS = { value: 'checked' };
    oj.CustomElementBridge.register('oj-buttonset-many', {
      metadata: __oj_buttonset_many_metadata
    });
  })();

  /* eslint-disable quote-props */
  /* eslint-disable quotes */

  // Backdoor for using widget-based implmentation instead of VComponent implementation for oj-button.
  // Apps can enable it by mapping ojs/ojbutton2 to ojs/ojbuttonlegacy in requirejs.config.
  // We can't register oj-button in ojbuttonlegacy because it needs to be done at the same time as
  // ojButton widget.  Otherwise the framework may try to create oj-button custom element prematurely.
  //
  if (oj.ButtonLegacy) {
    // The metadata is usually generated from jsdoc during the build.
    // However, including jsdoc will cause it to appear in the actual API doc, so we specify the metadata directly.

    // eslint-disable-next-line camelcase
    var __oj_button_legacy_metadata = {
      properties: {
        chroming: {
          type: 'string',
          enumValues: ['borderless', 'callToAction', 'danger', 'full', 'half', 'outlined', 'solid']
        },
        disabled: {
          type: 'boolean',
          value: false
        },
        display: {
          type: 'string',
          enumValues: ['all', 'icons', 'label'],
          value: 'all'
        },
        translations: {
          type: 'object',
          value: {}
        }
      },
      methods: {
        refresh: {},
        setProperty: {},
        getProperty: {},
        setProperties: {},
        getNodeBySubId: {},
        getSubIdByNode: {}
      },
      events: {
        ojAction: {}
      },
      extension: {}
    };

    (function () {
      __oj_button_legacy_metadata.extension._WIDGET_NAME = 'ojButton';
      __oj_button_legacy_metadata.extension._TRACK_CHILDREN = 'nearestCustomElement';
      __oj_button_legacy_metadata.extension._GLOBAL_TRANSFER_ATTRS = [
        'href',
        'aria-label',
        'aria-labelledby',
        'aria-describedby'
      ];
      oj.CustomElementBridge.register('oj-button', {
        metadata: __oj_button_legacy_metadata,
        innerDomFunction: function (element) {
          return element.getAttribute('href') ? 'a' : 'button';
        }
      });
    })();
  }

  (function () {
    // Button / Buttonset wrapper function, to keep "private static members" private
    // -----------------------------------------------------------------------------
    // "private static members" shared by all buttons and buttonsets
    // -----------------------------------------------------------------------------
    var _lastActive;
    var _lastToggleActive;

    var BASE_CLASSES = 'oj-button oj-component oj-enabled oj-default'; // oj-enabled is a state class, but convenient to include in this var instead
    var STATE_CLASSES = 'oj-hover oj-active oj-selected';
    var TYPE_CLASSES =
      'oj-button-icons-only oj-button-icon-only oj-button-text-icons oj-button-text-icon-start oj-button-text-icon-end oj-button-text-only';
    var CHROMING_CLASSES =
      'oj-button-full-chrome oj-button-half-chrome oj-button-outlined-chrome oj-button-cta-chrome oj-button-danger-chrome';

    var _chromingMap = {
      solid: 'oj-button-full-chrome',
      outlined: 'oj-button-outlined-chrome',
      borderless: 'oj-button-half-chrome',
      full: 'oj-button-full-chrome',
      half: 'oj-button-half-chrome',
      callToAction: 'oj-button-cta-chrome',
      danger: 'oj-button-danger-chrome oj-button-full-chrome'
    };

    var _interestingContainers = {
      button: ['ojButtonset', 'ojToolbar'],
      buttonset: ['ojToolbar']
    };

    /**
     * @ojcomponent oj.ojButton
     * @augments oj.baseComponent
     * @since 0.6.0
     * @ojdeprecated [
     *  {
     *    type: "maintenance",
     *    since: "15.0.0",
     *    value: ["oj-c-button"]
     *  }
     * ]
     *
     * @ojshortdesc Buttons direct users to initiate or take actions and work with a single tap, click, or keystroke.
     * @ojrole button
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojButton<SP extends ojButtonSettableProperties = ojButtonSettableProperties> extends baseComponent<SP>"
     *               }
     *              ]
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["label", "display", "chroming", "disabled"]}
     * @ojvbdefaultcolumns 2
     * @ojvbmincolumns 1
     *
     * @ojuxspecs ['button']
     *
     * @classdesc
     * <h3 id="buttonOverview-section">
     *   JET Button
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant push buttons, with appropriate styles for hover, active, checked, and disabled.
     *
     * <p>To create toggle buttons, see the [JET Buttonset]{@link oj.ojButtonset}.
     *
     * <pre class="prettyprint"><code>&lt;oj-button id="myButton">
     *     &lt;span>My Button&lt;/span>
     * &lt;/oj-button>
     * </code></pre>
     *
     * <h3 id="pushButtons-section">
     *   Push Buttons
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pushButtons-section"></a>
     * </h3>
     *
     * <p>Push buttons are ordinary buttons that do not stay pressed in when clicked.
     * Push buttons are created from <code class="prettyprint">oj-button</code> elements.
     *
     * <h3 id="buttonsetToolbar-section">
     *   Buttonsets and Toolbars
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetToolbar-section"></a>
     * </h3>
     *
     * <p>The [JET Buttonset]{@link oj.ojButtonset} component can be used to create toggle buttons or group related buttons, such as a group of radios or checkboxes.  Buttonset provides
     * visual and semantic grouping and WAI-ARIA-compliant focus management.  See the Buttonset API doc for more information.
     *
     * <p>Also, buttons and buttonsets can be placed in a [JET Toolbar]{@link oj.ojToolbar}.  Like Buttonset, Toolbar is themable and provides WAI-ARIA-compliant
     * focus management.  See the Toolbar API doc for more information.
     *
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, it is not required to set an aria label on a JET button as it uses the text in the default slot to generate an aria label.
     * Therefore the default slot should be filled even if the button is <a href="#display">icon-only (display=icons)</a>. However,
     * you can override the default behavior by setting <code class="prettyprint">aria-label</code> or <code class="prettyprint">aria-labelledby</code>.
     * For providing additional description, you can set <code class="prettyprint">aria-describedby</code> with id of span with custom description
     * {@ojinclude "name":"accessibilityCommon"}
     *
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     *  </h3>
     *  To migrate from oj-button to oj-c-button, you need to revise the import statement and references to oj-c-button in your app.  Please note the changes between the two components below.
     *  <h5>Label attribute</h5>
     *  <p>The default slot is no longer supported.  Text labels must be provide using the label attribute.</p>
     *  <h5>Context Menu</h5>
     *   <p>The context menu is no longer supported. </p>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <p>In lieu of stamping a button in a table, dataGrid, or other container, consider placing a single Button outside the
     * container that acts on the currently selected row or cell.
     *
     * <h3 id="state-section">
     *   Setting Component State
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"stateCommon"}
     */
    // API doc for inherited methods with no JS in this file:

    /**
     * <p>The default slot is the button's text label, if no label attribute is specified. The <code class="prettyprint">&lt;oj-button></code> element accepts plain text or DOM nodes as children for the default slot.
     * A default slot label is required for all buttons for accessibility purposes, if no label attribute is specified. The label can be hidden using the display attribute.</p>
     *
     * <p>If a text node is provided it will be wrapped in a span.</p>
     *
     * Note that if both a default slot and a label attribute are provided, the attribute takes precedence over the default slot.
     *
     * @ojchild Default
     * @memberof oj.ojButton
     * @ojshortdesc The default slot is the button's text label. The oj-button element accepts plain text or DOM nodes as children for the default slot.
     *
     * @example <caption>Initialize the Button with child content specified:</caption>
     * &lt;oj-button>
     *   &lt;span>myValue&lt;/span>
     * &lt;/oj-button>
     *
     * @example <caption>Initialize the Button with data-bound child content specified in a span:</caption>
     * &lt;oj-button>
     *   &lt;span>
     *     &lt;oj-bind-text value='[[myText]]'>&lt;/oj-bind-text>
     *   &lt;/span>
     * &lt;/oj-button>
     *
     * @example <caption>Initialize the Button with data-bound child content specified without a container element:</caption>
     * &lt;oj-button>
     *   &lt;oj-bind-text value='[[myText]]'>&lt;/oj-bind-text>
     * &lt;/oj-button>
     */

    /**
     * <p>The default slot is the menu button's text label. The <code class="prettyprint">&lt;oj-menu-button></code> element accepts plain text or DOM nodes as children for the default slot.
     * A default slot label is required for all menu buttons for accessibility purposes. The label can be hidden using the display attribute.</p>
     *
     * <p>If a text node is provided it will be wrapped in a span.</p>
     *
     * @ojchild Default
     * @memberof oj.ojMenuButton
     * @ojshortdesc The default slot is the button's text label. The oj-menu-button element accepts plain text or DOM nodes as children for the default slot.
     *
     * @example <caption>Initialize the Menu Button with child content specified:</caption>
     * &lt;oj-menu-button>
     *   &lt;span>myValue&lt;/span>
     * &lt;/oj-menu-button>
     *
     * @example <caption>Initialize the Menu Button with data-bound child content specified in a span:</caption>
     * &lt;oj-menu-button>
     *   &lt;span>
     *     &lt;oj-bind-text value='[[myText]]'>&lt;/oj-bind-text>
     *   &lt;/span>
     * &lt;/oj-menu-button>
     *
     * @example <caption>Initialize the Menu Button with data-bound child content specified without a container element:</caption>
     * &lt;oj-menu-button>
     *   &lt;oj-bind-text value='[[myText]]'>&lt;/oj-bind-text>
     * &lt;/oj-menu-button>
     */

    /**
     * <p>The <code class="prettyprint">startIcon</code> slot is the button's start icon. The  <code class="prettyprint">&lt;oj-button></code> element accepts DOM nodes as children with the startIcon slot.</p>
     *
     * @ojslot startIcon
     * @memberof oj.ojButton
     * @ojshortdesc The startIcon slot is the button's start icon. The oj-button element accepts DOM nodes as children with the startIcon slot.
     *
     * @ojtsexample
     * &lt;oj-button>
     *   &lt;span slot='startIcon' class='myIconClass'>&lt;/span>
     *   &lt;span>myValue&lt;/span>
     * &lt;/oj-button>
     */

    /**
     * <p>The <code class="prettyprint">startIcon</code> slot is the menu button's start icon. The  <code class="prettyprint">&lt;oj-menu-button></code> element accepts DOM nodes as children with the startIcon slot.</p>
     *
     * @ojslot startIcon
     * @memberof oj.ojMenuButton
     * @ojshortdesc The startIcon slot is the button's start icon. The oj-menu-button element accepts DOM nodes as children with the startIcon slot.
     *
     * @example <caption>Initialize the Menu Button with child content specified for the startIcon:</caption>
     * &lt;oj-menu-button>
     *   &lt;span slot='startIcon' class='myIconClass'>&lt;/span>
     *   &lt;span>myValue&lt;/span>
     * &lt;/oj-menu-button>
     */

    /**
     * <p>The <code class="prettyprint">endIcon</code> slot is the button's end icon. The  <code class="prettyprint">&lt;oj-button></code> element accepts DOM nodes as children with the endIcon slot.</p>
     *
     * @ojslot endIcon
     * @memberof oj.ojButton
     * @ojshortdesc The endIcon slot is the button's end icon. The oj-button element accepts DOM nodes as children with the endIcon slot.
     *
     * @ojtsexample
     * &lt;oj-button>
     *   &lt;span>myValue&lt;/span>
     *   &lt;span slot='endIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-button>
     */

    /**
     * <p>The <code class="prettyprint">endIcon</code> slot is the menu button's end icon. The  <code class="prettyprint">&lt;oj-menu-button></code> element accepts DOM nodes as children with the endIcon slot. If no end icon is provided, a default end icon is used.</p>
     *
     * @ojslot endIcon
     * @memberof oj.ojMenuButton
     * @ojshortdesc The endIcon slot is the button's end icon. The oj-menu button element accepts DOM nodes as children with the endIcon slot.
     *
     * @example <caption>Initialize the Menu Button with child content specified for the endIcon:</caption>
     * &lt;oj-menu-button>
     *   &lt;span>myValue&lt;/span>
     *   &lt;span slot='endIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-menu-button>
     */

    /**
     * <p>The <code class="prettyprint">menu</code> menu associated with the menu button. The <code class="prettyprint">oj-menu-button</code> element accepts a single <code class="prettyprint">oj-menu</code> element as a child with the menu slot. See the [JET Menu]{@link oj.ojMenu} for more information on setting up a menu.</p>
     *
     * @ojslot menu
     * @ojmaxitems 1
     * @memberof oj.ojMenuButton
     * @ojshortdesc The menu associated with the menu button. The oj-menu-button element accepts a single oj-menu element as a child with the menu slot.
     * @ojpreferredcontent ["MenuElement"]
     *
     * @example <caption>Initialize the Menu Button with child content specified for the menu:</caption>
     * &lt;oj-menu-button>
     *   &lt;span>myValue&lt;/span>
     *   &lt;oj-menu slot="menu" style="display:none" aria-label="This menu button's menu">
     *   ...
     *   &lt;/oj-menu>
     * &lt;/oj-menu-button>
     */

    // Fragments:

    /**
     * <p>See also the <a href="#styling-section">oj-focus-highlight</a> discussion.
     *
     * <p>Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.<p>
     *
     * @ojfragment accessibilityCommon
     * @memberof oj.ojButton
     * @instance
     */

    /**
     * <p>Built-in KO bindings, like KO's <code class="prettyprint">disable</code> binding, should not be used for state with a JS API, since that is tatamount to
     * updating the DOM directly.  The component attribute should be bound instead.
     *
     * <p>State with no JS API should be set by manipulating the DOM directly in an allowable way, and then calling <code class="prettyprint">refresh()</code>
     * on the affected component(s).  E.g. the reading direction (LTR / RTL) is changed by by setting the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> node and calling <code class="prettyprint">refresh()</code>.
     *
     * <p>When using a built-in Knockout binding, keep in mind that those bindings do not
     * execute the necessary <code class="prettyprint">refresh()</code> call after updating the DOM.  Updates that flow from the component to the observable,
     * as a result of user interaction, are not problematic.  But updates in the other direction, that programmatically update the DOM because the observable changed,
     * will not be picked up until the next <code class="prettyprint">refresh()</code>.
     *
     * @ojfragment stateCommon
     * @memberof oj.ojButton
     * @instance
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *     <tr>
     *       <td>Toggle Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Toggle the button.</td>
     *     </tr>
     *     <tr>
     *       <td>Menu Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Open the menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>See also the [Menu]{@link oj.ojMenu} touch gesture doc.
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojButton
     * @instance
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd>*</td>
     *       <td>Push the button.</td>
     *     </tr>
     *     <tr>
     *       <td>Toggle Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Toggle the button.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Menu Button</td>
     *       <td><kbd>Enter</kbd>, <kbd>Space</kbd>*, or <kbd>DownArrow</kbd></td>
     *       <td>Open the menu.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Close the menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>* Some types of Push and Menu Buttons support <kbd>Enter</kbd>, not <kbd>Space</kbd>.
     *
     * <p>See the [Menu]{@link oj.ojMenu} keyboard doc for keystrokes that apply when focus is on the menu.
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojButton
     * @instance
     */
    oj.__registerWidget('oj.ojButton', $.oj.baseComponent, {
      defaultElement: '<button>', // added to externs.js, since this is an override of a superclass member.  (That's the rule for public methods, what about protected fields?)  Would @override do the job and be better than externing?
      widgetEventPrefix: 'oj',
      // options is in externs.js, so no need for quotes
      options: {
        /**
         * {@ojinclude "name":"buttonCommonChroming"}
         *
         * @name chroming
         * @instance
         * @memberof oj.ojButton
         * @type {string}
         * @ojvalue {string} "solid" Solid buttons stand out, and direct the user's attention to the most important actions in the UI.
         * @ojvalue {string} "outlined" Outlined buttons are salient, but lighter weight than solid buttons. Outlined buttons are useful for secondary actions.
         * @ojvalue {string} "borderless" Borderless buttons are the least prominent variation. Borderless buttons are useful for supplemental actions that require minimal emphasis.
         * @ojvalue {string} "callToAction" A Call To Action (CTA) button guides the user to take or complete the action that is the main goal of the page or page section. There should only be one CTA button on a page at any given time.
         * @ojvalue {string} "danger" A Danger button alerts the user to a dangerous situation.
         * @ojvalue {string} "full" Please use solid instead. In typical themes, full-chrome buttons always have chrome.
         * @ojvalue {string} "half" In typical themes, half-chrome buttons acquire chrome only in their hover, active, and selected states.
         * @ojshortdesc Indicates in what states the button has chrome (background and border).
         * @ojdeprecated [{target:'propertyValue', for:"half", since: "6.0.0", description: "This value will be removed in the future. Please use borderless instead."},
         *                {target:'propertyValue', for:"full", since: "6.0.0", description: "This value will be removed in the future. Please use solid instead."}]
         * @example <caption>Initialize the Button with the <code class="prettyprint">chroming</code> attribute specified:</caption>
         * &lt;oj-button chroming='borderless'>&lt;/oj-button>
         *
         * @example <caption>Get or set the <code class="prettyprint">chroming</code> property after initialization:</caption>
         * // getter
         * var chromingValue = myButton.chroming;
         *
         * // setter
         * myButton.chroming = 'borderless';
         *
         * @example <caption>Set the default in the theme (CSS) :</caption>
         * --oj-private-buttonset-global-chroming-default: borderless !default;
         */

        /**
         * {@ojinclude "name":"buttonCommonChroming"}
         *
         * @name chroming
         * @instance
         * @memberof oj.ojMenuButton
         * @type {string}
         * @ojvalue {string} "solid" Solid buttons stand out, and direct the user's attention to the most important actions in the UI.
         * @ojvalue {string} "outlined" Outlined buttons are salient, but lighter weight than solid buttons. Outlined buttons are useful for secondary actions.
         * @ojvalue {string} "borderless" Borderless buttons are the least prominent variation. Borderless buttons are useful for supplemental actions that require minimal emphasis.
         * @ojvalue {string} "full" Please use solid instead. In typical themes, full-chrome buttons always have chrome.
         * @ojvalue {string} "half" In typical themes, half-chrome buttons acquire chrome only in their hover, active, and selected states.
         * @ojshortdesc Indicates in what states the button has chrome (background and border).
         * @ojdeprecated [{target:'propertyValue', for:"half", since: "6.0.0", description: "This value will be removed in the future. Please use borderless instead."},
         *                {target:'propertyValue', for:"full", since: "6.0.0", description: "This value will be removed in the future. Please use solid instead."}]
         *
         * @example <caption>Initialize the Button with the <code class="prettyprint">chroming</code> attribute specified:</caption>
         * &lt;oj-button chroming='borderless'>&lt;/oj-button>
         *
         * @example <caption>Get or set the <code class="prettyprint">chroming</code> property after initialization:</caption>
         * // getter
         * var chromingValue = myButton.chroming;
         *
         * // setter
         * myButton.chroming = 'borderless';
         *
         * @example <caption>Set the default in the theme (CSS) :</caption>
         * --oj-private-button-global-chroming-default: borderless;
         */

        /**
         * <p>Indicates in what states the button has chrome (background and border).
         *
         * <p>The default chroming varies by theme and containership as follows:
         * <ul>
         *   <li>If the button is in a buttonset or toolbar, then the default chroming is the current <code class="prettyprint">chroming</code> value of the nearest such container.</li>
         *   <li>Else, the default chroming value is controlled by the theme.
         * </ul>
         *
         * <p>Once a value has been set on this button attribute, that value applies regardless of theme and containership.
         *
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @since 1.2.0
         * @ojfragment buttonCommonChroming
         */
        chroming: 'solid',

        /**
         * {@ojinclude "name":"buttonCommonDisabled"}
         *
         * @name disabled
         * @memberof oj.ojButton
         * @instance
         * @type {boolean}
         * @default false
         * @ojshortdesc Specifies that the button element should be disabled.
         *
         * @example <caption>Initialize the Button with the <code class="prettyprint">disabled</code> attribute specified:</caption>
         * &lt;oj-button disabled='true'>&lt;/oj-button>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabledValue = myButton.disabled;
         *
         * // setter
         * myButton.disabled = true;
         */

        /**
         * {@ojinclude "name":"buttonCommonDisabled"}
         *
         * @name disabled
         * @memberof oj.ojMenuButton
         * @instance
         * @type {boolean}
         * @default false
         * @ojshortdesc Specifies that the button element should be disabled.
         *
         * @example <caption>Initialize the Menu Button with the <code class="prettyprint">disabled</code> attribute specified:</caption>
         * &lt;oj-menu-button disabled='true'>&lt;/oj-menu-button>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabledValue = myMenuButton.disabled;
         *
         * // setter
         * myMenuButton.disabled = true;
         */

        /**
         * <p>Disables the button if set to <code class="prettyprint">true</code>.
         *
         * <p>After create time, the <code class="prettyprint">disabled</code> state should be set via this API, not by setting the underlying DOM attribute.
         *
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @ojfragment buttonCommonDisabled
         */
        disabled: false,

        /**
         * {@ojinclude "name":"buttonCommonDisplay"}
         *
         * <p>For accessibility, a JET Button must always have a label set via the default slot, even if it is icon-only.
         *
         * @name display
         * @memberof oj.ojButton
         * @instance
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @ojvalue {string} "label" Display only the label.
         * @default "all"
         * @ojshortdesc Specifies whether the button displays label and icons, or just icons.
         *
         * @example <caption>Initialize the Button with the <code class="prettyprint">display</code> attribute specified:</caption>
         * &lt;oj-button display='icons'>&lt;/oj-button>
         *
         * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
         * // getter
         * var displayValue = myButton.display;
         *
         * // setter
         * myButton.display = 'icons';
         */

        /**
         * {@ojinclude "name":"buttonCommonDisplay"}
         *
         * <p>For accessibility, a JET Menu Button must always have a label set via the default slot, even if it is icon-only.
         *
         * @name display
         * @instance
         * @memberof oj.ojMenuButton
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @ojvalue {string} "label" Display only the label.
         * @default "all"
         * @ojshortdesc Specifies whether the button displays label and icons, or just icons.
         *
         * @example <caption>Initialize the Menu Button with the <code class="prettyprint">display</code> attribute specified:</caption>
         * &lt;oj-menu-button display='icons'>&lt;/oj-menu-button>
         *
         * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
         * // getter
         * var displayValue = myMenuButton.display;
         *
         * // setter
         * myMenuButton.display = 'icons';
         */

        /**
         * <p>Whether to display both the label and icons (<code class="prettyprint">"all"</code>)
         * or just the label (<code class="prettyprint">"label"</code>)
         * or just the icons (<code class="prettyprint">"icons"</code>).  In the latter case, the label is displayed in a tooltip instead, unless a
         * tooltip was already supplied at create time.
         *
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @ojfragment buttonCommonDisplay
         */
        display: 'all',

        /**
         * <p>Text to show in the button.  The label attribute takes precedence over the default DOM slot.
         *
         * <p>Values set on this option, at create time or later, are treated as plain text, not HTML.  If the label is specified via
         * DOM at create time, that HTML content is kept.
         *
         * <p>For accessibility, a JET Button must always have a label, even if it is <a href="#display">icon-only</a>.
         *
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {?string}
         * @ojtranslatable
         */
        label: null,

        /**
         * <p>Icons to display in the button.  Support is as follows:
         * <ul>
         *   <li>Any combination of start and end icons can be specified, with or without the label (see <code class="prettyprint">display</code> option).</li>
         *   <li>Icons are supported for push buttons created from buttons and anchors, and for toggle buttons (radios and checkboxes).</li>
         *   <li>Icons are not supported for push buttons created from inputs of type button, submit, and reset.</li>
         * </ul>
         *
         * <p>The start icon is displayed before the label text (on the left in LTR), and the end icon is displayed after the
         * label (on the right in LTR).  In RTL, the positions are reversed.
         *
         * <p>The <code class="prettyprint">start</code> and <code class="prettyprint">end</code> properties accept one or more
         * style class names (as seen in the examples), or <code class="prettyprint">null</code>, indicating "no icon."
         *
         * @ignore
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {Object}
         *
         * @example <caption>Initialize the button, specifying both icons:</caption>
         * $( ".selector" ).ojButton({ "icons": { start: "demo-icon-font demo-bookmark-icon-16",
         *                                        end: "demo-icon-font demo-grid-icon-16" } });
         *
         * @example <caption>Get or set the <code class="prettyprint">icons</code> option, after initialization:</caption>
         * // getter
         * var icons = $( ".selector" ).ojButton( "option", "icons" );
         *
         * // setter, specifying both icons:
         * $( ".selector" ).ojButton( "option", "icons", { start: "oj-fwk-icon-caret-start oj-fwk-icon",
         *                                                 end: "demo-icon-font demo-grid-icon-16" } );
         */
        icons: {
          /**
           * <p>The start icon of the button.  See the top-level <code class="prettyprint">icons</code> option for details.
           *
           * @ignore
           * @expose
           * @alias icons.start
           * @memberof! oj.ojButton
           * @instance
           * @type {?string}
           * @default null
           *
           * @example <caption>Get or set the <code class="prettyprint">icons.start</code> sub-option, after initialization:</caption>
           * // getter
           * var startIcon = $( ".selector" ).ojButton( "option", "icons.start" );
           *
           * // setter:
           * $( ".selector" ).ojButton( "option", "icons.start", "oj-fwk-icon-caret-start oj-fwk-icon" );
           */
          start: null,
          /**
           * <p>The end icon of the button.  See the top-level <code class="prettyprint">icons</code> option for details.
           * @ignore
           * @expose
           * @alias icons.end
           * @memberof! oj.ojButton
           * @instance
           * @type {?string}
           *
           * @example <caption>Get or set the <code class="prettyprint">icons.end</code> sub-option, after initialization:</caption>
           * // getter
           * var startIcon = $( ".selector" ).ojButton( "option", "icons.end" );
           *
           * // setter:
           * $( ".selector" ).ojButton( "option", "icons.end", "demo-icon-font demo-grid-icon-16" );
           */
          end: null
        },

        /**
         * <p>Identifies the [JET Menu]{@link oj.ojMenu} that the button should launch. If specified, the button is a menu button.
         *
         * <p>The value can be an HTML element, JQ selector, JQ object, NodeList, or array of elements. In all cases, the first indicated element is used.
         *
         * <p>By default, menu buttons have a downward pointing "dropdown" arrow for their end icon.  See the <code class="prettyprint">icons</code> option for details.
         *
         * <p>See [Menu's]{@link oj.ojMenu} Accessibility section for a discussion of how <code class="prettyprint">aria-label</code> ,
         * <code class="prettyprint">aria-labelledby</code> and <code class="prettyprint">aria-descibedby</code> are handled for menu buttons and other menu launchers.
         *
         * @expose
         * @memberof oj.ojButton
         * @instance
         * @type {Element|Array.<Element>|string|jQuery|NodeList}
         * @default null
         * @ignore
         * @ojtsignore
         * @example <caption>Initialize a menu button:</caption>
         * $( ".selector" ).ojButton({ "menu": "#myMenu" });
         *
         * @example <caption>Get or set the <code class="prettyprint">menu</code> option, after initialization:</caption>
         * // getter
         * var menu = $( ".selector" ).ojButton( "option", "menu" );
         *
         * // setter
         * $( ".selector" ).ojButton( "option", "menu", ".my-marker-class" );
         */
        menu: null,

        // Events
        /**
         * <p>Triggered when a button is clicked. This will be triggered by keyboard events as well as mouse/touch events.
         *
         * <p>To ensure keyboard accessibility, the only correct, supported way to react to the click of a button is to listen
         * for this event. Click listeners should not be used.
         *
         * @expose
         * @event
         * @memberof oj.ojButton
         * @ojshortdesc Triggered when a button is clicked, whether by keyboard, mouse, or touch events.  To meet accessibility requirements, the only supported way to react to the click of a button is to listen for this event.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @ojeventgroup common
         * @since 5.0.0
         */
        action: null
      },

      _InitOptions: function (originalDefaults, constructorOptions) {
        this._super(originalDefaults, constructorOptions);

        // if custom element we are supporting slots
        if (this._IsCustomElement()) {
          this._processSlots();
        }

        this._initButtonTypes(); // init this.type and this.buttonElement, used below

        // At create time, disabled and label can be set via either option or DOM.
        // If app set the option, then that wins over the DOM, in which case _ComponentCreate() will later set that value on the DOM.
        // Else DOM wins, in which case we set the option from the DOM here, with any remaining tasks done later in _ComponentCreate().

        if (!this._IsCustomElement()) {
          if (!('disabled' in constructorOptions)) {
            // if app didn't set option, then set the option from the DOM
            // For anchors, this line always sets disabled option to false.  (Neither JQUI nor JET look for the .oj-disabled class for anchors,
            // so the only way to disable an anchor button at create time is via the API.  At refresh time, JQUI did look
            // for the .oj-disabled class, but our refresh doesn't handle disabled.)
            this.option('disabled', !!this.element[0].disabled, { _context: { internalSet: true } }); // writeback not needed since "not in constructorOptions" means "not bound"
          }
        }

        if (!('label' in constructorOptions)) {
          // if app didn't set option, then set the option from the DOM
          this.keepDomLabel = true;
          this.option(
            'label',
            this.type === 'inputPush' ? this.buttonElement.val() : this.buttonElement[0].innerHTML, // @HTMLUpdateOK getter not setter
            { _context: { internalSet: true } }
          ); // writeback not needed since "not in constructorOptions" means "not bound"
        }

        if (!this._IsCustomElement()) {
          // if this is a menuButton and app didn't set icons.end to its own icon or to null to suppress the icon, then default to built-in menuButton dropdown icon
          if (
            this.options.menu &&
            (!constructorOptions.icons || constructorOptions.icons.end === undefined)
          ) {
            this.option('icons.end', 'oj-component-icon oj-button-menu-dropdown-icon', {
              _context: { writeback: true, internalSet: true }
            });
          }
        }
      },

      _ComponentCreate: function () {
        this._super();

        // facilitate removing menuButton handlers separately, if app sets/clears the "menu" option
        this.menuEventNamespace = this.eventNamespace + 'menu';

        this._initButtonTypes2();
        this.hasTitle = !!this.rootElement.getAttribute('title');

        var self = this;
        var toggleButton = this._isToggle;

        _addClasses(this.rootElement, BASE_CLASSES);
        _setChromingClass(this.rootElement, this.options.chroming);

        // Called for touchend/cancel on both button and document.  Listening only on button isn't completely reliable
        // on at least iOS and Android since the touchend can happen slightly off of the button.  Listening only on the
        // document runs the risk that we won't hear it because someone eats it.  Could use capture listener to dodge
        // that risk, but just listening on both seems to work great.
        var endHandler = function () {
          self.rootElement.classList.remove('oj-active');
          self.rootElement.classList.remove('oj-hover');
          self._toggleDefaultClasses();
        };

        this._touchStartHandler = function () {
          if (self._IsEffectivelyDisabled()) {
            return;
          }

          self.rootElement.classList.add('oj-active');
          self._toggleDefaultClasses();

          // don't pass "touchend touchcancel", due to semantics of one() : it's called once per event type.
          // It's almost always touchend, not touchcancel, that is fired, so the touchend listeners would pile up.
          // The likelihood is very small that the double edge case would occur where both endHandler is needed,
          // AND the touch ends with touchcancel rather than touchend, and the result would only be that the hover
          // style sticks to the button.
          self.document.one('touchend', endHandler);
        };

        if (DomUtils.isTouchSupported()) {
          this.buttonElement[0].addEventListener('touchstart', this._touchStartHandler, {
            passive: true
          });
          this.buttonElement.bind(
            'touchend' + this.eventNamespace + ' touchcancel' + this.eventNamespace,
            endHandler
          );
        }

        this.buttonElement
          .bind('mouseenter' + this.eventNamespace, function () {
            if (self._IsEffectivelyDisabled()) {
              return;
            }
            if (!self._isSelectedInButtonsetOne()) {
              self.rootElement.classList.add('oj-hover');
              // do this for real mouse enters, but not 300ms after a tap
              if (!DomUtils.recentTouchEnd()) {
                if (this === _lastActive) {
                  self.rootElement.classList.add('oj-active');
                }
              }
              self.rootElement.classList.remove('oj-default');
              self.rootElement.classList.remove('oj-focus-only');
            }
          })
          .bind('mouseleave' + this.eventNamespace, function () {
            self.rootElement.classList.remove('oj-hover');

            if (self._IsEffectivelyDisabled()) {
              return;
            }
            self.rootElement.classList.remove('oj-active');
            self._toggleDefaultClasses();
          });

        this._disabledClickHandler = function (event) {
          if (self._IsEffectivelyDisabled()) {
            event.preventDefault();
            event.stopImmediatePropagation();
          }
        };

        this._ojActionClickHandler = function (event) {
          self._trigger('action', event, {});
        };

        // Must do this in capture phase to avoid race condition where app's click
        // handlers on anchor buttons can be called if their listeners get registered
        // before ours, e.g. if their KO click binding is before the ojComponent binding.
        if (this._IsCustomElement()) {
          this.rootElement.addEventListener('click', this._disabledClickHandler, true);
          this.rootElement.addEventListener('click', this._ojActionClickHandler, false);
        } else {
          this.buttonElement[0].addEventListener('click', this._disabledClickHandler, true);
        }

        this._focusable({
          element: $(this.rootElement),
          applyHighlight: true,
          afterToggle: function () {
            self._toggleDefaultClasses();
          }
        });

        if (toggleButton) {
          this.element.bind('change' + this.eventNamespace, function (event) {
            self._applyCheckedStateFromDom(true); // we just get one change event for entire radio group, even though up to 2 changed, so must refresh entire radio group, not just this button

            // if in a buttonset that tracks checked state (i.e. checkbox set or single
            // radio group), then set that option and fire optionChange event
            var buttonset = self._getEnclosingContainerComponent('buttonset');
            var checkedState = buttonset && buttonset._getCheckedFromDom(buttonset.$buttons);
            if (buttonset && checkedState !== undefined) {
              buttonset.option('checked', checkedState, {
                _context: { writeback: true, originalEvent: event, internalSet: true }
              });
            }
          });

          // Required for FF, where click-drag on checkbox/radio btn's label(JET decorates label as button for toggle buttons )
          // will not yield in to click event and also trasfers focus out of the <input> element and hence breaks arrow navigation.
          // To fix, If mouse moves between mouseDown/mouseUp (drag) with in the boundaries of button then focus should be set
          // on the button which will ensure proper arrow key navigation(see  for more details).
          this.buttonElement
            .bind('mousedown' + this.eventNamespace, function () {
              if (self._IsEffectivelyDisabled()) {
                return;
              }
              _lastToggleActive = this;
              if (!self._isSelectedInButtonsetOne()) {
                self.rootElement.classList.add('oj-active');
              }
              self.document.one('mouseup', function () {
                _lastToggleActive = null;
                self.rootElement.classList.remove('oj-active');
              });
            })
            .bind('mouseup' + this.eventNamespace, function () {
              if (self._IsEffectivelyDisabled()) {
                return;
              }
              self.rootElement.classList.remove('oj-active');
              if (this === _lastToggleActive) {
                self.element.focus();
              }
            });
        }

        if (this.type === 'checkbox') {
          this.buttonElement.bind('click' + this.eventNamespace, function () {
            if (self._IsEffectivelyDisabled()) {
              return false;
            }
            return undefined;
          });

          // role="button" requires both Space and Enter support, but radios and checkboxes natively support only Space, so add Enter.
          // Update: now that we're not using role=button for checkboxes, we don't strictly need this.
          // This fire-click-on-Enter logic gives Enter the same behavior as Space for checkboxes in Chrome, FF, and IE9:
          // In Chrome28 and IE9, for Space and Enter on Checkboxes, first the "checked" value updates, then change event, then click event.
          // In FF22, for Space and Enter on Checkboxes, first the "checked" value updates, then click event, then change event.
          // Unlike the radio Enter handler, we get this good behavior by only firing "click".
          this.element.bind('keyup' + this.eventNamespace, function (event) {
            if (event.keyCode === $.ui.keyCode.ENTER) {
              if (!self._IsEffectivelyDisabled()) {
                // console.log("checkbox Enter handler firing click event");
                self.element.click();
              }
            }
          });
        } else if (this.type === 'radio') {
          this.buttonElement.bind('click' + this.eventNamespace, function () {
            if (self._IsEffectivelyDisabled()) {
              return false;
            }
            return undefined;
          });

          // role="button" requires both Space and Enter support, but radios and checkboxes natively support only Space, so add Enter.
          // Update: now that we're not using role=button for radios, we don't strictly need this.
          // For radios, this handler gives Enter in Chrome28/ IE9/ FF22 the same behavior as Space on Chrome.  Since Space in IE/FF is
          // different than Space in Chrome, this means that Enter and Space are not quite the same within those browsers.
          // For Space and Enter on unchecked radios in Chrome28 and IE9:
          //   - first the "Checked" value updates, then change event, then click event.
          // For already-checked radios, where activation would just check it again:
          //   - Space and Enter in Chrome28, and Enter in IE9:  do nothing.
          //   - Space in IE9:  first the "Checked" value updates, then click event.  (No change event since nothing changed.)
          //     (This is the only Chrome/IE9 Space/Enter difference.)
          // In FF22:
          //   - Space on unchecked radios: first the "Checked" value updates, then click event, then change event.
          //   - Enter on unchecked radios is same as Chrome.  (Different event ordering than FF.)
          //   - Space on checked radios is like IE9: first the "Checked" value updates, then click event.  (No change event since nothing changed.)
          //   - Enter on checked radios is same as Chrome.  (Do-nothing.)
          this.element.bind('keyup' + this.eventNamespace, function (event) {
            if (event.keyCode === $.ui.keyCode.ENTER) {
              if (!self.element[0].checked && !self._IsEffectivelyDisabled()) {
                // console.log("radio Enter handler found radio unchecked, so checking it and firing click event");

                // Unlike the checkbox Enter handler, we set checked=true and fire changed before firing click, without which
                // we didn't get the exact behavior described above.  Without setting checked, the click handlers in all 3 desktop
                // browsers saw the "old" "checked" value when Enter was pressed on radios, which broke Buttonset's focus mgmt logic.
                // If we set checked, then change no longer fires automatically, in at least some browsers, so we have to fire it
                // manually, both for apps that rely on it, and because our code relies on our change listener to update the "checked" styling.
                self.element[0].checked = true;
                self.element.change();
                self.element.click();
              }
            }
          });
        } else {
          // neither checkbox nor radio, so not a toggle button, so element, buttonElement (and rootElement in JQUI) are all the same node
          this.buttonElement
            .bind('mousedown' + this.eventNamespace, function (event) {
              if (self._IsEffectivelyDisabled()) {
                return false;
              }

              // don't show active/pressed-down state unless left mouse button, since only that button will click the button after mouseup
              // do this for real mousedowns, but not 300ms after a tap
              if (event.which === 1 && !DomUtils.recentTouchEnd()) {
                if (!self._isSelectedInButtonsetOne()) {
                  self.rootElement.classList.add('oj-active');
                }
                self.rootElement.classList.remove('oj-default');
                self.rootElement.classList.remove('oj-focus-only');
                _lastActive = this;
                self.document.one('mouseup', function () {
                  // TODO: prob need capture listener like Menu for reliability
                  _lastActive = null;
                });
              }

              return undefined;
            })
            .bind('mouseup' + this.eventNamespace, function () {
              if (self._IsEffectivelyDisabled()) {
                return false;
              }
              self.rootElement.classList.remove('oj-active');
              self._toggleDefaultClasses();
              return undefined;
            })
            .bind('keydown' + this.eventNamespace, function (event) {
              if (self._IsEffectivelyDisabled()) {
                // ...then bail out always, also eating event unless key is Tab or left/right arrow, since:
                // - Must allow Tab so KB user can't get stuck here.
                // - Nice to allow Buttonset/Toolbar's left/right arrow handling too, but not strictly essential as long as user
                //   can Tab out and back in, since (if app refreshed Buttonset/Toolbar after disabling button as required), the
                //   tab-back-in will go to an enabled button of the Buttonset/Toolbar, or skip Buttonset/Toolbar if all buttons disabled.
                // - Must eat Enter/Space/DownArrow to prevent that functionality from occurring. (For non-anchor buttons, the native
                //   disabled status prevents some of those on at least some platforms.)
                // Since anchor buttons don't have a native disabled status, they remain focusable when disabled, and thus are most
                // susceptible to having key events while disabled. (We ensure they are not tabbable, but they remain focusable)
                return (
                  event.keyCode === $.ui.keyCode.TAB ||
                  event.keyCode === $.ui.keyCode.LEFT ||
                  event.keyCode === $.ui.keyCode.RIGHT
                );
              }

              var isSpace = event.keyCode === $.ui.keyCode.SPACE;
              var isAnchor = self.type === 'anchor';

              // now that anchor doesn't support Space, still keep this line, in case users try to click via Space
              if (isAnchor && isSpace) {
                event.preventDefault(); // prevent scrolling down one page when clicking anchor button via Spacebar.  Only prevent for anchor!
              }
              if ((isSpace && !isAnchor) || event.keyCode === $.ui.keyCode.ENTER) {
                if (!self._isSelectedInButtonsetOne()) {
                  self.rootElement.classList.add('oj-active');
                }
                self.rootElement.classList.remove('oj-default');
                self.rootElement.classList.remove('oj-focus-only');
              }
              return undefined;
            })
            // see #8559, we bind to blur here in case the button element loses
            // focus between keydown and keyup, it would be left in an "active" state
            .bind('keyup' + this.eventNamespace + ' blur' + this.eventNamespace, function () {
              self.rootElement.classList.remove('oj-active');
              self._toggleDefaultClasses();
            });

          if (this.type === 'anchor') {
            // Chrome is not updating document.activeElement on click of <a> which is needed for ojPopup and
            // setting tabIndex to a non-negative value will fix this. Refer 
            // isNaN(..) returns true when tabIndex is undefined (or 'undefined', which the original impl checked for...)
            var tabIndex = this.buttonElement[0].getAttribute('tabindex');
            if (tabIndex === null || isNaN(tabIndex)) {
              // Don't override if user already set a tabIndex.
              this.buttonElement[0].setAttribute('tabindex', '0');
            }
          }
        } // end of: if (checkbox) {} else if (radio) {} else {}

        // at create time, we want only the "if disabled" part of callee, not the "if enabled" part, so only call if disabled
        if (this.options.disabled) {
          this._manageAnchorTabIndex(false, true);
        }

        this._updateEffectivelyDisabled();

        var buttonset = self._getEnclosingContainerComponent('buttonset');
        if (this._IsCustomElement() || (buttonset && buttonset._IsCustomElement())) {
          this._setDisplayOptionOnDom();
        } else {
          this._handleLabelAndIconsAtCreateTime();
        }

        this._setupMenuButton(null);

        // call this at the *end* of _ComponentCreate, since it needs to know whether any state classes like oj-active, oj-disabled, oj-selected, oj-hover, .oj-focus
        // have been applied.
        this._toggleDefaultClasses();

        // _childMutationObserver would have been created in _setDisplayOptionOnDom if one is needed
        if (this._childMutationObserver) {
          // Start observing the button element for changes to children
          this._childMutationObserver.observe();
        }
      },

      _NotifyContextMenuGesture: function (menu, event, eventType) {
        // For toggle buttons, launcher must be the hidden focusable input, but for Shift-F10 we want the CM aligned to the root element, not that
        // launcher.  rootElement works for push buttons too.
        this._OpenContextMenu(event, eventType, {
          position: { of: eventType === 'keyboard' ? $(this.rootElement) : event }
        });
      },

      _addMutationObserver: function () {
        // No need to create it again if we already have one
        if (this._childMutationObserver || !this._IsCustomElement()) {
          return;
        }

        var self = this;
        this._childMutationObserver = new ChildMutationObserver(this.rootElement, function (
          mutations
        ) {
          mutations.forEach(function (mutation) {
            var doUpdate;

            if (mutation.type === 'childList') {
              var node = mutation.addedNodes && mutation.addedNodes[0];
              var target = mutation.target;
              if (
                node &&
                node.nodeType === 3 &&
                target &&
                target.nodeType === 1 &&
                target.classList.contains('oj-button-label')
              ) {
                // Handle the case where there is no span around the text binding in the source HTML.
                // In this case the ko comment nodes stay in the oj-button-label div, but the resulting
                // text node is moved down to the oj-button-text span. When the binding is updated, we need
                // to replace oj-button-text content with the new text node to avoid it being shown.
                self._childMutationObserver.disconnect();
                doUpdate = true;

                var buttonTextElem = self.buttonElement[0].querySelector('.oj-button-text');
                if (buttonTextElem) {
                  buttonTextElem.textContent = node.textContent;
                }
                node.parentNode.removeChild(node);
              }
            } else if (mutation.type === 'characterData') {
              // Handle the case where there is a span around the text binding in the source HTML.
              // In this case the comment nodes and resulting text node are both moved down to the
              // oj-button-text span. When the binding is updated, it will update the oj-button-text
              // content directly.
              self._childMutationObserver.disconnect();
              doUpdate = true;
            }

            if (doUpdate) {
              // _setDisplayOptionOnDom will update the oj-button title attribute to new text content
              // if necessary.
              self._setDisplayOptionOnDom();

              self._childMutationObserver.observe();
            }
          });
        });
      },

      _removeMutationObserver: function () {
        if (this._childMutationObserver) {
          this._childMutationObserver.disconnect();
          this._childMutationObserver = null;
        }
      },

      _processSlots: function () {
        var self = this;
        var elem = this.element[0];
        var rootElem = elem.parentNode;
        var isMenuButton = rootElem.tagName === 'OJ-MENU-BUTTON';

        // we are responsible for reparenting any slots because of use of inner elem
        var rootSlots = ojcustomelementUtils.CustomElementUtils.getSlotMap(rootElem);

        // don't add context menu here since we do not ever need to move it
        var supportedSlots;
        if (isMenuButton) {
          supportedSlots = ['startIcon', '', 'endIcon', 'menu'];
        } else {
          supportedSlots = ['startIcon', '', 'endIcon'];
        }

        // move all desired slots down one level
        $.each(supportedSlots, function (i, slotName) {
          if (rootSlots[slotName] && slotName !== '') {
            $.each(rootSlots[slotName], function (_i, node) {
              elem.appendChild(node);
            });
          }
        });

        // be sure to not remove the context menu slot
        var children = rootElem.children;
        for (var len = children.length, idx = len - 1; idx >= 0; idx--) {
          var child = children[idx];
          if (child !== elem && child.getAttribute('slot') !== 'contextMenu') {
            rootElem.removeChild(child);
          }
        }

        // all slots are now within the inner button element
        var slots = ojcustomelementUtils.CustomElementUtils.getSlotMap(elem);

        // rearrange slots
        $.each(supportedSlots, function (i, slotName) {
          if (slots[slotName]) {
            $.each(slots[slotName], function (_i, node) {
              elem.appendChild(node);
              if (slotName === '') {
                var currentText = node;
                var wrapperSpan = currentText;
                if (currentText.nodeType === 3) {
                  wrapperSpan = document.createElement('span');
                  currentText.parentNode.insertBefore(wrapperSpan, currentText); // @HTMLUpdateOK
                  wrapperSpan.appendChild(currentText);
                }
                wrapperSpan.classList.add('oj-button-text');
                self._setTextSpanIdAndLabelledBy(wrapperSpan);
              } else if (slotName === 'startIcon') {
                node.classList.add('oj-button-icon');
                node.classList.add('oj-start');
              } else if (slotName === 'endIcon') {
                node.classList.add('oj-button-icon');
                node.classList.add('oj-end');
              } else if (slotName === 'menu') {
                $(node).uniqueId();
                self.menuSlot = '#' + node.id;
                if (slots.endIcon === undefined) {
                  var dropDownElem = document.createElement('span');
                  var dropdownIconClass = 'oj-button-menu-dropdown-icon';
                  if (slots.startIcon === undefined && self.options.display === 'icons') {
                    dropdownIconClass = 'oj-button-menu-icon-only-dropdown-icon';
                  }
                  dropDownElem.className =
                    'oj-button-icon oj-end oj-component-icon ' + dropdownIconClass;
                  dropDownElem.setAttribute('slot', 'endIcon');
                  elem.insertBefore(dropDownElem, node); // @HTMLUpdateOK
                }
              }
            });
          }
        });

        // wrap button content in a label for consistent DOM/theming structure
        var wrapperDiv = document.createElement('div');
        wrapperDiv.className = 'oj-button-label';
        while (elem.hasChildNodes()) {
          wrapperDiv.appendChild(elem.firstChild); // @HTMLUpdateOK
        }
        elem.appendChild(wrapperDiv); // @HTMLUpdateOK
      },

      // Helper function to return the correct menu reference between custom element and non custom element components.
      _getMenuNode: function () {
        // Private, not an override (not in base class). Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._IsCustomElement()) {
          return this.menuSlot;
        }
        return this.options.menu;
      },

      // Part 1 of type-specific component init.  Called from _InitOptions, so very limited component state is available!
      _initButtonTypes: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // for toggle buttons (radio/checkbox), element is <input>, buttonElement is <label>,
        // and rootElement is a new wrapper element we create.  This is true in JQUI; in CustomElements not exposing toggle buttons.
        var elem = this.element[0];
        if (elem.tagName === 'INPUT' && elem.type === 'checkbox') {
          this.type = 'checkbox';
          this._isToggle = true;
        } else if (elem.tagName === 'INPUT' && elem.type === 'radio') {
          this.type = 'radio';
          this._isToggle = true;
        } else if (
          elem.tagName === 'INPUT' &&
          (elem.type === 'button' || elem.type === 'submit' || elem.type === 'reset')
        ) {
          // for push buttons (next 3 cases), element, buttonElement, and rootElement are all the same elem in JQUI.
          // In CustomElements, element and buttonElement are the same elem, and rootElement is the parent custom element.
          // We ignore <label> if present.
          this.type = 'inputPush';
        } else if (elem.tagName === 'BUTTON') {
          this.type = 'button';
        } else if (elem.tagName === 'A') {
          this.type = 'anchor';
        } else {
          throw new Error('JET Button not supported on this element type');
        }

        if (this._isToggle) {
          // TBD: rather than requiring the label to be supplied, should we just create one for them if it's not there?
          var labelSelector = "label[for='" + this.element[0].getAttribute('id') + "']";
          this.buttonElement = this.element.siblings().filter(labelSelector);
        } else {
          this.buttonElement = this.element;
        }
      },

      // Part 2 of type-specific component init, called from _ComponentCreate().
      _initButtonTypes2: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var elem = this.element[0];
        if (this._isToggle) {
          this.buttonElement[0].classList.add('oj-button-label');

          elem.classList.add('oj-button-input');
          elem.classList.add('oj-helper-hidden-accessible');
          elem.setAttribute('data-oj-internal', ''); // automation support
          var spanElem = document.createElement('span');
          this.element[0].parentNode.insertBefore(spanElem, this.buttonElement[0]); // @HTMLUpdateOK
          spanElem.appendChild(this.buttonElement[0]); // add root node around label/input.  @HTMLUpdateOK trusted string
          spanElem.appendChild(this.element[0]); // add root node around label/input.  @HTMLUpdateOK trusted string

          this.rootElement = this.element[0].parentNode; // the new root
          this.rootElement.classList.add('oj-button-toggle');

          var checked = elem.checked;
          if (checked) {
            this.rootElement.classList.add('oj-selected');
            this.rootElement.classList.remove('oj-default');
            this.rootElement.classList.remove('oj-focus-only');
          }
          // else no need to removeClass since this code runs only at create time
        } else if (this._IsCustomElement()) {
          this.rootElement = this.element[0].parentNode;
          elem.classList.add('oj-button-button');
        } else {
          this.rootElement = this.element[0];
          // oj-button-jqui was renamed to oj-button-toggle
          // we still need this styling for jqueryui ojButton. For example,
          // oj-input-number creates ojButtonset and ojButtons widgets internally.
          if (!this._IsCustomElement()) {
            elem.classList.add('oj-button-toggle');
          }
        }
      },

      /**
       * Returns a <code class="prettyprint">jQuery</code> object containing the root element of the Button component.
       * @ignore
       * @expose
       * @memberof oj.ojButton
       * @instance
       * @return {jQuery} the root element of the component
       *
       * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
       * var widget = $( ".selector" ).ojButton( "widget" );
       */
      widget: function () {
        // Override of public base class method.  Method name needn't be quoted since is in externs.js.
        return $(this.rootElement);
      },

      _destroy: function () {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this._removeMenuBehavior(this._getMenuNode());
        this.buttonElement[0].removeEventListener('click', this._disabledClickHandler, true);
        this.buttonElement[0].removeEventListener('click', this._ojActionClickHandler, false);

        this.buttonElement[0].removeEventListener('touchstart', this._touchStartHandler, {
          passive: true
        });
        delete this._touchStartHandler;

        // TBD: won't need this after the restore-attrs feature is in place.
        var elem = this.element[0];
        elem.classList.remove('oj-helper-hidden-accessible');
        elem.removeAttribute('aria-labelledby');
        elem.removeAttribute('aria-describedby');
        this.element.removeUniqueId();

        // If disabled, we want to run the "changing from disabled to enabled" part of callee, to restore original tabindex.
        // If enabled, don't want to run any part of callee.
        if (this.options.disabled) {
          this._manageAnchorTabIndex(true, false);
        }

        var isToggle = this._isToggle;

        // TBD: won't need this after the restore-attrs feature is in place.
        if (!isToggle) {
          _removeClasses(
            this.rootElement,
            BASE_CLASSES +
              ' oj-button-toggle ' +
              STATE_CLASSES +
              ' ' +
              TYPE_CLASSES +
              ' ' +
              CHROMING_CLASSES
          );
        }

        var buttonText = this.buttonElement[0].querySelector('.oj-button-text');
        if (buttonText) {
          this.buttonElement[0].innerHTML = buttonText.innerHTML; // @HTMLUpdateOK reparent existing DOM
        }

        if (!isToggle) {
          // TBD: won't need this after the restore-attrs feature is in place.
          if (!this.hasTitle) {
            this.rootElement.removeAttribute('title');
          }
        } else {
          this.buttonElement[0].classList.remove('oj-button-label'); // TBD: won't need this after the restore-attrs feature is in place.

          // : If the button is stamped out by a KO foreach (with or without a containing buttonset), and the foreach
          // observable is updated to no longer include the button, then _destroy() is called.  Due to the ordering of tasks, if
          // JQ's unwrap() is called directly, the nodes winds up back into the DOM.  To avoid this, we previously successfully
          // put the JQ unwrap() call in a setTimeout(0), and now we do the following:
          //
          //  - DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout
          DomUtils.unwrap(this.element);
        }

        if (_lastToggleActive === this.buttonElement[0]) {
          _lastToggleActive = null; // clear _lastToggleActive flag, while destroying the button.
        }

        //  - blur event needs to be explicitly removed
        this.buttonElement.off('blur');

        this._removeMutationObserver();
      },

      _NotifyDetached: function () {
        // In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content,
        // so when the component is detached from the document, we must use this hook to remove the oj-focus, oj-focus-highlight, oj-hover, and oj-active classes, to
        // ensure that button is displayed without those classes when it is re-attached to the DOM. Refer .
        // _super() now removes those 3 classes, so just need to call _tDC() afterwards.
        this._super();
        this._toggleDefaultClasses();
      },

      __setAncestorComponentDisabled: function (disabled) {
        this._super(disabled); // sets this._ancestorDisabled
        this._updateEffectivelyDisabled();
      },

      // Prereq:  this.options.disabled and this._ancestorDisabled must already be set to their updated values before calling this method.
      //
      // When called by __setAncestorComponentDisabled(), it has already set this._ancestorDisabled.
      //
      // When called by _setOption("disabled"), its _super() has already done the following things:
      // - Set this.options.disabled.
      // - Applied .oj-disabled and aria-disabled to rootElement, often incorrectly per comments below.  The below code fixes it up.  The _super() code has tbd to fix this.
      // - If option is being set to true, it's removed .oj-hover/focus/focus-highlight/active.  (See comment below.)
      _updateEffectivelyDisabled: function () {
        var elem = this.element[0];
        var effectivelyDisabled = this._IsEffectivelyDisabled();

        // Unlike JQUI, root element should have exactly one of .oj-enabled and .oj-disabled at any point in time, for all flavors of Button.
        // _setOption._super() sets .oj-disabled to potentially wrong value since it doesn't know about "effectively disabled".  This fixes it up.
        if (effectivelyDisabled) {
          this.rootElement.classList.add('oj-disabled');
          this.rootElement.classList.remove('oj-enabled'); // _setOption._super() doesn't try to set this
        } else {
          this.rootElement.classList.remove('oj-disabled');
          this.rootElement.classList.add('oj-enabled'); // _setOption._super() doesn't try to set this
        }

        if (this.type !== 'anchor') {
          // i.e. <button> or <input> (including type=radio|checkbox|other)
          // <button> and <input> (including type=radio|checkbox|other) have this property, but <a> doesn't
          elem.disabled = effectivelyDisabled; // JQUI's _setOption sets this for <a>'s too, which seems harmless but is incorrect.

          // _setOption._super() puts aria-disabled on the rootElement.  Per A11y team, don't put aria-disabled on element already having disabled
          // attr.  (And if we DID apply aria-disabled, for radios/checkboxes it should go on the element / input, not the buttonElement / label or rootElement,
          // so the _setOption._super() behavior used by JQUI button is doubly wrong.)  Further, _setOption._super() can set it wrong since it doesn't know
          // about "effectively disabled".  This fixes it up.
          this.rootElement.removeAttribute('aria-disabled');
        } else {
          // else is <a>
          // _setOption._super() puts aria-disabled on the rootElement. For <a>'s, element and rootElement are both the <a> in JQUI,
          // but are different in CustomElements.  aria-disabled belongs on element.  Also, the value it sets is potentially wrong since it
          // doesn't know about "effectively disabled".
          elem.setAttribute('aria-disabled', effectivelyDisabled); // set element attr to correct value in both JQUI and Custom Elements.
          if (this._IsCustomElement()) this.rootElement.removeAttribute('aria-disabled');
        }

        if (effectivelyDisabled) {
          // TBD: when the handling of oj-active in baseComponent._setOption("disabled") is finalized, review whether this should be handled there instead.
          // baseComponent._setOption("disabled") removes oj-active, oj-hover, oj-focus, and oj-focus-highlight, but _updateEffectivelyDisabled is called in a number of other
          // cases too, so do it here too to be safe.
          var classList = this.widget()[0].classList;
          classList.remove('oj-active');
          classList.remove('oj-default');
          classList.remove('oj-focus-only');
          classList.remove('oj-hover');
          classList.remove('oj-focus');
          classList.remove('oj-focus-highlight');
          _lastActive = null; // avoid (very slight) possibility that first mouseIn after button is subsequently re-enabled will set oj-active

          // when disabling a menu button, dismiss the menu if open
          this._dismissMenu(this._getMenuNode());
        } else {
          this._toggleDefaultClasses();
        }
      },

      _setOption: function (key, value, flags) {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        var oldValue = this.options[key];
        this._super(key, value, flags);
        // TBD: Currently the below code relies on super already having been called.  Consider removing that dependency
        // and calling super at end instead, so that optionChange (fired at end of super) is fired at very end.

        switch (key) {
          case 'chroming':
            _setChromingClass(this.rootElement, value);
            break;
          case 'disabled':
            // call this from _setOption, not _updateEffectivelyDisabled, as discussed in callee
            this._manageAnchorTabIndex(oldValue, value);

            // must call this *after* _super(), as discussed in callee
            this._updateEffectivelyDisabled();

            // Legacy code for widgets.  Toolbar custom element will listen for property change event on buttons.
            if (!this._IsCustomElement()) {
              // If this button is inside a toolbar, the toolbar needs to be refreshed for new disabled setting
              var $toolbarElem = this._getEnclosingContainerElement('toolbar');
              if ($toolbarElem.length) {
                $toolbarElem.ojToolbar('refresh');
              }
            }
            break;
          case 'label':
            this._setLabelOption();
            break;
          case 'display':
            if (this.type !== 'inputPush') {
              // <input type=button|submit|reset> doesn't support child nodes, thus no icons, icon-only buttons, etc.
              this._setDisplayOptionOnDom();
            }
            break;
          case 'icons':
            this._setIconsOption(true);
            break;
          case 'menu': // setting/clearing the menu sets whether this is a menuButton
            this._setupMenuButton(oldValue);
            break;
          default:
            break;
        }
      },

      // @inheritdoc
      refresh: function () {
        // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
        this._super();

        // TODO:
        // - JSDoc says to call refresh() when Button reparented.  Instead, app should call oj.Components.subtreeAttached(), and our
        //   _NotifyAttached override should do the handling.
        // - There are other things we should do in the "no longer in buttonset" case, like removing buttonset listeners.  Anything else too?
        // - The reason the jsdoc doesn't mention the "moved into Buttonset (possibly from another buttonset)" case is that in that case
        //   Bset.refresh() must be called.  However, not sure that it's doing all the necessary things for the "from another Bset" case.

        // Handle the rare case where we just got reparented out of a disabled Buttonset
        if (this._ancestorDisabled && !this._getEnclosingContainerElement('buttonset').length) {
          this.__setAncestorComponentDisabled(false);
        }

        // re-fetch the chroming option, so that if it's still set to the default dynamic getter, which takes its value from the containing
        // buttonset or toolbar if present, refresh() will update the visible chroming.  This is needed for cases like the following, all of
        // which call button.refresh() :
        // - The button previously wasn't in a buttonset or toolbar, but now is, or vice versa.  This is common at init time, when the bset/
        //   toolbar is created after their buttons, in which case the bset/toolbar refreshes their buttons.  Can also happen due to reparenting
        //   the button into or out of the bset/toolbar. "into": app must refresh bset/toolbar, which refreshes their buttons.  "out of": app
        //   must refresh the button.
        // - The app sets the chroming option of the containing buttonset or toolbar, which refreshes their buttons.
        // Do this after the _super() call, which updates the list of containers (buttonset/toolbar) that the component is in.
        _setChromingClass(this.rootElement, this.options.chroming);
      },

      // If this button is radio/checkbox, then this method gets the checked state from DOM's
      // "checked" prop and toggles oj-selected accordingly.
      // If wholeGroup param is true, and this button is a radio, then do that for all buttons in the group.
      _applyCheckedStateFromDom: function (wholeGroup) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.type === 'radio') {
          (wholeGroup ? _radioGroup(this.element[0]) : this.element).each(function () {
            var $radioWidget = $(this).data('oj-ojButton'); // definitely exists because _radioGroup() checks for :oj-button

            if (this.checked) {
              $radioWidget.rootElement.classList.add('oj-selected');
              $radioWidget.rootElement.classList.remove('oj-default');
              $radioWidget.rootElement.classList.remove('oj-focus-only');
            } else {
              $radioWidget.rootElement.classList.remove('oj-selected');
              $radioWidget._toggleDefaultClasses();
            }
          });
        } else if (this.type === 'checkbox') {
          if (this.element[0].checked) {
            this.rootElement.classList.add('oj-selected');
            this.rootElement.classList.remove('oj-default');
            this.rootElement.classList.remove('oj-focus-only');
          } else {
            this.rootElement.classList.remove('oj-selected');
            this._toggleDefaultClasses();
          }
        }
      },

      /*
       * Method name sums it up.  Should only be called at create time.
       */
      _handleLabelAndIconsAtCreateTime: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.type === 'inputPush') {
          // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
          this._setLabelOnDomOfSpanlessButton();
        } else {
          // <button>, <a>, checkboxes, and radios
          var textSpan = this._setLabelOnDomAtCreateTime();
          var hasStartIcon = this._setIconOnDom(true);
          var hasEndIcon = this._setIconOnDom(false);

          this._setDisplayOptionOnDom(textSpan, hasStartIcon, hasEndIcon);
        }
      },

      /*
       * Replace the button contents with a span containing the label:
       * - If app didn't set the label option, then reparent their DOM label to the new span.
       * - If app set the label option, then set escaped version onto label span.
       * Either way, button contents are completely replaced with the new span.
       *
       * Should only be called at create time.
       *
       * return the new textSpan
       */
      _setLabelOnDomAtCreateTime: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var buttonElement = this.buttonElement[0];
        var textSpan = document.createElement('span');
        textSpan.className = 'oj-button-text';

        if (this.keepDomLabel) {
          while (buttonElement.hasChildNodes()) {
            textSpan.appendChild(buttonElement.firstChild); // @HTMLUpdateOK reparent existing DOM
          }
        } else {
          buttonElement.innerHTML = ''; // @HTMLUpdateOK
          textSpan.textContent = this.options.label;
        }

        // Due to FF bug (see Bugzilla's ), <button> with flex/inline-flex display doesn't work. Workaround by wrapping <button> contents with a <div> and setting the latter display flex/inline-flex
        if (this.type === 'button') {
          var contentContainer = document.createElement('div');
          contentContainer.className = 'oj-button-label';
          contentContainer.appendChild(textSpan); // @HTMLUpdateOK append span containing trusted content and existing DOM, per above comments on lines referencing textSpan.
          this.element[0].appendChild(contentContainer); // @HTMLUpdateOK attach detached wrapped DOM created from trusted string and existing DOM
        } else {
          buttonElement.appendChild(textSpan); // @HTMLUpdateOK attach detached DOM created from trusted string and existing DOM
        }

        // Need to set "aria-labelledby" attribute of (button/anchor) element to point to label span as fix for  (accessibility: icon-only button label is read twice by screen reader)
        // This is only a problem for <button> and <a> at the time of writing, so the fix is only applied to these two button types.
        if (
          (this.type === 'button' || this.type === 'anchor') &&
          !this.element[0].hasAttribute('aria-label') &&
          !this.element[0].hasAttribute('aria-labelledby')
        ) {
          this._setTextSpanIdAndLabelledBy(textSpan);
        }
        return $(textSpan);
      },

      _setTextSpanIdAndLabelledBy: function (textSpan) {
        $(textSpan).uniqueId(); // assign id so that this.element can have "aria-labelledby" attribute pointing to the textspan
        if (
          !this.element[0].hasAttribute('aria-label') &&
          !this.element[0].hasAttribute('aria-labelledby')
        ) {
          this.element[0].setAttribute('aria-labelledby', textSpan.getAttribute('id'));
        }
      },

      /*
       * Following is an old TBD from before the refactoring.  Now that we've sharply reduced the amount of unnecessary DOM replacement when
       * options like label and icons are set, is this still an issue?  If so, can we further minimize the churn to fix it?
       * TBD: Per http://www.quirksmode.org/blog/archives/2007/01/a_note_about_ev.html, if a click handler blows away the thing that was
       * clicked, it stops the click event from bubbling any further.  For antonym buttons like Play/Pause where the app puts a click handler
       * on the button that toggles its label and/or icons, this method replaces the clicked element, e.g. a <span> inside the <button>,
       * stopping the bubble. [UPDATE: we keep the span now but change its contents.  Does that fix it?].  This makes bubbling brittle.
       * Consider improving and/or doc'ing the issue.
       */

      /*
       * This method takes care of everything that needs to happen when the "label" option is set *after* create time.
       */
      _setLabelOption: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.type === 'inputPush') {
          // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
          this._setLabelOnDomOfSpanlessButton();
        } else {
          var textSpan = this.buttonElement[0].querySelector('.oj-button-text');
          textSpan.textContent = this.options.label;
          this._setDisplayOptionOnDom($(textSpan));
        }
      },

      /*
       * This method should only be called when the button is a "spanless" button, i.e. <input type=button|submit|reset>. It is called when the label is set,
       * both at create time and when it is set later.
       */
      _setLabelOnDomOfSpanlessButton: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // TBD: The "if label" check is from JQUI.  Is there some reason that setting "" should be ignored?
        // Probably not too harmful since they should set "display" option to "icons" instead, or set " " if they really want to.
        if (this.options.label) {
          this.element.val(this.options.label); // escaping is automatic; e.g. if label is <span>foo</span>, then val() sets that literal string on the input's "value" attr.
        }
      },

      _setIconsOption: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.type === 'inputPush') {
          // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
          return;
        }

        var hasStartIcon = this._setIconOnDom(true);
        var hasEndIcon = this._setIconOnDom(false);
        this._setDisplayOptionOnDom(undefined, hasStartIcon, hasEndIcon);
      },

      /*
       * This method sets either the start or end icon on the DOM, depending on the param, adding or removing the
       * icon span as needed.  It is called both at create time and when the icon changes later.
       *
       * param isStart boolean, whether is start or end icon
       * return boolean indicating whether an icon was set on DOM
       */
      _setIconOnDom: function (isStart) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var contentContainer = this.buttonElement[0];
        if (this.type === 'button') {
          contentContainer = this.element.children('div.oj-button-label')[0];
        }

        var iconSpanSelector;
        var standardIconClasses;
        var appIconClass;
        var lastIvar;
        if (isStart) {
          iconSpanSelector = '.oj-button-icon.oj-start';
          standardIconClasses = 'oj-button-icon oj-start';
          appIconClass = this.options.icons.start;
          lastIvar = '_lastStartIcon';
        } else {
          iconSpanSelector = '.oj-button-icon.oj-end';
          standardIconClasses = 'oj-button-icon oj-end';
          appIconClass = this.options.icons.end;
          lastIvar = '_lastEndIcon';
        }

        var iconSpan = contentContainer.querySelectorAll(iconSpanSelector);
        var idx;
        var icon;

        if (appIconClass) {
          if (iconSpan.length) {
            // remove the app icon class we set last time
            var oldAppIconClass = this[lastIvar];
            for (idx = 0; idx < iconSpan.length; idx++) {
              icon = iconSpan[idx];
              _removeClasses(icon, oldAppIconClass);
              _addClasses(icon, appIconClass);
            }
          } else {
            var spanElem = document.createElement('span');
            spanElem.className = standardIconClasses + ' ' + appIconClass;
            if (isStart) {
              contentContainer.insertBefore(spanElem, contentContainer.firstChild); // @HTMLUpdateOK prepend trusted new DOM to button elem
            } else {
              contentContainer.appendChild(spanElem); // @HTMLUpdateOK append trusted new DOM to button elem
            }
          }
        } else {
          for (idx = 0; idx < iconSpan.length; idx++) {
            icon = iconSpan[idx];
            icon.parentNode.removeChild(icon);
          }
        }

        // remember the app icon class we set, so we can remove it next time
        this[lastIvar] = appIconClass;

        return !!appIconClass;
      },

      /*
       * Hides / shows the label, and adds / removes the rootElement tooltip, depending on whether
       * display is "icons" (and whether there are in fact icons).  Doesn't add/remove the
       * tooltip if app provided one initially.
       *
       * Sets the corresponding root style class, e.g. "oj-button-text-only" or "oj-button-text-icon-start".
       *
       * Note: if rootAttributes ever supports "title", then need to call this *after* _SetRootAttributes so
       * app has a chance to set their own tooltip for checkbox/radio.
       *
       * Must be called when display, icons, or label options are set.
       * (If icons.end ever supports "auto" and is set to "auto", then must be called when menu option is set.)
       *
       * Caller must check that it's not a spanless button before calling this method.
       *
       * All params optional.
       */
      _setDisplayOptionOnDom: function (textSpan, hasStartIcon, hasEndIcon) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // The case for menu buttons and top level buttons
        var buttonLabelElem = this.buttonElement.children('.oj-button-label');

        // The case for buttonset buttons
        if (!buttonLabelElem.length) {
          var buttonset = this._getEnclosingContainerComponent('buttonset');
          if (this._IsCustomElement() || (buttonset && buttonset._IsCustomElement())) {
            buttonLabelElem = this.buttonElement.children('oj-option');
          } else {
            buttonLabelElem = this.buttonElement;
          }
        }

        if (textSpan === undefined) {
          // eslint-disable-next-line no-param-reassign
          textSpan = buttonLabelElem.children('.oj-button-text');
        }
        if (hasStartIcon === undefined) {
          // eslint-disable-next-line no-param-reassign
          hasStartIcon =
            !!this.options.icons.start || buttonLabelElem.children("[slot='startIcon']").length;
        }
        if (hasEndIcon === undefined) {
          // eslint-disable-next-line no-param-reassign
          hasEndIcon =
            !!this.options.icons.end || buttonLabelElem.children("[slot='endIcon']").length;
        }

        var multipleIcons = hasStartIcon && hasEndIcon;
        var atLeastOneIcon = hasStartIcon || hasEndIcon;
        var displayIsIcons = this.options.display === 'icons';

        var displayIsLabel = this.options.display === 'label';
        if (displayIsLabel) {
          if (buttonLabelElem.children("[slot='startIcon']")) {
            buttonLabelElem.children("[slot='startIcon']")[0].classList.add('oj-helper-hidden');
          }
          if (buttonLabelElem.children("[slot='endIcon']")) {
            buttonLabelElem.children("[slot='endIcon']")[0].classList.add('oj-helper-hidden');
          }
        } else if (atLeastOneIcon && displayIsIcons) {
          if (textSpan[0]) {
            textSpan[0].classList.add('oj-helper-hidden-accessible');
          }

          if (!this.hasTitle) {
            var buttonText = textSpan[0] ? textSpan[0].textContent : '';
            this.rootElement.setAttribute('title', $.trim(buttonText)); // use buttonText, which is escaped, not options.label, which isn't!
          }

          this._addMutationObserver();
        } else {
          if (textSpan[0]) {
            textSpan[0].classList.remove('oj-helper-hidden-accessible');
          }

          if (!this.hasTitle) {
            this.rootElement.removeAttribute('title');
          }

          this._removeMutationObserver();
        }

        var buttonClass;
        // if display value is label and it contain some text,
        if (displayIsLabel) {
          buttonClass = 'oj-button-text-only';
        }
        if (atLeastOneIcon) {
          if (displayIsIcons) {
            if (multipleIcons) {
              buttonClass = 'oj-button-icons-only';
            } else {
              buttonClass = 'oj-button-icon-only';
            }
          } else if (multipleIcons) {
            buttonClass = 'oj-button-text-icons';
          } else if (hasStartIcon) {
            buttonClass = 'oj-button-text-icon-start';
          } else {
            buttonClass = 'oj-button-text-icon-end';
          }
        } else {
          buttonClass = 'oj-button-text-only';
        }

        _removeClasses(this.rootElement, TYPE_CLASSES);
        this.rootElement.classList.add(buttonClass);
      },

      // Anchors are the only Button type lacking a native disabled API, so this tabindex logic is needed to prevent
      // them from being tabbable when disabled.  We only set the tabindex for anchors, and only when the Button is
      // standalone (not in a Buttonset or Toolbar), since those components already manage the tabindex.
      //
      // Each time a standalone anchor Button is set to disabled, including create time, we set its tabindex to -1, and
      // stash its old tabindex in an ivar, so that we can restore it when it is later enabled, and at destroy time.
      // This handles the common case where the button's "is standalone" status never changes.
      //
      // For the rare case that a Button is reparented into one of those components, those components will take
      // over the tabindex, so Button needn't do anything special at that time.
      //
      // Likewise, for the routine case that a Button is inited before its Buttonset/Toolbar, those components will take
      // over the tabindex when they're inited, so it's harmless for Button to have already set a tabindex that those
      // components will overwrite, and to have already set an ivar that those components will ignore.
      //
      // For the rare case that a Button is reparented out of one of those components, so as to become standalone, we
      // take no action, and in fact should NOT call this method, for the following reasons:
      // - Already, for all button types (not just anchor), the app must fix up the tabindex of a button reparented out of
      //   these containers, since it might be -1. There's little reason to handle anchors specially.
      // - We prefer not to introduce special handling just for this rare edge case.
      // - We don't want to guess whether the tabindex was set by the former container (which we try to fix up), vs. being
      //   set a moment ago by the app (which we hope not to clobber).
      // - If the button is disabled, we don't want to call the regular "set tabindex and stash old tabindex" logic, since
      //   the old tabindex is often -1 set by the old container.  Stashing -1 would mean that the next enable or destroy
      //   incorrectly sets -1 on the tabindex. And we don't want to special-case that logic for this rare reparenting case.
      //   Also, disabled buttons from those containers already have the desired -1 value (unless app changed it, which is
      //   their decision), so no action needed anyway.
      //
      // Since this logic never runs when in a Buttonset, callers don't need to worry about "effectively disabled", and can
      // just pass the old/new values of this.options.disabled.
      //
      // This method should NOT be called by refresh(), since there's no need, and since refresh() is called when reparented
      // out of a buttonset/toolbar.  Per above, this method should NOT be called at that time.
      //
      // This method should be called by _setOption("disabled") and at create time, NOT by _updateEffectivelyDisabled()
      // (which is called in both of those cases), since _updateEffectivelyDisabled() can be called
      // indirectly by refresh() when the button was just reparented out of a disabled Buttonset.  Since this logic never
      // runs when in a Buttonset, calling from _updateEffectivelyDisabled() is not needed.
      _manageAnchorTabIndex: function (oldDisabled, disabled) {
        // bail if:
        // - truthiness of disabled option is same as before, e.g. changed from "a" to "b"
        // - not a standalone anchor button
        if (
          !oldDisabled === !disabled ||
          this.type !== 'anchor' ||
          this._getEnclosingContainerElement('buttonset').length ||
          this._getEnclosingContainerElement('toolbar').length
        ) {
          return;
        }

        var elem = this.element[0];
        if (disabled) {
          // enabled button becoming disabled, at create time or later. (Not destroy time, since that logic only passes disabled=false.)
          // If the existing tabindex is unset (attr() returns undefined) or invalid (not a (stringified) integer), set the
          // ivar to null, in which case when we later restore the old value, we just clear the attr.  Obviously correct
          // in unset case. For invalid case, we prefer not to set anything invalid on the dom, and per MDN
          // unset and invalid tabindexes are handled the same.
          var attr = elem.getAttribute('tabindex');
          this._oldAnchorTabIndex = this._isInteger(Number(attr)) ? attr : null;

          elem.setAttribute('tabindex', -1);
        } else if (this._oldAnchorTabIndex == null) {
          // disabled button becoming enabled after create time, incl. destroy time.  (Not create time, since that logic only passes disabled=true.)
          elem.removeAttribute('tabindex');
        } else {
          elem.setAttribute('tabindex', this._oldAnchorTabIndex);
          // no need to clear ivar
        }
      },

      // IE11 and several modern platforms don't support Number.isInteger(), so use MDN's polyfill:
      _isInteger: function (value) {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
      },

      _selectorMap: {
        buttonset: '.oj-buttonset',
        toolbar: '.oj-toolbar',
        buttonsetone: 'oj-buttonset-one'
      },

      _constructorMap: {
        buttonset: 'ojButtonset',
        toolbar: 'ojToolbar'
      },

      // Utility routine to see if component inside a buttonset-one and currently selected
      _isSelectedInButtonsetOne: function () {
        var inButtosetOne = this._getEnclosingContainerElement('buttonsetone').length === 1;
        return inButtosetOne && this.rootElement.classList.contains('oj-selected');
      },

      // component param is "buttonset" or "toolbar" or "buttonsetone"
      // Returns non-null JQ object that's length 1 iff this button is contained in a container of the specified type
      _getEnclosingContainerElement: function (component) {
        return $(this.rootElement).closest(this._selectorMap[component]);
      },

      // component param is "buttonset" or "toolbar"
      // Returns buttonset/toolbar component, or null if none.
      _getEnclosingContainerComponent: function (component) {
        var elem = this._getEnclosingContainerElement(component)[0];
        var constructor = Components.__GetWidgetConstructor(elem, this._constructorMap[component]);
        return constructor && constructor('instance');
      },

      /*
       * Call this method at create time and whenever the "menu" option is set by the app.
       *
       * - This method first removes menuButton stuff from the element and from any Menu previously set on this Button.
       * - Then, if the Button's "menu" option is set, then it sets the needed listeners on the button.
       *
       * We don't set listeners on the menu until _getMenu() is called on the first launch,
       * so that the menu needn't be inited before the button.
       */
      _setupMenuButton: function (oldMenuOption) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._getMenuNode() && this.element[0].tagName === 'INPUT') {
          // both push and toggle buttons based on <input>
          throw new Error('Menu Button functionality is not supported on input elements.');
        }

        this._removeMenuBehavior(oldMenuOption);

        if (this._getMenuNode()) {
          var self = this;
          this.element
            .attr('aria-haspopup', true)
            .attr('role', 'button')
            .on('keydown' + this.menuEventNamespace, function (event) {
              if (
                event.which === $.ui.keyCode.DOWN ||
                event.which === $.ui.keyCode.ENTER ||
                event.which === $.ui.keyCode.SPACE
              ) {
                self._toggleMenu(event, 'firstItem');
                event.preventDefault();
                return true;
              } else if (event.which === $.ui.keyCode.ESCAPE) {
                var bubbleEscUp = !self.rootElement.classList.contains('oj-selected');
                self._dismissMenu(self._getMenuNode(), event);
                return bubbleEscUp;
              }

              return true;
            })
            .on('click' + this.menuEventNamespace, function (event) {
              // console.log("mb click handler");
              var menu = self._getMenu();
              if (!menu.__spaceEnterDownInMenu) {
                // console.log("mb click handler showing menu");
                // Ideally a click (Enter/Space) would toggle (open/close) the menu without moving focus to it, per WAI-ARIA.
                // But on IE, JAWS is not recognizing the menu on click/Enter/Space.
                // Workaround for this, cleared with A11y team, is to move focus to menu like DownArrow. Ref .
                self._toggleMenu(event, 'menu');
              }
              menu.__spaceEnterDownInMenu = false;
              event.preventDefault();
              return true;
            });
        }
      },

      /*
       * This method removes menuButton functionality from the button and specified menu
       *
       * param menuOption - a current or previous value of the "menu" option
       */
      _removeMenuBehavior: function (menuOption) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element.removeAttr('aria-haspopup').removeAttr('role').off(this.menuEventNamespace);

        this._dismissMenu(menuOption);

        // access menu elem directly, rather than using _getMenuOnly(menuOption).widget(), so listener is cleared even if component no longer exists.
        $(menuOption).off(this.menuEventNamespace);
        this._menuListenerSet = false;
      },

      /*
       * Lazy getter for the menu.  It finds the menu instance pointed to by the "menu" option, registers menuButton listeners on it, and returns the menu.
       *
       * This method should be called only by the "user is launching the menu" listeners, which should only be registered if the "menu" option is set.  Do not call at create time.
       *
       * We wait until menu-launch time to lazily get and configure the menu, to avoid an init-order dependency.  It should be OK to init the button before the menu.
       *
       * This method throws if no Menu found, which is app error since Menu should be inited by the time a user launches the menu.
       *
       * (Do NOT return null just because button is disabled, since that would mean disabled menuButtons lose their dropdown arrow, and possibly other problems.)
       */
      _getMenu: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // The JET Menu of the first element found.
        // Per architect discussion, get it every time rather than caching the menu.
        var menu = this._getMenuOnly(this._getMenuNode());

        // if no element found, or if element has no JET Menu
        if (!menu) {
          throw new Error(
            'JET Button: "menu" option specified, but does not reference a valid JET Menu.'
          );
        }

        if (!this._menuListenerSet) {
          var self = this;

          var closeEvent;
          // Use the close event type that's appropriate for the menu, not the button.  It's possible that
          // a button widget is used with an oj-menu custom element.  Since the event listener is bound
          // to the menu, we need to check the type of menu component.
          if (!menu._IsCustomElement()) {
            closeEvent = 'ojclose';
          } else {
            closeEvent = 'ojClose';
          }

          // must use "on" syntax rather than clobbering whatever "close" handler the app may have set via the menu's "option" syntax
          menu.widget().on(closeEvent + this.menuEventNamespace, function (event) {
            self._menuDismissHandler(event);
          });
          this._menuListenerSet = true;
        }

        return menu;
      },

      /*
       * Returns the JET Menu of the (first) element specified by the menuOption param, which should be a (current or old)
       * value of the menu option.  Returns null if no element found, or if element has no JET Menu.
       *
       * Most callers should call _getMenu instead, as _getMenuOnly() performs no init, and doesn't throw if no menu found.
       * This method is suitable as a helper for _getMenu, or (say) to close an open menu (which isn't needed if menu is already gone).
       *
       * If you need the menu's *element* (not component), then it's better to call $(foo) than
       * menu=this._getMenuOnly(foo); elem=menu && menu.widget(),
       * since $(foo) works when the element is found but its component is not (and is more efficient).
       *
       * If you need the menu's element *and* component, and should throw if they're missing, then just call
       * menu=this._getMenu(); elem=menu.widget(),
       */
      _getMenuOnly: function (menuOption) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // Call instance() since need to access non-public Menu api's like __dismiss()
        var constructor = Components.__GetWidgetConstructor($(menuOption)[0], 'ojMenu');
        return constructor && constructor('instance');
      },

      /*
       * Toggle the menuButton menu on and off if there is one and we're not disabled.
       *
       * MenuButton types:
       * - We support menuButtons on push buttons based on <button> and <a>.
       *     - Architects require that we support menuButtons on at least some types of push buttons.
       *       I.e. if checkbox-based menuButtons were supported, it would not be OK for that to be the only type that's supported.
       * - <input type=button|submit|reset> work fine using the same code path as <button> and <a>, but architects approved proposal
       *   not to support them for following reasons:
       *     - submit/reset menubuttons are semantically / behaviorally absurd.
       *     - these types don't support icons, i.e. the dropdown icon.
       *     - reduces exposure to issues like we had for checkboxes, without sacrificing anything since these flavors were undesirable
       *       for menuButton use anyway.
       *  - Radios are inappropriate for menuButtons.  Alternate clicks should open and close the menu, with corresponding visual
       *    feedback from button, but radios are idempotent: they stay pressed on repeated clicks.
       *  - Architects approved proposal not to support checkboxes for following reasons:
       *      - Checkbox-based menuButtons were considered a bit odd, and we had zero requirements for it.
       *      - The only thing they buy anyone is the checked state corresponding to the menu-open state, but there are several ways for
       *        apps to find out if the menu is open, e.g. check its "hidden" status, check whether the oj-selected class is present, etc.
       *      - They proved to be somewhat brittle, with *different* event-ordering problems in each browser.  Even if we spent the time
       *        to fix it, they could still be a source of problems later, which didn't seem worth it for a flavor no one wanted.
       *
       * param event required
       * param focus required
       */
      _toggleMenu: function (event, focus) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._IsEffectivelyDisabled()) {
          return;
        }

        // No need to fire click event, since not appropriate for DownArrow, and already fired for user click.

        var menu = this._getMenu();
        var menuElem = menu.widget();

        // If the menu is already opened, click MenuButton again will close the menu.
        if (this._menuVisible) {
          this._dismissMenu(this._getMenuNode(), event);
          return;
        }

        menu.open(event, { launcher: this.element, initialFocus: focus });

        // bail if launch was cancelled by a beforeOpen listener
        if (!menuElem.is(':visible')) {
          return;
        }

        this._menuVisible = true;

        // If menu has neither aria-label nor aria-labelledby after menu.open() calls the beforeOpen listeners, then set aria-labelledby
        // referencing the menu button, and remove it when the menu is closed.  This approach provides a useful default while allowing
        // the menu to be shared by several launchers.
        if (!menuElem[0].getAttribute('aria-label') && !menuElem[0].getAttribute('aria-labelledby')) {
          this.element.uniqueId(); // add id if not already there
          this._setAriaLabelledBy = true;
          menuElem[0].setAttribute('aria-labelledby', this.element[0].getAttribute('id'));
        }

        // Per UX requirements, menuButtons should look pressed/checked iff the menu is open:
        // - For push buttons, per architectural review, just add/remove oj-selected even though it's a push button.
        //     - Per a11y review, that's fine, but do NOT apply aria-pressed to push buttons, which would turn it into a toggle button for AT users.  He said that
        //       would just confuse things, and that the visual pressed-in look was just eye candy in this case, not semantics that we need to show to AT users.
        // - If checkbox menuButtons were supported, obviously we'd toggle the pressed look by checking/unchecking the button, which in turn would toggle oj-selected.
        //   In that case, we'd fire DOM checked event (right?) and if wrapped in Buttonset, update its checked option and fire optionChange event.
        // ER 19167450
        // calling open on a already open menu now first dismisses it.  the button
        // dismissal handler removes the "oj-select" style.  move the logic that sets
        // the oj-select to after the menu is open.
        this.rootElement.classList.add('oj-selected');
        this.rootElement.classList.remove('oj-default');
        this.rootElement.classList.remove('oj-focus-only');
      },

      /*
       * Dismisses the menuButton menu if *we* launched it
       *
       * param menuOption required.  An old or current value of the menu option, indicating which menu to close.
       * param event optional.  Pass iff dismissing due to UI event.
       */
      _dismissMenu: function (menuOption, event) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // this._menuVisible is set iff *we* launched the menu.  If *something else* launched it, don't dismiss it.
        if (this._menuVisible) {
          // Doesn't throw if menu not found. Something is likely wrong in that case, but don't sweat it unless they try to *launch* an MIA menu.
          var menu = this._getMenuOnly(menuOption);
          if (menu) {
            // TODO: this should be called by __dismiss(), rather than the caller having to call this too.
            menu.__collapseAll(event, true); // close open submenus before hiding the popup so that submenus will not be shown on reopen

            menu.__dismiss(event); // causes _menuDismissHandler(event) to be called
          }
        }
      },

      /*
       * Handles menu dismissals, whether or not we dismissed it ourselves.
       * See comments on similar code in _toggleMenu().
       *
       * Also called by the beforeOpen listener we put on the menu, *if* the launch was by something else,
       * including our own context menu.  So if something steals our menu, we deselect the button.
       *
       * param event must remain optional, since some callers of _dismissMenu have no event
       */
      _menuDismissHandler: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this._setAriaLabelledBy) {
          $(this._getMenuNode()).removeAttr('aria-labelledby');
          this._setAriaLabelledBy = false;
        }

        // console.log(this.options.label + ": button._menuDismissHandler called");
        // Since only push buttons are supported for menu buttons, the only reason for .oj-selected to be present is if it's an open menu button,
        // so we remove the class since the menu is being dismissed.
        this.rootElement.classList.remove('oj-selected');
        this._toggleDefaultClasses();

        this._menuVisible = false;
      },

      /*
       * Let the "state classes" be oj-active, oj-disabled, oj-selected, oj-hover, and oj-focus.
       * This method ensures that the root element has:
       *   - the oj-default class iff it has none of the state classes, and
       *   - the oj-focus-only class iff it has oj-focus but no other state classes.
       * Note that oj-focus-highlight should never be present without oj-focus, so there's no need to check for that separately.
       */
      _toggleDefaultClasses: function () {
        var otherStates = $(this.rootElement).is('.oj-hover, .oj-active, .oj-selected, .oj-disabled');
        var defaultState;
        var focusedOnly;

        if (otherStates) {
          defaultState = false;
          focusedOnly = false;
        } else {
          var focused = $(this.rootElement).is('.oj-focus');
          defaultState = !focused;
          focusedOnly = focused;
        }

        if (defaultState) {
          this.rootElement.classList.add('oj-default');
        } else {
          this.rootElement.classList.remove('oj-default');
        }

        if (focusedOnly) {
          this.rootElement.classList.add('oj-focus-only');
        } else {
          this.rootElement.classList.remove('oj-focus-only');
        }
      }
    });

    /**
     * @ojcomponent oj.ojMenuButton
     * @ojdisplayname Menu Button
     * @since 4.0.0
     * @ojdeprecated [
     *  {
     *    type: "maintenance",
     *    since: "16.0.0",
     *    value: ["oj-c-menu-button"]
     *  },
     * ]
     * @augments oj.ojButton
     * @ojshortdesc A menu button launches a menu when clicked.
     * @ojrole button
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["label", "display", "chroming", "disabled"]}
     * @ojvbdefaultcolumns 2
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-menu-button'
     * @ojuxspecs ['menu-button']
     *
     * @classdesc
     * <h3 id="menubuttonOverview-section">
     *   JET Menu Button
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#menubuttonOverview-section"></a>
     * </h3>
     *
     * <pre class="prettyprint"><code>&lt;oj-menu-button id="menuButton">
     *   &lt;oj-menu id="menu" slot="menu" style="display:none">
     *       &lt;oj-option>Item 1&lt;/oj-option>
     *       &lt;oj-option>Item 2&lt;/oj-option>
     *       &lt;oj-option>Item 3&lt;/oj-option>
     *   &lt;/oj-menu>
     * &lt;/oj-menu-button></code></pre>
     *
     * <h3 id="buttonsetToolbar-section">
     *   Buttonsets and Toolbars
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetToolbar-section"></a>
     * </h3>
     *
     * <p>The [JET Buttonset]{@link oj.ojButtonset} component can be used to create toggle buttons or group related buttons.  It cannot be used
     * to create menu buttons or regular push buttons. Buttonset provides visual and semantic grouping and WAI-ARIA-compliant focus management.  See the Buttonset API doc for more information.
     *
     * <p>Menu buttons, push buttons, and buttonsets can be placed in a [JET Toolbar]{@link oj.ojToolbar}.  Like Buttonset, Toolbar is themable and provides WAI-ARIA-compliant
     * focus management.  See the Toolbar API doc for more information.
     *
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, it is not required to set an aria label on a JET Menu Button as it uses the text in the default slot to generate an aria label.
     * Therefore the default slot should be filled even if the button is <a href="#display">icon-only (display=icons)</a>. However,
     * you can override the default behavior by setting <code class="prettyprint">aria-label</code> or <code class="prettyprint">aria-labelledby</code>.
     * {@ojinclude "name":"accessibilityCommon"}
     *
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     * <p>
     * To migrate from oj-menu-button to oj-c-menu-button, you need to revise the import statement
     * and references to oj-c-menu-button in your app. Please note the changes between the two components below.
     * </p>
     * <strong>oj-c-menu-button no longer supports DOM-centric menus specified in the menu slot.  Instead, the menu is specified
     * to the items property.  The selection property indicates what items are selected in selection group, oj-menu-select-many is
     * no longer supported.  The label property is used instead of the default slot.  A on-oj-menu-action callback can be used to
     * replace the oj-menu on-oj-menu-action, though each menu item now supports onAction callbacks as well. </strong>
     * <h5>Menu Button Specific Attributes and Methods</h5>
     * <p>oj-c-menu-button does not support a menu slot oj-menu, so menus must be specified via the items property.
     * </p>
     *
     * <ul>
     * <li>Attributes:
     * <ul>
     * <li>label</li>
     * <li>width</li>
     * <li>size</li>
     * <li>edge</li>
     * <li>tooltip</li>
     * </ul>
     * </li>
     * </ul>
     *
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <p>In lieu of stamping a menu button in a table, dataGrid, or other container, consider placing a single Menu Button outside of the
     * container that acts on the currently selected row or cell.
     *
     * <h3 id="state-section">
     *   Setting Component State
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"stateCommon"}
     */
    // --------------------------------------------------- oj.ojMenuButton Styling Start ------------------------------------------------------------
    /**
     * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
     */
    // ---------------- oj-button size --------------
    /**
     * Makes the button small or large.<br>
     * @ojstyleset button-size
     * @ojdisplayname Button Size
     * @ojstylesetitems ["button-size.oj-button-sm", "button-size.oj-button-lg"]
     * @ojstylerelation exclusive
     * @memberof oj.ojMenuButton
     */
    /**
     * @ojstyleclass button-size.oj-button-sm
     * @ojshortdesc Makes the button small.
     * @ojdisplayname Small
     * @memberof! oj.ojMenuButton
     */
    /**
     * @ojstyleclass button-size.oj-button-lg
     * @ojshortdesc Makes the button large.
     * @ojdisplayname Large
     * @memberof! oj.ojMenuButton
     */
    // --------------------------------------------------- oj.ojMenuButton Styling End ------------------------------------------------------------

    /**
     * @ojcomponent oj.ojButtonsetOne
     * @since 0.6.0
     * @ojdeprecated [
     *  {
     *    type: "maintenance",
     *    since: "17.0.0",
     *    value: ["oj-c-buttonset-single"]
     *  }
     * ]
     *
     * @augments oj.ojButtonset
     * @ojshortdesc A buttonset one is a grouping of related buttons where only one button may be selected.
     * @ojrole button
     * @ojrole radiogroup
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["display", "chroming", "disabled"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 12
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-button-set-one'
     * @ojuxspecs ['toggle-button']
     *
     * @classdesc
     * <h3 id="buttonsetOverview-section">
     *   JET Buttonset One
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant visual and semantic grouping container for [JET Buttons]{@link oj.ojButton}.
     *
     * <p>The JET ButtonsetOne can be used to group related buttons, where only one button may be selected.  Buttonset provides
     * visual and semantic grouping and WAI-ARIA-compliant focus management.
     *
     * <p>When a Buttonset is created or refreshed, it creates JET Buttons out of all contained <code class="prettyprint">oj-option</code>
     * DOM elements by wrapping them and calling <code class="prettyprint">.ojButton()</code> on the generated content. The Buttonset will remove all
     * non <code class="prettyprint">oj-option</code> DOM elements from the Buttonset.
     *
     * <p><code class="prettyprint">oj-option</code>s inside of the buttonset should specify the <code class="prettyprint">oj-option</code>
     * <code class="prettyprint">value</code> attribute, since the <code class="prettyprint">oj-buttonset-one</code> <code class="prettyprint">value</code> attribute refers to that attribute.
     *
     * <pre class="prettyprint"><code>&lt;oj-buttonset-one id="myButtonset">
     *   &lt;oj-option value="myValue0">Value0&lt;/oj-option>
     *   &lt;oj-option value="myValue1">Value1&lt;/oj-option>
     * &lt;/oj-buttonset-one></code></pre>
     *
     * {@ojinclude "name":"buttonsetCommon"}
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-buttonset-one id="drinkset">
     *       &lt;oj-bind-for-each data="[[drinkValues]]">
     *         &lt;template>
     *           &lt;oj-option value="[[$current.data.id]]">
     *             &lt;span>
     *               &lt;oj-bind-text value="[[$current.data.label]]">&lt;/oj-bind-text>
     *             &lt;/span>
     *           &lt;/oj-option>
     *         &lt;/template>
     *       &lt;/oj-bind-for-each>
     *   &lt;/oj-buttonset-one>
     * </code></pre>
     */
    // --------------------------------------------------- oj.ojButtonsetOne Styling Start ------------------------------------------------------------
    /**
     * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
     */
    // -----------------oj-buttonset-width-auto --------------
    /**
     * <p>Forces Buttonset Buttons' widths to be determined by the total width of their icons and label contents, overriding any theming defaults.</p>
     * <p>Optionally, specify the overall width of the Buttonset for further width control.</p>
     * <p>Can be applied to Buttonset's root element, or on an ancestor such as Toolbar or document.</p>
     * @ojstyleclass oj-buttonset-width-auto
     * @ojshortdesc Sets button set width to content size.
     * @ojdisplayname Auto-Width
     * @memberof oj.ojButtonsetOne
     */
    // ----------------- oj-buttonset-width-equal --------------
    /**
     * <p>Forces Buttonset Buttons' widths to be equal, overriding any theming defaults.</p>
     * <p>Note that the overall width of the Buttonset defaults to 100%; set the max-width (recommended) or width of the Buttonset for further width control.</p>
     * <p>Can be applied to Buttonset's root element, or on an ancestor such as Toolbar or document.</p>
     * @ojstyleclass oj-buttonset-width-equal
     * @ojshortdesc Sets button set width to be equal.
     * @ojdisplayname Equal Width
     * @memberof oj.ojButtonsetOne
     */
    // ---------------- oj-button size --------------
    /**
     * Makes the button small or large.<br>
     * @ojstyleset button-size
     * @ojdisplayname Button Size
     * @ojstylesetitems ["button-size.oj-button-sm", "button-size.oj-button-lg"]
     * @ojstylerelation exclusive
     * @memberof oj.ojButtonsetOne
     */
    /**
     * @ojstyleclass button-size.oj-button-sm
     * @ojshortdesc Makes the button small.
     * @ojdisplayname Small
     * @memberof! oj.ojButtonsetOne
     */
    /**
     * @ojstyleclass button-size.oj-button-lg
     * @ojshortdesc Makes the button large.
     * @ojdisplayname Large
     * @memberof! oj.ojButtonsetOne
     */
    // --------------------------------------------------- oj.ojButtonsetOne Styling End ------------------------------------------------------------

    /**
     * @ojcomponent oj.ojButtonsetMany
     * @since 0.6.0
     * @ojdeprecated [
     *  {
     *    type: "maintenance",
     *    since: "17.0.0",
     *    value: ["oj-c-buttonset-multiple"]
     *  }
     * ]
     *
     * @augments oj.ojButtonset
     * @ojshortdesc A buttonset many is a grouping of related buttons where any number of buttons may be selected.
     * @ojrole button
     * @ojrole group
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["display", "chroming", "disabled"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
     * @ojvbdefaultcolumns 12
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-button-set-many'
     * @ojuxspecs ['toggle-button']
     *
     * @classdesc
     * <h3 id="buttonsetOverview-section">
     *   JET Buttonset Many
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant visual and semantic grouping container for [JET Buttons]{@link oj.ojButton}.
     *
     * <p>The JET ButtonsetMany can be used to group related buttons, where any number of the buttons can be selected.  Buttonset provides
     * visual and semantic grouping and WAI-ARIA-compliant focus management.
     *
     * <p>When a Buttonset is created or refreshed, it creates JET Buttons out of all contained <code class="prettyprint">oj-option</code>
     * DOM elements by wrapping them and calling <code class="prettyprint">.ojButton()</code> on the generated content. The Buttonset will remove all
     * non <code class="prettyprint">oj-option</code> DOM elements from the Buttonset.
     *
     * <p><code class="prettyprint">oj-option</code>s in the buttonset should specify the <code class="prettyprint">oj-option</code>
     * <code class="prettyprint">value</code> attribute, since the <code class="prettyprint">oj-buttonset-mnay</code> <code class="prettyprint">value</code> attribute refers to that attribute.
     *
     * <pre class="prettyprint"><code>&lt;oj-buttonset-many id="myButtonset">
     *   &lt;oj-option value="myValue0">Value0&lt;/oj-option>
     *   &lt;oj-option value="myValue1">Value1&lt;/oj-option>
     * &lt;/oj-buttonset-many></code></pre>
     *
     * {@ojinclude "name":"buttonsetCommon"}
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-buttonset-many id="drinkset">
     *       &lt;oj-bind-for-each data="[[drinkValues]]">
     *         &lt;template>
     *           &lt;oj-option value="[[$current.data.id]]">
     *             &lt;span>
     *               &lt;oj-bind-text value="[[$current.data.label]]">&lt;/oj-bind-text>
     *             &lt;/span>
     *           &lt;/oj-option>
     *         &lt;/template>
     *       &lt;/oj-bind-for-each>
     *   &lt;/oj-buttonset-many>
     * </code></pre>
     */
    // --------------------------------------------------- oj.ojButtonsetMany Styling Start ------------------------------------------------------------
    /**
     * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
     */
    // ----------------- oj-buttonset-width-auto --------------
    /**
     * <p>Forces Buttonset Buttons' widths to be determined by the total width of their icons and label contents, overriding any theming defaults.</p>
     * <p>Optionally, specify the overall width of the Buttonset for further width control.</p>
     * <p>Can be applied to Buttonset's root element, or on an ancestor such as Toolbar or document.</p>
     * @ojstyleclass oj-buttonset-width-auto
     * @ojshortdesc Sets button set width to content size.
     * @ojdisplayname Auto-Width
     * @memberof oj.ojButtonsetMany
     */
    // ----------------- oj-buttonset-width-equal --------------
    /**
     * <p>Forces Buttonset Buttons' widths to be equal, overriding any theming defaults.</p>
     * <p>Note that the overall width of the Buttonset defaults to 100%; set the max-width (recommended) or width of the Buttonset for further width control.</p>
     * <p>Can be applied to Buttonset's root element, or on an ancestor such as Toolbar or document.</p>
     * @ojstyleclass oj-buttonset-width-equal
     * @ojshortdesc Sets button set width to be equal.
     * @ojdisplayname Equal Width
     * @memberof oj.ojButtonsetMany
     */
    // ---------------- oj-button size --------------
    /**
     * Makes the button small or large.<br>
     * @ojstyleset button-size
     * @ojdisplayname Button Size
     * @ojstylesetitems ["button-size.oj-button-sm", "button-size.oj-button-lg"]
     * @ojstylerelation exclusive
     * @memberof oj.ojButtonsetMany
     */
    /**
     * @ojstyleclass button-size.oj-button-sm
     * @ojshortdesc Makes the button small.
     * @ojdisplayname Small
     * @memberof! oj.ojButtonsetMany
     */
    /**
     * @ojstyleclass button-size.oj-button-lg
     * @ojshortdesc Makes the button large.
     * @ojdisplayname Large
     * @memberof! oj.ojButtonsetMany
     */
    // --------------------------------------------------- oj.ojButtonsetMany Styling End ------------------------------------------------------------

    /**
     * @ojcomponent oj.ojButtonset
     * @augments oj.baseComponent
     * @since 0.6.0
     * @abstract
     * @classdesc
     * @hideconstructor
     */

    /**
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="keyboard-appdev-section">
     *   Keyboard Application Developer Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
     * </h3>
     *
     * <p>The application should not do anything to interfere with the Buttonset's focus management, such as setting the <code class="prettyprint">tabindex</code>
     * of the buttons.  Also, enabled buttons should remain user-visible, without which arrow-key navigation to the button would cause the focus to seemingly disappear.
     *
     * <p>The buttonset's focus management should be turned off when placing the buttonset in a [JET Toolbar]{@link oj.ojToolbar}.  See the <code class="prettyprint">focusManagement</code> attribute.
     * In this case, the "Keyboard End User Information" documented above is superseded by the Toolbar's documented keyboard behavior.
     *
     * <h3 id="migration-section">
     *   Migration
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
     * </h3>
     * <p>
     * To migrate from oj-buttonset-many to oj-c-buttonset-multiple, or oj-buttonset-one to oj-c-buttonset-single, you need to revise the import statement
     * and references to oj-c-buttonset-multiple, or oj-c-buttonset-single in your app. Please note the changes between the components below.
     * Note that oj-c-toggle-button should be used instead of oj-c-buttonset-multiple, as it provide superior speed, though oj-c-buttonset-multiple
     * with a single button will function properly.
     * </p>
     * <strong>oj-c-buttonset-multiple</strong> no longer supports DOM-centric options specified in the default slot.  Instead, the toggles are specified
     * in the items property.  Sizes, layout widths, widths, max width, and edge behavior are all now done via properties instead of style classes or styling.
     * Tooltip replaces title.   Solid chroming is no longer supported.   For oj-c-toggle-button, a value and label are used on the button, instead of having
     * a value on a containing buttonset.
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>The application is responsible for applying <code class="prettyprint">aria-label</code> and/or
     * <code class="prettyprint">aria-controls</code> attributes like the following to the buttonset element, if applicable per the instructions that follow:
     *
     * <pre class="prettyprint">
     * <code>aria-label="Choose only one beverage."
     * aria-controls="myTextEditor"
     * </code></pre>
     *
     * <p>An <code class="prettyprint">aria-label</code> conveying the "choose only one" semantics should be included for a buttonset-one.
     *
     * <p>The <code class="prettyprint">aria-controls</code> attribute should be included if the buttonset is controlling something else on the page, e.g.
     * bold / italic / underline buttons controlling a rich text editor.  If the buttonset is contained in a toolbar, <code class="prettyprint">aria-controls</code>
     * should be placed on the toolbar, not on the buttonsets within the toolbar.
     *
     * <p>Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.<p>
     *
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
     * is changed post-create, the buttonset must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
     *
     * <h3 id="binding-section">
     *   Declarative Binding
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
     * </h3>
     *
     * <p>For components like Buttonset and Menu that contain a number of like items, applications may wish to use an <code class="prettyprint">oj-bind-for-each</code>
     * to stamp out the contents as follows:
     *
     * @ojfragment buttonsetCommon
     * @memberof oj.ojButtonset
     * @instance
     */
    // ---------------------------------- Styling oj-button ------------------------------------
    /**
     * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
     */
    // ---------------- oj-button size --------------
    /**
     * Makes the button small, large, or extra large.<br>
     * The class is applied to the Button's root element.
     * @ojstyleset button-size
     * @ojdisplayname Button Size
     * @ojstylesetitems ["button-size.oj-button-sm", "button-size.oj-button-lg", "button-size.oj-button-xl"]
     * @ojstylerelation exclusive
     * @memberof oj.ojButton
     * @ojtsexample
     * &lt;oj-button class="oj-button-sm">
     *    &lt;!--  content -->
     * &lt;/oj-button>
     */
    /**
     * @ojstyleclass button-size.oj-button-sm
     * @ojshortdesc Makes the button small.
     * @ojdisplayname Small
     * @memberof! oj.ojButton
     */
    /**
     * @ojstyleclass button-size.oj-button-lg
     * @ojshortdesc Makes the button large.
     * @ojdisplayname Large
     * @memberof! oj.ojButton
     */
    /**
     * @ojstyleclass button-size.oj-button-xl
     * @ojshortdesc Makes the button extra large.
     * @ojdisplayname X-Large
     * @ojdeprecated [{since: "9.0.0", description: "This class will be removed in the future."}]
     * @memberof! oj.ojButton
     */
    // ---------------- oj-button-full-width --------------
    /**
     * Apply 100% full-width to the button.
     * The class is applied to the Button's root element.
     * It is intended for buttons which stretch to the edge, not for buttons with padding.
     *
     * @ojstyleclass oj-button-full-width
     * @ojshortdesc Apply 100% full-width to the button.
     * @ojdisplayname Full Width
     * @ojunsupportedthemes ["Alta"]
     * @memberof oj.ojButton
     * @ojtsexample
     * &lt;oj-button class="oj-button-full-width">
     *    &lt;!--  content -->
     * &lt;/oj-button>
     */
    // ---------------- oj-button-primary --------------
    /**
     * Draws attention to the button, often identifying the primary action in a set of buttons. Designed for use with a push button. In some themes, this class does nothing.<br>
     * The class is applied to the Button's root element.
     * @ojstyleclass oj-button-primary
     * @ojdisplayname Primary
     * @ojdeprecated [{since: "8.0.0", description: "This class will be removed in the future. Please use 'callToAction' chroming instead."}]
     * @memberof oj.ojButton
     * @ojtsexample
     * &lt;oj-button class="oj-button-primary">
     *    &lt;!--  content -->
     * &lt;/oj-button>
     */
    // ---------------- oj-button-confirm --------------
    /**
     * Identifies an action to confirm. Designed for use with a push button.<br>
     * This class is applied to the Button's root element.
     * @ojstyleclass oj-button-confirm
     * @ojdisplayname Confirm
     * @ojdeprecated [{since: "9.0.0", description: "This class will be removed in the future."}]
     * @memberof oj.ojButton
     * @ojtsexample
     * &lt;oj-button class="oj-button-confirm">
     *    &lt;!--  content -->
     * &lt;/oj-button>
     */
    // ---------------- oj-focus-highlight --------------
    /**
     * Under normal circumstances this class is applied automatically. It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The <code class="prettyprint"><span>oj-focus-highlight</span></code> class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojButton
     * @ojtsexample
     * &lt;oj-button class="oj-focus-highlight">
     *    &lt;!--  content -->
     * &lt;/oj-button>
     */
    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------
    // ---------------- default button ---------------------
    /**
     * @ojstylevariableset oj-button-css-set1
     * @ojdisplayname Default buttons
     * @ojstylevariable oj-button-height                {description: "Button height",                formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-border-radius         {description: "Button border radius",         formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-font-size             {description: "Button font size",             formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-font-weight           {description: "Button font weight",           formats: ["font_weight"]}
     * @ojstylevariable oj-button-icon-size             {description: "Button icon size",             formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-text-to-edge-padding  {description: "Button text to edge padding",  formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-icon-to-text-padding  {description: "Button icon to text padding",  formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-icon-to-edge-padding  {description: "Button icon to edge padding",  formats: ["length", "percentage"]}
     * @memberof oj.ojButton
     */
    // ---------------- small button -----------------------
    /**
     * @ojstylevariableset oj-button-css-set2
     * @ojdisplayname Small buttons
     * @ojstylevariable oj-button-sm-height                {description: "Small button height",                formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-sm-font-size             {description: "Small button font size",             formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-sm-icon-size             {description: "Small button icon size",             formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-sm-text-to-edge-padding  {description: "Small button text to edge padding",  formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-sm-icon-to-text-padding  {description: "Small button icon to text padding",  formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-sm-icon-to-edge-padding  {description: "Small button icon to edge padding",  formats: ["length", "percentage"]}
     * @memberof oj.ojButton
     */
    // ---------------- large button -----------------------
    /**
     * @ojstylevariableset oj-button-css-set3
     * @ojdisplayname Large buttons
     * @ojstylevariable oj-button-lg-height                {description: "Large button height",                formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-lg-font-size             {description: "Large button font size",             formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-lg-icon-size             {description: "Large button icon size",             formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-lg-text-to-edge-padding  {description: "Large button text to edge padding",  formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-lg-icon-to-text-padding  {description: "Large button icon to text padding",  formats: ["length", "percentage"]}
     * @ojstylevariable oj-button-lg-icon-to-edge-padding  {description: "Large button icon to edge padding",  formats: ["length", "percentage"]}
     * @memberof oj.ojButton
     */
    // ---------------- borderless buttons -----------------------
    /**
     * @ojstylevariableset oj-button-css-set4
     * @ojdisplayname Borderless buttons
     * @ojstylevariable oj-button-borderless-chrome-text-color                     {description: "Borderless chrome button text color",                         formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-bg-color-hover                 {description: "Borderless chrome button hover background color",             formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-border-color-hover             {description: "Borderless chrome button hover border color",                 formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-text-color-hover               {description: "Borderless chrome button hover text color",                   formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-bg-color-active                {description: "Borderless chrome button active background color",            formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-border-color-active            {description: "Borderless chrome button active border color",                formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-text-color-active              {description: "Borderless chrome button active text color",                  formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-bg-color-selected              {description: "Borderless chrome button selected background color",          formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-border-color-selected          {description: "Borderless chrome button selected border color",              formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-text-color-selected            {description: "Borderless chrome button selected text color",                formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-bg-color-selected-hover        {description: "Borderless chrome button selected hover background color",    formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-border-color-selected-hover    {description: "Borderless chrome button selected hover border color",        formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-text-color-selected-hover      {description: "Borderless chrome button selected hover text color",          formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-text-color-disabled            {description: "Borderless chrome button disabled text color",                formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-bg-color-selected-disabled     {description: "Borderless chrome button disabled selected background color", formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-border-color-selected-disabled {description: "Borderless chrome button disabled selected border color",     formats:  ["color"]}
     * @ojstylevariable oj-button-borderless-chrome-text-color-selected-disabled   {description: "Borderless chrome button disabled selected text color",       formats:  ["color"]}
     * @memberof oj.ojButton
     */
    // ---------------- outlined buttons -----------------------
    /**
     * @ojstylevariableset oj-button-css-set5
     * @ojdisplayname Outlined buttons
     * @ojstylevariable oj-button-outlined-chrome-bg-color                         {description: "Outlined chrome button background color",                     formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color                     {description: "Outlined chrome button border color",                         formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color                       {description: "Outlined chrome button text color",                           formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-bg-color-hover                   {description: "Outlined chrome button hover background color",               formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color-hover               {description: "Outlined chrome button hover border color",                   formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color-hover                 {description: "Outlined chrome button hover text color",                     formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-bg-color-active                  {description: "Outlined chrome button active background color",              formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color-active              {description: "Outlined chrome button active border color",                  formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color-active                {description: "Outlined chrome button active text color",                    formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-bg-color-selected                {description: "Outlined chrome button selected background color",            formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color-selected            {description: "Outlined chrome button selected border color",                formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color-selected              {description: "Outlined chrome button selected text color",                  formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-bg-color-selected-hover          {description: "Outlined chrome button selected hover background color",      formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color-selected-hover      {description: "Outlined chrome button selected hover border color",          formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color-selected-hover        {description: "Outlined chrome button selected hover text color",            formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-bg-color-disabled                {description: "Outlined chrome button disabled background color",            formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color-disabled            {description: "Outlined chrome button disabled border color",                formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color-disabled              {description: "Outlined chrome button disabled text color",                  formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-bg-color-selected-disabled       {description: "Outlined chrome button selected disabled background color",   formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-border-color-selected-disabled   {description: "Outlined chrome button selected disabled border color",       formats:  ["color"]}
     * @ojstylevariable oj-button-outlined-chrome-text-color-selected-disabled     {description: "Outlined chrome button selected disabled text color",         formats:  ["color"]}
     * @memberof oj.ojButton
     */
    // ---------------- solid buttons -----------------------
    /**
     * @ojstylevariableset oj-button-css-set6
     * @ojdisplayname Solid buttons
     * @ojstylevariable oj-button-solid-chrome-bg-color              {description: "Solid chrome button background color",           formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color          {description: "Solid chrome button border color",               formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color            {description: "Solid chrome button text color",                 formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-bg-color-hover        {description: "Solid chrome button hover background color",     formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color-hover    {description: "Solid chrome button hover border color",         formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color-hover      {description: "Solid chrome button hover text color",           formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-bg-color-active       {description: "Solid chrome button active background color",    formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color-active   {description: "Solid chrome button active border color",        formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color-active     {description: "Solid chrome button active text color",          formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-bg-color-selected     {description: "Solid chrome button selected background color",  formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color-selected {description: "Solid chrome button selected border color",      formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color-selected   {description: "Solid chrome button selected text color",        formats: ["color"]}
     * @ojstylevariable oj-button-solid-chrome-bg-color-selected-hover         {description: "Solid chrome button selected hover background color",     formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color-selected-hover     {description: "Solid chrome button selected hover border color",         formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color-selected-hover       {description: "Solid chrome button selected hover text color",           formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-bg-color-disabled               {description: "Solid chrome button disabled background color",           formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color-disabled           {description: "Solid chrome button disabled border color",               formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color-disabled             {description: "Solid chrome button disabled text color",                 formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-bg-color-selected-disabled      {description: "Solid chrome button disabled selected background color",  formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-border-color-selected-disabled  {description: "Solid chrome button disabled selected border color",      formats:  ["color"]}
     * @ojstylevariable oj-button-solid-chrome-text-color-selected-disabled    {description: "Solid chrome button disabled selected text color",        formats:  ["color"]}
     * @memberof oj.ojButton
     */
    // ---------------- call to action buttons -----------------------
    /**
     * @ojstylevariableset oj-button-css-set7
     * @ojdisplayname Call to action buttons
     * @ojstylevariable oj-button-call-to-action-chrome-bg-color             {description: "Call to action chrome button background color",         formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-border-color         {description: "Call to action chrome button border color",             formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-text-color           {description: "Call to action chrome button text color",               formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-bg-color-hover       {description: "Call to action chrome button hover background color",   formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-border-color-hover   {description: "Call to action chrome button hover border color",       formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-text-color-hover     {description: "Call to action chrome button hover text color",         formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-bg-color-active      {description: "Call to action chrome button active background color",  formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-border-color-active  {description: "Call to action chrome button active border color",      formats:  ["color"]}
     * @ojstylevariable oj-button-call-to-action-chrome-text-color-active    {description: "Call to action chrome button active text color",        formats:  ["color"]}
     * @memberof oj.ojButton
     */
    // ---------------------------------- Styling oj-button end------------------------------------

    // ---------------------------------- oj-buttonset virtual doclets ------------------------------------
    // API doc for inherited methods with no JS in this file:

    // Fragments:

    /**
     * <p>The &lt;oj-buttonset-one> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
     * accepted children and slots.</p>
     *
     * @ojchild Default
     * @memberof oj.ojButtonsetOne
     * @ojshortdesc The oj-buttonset-one element accepts oj-option elements as children.
     * @ojpreferredcontent ["OptionElement"]
     *
     * @example <caption>Initialize the Buttonset with child content specified:</caption>
     * &lt;oj-buttonset-one>
     *   &lt;oj-option value="btn1">Button 1&lt;/oj-option>
     *   &lt;oj-option value="btn2">Button 2&lt;/oj-option>
     *   &lt;oj-option value="btn3">Button 3&lt;/oj-option>
     * &lt;/oj-buttonset-one>
     */

    /**
     * <p>The &lt;oj-buttonset-many> element accepts <code class="prettyprint">oj-option</code> elements as children. See the [oj-option]{@link oj.ojOption} documentation for details about
     * accepted children and slots.</p>
     *
     * @ojchild Default
     * @memberof oj.ojButtonsetMany
     * @ojshortdesc The oj-buttonset-many element accepts oj-option elements as children.
     * @ojpreferredcontent ["OptionElement"]
     *
     * @example <caption>Initialize the Buttonset with child content specified:</caption>
     * &lt;oj-buttonset-many>
     *   &lt;oj-option value="btn1">Button 1&lt;/oj-option>
     *   &lt;oj-option value="btn2">Button 2&lt;/oj-option>
     *   &lt;oj-option value="btn3">Button 3&lt;/oj-option>
     * &lt;/oj-buttonset-many>
     */

    /**
     * <p>All Buttonset touch interaction is with the individual buttons.  See the [JET Button]{@link oj.ojButton} touch gesture doc.
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojButtonset
     * @instance
     */

    /**
     * <p>JET Buttonset is a single tabstop, with arrow-key navigation within the buttonset, as follows:
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Navigate to the previous enabled button on the left, wrapping around at the end.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Navigate to the next enabled button on the right, wrapping around at the end.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>See also the [JET Button]{@link oj.ojButton} keyboard doc, for details on interacting with
     * the individual buttons.
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojButtonset
     * @instance
     */
    oj.__registerWidget('oj.ojButtonset', $.oj.baseComponent, {
      // private.  Was an undocumented JQUI option, which we removed, so I moved from options to here and added underscore.  Leave unquoted so gets renamed by GCC as desired.
      _items:
        'button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a',

      widgetEventPrefix: 'oj',

      // options is in externs.js.  TODO: same as other prototype fields.
      options: {
        /**
         * The <code class="prettyprint">value</code> attribute indicates which <code class="prettyprint">oj-option</code> in the Buttonset is selected.
         * It corresponds to the <code class="prettyprint">value</code> attribute of the <code class="prettyprint">oj-option</code>, which should always be set.
         *
         * <code class="prettyprint">value</code> is any type equal to the <code class="prettyprint">value</code> attribute of the selected <code class="prettyprint">oj-option</code>.  The attribute is
         * <code class="prettyprint">null</code> if and only if no <code class="prettyprint">oj-option</code> is selected.  Thus, an n-<code class="prettyprint">oj-option</code> group has n+1 valid
         * <code class="prettyprint">value</code> values: the n <code class="prettyprint">oj-option</code> values, and <code class="prettyprint">null</code> .
         *
         * {@ojinclude "name":"buttonsetCommonValue"}
         *
         * @name value
         * @memberof oj.ojButtonsetOne
         * @instance
         * @type {any}
         * @default null
         * @ojwriteback
         * @ojshortdesc Indicates which oj-option in the buttonset is selected.
         * @ojeventgroup common
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">value</code> attribute specified:</caption>
         * &lt;oj-buttonset-one value='bold'>&lt;/oj-buttonset-one>
         *
         * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
         * // Get one
         * var value = myButtonset.value;
         *
         * // Set one.  (No property change event will be fired.)
         * myButtonset.value = 'bold';
         */
        /**
         * The <code class="prettyprint">value</code> attribute indicates which <code class="prettyprint">oj-option</code>s in the Buttonset are selected.
         * It corresponds to the <code class="prettyprint">value</code> attribute of those elements, which should always be set.
         *
         * <code class="prettyprint">value</code> is a possibly empty, non-<code class="prettyprint">null</code> string array containing the <code class="prettyprint">value</code>
         * attributes of the selected <code class="prettyprint">oj-option</code>s.  This array has "set", not "list", semantics; i.e. order is neither important nor guaranteed.
         * Thus, an n-<code class="prettyprint">oj-option</code> set has 2^n valid <code class="prettyprint">value</code> values: the 2^n possible subsets of n <code class="prettyprint">oj-option</code>s.
         *
         * {@ojinclude "name":"buttonsetCommonValue"}
         *
         * @name value
         * @memberof oj.ojButtonsetMany
         * @instance
         * @type {Array.<any>|null}
         * @default null
         * @ojwriteback
         * @ojshortdesc Indicates which oj-options in the buttonset are selected.
         * @ojeventgroup common
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">value</code> attribute specified:</caption>
         * &lt;oj-buttonset-many value='{{["bold", "italic"]}}'>&lt;/oj-buttonset-many>
         *
         * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization:</caption>
         * // Get one (if many)
         * var value = myButtonset.value[0];
         *
         * // Get all
         * var values = myButtonset.value;
         *
         * // Set one.  (If many. No property change event will be fired.)
         * myButtonset.value[1] = 'bold';
         *
         * // Set all.
         * myButtonset.value = ["bold", "italic"];
         */
        /**
         * <p>In all other cases, <code class="prettyprint">value</code> is <code class="prettyprint">null</code>.
         *
         * <p>It's still possible for the <code class="prettyprint">value</code> attribute and DOM to get out of sync by other means.
         * In this case, the app is responsible for updating the <code class="prettyprint">value</code> attribute.  A typical case is
         * when the set of Buttons contained in the Buttonset changes, possibly due to a Knockout binding, in which case the app must first call
         * <code class="prettyprint">refresh</code> (as in all cases when the DOM changes underneath a component), and then
         * update the <code class="prettyprint">value</code> attribute to the desired value.
         *
         * <p>Often there is no need to listen for this event, since the
         * <code class="prettyprint">value</code> binding, discussed above, will update the bound observable whenever the
         * <code class="prettyprint">value</code> state changes.  The declarative binding is often preferable to an explicit listener.
         *
         * <p>A click listener should not be used to detect changes to the <code class="prettyprint">value</code> state.
         * The attribute <code class="prettyprint">value</code> binding and/or
         * the <code class="prettyprint">valueChange</code> event should be used instead.
         *
         * @memberof oj.ojButtonset
         * @instance
         * @ojfragment buttonsetCommonValue
         */
        checked: null,

        /**
         * {@ojinclude "name":"buttonsetCommonChroming"}
         *
         * @name chroming
         * @memberof oj.ojButtonsetOne
         * @instance
         * @type {string}
         * @ojvalue {string} "solid" Solid buttons stand out, and direct the user's attention to the most important actions in the UI. Note that this option is not supported in the Redwood theme.
         * @ojvalue {string} "outlined" Outlined buttons are salient, but lighter weight than solid buttons. Outlined buttons are useful for secondary actions.
         * @ojvalue {string} "borderless" Borderless buttons are the least prominent variation. Borderless buttons are useful for supplemental actions that require minimal emphasis.
         * @ojvalue {string} "full" Please use solid instead. In typical themes, full-chrome buttons always have chrome.
         * @ojvalue {string} "half" In typical themes, half-chrome buttons acquire chrome only in their hover, active, and selected states.
         * @ojshortdesc Indicates in what states the buttonset has chrome (background and border).
         * @ojdeprecated [{target:'propertyValue', for:"half", since: "6.0.0", description: "This value will be removed in the future. Please use borderless instead."},
         *                {target:'propertyValue', for:"full", since: "6.0.0", description: "This value will be removed in the future. Please use solid instead."}]
         *
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">chroming</code> attribute specified:</caption>
         * &lt;oj-buttonset-one chroming='borderless'>&lt;/oj-buttonset-one>
         *
         * @example <caption>Get or set the <code class="prettyprint">chroming</code> property after initialization:</caption>
         * // getter
         * var chromingValue = myButtonset.chroming;
         *
         * // setter
         * myButtonset.chroming = 'borderless';
         *
         * @example <caption>Set the default in the theme (CSS) :</caption>
         * --oj-private-buttonset-global-chroming-default: borderless !default;
         */
        /**
         * {@ojinclude "name":"buttonsetCommonChroming"}
         *
         * @name chroming
         * @memberof oj.ojButtonsetMany
         * @instance
         * @type {string}
         * @ojvalue {string} "solid" Solid buttons stand out, and direct the user's attention to the most important actions in the UI. Note that this option is not supported in the Redwood theme.
         * @ojvalue {string} "outlined" Outlined buttons are salient, but lighter weight than solid buttons. Outlined buttons are useful for secondary actions.
         * @ojvalue {string} "borderless" Borderless buttons are the least prominent variation. Borderless buttons are useful for supplemental actions that require minimal emphasis.
         * @ojvalue {string} "full" Please use solid instead. In typical themes, full-chrome buttons always have chrome.
         * @ojvalue {string} "half" In typical themes, half-chrome buttons acquire chrome only in their hover, active, and selected states.
         * @ojshortdesc Indicates in what states the button has chrome (background and border).
         * @ojdeprecated [{target:'propertyValue', for:"half", since: "6.0.0", description: "This value will be removed in the future. Please use borderless instead."},
         *                {target:'propertyValue', for:"full", since: "6.0.0", description: "This value will be removed in the future. Please use solid instead."}]
         * @ojshortdesc Indicates in what states the buttonset has chrome (background and border).
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">chroming</code> attribute specified:</caption>
         * &lt;oj-buttonset-many chroming='borderless'>&lt;/oj-buttonset-many>
         *
         * @example <caption>Get or set the <code class="prettyprint">chroming</code> property after initialization:</caption>
         * // getter
         * var chromingValue = myButtonset.chroming;
         *
         * // setter
         * myButtonset.chroming = 'borderless';
         *
         * @example <caption>Set the default in the theme (CSS) :</caption>
         * --oj-private-buttonset-global-chroming-default: borderless !default;
         */

        /**
         * <p>Indicates in what states the buttonset's buttons have chrome (background and border).
         *
         * <p>A buttonset's chroming must be set by setting this buttonset attribute (or setting the [chroming]{@link oj.ojToolbar#chroming} attribute
         * of a containing toolbar).
         *
         * <p>The default chroming varies by theme and containership as follows:
         * <ul>
         *   <li>If the buttonset is in a toolbar, then the default chroming is the current value of the toolbar's [chroming]{@link oj.ojToolbar#chroming} attribute.</li>
         *   <li>Else, the default chroming value is controlled by the theme.
         * </ul>
         *
         * <p>Once a value has been set on this buttonset attribute, that value applies regardless of theme and containership.
         *
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @since 1.2.0
         * @ojfragment buttonsetCommonChroming
         */
        chroming: 'solid',

        /**
         * {@ojinclude "name":"buttonsetCommonDisplay"}
         *
         * @name display
         * @memberof oj.ojButtonsetOne
         * @instance
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @ojvalue {string} "label" Display only the label.
         * @default "all"
         * @ojshortdesc Specifies whether the buttonset displays label and icons, or just icons.
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">display</code> attribute specified:</caption>
         * &lt;oj-buttonset-one display='icons'>&lt;/oj-buttonset-one>
         *
         * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
         * // getter
         * var displayValue = myButtonset.display;
         *
         * // setter
         * myButtonset.display = 'icons';
         */
        /**
         * {@ojinclude "name":"buttonsetCommonDisplay"}
         *
         * @name display
         * @memberof oj.ojButtonsetMany
         * @instance
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @ojvalue {string} "label" Display only the label.
         * @default "all"
         * @ojshortdesc Specifies whether the buttonset displays label and icons, or just icons.
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">display</code> attribute specified:</caption>
         * &lt;oj-buttonset-many display='icons'>&lt;/oj-buttonset-many>
         *
         * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
         * // getter
         * var displayValue = myButtonset.display;
         *
         * // setter
         * myButtonset.display = 'icons';
         */
        /**
         * <p>Whether to display both the label and icons (<code class="prettyprint">"all"</code>)
         * or just the label (<code class="prettyprint">"label"</code>)
         * or just the icons (<code class="prettyprint">"icons"</code>) of the buttons.  In the latter case, the label is displayed in a tooltip instead.
         *
         * <p>The <code class="prettyprint">display</code> attribute will be ignored if no icons exist in the button.
         *
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @ojfragment buttonsetCommonDisplay
         */
        display: 'all',

        /**
         * {@ojinclude "name":"buttonsetCommonDisabled"}
         *
         * @member
         * @name disabled
         * @memberof oj.ojButtonsetOne
         * @instance
         * @type {boolean}
         * @default false
         * @ojshortdesc Specifies that the buttonset element should be disabled.
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">disabled</code> attribute specified:</caption>
         * &lt;oj-buttonset-one disabled='true'>&lt;/oj-buttonset-one>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabledValue = myButtonset.disabled;
         *
         * // setter
         * myButtonset.disabled = true;
         */
        /**
         * {@ojinclude "name":"buttonsetCommonDisabled"}
         *
         * @member
         * @name disabled
         * @memberof oj.ojButtonsetMany
         * @instance
         * @type {boolean}
         * @default false
         * @ojshortdesc Specifies that the buttonset element should be disabled.
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">disabled</code> attribute specified:</caption>
         * &lt;oj-buttonset-many disabled='true'>&lt;/oj-buttonset-many>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabledValue = myButtonset.disabled;
         *
         * // setter
         * myButtonset.disabled = true;
         */
        /**
         * <p>Setting the Buttonset's <code class="prettyprint">disabled</code> attribute effectively disables all its Buttons, without affecting
         * their <code class="prettyprint">disabled</code> attributes.  Thus, a Button is effectively disabled if either its own
         * <code class="prettyprint">disabled</code> attribute is set, or the Buttonset's <code class="prettyprint">disabled</code> attribute is set.
         *
         * @member
         * @name disabled
         * @memberof oj.ojButtonset
         * @instance
         * @ojfragment buttonsetCommonDisabled
         */
        // disabled option declared in superclass, but we still want the above API doc

        // Consider getting rid of this option in the future.  Under his proposal (whose particulars we agreed needed to be ironed out),
        // rather than using this option to turn off Bset's handling, Bset would always handle arrow keys and preventDefault or stopPropagation.  Arrow
        // keys would no longer wrap around when reach end of Bset, in which case Bset would let the event bubble up to Toolbar (or to whoever if
        // not in a TB).  Any edge cases?  e.g. with tabstops, TB contents with special arrow-key behavior like inputTexts, etc.?
        /**
         * {@ojinclude "name":"buttonsetCommonFocusManagement"}
         *
         * @name focusManagement
         * @memberof oj.ojButtonsetOne
         * @instance
         * @type {string}
         * @ojvalue {string} "oneTabstop" Focus management is enabled.  The Buttonset is a single tabstop with arrow-key navigation.
         * @ojvalue {string} "none" Focus management is disabled, to avoid interfering with the focus management of a containing component.
         * @default "oneTabstop"
         * @ojshortdesc Should be set to none when the buttonset is placed within a toolbar.
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">focusManagement</code> attribute specified:</caption>
         * &lt;oj-buttonset-one focus-management='none'>&lt;/oj-buttonset-one>
         *
         * @example <caption>Get or set the <code class="prettyprint">focusManagement</code> property after initialization:</caption>
         * // getter
         * var focusManagementValue = myButtonset.focusManagement;
         *
         * // setter
         * myButtonset.focusManagement = 'none';
         */
        /**
         * {@ojinclude "name":"buttonsetCommonFocusManagement"}
         *
         * @name focusManagement
         * @memberof oj.ojButtonsetMany
         * @instance
         * @type {string}
         * @ojvalue {string} "oneTabstop" Focus management is enabled.  The Buttonset is a single tabstop with arrow-key navigation.
         * @ojvalue {string} "none" Focus management is disabled, to avoid interfering with the focus management of a containing component.
         * @default "oneTabstop"
         * @ojshortdesc Should be set to none when the buttonset is placed within a toolbar.
         *
         * @example <caption>Initialize the Buttonset with the <code class="prettyprint">focusManagement</code> attribute specified:</caption>
         * &lt;oj-buttonset-many focus-management='none'>&lt;/oj-buttonset-many>
         *
         * @example <caption>Get or set the <code class="prettyprint">focusManagement</code> property after initialization:</caption>
         * // getter
         * var focusManagementValue = myButtonset.focusManagement;
         *
         * // setter
         * myButtonset.focusManagement = 'none';
         */
        /**
         * The <code class="prettyprint">focusManagement</code> attribute should be set to <code class="prettyprint">"none"</code> when the
         * Buttonset is placed in a [JET Toolbar]{@link oj.ojToolbar}.  This allows the Toolbar to manage the focus with no interference from the Buttonset,
         * so that arrow keys move within the entire Toolbar, not just within the Buttonset.
         *
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @ojfragment buttonsetCommonFocusManagement
         */
        focusManagement: 'oneTabstop',

        /**
         * {@ojinclude "name":"buttonsetCommonLabelledBy"}
         *
         * @name labelledBy
         * @memberof oj.ojButtonsetOne
         * @public
         * @instance
         * @type {string|null}
         * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documentation for more information.
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelId = myButtonset.labelledBy;
         *
         * // setter
         * myButtonset.labelledBy = "labelId";
         */
        /**
         * {@ojinclude "name":"buttonsetCommonLabelledBy"}
         *
         * @name labelledBy
         * @memberof oj.ojButtonsetMany
         * @public
         * @instance
         * @type {string|null}
         * @ojshortdesc Establishes a relationship between this component and another element, typically an oj-label custom element. See the Help documentation for more information.
         *
         * @example <caption>Get or set the <code class="prettyprint">labelledBy</code> property after initialization:</caption>
         * // getter
         * var labelId = myButtonset.labelledBy;
         *
         * // setter
         * myButtonset.labelledBy = "labelId";
         */
        /**
         * It is used to establish a relationship between this component and another element.
         * A common use is to tie the oj-label and the oj-buttonset together for accessibility.
         * The oj-label custom element has an id, and you use the labelled-by attribute
         * to tie the two components together to facilitate correct screen reader behavior.
         *
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @ojfragment buttonsetCommonLabelledBy
         */
        labelledBy: null,

        /**
         * {@ojinclude "name":"buttonsetCommonDescribedBy"}
         *
         * @name describedBy
         * @memberof oj.ojButtonsetOne
         * @public
         * @instance
         * @type {?string}
         * @ojshortdesc buttonset's oj-label automatically sets described-by to make it accessible.
         * It is not meant to be set by application developer.
         *
         * @example <caption>Get or set the <code class="prettyprint">describedBy</code> property after initialization:</caption>
         * // getter
         * var descById = myComp.describedBy;
         *
         * // setter
         * myComp.describedBy = "someId";
         */
        /**
         * {@ojinclude "name":"buttonsetCommonDescribedBy"}
         *
         * @name describedBy
         * @memberof oj.ojButtonsetMany
         * @public
         * @instance
         * @type {?string}
         * @ojshortdesc buttonset's oj-label automatically sets described-by to make it accessible.
         * It is not meant to be set by application developer.
         *
         * @example <caption>Get or set the <code class="prettyprint">describedBy</code> property after initialization:</caption>
         * // getter
         * var descById = myComp.describedBy;
         *
         * // setter
         * myComp.describedBy = "someId";
         */
        /**
         * The oj-label sets the described-by attribute programmatically on the buttonset component.
         * This attribute is not meant to be set by an application developer directly.
         * The described-by is copied to the aria-describedby
         * attribute on the component's inner dom element, and it is needed
         * for accessibility.
         * @expose
         * @memberof oj.ojButtonset
         * @instance
         * @ojfragment buttonsetCommonDescribedBy
         */
        describedBy: null

        // Events
      },

      // If this is a radio or checkbox buttonset, and the specified checked value is valid,
      //   then sets it on the buttons' checked properties in the DOM,
      // Else if it's the non-radio, non-checkbox case and null was passed, which is the one and only valid value for that case,
      //   then doesn't change DOM.
      // Else it's an invalid value,
      //   so throws.
      // Does not set oj-selected, so must call _applyCheckedStateFromDom() after this.
      //   TBD: optionally, this method could do that work, perhaps controlled by a param
      // This method is called by _setOption("checked", ...) and _ComponentCreate > _setup.
      // Does NOT require the buttons to already be JET Buttons (useful for _setup caller).
      _setCheckedOnDom: function (checked, $buttons) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var type = $.type(checked);
        var valid;
        var allCheckboxes;
        var elem = this.element[0];

        // whether buttonset contains exclusively checkboxes, therefore is buttonset many
        allCheckboxes =
          elem.tagName === 'OJ-BUTTONSET-MANY' ||
          ($buttons.length > 0 && $buttons.filter('input[type=checkbox]').length === $buttons.length);

        // requires an array in buttonset many case
        if (allCheckboxes && type !== 'array') {
          throw new Error("Invalid 'checked' value set on JET Buttonset: " + checked);
        }

        valid = this._setCheckedOnButtons(checked, $buttons, type, allCheckboxes);

        valid = valid || checked === null || checked === undefined;

        if (!valid && (!this._IsCustomElement() || $buttons.length === elem.children.length)) {
          throw new Error("Invalid 'checked' value set on JET Buttonset: " + checked);
        }
      },
      // does comparsion and sets checked on inputs
      // for custom elements it will accept objects as values on inputs and will get the value from oj option rather than the input
      // compares references first
      // if any references match it will not do object comparison
      // if there are no reference matches and it is custom element and it is an object or array containing at least one object do deep comparison on the objects
      _setCheckedOnButtons: function (checked, $buttons, type, isMany) {
        // loop once for reference comparison
        var checkedFoundCount = this._shallowCompare(checked, $buttons, isMany);

        // loop second for deep object comparison, supported in custom elements only, and only if no references were found in prior check
        if (this._shouldDeepCompare(checked, isMany, checkedFoundCount)) {
          checkedFoundCount = this._deepCompare(checked, $buttons, isMany, checkedFoundCount);
        }

        return isMany ? checkedFoundCount === checked.length : checkedFoundCount === 1;
      },

      // compares references and increments the match counter
      _shallowCompare: function (checked, $buttons, isMany) {
        var self = this;
        var checkedFoundCount = 0;
        $buttons.each(function () {
          // gets value off ojOption in custom element case
          var value = self._getInputValue(this);

          // if a buttonset many, checked is an array so do indexOf for reference comparison
          // if a buttonset one, check reference
          if (isMany ? checked.indexOf(value) > -1 : value === checked) {
            this.checked = true;
            checkedFoundCount += 1;
          } else {
            this.checked = false;
          }
        });
        return checkedFoundCount;
      },
      // checks if deep comparison needed
      // if buttonset many - deep compare if we have not found all of our values in the value array
      // if buttonset one -  deep compare if we did not find the value
      _shouldDeepCompare: function (checked, isMany, checkedFoundCount) {
        return isMany ? checkedFoundCount !== checked.length : !checkedFoundCount;
      },

      // compares objects deeply using
      _deepCompare: function (checked, $buttons, isMany, checkedFoundCount) {
        var resultCheckedFoundCount = checkedFoundCount;
        var self = this;
        $buttons.each(function () {
          // gets value off ojOption in custom element case
          var value = self._getInputValue(this);

          // if array loop over values and only compare objects
          if (isMany) {
            for (var i = 0; i < checked.length; i++) {
              // need to compare all types within many due to parsing
              if (self._deepCompareValues(value, checked[i])) {
                this.checked = true;
                resultCheckedFoundCount += 1;
              }
            }
          } else if (self._deepCompareValues(value, checked)) {
            this.checked = true;
            resultCheckedFoundCount += 1;
          }
        });
        return resultCheckedFoundCount;
      },

      // performs deep comparison using public method if available otherwise internal compareValues
      _deepCompareValues: function (value, checked) {
        // ojCompareValues is a custom comparator that returns 0 if the values are equal
        return $.type(value) === 'object' && value.ojCompareValues
          ? value.ojCompareValues(value, checked) === 0
          : oj.Object.compareValues(value, checked);
      },

      // gets value from ojOption in custom element case
      _getInputValue: function (input) {
        return this._IsCustomElement() ? this._getOjOptionFromInput(input).value : input.value;
      },

      // gets the oj option associated with an input
      _getOjOptionFromInput: function (input) {
        // oj option is first child of preceeding label
        return input.previousElementSibling.children[0];
      },

      // if all buttons are radios with same group, returns value attr of selected radio (string), or null if none selected
      // else if all buttons are checkboxes, returns non-null, possibly empty string array containing values of selected checkboxes
      // else returns undefined.  In the API we use null, not undefined, for this case, so callers should map undefined to null before setting on DOM.
      // NOTE: Called from _InitOptions, so very limited component state is available!
      _getCheckedFromDom: function ($buttons) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var checked;
        var isRadio = null;
        var name = null;
        var self = this;

        $buttons.each(function () {
          // at this point, all previous buttons, if any, were all radios in same group, or were all checkboxes
          var tagName = this.tagName.toLowerCase();
          if (tagName !== 'input') {
            checked = undefined;
            return false; // stop iterating
          }

          var currentType = this.type.toLowerCase();
          var currentIsRadio;
          var currentName;

          if (currentType === 'radio') {
            currentIsRadio = true;
            currentName = this.name.toLowerCase();
          } else if (currentType === 'checkbox') {
            currentIsRadio = false;
            currentName = null;
          } else {
            checked = undefined;
            return false; // stop iterating
          }

          // at this point, current button is input of type radio or checkbox

          // If this is not the first button, then bail if:
          // - this is a radio and previous were checkboxes or vice versa
          // - this is a radio in a different group than previous ones, which can happen
          //   if the group names are different, or if the names are all "", in which
          //   case each radio is in a separate radio group.
          if (
            checked !== undefined && // must be !== not !=
            (currentIsRadio !== isRadio || currentName !== name || (isRadio && !name))
          ) {
            checked = undefined;
            return false; // stop iterating
          }

          // at this point, all buttons so far including this one are either all radios in same group, or are all checkboxes

          var value = self._getInputValue(this);
          if (checked === undefined) {
            // this is first button
            if (currentIsRadio) {
              if (this.checked) {
                checked = value;
              } else {
                checked = null;
              }
            } else if (this.checked) {
              checked = [value];
            } else {
              checked = [];
            }
            isRadio = currentIsRadio;
            name = currentName;
          } else if (this.checked) {
            if (isRadio) {
              checked = value;
            } else {
              checked.push(value);
            }
          } // else not first button and not checked, so leave "checked" at whatever value we set on previous iteration
          return undefined;
        });

        return checked;
      },

      _CompareOptionValues: function (option, value1, value2) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (option === 'checked') {
          // handle null, string, and (rare) identically equal arrays
          if (value1 === value2) {
            return true;
          }
          return (
            $.type(value1) === 'array' &&
            $.type(value2) === 'array' &&
            this._compareArraysAsSets(value1, value2)
          );
        }

        return this._superApply(arguments);
      },

      // Params must be arrays.  Returns true iff the arrays have the same set of elements regardless of order.
      _compareArraysAsSets: function (first, second) {
        return (
          !first.some(function (elem) {
            return second.indexOf(elem) < 0;
          }) &&
          !second.some(function (elem) {
            return first.indexOf(elem) < 0;
          })
        );
      },

      // remove non oj-options from DOM
      _removeNonOjOptions: function () {
        this.element.children(':not(oj-option)').remove();
      },

      // Add the custom option renderer to all oj options
      _processOjOptions: function () {
        var self = this;
        var ojOptions = this.element[0].querySelectorAll('oj-option');

        $.each(ojOptions, function (i, option) {
          // eslint-disable-next-line no-param-reassign
          option.customOptionRenderer = self._customOptionRenderer.bind(self);
        });
      },

      // Call render on all the oj options directly
      _customOptionRenderer: function (option) {
        this._removeOptionDecoration(option);
        this._addOptionDecoration(option);
      },

      // Wrap the oj option in a label and add an input as a sibling
      _addOptionDecoration: function (option) {
        // add classes to slots and wrap text if applicable
        this._addOptionClasses(option);

        // is the buttonset one or many
        var isOne = this.element[0].tagName === 'OJ-BUTTONSET-ONE';
        var type = isOne ? 'radio' : 'checkbox';

        // get values from the oj option to set on the input
        var value = option.value;
        var disabled = option.disabled;

        // create label/input to decorate oj option
        var input = document.createElement('input');
        var label = document.createElement('label');

        // input needs an id so label can set the for attribute
        $(input).uniqueId();
        input.value = value;
        input.type = type;
        input.disabled = disabled;

        // set the label for attribute
        var id = input.id;
        label.htmlFor = id;

        // if a radio buttonset need a uniform name, create one using the first input id
        if (isOne) {
          if (!this._name) {
            this._name = '_n_' + id;
          }
          input.name = this._name;
        }

        // rearrange the dom
        option.parentNode.insertBefore(label, option); // @HTMLUpdateOK
        label.appendChild(option); // @HTMLUpdateOK
        label.parentNode.insertBefore(input, label.nextElementSibling); // @HTMLUpdateOK

        // reset buttonset group properties
        this._setup(false);
        this._setCheckedOnDom(this.options.checked, this.$buttons); // throws if checked option invalid
        this.$buttons.each(function () {
          $(this).data('oj-ojButton')._applyCheckedStateFromDom(false);
        });
      },

      // remove the dom that we generated excluding the wrapped span
      // destroy the button and leave just what was originally there
      _removeOptionDecoration: function (option) {
        var parentLabel = option.parentNode;

        if (parentLabel.tagName === 'LABEL') {
          this._removeOptionClasses(option);

          var input = $(parentLabel).siblings('.oj-button-input');

          input.ojButton('destroy');

          input.removeUniqueId();

          input.remove();
          parentLabel.parentNode.insertBefore(option, parentLabel); // @HTMLUpdateOK
          parentLabel.parentNode.removeChild(parentLabel);
        }
      },

      // add needed CSS Classes to slots and wrap the text spans
      _addOptionClasses: function (option) {
        var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(option);
        var text = slotMap[''] ? slotMap[''] : null;
        var startIcon = slotMap.startIcon ? slotMap.startIcon[0] : null;
        var endIcon = slotMap.endIcon ? slotMap.endIcon[0] : null;

        if (startIcon) {
          startIcon.classList.add('oj-button-icon');
          startIcon.classList.add('oj-start');
        }

        if (text) {
          for (var i = 0; i < text.length; i++) {
            var currentText = text[i];
            var wrapperSpan = currentText;
            if (currentText.nodeType === 3) {
              wrapperSpan = document.createElement('span');
              currentText.parentNode.insertBefore(wrapperSpan, currentText); // @HTMLUpdateOK
              wrapperSpan.appendChild(currentText); // @HTMLUpdateOK
            }

            wrapperSpan.classList.add('oj-button-text');
          }
        }

        if (endIcon) {
          endIcon.classList.add('oj-button-icon');
          endIcon.classList.add('oj-end');
        }
      },

      // remove needed CSS Classes to slots
      _removeOptionClasses: function (option) {
        var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(option);
        var text = slotMap[''] ? slotMap[''] : null;
        var startIcon = slotMap.startIcon ? slotMap.startIcon[0] : null;
        var endIcon = slotMap.endIcon ? slotMap.endIcon[0] : null;

        if (startIcon) {
          startIcon.classList.remove('oj-button-icon');
          startIcon.classList.remove('oj-start');
        }

        if (text) {
          for (var i = 0; i < text.length; i++) {
            text[i].classList.remove('oj-button-text');
          }
        }

        if (endIcon) {
          endIcon.classList.remove('oj-button-icon');
          endIcon.classList.remove('oj-end');
        }
      },

      _InitOptions: function (originalDefaults, constructorOptions) {
        this._super(originalDefaults, constructorOptions);

        this.$buttons = this.element.find(this._items);

        // At create time, checked can be set via either option or DOM, i.e. the "checked" properties of the buttons.
        // If app set the option, then that wins over the DOM, in which case _ComponentCreate() will later set that value on the DOM.
        // Else DOM wins, in which case we set the option from the DOM here, with any remaining tasks done later in _ComponentCreate().

        if (!('checked' in constructorOptions)) {
          // if app didn't set option, then set the option from the DOM
          this.initCheckedFromDom = true;
          var checked = this._getCheckedFromDom(this.$buttons); // doesn't rely on any component state, e.g. this.foo

          // 3 cases:  (1) checkbox set, (2) radio group, and (3) none of the above.
          // Conceptually, the default value is [] for (1), and null for (2) and (3).
          // However, the value to which it's actually inited, in the declaration, is null in all 3 cases.
          //
          // Per discussion with architect, we want to update the option value in all cases where it's different than the
          // init value of null, but only fire the event if the new value is different than the conceptual default.
          //
          // The only problem case is when the new value is [], "no checkboxes checked".  To avoid firing the event in this
          // case, while still handling all other cases correctly, we update the ivar to [], the conceptual default,
          // for all checkbox / array cases, before calling option().
          //
          // Writeback is not relevant here, since this code block handles the case where no option value was supplied, in
          // which case there must not be an observable to write to.
          if ($.type(checked) === 'array' || this.element[0].tagName === 'OJ-BUTTONSET-MANY') {
            this.options.checked = [];
          }

          if (checked !== undefined) {
            this.option('checked', checked, { _context: { internalSet: true } }); // writeback not needed since "not in constructorOptions" means "not bound"
          }
        }
      },

      _ComponentCreate: function () {
        this._super();

        var elem = this.element[0];
        elem.setAttribute(Components._OJ_CONTAINER_ATTR, this.widgetName); // @HTMLUpdateOK
        elem.classList.add('oj-buttonset');
        elem.classList.add('oj-component');
        this._setRole(this.options.focusManagement);

        if (this._IsCustomElement()) {
          this._removeNonOjOptions();
          this._processOjOptions();
        }

        this._setup(true);
      },

      _NotifyContextMenuGesture: function (menu, event, eventType) {
        // Set launcher to the current tabbable button
        // For toggle buttons, launcher must be the hidden focusable input, but for Shift-F10 we want the CM aligned to the Button's root element, not that
        // hidden input.  This is no change from the default for push buttons, since in that case the root element and launcher (input) are the same.
        var currentButton = this.element.find(':oj-button[tabindex=0]');
        this._OpenContextMenu(event, eventType, {
          launcher: currentButton,
          position: { of: eventType === 'keyboard' ? currentButton.ojButton('widget') : event }
        });
      },

      _propagateDisabled: function (disabled) {
        var _disabled = !!disabled;
        this.$buttons.each(function () {
          $(this).data('oj-ojButton').__setAncestorComponentDisabled(_disabled);
        });
      },

      _setRole: function (focusManagement) {
        var elem = this.element[0];
        if (focusManagement === 'oneTabstop') {
          elem.setAttribute('role', 'toolbar');
        } else {
          elem.removeAttribute('role');
        }
      },

      // eslint-disable-next-line no-unused-vars
      _setOption: function (key, value, flags) {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        var oldValue = this.options[key];

        // previously called super at end, so that optionChange (fired at end of super) is fired at very end, but now must call at start, so that
        // when the chroming case calls Button.refreshrefresh(), callee sees the new value of the option.
        this._superApply(arguments);

        if (key === 'disabled') {
          this._propagateDisabled(value);
          this._refreshTabStop();

          // Legacy code for widgets.  Toolbar custom element will listen for property change event on buttons.
          if (!this._IsCustomElement()) {
            // If this button is inside a toolbar, the toolbar needs to be refreshed for new disabled setting
            var $toolbarElem = $(this.element).closest('.oj-toolbar');
            if ($toolbarElem.length) {
              $toolbarElem.ojToolbar('refresh');
            }
          }
        } else if (key === 'checked') {
          // This "checked" block should run only if app called option(), but not if called because user clicked button,
          // since in the latter case, we know we passed a valid non-undefined value, and DOM is already up to date.
          // Fortunately, this is guaranteed, since _setOption is no longer called in the latter case.
          this._setCheckedOnDom(value, this.$buttons); // throws if checked option invalid

          // Set oj-selected on all buttons' DOM:
          this.$buttons.each(function () {
            $(this).data('oj-ojButton')._applyCheckedStateFromDom(false);
          });
        } else if (key === 'focusManagement') {
          this._setRole(value);
        } else if (key === 'chroming') {
          _setChromingClass(this.element[0], value);

          // refresh the buttons to make them re-fetch their chroming option, in case it's still set to the default dynamic getter,
          // which takes its value from the containing buttonset or toolbar if present.
          // TBD: Consider only calling refresh() on children that haven't had their chroming option set, i.e. those still using the dynamic getter.
          this.$buttons.ojButton('refresh');
        } else if (key === 'display') {
          this.$buttons.ojButton('option', key, value);
        } else if (key === 'labelledBy') {
          var $elem = this.element;
          this._labelledByUpdatedForSet($elem[0].id, oldValue, value, $elem);
        } else if (key === 'describedBy') {
          // This sets the aria-describedby on the correct dom node
          this._describedByUpdated(oldValue, value);
        }
      },

      // TODO: JSDoc says: "refresh() is required ... after a change to the disabled status of any of the buttons in the buttonset."  Instead, shouldn't
      // Button._setOption("disabled") look for a containing Buttonset and do the necessary housekeeping?
      // @inheritdoc
      refresh: function () {
        // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
        this._super();

        // Should not need to call refresh on oj-options. If the content of an oj-option is modified then
        // app should call refresh on the option not the container and that should trigger a re-render
        // only need to add custom renderer for case where something is added that the buttonset did not
        // know about before
        if (this._IsCustomElement()) {
          this._processOjOptions();
        }

        // Call this after _super(), which updates the list of containers (toolbar) that the buttonset is in, which must be updated
        // when _setup calls the chroming option getter.
        this._setup(false);
      },

      _setup: function (isCreate) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var self = this;
        var elem = this.element[0];
        this.isRtl = this._GetReadingDirection() === 'rtl';
        _setChromingClass(elem, this.options.chroming);

        if (isCreate && !this.initCheckedFromDom && !this._IsCustomElement()) {
          // if app provided a "checked" option, it wins over whatever's in the DOM.
          this._setCheckedOnDom(this.options.checked, this.$buttons); // throws if checked option invalid

          // At create time, whether set from DOM or option, checked option and checked props are now in synch, so we just need to
          // set .oj-selected on each button.  This is done below by either the _applyCheckedStateFromDom()
          // call (for existing buttons) or the initializer call (for new buttons).
        }

        if (!isCreate) {
          // it's refresh time.
          // If the DOM's checked state is out of synch with the checked option, it's either because
          // the app directly set the "checked" attr of an existing Button in the Buttonset, which we don't support (they should
          // have used the component API instead), or the set of buttons in the set has changed (possibly because a KO foreach
          // binding added/removed buttons).  In the latter case, we require that the app update the "checked" option, by setting
          // the bound observable (if present) or calling option() (otherwise).

          this.$buttons = this.element.find(this._items); // only needed at refresh time, since at create time this was already done in _InitOptions()
        }

        // buttonset styling should only be applied if this is a multi-button buttonset.  When a single button is wrapped in a buttonset, that's an implementation
        // detail to get the "checked" option; users still see it as a standalone button, and it should be themed as such.
        if (this.$buttons.length > 1) {
          elem.classList.add('oj-buttonset-multi');
        } else {
          elem.classList.remove('oj-buttonset-multi');
        }

        this.$buttons
          // refresh any buttons underneath us that already exist, like JQUI does
          // TBD:  Now that Bset has a checked option, the recursive refreshing of the Bset's buttons is necessary in more cases than before.
          //   Review whether it's still desirable to add a refresh() param that would allow turning off this recursive
          //   refreshing.  That was previously approved, but changing the default (compared to JQUI) was not approved.
          //   The refresh param wouldn't help for creates; for that we'd need to add a Buttonset option.
          //   See also _destroy() code comment.
          .filter(':oj-button')
          .ojButton('refresh')
          .each(function () {
            $(this).data('oj-ojButton')._applyCheckedStateFromDom(false); // set .oj-selected
          })
          .end()

          // Create buttons underneath us
          .not(':oj-button')
          .ojButton({ display: this.options.display }) // sets .oj-selected
          .end();

        // Update rounded corners, etc.
        for (var i = 0, len = this.$buttons.length; i < len; i++) {
          var btn = this.$buttons.eq(i).ojButton('widget')[0];
          btn.classList.remove('oj-buttonset-first');
          btn.classList.remove('oj-buttonset-last');
          if (i === 0) {
            btn.classList.add('oj-buttonset-first');
          } else if (i === len - 1) {
            btn.classList.add('oj-buttonset-last');
          }
        }

        // Must do this after creating the buttons above since callee calls Button API.
        // Must do this before the focus mgmt code, which needs to know which buttons are effectively disabled.
        // Must do this at refresh time, not just create time, in case new buttons were added to the Bset (whether
        // reparented or created e.g. by KO foreach).
        this._propagateDisabled(this.options.disabled);

        if (this.options.focusManagement === 'oneTabstop') {
          // When buttonset is binding listeners to buttons, use the Buttonset's eventNamespace, not the Button's
          // eventNamespace, to facilitate later unbinding only the Buttonset listeners.

          // For checkbox/radio, we're binding to inputs, not labels.

          // Put listeners on every button, b/c it's too unreliable to put them on the buttonset node and rely on event bubbling.
          // - E.g. bubbling doesn't work for antonym buttons (is this still true after the refactoring?) -- see comment on Button._setLabelOption().
          // - Likewise, focus mgmt can't just break if app listener stops propagation.
          // - Both of these problems still happen when using the delegation / selector overload of .on(); there is no special JQ bubbling magic.

          this.$buttons
            .unbind('keydown' + this.eventNamespace)
            .bind('keydown' + this.eventNamespace, function (event) {
              self._handleKeyDown(event, $(this));
            })

            .unbind('click' + this.eventNamespace)
            .bind('click' + this.eventNamespace, function () {
              if (!$(this).data('oj-ojButton')._IsEffectivelyDisabled()) {
                // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and
                // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked
                // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                self._setTabStop($(this));
              }
            })
            .unbind('focus' + this.eventNamespace)
            .bind('focus' + this.eventNamespace, function () {
              self._setTabStop($(this));
            });

          // the subset of Buttonset buttons that are enabled.  Effectively disabled buttons are not tabbable.
          this.$enabledButtons = this.$buttons.filter(function () {
            return !$(this).data('oj-ojButton')._IsEffectivelyDisabled();
          });

          this._initTabindexes(isCreate);
        }

        // since oj-label depends on oj-buttonset having an ID, check if the element has an id
        // and if not it will be generated and set on the oj-buttonset
        this.element.uniqueId();

        // copy labelledBy to aria-labelledBy
        this._labelledByUpdatedForSet(elem.id, null, this.options.labelledBy, this.element);

        // set describedby on the element as aria-describedby
        var describedBy = this.options.describedBy;

        if (describedBy) {
          this._describedByUpdated(describedBy);
        }
      },

      /**
       * If custom element, get the labelledBy option, and set this
       * onto the root dom element as aria-labelledby. We append "|label" so it matches the id that
       * is on the oj-label's label element.
       * @memberof oj.ojButtonset
       * @instance
       * @private
       */
      _labelledByUpdatedForSet: LabelledByUtils._labelledByUpdatedForSet,

      /**
       * When describedBy changes, we need to update the aria-described attribute.
       * @memberof oj.ojButtonset
       * @instance
       * @private
       */
      _describedByUpdated: LabelledByUtils._describedByUpdated,

      /**
       * Returns a jquery object of the elements representing the
       * content nodes (oj-option). This is used in LabelledByUtils to add
       * aria-describedby to the oj-option when there is a help icon
       * @protected
       * @override
       * @memberof oj.ojButtonset
       */
      _GetContentElement: function () {
        if (this.$buttons != null) {
          return this.$buttons;
        }

        this.$buttons = this.element.find(this._items);
        return this.$buttons;
      },

      // Update the current tabStop after _setOption("disabled")
      // Prereq: _propagateDisabled() must be called before this refresh
      _refreshTabStop: function () {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if (this.options.focusManagement === 'oneTabstop') {
          // the subset of Buttonset buttons that are enabled.  Effectively disabled buttons are not tabbable.
          this.$enabledButtons = this.$buttons.filter(function () {
            return !$(this).data('oj-ojButton')._IsEffectivelyDisabled();
          });

          this._initTabindexes(false); // call initTabindexes in refresh mode
        }
      },

      // For create, make only the first enabled button tabbable.  (We decided to have Shift-Tab go to first, not last, button.)
      // For refreshes, keep the existing tabstop if we can, otherwise proceed as with create.
      // Either way, if that button is a radio and some radio in its group is checked, make that one tabbable instead.
      // If there are no enabled buttons, makes them all untabbable.
      // No return value.
      _initTabindexes: function (isCreate) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // even for refreshes where we'll wind up keeping the same tabstop, must make everything untabbable first, to ensure any new buttons become untabbable.
        var $last = $(this._lastTabStop);
        this._lastTabStop = undefined;
        this.$buttons.attr('tabindex', '0');

        var $newTabStop; // callee might map this to radio groupmate

        // TBD: for refreshes when $last is an effectively disabled radio with a checked enabled groupmate and they are in the buttonset, the groupmate would be
        // a valid tabstop, but this defaults to the first.
        if (isCreate || !$last.is(this.$enabledButtons)) {
          // is create, or is refresh but must treat like create b/c $last is empty, or not enabled, or no longer in the buttonset
          $newTabStop = this.$enabledButtons.first(); // if empty (none enabled), no tabstop will be set
        } else {
          // is a refresh, and $last is non-empty and is an enabled button still in the buttonset.  May be a radio whose groupmate
          // has become checked, in which case callee will map it to that groupmate.
          $newTabStop = $last;
        }
        this._setTabStop($newTabStop);
      },

      // For each button in $button (in our usage always 0-1 button hence $button singular), if that button is an unchecked radio
      // with a checked groupmate (which means it's not tabbable), then map it to the checked one (checked enabled radios are
      // tabbable, and we know it's enabled per the argument below).
      //
      // $button contains 0 or more buttons to map.  Must be enabled since effectively disabled buttons aren't tabbable.
      // Returns the mapped JQ object (which the caller will make the tabstop).
      //
      // We know that this.$enabledButtons contains all buttons in $button, and all of their potentially checked radio-groupmates, since:
      // - The above "enabled" requirement guarantees that $button's contents are all in $enabledButtons.
      // - The prohibition against radio groupmates that are not in the buttonset, and the prohibition against checked disabled groupmates
      //   of enabled radios, guarantee that if $button is a radio, then all of its potentially checked groupmates are enabled and thus in
      //   $enabledButtons.
      //
      // Firefox browser issue:   (TODO: should we doc this?  File FF and/or JET bug?)
      //
      // When this method maps an unchecked radio to its checked groupmate, the caller ensures that the former still has focus, but the latter
      // is the tabstop for when the user tabs out and back in.  When tabbing / Shift-Tabbing from the unchecked radio in the direction of the
      // checked one, Chrome and IE9 are smart enough to tab out of the radio group to the adjacent tabstop as desired.  But in FF, focus goes to
      // the checked one, which is not what we want.
      //
      // Reason: Chrome and IE9 are smart enough never to tab within a radio group.  If focus is in the radio group, Tab and Shift-Tab exit the radio group.
      // But in FF, [a radio is reachable via Tab/Shift-Tab from within the group] if [it's enabled, tabindex != -1, and either checked or has no
      // checked groupmates], i.e. [it would be reachable via Tab/Shift-Tab from outside the group if all its groupmates happened to be untabbable
      // (e.g. disabled)].  In other words, FF is the only one that fails to distinguish between radios that could be valid tabstops from outside, and
      // those that should be valid tabstops from inside.
      //
      // This impl improves on the native behavior.  In FF, in an unchecked radio group, every single radio is a tabstop.  Our use of tabindex=-1
      // guarantees that we never tab within the group in that case.  It's only a checked groupmate that can be tabbed to from within. (So at
      // most one unwanted tabstop.)
      //
      // After much time and effort, the latter issue seems to be infeasible to fix in any robust, non-brittle way.  E.g.:
      // - Clearing all tabstops and restoring on tab-out of buttonset:  FF provides no reliable way to find out whether a blur is exiting the entire
      //   buttonset.  The obvious setTimeout workaround needed to be unacceptably long (e.g. 250ms) and even then was unreliable.  If we ever fail
      //   to restore the tabstop, the buttonset becomes untabbable and inaccessible.
      // - Every other approach had similar robustness issues.
      _mapToTabbable: function ($button) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var $enabledButtons = this.$enabledButtons;
        return $button.map(function (index, elem) {
          // Buttons other than radios, and checked radios, are always tabbable if they're enabled, which this method requires.
          // Radios w/ name="" (incl name omitted) are not in a radio group, not even with other radios with w/ name="".  Radios
          // with no groupmates are always tabbable, since either they're checked, or they're unchecked with no checked groupmate.
          if (elem.type !== 'radio' || elem.checked || elem.name === '') {
            return elem;
          }

          // elem is unchecked radio in real (not "") group, which is tabbable iff no groupmate is checked.  Per above doc, we know that
          // all of its potentially checked groupmates are in $enabledButtons.
          var $checkedRadio = _radioGroup(elem, $enabledButtons).filter(':checked');
          return $checkedRadio.length ? $checkedRadio[0] : elem;
        });
      },

      // Set which button is in the tab sequence.
      // $button should contain 0 or 1 button to be made tabbable (since at most one should be tabbable at a time).
      //   If 0 (i.e. no enabled buttons), all will become untabbable.  If 1, it must be tabbable in every way (e.g. enabled) except possibly
      //   being an unchecked radio with a checked groupmate, which this method will map to its checked groupmate, which
      //   we know is enabled thus tabbable since we require that checked radios with enabled groupmates not be disabled.
      // No return value.
      _setTabStop: function ($button) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        //        if (!window.setTabStopCounter) window.setTabStopCounter=1; // REMOVE, is only for console.log's
        //        console.log("in _setTabStop: " + window.setTabStopCounter++ + ".  Orig (premap) button checked: " + $button[0].checked); // + " and is:");
        //        console.log($button[0]);

        // eslint-disable-next-line no-param-reassign
        $button = this._mapToTabbable($button);
        var button = $button[0]; // button is undefined iff $button is empty iff we need to clear all tabstops b/c there are no enabled buttons to make tabbable
        var last = this._lastTabStop; // last is undefined iff $(last) is empty iff there are no existing tabstops to clear (b/c _initTabindexes just ran
        // or previously there were no enabled buttons to make tabbable)

        //        console.log("mapped button and last button are:");  console.log(button);  console.log(last);  console.log(".");

        // Cases: both are undefined: have no tabstops; want to keep it that way (b/c none enabled), so do nothing
        //        both are node X: X is the tabstop; want to keep it that way, so do nothing
        //        last is node X; button is undefined: X is the tabstop; want to clear it w/o replacing it (b/c none enabled).  This logic does that.
        //        last is undefined; button is node X: no existing tabstop; want to make X the tabstop.  This logic does that.
        //        last is node X; button is node Y: X is the tabstop; want to clear it and make Y the tabstop.  This logic does that.
        if (button !== last) {
          // console.log("setting tab stop to " + $button.attr("id"));  console.log("$(last).length:");  console.log($(last).length);
          if ($button[0]) {
            $button[0].setAttribute('tabindex', '0'); // no-op iff $button is empty iff (see comment above)
          }
          this._lastTabStop = button;
        }
      },

      // No return value.
      _handleKeyDown: function (event, $button) {
        // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        switch (event.which) {
          case $.ui.keyCode.UP: // up arrow
          case $.ui.keyCode.DOWN: // down arrow
            if ($button[0].getAttribute('type') !== 'radio') {
              break;
            }
          // fall thru for radio only.  See comments below.
          // eslint-disable-next-line no-fallthrough
          case $.ui.keyCode.LEFT: // left arrow
          case $.ui.keyCode.RIGHT: // right arrow
            event.preventDefault();

            var $enabledButtons = this.$enabledButtons;
            var length = $enabledButtons.length;
            if (length < 2) {
              // nowhere to navigate to; currently focused button is the only enabled one in buttonset
              break;
            }

            var oldIndex = $enabledButtons.index($button);
            var increment =
              event.which === $.ui.keyCode.DOWN || (event.which === $.ui.keyCode.RIGHT) !== this.isRtl
                ? 1
                : -1;
            var newIndex = (oldIndex + increment + length) % length; // wrap around if at start/end of buttonset

            // When radios are inside an element with role=toolbar, WAI-ARIA doesn't specify how to reconcile its recommended
            // Toolbar behavior (left/right arrows move focus w/o selecting) and radio behavior (all 4 arrow keys both move focus
            // and check/select that radio).  A11y office recommended treating radios in a Buttonset or Toolbar like other buttons:
            // Arrow moves focus without selecting, Spacebar selects, which we prefer too.
            // Previously we did that for only left/right arrows, and disabled up/down arrows, but since both native and WAI-ARIA-
            // compliant radios support up/down arrows, and since JAWS automatically instructs the user to use up/down arrows even
            // when the radio group is inside a role=toolbar, we now support up/down arrows for radios via the fall-thru above
            // (but still focus only, not select).
            $enabledButtons.eq(newIndex).focus();
            break;

          // Don't need Space/Enter handlers.  For all buttons except already-checked radios in some browsers, Space/Enter fire a click event
          // (natively or manually), which already calls _setTabStop.  For checked radios (which are focused if they're getting
          // this key event), _setTabStop has already been called for whichever happened 2nd:  focus (an already checked radio) or
          // check (an already focused radio) via click/Space/Enter.  We don't support programmatically checking the button; it must
          // be done via the "checked" option.
          default:
            break;
        }
      },

      _destroy: function () {
        // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        var elem = this.element[0];
        _removeClasses(elem, 'oj-buttonset oj-component ' + CHROMING_CLASSES);
        elem.removeAttribute(Components._OJ_CONTAINER_ATTR);
        elem.removeAttribute('role');

        if (this.options.focusManagement === 'oneTabstop') {
          this.$buttons.attr('tabindex', '0');
        }

        this.$buttons
          .map(function () {
            return $(this).ojButton('widget')[0];
          })
          // do .removeClass outside the filter in case button has been destroyed but still has these Buttonset styles on it.
          // TBD: if this has definitely been taken care of already for destroyed buttons, then move inside filter.
          .removeClass('oj-buttonset-first oj-buttonset-last')
          .end()

          // Recursively destroy Bset's buttons like JQUI.
          // TBD: The recursive destroy makes it impossible to ungroup the buttons if desired, i.e. destroy the Buttonset without destroying its buttons.
          //   As discussed in _setup() code comment, it was approved to add refresh() and/or destroy() params that would allow turning off
          //   the recursive behavior, but changing the default (compared to JQUI) was not approved.
          //   When not destroying the buttons, must instead restore the buttons to a not-in-buttonset state, i.e. remove Bset stuff, restore any
          //   Button stuff we removed, etc.
          .ojButton('destroy');
      }
    });

    // SECURITY NOTE: To avoid injection attacks, do NOT compute the class via string concatenation, i.e. don't do "oj-button-" + chroming + "-chrome"
    function _setChromingClass(elem, chroming) {
      _removeClasses(elem, CHROMING_CLASSES);
      elem.classList.add(_chromingMap[chroming]);
    }

    /**
     * In all cases, the return value includes only radios that are an :oj-button, i.e. radios that have been buttonized.
     *
     * Where this method looks for radio groupmates:
     *
     * - If $elems is present (even if empty),
     *     - This method will only look in that set, and will not attempt to weed out any false positives as defined below.
     *       (So in this case, return value includes the specified radio iff it's an :oj-button in $elems.)
     * - Else this method looks in exactly the places where groupmates (including the original radio) would live, i.e. not in
     *   the places false positives would live.  (So in both of the following cases, return value includes the specified radio
     *   iff it's an :oj-button.)  Specifically:
     *     - If radio is in a form, this method will only look in that form.
     *     - Else, this method will look in the radio's document, but not in any forms.
     *
     * Radios w/ name="" (incl name omitted) are not in a radio group (i.e. no SelectOne semantics), not even with other radios with
     * w/ name="".  So if radio is nameless, the return value will include only radio (or nothing at all if it isn't an :oj-button, or
     * if $elems is passed and it doesn't include radio).
     *
     * False positives: radios with nonempty names that match radio's name, but are actually not groupmates (i.e. no SelectOne
     * relationship), e.g. because they're from a different form.
     *
     *
     * @param {!Element} radio  a radio button.  Not a JQ object, other button or element type, or null.
     * @param {jQuery=} $elems  optional JQ object, containing 0 or more elems that aren't necessarily radios or buttons, in which to look for groupmates.
     *                          E.g. the elements in a buttonset or toolbar.  Must not contain any false positives as defined above.
     * @private
     */
    function _radioGroup(radio, $elems) {
      var name = radio.name;
      var form = radio.form;
      var $radios;

      if (name) {
        name = name.replace(/'/g, "\\'"); // escape single quotes
        var selector = ":radio[name='" + name + "']:oj-button";
        if ($elems) {
          $radios = $elems.filter(selector);
        } else if (form) {
          $radios = $(form).find(selector);
        } else {
          $radios = $(selector, radio.ownerDocument).filter(function () {
            return !this.form;
          });
        }
      } else {
        $radios = ($elems ? $elems.filter(radio) : $(radio)).filter(':oj-button');
      }
      return $radios;
    }

    // searches actualContainers array for each elem of interestingContainers in order, until one is found,
    // walks up the tree to find that container, and returns its widget constructor.  Returns null if no containers found.
    function _findContainer(element, actualContainers, interestingContainers) {
      for (var i = 0; i < interestingContainers.length; ++i) {
        var containerName = interestingContainers[i];
        if (actualContainers.indexOf(containerName) >= 0) {
          // walk up parents until find the container
          // eslint-disable-next-line no-param-reassign
          for (; ; element = element.parentNode) {
            var func = Components.__GetWidgetConstructor(element, containerName);
            if (func) {
              return func;
            }
          }
        }
      }
      return null;
    }

    function _getChromingDefault(componentName, element, actualContainers) {
      var containerConstructor = _findContainer(
        element,
        actualContainers,
        _interestingContainers[componentName]
      );
      // If the component is in an interesting container (buttonset or toolbar), then the default chroming is the current value of the chroming option of the nearest such container.
      if (containerConstructor) {
        return containerConstructor('option', 'chroming');
      }
      // Else, if $___ChromingOptionDefault is set in the current theme, then this expr returns that value for use as the chroming default.
      // Else, returns undefined, so that the prototype default is used.
      return ThemeUtils.getCachedCSSVarValues([
        '--oj-private-' + componentName + '-global-chroming-default'
      ])[0];
    }

    function _addClasses(elem, classes) {
      var oldClasses = elem.className;
      if (oldClasses) {
        var oldClassArray = oldClasses.split(' ');
        var newClassArray = classes.split(' ');
        for (var i = newClassArray.length; i >= 0; i--) {
          if (oldClassArray.indexOf(newClassArray[i]) >= 0) {
            newClassArray.splice(i, 1);
          }
        }
        if (newClassArray.length > 0) {
          // eslint-disable-next-line no-param-reassign
          elem.className = oldClasses + ' ' + newClassArray.join(' ');
        }
      } else {
        // eslint-disable-next-line no-param-reassign
        elem.className = classes;
      }
    }

    function _removeClasses(elem, classes) {
      var oldClasses = elem.className;
      if (oldClasses) {
        var oldClassArray = oldClasses.split(' ');
        var removeClassArray = classes.split(' ');
        var changed = false;
        for (var i = 0; i < removeClassArray.length; i++) {
          var idx = oldClassArray.indexOf(removeClassArray[i]);
          if (idx >= 0) {
            oldClassArray.splice(idx, 1);
            changed = true;
          }
        }
        if (changed) {
          // eslint-disable-next-line no-param-reassign
          elem.className = oldClassArray.join(' ');
        }
      }
    }

    // Set theme-based defaults
    Components.setDefaultOptions({
      ojButton: {
        chroming: Components.createDynamicPropertyGetter(function (context) {
          return _getChromingDefault('button', context.element, context.containers);
        })
      },
      ojButtonset: {
        chroming: Components.createDynamicPropertyGetter(function (context) {
          return _getChromingDefault('buttonset', context.element, context.containers);
        })
      }
    });
  })(); // end of Button / Buttonset wrapper function

});


define('ojs/ojtoolbar',['ojs/ojcore-base', 'jquery', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojlogger'], function (oj, $, ThemeUtils, Components, Logger) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  (function () {
    // Toolbar wrapper function, to keep "private static members" private
    /**
     * @ojcomponent oj.ojToolbar
     * @ojdisplayname Toolbar
     * @augments oj.baseComponent
     * @ojrole toolbar
     * @since 0.6.0
     * @ojshortdesc A toolbar displays a strip of control elements such as buttons and menu buttons, often grouped by separators.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["chroming"]}
     * @ojvbdefaultcolumns 12
     * @ojvbmincolumns 2
     *
     * @ojoracleicon 'oj-ux-ico-toolbar'
     * @ojuxspecs ['toolbar']
     *
     * @classdesc
     * <h3 id="toolbarOverview-section">
     *   JET Toolbar
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toolbarOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant toolbar element.
     *
     * <pre class="prettyprint"><code>&lt;oj-toolbar id="myToolbar">
     *     &lt;oj-button id="myButton">
     *          &lt;span>My Button&lt;/span>
     *     &lt;/oj-button>
     * &lt;/oj-toolbar>
     * </code></pre>
     *
     * <p>The JET Toolbar can contain [JET Buttons]{@link oj.ojButton}, [JET Menu Buttons]{@link oj.ojMenuButton}, [JET Buttonsets]{@link oj.ojButtonset}, and non-focusable content
     * such as separator icons.  Toolbar provides WAI-ARIA-compliant focus management.
     *
     * <p>A toolbar that contains radios should contain all radios in the radio group.
     *
     * <p>Multiple toolbars can be laid out as a set using the <a href="ToolbarSets.html#oj-toolbars">.oj-toolbars</a>
     * and <a href="ToolbarSets.html#oj-toolbar-row">.oj-toolbar-row</a> style classes.
     *
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     *
     * <h3 id="keyboard-appdev-section">
     *   Keyboard Application Developer Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
     * </h3>
     *
     * <p>Any buttonsets placed in the toolbar should have <code class="prettyprint">focusManagement</code> set to <code class="prettyprint">"none"</code>,
     * so as not to compete with the toolbar's focus management.
     *
     * <p>The application should not do anything to interfere with the Toolbar's focus management, such as setting the <code class="prettyprint">tabindex</code>
     * of the buttons.  Also, enabled buttons should remain user-visible, without which arrow-key navigation to the button would cause the focus to
     * seemingly disappear.
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET Toolbar takes care of focus management, as noted above.
     *
     * <p>The application is responsible for applying <code class="prettyprint">aria-label</code> and/or
     * <code class="prettyprint">aria-controls</code> attributes to the toolbar element, if applicable per the instructions that follow:
     *
     * <p>If this toolbar is (or might be) placed in context with other toolbars, then the application should apply an
     * <code class="prettyprint">aria-label</code> to the toolbar element to distinguish it, e.g. an "Edit" toolbar.  The
     * <code class="prettyprint">aria-label</code> is optional when there is only one toolbar.
     *
     * <p>If the toolbar is controlling something else on the page, e.g. bold / italic / underline buttons controlling a rich
     * text editor, then the application should apply an <code class="prettyprint">aria-controls</code> attribute to the toolbar element,
     * e.g. <code class="prettyprint">aria-controls="myTextEditor"</code>.
     *
     *
     * <p>Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.</p>
     *
     *
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
     * is changed post-create, the toolbar must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
     *
     *
     * <h3 id="binding-section">
     *   Declarative Binding
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
     * </h3>
     *
     * <p>For elements like Toolbar and Menu that contain a number of like items, applications may wish to use <code class="prettyprint">oj-bind-for-each</code>
     * to stamp out the contents as follows:
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-toolbar id="myToolbar">
     *     &lt;oj-bind-for-each data="[[myButtons]]">
     *         &lt;template>
     *             &lt;oj-button :id="[[$current.data.id]]">
     *                 &lt;span>
     *                     &lt;oj-bind-text value="[[$current.data.label]]">&lt;/oj-bind-text>
     *                 &lt;/span>
     *             &lt;/oj-button>
     *         &lt;/template>
     *     &lt;/oj-bind-for-each>
     * &lt;/oj-toolbar>
     * </code></pre>
     *
     */

    // API doc for inherited methods with no JS in this file:
    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the root element of the Toolbar component.
     *
     * @method
     * @name oj.ojToolbar#widget
     * @memberof oj.ojToolbar
     * @instance
     * @ignore
     * @return {jQuery} the root element of the component
     */

    /**
     * Removes the toolbar functionality completely. This will return the element back to its pre-init state,
     * and remove the toolbar's focus management from the contained buttons.
     *
     * @method
     * @name oj.ojToolbar#destroy
     * @memberof oj.ojToolbar
     * @instance
     * @ignore
     */

    //-----------------------------------------------------
    //                   Slots
    //-----------------------------------------------------
    /**
     * <p>The &lt;oj-toolbar> element accepts <code class="prettyprint">oj-button</code>, <code class="prettyprint">oj-c-button</code>, <code class="prettyprint">oj-buttonset-many</code>,
     * <code class="prettyprint">oj-buttonset-one</code>, <code class="prettyprint">oj-menu-button</code>, <code class="prettyprint">oj-c-menu-button</code>, <code class="prettyprint">oj-c-split-menu-button</code> and non-focusable content such as separator icon elements as children.</p>
     *
     * @ojchild Default
     * @memberof oj.ojToolbar
     * @ojpreferredcontent ["ButtonElement", "CButtonElement", "ButtonsetManyElement","ButtonsetOneElement","MenuButtonElement", "CMenuButtonElement", "CSplitMenuButtonElement"]
     *
     * @example <caption>Initialize the Toolbar with child content specified:</caption>
     * &lt;oj-toolbar>
     *   &lt;oj-button>Button Text 1&lt;/oj-button>
     *   &lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator">&lt;/span>
     *   &lt;oj-button>Button Text 2&lt;/oj-button>
     *   &lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator">&lt;/span>
     *   &lt;oj-button>Button Text 3&lt;/oj-button>
     * &lt;/oj-toolbar>
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------
    /**
     * <p>All Toolbar touch interaction is with the individual buttons.  See the [JET Button]{@link oj.ojButton} touch gesture doc.
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojToolbar
     */

    /**
     * <p>JET Toolbar is a single tabstop, with arrow-key navigation within the toolbar, as follows:
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Navigate to the previous enabled button on the left, wrapping around at the end.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Navigate to the next enabled button on the right, wrapping around at the end.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>See also the [JET Button]{@link oj.ojButton} keyboard doc, for details on interacting with
     * the individual buttons.
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojToolbar
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------

    // ---------------- oj-toolbar-separator --------------
    /**
     * Separators should be placed around any buttonsets in the toolbar, and anywhere else in the toolbar that a separator is desirable. <br/>
     * For accessibility, additionally apply role and aria-orientation as shown.
     * @ojstyleclass oj-toolbar-separator
     * @ojdisplayname Separator
     * @ojstyleselector "oj-toolbar span"
     * @memberof oj.ojToolbar
     * @ojtsexample
     * &lt;oj-toolbar id="myToolbar" aria-label="Foo" aria-controls="bar">
     *   &lt;oj-button ...>&lt;/oj-button>
     *   &lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator">&lt;/span>
     *   &lt;oj-button ...>&lt;/oj-button>
     * &lt;/oj-toolbar>
     */
    // ---------------- oj-toolbar-top-border --------------
    /**
     * Applies a top border to the toolbar, or to the oj-toolbars element, in themes not having this border by default.
     * @ojstyleclass oj-toolbar-top-border
     * @ojdisplayname Top Border
     * @memberof oj.ojToolbar
     * @ojtsexample
     * &lt;oj-toolbar id="myToolbar" aria-label="Foo" aria-controls="bar" class="oj-toolbar-top-border">
     *   &lt;oj-button ...>&lt;/oj-button>
     *   &lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator">&lt;/span>
     *   &lt;oj-button ...>&lt;/oj-button>
     * &lt;/oj-toolbar>
     */
    // ---------------- oj-toolbar-bottom-border --------------
    /**
     * Applies a bottom border to the toolbar, or to the oj-toolbars element, in themes not having this border by default.
     * @ojstyleclass oj-toolbar-bottom-border
     * @ojdisplayname Bottom Border
     * @memberof oj.ojToolbar
     * @ojtsexample
     * &lt;oj-toolbar id="myToolbar" aria-label="Foo" aria-controls="bar" class="oj-toolbar-bottom-border">
     *   &lt;oj-button ...>&lt;/oj-button>
     *   &lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator">&lt;/span>
     *   &lt;oj-button ...>&lt;/oj-button>
     * &lt;/oj-toolbar>
     */
    // ---------------- oj-toolbar-no-chrome --------------
    /**
     * Removes chrome (background and border) from the toolbar(s), in themes having this chrome by default.
     * @ojstyleclass oj-toolbar-no-chrome
     * @ojdisplayname No Chrome
     * @memberof oj.ojToolbar
     * @ojtsexample
     * &lt;oj-toolbar id="myToolbar" aria-label="Foo" aria-controls="bar" class="oj-toolbar-no-chrome">
     *   &lt;oj-button ...>&lt;/oj-button>
     *   &lt;span role="separator" aria-orientation="vertical" class="oj-toolbar-separator">&lt;/span>
     *   &lt;oj-button ...>&lt;/oj-button>
     * &lt;/oj-toolbar>
     */
    /**
     * @ojstylevariableset oj-toolbar-css-set1
     * @ojstylevariable oj-toolbar-button-margin {description: "Horizontal margin around a button in a toolbar", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-toolbar-borderless-button-margin {description: "Horizontal margin around a borderless button in a toolbar", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-toolbar-separator-margin {description: "Horizontal margin around a separator in a toolbar",formats: ["length"], help: "#css-variables"}
     * @memberof oj.ojToolbar
     */
    // --------------------------------------------------- oj.ojToolbar Styling End -----------------------------------------------------------

    (function () {
      const _OJ_TOOLBAR = 'oj-toolbar';
      const _OJ_MENU_BUTTON = 'OJ-MENU-BUTTON';
      const _OJ_BUTTON = 'OJ-BUTTON';
      const _OJ_C_BUTTON = 'OJ-C-BUTTON';
      const _OJ_C_MENU_BUTTON = 'OJ-C-MENU-BUTTON';
      const _OJ_C_SPLIT_MENU_BUTTON = 'OJ-C-SPLIT-MENU-BUTTON';
      const _ELEM_LIST =
        'oj-button, oj-menu-button, oj-buttonset-one, oj-buttonset-many, oj-c-button, oj-c-menu-button, oj-c-split-menu-button';
      const _BUTTON_LIST =
        'oj-button, oj-menu-button, oj-buttonset-one .oj-button, oj-buttonset-many .oj-button, oj-c-button, oj-buttonset-one .oj-c-button, oj-buttonset-many .oj-c-button, oj-c-menu-button, oj-c-split-menu-button';

      oj.__registerWidget('oj.ojToolbar', $.oj.baseComponent, {
        widgetEventPrefix: 'oj',

        options: {
          /**
           * <p>Indicates in what states the toolbar's buttons and buttonsets have chrome (background and border).
           *
           * <p>This option only affects buttons and buttonsets that have never had their own <code class="prettyprint">chroming</code> option set.  This allows
           * individual buttons and buttonsets to opt out of their toolbar's chroming if needed.
           *
           * <p>The default chroming varies by theme.
           *
           * <p>Once a value has been set on this option, that value applies regardless of theme.
           *
           * @expose
           * @memberof oj.ojToolbar
           * @ojshortdesc Indicates in what states the toolbar's buttons and buttonsets has chrome (background and border).
           * @instance
           * @since 1.2.0
           *
           * @type {string}
           * @ojvalue {string} "solid" Solid buttons stand out, and direct the user's attention to the most important actions in the UI.
           * @ojvalue {string} "outlined" Outlined buttons are salient, but lighter weight than solid buttons. Outlined buttons are useful for secondary actions.
           * @ojvalue {string} "borderless" Borderless buttons are the least prominent variation and are useful for supplemental actions that require minimal emphasis.
           * @ojvalue {string} "full" In typical themes, full-chrome buttons always have chrome.
           * @ojvalue {string} "half" In typical themes, half-chrome buttons acquire chrome only in their hover, active, and selected states.
           * @ojdeprecated [{target:'propertyValue', for:"half", since: "6.0.0", description: "This value will be removed in the future. Please use borderless instead."},
           *                {target:'propertyValue', for:"full", since: "6.0.0", description: "This value will be removed in the future. Please use solid instead."}]
           * @example <caption>Initialize the Toolbar with the <code class="prettyprint">chroming</code> attribute specified:</caption>
           * &lt;oj-toolbar chroming='borderless'>&lt;/oj-toolbar>
           *
           * @example <caption>Get or set the <code class="prettyprint">chroming</code> property after initialization:</caption>
           * // getter
           * var chromingValue = myToolbar.chroming;
           *
           * // setter
           * myToolbar.chroming = 'borderless';
           *
           * @example <caption>Set the default in the theme (CSS) :</caption>
           * --oj-private-toolbar-global-chroming-default: borderless !default;
           */
          chroming: 'borderless'

          /**
           * <p>JET Toolbar does not support a
           * <code class="prettyprint">disabled</code> option.  The following
           * one-liner can be used to disable or enable all buttons in a toolbar:
           *
           * @member
           * @name disabled
           * @memberof oj.ojToolbar
           * @instance
           * @ignore
           */
          // disabled option declared in superclass, but we still want the above API doc

          // Events

          /**
           * Triggered when the toolbar is created.
           *
           * @event
           * @name create
           * @memberof oj.ojToolbar
           * @instance
           * @ignore
           * @property {Event} event <code class="prettyprint">jQuery</code> event object
           * @property {Object} ui Empty object included for consistency with other events
           */
          // create event declared in superclass, but we still want the above API doc
        },

        _InitOptions: function (originalDefaults, constructorOptions) {
          this._super(originalDefaults, constructorOptions);

          if ('disabled' in constructorOptions) {
            Logger.warn(
              "Caller attempted to set the 'disabled' option on Toolbar, but Toolbar does not support the 'disabled' option.  See API doc."
            );
          }
        },

        _ComponentCreate: function () {
          this._super();

          var elem = this.element[0];
          elem.setAttribute(Components._OJ_CONTAINER_ATTR, this.widgetName); // @HTMLUpdateOK
          elem.classList.add(_OJ_TOOLBAR);
          elem.classList.add('oj-component');
          elem.setAttribute('role', 'toolbar');
          this._hasInitialFocusHandler = false;

          this._setup();
        },

        // Override to set custom launcher
        _NotifyContextMenuGesture: function (menu, event, eventType) {
          // Set launcher to the current tabbable button
          // For toggle buttons, launcher must be the hidden focusable input, but for Shift-F10 we want the CM aligned to the Button's root element, not that
          // hidden input.  This is no change from the default for push buttons, since in that case the root element and launcher (input) are the same.
          var currentButton = this.element.find(':oj-button[tabindex=0]'); // For now leaving pseudo selectors as jQuery ( for details)
          this._OpenContextMenu(event, eventType, {
            launcher: currentButton,
            position: { of: eventType === 'keyboard' ? currentButton.ojButton('widget') : event }
          });
        },

        // eslint-disable-next-line no-unused-vars
        _setOption: function (key, value) {
          // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
          if (key === 'disabled') {
            Logger.warn(
              "Caller attempted to set the 'disabled' option on Toolbar, but Toolbar does not support the 'disabled' option.  See API doc.  Ignoring the call."
            );
            return;
          }

          // Call super() after the "disabled" check returns, to avoid super() setting oj-disabled, etc.
          // Call it before handling chroming case, so that when that case calls refresh() on Button/Buttonset, callees see the new value of the option.
          // (Previously called super() at end, so that optionChange (fired at end of super) is fired at very end.)
          this._superApply(arguments);

          if (key === 'chroming') {
            // refresh the top-level buttons, and refresh the buttonsets to make them refresh their buttons, so that all toolbar buttons are refreshed.
            // Reason: to make them re-fetch their chroming option, in case it's still set to the default dynamic getter,
            // which takes its value from the containing buttonset or toolbar if present.
            // TBD: Consider only calling refresh() on children that haven't had their chroming option set, i.e. those still using the dynamic getter.
            this._refreshChildren();
          }
        },

        /**
         * Refreshes the toolbar, including the following:
         *
         * <ul>
         *   <li>Re-applies focus management / keyboard navigation.
         *   <li>Rechecks the reading direction (LTR vs. RTL).
         * </ul>
         *
         *
         * <p>A <code class="prettyprint">refresh()</code> is required in the following circumstances:
         * <ul>
         *   <li>After buttons or buttonsets are added to, removed from, or reordered within the toolbar.</li>
         *   <li>After a programmatic change to the <code class="prettyprint">checked</code> status of a radio button in the toolbar
         *       (which should be done via Buttonset's [value]{@link oj.ojButtonsetOne#value} option).  This applies only to radios,
         *       not to checkboxes or push buttons.</li>
         *   <li>After the reading direction (LTR vs. RTL) changes.</li>
         * </ul>
         *
         * @expose
         * @memberof oj.ojToolbar
         * @ojshortdesc Refreshes the toolbar.
         * @return {void}
         * @instance
         *
         * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
         * myToolbar.refresh();
         */
        refresh: function () {
          this._super();
          this._setup();
          this._refreshTabindex();
        },

        _setup: function () {
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          var self = this;
          var elem = this.element[0];
          this.isRtl = this._GetReadingDirection() === 'rtl';

          // initialize as an empty JQuery object so we don't fall over if focus hasn't been introduced before a click is made
          this.$enabledButtons = $();

          // When toolbar is binding listeners to buttons, use the Toolbar's eventNamespace, not the Button's
          // eventNamespace, to facilitate later unbinding only the Toolbar listeners.

          // For checkbox/radio, we're binding to inputs, not labels.

          // Put listeners on every button, b/c it's too unreliable to put them on the toolbar node and rely on event bubbling.
          // - E.g. bubbling doesn't work for antonym buttons (is this still true after the refactoring?) -- see comment on Button._setLabelOption().
          // - Likewise, focus mgmt can't just break if app listener stops propagation.
          // - Both of these problems still happen when using the delegation / selector overload of .on(); there is no special JQ bubbling magic.

          if (this._IsCustomElement()) {
            if (!this._hasInitialFocusHandler) {
              // Don't add more than one initial focus handler (for the case where toolbar is refreshed but not yet focused)
              // defer setting up button-specific event handling until the first focusin event is triggered
              this._focusinListener = function (event) {
                // eslint-disable-line no-unused-vars
                self._handleInitialFocus(event.target);
              };
              elem.addEventListener('focusin', this._focusinListener, true);
              this._hasInitialFocusHandler = true;
            }

            // find any current supported children to refresh in case they were already initialized and need to update their 'chroming' values
            this.topLevelChildren = elem.querySelectorAll(_ELEM_LIST);

            // refresh the top-level buttons, and refresh the buttonsets to make them refresh their buttons, so that all toolbar buttons are refreshed.
            // Reason: to make them re-fetch their chroming option, in case it's still set to the default dynamic getter,
            // which takes its value from the containing buttonset or toolbar if present.
            // TBD: Consider only calling refresh() on children that haven't had their chroming option set, i.e. those still using the dynamic getter.
            this._refreshChildren();
          } else {
            const _OJ_BUTTON_FIND = ':oj-button';
            this.$buttons = this.element
              .find(_OJ_BUTTON_FIND)
              .off('keydown' + this.eventNamespace)
              .on('keydown' + this.eventNamespace, function (event) {
                self._handleKeyDown(event, $(this));
              })

              .off('click' + this.eventNamespace)
              // eslint-disable-next-line no-unused-vars
              .on('click' + this.eventNamespace, function (event) {
                if (!$(this).ojButton('option', 'disabled')) {
                  // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and
                  // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked
                  // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                  self._setTabStop($(this));
                }
              })
              .off('focus' + this.eventNamespace)
              // eslint-disable-next-line no-unused-vars
              .on('focus' + this.eventNamespace, function (event) {
                self._handleFocus($(this));
              });

            // refresh the top-level buttons, and refresh the buttonsets to make them refresh their buttons, so that all toolbar buttons are refreshed.
            // Reason: to make them re-fetch their chroming option, in case it's still set to the default dynamic getter,
            // which takes its value from the containing buttonset or toolbar if present.
            // TBD: Consider only calling refresh() on children that haven't had their chroming option set, i.e. those still using the dynamic getter.
            this.$buttonsets = this.element.find(':oj-buttonset').ojButtonset('refresh');
            this.$topLevelButtons = this.$buttons
              .not(this.$buttonsets.find(_OJ_BUTTON_FIND))
              .ojButton('refresh');
          }
        },

        _handleFocus: function ($button) {
          if (!this._IsCustomElement() && this.$enabledButtons.length === 0) {
            // the subset of Toolbar buttons that are enabled.  Disabled buttons are not tabbable.
            this.$enabledButtons = this.$buttons.filter(function () {
              return !$(this).ojButton('option', 'disabled') && $(this).is(':visible');
            });

            this._initTabindexes(this._lastTabStop == null);
            this.$enabledButtons[0].focus();
          } else {
            this._setTabStop($button);
          }
        },

        // For custom element only, return if a button with oj-button class is disabled.
        // This can either be an oj-button, oj-c-button, oj-menu-button, oj-c-menu-button, oj-c-split-menu-button, or a span inside oj-buttonset-*.
        // We check the disabled property on custom elements instead of oj-disabled class because
        // there is delay between setting the property and having the class updated.
        _isButtonDisabled: function (button) {
          var disabled;
          if (
            button.tagName === _OJ_BUTTON ||
            button.tagName === _OJ_C_BUTTON ||
            button.tagName === _OJ_MENU_BUTTON ||
            button.tagName === _OJ_C_MENU_BUTTON ||
            button.tagName === _OJ_C_SPLIT_MENU_BUTTON
          ) {
            disabled = button.disabled;
          } else {
            // "button" is a span around an oj-option that represents a button in oj-buttonset-one or oj-buttonset-many
            disabled = button.parentNode.disabled;
            if (!disabled) {
              var ojOption = button.querySelector('oj-option');
              disabled = ojOption && ojOption.disabled;
            }
          }
          return disabled;
        },

        // For custom element only, we setup this handler for any focusin event on the toolbar. We then remove this handler, and setup the rest of the handlers we need
        // once all of our children have finished being initialized.
        _handleInitialFocus: function (targetElement) {
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          var self = this;
          var elem = this.element[0];
          var disabledChangedEventType = 'disabledChanged';

          // remove this event handling as we only want to run this setup logic on the first focusin event
          elem.removeEventListener('focusin', this._focusinListener, true);
          this._hasInitialFocusHandler = false;

          this.topLevelChildren = elem.querySelectorAll(_ELEM_LIST);

          // Add a MutationObserver to handle add and remove of descendants
          if (!this._mutationObserver) {
            var ojElementNames = [
              _OJ_BUTTON,
              _OJ_C_BUTTON,
              _OJ_MENU_BUTTON,
              _OJ_C_MENU_BUTTON,
              _OJ_C_SPLIT_MENU_BUTTON,
              'OJ-BUTTONSET-ONE',
              'OJ-BUTTONSET-MANY',
              'OJ-OPTION'
            ];
            this._disabledChangedListener = this.refresh.bind(this);
            this._mutationObserver = new MutationObserver(function (mutationList) {
              // mutationList is an array of MutationRecord
              mutationList.forEach(function (mutation) {
                if (mutation.type === 'childList') {
                  var i;
                  // addedNodes and removedNodes are NodeList
                  if (mutation.addedNodes) {
                    for (i = 0; i < mutation.addedNodes.length; i++) {
                      if (ojElementNames.indexOf(mutation.addedNodes[i].nodeName) >= 0) {
                        mutation.addedNodes[i].addEventListener(
                          disabledChangedEventType,
                          self._disabledChangedListener
                        );
                      }
                    }
                  }
                  if (mutation.removedNodes) {
                    for (i = 0; i < mutation.removedNodes.length; i++) {
                      if (ojElementNames.indexOf(mutation.removedNodes[i].nodeName) >= 0) {
                        mutation.removedNodes[i].removeEventListener(
                          disabledChangedEventType,
                          self._disabledChangedListener
                        );
                      }
                    }
                  }
                }
              });
            });
            this._mutationObserver.observe(elem, { childList: true, subtree: true });
          }

          // Toolbar custom element can listen to disabledChanged event on descendants to refresh itself
          var ojElements = elem.querySelectorAll(_ELEM_LIST);
          ojElements.forEach(function (ojElement) {
            // This can be called on the same element more than once, so try to remove any listener first
            ojElement.removeEventListener(disabledChangedEventType, self._disabledChangedListener);
            ojElement.addEventListener(disabledChangedEventType, self._disabledChangedListener);
          });

          var buttons = elem.querySelectorAll(_BUTTON_LIST);
          this.$buttons = $(buttons)
            .off('keydown' + this.eventNamespace)
            .on('keydown' + this.eventNamespace, function (event) {
              var $button = $(this);
              self._handleKeyDown(event, $button);
            })

            .off('click' + this.eventNamespace)
            // eslint-disable-next-line no-unused-vars
            .on('click' + this.eventNamespace, function (event) {
              var $button = $(this);
              if (!$button.hasClass('oj-disabled')) {
                // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and
                // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked
                // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                self._setTabStop($button);
              }
            })
            .off('focusin' + this.eventNamespace)
            // eslint-disable-next-line no-unused-vars
            .on('focusin' + this.eventNamespace, function (event) {
              var $button = $(this);
              self._handleFocus($button);
            });

          // the subset of Toolbar buttons that are enabled.  Disabled buttons are not tabbable.
          if (this._IsCustomElement()) {
            this.$enabledButtons = this.$buttons.filter(function () {
              return !self._isButtonDisabled(this) && $(this).is(':visible');
            });
          } else {
            this.$enabledButtons = this.$buttons.filter(function () {
              return !$(this).ojButton('option', 'disabled') && $(this).is(':visible');
            });
          }

          this._initTabindexes(this._lastTabStop == null);
          if (this.$enabledButtons && this.$enabledButtons.length > 0) {
            if (targetElement) {
              let targetButton =
                targetElement.nodeName === 'INPUT' ? targetElement.parentElement : targetElement;
              targetButton.focus();
            } else {
              let btn = this._getButtonFocusElem(this.$enabledButtons[0]);
              if (btn) {
                btn.focus();
              }
            }
          }
        },

        // Update list of enabled buttons and refresh tabindex settings
        _refreshTabindex: function () {
          var self = this;
          // We need to re-select buttons because with refresh buttons in toolbar may be added/deleted.
          if (this._IsCustomElement()) {
            this.$buttons = $(this.element[0].querySelectorAll(_BUTTON_LIST));
          } else {
            this.$buttons = this.element.find(':oj-button');
          }
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          if (this.$buttons !== undefined) {
            // the subset of Toolbar buttons that are enabled.  Disabled buttons are not tabbable.
            if (this._IsCustomElement()) {
              this.$enabledButtons = this.$buttons.filter(function () {
                return !self._isButtonDisabled(this) && $(this).is(':visible');
              });
            } else {
              this.$enabledButtons = this.$buttons.filter(function () {
                return !$(this).ojButton('option', 'disabled') && $(this).is(':visible');
              });
            }

            this._initTabindexes(this._lastTabStop == null);
          }
        },

        // Returns the focusable inner element of the button.
        _getButtonFocusElem: function (button) {
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          var focusElem = button; // Set to button by default
          if (button !== undefined && this._IsCustomElement()) {
            var expectedTag = 'button';
            if (button.classList.contains('oj-button-toggle')) {
              // the underlying input element is one of the button's children
              expectedTag = 'input';
            }
            var children = button.children;
            for (var i = 0; i < children.length; i++) {
              var child = children[i];
              if (child.tagName.toLowerCase() === expectedTag) {
                focusElem = child;
                break;
              }
            }
          }
          return focusElem;
        },

        // For create, make only the first enabled button tabbable.  (We decided to have Shift-Tab go to first, not last, button.)
        // For refreshes, keep the existing tabstop if we can, otherwise proceed as with create.
        // Either way, if that button is a radio and some radio in its group is checked, make that one tabbable instead.
        // If there are no enabled buttons, makes them all untabbable.
        // No return value.
        _initTabindexes: function (isCreate) {
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          // even for refreshes where we'll wind up keeping the same tabstop, must make everything untabbable first, to ensure any new buttons become untabbable.
          var $last = $(this._lastTabStop);
          this._lastTabStop = undefined;

          if (this._IsCustomElement()) {
            for (var i = 0; i < this.$buttons.length; i++) {
              if (this.$buttons[i].tagName.trim() === _OJ_C_SPLIT_MENU_BUTTON.trim()) {
                this.$buttons[i].children[0].children[0].setAttribute('tabindex', '-1');
              }
              this._getButtonFocusElem(this.$buttons[i]).setAttribute('tabindex', '-1');
            }
          } else {
            this.$buttons.attr('tabindex', '-1');
          }

          var $newTabStop; // callee might map this to radio groupmate

          // TBD: for refreshes when $last is a disabled radio with a checked enabled groupmate and they are in the toolbar, the groupmate would be
          // a valid tabstop, but this defaults to the first.
          if (isCreate || !$last.is(this.$enabledButtons)) {
            // is create, or is refresh but must treat like create b/c $last is empty, or not enabled, or no longer in the toolbar
            $newTabStop = this.$enabledButtons.first(); // if empty (none enabled), no tabstop will be set
          } else {
            // is a refresh, and $last is non-empty and is an enabled button still in the toolbar.  May be a radio whose groupmate
            // has become checked, in which case callee will map it to that groupmate.
            $newTabStop = $last;
          }
          this._setTabStop($newTabStop);
        },

        // For each button in $button (in our usage always 0-1 button hence $button singular), if that button is an unchecked radio
        // with a checked groupmate (which means it's not tabbable), then map it to the checked one (checked enabled radios are
        // tabbable, and we know it's enabled per the argument below).
        //
        // $button contains 0 or more buttons to map.  Must be enabled since disabled buttons aren't tabbable.
        // Returns the mapped JQ object (which the caller will make the tabstop).
        //
        // We know that this.$enabledButtons contains all buttons in $button, and all of their potentially checked radio-groupmates, since:
        // - The above "enabled" requirement guarantees that $button's contents are all in $enabledButtons.
        // - The prohibition against radio groupmates that are not in the toolbar, and the prohibition against checked disabled groupmates
        //   of enabled radios, guarantee that if $button is a radio, then all of its potentially checked groupmates are enabled and thus in
        //   $enabledButtons.
        //
        //
        // When this method maps an unchecked radio to its checked groupmate, the caller ensures that the former still has focus, but the latter
        // is the tabstop for when the user tabs out and back in.  When tabbing / Shift-Tabbing from the unchecked radio in the direction of the
        // checked one, Chrome and IE9 are smart enough to tab out of the radio group to the adjacent tabstop as desired.  But in FF, focus goes to
        // the checked one, which is not what we want.
        //
        // Reason: Chrome and IE9 are smart enough never to tab within a radio group.  If focus is in the radio group, Tab and Shift-Tab exit the radio group.
        // But in FF, [a radio is reachable via Tab/Shift-Tab from within the group] if [it's enabled, tabindex != -1, and either checked or has no
        // checked groupmates], i.e. [it would be reachable via Tab/Shift-Tab from outside the group if all its groupmates happened to be untabbable
        // (e.g. disabled)].  In other words, FF is the only one that fails to distinguish between radios that could be valid tabstops from outside, and
        // those that should be valid tabstops from inside.
        //
        // This impl improves on the native behavior.  In FF, in an unchecked radio group, every single radio is a tabstop.  Our use of tabindex=-1
        // guarantees that we never tab within the group in that case.  It's only a checked groupmate that can be tabbed to from within. (So at
        // most one unwanted tabstop.)
        //
        // After much time and effort, the latter issue seems to be infeasible to fix in any robust, non-brittle way.  E.g.:
        // - Clearing all tabstops and restoring on tab-out of toolbar:  FF provides no reliable way to find out whether a blur is exiting the entire
        //   toolbar.  The obvious setTimeout workaround needed to be unacceptably long (e.g. 250ms) and even then was unreliable.  If we ever fail
        //   to restore the tabstop, the toolbar becomes untabbable and inaccessible.
        // - Every other approach had similar robustness issues.
        _mapToTabbable: function ($button) {
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          var focusElems = [];
          for (var i = 0; i < this.$enabledButtons.length; i++) {
            focusElems.push(this._getButtonFocusElem(this.$enabledButtons[i]));
          }
          var $enabledButtonFocusElems = $(focusElems);
          return $button.map(function (index, elem) {
            // Buttons other than radios, and checked radios, are always tabbable if they're enabled, which this method requires.
            // Radios w/ name="" (incl name omitted) are not in a radio group, not even with other radios with w/ name="".  Radios
            // with no groupmates are always tabbable, since either they're checked, or they're unchecked with no checked groupmate.
            if (elem.type !== 'radio' || elem.checked || elem.name === '') {
              return elem;
            }
            // elem is unchecked radio in real (not "") group, which is tabbable iff no groupmate is checked.  Per above doc, we know that
            // all of its potentially checked groupmates are in $enabledButtons.
            var $checkedRadio = _radioGroup(elem, $enabledButtonFocusElems).filter(':checked'); // For now leaving pseudo selectors as jQuery ( for details)
            return $checkedRadio.length ? $checkedRadio[0] : elem;
          });
        },

        // Set which button is in the tab sequence.
        // $button should contain 0 or 1 button to be made tabbable (since at most one should be tabbable at a time).
        //   If 0 (i.e. no enabled buttons), all will become untabbable.  If 1, it must be tabbable in every way (e.g. enabled) except possibly
        //   being an unchecked radio with a checked groupmate, which this method will map to its checked groupmate, which
        //   we know is enabled thus tabbable since we require that checked radios with enabled groupmates not be disabled.
        // No return value.
        _setTabStop: function (_button) {
          var $button = _button;

          if (this._IsCustomElement()) {
            $button = this._mapToTabbable($(this._getButtonFocusElem($button[0])));
          } else {
            $button = this._mapToTabbable($button);
          }

          var button = $button[0]; // button is undefined iff $button is empty iff we need to clear all tabstops b/c there are no enabled buttons to make tabbable
          var last = this._lastTabStop; // last is undefined iff $(last) is empty iff there are no existing tabstops to clear (b/c _initTabindexes just ran
          // or previously there were no enabled buttons to make tabbable)

          // Cases: both are undefined: have no tabstops; want to keep it that way (b/c none enabled), so do nothing
          //        both are node X: X is the tabstop; want to keep it that way, so do nothing
          //        last is node X; button is undefined: X is the tabstop; want to clear it w/o replacing it (b/c none enabled).  This logic does that.
          //        last is undefined; button is node X: no existing tabstop; want to make X the tabstop.  This logic does that.
          //        last is node X; button is node Y: X is the tabstop; want to clear it and make Y the tabstop.  This logic does that.
          if (button !== last) {
            if (last && last.tagName.trim() === _OJ_C_SPLIT_MENU_BUTTON.trim()) {
              last.children[0].children[0].setAttribute('tabindex', '-1');
            } else {
              $(last).attr('tabindex', '-1'); // no-op iff $(last) is empty iff (see comment above)
            }
            if ($button[0].tagName.trim() === _OJ_C_SPLIT_MENU_BUTTON.trim()) {
              $button[0].children[0].children[0].setAttribute('tabindex', '0');
            } else {
              $button.attr('tabindex', '0'); // no-op iff $button is empty iff (see comment above)
            }
            this._lastTabStop = button;
          }
        },

        // No return value.
        _handleKeyDown: function (event, $button) {
          var self = this;
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          switch (event.which) {
            case $.ui.keyCode.UP: // up arrow
            case $.ui.keyCode.DOWN: // down arrow
              if ($button.attr('type') !== 'radio') {
                break;
              }
            // fall thru for radio only.  See comments below.
            // eslint-disable-next-line no-fallthrough
            case $.ui.keyCode.LEFT: // left arrow
            case $.ui.keyCode.RIGHT: // right arrow
              event.preventDefault();
              // reselect enabled buttons
              if (this._IsCustomElement()) {
                this.$enabledButtons = this.$buttons.filter(function () {
                  return !self._isButtonDisabled(this) && $(this).is(':visible');
                });
              } else {
                this.$enabledButtons = this.$buttons.filter(function () {
                  return !$(this).ojButton('option', 'disabled') && $(this).is(':visible');
                });
              }

              var length = this.$enabledButtons.length;
              if (length < 2) {
                // nowhere to navigate to; currently focused button is the only enabled one in toolbar
                break;
              }

              var oldIndex = this.$enabledButtons.index($button);
              //
              var increment =
                event.which === $.ui.keyCode.DOWN ||
                // eslint-disable-next-line no-bitwise
                (event.which === $.ui.keyCode.RIGHT) ^ this.isRtl
                  ? 1
                  : -1;
              var newIndex = (oldIndex + increment + length) % length; // wrap around if at start/end of toolbar

              // When radios are inside an element with role=toolbar, WAI-ARIA doesn't specify how to reconcile its recommended
              // Toolbar behavior (left/right arrows move focus w/o selecting) and radio behavior (all 4 arrow keys both move focus
              // and check/select that radio).  A11y office recommended treating radios in a Buttonset or Toolbar like other buttons:
              // Arrow moves focus without selecting, Spacebar selects, which we prefer too.
              // Previously we did that for only left/right arrows, and disabled up/down arrows, but since both native and WAI-ARIA-
              // compliant radios support up/down arrows, and since JAWS automatically instructs the user to use up/down arrows even
              // when the radio group is inside a role=toolbar, we now support up/down arrows for radios via the fall-thru above
              // (but still focus only, not select).
              this._getButtonFocusElem(this.$enabledButtons.eq(newIndex)[0]).focus();
              break;

            default:
              break;
            // Don't need Space/Enter handlers.  For all buttons except already-checked radios in some browsers, Space/Enter fire a click event
            // (natively or manually), which already calls _setTabStop.  For checked radios (which are focused if they're getting
            // this key event), _setTabStop has already been called for whichever happened 2nd:  focus (an already checked radio) or
            // check (an already focused radio) via click/Space/Enter.  If checking was done programmatically (via Bset.checked option), we require a refresh().
          }
        },

        _destroy: function () {
          // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
          // this entire stmt can be removed once restoreAttrs code is running.
          var elem = this.element[0];
          elem.classList.remove(_OJ_TOOLBAR);
          elem.classList.remove('oj-component');
          elem.removeAttribute(Components._OJ_CONTAINER_ATTR);
          elem.removeAttribute('role');

          // Since we're not destroying the buttons themselves, the restoreAttrs code will NOT take care of this.
          this.$buttons.attr('tabindex', '0'); // bsets in a toolbar should not have focusMgmt turned on, so this is OK, but should revert to orig value, not assume 0.

          // Refresh the top-level buttons, and refresh the buttonsets to make them refresh their buttons, so that all toolbar buttons are refreshed.
          // Reason: to make them re-fetch their chroming option, in case it's still set to the default dynamic getter,
          // which takes its value from the containing toolbar, which is no longer present.
          // Call refresh *after* removing _OJ_CONTAINER_ATTR, so the buttons/sets no longer detect that they're in a toolbar.
          // TBD: Consider only calling refresh() on children that haven't had their chroming option set, i.e. those still using the dynamic getter.
          this._refreshChildren();
        },

        // Refreshes the toolbar's child components.
        _refreshChildren: function () {
          // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
          if (!this._IsCustomElement()) {
            this.$buttonsets.ojButtonset('refresh');
            this.$topLevelButtons.ojButton('refresh');
          } else {
            // This relies on the button and buttonset components being implemented with JQUI - this will need to be revisited once that is no longer the case
            for (var i = 0; i < this.topLevelChildren.length; i++) {
              var child = this.topLevelChildren[i];
              if (
                child.tagName === _OJ_BUTTON ||
                child.tagName === _OJ_C_BUTTON ||
                child.tagName === _OJ_MENU_BUTTON ||
                child.tagName === _OJ_C_MENU_BUTTON ||
                child.tagName === _OJ_C_SPLIT_MENU_BUTTON
              ) {
                // must check to make sure the child button element has been initialized
                if (Components.__GetWidgetConstructor(this._getButtonFocusElem(child), 'ojButton')) {
                  child.refresh();
                }
              } else if (
                child.tagName === 'OJ-BUTTONSET-ONE' ||
                child.tagName === 'OJ-BUTTONSET-MANY'
              ) {
                // must check to make sure the child buttonset element has been initialized
                if (Components.__GetWidgetConstructor(child, 'ojButtonset')) {
                  child.refresh();
                }
              }
            }
          }
        }
      });
    })();

    // -----------------------------------------------------------------------------
    // "private static members" shared by all toolbars:
    // -----------------------------------------------------------------------------

    /**
     * This is the same as _radioGroup() in Buttonset's code, minus the code branches that toolbar's caller never reaches.
     * In the cases that toolbar's caller reaches, the behavior should be the same.  So if Buttonset and Toolbar ever share code,
     * keep Buttonset's copy of this function for use by both components.
     *
     * In all cases, the return value includes only radios that are an :oj-button, i.e. radios that have been buttonized.
     *
     * Where this method looks for radio groupmates:  This method will only look in $elems, and will not attempt to weed out any
     * false positives as defined below.  (So return value includes the specified radio iff it's an :oj-button in $elems.)
     *
     * Radios w/ name="" (incl name omitted) are not in a radio group (i.e. no SelectOne semantics), not even with other radios with
     * w/ name="".  So if radio is nameless, the return value will include only radio (or nothing at all if it isn't an :oj-button, or
     * if $elems doesn't include radio).
     *
     * False positives: radios with nonempty names that match radio's name, but are actually not groupmates (i.e. no SelectOne
     * relationship), e.g. because they're from a different form.
     *
     *
     * @param {!Element} radio  a radio button.  Not a JQ object, other button or element type, or null.
     * @param {jQuery=} $elems  optional JQ object, containing 0 or more elems that aren't necessarily radios or buttons, in which to look for groupmates.
     *                          E.g. the elements in a buttonset or toolbar.  Must not contain any false positives as defined above.
     * @private
     */
    function _radioGroup(radio, $elems) {
      var name = radio.name;
      var $radios;

      if (name) {
        name = name.replace(/'/g, "\\'"); // escape single quotes
        var selector = ":radio[name='" + name + "']:oj-button"; // For now leaving pseudo selectors as jQuery ( for details)
        $radios = $elems.filter(selector);
      } else {
        $radios = $elems.filter(radio).filter(':oj-button'); // For now leaving pseudo selectors as jQuery ( for details)
      }
      return $radios;
    }
  })(); // end of Toolbar wrapper function

  // Set theme-based defaults
  Components.setDefaultOptions({
    ojToolbar: {
      chroming: Components.createDynamicPropertyGetter(function () {
        return ThemeUtils.getCachedCSSVarValues(['--oj-private-toolbar-global-chroming-default'])[0];
      })
    }
  });

  (function () {
var __oj_toolbar_metadata = 
{
  "properties": {
    "chroming": {
      "type": "string",
      "enumValues": [
        "borderless",
        "full",
        "half",
        "outlined",
        "solid"
      ]
    },
    "translations": {
      "type": "object",
      "value": {}
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_toolbar_metadata.extension._WIDGET_NAME = 'ojToolbar';
    oj.CustomElementBridge.register('oj-toolbar', {
      metadata: oj.CollectionUtils.mergeDeep(__oj_toolbar_metadata, {
        properties: {
          chroming: {
            binding: {
              provide: [
                {
                  name: 'containerChroming',
                  default: oj.ThemeUtils.getCachedCSSVarValues([
                    '--oj-private-toolbar-global-chroming-default'
                  ])[0]
                }
              ]
            }
          }
        }
      })
    });
  })();

});


define('ojs/ojdialog',['ojs/ojpopupcore', 'ojs/ojbutton', 'jqueryui-amd/widgets/mouse', 'jqueryui-amd/widgets/draggable', 'jquery', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojanimation', 'ojs/ojfocusutils', 'ojs/ojcustomelement-utils', 'ojs/ojconfig'], function (ojpopupcore, ojbutton, mouse, draggable, $, oj, DomUtils, ThemeUtils, Components, AnimationUtils, FocusUtils, ojcustomelementUtils, Config) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;

  (function () {
    const OJ_RESIZABLE_HANDLE_SELECTOR = '.oj-resizable-handle';
    const OJ_RESIZABLE_RESIZE = 'oj-resizable-alsoresize';

    $.widget('oj.ojResizable', {
      version: '1.0.0',
      widgetEventPrefix: 'oj',
      options: {
        // ///////////////////////////////////////////////////////////////////////////////////
        //
        // Mouse Options (copied)
        //
        // ///////////////////////////////////////////////////////////////////////////////////

        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        cancel: 'input,textarea,button,select,option',
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        distance: 1,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        delay: 0,
        // ///////////////////////////////////////////////////////////////////////////////////
        //
        // Resize Options
        //
        // ///////////////////////////////////////////////////////////////////////////////////

        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        maxHeight: null,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        maxWidth: null,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        minHeight: 10,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        minWidth: 10,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        alsoResize: false,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        animate: false,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        animateDuration: 'slow',
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        animateEasing: 'swing',
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        containment: false,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        ghost: false,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        grid: false,
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        handles: 'e,s,se',
        /**
         *
         * @private
         * @expose
         * @memberof! oj.ojResizable
         * @instance
         *
         */
        helper: false,
        // See #7960
        // zIndex: 90,

        // ///////////////
        // callbacks
        // ///////////////

        /**
         * Triggered when the ojResizable is resized.
         *
         * @private
         * @expose
         * @event
         * @name resize
         * @memberof! oj.ojResizable
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         *
         * @example <caption>Initialize the resizable with the <code class="prettyprint">resize</code> callback specified:</caption>
         * $( ".selector" ).ojResizable({
         *     "resize": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
         * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
         */
        resize: null,
        /**
         * Triggered on the start of a resize operation.
         *
         * @private
         * @expose
         * @event
         * @name start
         * @memberof! oj.ojResizable
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         *
         * @example <caption>Initialize the resizable with the <code class="prettyprint">start</code> callback specified:</caption>
         * $( ".selector" ).ojResizable({
         *     "start": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojstart</code> event:</caption>
         * $( ".selector" ).on( "ojstart", function( event, ui ) {} );
         */
        // note - jqui doc has .on("resizestart"
        start: null,
        /**
         * Triggered on the end of a resize operation.
         *
         * @private
         * @expose
         * @event
         * @name stop
         * @memberof! oj.ojResizable
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         *
         * @example <caption>Initialize the resizable with the <code class="prettyprint">stop</code> callback specified:</caption>
         * $( ".selector" ).ojResizable({
         *     "stop": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojstop</code> event:</caption>
         * $( ".selector" ).on( "ojstop", function( event, ui ) {} );
         */
        // note - jqui doc has .on("resizestop"
        stop: null
      },
      // ///////////////////////////////////////////////////////////////////////////////////
      //
      // Original Resize Functions
      //
      // ///////////////////////////////////////////////////////////////////////////////////

      _num: function (value) {
        return parseInt(value, 10) || 0;
      },
      _isNumber: function (value) {
        return !isNaN(parseInt(value, 10));
      },
      _hasScroll: function (_el, a) {
        var el = _el;
        if ($(el).css('overflow') === 'hidden') {
          return false;
        }

        var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop';
        var has = false;

        if (el[scroll] > 0) {
          return true;
        }

        // TODO: determine which cases actually cause this to happen
        // if the element doesn't have the scroll set, see if it's possible to
        // set the scroll
        el[scroll] = 1;
        has = el[scroll] > 0;
        el[scroll] = 0;
        return has;
      },
      /**
       * Triggered when the ojResizable is created.
       *
       * @private
       * @expose
       * @event
       * @name create
       * @memberof! oj.ojResizable
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Empty object included for consistency with other events
       *
       * @example <caption>Initialize the resizable with the <code class="prettyprint">create</code> callback specified:</caption>
       * $( ".selector" ).ojResizable({
       *     "create": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
       * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
       */
      // note - jqui has on("resizecreate", ... need to verify if we need some form of "ojcreate".
      _create: function () {
        this._super();

        var n;
        var i;
        var handle;
        var axis;
        var hname;
        var that = this;
        var o = this.options;

        //
        // Create an instance of the 3rd party jqueryui mouse widget.
        //

        var mouseConstructor = this.element.mouse.bind(this.element);
        mouseConstructor();
        this.mouse = mouseConstructor('instance');

        //
        // Because we aggregating the mouse widget (and not extending it),
        // we override the protected methods of this mouse instance.
        //

        this.mouse._mouseCapture = function (event) {
          return that._mouseCapture(event);
        };

        this.mouse._mouseStart = function (event) {
          return that._mouseStart(event);
        };

        this.mouse._mouseDrag = function (event) {
          return that._mouseDrag(event);
        };

        this.mouse._mouseStop = function (event) {
          if (this.element) {
            this.element.focus();
          }
          return that._mouseStop(event);
        };

        this.element.addClass('oj-resizable');

        $.extend(this, {
          originalElement: this.element,
          _proportionallyResizeElements: [],
          // _helper: o.helper || o.ghost || o.animate ? o.helper || "oj-resizable-helper" : null
          _helper: null
        });

        this._initialResize = true;

        this.handles =
          o.handles ||
          (!$(OJ_RESIZABLE_HANDLE_SELECTOR, this.element).length
            ? 'e,s,se'
            : {
                n: '.oj-resizable-n',
                e: '.oj-resizable-e',
                s: '.oj-resizable-s',
                w: '.oj-resizable-w',
                se: '.oj-resizable-se',
                sw: '.oj-resizable-sw',
                ne: '.oj-resizable-ne',
                nw: '.oj-resizable-nw'
              });

        if (this.handles.constructor === String) {
          if (this.handles === 'all') {
            this.handles = 'n,e,s,w,se,sw,ne,nw';
          }

          n = this.handles.split(',');
          this.handles = {};

          for (i = 0; i < n.length; i++) {
            handle = $.trim(n[i]);
            hname = 'oj-resizable-' + handle;
            axis = $("<div class='oj-resizable-handle " + hname + "'></div>");

            this.handles[handle] = '.oj-resizable-' + handle;
            this.element.append(axis); // @HTMLUpdateOK
          }
        }

        var keys = Object.keys(this.handles);
        for (i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (this.handles[k].constructor === String) {
            this.handles[k] = this.element.children(this.handles[k]).first().show();
          }
        }

        this._handles = $(OJ_RESIZABLE_HANDLE_SELECTOR, this.element);

        this._handles.mouseover(function () {
          if (!that.resizing) {
            if (this.className) {
              axis = this.className.match(/oj-resizable-(se|sw|ne|nw|n|e|s|w)/i);
            }
            that.axis = axis && axis[1] ? axis[1] : 'se';
          }
        });

        this.mouse._mouseInit();
      },
      /**
       * Remove the ojResizable functionality completely.
       * This will return the element back to its pre-init state.
       *
       * <p>This method does not accept any arguments.
       *
       * @private
       * @expose
       * @method
       * @name oj.ojResizable#destroy
       * @memberof! oj.ojResizable
       * @instance
       *
       * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
       * var destroy = $( ".selector" ).ojResizable( "destroy" );
       */

      _destroy: function () {
        if (this.mouse) {
          this.mouse._mouseDestroy();
        }

        try {
          this.mouse.destroy();
          this.mouse = null;
        } catch (e) {
          // ignore
        }

        var _destroy = function (exp) {
          $(exp)
            .removeClass('oj-resizable oj-resizable-disabled oj-resizable-resizing')
            .removeData('resizable')
            .removeData('oj-resizable')
            .unbind('.resizable')
            .find(OJ_RESIZABLE_HANDLE_SELECTOR)
            .remove();
        };

        _destroy(this.originalElement);

        return this;
      },
      _mouseCapture: function (event) {
        var capture = false;
        var keys = Object.keys(this.handles);

        for (var i = 0; i < keys.length; i++) {
          var handle = $(this.handles[keys[i]])[0];
          if (handle === event.target || $.contains(handle, event.target)) {
            capture = true;
          }
        }

        return !this.options.disabled && capture;
      },
      _mouseStart: function (event) {
        var curleft;
        var curtop;
        var cursor;
        var o = this.options;
        var iniPos = this.element.position();
        var el = this.element;

        this.resizing = true;

        // Bugfix for http://bugs.jqueryui.com/ticket/1749
        if (/absolute/.test(el.css('position'))) {
          el.css({ position: 'absolute', top: el.css('top'), left: el.css('left') });
        } else if (el.is('.oj-draggable')) {
          el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
        }

        this._renderProxy();

        curleft = this._num(this.helper.css('left'));
        curtop = this._num(this.helper.css('top'));

        if (o.containment) {
          curleft += $(o.containment).scrollLeft() || 0;
          curtop += $(o.containment).scrollTop() || 0;
        }

        this.offset = this.helper.offset();
        this.position = { left: curleft, top: curtop };
        this.size = { width: el.width(), height: el.height() };
        this.originalSize = { width: el.width(), height: el.height() };
        this.originalPosition = { left: curleft, top: curtop };
        this.sizeDiff = {
          width: el.outerWidth() - el.width(),
          height: el.outerHeight() - el.height()
        };
        this.originalMousePosition = { left: event.pageX, top: event.pageY };

        this.aspectRatio = this.originalSize.width / this.originalSize.height || 1;

        cursor = /** @type string */ ($('.oj-resizable-' + this.axis).css('cursor'));
        $('body').css('cursor', cursor === 'auto' ? this.axis + '-resize' : cursor);

        el.addClass('oj-resizable-resizing');

        this._propagate('start', event);

        this._alsoresize_start(event);
        this._containment_start(event);

        return true;
      },
      _mouseDrag: function (event) {
        var data;
        var el = this.helper;
        var props = {};
        var smp = this.originalMousePosition;
        var a = this.axis;
        var dx = event.pageX - smp.left || 0;
        var dy = event.pageY - smp.top || 0;
        var trigger = this._change[a];

        this.prevPosition = {
          top: this.position.top,
          left: this.position.left
        };
        this.prevSize = {
          width: this.size.width,
          height: this.size.height
        };

        if (!trigger) {
          return false;
        }

        data = trigger.apply(this, [event, dx, dy]);

        this._updateVirtualBoundaries(event.shiftKey);
        if (event.shiftKey) {
          data = this._updateRatio(data, event);
        }

        data = this._respectSize(data, event);

        this._updateCache(data);

        this._propagate('resize', event);

        this._alsoresize_resize(event, this.ui());
        this._containment_resize(event, this.ui());

        if (this.position.top !== this.prevPosition.top) {
          props.top = this.position.top + 'px';
        }
        if (this.position.left !== this.prevPosition.left) {
          props.left = this.position.left + 'px';
        }
        if (this.size.width !== this.prevSize.width) {
          props.width = this.size.width + 'px';
        }
        if (this.size.height !== this.prevSize.height) {
          props.height = this.size.height + 'px';
        }
        el.css(props);

        if (!this._helper && this._proportionallyResizeElements.length) {
          this._proportionallyResize();
        }

        if (!$.isEmptyObject(props)) {
          this._trigger('resize', event, this.ui());
        }

        return false;
      },
      _mouseStop: function (event) {
        this.resizing = false;
        $('body').css('cursor', 'auto');

        this.element.removeClass('oj-resizable-resizing');

        this._propagate('stop', event);

        this._alsoresize_stop(event);
        this._containment_stop(event);

        return false;
      },
      _updateVirtualBoundaries: function (forceAspectRatio) {
        var pMinWidth;
        var pMaxWidth;
        var pMinHeight;
        var pMaxHeight;
        var b;
        var o = this.options;

        b = {
          minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
          maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
          minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
          maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity

          /*
             minWidth: 0,
             maxWidth: Infinity,
             minHeight: 0,
             maxHeight: Infinity
             */
        };

        if (forceAspectRatio) {
          pMinWidth = b.minHeight * this.aspectRatio;
          pMinHeight = b.minWidth / this.aspectRatio;
          pMaxWidth = b.maxHeight * this.aspectRatio;
          pMaxHeight = b.maxWidth / this.aspectRatio;

          if (pMinWidth > b.minWidth) {
            b.minWidth = pMinWidth;
          }
          if (pMinHeight > b.minHeight) {
            b.minHeight = pMinHeight;
          }
          if (pMaxWidth < b.maxWidth) {
            b.maxWidth = pMaxWidth;
          }
          if (pMaxHeight < b.maxHeight) {
            b.maxHeight = pMaxHeight;
          }
        }
        this._vBoundaries = b;
      },
      _updateCache: function (data) {
        this.offset = this.helper.offset();
        if (this._isNumber(data.left)) {
          this.position.left = data.left;
        }
        if (this._isNumber(data.top)) {
          this.position.top = data.top;
        }
        if (this._isNumber(data.height)) {
          this.size.height = data.height;
        }
        if (this._isNumber(data.width)) {
          this.size.width = data.width;
        }
      },
      _updateRatio: function (_data) {
        var data = _data;
        var cpos = this.position;
        var csize = this.size;
        var a = this.axis;

        if (this._isNumber(data.height)) {
          data.width = data.height * this.aspectRatio;
        } else if (this._isNumber(data.width)) {
          data.height = data.width / this.aspectRatio;
        }

        if (a === 'sw') {
          data.left = cpos.left + (csize.width - data.width);
          data.top = null;
        }
        if (a === 'nw') {
          data.top = cpos.top + (csize.height - data.height);
          data.left = cpos.left + (csize.width - data.width);
        }

        return data;
      },
      _respectSize: function (_data) {
        var data = _data;
        var o = this._vBoundaries;
        var a = this.axis;
        var ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width;
        var ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height;
        var isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width;
        var isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height;
        var dw = this.originalPosition.left + this.originalSize.width;
        var dh = this.position.top + this.size.height;
        var cw = /sw|nw|w/.test(a);
        var ch = /nw|ne|n/.test(a);

        if (isminw) {
          data.width = o.minWidth;
        }
        if (isminh) {
          data.height = o.minHeight;
        }
        if (ismaxw) {
          data.width = o.maxWidth;
        }
        if (ismaxh) {
          data.height = o.maxHeight;
        }

        if (isminw && cw) {
          data.left = dw - o.minWidth;
        }
        if (ismaxw && cw) {
          data.left = dw - o.maxWidth;
        }
        if (isminh && ch) {
          data.top = dh - o.minHeight;
        }
        if (ismaxh && ch) {
          data.top = dh - o.maxHeight;
        }

        // Fixing jump error on top/left 
        if (!data.width && !data.height && !data.left && data.top) {
          data.top = null;
        } else if (!data.width && !data.height && !data.top && data.left) {
          data.left = null;
        }

        return data;
      },
      _proportionallyResize: function () {
        if (!this._proportionallyResizeElements.length) {
          return;
        }

        var i;
        var j;
        var borders;
        var paddings;
        var prel;
        var element = this.helper || this.element;

        for (i = 0; i < this._proportionallyResizeElements.length; i++) {
          prel = this._proportionallyResizeElements[i];

          if (!this.borderDif) {
            this.borderDif = [];
            borders = [
              prel.css('borderTopWidth'),
              prel.css('borderRightWidth'),
              prel.css('borderBottomWidth'),
              prel.css('borderLeftWidth')
            ];
            paddings = [
              prel.css('paddingTop'),
              prel.css('paddingRight'),
              prel.css('paddingBottom'),
              prel.css('paddingLeft')
            ];

            for (j = 0; j < borders.length; j++) {
              this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
            }
          }

          prel.css({
            height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
            width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
          });
        }
      },
      _renderProxy: function () {
        var el = this.element;
        this.elementOffset = el.offset();

        this.helper = this.element;
      },
      _change: {
        e: function (event, dx) {
          return { width: this.originalSize.width + dx };
        },
        w: function (event, dx) {
          var cs = this.originalSize;
          var sp = this.originalPosition;
          return { left: sp.left + dx, width: cs.width - dx };
        },
        n: function (event, dx, dy) {
          var cs = this.originalSize;
          var sp = this.originalPosition;
          return { top: sp.top + dy, height: cs.height - dy };
        },
        s: function (event, dx, dy) {
          return { height: this.originalSize.height + dy };
        },
        se: function (event, dx, dy) {
          return $.extend(
            this._change.s.apply(this, arguments),
            this._change.e.apply(this, [event, dx, dy])
          );
        },
        sw: function (event, dx, dy) {
          return $.extend(
            this._change.s.apply(this, arguments),
            this._change.w.apply(this, [event, dx, dy])
          );
        },
        ne: function (event, dx, dy) {
          return $.extend(
            this._change.n.apply(this, arguments),
            this._change.e.apply(this, [event, dx, dy])
          );
        },
        nw: function (event, dx, dy) {
          return $.extend(
            this._change.n.apply(this, arguments),
            this._change.w.apply(this, [event, dx, dy])
          );
        }
      },
      _propagate: function (n, event) {
        //
        // Propage resizeStart and resizeStop events.
        // (resize is propagated internally by drag)
        //

        // $.ui.plugin.call(this, n, [event, this.ui()]);
        if (n !== 'resize') {
          this._trigger(n, event, this.ui());
        }
      },
      // ////////////////////////////////////////////////////////////////////////////////
      //
      // Code block that implements functionality formerly in defined as a plugin.
      // (note: plugin code is deprecated)
      //
      // The alsoResize functionality "also resizes" the dialog body.
      // This approach allows the footer area to remain at a fixed height
      // the dialog is resized.
      //
      // $.ui.plugin.add("resizable", "alsoResize", {
      //
      // ///////////////////////////////////////////////////////////////////////////////

      _alsoresize_start: function () {
        // var that = $(this).resizable( "instance" ),
        // var that = $(this).data("oj-resizable"), // w
        var that = this;
        var o = that.options;

        var _store = function (exp) {
          $(exp).each(function () {
            var el = $(this);

            el.data(OJ_RESIZABLE_RESIZE, {
              width: parseInt(el.width(), 10),
              height: parseInt(el.height(), 10),
              left: parseInt(el.css('left'), 10),
              top: parseInt(el.css('top'), 10)
            });
          });
        };

        if (typeof o.alsoResize === 'object' && !o.alsoResize.parentNode) {
          if (o.alsoResize.length) {
            o.alsoResize = o.alsoResize[0];
            _store(o.alsoResize);
          } else {
            $.each(o.alsoResize, function (exp) {
              _store(exp);
            });
          }
        } else {
          _store(o.alsoResize);
        }
      },
      _alsoresize_resize: function (event, ui) {
        // var that = $(this).resizable( "instance" ),
        // var that = $(this).data("oj-resizable"), // v
        var that = this;

        var o = that.options;
        var os = that.originalSize;
        var op = that.originalPosition;

        var delta = {
          height: that.size.height - os.height || 0,
          width: that.size.width - os.width || 0,
          top: that.position.top - op.top || 0,
          left: that.position.left - op.left || 0
        };
        var _alsoResize = function (exp, c) {
          $(exp).each(function () {
            var el = $(this);
            var start = $(this).data(OJ_RESIZABLE_RESIZE);
            var style = {};
            var css;
            if (c && c.length) {
              css = c;
            } else if (el.parents(ui.originalElement[0]).length) {
              css = ['width', 'height'];
            } else {
              css = ['width', 'height', 'top', 'left'];
            }

            $.each(css, function (i, prop) {
              var sum = (start[prop] || 0) + (delta[prop] || 0);
              if (sum && sum >= 0) {
                style[prop] = sum;
              }
            });

            el.css(style);
          });
        };

        if (typeof o.alsoResize === 'object' && !o.alsoResize.nodeType) {
          $.each(o.alsoResize, function (exp, c) {
            _alsoResize(exp, c);
          });
        } else {
          _alsoResize(o.alsoResize, null);
        }
      },
      _alsoresize_stop: function () {
        $(this).removeData(OJ_RESIZABLE_RESIZE);
      },
      // ///////////////////////////////////////////////////////////////////////////////
      //
      // Code block for containment functionality (formerly defined as a plugin)
      //
      // $.ui.plugin.add( "resizable", "containment", {
      //
      // ///////////////////////////////////////////////////////////////////////////////

      _containment_start: function () {
        var element;
        var p;
        var co;
        var ch;
        var cw;
        var width;
        var height;

        var that = this;

        var o = that.options;
        var el = that.element;
        var oc = o.containment;
        var ce;
        if (oc instanceof $) {
          ce = oc.get(0);
        } else if (/parent/.test(oc)) {
          ce = el.parent().get(0);
        } else {
          ce = oc;
        }

        if (!ce) {
          return;
        }

        that.containerElement = $(ce);

        if (/document/.test(oc) || oc === document) {
          that.containerOffset = {
            left: 0,
            top: 0
          };
          that.containerPosition = {
            left: 0,
            top: 0
          };

          that.parentData = {
            element: $(document),
            left: 0,
            top: 0,
            width: $(document).width(),
            height: $(document).height() || document.body.parentNode.scrollHeight
          };
        } else {
          element = $(ce);
          p = [];
          $(['Top', 'Right', 'Left', 'Bottom']).each(function (i, name) {
            p[i] = that._num(element.css('padding' + name));
          });

          that.containerOffset = element.offset();
          that.containerPosition = element.position();
          that.containerSize = {
            height: element.innerHeight() - p[3],
            width: element.innerWidth() - p[1]
          };

          co = that.containerOffset;
          ch = that.containerSize.height;
          cw = that.containerSize.width;
          width = that._hasScroll(ce, 'left') ? ce.scrollWidth : cw;
          height = that._hasScroll(ce) ? ce.scrollHeight : ch;

          that.parentData = {
            element: ce,
            left: co.left,
            top: co.top,
            width: width,
            height: height
          };
        }
      },
      _containment_resize: function (event, ui) {
        var woset;
        var hoset;
        var isParent;
        var isOffsetRelative;

        // var that = $(this).data("oj-resizable");
        var that = this;

        var o = that.options;
        var co = that.containerOffset;
        var cp = that.position;
        var pRatio = event.shiftKey;
        var cop = {
          top: 0,
          left: 0
        };
        var ce = that.containerElement;
        var continueResize = true;

        if (ce[0] !== document && /static/.test(ce.css('position'))) {
          cop = co;
        }

        if (cp.left < (that._helper ? co.left : 0)) {
          that.size.width += that._helper
            ? that.position.left - co.left
            : that.position.left - cop.left;
          if (pRatio) {
            that.size.height = that.size.width / that.aspectRatio;
            continueResize = false;
          }
          that.position.left = o.helper ? co.left : 0;
        }

        if (cp.top < (that._helper ? co.top : 0)) {
          that.size.height += that._helper ? that.position.top - co.top : that.position.top;
          if (pRatio) {
            that.size.width = that.size.height * that.aspectRatio;
            continueResize = false;
          }
          that.position.top = that._helper ? co.top : 0;
        }

        that.offset.left = that.parentData.left + that.position.left;
        that.offset.top = that.parentData.top + that.position.top;

        woset = Math.abs(
          (that._helper ? that.offset.left - cop.left : that.offset.left - co.left) +
            that.sizeDiff.width
        );
        hoset = Math.abs(
          (that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height
        );

        isParent = that.containerElement.get(0) === that.element.parent().get(0);
        isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));

        if (isParent && isOffsetRelative) {
          woset -= Math.abs(that.parentData.left);
        }

        if (woset + that.size.width >= that.parentData.width) {
          that.size.width = that.parentData.width - woset;
          if (pRatio) {
            that.size.height = that.size.width / that.aspectRatio;
            continueResize = false;
          }
        }

        if (hoset + that.size.height >= that.parentData.height) {
          that.size.height = that.parentData.height - hoset;
          if (pRatio) {
            that.size.width = that.size.height * that.aspectRatio;
            continueResize = false;
          }
        }

        if (!continueResize) {
          that.position.left = ui.prevPosition.left;
          that.position.top = ui.prevPosition.top;
          that.size.width = ui.prevSize.width;
          that.size.height = ui.prevSize.height;
        }
      },
      _containment_stop: function () {
        var that = this;
        var o = that.options;
        var co = that.containerOffset;
        var cop = that.containerPosition;
        var ce = that.containerElement;
        var helper = $(that.helper);
        var ho = helper.offset();
        var w = helper.outerWidth() - that.sizeDiff.width;
        var h = helper.outerHeight() - that.sizeDiff.height;

        if (that._helper && !o.animate && /relative/.test(ce.css('position'))) {
          $(this).css({
            left: ho.left - cop.left - co.left,
            width: w,
            height: h
          });
        }

        if (that._helper && !o.animate && /static/.test(ce.css('position'))) {
          $(this).css({
            left: ho.left - cop.left - co.left,
            width: w,
            height: h
          });
        }
      },
      ui: function () {
        return {
          originalElement: this.originalElement,
          element: this.element,
          helper: this.helper,
          position: this.position,
          size: this.size,
          originalSize: this.originalSize,
          originalPosition: this.originalPosition,
          prevSize: this.prevSize,
          prevPosition: this.prevPosition
        };
      }
    });
  })();

  (function () {
    // class name constants
    var /** @const */ OJD_BODY = 'oj-dialog-body';
    var /** @const */ OJD_CONTAINER = 'oj-dialog-container';
    var /** @const */ OJD_CONTENT = 'oj-dialog-content';
    var /** @const */ OJD_FOOTER = 'oj-dialog-footer';
    var /** @const */ OJD_HEADER = 'oj-dialog-header';
    var /** @const */ OJD_HEADER_CLOSE = 'oj-dialog-header-close';
    var /** @const */ OJD_HEADER_CLOSE_WRAPPER = 'oj-dialog-header-close-wrapper';
    var /** @const */ OJD_OPTION_DEFAULTS = 'oj-dialog-option-defaults';
    var /** @const */ OJD_HELPER_ELEMENT_DIALOG = 'oj-helper-element-in-dialog-with-accesskey';
    var /** @const */ OJD_ACCESS_KEY = 'data-ojAccessKey';

    var /** @const */ OJD_TITLE_CLASS = '.oj-dialog-title';
    var /** @const */ OJD_FOOTER_CLASS = '.oj-dialog-footer';
    var /** @const */ OJD_HEADER_CLASS = '.oj-dialog-header';
    var /** @const */ OJD_BODY_CLASS = '.oj-dialog-body';
    var /** @const */ OJD_CONTENT_CLASS = '.oj-dialog-content';
    var /** @const */ OJD_CONTAINER_CLASS = '.oj-dialog-container';

    var /** @const */ OJ_RESIZABLE = 'oj-resizable';
    var /** @const */ OJ_RESIZABLE_N = 'oj-resizable-n';
    var /** @const */ OJ_RESIZABLE_E = 'oj-resizable-e';
    var /** @const */ OJ_RESIZABLE_S = 'oj-resizable-s';
    var /** @const */ OJ_RESIZABLE_W = 'oj-resizable-w';
    var /** @const */ OJ_RESIZABLE_SE = 'oj-resizable-se';
    var /** @const */ OJ_RESIZABLE_SW = 'oj-resizable-sw';
    var /** @const */ OJ_RESIZABLE_NE = 'oj-resizable-ne';
    var /** @const */ OJ_RESIZABLE_NW = 'oj-resizable-nw';

    var /** @const */ OJ_DRAGGABLE = 'oj-draggable';

    var /** @const */ SLOT_BODY = 'body';
    var /** @const */ SLOT_DEFAULT = '';
    var /** @const */ SLOT_HEADER = 'header';
    var /** @const */ SLOT_FOOTER = 'footer';
    var /** @const */ SLOT_CONTEXTMENU = 'contextMenu';

    /**
     * @typedef {Object} oj.ojDialog.PositionAlign
     * @property {"top"|"bottom"|"center"} [vertical] Vertical alignment.
     * @property {"start"|"end"|"left"|"center"|"right"} [horizontal] Horizontal alignment. <p>
     * <ul>
     *  <li><b>"start"</b> evaluates to "left" in LTR mode and "right" in RTL mode.</li>
     *  <li><b>"end"</b> evaluates to "right" in LTR mode and "left" in RTL mode.</li>
     * </ul>
     *
     */

    /**
     * @typedef {Object} oj.ojDialog.PositionPoint
     * @property {number} [x] Horizontal alignment offset.
     * @property {number} [y] Vertical alignment offset.
     */

    /**
     * @typedef {Object} oj.ojDialog.Position
     * @property {Object} [my] Defines which edge on the popup to align with the target ("of") element.
     * @property {Object} [at] Defines which position on the target element ("of") to align the positioned element
     *                                  against.
     * @property {Object} [offset] Defines a point offset in pixels from the ("my") alignment.
     * @property {string|Object} [of] Which element to position the popup against.
     *
     * If the value is a string, it should be a selector or the literal string value
     * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
     * is used, the values are relative to the whole document.  Page horizontal and vertical
     * scroll offsets need to be factored into this point - see UIEvent
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
     *
     * @property {"flip"|"fit"|"flipfit"|"none"} [collision] Rule for alternate alignment. <p>
     * <ul>
     *  <li><b>"flip"</b> the element to the opposite side of the target and the
     *             collision detection is run again to see if it will fit. Whichever side
     *             allows more of the element to be visible will be used. </li>
     * <li><b>"fit"</b> shift the element away from the edge of the window. </li>
     * <li><b>"flipfit"</b> first applies the flip logic, placing the element
     *  on whichever side allows more of the element to be visible. Then the fit logic
     *  is applied to ensure as much of the element is visible as possible.</li>
     * <li><b>"none"</b> no collision detection.</li>
     * </ul>
     * @ojsignature [{target:"Type", value:"oj.ojDialog.PositionAlign", for:"my", jsdocOverride:true},
     *               {target:"Type", value:"oj.ojDialog.PositionAlign", for:"at", jsdocOverride:true},
     *               {target:"Type", value:"oj.ojDialog.PositionPoint", for:"offset", jsdocOverride:true},
     *               {target:"Type", value:"string|oj.ojDialog.PositionPoint", for:"of", jsdocOverride:true}]
     */

    /**
     * @ojcomponent oj.ojDialog
     * @augments oj.baseComponent
     * @since 0.6.0
     * @ojrole dialog
     * @ojdisplayname Dialog
     * @ojshortdesc A dialog displays a popup window that provides information and gathers input from the application user.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["dialogTitle", "initialVisibility", "style", "modality", "dragAffordance", "cancelBehavior", "resizeBehavior"]}
     * @ojvbdefaultcolumns 12
     * @ojvbmincolumns 12
     *
     * @ojoracleicon 'oj-ux-ico-dialog'
     * @ojuxspecs ['dialog']
     *
     * @classdesc
     * <h3 id="dialogOverview-section">
     *   JET Dialog Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialogOverview-section"></a>
     * </h3>
     * <p>Description: Themeable, WAI-ARIA-compliant dialog component.
     * A dialog is a floating window that typically contains a title bar and a content area.
     * The dialog window can be moved by dragging on the title area, and closed with the 'x' icon (by default). Dialogs can also be resized by dragging on edges or corners of the dialog component. </p>
     *
     *<p>If the content length exceeds the maximum height, a scrollbar will automatically appear.</p>
     *
     *<p>A bottom button bar and semi-transparent modal overlay layer are common options that can be added.</p>
     *
     *
     * <h3 id="focus-section">
     *   Focus
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#focus-section"></a>
     * </h3>
     *
     *<p>Upon opening a dialog, focus is automatically moved to the first item that matches the following:</p>
     *<ol>
     *  <li>The first <code>:tabbable</code> element within the dialog body</li>
     *  <li>The first <code>:tabbable</code> element within the dialog footer</li>
     *  <li>The dialog's close button</li>
     *  <li>The dialog itself</li>
     *</ol>
     *<p>The use of the HTML <code>autofocus</code> global attribute is discouraged.
     * If specified, the dialog will try to honor it but it may have undesirable implications for accessibility.
     * For more details, see the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus#accessibility_concerns">Accessibility concerns section</a>.</p>
     *
     *<p>While open, the dialog widget ensures that tabbing cycles focus between elements within the dialog itself, not elements outside of it. Modal dialogs additionally prevent mouse users from clicking on elements outside of the dialog.</p>
     *
     *<p>Upon closing a dialog, focus is automatically returned to the element that had focus when the dialog was opened.</p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     *<p>
     *<h3>Sizing</h3>
     *
     * <p> Dialog dimensions, including <code class="prettyprint"> height, width, min-width, max-width, min-height</code> and <code class="prettyprint">max-height</code> are defined with css variables. The default dialog dimensions are the following:
     *
     *<ul>
     *  <li> <code class="prettyprint">height: auto</code> </li>
     *  <li> <code class="prettyprint">width: 600px</code> </li>
     *  <li> <code class="prettyprint">min-width: 200px</code> </li>
     *  <li> <code class="prettyprint">max-width: 100vw - 3rem</code> </li>
     *  <li> <code class="prettyprint">max-height: 100vh - 3rem</code> </li>
     *</ul>
     *
     * In most cases, you will want to use the default <code class="prettyprint">height:auto</code>, since this will automatically adjust the height based on the content.
     * Users can change the dialog dimensions using style attributes:
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-dialog id="wideDialog" title="Wide Dialog" style="width: 400px; min-width: 100px; max-width 500px;"&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p&gt; Dialog Text
     *    &lt;/div&gt;
     * &lt;/oj-dialog&gt;
     * </code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <h4> role </h4>
     * By default, the role will be set to dialog.
     * This can be observed by inspecting the DOM:
     *
     * <pre class="prettyprint">
     * <code>
     *  &lt;div class="ojdialog ..." role="dialog"&gt;
     * </code></pre>
     *
     * This can be changed using the role attribute. WAI-ARIA recommends that role="dialog" be used if the dialog expects input (such as text input),
     * otherwise, use the role attribute to assign role="alertdialog".
     *
     * <h4> aria-labelledby </h4>
     *
     * For both default and user-defined headers, the dialog component takes care of aria-labelledby for you.
     * The <code class="prettyprint">aria-labelledby</code> attribute is generated automatically (and set to the id of the header's title).
     * For user-defined headers, the title div is identified by the div that has the <code class="prettyprint">oj-dialog-title</code> class.
     * Note that user-defined headers must have a title div (in order to meet accesibility requirements).
     *
     * <h4> aria-describedby </h4>
     *
     * If the dialog contains additional descriptive text besides the dialog title, this text can be associated
     * with the dialog using the <code class="prettyprint">aria-describedby</code> attribute. Unlike the
     * <code class="prettyprint">aria-labelledby</code> association, the <code class="prettyprint">aria-describedby</code>
     * attribute is not generated and set automatically. It is up to the user to specify the attribute
     * on <code class="prettyprint">oj-dialog</code> and link it to the element containing the additional description:
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-dialog id="dialog" title="Accessible Title" aria-describedby="desc"&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p id="desc"&gt; This is a dialog with accessible description.
     *    &lt;/div&gt;
     * &lt;/oj-dialog&gt;
     * </code></pre>
     *
     * <h3 id="reparenting-section">
     *   Reparenting
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
     * </h3>
     *
     *  <p id="reparenting-strategy">
     *     When dialogs are open, they will be reparented into a common container in the
     *     document body and reparented back when closed.  Within this container in the body,
     *     dialogs will always be top rooted but other types of dialogs used within an open
     *     dialog will be reparented within the dialog's layer. The dialog's layer defines its
     *     z-index weight "stacking context" and marked by the "oj-dialog-layer" style.
     *     The goal of this design is to maintain as much of the page author's document structure
     *     while avoiding most of the clipping and positioning issues of a completely inline design.
     *     Dialogs are assigned the same z-index values  The layering between dialog peers reflect the
     *     opening order.  In addition, the dialog that has active focus will be assigned a greater z-index
     *     by way of the "oj-focus-within" pseudo selector applied with "oj-dialog-layer" selector.
     *     The page author has control over z-index weights by way of the "oj-dialog-layer" selector.
     *  </p>
     *  <p>
     *     There are known caveats with this design. However, these scenarios are considered "bad use"
     *     based on our JET dialog/popup strategy.
     *  </p>
     *  <ol>
     *    <li>Events raised within the dialog will not bubble up to the dialog's original ancestors.  Instead, listeners for menu events should
     *        be applied to either the dialog's root element, or the document.</li>
     *    <li>Likewise, developers should not use CSS descendant selectors, or similar logic, that assumes that the dialog will remain a child
     *        of its original parent.</li>
     *    <li>Dialogs containing iframes are problematic.  The iframe elements "may" fire a HTTP GET request for its src attribute
     *        each time the iframe is reparented in the document.</li>
     *    <li>If an iframe is added to the dialog's body, it must not be the first or last tab stop within the dialog or keyboard and VoiceOver
     *        navigation will not remain within the dialog.</li>
     *    <li>In some browsers, reparenting a dialog that contains elements having overflow, will cause these overflow elements to
     *        reset their scrollTop.</li>
     *  </ol>
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p> Setting the reading direction (LTR or RTL) is supported by setting the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
     * is changed post-init, the dialog must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
     *
     *<h3>Additional Examples</h3>
     *
     * <p> The following defines a basic dialog, with an ok button in the footer:
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-dialog id="dialogWithFooter" dialog-title="Dialog with Footer" style="width: 400px; min-width: 100px; max-width 500px;"&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p&gt; Dialog Text
     *    &lt;/div&gt;
     *    &lt;div slot="footer"&gt;
     *       &lt;oj-button id="okButton"&gt; OK &lt;/oj-button&gt;
     *    &lt;/div&gt;
     * &lt;/oj-dialog&gt;
     *
     * </code></pre>
     *
     * Note that you will need to define your own event handlers for the ok and close buttons (see the demos for examples of this).
     *
     * <p> A dialog with user-defined header is shown next. Arbitrary header content can be defined using a user-defined header.
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-dialog id="dialog" dialog-title="Dialog Title"&gt;
     *    &lt;div slot="header"&gt;
     *       &lt;span id="dialog-title-id" class="oj-dialog-title"&gt; User Defined Header&lt;/span&gt;
     *    &lt;/div&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p&gt; Dialog Text
     *    &lt;/div&gt;
     * &lt;/oj-dialog&gt;
     * </code></pre>
     */
    //-----------------------------------------------------
    //                   Slots
    //-----------------------------------------------------
    /**
     * <p>The default slot is the dialog's body. The <code class="prettyprint">&lt;oj-dialog></code>
     * element accepts DOM nodes as children for the default slot.
     * The default slot can also be named with "body".
     * For styling, the default body slot will be rendered with the <code class="prettyprint">oj-dialog-body</code> class.
     *
     * @ojchild Default
     * @ojshortdesc The default slot is the dialog's body. It is the same as the named "body" slot.
     * @memberof oj.ojDialog
     * @since 4.0.0
     *
     * @example <caption>Initialize the Dialog with body content (using the default slot name):</caption>
     * &lt;oj-dialog>
     *   &lt;div>Dialog Content&lt;/div>
     * &lt;/oj-dialog>
     *
     */

    /**
     * <p>The <code class="prettyprint">header</code> slot is for the dialog's header area.
     * The  <code class="prettyprint">&lt;oj-dialog></code> element accepts DOM nodes as children
     * with the header slot.
     * For styling, the header slot will be rendered with the <code class="prettyprint">oj-dialog-header</code> class.
     * </p>
     * If a header slot is not specified by the user, a header will automatically be created.
     * The automatically generated header will contain a close button, and the header title will be set
     * to the dialog title.
     *
     * @ojslot header
     * @ojshortdesc The header slot is for the dialog's header area. See the Help documentation for more information.
     * @memberof oj.ojDialog
     * @since 4.0.0
     *
     * @example <caption>Initialize the Dialog with header and body content:</caption>
     * &lt;oj-dialog>
     *   &lt;div slot='header'>Header Content&lt;/div>
     *   &lt;div>Dialog Content&lt;/div>
     * &lt;/oj-dialog>
     */

    /**
     * <p>The <code class="prettyprint">body</code> slot is for the dialog's body area.
     * The <code class="prettyprint">&lt;oj-dialog></code> element accepts DOM nodes as children
     * with the body slot.
     * For styling, the body slot will be rendered with the <code class="prettyprint">oj-dialog-body</code> class.
     * Note that "body" is the default slot.
     *
     * @ojslot body
     * @ojshortdesc The body slot is for the dialog's body area. See the Help documentation for more information.
     * @memberof oj.ojDialog
     * @since 4.0.0
     *
     * @example <caption>Initialize the Dialog with body content:</caption>
     * &lt;oj-dialog>
     *   &lt;div slot="body">Dialog Content&lt;/div>
     * &lt;/oj-dialog>
     */

    /**
     * <p>The <code class="prettyprint">footer</code> slot is for the dialog's footer area.
     * The <code class="prettyprint">&lt;oj-dialog></code> element accepts DOM nodes as children
     * with the footer slot.
     * For styling, the footer slot will be rendered with the <code class="prettyprint">oj-dialog-footer</code> class.
     *
     * @ojslot footer
     * @ojshortdesc The footer slot is for the dialog's footer area. See the Help documentation for more information.
     * @memberof oj.ojDialog
     * @since 4.0.0
     *
     * @example <caption>Initialize the Dialog with body and footer content:</caption>
     * &lt;oj-dialog>
     *   &lt;div>Dialog Content&lt;/div>
     *   &lt;div slot='footer'>Footer Content&lt;/div>
     * &lt;/oj-dialog>
     */
    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Dialog Close Icon</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Close the dialog.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojDialog
     */

    /**
     * The JET Dialog can be closed with keyboard actions:
     *
     * <p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Dialog</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Close the dialog.</td>
     *     </tr>
     *     <tr>
     *       <td>Dialog Close Icon</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Close the dialog.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojDialog
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------
    /**
     * <p>Sub-ID for the dialog header.</p>
     *
     * @ojsubid oj-dialog-header
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-header'});
     */

    /**
     * <p>Sub-ID for the dialog footer.</p>
     *
     * @ojsubid oj-dialog-footer
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog footer:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-footer'});
     */

    /**
     * <p>Sub-ID for the dialog body.</p>
     *
     * @ojsubid oj-dialog-body
     * @memberof oj.ojDialog
     * @ojdeprecated {since:"1.2.0", description:"This sub-ID is not needed.  Since the application supplies this element, it can supply a unique ID by which the element can be accessed."}
     *
     * @example <caption>Get the node for the dialog body:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-body'});
     */

    /**
     * <p>Sub-ID for the dialog content.</p>
     *
     * @ojsubid oj-dialog-content
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog content:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-content'});
     */

    /**
     * <p>Sub-ID for the dialog header-close-wrapper.</p>
     *
     * @ojsubid oj-dialog-header-close-wrapper
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header-close-wrapper:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-header-close-wrapper'});
     */

    /**
     * <p>Sub-ID for the dialog close-icon.</p>
     *
     * @ojsubid oj-dialog-close-icon
     * @memberof oj.ojDialog
     * @ojdeprecated {since: "1.2.0", description: "This sub-ID is deprecated."}
     *
     * @example <caption>Get the node for the dialog close-icon:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-close-icon'});
     */

    /**
     * <p>Sub-ID for the dialog close affordance.</p>
     *
     * @ojsubid oj-dialog-close
     * @memberof oj.ojDialog
     * @ojdeprecated {since: "2.1.0", description: "This sub-ID is deprecated."}
     *
     * @example <caption>Get the node for the dialog close affordance:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-dialog-close'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the north location.</p>
     *
     * @ojsubid oj-resizable-n
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-n'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the south location.</p>
     *
     * @ojsubid oj-resizable-s
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-s'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the east location.</p>
     *
     * @ojsubid oj-resizable-e
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-e'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the west location.</p>
     *
     * @ojsubid oj-resizable-w
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-w'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the northeast location.</p>
     *
     * @ojsubid oj-resizable-ne
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-ne'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the northwest location.</p>
     *
     * @ojsubid oj-resizable-nw
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-nw'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the southwest location.</p>
     *
     * @ojsubid oj-resizable-sw
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-sw'});
     */

    /**
     * <p>Sub-ID for the dialog resizable handle at the southeast location.</p>
     *
     * @ojsubid oj-resizable-se
     * @memberof oj.ojDialog
     *
     * @example <caption>Get the node for the dialog header:</caption>
     * var node = myComponent.getNodeBySubId({'subId': 'oj-resizable-se'});
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------

    // ----------------------------------- oj-dialog-title--------------
    /**
     * Class used to format the dialog title. Automatically created headers use oj-dialog-title to format the title.<br/>
     * For user-defined headers, you may want to use the oj-dialog-title class so that the title in your user-defined header
     * is stylistically similar to a default title.<br/>
     * @ojstyleclass oj-dialog-title
     * @ojdisplayname Dialog Title
     * @ojstyleselector oj-dialog *
     * @ojshortdesc Class used to format the dialog title. See the Help documentation for more information.
     * @memberof oj.ojDialog
     */
    // ----------------------------------- oj-dialog-footer-separator--------------
    /**
     * Class that works with the <code class="prettyprint">oj-dialog-footer</code> class to specify a separator between the dialog body and the dialog footer.</br>
     * This class should be applied to the div that specifies <code class="prettyprint">slot="footer"</code> for the dialog.<br/>
     * Note that for themes that have a built-in footer separator (specifically the iOS theme), this class has no effect.<br/>
     * @ojstyleclass oj-dialog-footer-separator
     * @ojdisplayname Footer Separator
     * @ojstyleselector oj-dialog > div
     * @ojshortdesc Class used to specify a separator between the dialog body and the dialog footer. See the Help documentation for more information.
     * @memberof oj.ojDialog
     */
    // ----------------------------------- oj-progress-bar-embedded--------------
    /**
     * Optional class used to format a progress bar when embedded in the dialog.<br/>
     * @ojstyleclass oj-progress-bar-embedded
     * @ojdisplayname Embedded Progress Bar
     * @memberof oj.ojDialog
     */
    // ----------------------------------- oj-focus-highlight -------------
    /**
     * Under normal circumstances this class is applied automatically. It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojDialog
     */
    /**
     * @ojstylevariableset oj-dialog-css-set1
     * @ojstylevariable oj-dialog-border-radius {description: "Dialog border radius", formats: ["length","percentage"], help: "#css-variables"}
     * @ojstylevariable oj-dialog-bg-color {description: "Dialog background color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-dialog-border-color {description: "Dialog border color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-dialog-box-shadow {description: "Dialog box shadow", help: "#css-variables"}
     * @ojstylevariable oj-dialog-header-bg-color {description: "Dialog header background color", formats: ["color"],help: "#css-variables"}
     * @ojstylevariable oj-dialog-header-border-color {description: "Border color between the dialog header and body", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-dialog-header-padding {description: "Dialog header padding", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-dialog-body-padding {description: "Dialog body padding", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-dialog-footer-padding {description: "Dialog footer padding", formats: ["length"], help: "#css-variables"}
     * @memberof oj.ojDialog
     */
    /**
     * @ojstylevariableset oj-dialog-css-set2
     * @ojdisplayname Title
     * @ojstylevariable oj-dialog-title-font-size {description: "Dialog title font size", formats: ["length"], help: "#oj-dialog-css-set2"}
     * @ojstylevariable oj-dialog-title-line-height {description: "Dialog title line height", formats: ["number"], help: "#oj-dialog-css-set2"}
     * @ojstylevariable oj-dialog-title-font-weight {description: "Dialog title font weight", formats: ["font_weight"], help: "#oj-dialog-css-set2"}
     * @ojstylevariable oj-dialog-title-text-color {description: "Dialog title text color", formats: ["color"], help: "#oj-dialog-css-set2"}
     * @memberof oj.ojDialog
     */

    /**
     * @ojstylevariableset oj-dialog-css-set3
     * @ojdisplayname Cancel icon
     * @ojstylevariable oj-dialog-cancel-icon-margin-top {description: "Dialog cancel icon margin top", formats: ["length"], help: "#oj-dialog-css-set3"}
     * @ojstylevariable oj-dialog-cancel-icon-margin-end {description: "Dialog cancel icon margin end", formats: ["length"], help: "#oj-dialog-css-set3"}
     * @memberof oj.ojDialog
     */
    // ------------------------------------------------ oj-dialog Styling end ------------------------------------------------

    oj.__registerWidget('oj.ojDialog', $.oj.baseComponent, {
      version: '1.0.0',
      widgetEventPrefix: 'oj',
      options: {
        /**
         * Specifies the cancel behavior of the dialog.
         * The default value depends on the theme.
         * In the Redwood theme, the default is <code class="prettyprint">"none"</code>.
         * In the deprecated Alta web theme, the default is <code class="prettyprint">"icon"</code>.
         * In the deprecated Alta mobile themes (Android, iOS, Windows), the default is <code class="prettyprint">"none"</code>.
         *
         * <p> Note that the cancelBehavior applies to both automatic and user-defined headers.
         * So, a user-defined header will use the cancelBehavior setting or a theme-specific default.
         *
         * @expose
         * @memberof oj.ojDialog
         * @ojshortdesc Specifies the cancel behavior of the dialog. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojvalue {string} "icon" A close icon will automatically be created. The dialog will close when it has focus and user presses the escape (ESC) key.
         * @ojvalue {string} "escape" The dialog will close when it has focus and user presses the escape (ESC) key. A close icon will not be created.
         * @ojvalue {string} "none" A close icon will not be created. No actions will be associated with the escape key.
         *
         * @example <caption>Initialize the dialog to disable the default <code class="prettyprint">cancelBehavior</code></caption>
         * &lt;oj-dialog cancel-behavior="none" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">cancelBehavior</code> property, after initialization:</caption>
         * // getter
         * var cancelBehavior = myDialog.cancelBehavior;
         *
         * // setter
         * myDialog.cancelBehavior = "icon";
         *
         * @example <caption>Set the default in the theme (SCSS) :</caption>
         * $dialogCancelBehaviorOptionDefault: icon !default;
         *
         */
        cancelBehavior: 'icon',
        /**
         * Specifies the drag affordance.
         * The default value depends on the theme.
         * In the Redwood theme, the default is <code class="prettyprint">"none"</code>.
         * In the deprecated Alta web theme, the default is <code class="prettyprint">"title-bar"</code>.
         * In the deprecated Alta mobile themes (Android, iOS, Windows), the default is <code class="prettyprint">"none"</code>.
         *
         * @expose
         * @memberof oj.ojDialog
         * @ojshortdesc Specifies the drag affordance. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojvalue {string} "title-bar" The dialog will be draggable by the title bar.
         * @ojvalue {string} "none" The dialog will not be draggable.
         *
         * @example <caption>Initialize the dialog to enable dragging <code class="prettyprint">dragAffordance</code></caption>
         * &lt;oj-dialog drag-affordance="title-bar" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">dragAffordance</code> property, after initialization:</caption>
         * // getter
         * var dragAffordance = myDialog.dragAffordance;
         *
         * // setter
         * myDialog.dragAffordance = "title-bar";
         */
        dragAffordance: 'title-bar',
        /**
         * Set the initial visibility of the dialog.
         *
         * @expose
         * @memberof oj.ojDialog
         * @instance
         * @type {string}
         * @default "hide"
         * @ojvalue {string} "hide" The dialog will stay hidden until the <a href="#open"><code class="prettyprint">open()</code></a> method is called.
         * @ojvalue {string} "show" The dialog will automatically open upon initialization.
         *
         * @example <caption>Initialize the dialog with the <code class="prettyprint">initialVisibility</code> property:</caption>
         * &lt;oj-dialog initial-visibility="show" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">initialVisibility</code> property, after initialization:</caption>
         * // getter
         * var initialVisibility = myDialog.initialVisibility;
         *
         * // setter
         * myDialog.initialVisibility = "show";
         */
        initialVisibility: 'hide',
        /**
         *
         * Defines the modality of the dialog.
         *
         * @expose
         * @memberof oj.ojDialog
         * @instance
         * @default "modal"
         * @type {string}
         * @ojvalue {string} "modal" The dialog is modal. Interactions with other page elements are disabled. Modal dialogs overlay other page elements.
         * @ojvalue {string} "modeless" Defines a modeless dialog.
         *
         * @example <caption>Initialize the dialog to a specific modality <code class="prettyprint">modality</code></caption>
         * &lt;oj-dialog modality="modeless" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">modality</code> property, after initialization:</caption>
         * // getter
         * var modality = myDialog.modality;
         *
         * // setter
         * myDialog.modality = "modeless";
         */
        modality: 'modal',
        /**
         * <p>Position object is used to establish the location the dialog will appear relative to
         * another element. {@link oj.ojDialog.Position} defines "my" alignment "at" the alignment
         * "of" some other thing which can be "offset" by so many pixels.</p>
         *
         * <p>The "my" and "at" properties define alignment points relative to the dialog and other
         * element.  The "my" property represents the dialog's alignment where the "at" property
         * represents the other element that can be identified by "of". The values of these properties
         * describe horizontal and vertical alignments.</p>
         *
         * <p>If none of the <code class="prettyprint">position</code> properties are specified,
         * the default dialog position is "center" on desktop and "bottom" on phone.</p>
         *
         * <b>Deprecated v3.0.0 jQuery UI position syntax; Use of a percent unit with
         * "my" or "at" is not supported.</b>
         *
         * @expose
         * @memberof oj.ojDialog
         * @ojshortdesc Establishes the location that the dialog will appear relative to another element. See the Help documentation for more information.
         * @instance
         * @type {Object}
         * @ojsignature { target: "Type",
         *                value: "oj.ojDialog.Position",
         *                jsdocOverride: true}
         * @name position
         * @example <caption>Initialize the dialog with <code class="prettyprint">position</code>
         *           property specified:</caption>
         * &lt;oj-dialog position.my.horizontal="left"
         *           position.my.vertical="top"
         *           position.at.horizontal="right"
         *           position.at.vertical="top" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">position</code> property,
         *          after initialization:</caption>
         * // getter
         * var position = myDialog.position;
         *
         * // setter
         * myDialog.position =
         *    {"my": {"horizontal": "start", "vertical": "bottom"},
         *     "at": {"horizontal": "end", "vertical": "top" },
         *     "offset": {"x": 0, "y":5}};
         */
        position: {
          /**
           * Defines which edge on the dialog to align with the target ("of") element.
           *
           * @expose
           * @memberof! oj.ojDialog
           * @instance
           * @name position.my
           * @name position.my
           * @type {{horizontal:string, vertical:string}}
           */
          my: {
            /**
             * @expose
             * @memberof! oj.ojDialog
             * @instance
             * @name position.my.horizontal
             * @name position.my.horizontal
             * @type {string}
             * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
             * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
             * @ojvalue {string} "left"
             * @ojvalue {string} "center"
             * @ojvalue {string} "right"
             * @default "center"
             */
            horizontal: 'center',
            /**
             * @expose
             * @memberof! oj.ojDialog
             * @instance
             * @name position.my.vertical
             * @name position.my.vertical
             * @type {string}
             * @ojvalue {string} "top"
             * @ojvalue {string} "center"
             * @ojvalue {string} "bottom"
             * @default "center"
             */
            vertical: 'center'
          },
          /**
           * Defines a point offset in pixels from the ("my") alignment.
           * @expose
           * @memberof! oj.ojDialog
           * @instance
           * @name position.offset
           * @name position.offset
           * @type {{x:number, y:number}}
           */
          offset: {
            /**
             * Horizontal alignment offset.
             * @expose
             * @memberof! oj.ojDialog
             * @instance
             * @name position.offset.x
             * @name position.offset.x
             * @type {number}
             * @default 0
             */
            x: 0,
            /**
             * Vertical alignment offset.
             * @expose
             * @memberof! oj.ojDialog
             * @instance
             * @name position.offset.y
             * @name position.offset.y
             * @type {number}
             * @default 0
             */
            y: 0
          },
          /**
           * Defines which position on the target element ("of") to align the positioned element
           * against.
           *
           * @expose
           * @memberof! oj.ojDialog
           * @instance
           * @name position.at
           * @name position.at
           * @type {{horizontal:string, vertical:string}}
           */
          at: {
            /**
             * @expose
             * @memberof! oj.ojDialog
             * @instance
             * @name position.at.horizontal
             * @name position.at.horizontal
             * @type {string}
             * @ojvalue {string} "start" evaluates to "left" in LTR mode and "right" in RTL mode.
             * @ojvalue {string} "end" evaluates to "right" in LTR mode and "left" in RTL mode.
             * @ojvalue {string} "left"
             * @ojvalue {string} "center"
             * @ojvalue {string} "right"
             * @default "center"
             */
            horizontal: 'center',
            /**
             * @expose
             * @memberof! oj.ojDialog
             * @instance
             * @name position.at.vertical
             * @name position.at.vertical
             * @type {string}
             * @ojvalue {string} "top"
             * @ojvalue {string} "center"
             * @ojvalue {string} "bottom"
             * @default "center"
             */
            vertical: 'center'
          },
          /**
           * Which element to position the dialog against.
           * If the value is a string, it should be a selector or the literal string value
           * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
           * is used, the values are relative to the whole document.  Page horizontal and vertical
           * scroll offsets need to be factored into this point - see UIEvent
           * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
           * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
           *
           * @example <caption>Finding the point for an svg element:</caption>
           * var rect = svgDom.getBoundingClientRect();
           * var position = {of:{x:rect.left + window.pageXOffset, y:rect.top + window.pageYOffset}};
           *
           * @expose
           * @memberof! oj.ojDialog
           * @ojshortdesc Specifies which element to position the dialog against. See the Help documentation for more information.
           * @instance
           * @name position.of
           * @name position.of
           * @type {string|{x: number, y: number}}
           * @default "window"
           */
          of: 'window',
          /**
           * Rule for alternate alignment.
           *
           * @expose
           * @memberof! oj.ojDialog
           * @instance
           * @name position.collision
           * @name position.collision
           * @type {string}
           * @ojvalue {string} "flip" Flip the element to the opposite side of the target and the
           *  collision detection is run again to see if it will fit. Whichever side
           *  allows more of the element to be visible will be used.
           * @ojvalue {string} "fit" Shift the element away from the edge of the window.
           * @ojvalue {string} "flipfit" First applies the flip logic, placing the element
           *  on whichever side allows more of the element to be visible. Then the fit logic
           *  is applied to ensure as much of the element is visible as possible.
           * @ojvalue {string} "none" No collision detection.
           * @default "fit"
           */
          collision: 'fit',
          // Ensure the titlebar is always visible
          using: function (pos) {
            var topOffset = $(this).css(pos).offset().top;
            if (topOffset < 0) {
              $(this).css('top', pos.top - topOffset);
            }
          }
        },
        /**
         *
         * Specifies the resizeBehavior of the dialog.
         * The default value depends on the theme.
         * In the Redwood theme, the default is <code class="prettyprint">"none"</code>.
         * In the deprecated Alta web theme, the default is <code class="prettyprint">"resizable"</code>.
         * In the deprecated Alta mobile themes (Android, iOS, Windows), the default is <code class="prettyprint">"none"</code>.
         *
         * @expose
         * @memberof oj.ojDialog
         * @ojshortdesc Specifies the resizeBehavior of the dialog. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @ojvalue {string} "resizable" The dialog will be interactively resizable.
         * @ojvalue {string} "none" The dialog will not be interactively resizable.
         *
         * @example <caption>Initialize the dialog to a specific resizeBehavior <code class="prettyprint">resizeBehavior</code></caption>
         * &lt;oj-dialog resize-behavior="resizable" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">resizeBehavior</code> property, after initialization:</caption>
         *
         * // getter
         * var resizeBehavior = myDialog.resizeBehavior;
         *
         * // setter
         * myDialog.resizeBehavior = "resizable";
         * @example <caption>Set the default in the theme (SCSS) :</caption>
         * $dialogResizeBehaviorOptionDefault: resizable !default;
         */
        resizeBehavior: 'resizable',
        /**
         *
         * The WAI-ARIA role of the dialog. By default, role="dialog" is added to the generated HTML markup that surrounds the dialog.
         * When used as an alert dialog, the user should set role to "alertdialog".
         *
         * @ignore
         * @memberof oj.ojDialog
         * @ojshortdesc The WAI-ARIA role of the dialog. See the Help documentation for more information.
         * @instance
         * @type {string}
         * @default "dialog"
         *
         * @example <caption>Initialize the dialog with the <code class="prettyprint">role</code></caption> property specified:</caption>
         * &lt;oj-dialog role="alertdialog" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">role</code> property, after initialization:</caption>
         * // getter
         * var role = myDialog.role;
         *
         * // setter
         * myDialog.role = "alertdialog";
         */
        role: 'dialog',
        /**
         *
         * Specify the title of the dialog. null is the default.
         *
         * @expose
         * @memberof oj.ojDialog
         * @ojtranslatable
         * @instance
         * @type {string|null}
         *
         * @example <caption>Initialize the <code class="prettyprint">dialogTitle</code> property.</caption>
         * &lt;oj-dialog dialog-title="Title of Dialog" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">dialogTitle</code> property, after initialization:</caption>
         * // getter
         * var dialogTitle = myDialog.dialogTitle;
         *
         * // setter
         * myDialog.dialogTitle = "Title of Dialog";
         */
        dialogTitle: null,
        /**
         *
         * Specify the title of the dialog. null is the default.
         *
         * @expose
         * @ignore
         * @memberof oj.ojDialog
         * @instance
         * @type {string|null}
         *
         * @example <caption>Initialize the dialog to a specific title <code class="prettyprint">title</code></caption>
         * &lt;oj-dialog dialog-title="Title of Dialog" &gt;&lt;/oj-dialog&gt;
         *
         * @example <caption>Get or set the <code class="prettyprint">title</code> property, after initialization:</caption>
         * // getter
         * var title = myDialog.title;
         *
         * // setter
         * myDialog.title = "Title of Dialog";
         */
        title: null,
        // /////////////////////////////////////////////////////
        // events
        // /////////////////////////////////////////////////////

        /**
         * Triggered before the dialog is dismissed via the
         * <code class="prettyprint">close()</code> method. The close can be cancelled by calling
         * <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {Event} event a custom event
         */
        beforeClose: null,
        /**
         * Triggered before the dialog is launched via the <code class="prettyprint">open()</code>
         * method. The open can be cancelled by calling
         * <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {Event} event a custom event
         */
        beforeOpen: null,
        /**
         * Triggered after the dialog is dismissed via the
         * <code class="prettyprint">close()</code> method.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @instance
         * @ojbubbles
         * @ojeventgroup common
         * @property {Event} event a custom event
         */
        close: null,
        /**
         * Triggered after focus has been transferred to the dialog.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @instance
         * @ojbubbles
         * @property {Event} event a custom event
         */
        focus: null,
        /**
         * Triggered after the dialog is launched via the <code class="prettyprint">open()</code>
         * method.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {Event} event a custom event
         */
        open: null,
        /**
         * Triggered when the dialog is being resized.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @ojshortdesc Triggered when the dialog is being resized. See the Help documentation for more information.
         * @instance
         * @ojbubbles
         * @property {Object} originalEvent the underlying UI <a href="http://api.jqueryui.com/resizable/#event-resize">Event</a> object
         * @property {Object} originalPosition the original CSS position of the dialog
         * @property {Object} originalSize the original size of the dialog
         * @property {Object} position the current CSS position of the dialog
         * @property {Object} size the current size of the dialog
         */
        resize: null,
        /**
         * Triggered when the user starts resizing the dialog.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @ojshortdesc Triggered when the user starts resizing the dialog. See the Help documentation for more information.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {Object} originalEvent the underlying UI <a href="http://api.jqueryui.com/resizable/#event-resize">Event</a> object
         * @property {Object} originalPosition the original CSS position of the dialog
         * @property {Object} originalSize the original size of the dialog
         * @property {Object} position the current CSS position of the dialog
         * @property {Object} size the current size of the dialog
         */
        resizeStart: null,
        /**
         * Triggered when the user stops resizing the dialog.
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @ojshortdesc Triggered when the user stops resizing the dialog. See the Help documentation for more information.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {Object} originalEvent the underlying UI <a href="http://api.jqueryui.com/resizable/#event-resize">Event</a> object
         * @property {Object} originalPosition the original CSS position of the dialog
         * @property {Object} originalSize the original size of the dialog
         * @property {Object} position the current CSS position of the dialog
         * @property {Object} size the current size of the dialog
         */
        resizeStop: null,
        /**
         * Triggered when a default animation is about to start, such as when the component is
         * being opened/closed or a child item is being added/removed. The default animation can
         * be cancelled by calling <code class="prettyprint">event.preventDefault</code>.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @ojshortdesc Triggered when a default animation is about to start, such as when the component is being opened/closed or a child item is being added/removed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {"open"|"close"} action The action that triggers the animation.<br><br>
         *            The number of actions can vary from component to component.
         *            Suggested values are:
         *                    <ul>
         *                      <li>"open" - when a dialog component is opened</li>
         *                      <li>"close" - when a dialog component is closed</li>
         *                    </ul>
         * @property {!Element} element target of animation
         * @property {!function():void} endCallback If the event listener calls
         *            event.preventDefault to cancel the default animation, It must call the
         *            endCallback function when it finishes its own animation handling and any
         *            custom animation has ended.
         *
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateStart</code> event to override the default
         *          "close" animation:</caption>
         * myDialog.addEventListener("ojAnimateStart", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is close
         *     if (event.detail.action == "close") {
         *       event.preventDefault();
         *       oj.AnimationUtils.slideOut(event.detail.element).then(event.detail.endCallback);
         *   });
         *
         * @example <caption>The default open and close animations are controlled via the theme
         *          (SCSS) :</caption>
         * $dialogOpenAnimation: ((effect: "zoomIn"), "fadeIn")  !default;
         * $dialogCloseAnimation: ((effect: "zoomOut"), "fadeOut")  !default;
         */

        animateStart: null,
        /**
         * Triggered when a default animation has ended, such as when the component is being
         * opened/closed or a child item is being added/removed. This event is not triggered if
         * the application has called preventDefault on the animateStart
         * event.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojDialog
         * @ojshortdesc Triggered when a default animation has ended, such as when the component is being opened/closed or a child item is being added/removed.
         * @instance
         * @ojcancelable
         * @ojbubbles
         * @property {!Element} element target of animation
         * @property {"open"|"close"} action The action that triggered the animation.<br><br>
         *                   The number of actions can vary from component to component.
         *                   Suggested values are:
         *                    <ul>
         *                      <li>"open" - when a dialog component is opened</li>
         *                      <li>"close" - when a dialog component is closed</li>
         *                    </ul>
         *
         * @example <caption>Add a listener for the
         *          <code class="prettyprint">ojAnimateEnd</code> event to listen for the "close"
         *          ending animation:</caption>
         * myDialog.addEventListener("ojAnimateEnd", function( event )
         *   {
         *     // verify that the component firing the event is a component of interest and action
         *      is close
         *     if (event.detail.action == "close") {}
         *   });
         *
         * @example <caption>The default open and close animations are controlled via the theme
         *          (SCSS) :</caption>
         * $dialogOpenAnimation: (effect: "zoomIn", fade: true)  !default;
         * $dialogCloseAnimation: (effect: "zoomOut", fade: true)  !default;
         */
        animateEnd: null
      },
      /**
       * @memberof oj.ojDialog
       * @instance
       * @protected
       * @override
       * @return {void}
       */

      _ComponentCreate: function () {
        this._super();
        var self = this;

        this.originalCss = {
          display: this.element[0].style.display,
          width: this.element[0].style.width,
          height: this.element[0].style.height
        };
        this.originalPosition = {
          parent: this.element.parent(),
          index: this.element.parent().children().index(this.element)
        };

        // For the widget syntax, pull the title attribute from the root element moving to an option
        if (!this._IsCustomElement()) {
          this.originalTitle = this.element.attr('title');
          this.options.title = this.options.title || this.originalTitle;
          this.element.removeAttr('title');
        }

        this.element.hide();
        this.element.uniqueId();
        this.element.addClass('oj-dialog oj-component');
        this.element.attr({
          // Setting tabIndex makes the div focusable
          tabIndex: -1
        });

        if (!this._IsCustomElement() || !this.element[0].hasAttribute('role')) {
          this.element.attr('role', this.options.role);
        }

        this._on(this.element, { keydown: this._keydownHandler.bind(this) });

        // fixup references to header, body and footer.  assumption is they will be immediate children
        // of the root node.
        this.userDefinedDialogHeader = false;

        this._createContainer();

        if (!this._IsCustomElement()) {
          var children = this.element.children();
          for (var i = 0; i < children.length; i++) {
            var child = $(children[i]);
            if (child.is(OJD_HEADER_CLASS)) {
              this.userDefinedDialogHeader = true;
              this._userDefinedHeader = child;
              this._userDefinedHeaderDiv = children[i];
              this._dialogContainer.appendChild(this._userDefinedHeader[0]); // @HTMLUpdateOK
              Components.subtreeAttached(this._userDefinedHeader);
            } else if (child.is(OJD_BODY_CLASS)) {
              this._createContentDiv();
              this._uiDialogContent = $(this._contentDiv);

              this._contentDiv.appendChild(children[i]); // @HTMLUpdateOK
              Components.subtreeAttached(children[i]);

              this._dialogContainer.appendChild(this._contentDiv); // @HTMLUpdateOK
              Components.subtreeAttached(this._contentDiv);

              this._uiDialogBody = child;
              this._uiDialogBodyDiv = children[i];
            } else if (child.is(OJD_FOOTER_CLASS)) {
              this._uiDialogFooter = child;
              this._uiDialogFooterDiv = children[i];
              this._dialogContainer.appendChild(this._uiDialogFooter[0]); // @HTMLUpdateOK
              Components.subtreeAttached(this._uiDialogFooter);
            }
          }
        }

        if (this._IsCustomElement()) {
          this._processSlottedChildren();
        }

        this.element[0].appendChild(this._dialogContainer); // @HTMLUpdateOK
        Components.subtreeAttached(this._dialogContainer);

        // fixup dialog header
        if (this.userDefinedDialogHeader) {
          this._userDefinedTitleDiv = this._userDefinedHeaderDiv.querySelector(OJD_TITLE_CLASS);
          this._userDefinedTitle = $(this._userDefinedTitleDiv);

          if (this._userDefinedTitleDiv !== null && this._userDefinedTitleDiv !== undefined) {
            // create an id for the user-defined title
            this._userDefinedTitle.uniqueId();
            // to meet accessibility requirements for user-defined headers,
            // associate the title id with the .oj-dialog aria-labelledby.
            this.element.attr({ 'aria-labelledby': this._userDefinedTitle.attr('id') });
          }
        } else {
          this._createTitlebar();
        }

        // body was not provided. insert the content between the header and footer
        if (!this._uiDialogContent) {
          this._createContentDiv();
          this._uiDialogContent = $(this._contentDiv);

          if (this._userDefinedHeader) {
            // prettier-ignore
            this._dialogContainer.insertBefore( // @HTMLUpdateOK
              this._contentDiv,
              this._userDefinedHeaderDiv.nextSibling
            );
          } else {
            // prettier-ignore
            this._dialogContainer.insertBefore( // @HTMLUpdateOK
              this._contentDiv,
              this._uiDialogTitlebarDiv.nextSibling
            );
          }
          Components.subtreeAttached(this._contentDiv);
        }

        this._setupFocus(this.element);

        // fixup the position option set via the widget constructor
        var options = this.options;
        options.position = oj.PositionUtils.coerceToJet(options.position);

        // For custom element dialogs, detect changes to the 'title' attribute using a mutation observer.
        // Update the dialog title DOM on 'title' attribute change.
        if (this._IsCustomElement()) {
          this._titleMutationObserver = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
              if (mutation.type === 'attributes') {
                if (mutation.attributeName === 'title') {
                  self._uiDialogTitleDiv.textContent = mutation.target.getAttribute(
                    mutation.attributeName
                  );
                }
              }
            });
          });
          // Start observing the dialog element for changes to the title attribute.
          this._titleMutationObserver.observe(this.element[0], {
            attributes: true,
            attributeFilter: ['title']
          });
        }
      },

      _createContainer: function () {
        this._dialogContainer = document.createElement('div');
        this._dialogContainer.classList.add(OJD_CONTAINER);
        this._dialogContainer.setAttribute('data-oj-context', '');
      },

      _createHeaderSlot: function () {
        this._headerSlot = document.createElement('div');
        this._headerSlot.classList.add(OJD_HEADER);

        this._dialogContainer.appendChild(this._headerSlot); // @HTMLUpdateOK
        Components.subtreeAttached(this._headerSlot);

        this.userDefinedDialogHeader = true;
        this._userDefinedHeaderDiv = this._headerSlot;
        this._userDefinedHeader = $(this._headerSlot);
      },

      // Create the footer slot element.
      _createFooterSlot: function () {
        this._footerSlot = document.createElement('div');

        this._dialogContainer.appendChild(this._footerSlot); // @HTMLUpdateOK
        Components.subtreeAttached(this._footerSlot);
        this._uiDialogFooterDiv = this._footerSlot;
        this._uiDialogFooter = $(this._footerSlot);
      },

      _createContentDiv: function () {
        this._contentDiv = document.createElement('div');
        this._contentDiv.classList.add(OJD_CONTENT, 'oj-dialog-default-content');
      },

      // Create the body slot element
      _createBodySlot: function () {
        this._createContentDiv();

        this._dialogContainer.appendChild(this._contentDiv); // @HTMLUpdateOK
        Components.subtreeAttached(this._contentDiv);

        this._bodySlot = document.createElement('div');
        this._bodySlot.classList.add('oj-dialog-body-wrapper');

        this._contentDiv.appendChild(this._bodySlot); // @HTMLUpdateOK
        this._uiDialogContent = $(this._contentDiv);

        this._uiDialogBodyDiv = this._bodySlot;
        this._uiDialogBody = $(this._bodySlot);
      },

      // override in order to return the reparented location of the context menu slot
      _GetContextMenu: function () {
        if (this._IsCustomElement()) {
          if (this._contextmenuSlot && this._contextmenuSlot.length > 0) {
            return this._contextmenuSlot[0];
          }
          return this._super();
        }
        return null;
      },

      // Process any slotted children and move them into the correct location
      _processSlottedChildren: function () {
        if (this._footerSlot != null) {
          this.element[0].removeChild(this._footerSlot);
        }
        if (this._headerSlot != null) {
          this.element[0].removeChild(this._headerSlot);
        }
        if (this._bodySlot != null) {
          this.element[0].removeChild(this._bodySlot);
        }
        if (this._contextmenuSlot != null) {
          this.element[0].removeChild(this._contextmenuSlot);
        }

        var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(this.element[0]);
        var slots = Object.keys(slotMap);
        var slot;
        var s;

        for (s = 0; s < slots.length; s++) {
          slot = slots[s];
          if (
            slot !== SLOT_HEADER &&
            slot !== SLOT_FOOTER &&
            slot !== SLOT_BODY &&
            slot !== SLOT_DEFAULT &&
            slot !== SLOT_CONTEXTMENU
          ) {
            // silently remove as per custom component slot behavior
            slotMap[slot].parentNode.removeChild(slotMap[slot]);
          }
        }

        var hasOwnProperty = Object.prototype.hasOwnProperty;
        if (hasOwnProperty.call(slotMap, SLOT_HEADER)) {
          this._createHeaderSlot();
        }

        // Note that the default slot is the body slot.
        if (hasOwnProperty.call(slotMap, SLOT_BODY) || hasOwnProperty.call(slotMap, SLOT_DEFAULT)) {
          this._createBodySlot();
        }

        if (hasOwnProperty.call(slotMap, SLOT_FOOTER)) {
          this._createFooterSlot();
        }

        // save the location of the context menu slot.
        if (hasOwnProperty.call(slotMap, SLOT_CONTEXTMENU)) {
          this._contextmenuSlot = slotMap[SLOT_CONTEXTMENU];
        }

        var slotParent = this._bodySlot;
        for (s = 0; s < slots.length; s++) {
          slot = slots[s];
          switch (slot) {
            case SLOT_HEADER:
              // Note - the header is wrapped with the title for accessibility,
              // so we add the oj-dialog-header class during wrap process.
              slotParent = this._headerSlot;
              break;
            case SLOT_FOOTER:
              slotParent = this._footerSlot;
              break;
            case SLOT_BODY:
            case SLOT_DEFAULT:
              slotParent = this._bodySlot;
              break;
            default:
              break;
          }

          var slotElements = slotMap[slot];
          if (slotElements != null) {
            for (var i = 0; i < slotElements.length; i++) {
              slotParent.appendChild(slotElements[i]); // @HTMLUpdateOK
              switch (slot) {
                case SLOT_HEADER:
                  break;
                case SLOT_FOOTER:
                  slotParent = this._footerSlot;
                  slotMap[slot][i].classList.add(OJD_FOOTER);
                  break;
                case SLOT_BODY:
                case SLOT_DEFAULT:
                  slotParent = this._bodySlot;
                  slotMap[slot][i].classList.add(OJD_BODY);
                  break;
                default:
                  break;
              }
            }
          }
        }
      },

      /**
       * @memberof oj.ojDialog
       * @instance
       * @protected
       * @override
       */
      _AfterCreateEvent: function () {
        if (this.options.initialVisibility === 'show') {
          this.open();
        }
      },
      /**
       * @memberof oj.ojDialog
       * @instance
       * @protected
       * @override
       */
      _destroy: function () {
        this._off(this.element, 'keydown');

        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._closeImplicitly();
        }

        this._setWhenReady('none');

        this._destroyResizable();

        if (this.element.hasClass(OJ_DRAGGABLE)) {
          this.element.draggable('destroy');
          this.element.removeClass(OJ_DRAGGABLE);
        }

        this._destroyCloseButton();

        if (this.userDefinedDialogHeader) {
          // remove any unique id from the user-defined header's title
          this._userDefinedTitle.removeUniqueId();
        }

        if (this._uiDialogBody) {
          // unwrap the dialog body from the content element.
          this._uiDialogBody.insertAfter(this._uiDialogContent); // @HTMLUpdateOK safe manipulation
        }
        this._uiDialogContent.remove();
        this._uiDialogBody = null;
        this._uiDialogContent = null;

        this.element.removeUniqueId().removeClass('oj-dialog oj-component').css(this.originalCss);

        this.element.stop(true, true);

        if (!this._IsCustomElement()) {
          if (this.originalTitle) {
            this.element.attr('title', this.originalTitle);
          }
        }

        if (this._uiDialogTitlebar) {
          this._uiDialogTitlebar.remove();
          this._uiDialogTitlebar = null;
        }

        delete this._popupServiceEvents;
        this._super();
      },
      disable: $.noop,
      enable: $.noop,
      /**
       * Closes the dialog.
       *
       * @expose
       * @name oj.ojDialog#close
       * @method
       * @memberof oj.ojDialog
       * @instance
       * @return {void}
       * @fires oj.ojDialog#beforeClose
       * @fires oj.ojDialog#close
       *
       * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
       * myDialog.close();
       */
      close: function (event) {
        if (this._isOperationPending('close', [event])) {
          return;
        }

        // can only close an open dialog.
        var status = oj.ZOrderUtils.getStatus(this.element);
        if (status !== oj.ZOrderUtils.STATUS.OPEN) {
          return;
        }

        // Status toggle is needed to prevent a recursive closed callled from a
        // beforeClose handler. The _isOperationPending gatekeeper isn't activated
        // until after the _setWhenReady('close'|'open') call.
        oj.ZOrderUtils.setStatus(this.element, oj.ZOrderUtils.STATUS.BEFORE_CLOSE);
        if (this._trigger('beforeClose', event) === false && !this._ignoreBeforeCloseResultant) {
          oj.ZOrderUtils.setStatus(this.element, status);
          return;
        }

        // activates the _isOperationPending gatekeeper
        this._setWhenReady('close');
        this._focusedElement = null;

        // if dialog modality is modal, check if we need
        // to restore the disabled accesskey attributes
        if (this.options.modality === 'modal') {
          var forEach = Array.prototype.forEach;
          // Find elements within dialog that have accesskey and remove marker added during open
          var elementsInDialogWithAccesskey = this.element[0].querySelectorAll(
            '.oj-helper-element-in-dialog-with-accesskey'
          );
          forEach.call(elementsInDialogWithAccesskey, function (element) {
            element.classList.remove(OJD_HELPER_ELEMENT_DIALOG);
          });
          // Find elements with oj-helper-element-with-accesskey class, get accesskey value from data attr, set accesskey attr, remove class
          var elementsInDOMWithAccesskey = document.querySelectorAll(
            '.oj-helper-element-with-accesskey'
          );
          forEach.call(elementsInDOMWithAccesskey, function (element) {
            element.setAttribute('accesskey', element.getAttribute(OJD_ACCESS_KEY));
            element.removeAttribute(OJD_ACCESS_KEY);
            element.classList.remove('oj-helper-element-with-accesskey');
          });
        }

        /** @type {!Object.<oj.PopupService.OPTION, ?>} */
        var psOptions = {};
        psOptions[oj.PopupService.OPTION.POPUP] = this.element;
        psOptions[oj.PopupService.OPTION.CONTEXT] = { closeEvent: event };
        oj.PopupService.getInstance().close(psOptions);
      },
      /**
       * Before callback is invoked while the dialog is still visible and still parented in the zorder container.
       * Close animation is performed here.
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the popup
       * @return {Promise|void}
       */
      _beforeCloseHandler: function (psOptions) {
        var rootElement = psOptions[oj.PopupService.OPTION.POPUP];
        var isFull = this._isFullDisplay();
        var isSheet = this._isSheetDisplay();

        this._unregisterResizeListener(rootElement[0]);

        this.element[0].classList.remove('oj-dialog-small-screen');

        this._destroyResizable();
        if (isSheet) {
          // turn off body overflow for animation duration in 'sheet' mode
          this._disableBodyOverflow();
        }

        var animationOptions = (ThemeUtils.parseJSONFromFontFamily(OJD_OPTION_DEFAULTS) || {})
          .animation;
        var closeAnimation;
        if (animationOptions) {
          if (isSheet && !isFull && animationOptions.sheet) {
            closeAnimation = animationOptions.sheet.close;
          } else if (animationOptions.normal) {
            closeAnimation = animationOptions.normal.close;
          } else if (animationOptions.close) {
            // compatibility with older themes
            closeAnimation = animationOptions.close;
          }
        }
        if (!this._ignoreBeforeCloseResultant && closeAnimation) {
          // eslint-disable-next-line no-undef
          return AnimationUtils.startAnimation(rootElement[0], 'close', closeAnimation, this).then(
            function () {
              rootElement.hide();
            }
          );
        }

        rootElement.hide();
        return undefined;
      },
      /**
       * Close finalization callback.
       *
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for closing the popup
       * @return {void}
       */
      _afterCloseHandler: function (psOptions) {
        var context = psOptions[oj.PopupService.OPTION.CONTEXT];
        this._restoreBodyOverflow();

        // Moved from close(). Don't want to move focus until the close animation completed.
        // If the launcher is not focusable, find the closet focuable ancestor
        if (!this.opener.filter(':focusable').focus().length) {
          var launcher = this.opener.parents().filter(':focusable');
          if (launcher.length > 0) {
            launcher[0].focus();
          } else {
            // Hiding a focused element doesn't trigger blur in WebKit
            // so in case we have nothing to focus on, explicitly blur the active element
            // https://bugs.webkit.org/show_bug.cgi?id=47182
            $(this.document[0].activeElement).blur();
          }
        }

        var event;
        if (context) {
          event = context.closeEvent;
        }

        this._trigger('close', event);
      },
      /**
       * <p>Returns true if the dialog is currently open. This method does not accept any arguments.
       * </p>
       *
       * The "open" state reflects the period of time the dialog is visible, including open and
       * close animations.
       *
       * @expose
       * @method
       * @name oj.ojDialog#isOpen
       * @ojshortdesc Returns true if the dialog is currently open.
       * @memberof oj.ojDialog
       * @instance
       * @return {boolean} <code>true</code> if the dialog is open.
       *
       * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
       * var isOpen = myDialog.isOpen();
       */
      isOpen: function () {
        var status = oj.ZOrderUtils.getStatus(this.element);
        // the window is visible and reparented to the zorder container for these statuses
        return (
          status === oj.ZOrderUtils.STATUS.OPENING ||
          status === oj.ZOrderUtils.STATUS.OPEN ||
          status === oj.ZOrderUtils.STATUS.BEFORE_CLOSE ||
          status === oj.ZOrderUtils.STATUS.CLOSING
        );
      },
      /**
       * Opens the dialog.
       *
       * @expose
       * @method
       * @name oj.ojDialog#open
       * @memberof oj.ojDialog
       * @instance
       * @return {void}
       * @fires oj.ojDialog#beforeOpen
       * @fires oj.ojDialog#open
       *
       * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
       * var open = myDialog.open();
       */
      open: function (event) {
        if (this._isOperationPending('open', [event])) {
          return;
        }

        // calling open on a dialog in an open state will result in calling the
        // beforeOpen followed by resetting inital focus. This is different behavior
        // than the popup which forces a sync close follwed by a reopen - dialog
        // doesn't have accessiblity launcher requirements.
        var status = oj.ZOrderUtils.getStatus(this.element);
        if (
          !(
            status === oj.ZOrderUtils.STATUS.OPEN ||
            status === oj.ZOrderUtils.STATUS.UNKNOWN ||
            status === oj.ZOrderUtils.STATUS.CLOSE
          )
        ) {
          return;
        }

        this._isDefaultPosition = !this._hasPositionAttribute();

        // status change is needed to prevent calling open from an on before open
        // handler.  The _isOperationPending doens't gurard until this._setWhenReady('open');
        oj.ZOrderUtils.setStatus(this.element, oj.ZOrderUtils.STATUS.BEFORE_OPEN);
        if (this._trigger('beforeOpen', event) === false) {
          oj.ZOrderUtils.setStatus(this.element, status);
          return;
        }

        // open was called on a open dialog, just establish intial focus
        if (status === oj.ZOrderUtils.STATUS.OPEN) {
          oj.ZOrderUtils.setStatus(this.element, status);
          this._focusTabbable();
          return;
        }

        // activates the isOperationPending gate keeper
        this._setWhenReady('open');

        if (this.userDefinedDialogHeader) {
          // Add close button to user-defined header
          if (
            (this.closeButton === undefined || this.closeButton === null) &&
            this.options.cancelBehavior === 'icon'
          ) {
            this._createCloseButton(this._userDefinedHeaderDiv);
          }
        } else {
          this._createTitlebarCloseButton();
        }

        this.opener = $(this.document[0].activeElement);

        var isSheetDisplay = this._isSheetDisplay();

        if (isSheetDisplay) {
          this.element[0].classList.add('oj-dialog-sheet');
        }

        if (!isSheetDisplay && this.options.dragAffordance === 'title-bar' && $.fn.draggable) {
          this._makeDraggable();
        }

        if (!isSheetDisplay && this._isSmallScreen()) {
          this.element[0].classList.add('oj-dialog-small-screen');
        }

        // normalize alignments, so that start and end keywords work as expected.
        var isRtl = this._GetReadingDirection() === 'rtl';
        var position = this.options.position;
        if (isSheetDisplay) {
          position = this._setSheetPosition(this.options.position);
        }
        position = oj.PositionUtils.coerceToJqUi(position);
        position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);

        // if modality is set to modal, prevent accesskey events
        // from being triggered while dialog is open
        if (this.options.modality === 'modal') {
          var forEach = Array.prototype.forEach;
          // Mark elements within the dialog that have an accesskey attr. Those shouldn't have accesskey attr removed
          var elementsInDialogWithAccesskey = this.element[0].querySelectorAll('[accesskey]');
          forEach.call(elementsInDialogWithAccesskey, function (element) {
            element.classList.add(OJD_HELPER_ELEMENT_DIALOG);
          });
          // Mark elements with accesskey attr, move accesskey value to data attr, remove accesskey attr from elements
          var elementsInDOMWithAccesskey = document.querySelectorAll('[accesskey]');
          forEach.call(elementsInDOMWithAccesskey, function (element) {
            if (!element.classList.contains(OJD_HELPER_ELEMENT_DIALOG)) {
              element.classList.add('oj-helper-element-with-accesskey');
              element.setAttribute(OJD_ACCESS_KEY, element.getAttribute('accesskey')); // @HTMLUpdateOK
              element.removeAttribute('accesskey');
            }
          });
        }

        /** @type {!Object.<oj.PopupService.OPTION, ?>} */
        var psOptions = {};
        psOptions[oj.PopupService.OPTION.POPUP] = this.element;
        psOptions[oj.PopupService.OPTION.LAUNCHER] = this.opener;
        psOptions[oj.PopupService.OPTION.POSITION] = position;
        psOptions[oj.PopupService.OPTION.MODALITY] = this.options.modality;
        psOptions[oj.PopupService.OPTION.EVENTS] = this._getPopupServiceEvents();
        psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = 'oj-dialog-layer';
        psOptions[oj.PopupService.OPTION.LAYER_LEVEL] = oj.PopupService.LAYER_LEVEL.TOP_LEVEL;
        psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = this._IsCustomElement();
        oj.PopupService.getInstance().open(psOptions);
      },
      /**
       * Before open callback is called after the dialog has been reparented into the
       * zorder container. Open animation is performed here.
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the popup
       * @return {Promise|void}
       */
      _beforeOpenHandler: function (psOptions) {
        var rootElement = psOptions[oj.PopupService.OPTION.POPUP];
        var position = psOptions[oj.PopupService.OPTION.POSITION];

        var isSheet = this._isSheetDisplay();
        if (isSheet) {
          // turn off overflow before animating in 'sheet' mode
          this._disableBodyOverflow();
        }

        rootElement.show();

        var isFull = this._isFullDisplay();
        if (isFull) {
          this.element[0].classList.add('oj-dialog-full');
        }

        rootElement.position(position);

        // note the initial dialog width/height
        this._initialWidth = rootElement.width();
        this._initialHeight = rootElement.height();

        this._registerResizeListener(this.element[0]);

        // JET-58635: move focus to the dialog as soon as possible
        this._focusTabbable();

        // We add .oj-animate-open when the dialog is animating on open.
        // This supports maintaing the visibility of a nested dialog during animation open.
        rootElement.parent().addClass('oj-animate-open');

        var animationOptions = (ThemeUtils.parseJSONFromFontFamily(OJD_OPTION_DEFAULTS) || {})
          .animation;
        var openAnimation;
        if (animationOptions) {
          if (isSheet && !isFull && animationOptions.sheet) {
            openAnimation = animationOptions.sheet.open;
          } else if (animationOptions.normal) {
            openAnimation = animationOptions.normal.open;
          } else if (animationOptions.open) {
            // compatibility with older themes
            openAnimation = animationOptions.open;
          }
        }
        if (openAnimation) {
          // eslint-disable-next-line no-undef
          return AnimationUtils.startAnimation(rootElement[0], 'open', openAnimation, this);
        }

        return undefined;
      },
      /**
       * Called after the dialog is shown. Perform open finalization.
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @param {!Object.<oj.PopupService.OPTION, ?>} psOptions property bag for opening the popup
       * @return {void}
       */
      _afterOpenHandler: function (psOptions) {
        var rootElement = psOptions[oj.PopupService.OPTION.POPUP];
        rootElement.parent().removeClass('oj-animate-open');

        // JET-44685: iOS may reveal address bar during open animation, need to make sure the position is set
        // properly after the animation completes
        if (oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS) {
          this._adjustPosition();
        } else if (
          this._initialWidth !== rootElement.width() ||
          this._initialHeight !== rootElement.height()
        ) {
          this._adjustPosition();
        }
        delete this._initialWidth;
        delete this._initialHeight;

        this._restoreBodyOverflow();
        this._makeResizable();
        this._trigger('open');
        // this._focusTabbable();
      },
      /**
       * Refresh the dialog.
       * Typically used after dynamic content is added to a dialog.
       * @expose
       * @method
       * @name oj.ojDialog#refresh
       * @memberof oj.ojDialog
       * @instance
       * @return {void}
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myDialog.refresh();
       */
      refresh: function () {
        this._super();
      },

      /**
       * Unregister event listeners for resize the dialog element.
       * @param {Element} element  DOM element
       * @private
       */
      _unregisterResizeListener: function (element) {
        if (element && this._resizeHandler) {
          // remove existing listener
          DomUtils.removeResizeListener(element, this._resizeHandler);
          this._resizeHandler = null;
        }
      },

      /**
       * Register event listeners for resize the dialog element.
       * @param {Element} element  DOM element
       * @private
       */
      _registerResizeListener: function (element) {
        if (element) {
          if (this._resizeHandler == null) {
            this._resizeHandler = this._handleResize.bind(this);
          }
          DomUtils.addResizeListener(element, this._resizeHandler, 100, true);
        }
      },

      /**
       * Resize handler to adjust dialog position when the size changes after
       * initial render.
       *
       * @memberof oj.ojDialog
       * @instance
       * @private
       */
      _handleResize: function () {
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._adjustPosition();
        }
      },

      /**
       * @memberof oj.ojDialog
       * @instance
       * @private
       */
      _focusTabbable: function () {
        // postpone setting focus until the content has been upgraded
        var busyContext = oj.Context.getContext(this._dialogContainer).getBusyContext();
        busyContext.whenReady().then(
          function () {
            var hasFocus = this.GetFocusElement();
            hasFocus.focus();
            this._trigger('focus');
          }.bind(this)
        );
      },

      /**
       * Returns the current focusable element for this component which can be the root custom element
       * or an HTML element like an input or select.
       * @return {Element}
       * @memberof oj.ojDialog
       * @instance
       * @protected
       * @override
       */
      GetFocusElement: function () {
        var hasFocus = null;

        // Set focus to the outer dialog if the title-bar is clicked (or dragged).
        if (this._titleBarMousedown === true) {
          return this.element[0];
        }

        // Set focus to the first match:
        // 1. First element inside the dialog matching [autofocus]
        // 2. Tabbable element inside the content element
        // 3. Tabbable element inside the footer
        // 4. The close button
        // 5. The dialog itself

        hasFocus = this.element.find('[autofocus]');

        if (hasFocus == null || !hasFocus.length) {
          hasFocus = FocusUtils.getFirstTabStop(this._contentDiv);
          if (hasFocus != null) return hasFocus;
        }
        if (hasFocus == null || !hasFocus.length) {
          if (this._uiDialogFooter && this._uiDialogFooter.length) {
            hasFocus = FocusUtils.getFirstTabStop(this._uiDialogFooterDiv);
            if (hasFocus != null) return hasFocus;
          }
        }
        if (hasFocus == null || !hasFocus.length) {
          if (this.closeButton) {
            hasFocus = this.closeButton;
          }
        }
        if (hasFocus == null || !hasFocus.length) {
          hasFocus = this.element;
        }
        return hasFocus[0];
      },

      _keydownHandler: function (event) {
        if (
          this.options.cancelBehavior !== 'none' &&
          !event.isDefaultPrevented() &&
          event.keyCode &&
          event.keyCode === $.ui.keyCode.ESCAPE
        ) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.close(event);
          return;
        }

        if (event.keyCode !== $.ui.keyCode.TAB) {
          return;
        }

        // prevent tabbing out of dialogs
        var focusItem;

        // Note that we check document.activeElement instead of event.target since
        // descendant elements such as ojTable may change focus when handling Tab key.
        // This aligns with browser behavior because it determines next tabstop
        // based on activeElement.
        if (!event.shiftKey) {
          // For TAB, we cycle when we are on the last element.
          if (
            FocusUtils.isLastActiveElement(this.element) ||
            document.activeElement === this.element[0]
          ) {
            focusItem = FocusUtils.getFirstTabStop(this.element);
            if (focusItem != null) {
              focusItem.focus();
              event.preventDefault();
            }
          }
        } else if (
          FocusUtils.isFirstActiveElement(this.element) ||
          document.activeElement === this.element[0]
        ) {
          // For SHIFT-TAB, we cycle when we are on the first element.
          focusItem = FocusUtils.getLastTabStop(this.element);
          if (focusItem != null) {
            focusItem.focus();
            event.preventDefault();
          }
        }
      },

      //
      // Invoke focusable on the passed element.
      // Called on two distinct elements - the outer dialog,
      // and the closeWrapper (assuming that there is an x-icon in the dialog)
      //
      _setupFocus: function (elem) {
        var self = this;
        this._focusable({
          applyHighlight: true,
          setupHandlers: function (focusInHandler, focusOutHandler) {
            self._on(elem, {
              focus: function (event) {
                focusInHandler($(event.currentTarget));
              },
              blur: function (event) {
                focusOutHandler($(event.currentTarget));
              }
            });
          }
        });
      },

      _disableBodyOverflow: function () {
        var body = document.body;
        body.classList.add('oj-dialog-sheet-animating');
      },

      _restoreBodyOverflow: function () {
        var body = document.body;
        body.classList.remove('oj-dialog-sheet-animating');
      },

      _destroyCloseButton: function () {
        if (this.closeButtonDiv !== null && this.closeButtonDiv !== undefined) {
          if (this.closeButtonDiv.parentElement) {
            Components.subtreeDetached(this.closeButtonDiv);
            this.closeButtonDiv.parentElement.removeChild(this.closeButtonDiv);
          }

          this.closeButton = null;
        }

        if (this._headerSlot) {
          this._headerSlot.classList.remove(OJD_HEADER_CLOSE);
        }
        if (this._uiDialogTitlebarDiv) {
          this._uiDialogTitlebarDiv.classList.remove(OJD_HEADER_CLOSE);
        }
      },

      //
      // Create a close button.
      // Needed for user-defined headers.
      //
      _createCloseButton: function (divParentElement) {
        // use oj-button for custom element implementations
        if (this._IsCustomElement()) {
          this.closeButtonDiv = document.createElement('oj-button');
          this.closeButtonDiv.classList.add(OJD_HEADER_CLOSE_WRAPPER);
          this.closeButtonDiv.setAttribute('data-oj-binding-provider', 'none');
          this.closeButtonDiv.setAttribute('display', 'icons');
          this.closeButtonDiv.setAttribute('chroming', 'half');

          var closeButtonLabel = document.createElement('span');
          closeButtonLabel.textContent = this.getTranslatedString('labelCloseIcon');

          var closeButtonStartIcon = document.createElement('span');
          closeButtonStartIcon.className = 'oj-fwk-icon oj-fwk-icon-cross';
          closeButtonStartIcon.setAttribute('slot', 'startIcon');

          this.closeButtonDiv.appendChild(closeButtonStartIcon);
          this.closeButtonDiv.appendChild(closeButtonLabel);

          divParentElement.appendChild(this.closeButtonDiv); // @HTMLUpdateOK
          Components.subtreeAttached(this.closeButtonDiv);

          this.closeButton = $(this.closeButtonDiv);
        }

        if (!this._IsCustomElement()) {
          this.closeButton = $('<button><\button>').addClass(OJD_HEADER_CLOSE_WRAPPER);

          this.closeButton
            .ojButton({
              display: 'icons',
              chroming: 'half',
              label: this.getTranslatedString('labelCloseIcon'),
              icons: { start: 'oj-component-icon oj-fwk-icon-cross' }
            })
            .appendTo(divParentElement); // @HTMLUpdateOK

          this.closeButtonDiv = this.closeButton[0];
        }

        this._on(this.closeButton, {
          click: function (event) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.close(event);
          }
        });

        // When the close button is present, add a class to the title bar.
        // This is used to conditionally apply style changes to the title div.
        if (this._headerSlot) {
          this._headerSlot.classList.add(OJD_HEADER_CLOSE);
        }
        if (this._uiDialogTitlebarDiv) {
          this._uiDialogTitlebarDiv.classList.add(OJD_HEADER_CLOSE);
        }

        // no need to do this - buttons handle focus on their own.
        // var hasFocus = this.closeButton;
        // this._setupFocus(hasFocus);
      },

      //
      // Create the close button and the titlebar's mousedown handler.
      //
      _createTitlebarCloseButton: function () {
        if (
          (this.closeButton === undefined || this.closeButton === null) &&
          this.options.cancelBehavior === 'icon'
        ) {
          this._createCloseButton(this._uiDialogTitlebarDiv);
        }

        this._on(this._uiDialogTitlebar, {
          mousedown: function (event) {
            // Don't prevent click on close button (#8838)
            // Focusing a dialog that is partially scrolled out of view
            // causes the browser to scroll it into view, preventing the click event
            // Note that the implementation will search for the dialog close wrapper class
            // in parent, grandparent, etc., in order to handle custom element vs. widget syntax,
            // as well as handle the differences in browser event implementions (e.g. IE reports
            // a shallower button stack for button click events).
            //
            var isCloseButton = DomUtils.isAncestorOrSelf(this.closeButtonDiv, event.target);
            this._titleBarMousedown = true;
            if (!isCloseButton) {
              // Set focus to the dialog if we are dragging by the header
              this.element.focus();
            }
          },
          mouseup: function () {
            this._titleBarMousedown = null;
          }
        });
      },

      _createTitlebar: function () {
        this._uiDialogTitlebarDiv = document.createElement('div');
        this._uiDialogTitlebarDiv.classList.add(OJD_HEADER);

        // prettier-ignore
        this._dialogContainer.insertBefore( // @HTMLUpdateOK
          this._uiDialogTitlebarDiv,
          this._dialogContainer.firstChild
        );

        Components.subtreeAttached(this._uiDialogTitlebarDiv);

        this._uiDialogTitlebar = $(this._uiDialogTitlebarDiv);

        this._uiDialogTitleDiv = document.createElement('h1');
        this._uiDialogTitleDiv.classList.add('oj-dialog-title');
        $(this._uiDialogTitleDiv).uniqueId();
        this._uiDialogTitlebarDiv.appendChild(this._uiDialogTitleDiv); // @HTMLUpdateOK
        Components.subtreeAttached(this._uiDialogTitleDiv);

        this._title(this._uiDialogTitleDiv);

        this.element.attr({
          'aria-labelledby': this._uiDialogTitleDiv.id
        });
      },

      _title: function (_title) {
        var title = _title;

        // Set the content of the title.
        if (!this._IsCustomElement()) {
          if (!this.options.title) {
            title.innerHTML = '&#160;'; // @HTMLUpdateOK
          }
          title.textContent = this.options.title;
        } else if (this._IsCustomElement()) {
          if (this.options.dialogTitle) {
            title.textContent = this.options.dialogTitle;
          } else if (this.element.attr('title')) {
            title.textContent = this.element.attr('title');
          } else {
            title.innerHTML = '&#160;'; // @HTMLUpdateOK
          }
        }
      },

      _makeDraggable: function () {
        var that = this;
        var options = this.options;

        function filteredUi(ui) {
          return {
            position: ui.position,
            offset: ui.offset
          };
        }

        this.element.draggable({
          addClasses: false,
          handle: '.oj-dialog-header',
          containment: 'document',
          start: function (event, ui) {
            $(this).addClass('oj-dialog-dragging');
            that._positionDescendents();
            that._trigger('dragStart', event, filteredUi(ui));
          },
          drag: function (event, ui) {
            //
            // call positionDescendents so that any descendents,
            // such as a pulldown menu, will be repositioned as the dialog is dragged.
            //
            that._positionDescendents();
            that._trigger('drag', event, filteredUi(ui));
          },
          stop: function (event, ui) {
            var left = ui.offset.left - that.document.scrollLeft();
            var top = ui.offset.top - that.document.scrollTop();

            options.position = {
              my: { horizontal: 'left', vertical: 'top' },
              at: { horizontal: 'left', vertical: 'top' },
              offset: { x: left >= 0 ? left : 0, y: top >= 0 ? top : 0 },
              of: window
            };

            $(this).removeClass('oj-dialog-dragging');
            that._positionDescendents();
            that._trigger('dragStop', event, filteredUi(ui));
          }
        });

        this.element.addClass(OJ_DRAGGABLE);
      },
      _destroyResizable: function () {
        if (this._resizableComponent && this._resizableComponent('instance')) {
          this._resizableComponent('destroy');
          delete this._resizableComponent;
        }
      },
      _makeResizable: function () {
        this._destroyResizable();
        if (this.options.resizeBehavior !== 'resizable') {
          return;
        }
        var that = this;
        var resizeHandles = 'n,e,s,w,se,sw,ne,nw';

        function filteredUi(ui) {
          return {
            originalPosition: ui.originalPosition,
            originalSize: ui.originalSize,
            position: ui.position,
            size: ui.size
          };
        }

        this._resizableComponent = this.element.ojResizable.bind(this.element);

        var minWidth = Math.max(DomUtils.getCSSLengthAsFloat(this.element.css('min-width')), 10);
        var minHeight = Math.max(DomUtils.getCSSLengthAsFloat(this.element.css('min-height')), 10);
        var maxWidth = DomUtils.getCSSLengthAsFloat(this.element.css('max-width'));
        var maxHeight = DomUtils.getCSSLengthAsFloat(this.element.css('max-height'));
        maxWidth = maxWidth === 0 ? null : maxWidth;
        maxHeight = maxHeight === 0 ? null : maxHeight;

        this._resizableComponent({
          minWidth: minWidth,
          minHeight: minHeight,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          cancel: OJD_CONTENT_CLASS,
          containment: 'document',
          handles: resizeHandles,
          start: function (event, ui) {
            that._isResizing = true;

            $(this).addClass('oj-dialog-resizing');
            // fire resizestart
            that._trigger('resizeStart', event, filteredUi(ui));
          },
          resize: function (event, ui) {
            that._trigger('resize', event, filteredUi(ui));
          },
          stop: function (event, ui) {
            that._isResizing = false;

            $(this).removeClass('oj-dialog-resizing');
            that._trigger('resizeStop', event, filteredUi(ui));
          }
        });
      },
      _position: function () {
        //
        // Extended position objects with better names to support RTL.
        //
        var isRtl = this._GetReadingDirection() === 'rtl';
        var position = this.options.position;
        if (this._isSheetDisplay()) {
          position = this._setSheetPosition(position);
        }
        position = oj.PositionUtils.coerceToJqUi(position);
        position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);
        this.element.position(position);

        this._positionDescendents();
      },
      _positionDescendents: function () {
        // trigger refresh of descendents
        oj.PopupService.getInstance().triggerOnDescendents(
          this.element,
          oj.PopupService.EVENT.POPUP_REFRESH
        );
      },
      _adjustPosition: function () {
        var isDraggable = this.element.hasClass(OJ_DRAGGABLE);
        var isResizable = this.element.hasClass(OJ_RESIZABLE);
        // do not adjust position for resizable, movable and big dialogs
        if (
          isDraggable ||
          isResizable ||
          this.element.width() > window.innerWidth ||
          this.element.height() > window.innerHeight
        ) {
          this._positionDescendents();
        } else {
          this._position();
        }
      },
      _isSheetDisplay: function () {
        if (this._isDefaultPosition) {
          var behavior = ThemeUtils.parseJSONFromFontFamily('oj-theme-json').behavior;
          var isPhone = Config.getDeviceRenderMode() === 'phone';
          if (behavior.includes('redwood') && isPhone) {
            return true;
          }
        }
        return false;
      },
      _isFullDisplay: function () {
        if (!this._isSheetDisplay()) {
          // full display supported on Redwood mobile only
          return false;
        }
        var height = window.innerHeight;
        var width = window.innerWidth;
        var elemHeight = this.element[0].offsetHeight;
        var elemWidth = this.element[0].offsetWidth;
        if (elemHeight >= height * 0.95 && elemWidth >= width * 0.95) {
          return true;
        }
        return false;
      },
      /* need to override max-height/width on small screens */
      _isSmallScreen: function () {
        if (window.innerHeight < 450 || window.innerWidth < 300) {
          return true;
        }
        return false;
      },
      _hasPositionAttribute: function () {
        var attrs = this.element[0].attributes;
        for (var i = 0; i < attrs.length; i++) {
          if (attrs[i].name.startsWith('position')) {
            return true;
          }
        }
        return false;
      },
      _setSheetPosition: function (position) {
        var pos = $.extend({}, position);
        pos.my.vertical = 'bottom';
        pos.at.vertical = 'bottom';
        pos.of = window;
        return pos;
      },
      _setOption: function (key, value, flags) {
        /* jshint maxcomplexity:15*/
        var isDraggable;

        // don't allow a dialog to be disabled.
        if (key === 'disabled') {
          return;
        }

        this._super(key, value, flags);

        switch (key) {
          case 'dragAffordance':
            isDraggable = this.element.hasClass(OJ_DRAGGABLE);

            if (isDraggable && value === 'none') {
              this.element.draggable('destroy');
              this.element.removeClass(OJ_DRAGGABLE);
            }

            if (!this._isSheetDisplay() && !isDraggable && value === 'title-bar') {
              this._makeDraggable();
            }

            break;

          case 'position':
            // convert to the internal position format and reevaluate the position.
            this._isDefaultPosition = false;
            var options = this.options;
            options.position = oj.PositionUtils.coerceToJet(value, options.position);
            this._position();

            // setting the option is handled here.  don't call on super.
            return;

          case 'resizeBehavior':
            if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
              this._makeResizable();
            }
            break;

          case 'title':
          case 'dialogTitle':
            if (this.userDefinedDialogHeader) {
              this._title(this._userDefinedHeaderDiv.querySelector(OJD_TITLE_CLASS));
            } else {
              this._title(this._uiDialogTitlebarDiv.querySelector(OJD_TITLE_CLASS));
            }
            break;
          case 'role':
            this.element.attr('role', value);
            break;

          case 'modality':
            if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
              /** @type {!Object.<oj.PopupService.OPTION, ?>} */
              var psOptions = {};
              psOptions[oj.PopupService.OPTION.POPUP] = this.element;
              psOptions[oj.PopupService.OPTION.MODALITY] = value;
              oj.PopupService.getInstance().changeOptions(psOptions);
            }
            break;

          case 'cancelBehavior':
            if (value === 'none' || value === 'escape') {
              this._destroyCloseButton();
            } else if (value === 'icon') {
              if (this.userDefinedDialogHeader) {
                this._destroyCloseButton();
                this._createCloseButton(this._userDefinedHeaderDiv);

                //
                // Insert oj-dialog-title between oj-dialog-header and oj-dialog-header-close-wrapper
                //
                this._userDefinedTitleDiv = this._userDefinedHeaderDiv.querySelector(OJD_TITLE_CLASS);
                this._userDefinedTitle = $(this._userDefinedTitleDiv);
              } else {
                this._destroyCloseButton();
                this._createCloseButton(this._uiDialogTitlebarDiv);

                this.standardTitleDiv = this._uiDialogTitlebarDiv.querySelector(OJD_TITLE_CLASS);
                this.standardTitle = $(this.standardTitleDiv);
              }
            }
            break;
          default:
            break;
        }
      },

      getNodeBySubId: function (locator) {
        if (locator === null) {
          return this.element ? this.element[0] : null;
        }

        function _escapeId(id) {
          var targetId = [];
          var regex = /\w|_|-/;

          for (var i = 0; i < id.length; i++) {
            var c = id.substring(i, i + 1);
            if (regex.test(c)) {
              targetId.push(c);
            } else {
              targetId.push('\\' + c);
            }
          }
          return targetId.join('');
        }

        var subId = locator.subId;

        //
        // Use slot structure to return body and footer subids.
        //
        if (this._IsCustomElement() && (subId === OJD_FOOTER || subId === OJD_BODY)) {
          if (subId === OJD_BODY) {
            return this._uiDialogBodyDiv.querySelector(OJD_BODY_CLASS);
          } else if (subId === OJD_FOOTER) {
            return this._uiDialogFooterDiv.querySelector(OJD_FOOTER_CLASS);
          }
        } else {
          // General case
          var selector;
          var node;

          switch (subId) {
            case OJD_HEADER:
            case OJD_CONTENT:
            case OJD_FOOTER:
              selector =
                this.element[0].nodeName +
                '[id="' +
                _escapeId(this.element.attr('id')) +
                '"] > ' +
                OJD_CONTAINER_CLASS +
                ' > ';
              selector += '.' + subId;
              node = this.element.parent().find(selector);
              if (!node || node.length === 0) {
                return null;
              }

              return node[0];

            case OJ_RESIZABLE_N:
            case OJ_RESIZABLE_E:
            case OJ_RESIZABLE_S:
            case OJ_RESIZABLE_W:
            case OJ_RESIZABLE_SE:
            case OJ_RESIZABLE_SW:
            case OJ_RESIZABLE_NE:
            case OJ_RESIZABLE_NW:
              selector =
                this.element[0].nodeName + '[id="' + _escapeId(this.element.attr('id')) + '"] > ';
              selector += '.' + subId;
              node = this.element.parent().find(selector);
              if (!node || node.length === 0) {
                return null;
              }

              return node[0];

            // "oj-dialog-close-icon" is deprecated as of 1.2
            // use "oj-dialog-close" instead.
            // "oj-dialog-close" is deprecated as of 2.1.*
            case 'oj-dialog-close-icon':
            case 'oj-dialog-close':
              return null;

            // "oj-dialog-body" is deprecated as of 1.2
            case OJD_BODY:
              selector =
                this.element[0].nodeName + '[id="' + _escapeId(this.element.attr('id')) + '"] > ';
              selector += OJD_CONTAINER_CLASS + ' > ' + OJD_CONTENT_CLASS + ' > ';
              selector += '.' + subId;
              node = this.element.parent().find(selector);
              if (!node || node.length === 0) {
                return null;
              }

              return node[0];

            case OJD_HEADER_CLOSE_WRAPPER:
              selector =
                this.element[0].nodeName + '[id="' + _escapeId(this.element.attr('id')) + '"] > ';
              selector += OJD_CONTAINER_CLASS + ' > ' + OJD_HEADER_CLASS + ' > ';
              selector += '.' + subId;
              node = this.element.parent().find(selector);
              if (!node || node.length === 0) {
                return null;
              }

              return node[0];

            default:
              break;
          }
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      getSubIdByNode: function (node) {
        if (node != null) {
          var nodeCached = $(node);

          if (nodeCached.hasClass(OJD_HEADER)) {
            return { subId: OJD_HEADER };
          }
          if (nodeCached.hasClass(OJD_FOOTER)) {
            return { subId: OJD_FOOTER };
          }
          if (nodeCached.hasClass(OJD_CONTENT)) {
            return { subId: OJD_CONTENT };
          }
          if (nodeCached.hasClass(OJD_HEADER_CLOSE_WRAPPER)) {
            return { subId: OJD_HEADER_CLOSE_WRAPPER };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_N)) {
            return { subId: OJ_RESIZABLE_N };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_E)) {
            return { subId: OJ_RESIZABLE_E };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_S)) {
            return { subId: OJ_RESIZABLE_S };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_W)) {
            return { subId: OJ_RESIZABLE_W };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_SE)) {
            return { subId: OJ_RESIZABLE_SE };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_SW)) {
            return { subId: OJ_RESIZABLE_SW };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_NE)) {
            return { subId: OJ_RESIZABLE_NE };
          }
          if (nodeCached.hasClass(OJ_RESIZABLE_NW)) {
            return { subId: OJ_RESIZABLE_NW };
          }
        }

        return null;
      },
      /**
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @return {void}
       */
      _surrogateRemoveHandler: function () {
        // In all cases except when the dialog is already open, removal of the
        // surrogate during opening or closing will result in implicit removal.
        // 1) CLOSING: Handled in oj.ZOrderUtils.removeFromAncestorLayer.  If the
        //    surrogate doesn't exist the layer containing the popup dom is detached.
        // 2) OPENING: in the PopupServiceImpl#open _finalize, if the surrogate doesn't
        //    exist after in the open state, this remove callback is invoked.
        //
        // Custom element will call _NotifyDetached after element.remove but
        // but jquery UI instances will invoke the _destory method.

        var element = this.element;
        var status = oj.ZOrderUtils.getStatus(element);
        if (status === oj.ZOrderUtils.STATUS.OPEN) {
          ojcustomelementUtils.CustomElementUtils.cleanComponentBindings(element[0]);
          element.remove();
        }
      },
      /**
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @return {!Object.<oj.PopupService.EVENT, function(...)>}
       */
      _getPopupServiceEvents: function () {
        if (!this._popupServiceEvents) {
          /** @type {!Object.<oj.PopupService.EVENT, function(...)>} **/
          var events = {};

          events[oj.PopupService.EVENT.POPUP_CLOSE] = this._closeImplicitly.bind(this);
          events[oj.PopupService.EVENT.POPUP_REMOVE] = this._surrogateRemoveHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_REFRESH] = this._adjustPosition.bind(this);
          events[oj.PopupService.EVENT.POPUP_BEFORE_OPEN] = this._beforeOpenHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_AFTER_OPEN] = this._afterOpenHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_BEFORE_CLOSE] = this._beforeCloseHandler.bind(this);
          events[oj.PopupService.EVENT.POPUP_AFTER_CLOSE] = this._afterCloseHandler.bind(this);

          this._popupServiceEvents = events;
        }
        return this._popupServiceEvents;
      },
      /**
       * @memberof oj.ojDialog
       * @instance
       * @private
       */
      _closeImplicitly: function () {
        this._ignoreBeforeCloseResultant = true;
        this.close();
        delete this._ignoreBeforeCloseResultant;
      },

      /**
       * Creates a Promise exposed by the {@link oj.ojDialog#whenReady} method.
       *
       * @param {string} operation valid values are "open", "close" or "none"
       * @memberof oj.ojDialog
       * @instance
       * @private
       */
      _setWhenReady: function (operation) {
        /** @type {PopupWhenReadyMediator} */
        var mediator = this._whenReadyMediator;
        if (mediator) {
          mediator.destroy();
          delete this._whenReadyMediator;
        }

        // operation === none
        if (['open', 'close'].indexOf(operation) < 0) {
          return;
        }

        this._whenReadyMediator = new ojpopupcore.PopupWhenReadyMediator(
          this.element,
          operation,
          'ojDialog',
          this._IsCustomElement()
        );
      },

      /**
       * Checks to see if there is a pending "open" or "close" operation.  If pending and it
       * is the same as the requested operation, the request silently fails.  If the current
       * operation is the inverse operation, we queue the current operation after the pending
       * operation is resolved.
       *
       * @memberof oj.ojDialog
       * @instance
       * @private
       * @param {string} operation currently requested
       * @param {Array} args passed to a queue operation
       * @returns {boolean} <code>true</code> if a "close" or "open" operation is pending completion.
       */
      _isOperationPending: function (operation, args) {
        /** @type {oj.PopupWhenReadyMediator} **/
        var mediator = this._whenReadyMediator;
        if (mediator) {
          return mediator.isOperationPending(this, operation, operation, args);
        }
        return false;
      },
      /**
       * Notifies the component that its subtree has been removed from the document
       * programmatically after the component has been created.
       *
       * @memberof oj.ojDialog
       * @instance
       * @protected
       * @override
       */
      _NotifyDetached: function () {
        // detaching an open popup results in implicit dismissal
        if (oj.ZOrderUtils.getStatus(this.element) === oj.ZOrderUtils.STATUS.OPEN) {
          this._closeImplicitly();
        }

        this._super();
      }
    });

    Components.setDefaultOptions({
      ojDialog: {
        resizeBehavior: Components.createDynamicPropertyGetter(function () {
          return (ThemeUtils.parseJSONFromFontFamily(OJD_OPTION_DEFAULTS) || {}).resizeBehavior;
        }),
        cancelBehavior: Components.createDynamicPropertyGetter(function () {
          return (ThemeUtils.parseJSONFromFontFamily(OJD_OPTION_DEFAULTS) || {}).cancelBehavior;
        }),
        dragAffordance: Components.createDynamicPropertyGetter(function () {
          return (ThemeUtils.parseJSONFromFontFamily(OJD_OPTION_DEFAULTS) || {}).dragAffordance;
        })
      }
    });
  })();

  (function () {
var __oj_dialog_metadata = 
{
  "properties": {
    "cancelBehavior": {
      "type": "string",
      "enumValues": [
        "escape",
        "icon",
        "none"
      ]
    },
    "dialogTitle": {
      "type": "string"
    },
    "dragAffordance": {
      "type": "string",
      "enumValues": [
        "none",
        "title-bar"
      ]
    },
    "initialVisibility": {
      "type": "string",
      "enumValues": [
        "hide",
        "show"
      ],
      "value": "hide"
    },
    "modality": {
      "type": "string",
      "enumValues": [
        "modal",
        "modeless"
      ],
      "value": "modal"
    },
    "position": {
      "type": "object",
      "properties": {
        "at": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ],
              "value": "center"
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ],
              "value": "center"
            }
          }
        },
        "collision": {
          "type": "string",
          "enumValues": [
            "fit",
            "flip",
            "flipfit",
            "none"
          ],
          "value": "fit"
        },
        "my": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ],
              "value": "center"
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ],
              "value": "center"
            }
          }
        },
        "of": {
          "type": "string|object",
          "value": "window"
        },
        "offset": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "value": 0
            },
            "y": {
              "type": "number",
              "value": 0
            }
          }
        }
      }
    },
    "resizeBehavior": {
      "type": "string",
      "enumValues": [
        "none",
        "resizable"
      ]
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "labelCloseIcon": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "close": {},
    "getProperty": {},
    "isOpen": {},
    "open": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeClose": {},
    "ojBeforeOpen": {},
    "ojClose": {},
    "ojFocus": {},
    "ojOpen": {},
    "ojResize": {},
    "ojResizeStart": {},
    "ojResizeStop": {}
  },
  "extension": {}
};
    __oj_dialog_metadata.extension._WIDGET_NAME = 'ojDialog';
    __oj_dialog_metadata.extension._CONTROLS_SUBTREE_HIDDEN = true;
    oj.CustomElementBridge.register('oj-dialog', { metadata: __oj_dialog_metadata });
  })();

});


define('ojs/ojoffcanvas',['exports', 'ojs/ojcore-base', 'jquery', 'hammerjs', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojdomutils', 'ojs/ojfocusutils', 'ojs/ojjquery-hammer', 'ojs/ojpopupcore'], function (exports, oj, $, Hammer, Context, ThemeUtils, Components, Logger, DomUtils, FocusUtils, ojjqueryHammer, ojpopupcore) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;

  /**
   * @namespace
   * @since 1.1.0
   * @ojdeprecated {since: '12.0.0', value:['oj-drawer-layout']}
   * @ojtsmodule
   * @hideconstructor
   * @ojimportmembers Offcanvas
   * @export
   *
   *
   * @classdesc
   * This class provides functions used for controlling offcanvas regions.  Offcanvas regions can be used in either static (simply displaying and hiding in response to user interactions) or responsive (using media queries to dynamically move application content between the main viewport and offcanvas regions) contexts.  The OffcanvasUtils methods can be used to directly control the display of an offcanvas region in both the static and responsive cases.
   *
   * <p>Note for performance reasons, if the Offcanvas content is expensive to render, you should wrap it in an <code class="prettyprint">oj-defer</code> element (API doc {@link oj.ojDefer}) to defer the rendering of that content.<br/>
   * See the Offcanvas - Deferred Rendering demo for an example.</p>
   *
   * <h3 id="events-section">
   *   Events
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#events-section"></a>
   * </h3>
   *
   *
   * <table class="generic-table events-table">
   *   <thead>
   *     <tr>
   *       <th>Event</th>
   *       <th>Description</th>
   *       <th>Example</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>ojbeforeclose</td>
   *       <td>Triggered immediately before the offcanvas is closed. It can be canceled to prevent the content from closing by returning a false in the event listener.</td>
   *       <td>$(".selector").on("ojbeforeclose", function(event, offcanvas) {});</td>
   *     </tr>
   *     <tr>
   *       <td>ojbeforeopen<br>
   *       <td>Triggered immediately before the offcanvas is open. It can be canceled to prevent the content from opening by returning a false in the event listener.</td>
   *       <td>$(".selector").on("ojbeforeopen", function(event, offcanvas) {});</td>
   *     </tr>
   *     <tr>
   *       <td>ojclose<br>
   *       <td>Triggered after the offcanvas has been closed.</td>
   *       <td>$(".selector").on("ojclose", function(event, offcanvas) {});</td>
   *     </tr>
   *     <tr>
   *       <td>ojopen<br>
   *       <td>Triggered after the offcanvas has been open (after animation completes).</td>
   *       <td>$(".selector").on("ojopen", function(event, offcanvas) {});</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   */

  // mapping variable definition, used in a no-require environment. Maps the OffcanvasUtils object to the name used in the require callback.
  // eslint-disable-next-line no-unused-vars
  const OffcanvasUtils = {};
  oj._registerLegacyNamespaceProp('OffcanvasUtils', OffcanvasUtils);

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._DATA_EDGE_KEY = 'oj-offcanvasEdge';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._DATA_OFFCANVAS_KEY = 'oj-offcanvas';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._DATA_MEDIA_QUERY_KEY = 'oj-mediaQueryListener';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._DATA_HAMMER_KEY = 'oj-offcanvasHammer';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.SELECTOR_KEY = 'selector';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.CONTENT_KEY = 'content';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.EDGE_START = 'start';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.EDGE_END = 'end';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.EDGE_TOP = 'top';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.EDGE_BOTTOM = 'bottom';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.DISPLAY_MODE_KEY = 'displayMode';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.DISPLAY_MODE_PUSH = 'push';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.DISPLAY_MODE_OVERLAY = 'overlay';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.DISPLAY_MODE_REFLOW = 'reflow';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.MODALITY_KEY = 'modality';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.MODALITY_NONE = 'none';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.MODALITY_MODAL = 'modal';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.DISMISS_HANDLER_KEY = '_dismissHandler';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.OPEN_PROMISE_KEY = '_openPromise';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.CLOSE_PROMISE_KEY = '_closePromise';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.GLASS_PANE_KEY = '_glassPane';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.SURROGATE_KEY = '_surrogate';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.ANIMATE_WRAPPER_KEY = '_animateWrapper';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.ANIMATE_KEY = '_animate';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.SURROGATE_ATTR = 'data-oj-offcanvas-surrogate-id';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.OUTER_WRAPPER_SELECTOR = 'oj-offcanvas-outer-wrapper';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.OPEN_SELECTOR = 'oj-offcanvas-open';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.TRANSITION_SELECTOR = 'oj-offcanvas-transition';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.REFLOW_WRAPPER_SELECTOR = 'oj-offcanvas-pin';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.REFLOW_TRANSITION_SELECTOR = 'oj-offcanvas-pin-transition';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.GLASSPANE_SELECTOR = 'oj-offcanvas-glasspane';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.GLASSPANE_DIM_SELECTOR = 'oj-offcanvas-glasspane-dim';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.VETO_BEFOREOPEN_MSG = 'ojbeforeopen veto';
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils.VETO_BEFORECLOSE_MSG = 'ojbeforeclose veto';

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._shiftSelector = {
    start: 'oj-offcanvas-shift-start',
    end: 'oj-offcanvas-shift-end',
    top: 'oj-offcanvas-shift-down',
    bottom: 'oj-offcanvas-shift-up'
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._drawerSelector = {
    start: 'oj-offcanvas-start',
    end: 'oj-offcanvas-end',
    top: 'oj-offcanvas-top',
    bottom: 'oj-offcanvas-bottom'
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getDisplayMode = function (offcanvas) {
    var displayMode = offcanvas[OffcanvasUtils.DISPLAY_MODE_KEY];
    if (
      displayMode !== OffcanvasUtils.DISPLAY_MODE_OVERLAY &&
      displayMode !== OffcanvasUtils.DISPLAY_MODE_PUSH &&
      displayMode !== OffcanvasUtils.DISPLAY_MODE_REFLOW
    ) {
      // default displayMode in iOS is push and in android and windows are overlay
      displayMode = ThemeUtils.getCachedCSSVarValues([
        '--oj-private-off-canvas-global-display-mode-default'
      ])[0];
    }

    return displayMode;
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getDrawer = function (offcanvas) {
    return $(offcanvas[OffcanvasUtils.SELECTOR_KEY]);
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._isModal = function (offcanvas) {
    return offcanvas[OffcanvasUtils.MODALITY_KEY] === OffcanvasUtils.MODALITY_MODAL;
  };

  /**
   * Returns whether the drawer is currently open.
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._isOpen = function (drawer) {
    return drawer.hasClass(OffcanvasUtils.OPEN_SELECTOR);
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getOuterWrapper = function (drawer) {
    return drawer.closest('.' + OffcanvasUtils.OUTER_WRAPPER_SELECTOR);
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getAnimateWrapper = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    if (
      OffcanvasUtils._noInnerWrapper(offcanvas) ||
      offcanvas[OffcanvasUtils.DISPLAY_MODE_KEY] === OffcanvasUtils.DISPLAY_MODE_OVERLAY
    ) {
      return drawer;
    }

    if (offcanvas[OffcanvasUtils.ANIMATE_WRAPPER_KEY]) {
      return drawer.closest('.' + offcanvas[OffcanvasUtils.ANIMATE_WRAPPER_KEY]);
    }

    return drawer.parent();
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getShiftSelector = function (edge) {
    var selector = OffcanvasUtils._shiftSelector[edge];
    if (!selector) {
      throw new Error('Invalid edge: ' + edge);
    }

    return selector;
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._isRTL = function () {
    return DomUtils.getReadingDirection() === 'rtl';
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._setTransform = function (wrapper, transform) {
    wrapper.css({
      '-webkit-transform': transform,
      transform: transform
    });
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getTranslationX = function (edge, width, negate) {
    var minus = edge === OffcanvasUtils.EDGE_END;
    if (OffcanvasUtils._isRTL() || negate) {
      minus = !minus;
    }

    return 'translate3d(' + (minus ? '-' : '') + width + ', 0, 0)';
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._setTranslationX = function (wrapper, edge, width) {
    OffcanvasUtils._setTransform(wrapper, OffcanvasUtils._getTranslationX(edge, width, false));
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getTranslationY = function (edge, height) {
    var minus = edge === OffcanvasUtils.EDGE_BOTTOM ? '-' : '';
    return 'translate3d(0, ' + minus + height + ', 0)';
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._setTranslationY = function (wrapper, edge, height) {
    OffcanvasUtils._setTransform(wrapper, OffcanvasUtils._getTranslationY(edge, height));
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getTranslationY2 = function (height, negate) {
    var minus = negate ? '-' : '';
    return 'translate3d(0, ' + minus + height + ', 0)';
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._setAnimateClass = function (offcanvas, drawer, $main, dtranslation, mtranslation) {
    drawer.addClass(OffcanvasUtils.TRANSITION_SELECTOR);
    OffcanvasUtils._setTransform(drawer, dtranslation);
    $main.addClass(OffcanvasUtils.TRANSITION_SELECTOR);
    OffcanvasUtils._setTransform($main, mtranslation);
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._saveEdge = function (offcanvas) {
    var edge = offcanvas.edge;
    var drawer = OffcanvasUtils._getDrawer(offcanvas);

    if (!edge || !edge.length) {
      if (drawer.hasClass('oj-offcanvas-start')) {
        edge = OffcanvasUtils.EDGE_START;
      } else if (drawer.hasClass('oj-offcanvas-end')) {
        edge = OffcanvasUtils.EDGE_END;
      } else if (drawer.hasClass('oj-offcanvas-top')) {
        edge = OffcanvasUtils.EDGE_TOP;
      } else if (drawer.hasClass('oj-offcanvas-bottom')) {
        edge = OffcanvasUtils.EDGE_BOTTOM;
      } else {
        // default to start edge
        edge = OffcanvasUtils.EDGE_START;
      }
    }
    $.data(drawer[0], OffcanvasUtils._DATA_EDGE_KEY, edge);

    return edge;
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._getEdge = function (drawer) {
    return $.data(drawer[0], OffcanvasUtils._DATA_EDGE_KEY);
  };

  /**
   * This method is called right before open and after close animation
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._toggleClass = function (offcanvas, wrapper, isOpen) {
    var displayMode = offcanvas[OffcanvasUtils.DISPLAY_MODE_KEY];
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var drawerClass = OffcanvasUtils.OPEN_SELECTOR;
    var wrapperClass =
      displayMode === OffcanvasUtils.DISPLAY_MODE_OVERLAY
        ? OffcanvasUtils.TRANSITION_SELECTOR + ' oj-offcanvas-overlay'
        : OffcanvasUtils.TRANSITION_SELECTOR;

    // toggle offcanvas and inner wrapper classes
    if (isOpen) {
      drawer.addClass(drawerClass);
      if (offcanvas[OffcanvasUtils.ANIMATE_KEY] === undefined) {
        wrapper.addClass(wrapperClass);
      }
    } else {
      // remove oj-focus-highlight
      if (offcanvas.makeFocusable) {
        DomUtils.makeFocusable({
          element: drawer,
          remove: true
        });
      }

      // restore the original tabindex
      var oTabIndex = offcanvas.tabindex;
      if (oTabIndex === undefined) {
        drawer.removeAttr('tabindex');
      } else {
        drawer.attr('tabindex', oTabIndex);
      }

      drawer.removeClass(drawerClass);
      wrapper.removeClass(wrapperClass);
    }
  };

  /**
   * Focus is automatically moved to the first item that matches the following:
   * The first element within the offcanvas with the autofocus attribute
   * The first :tabbable element inside the offcanvas
   * The offcanvas itself
   *
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._setFocus = function (_offcanvas) {
    var offcanvas = _offcanvas;
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var focusables = drawer.find('[autofocus]');
    var focusNode;

    if (focusables.length === 0) {
      focusables = drawer.find(':tabbable');
    }
    if (focusables.length === 0) {
      var oTabIndex = drawer.attr('tabindex');
      if (oTabIndex !== undefined) {
        // save the original tabindex
        offcanvas.tabindex = oTabIndex;
      }
      // set tabIndex so the div is focusable
      drawer.attr('tabindex', '-1');
      focusNode = drawer;

      DomUtils.makeFocusable({
        element: drawer,
        applyHighlight: true
      });

      offcanvas.makeFocusable = true;
    } else {
      focusNode = focusables[0];
    }

    FocusUtils.focusElement(focusNode);
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._isAutoDismiss = function (offcanvas) {
    return offcanvas.autoDismiss !== 'none';
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._calcTransitionTime = function ($elem) {
    var propertyArray = $elem.css('transitionProperty').split(',');
    var delayArray = $elem.css('transitionDelay').split(',');
    var durationArray = $elem.css('transitionDuration').split(',');
    var maxTime = 0;

    for (var i = 0; i < propertyArray.length; i++) {
      var duration = durationArray[i % durationArray.length];
      var durationMs =
        duration.indexOf('ms') > -1 ? parseFloat(duration) : parseFloat(duration) * 1000;
      if (durationMs > 0) {
        var delay = delayArray[i % delayArray.length];
        var delayMs = delay.indexOf('ms') > -1 ? parseFloat(delay) : parseFloat(delay) * 1000;

        maxTime = Math.max(maxTime, delayMs + durationMs);
      }
    }

    return maxTime + 100;
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._onTransitionEnd = function (target, handler) {
    var endEvents = 'transitionend.oc webkitTransitionEnd.oc';
    var transitionTimer;
    var listener = function () {
      if (transitionTimer) {
        clearTimeout(transitionTimer);
        transitionTimer = null;
      }
      // remove handler
      target.off(endEvents, listener);

      handler(target);
    };

    // add transition end listener
    target.on(endEvents, listener);

    transitionTimer = setTimeout(listener, OffcanvasUtils._calcTransitionTime(target));
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._closeWithCatch = function (offcanvas) {
    //  - offcanvas: error occurs when you veto the ojbeforeclose event
    OffcanvasUtils.close(offcanvas).catch(function (reason) {
      Logger.warn('Offcancas close failed: ' + reason);
    });
  };

  // check offcanvas.autoDismiss
  // update offcanvas.dismisHandler
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._registerCloseHandler = function (_offcanvas) {
    var offcanvas = _offcanvas;
    // unregister the old handler if exists
    OffcanvasUtils._unregisterCloseHandler(offcanvas);

    if (OffcanvasUtils._isAutoDismiss(offcanvas)) {
      var drawer = OffcanvasUtils._getDrawer(offcanvas);

      // save dismisHandler
      var dismisHandler = function (event) {
        var target = event.target;

        // Ignore mouse events on the scrollbar. FF and Chrome, raises focus events on the
        // scroll container too.
        if (
          DomUtils.isChromeEvent(event) ||
          (event.type === 'focus' && !$(target).is(':focusable'))
        ) {
          return;
        }

        var key = $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);
        if (key == null) {
          // offcanvas already destroyed, unregister the handler
          OffcanvasUtils._unregisterCloseHandler(offcanvas);
          return;
        }

        // if there is an open modal dialog, do not autoDismiss
        if (oj.ZOrderUtils.hasModalDialogOpen()) {
          return;
        }

        // if event target is not the offcanvas dom subtrees, dismiss it
        if (!DomUtils.isLogicalAncestorOrSelf(drawer[0], target)) {
          OffcanvasUtils._closeWithCatch(offcanvas);
        }
      };
      offcanvas[OffcanvasUtils.DISMISS_HANDLER_KEY] = dismisHandler;

      var documentElement = document.documentElement;
      if (DomUtils.isTouchSupported()) {
        documentElement.addEventListener('touchstart', dismisHandler, {
          passive: true,
          capture: true
        });
      }

      documentElement.addEventListener('mousedown', dismisHandler, true);
      documentElement.addEventListener('focus', dismisHandler, true);
    }

    // register swipe handler
    OffcanvasUtils._registerSwipeHandler(offcanvas);
  };

  // check offcanvas.autoDismiss
  // update offcanvas.dismisHandler
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._unregisterCloseHandler = function (_offcanvas) {
    var offcanvas = _offcanvas;
    var dismisHandler = offcanvas[OffcanvasUtils.DISMISS_HANDLER_KEY];
    if (dismisHandler) {
      var documentElement = document.documentElement;

      if (DomUtils.isTouchSupported()) {
        documentElement.removeEventListener('touchstart', dismisHandler, {
          passive: true,
          capture: true
        });
      }

      documentElement.removeEventListener('mousedown', dismisHandler, true);
      documentElement.removeEventListener('focus', dismisHandler, true);
      delete offcanvas[OffcanvasUtils.DISMISS_HANDLER_KEY];

      offcanvas[OffcanvasUtils.DISMISS_HANDLER_KEY] = null;
    }

    // unregister swipe handler
    OffcanvasUtils._unregisterSwipeHandler(offcanvas);
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._registerSwipeHandler = function (_offcanvas) {
    if (DomUtils.isTouchSupported()) {
      var offcanvas = _offcanvas;
      var selector = offcanvas[OffcanvasUtils.SELECTOR_KEY];
      var drawer = $(selector);
      var edge = OffcanvasUtils._getEdge(drawer);
      var swipeEvent;
      var options;
      var drawerHammer;

      if (
        (edge === OffcanvasUtils.EDGE_START && !OffcanvasUtils._isRTL()) ||
        (edge === OffcanvasUtils.EDGE_END && OffcanvasUtils._isRTL())
      ) {
        options = {
          recognizers: [[Hammer.Swipe, { direction: Hammer.DIRECTION_LEFT }]]
        };

        swipeEvent = 'swipeleft';
      } else if (
        (edge === OffcanvasUtils.EDGE_START && OffcanvasUtils._isRTL()) ||
        (edge === OffcanvasUtils.EDGE_END && !OffcanvasUtils._isRTL())
      ) {
        options = {
          recognizers: [[Hammer.Swipe, { direction: Hammer.DIRECTION_RIGHT }]]
        };

        swipeEvent = 'swiperight';
      } else if (edge === OffcanvasUtils.EDGE_TOP) {
        options = {
          recognizers: [[Hammer.Swipe, { direction: Hammer.DIRECTION_UP }]]
        };

        swipeEvent = 'swipeup';
      } else if (edge === OffcanvasUtils.EDGE_BOTTOM) {
        options = {
          recognizers: [[Hammer.Swipe, { direction: Hammer.DIRECTION_DOWN }]]
        };

        swipeEvent = 'swipedown';
      }

      drawerHammer = drawer.ojHammer(options).on(swipeEvent, function (event) {
        if (event.target === drawer[0]) {
          event.preventDefault();
          OffcanvasUtils._closeWithCatch(offcanvas);
        }
      });

      // keep the hammer in the offcanvas jquery data
      $.data($(selector)[0], OffcanvasUtils._DATA_HAMMER_KEY, {
        event: swipeEvent,
        hammer: drawerHammer
      });
    }
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._unregisterSwipeHandler = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    if (drawer.length > 0) {
      var dHammer = $.data(drawer[0], OffcanvasUtils._DATA_HAMMER_KEY);
      if (dHammer) {
        dHammer.hammer.off(dHammer.event);
      }
    }
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._isFixed = function (drawer) {
    return OffcanvasUtils._getOuterWrapper(drawer).hasClass('oj-offcanvas-page');
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._isReflow = function (offcanvas) {
    return offcanvas[OffcanvasUtils.DISPLAY_MODE_KEY] === OffcanvasUtils.DISPLAY_MODE_REFLOW;
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._noInnerWrapper = function (offcanvas) {
    return (
      offcanvas[OffcanvasUtils.CONTENT_KEY] ||
      OffcanvasUtils._isFixed(OffcanvasUtils._getDrawer(offcanvas)) ||
      OffcanvasUtils._isReflow(offcanvas)
    );
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._toggleOuterWrapper = function (offcanvas, drawer, test) {
    var edge = OffcanvasUtils._getEdge(drawer);
    var shiftSelector = OffcanvasUtils._getShiftSelector(edge);
    var outerWrapper = OffcanvasUtils._getOuterWrapper(drawer);

    oj.Assert.assertPrototype(outerWrapper, $);

    var isOpen = outerWrapper.hasClass(shiftSelector);
    if (!test) {
      outerWrapper.toggleClass(shiftSelector, !isOpen);
    }

    return isOpen;
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._afterCloseHandler = function (offcanvas) {
    var wrapper = OffcanvasUtils._getAnimateWrapper(offcanvas);
    // bail if pan to reveal is in progress
    if (wrapper.get(0).style.transform !== '') {
      return;
    }

    //  - customsyntax memory leak: offcanvas needs to implement _disconnected
    // unregister dismiss handler
    OffcanvasUtils._unregisterCloseHandler(offcanvas);

    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var isReflow = OffcanvasUtils._isReflow(offcanvas);

    // validate offcanvas
    var curOffcanvas = null;
    try {
      curOffcanvas = $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);
    } catch (e) {
      // Throw away error.
    }
    if (curOffcanvas !== offcanvas) {
      return;
    }

    // After animation, set display:none and remove transition class
    if (isReflow) {
      drawer.removeClass(
        OffcanvasUtils.OPEN_SELECTOR + ' ' + OffcanvasUtils.REFLOW_TRANSITION_SELECTOR
      );
    } else {
      OffcanvasUtils._toggleClass(offcanvas, wrapper, false);
    }

    // Remove the glassPane if offcanvas is modal
    OffcanvasUtils._removeModality(offcanvas);

    if (isReflow) {
      OffcanvasUtils._getOuterWrapper(drawer).removeClass(OffcanvasUtils.REFLOW_WRAPPER_SELECTOR);
    }

    // fire after close event
    drawer.trigger('ojclose', offcanvas);

    // remove data associate with the offcanvas
    $.removeData(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);
  };

  /**
   * Set whether the offcanvas is fixed inside the viewport
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._setVisible = function (selector, _visible, edge) {
    var drawer = $(selector);
    var visible = !!_visible;

    // close the offcanvas without animation if it's open
    if (visible && OffcanvasUtils._isOpen(drawer)) {
      // hide offcanvas without animation
      OffcanvasUtils._close(selector, false);
    }

    // toggle "oj-offcanvas-" + edge class
    drawer.toggleClass(OffcanvasUtils._drawerSelector[edge], !visible);
  };

  /**
   * Setup offcanvas for the responsive layout.
   * This method adds a listener based on the media query specified in offcanvas.query.
   * When the media query matches the listener is called and offcanvas behavior is removed.
   * When the media query does not match the listener is called and off canvas behavior is added.
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element
   * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end, top, bottom. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
   * @property {string|null} offcanvas.query the media query determine when the offcanvas is fixed inside the viewport.
   * @return {void}
   * @memberof OffcanvasUtils
   *
   * @see #.tearDownResponsive
   *
   * @example <caption>Setup the offcanvas:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer",
   *      "edge": "start",
   *      "query": oj.ResponsiveUtils.getFrameworkQuery(oj.ResponsiveUtils.FRAMEWORK_QUERY_KEY.LG_UP)
   *    };
   *
   * OffcanvasUtils.setupResponsive(offcanvas);
   *
   */
  OffcanvasUtils.setupResponsive = function (offcanvas) {
    var mqs = offcanvas.query;
    if (mqs !== null) {
      var selector = offcanvas[OffcanvasUtils.SELECTOR_KEY];
      var query = window.matchMedia(mqs);

      // save the edge
      var edge = OffcanvasUtils._saveEdge(offcanvas);
      var mqListener = function (event) {
        // when event.matches=true fix the offcanvas inside the visible viewport.
        OffcanvasUtils._setVisible(selector, event.matches, edge);
      };

      query.addListener(mqListener);
      OffcanvasUtils._setVisible(selector, query.matches, edge);

      // keep the listener in the offcanvas jquery data
      $.data($(selector)[0], OffcanvasUtils._DATA_MEDIA_QUERY_KEY, {
        mqList: query,
        mqListener: mqListener
      });
    }
  };

  /**
   * Removes the listener that was added in setupResponsive.  Page authors should call tearDownResponsive when the offcanvas is no longer needed.
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element
   * @return {void}
   * @memberof OffcanvasUtils
   *
   * @see #.setupResponsive
   *
   * @example <caption>TearDown the offcanvas:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer"
   *    };
   *
   * OffcanvasUtils.tearDownResponsive(offcanvas);
   *
   */
  OffcanvasUtils.tearDownResponsive = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var mql = $.data(drawer[0], OffcanvasUtils._DATA_MEDIA_QUERY_KEY);
    if (mql) {
      mql.mqList.removeListener(mql.mqListener);
      $.removeData(drawer[0], OffcanvasUtils._DATA_MEDIA_QUERY_KEY);
    }
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._openPush = function (offcanvas, resolve, reject, edge) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var $main = $(offcanvas[OffcanvasUtils.CONTENT_KEY]);
    oj.Assert.assertPrototype($main, $);

    // since drawer and main are animated seperately,
    // only resolve true when both transitions are ended
    var pending = true;

    var size = offcanvas.size;
    var translation;

    // transition end handler
    var endHandler = function ($elem) {
      // After animation, remove transition class
      $elem.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);

      if (pending) {
        pending = false;
      } else {
        //  - opening offcanvas automatically scrolls to the top
        //  - perf: fif jank: nav drawer and list view items
        // Moving the focus before animation works fine with the "start" and "top" drawers, but not
        // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)
        if (edge === OffcanvasUtils.EDGE_END || edge === OffcanvasUtils.EDGE_BOTTOM) {
          OffcanvasUtils._setFocus(offcanvas);
        }

        // fire after open event
        drawer.trigger('ojopen', offcanvas);

        //  - push and overlay demos don't work in ie11
        // register dismiss handler as late as possible because IE raises focus event
        // on the launcher that will close the offcanvas if autoDismiss is true
        OffcanvasUtils._registerCloseHandler(offcanvas);

        resolve(true);
      }
    };

    // set display block to get size of offcanvas
    drawer.addClass(OffcanvasUtils.OPEN_SELECTOR);

    // set translationX or Y
    window.setTimeout(function () {
      // if size is not specified, outerWidth/outerHeight is used
      if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_END) {
        if (size === undefined) {
          size = drawer.outerWidth(true) + 'px';
        }

        //  - offcanvas: drawer push animation is incorrect in rtl mode
        //      OffcanvasUtils._setTransform(drawer,
        //                                      OffcanvasUtils._getTranslationX(edge, size, true));
        translation = OffcanvasUtils._getTranslationX(edge, size, false);
      } else {
        if (size === undefined) {
          size = drawer.outerHeight(true) + 'px';
        }

        OffcanvasUtils._setTransform(
          drawer,
          OffcanvasUtils._getTranslationY2(size, edge === OffcanvasUtils.EDGE_TOP)
        );

        translation = OffcanvasUtils._getTranslationY2(size, edge !== OffcanvasUtils.EDGE_TOP);
      }

      // before animation
      window.setTimeout(function () {
        // add transition class
        OffcanvasUtils._setAnimateClass(
          offcanvas,
          drawer,
          $main,
          'translate3d(0, 0, 0)',
          translation
        );

        OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);

        // add transition end listener
        OffcanvasUtils._onTransitionEnd($main, endHandler);
        OffcanvasUtils._onTransitionEnd(drawer, endHandler);
      }, 0); // before animation
    }, 0); // set translationX or Y

    // insert a glassPane if offcanvas is modal
    OffcanvasUtils._applyModality(offcanvas, drawer);

    //  - opening offcanvas automatically scrolls to the top
    //  - perf: fif jank: nav drawer and list view items
    // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
    // the "end" and "bottom" drawers. (There may be a browser bug causing problems)
    if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_TOP) {
      OffcanvasUtils._setFocus(offcanvas);
    }
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._openOverlay = function (offcanvas, resolve, reject, edge) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);

    // Before animation, remove display:none and add transition class
    OffcanvasUtils._toggleClass(offcanvas, drawer, true);

    var size = offcanvas.size;
    if (size) {
      if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_END) {
        OffcanvasUtils._setTransform(drawer, OffcanvasUtils._getTranslationX(edge, size, true));
      } else {
        OffcanvasUtils._setTransform(drawer, OffcanvasUtils._getTranslationY(edge, size));
      }
    }

    // show the drawer
    window.setTimeout(function () {
      OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);
    }, 20); // chrome is fine with 0ms but FF needs ~10ms or it wont animate

    // insert a glassPane if offcanvas is modal
    OffcanvasUtils._applyModality(offcanvas, drawer);

    //  - opening offcanvas automatically scrolls to the top
    //  - perf: fif jank: nav drawer and list view items
    // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
    // the "end" and "bottom" drawers. (There may be a browser bug causing problems)
    if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_TOP) {
      OffcanvasUtils._setFocus(offcanvas);
    }

    // add transition end listener
    OffcanvasUtils._onTransitionEnd(drawer, function () {
      // After animation, remove transition class
      drawer.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);

      //  - opening offcanvas automatically scrolls to the top
      //  - perf: fif jank: nav drawer and list view items
      // Moving the focus before animation works fine with the "start" and "top" drawers, but not
      // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)
      if (edge === OffcanvasUtils.EDGE_END || edge === OffcanvasUtils.EDGE_BOTTOM) {
        OffcanvasUtils._setFocus(offcanvas);
      }
      // fire after open event
      drawer.trigger('ojopen', offcanvas);

      //  - push and overlay demos don't work in ie11
      // register dismiss handler as late as possible because IE raises focus event
      // on the launcher that will close the offcanvas if autoDismiss is true
      OffcanvasUtils._registerCloseHandler(offcanvas);

      resolve(true);
    });
  };

  /*
   * @memberof OffcanvasUtils
   * @private

  OffcanvasUtils._openReflow = function (offcanvas, resolve, reject, edge) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var $main = $(offcanvas[OffcanvasUtils.CONTENT_KEY]);
    oj.Assert.assertPrototype($main, $);

    var size = offcanvas.size;

    // set display block to get size of offcanvas
    drawer.addClass(OffcanvasUtils.OPEN_SELECTOR);

    // set translationX
    window.setTimeout(function () {
      // if size is not specified, outerWidth is used
      if (size === undefined) {
        size = drawer.outerWidth(true) + 'px';
      }
      drawer.addClass(OffcanvasUtils.REFLOW_TRANSITION_SELECTOR);

      // make the outer wrapper a flex layout
      OffcanvasUtils._getOuterWrapper(drawer).addClass(OffcanvasUtils.REFLOW_WRAPPER_SELECTOR);

      // clear transform only work if set style
      OffcanvasUtils._setTransform(drawer, 'none');

      // animate on min-width
      window.setTimeout(function () {
        drawer.css('min-width', size);

        OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);
      }, 10);
    }, 0);    // set translationX

    // insert a glassPane if offcanvas is modal
    OffcanvasUtils._applyModality(offcanvas, drawer);

    //  - opening offcanvas automatically scrolls to the top
    //  - perf: fif jank: nav drawer and list view items
    // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
    // the "end" and "bottom" drawers. (There may be a browser bug causing problems)
    if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_TOP) {
      OffcanvasUtils._setFocus(offcanvas);
    }

    // add transition end listener
    OffcanvasUtils._onTransitionEnd(drawer,
      function () {
        // After animation, remove transition class
        drawer.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);

        //  - opening offcanvas automatically scrolls to the top
        //  - perf: fif jank: nav drawer and list view items
        // Moving the focus before animation works fine with the "start" and "top" drawers, but not
        // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)
        if (edge === OffcanvasUtils.EDGE_END || edge === OffcanvasUtils.EDGE_BOTTOM) {
          OffcanvasUtils._setFocus(offcanvas);
        }

        // fire after open event
        drawer.trigger('ojopen', offcanvas);

        //  - push and overlay demos don't work in ie11
        // register dismiss handler as late as possible because IE raises focus event
        // on the launcher that will close the offcanvas if autoDismiss is true
        OffcanvasUtils._registerCloseHandler(offcanvas);

        resolve(true);
      });
  };
   */

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._closePush = function (offcanvas, resolve, reject, drawer, animation) {
    var $main = $(offcanvas[OffcanvasUtils.CONTENT_KEY]);
    // since drawer and main are animated seperately,
    // only resolve true when both transitions are ended
    var pending = true;

    //  - issue in ojoffcanvas when used inside ojtabs
    var endHandler = function () {
      if (!pending) {
        // clear transform translation on $main
        $main.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);
        OffcanvasUtils._setTransform($main, '');
        OffcanvasUtils._afterCloseHandler(offcanvas);
        resolve(true);
      }
      pending = false;
    };

    // clear transform
    OffcanvasUtils._setTransform(drawer, '');
    OffcanvasUtils._setTransform($main, '');
    OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);

    // dim glassPane
    if (OffcanvasUtils._isModal(offcanvas)) {
      offcanvas[OffcanvasUtils.GLASS_PANE_KEY].removeClass(OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
    }

    if (animation) {
      // Before animation, add transition class
      $main.addClass(OffcanvasUtils.TRANSITION_SELECTOR);
      drawer.addClass(OffcanvasUtils.TRANSITION_SELECTOR);

      // add transition end listener
      OffcanvasUtils._onTransitionEnd(drawer, endHandler);
      OffcanvasUtils._onTransitionEnd($main, endHandler);
    } else {
      pending = false;
      endHandler();
    }
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._closeOverlay = function (offcanvas, resolve, reject, drawer, animation) {
    var endHandler = function () {
      OffcanvasUtils._afterCloseHandler(offcanvas);
      resolve(true);
    };

    // clear transform
    OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);

    // dim glassPane
    if (OffcanvasUtils._isModal(offcanvas)) {
      offcanvas[OffcanvasUtils.GLASS_PANE_KEY].removeClass(OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
    }

    if (animation) {
      drawer.addClass(OffcanvasUtils.TRANSITION_SELECTOR);

      // add transition end listener
      OffcanvasUtils._onTransitionEnd(drawer, endHandler);
    } else {
      endHandler();
    }
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._openOldDrawer = function (offcanvas, resolve, reject, edge, displayMode) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var wrapper = OffcanvasUtils._getAnimateWrapper(offcanvas);
    oj.Assert.assertPrototype(wrapper, $);

    // Before animation, remove display:none and add transition class
    OffcanvasUtils._toggleClass(offcanvas, wrapper, true);

    var size;
    if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_END) {
      // if size is missing, outerWidth is used
      size = drawer.outerWidth(true) + 'px';

      // don't set transform for OffcanvasUtils.DISPLAY_MODE_OVERLAY
      if (displayMode === OffcanvasUtils.DISPLAY_MODE_PUSH) {
        OffcanvasUtils._setTranslationX(wrapper, edge, size);
      }
    } else {
      // if size is missing, outerHeight is used
      size = drawer.outerHeight(true) + 'px';

      // don't set transform for OffcanvasUtils.DISPLAY_MODE_OVERLAY
      if (displayMode === OffcanvasUtils.DISPLAY_MODE_PUSH) {
        OffcanvasUtils._setTranslationY(wrapper, edge, size);
      }
    }

    // show the drawer
    window.setTimeout(function () {
      OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);
    }, 10); // chrome is fine with 0ms but FF needs ~10ms or it wont animate

    // insert a glassPane if offcanvas is modal
    OffcanvasUtils._applyModality(offcanvas, drawer);

    //  - opening offcanvas automatically scrolls to the top
    //  - perf: fif jank: nav drawer and list view items
    // Moving the focus before animation works fine with the "start" and "top" drawers, but not with
    // the "end" and "bottom" drawers. (There may be a browser bug causing problems)
    if (edge === OffcanvasUtils.EDGE_START || edge === OffcanvasUtils.EDGE_TOP) {
      OffcanvasUtils._setFocus(offcanvas);
    }

    // add transition end listener
    OffcanvasUtils._onTransitionEnd(wrapper, function () {
      // After animation, remove transition class
      wrapper.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);

      //  - opening offcanvas automatically scrolls to the top
      //  - perf: fif jank: nav drawer and list view items
      // Moving the focus before animation works fine with the "start" and "top" drawers, but not
      // with the "end" and "bottom" drawers. (There may be a browser bug causing problems)
      if (edge === OffcanvasUtils.EDGE_END || edge === OffcanvasUtils.EDGE_BOTTOM) {
        OffcanvasUtils._setFocus(offcanvas);
      }

      // fire after open event
      drawer.trigger('ojopen', offcanvas);

      //  - push and overlay demos don't work in ie11
      // register dismiss handler as late as possible because IE raises focus event
      // on the launcher that will close the offcanvas if autoDismiss is true
      OffcanvasUtils._registerCloseHandler(offcanvas);

      resolve(true);
    });
  };

  /*
   * @memberof OffcanvasUtils
   * @private

  OffcanvasUtils._closeReflow = function (offcanvas, resolve, reject, drawer, animation) {
    var endHandler = function () {
      OffcanvasUtils._afterCloseHandler(offcanvas);
      resolve(true);
    };

    // clear transform
    OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);

    // dim glassPane
    if (OffcanvasUtils._isModal(offcanvas)) {
      offcanvas[OffcanvasUtils.GLASS_PANE_KEY]
        .removeClass(OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
    }

    if (animation) {
      // Before animation, add transition class
      drawer.addClass(OffcanvasUtils.TRANSITION_SELECTOR);
      OffcanvasUtils._setTransform(drawer, '');
      drawer.css('min-width', '0');

      // add transition end listener
      OffcanvasUtils._onTransitionEnd(drawer, endHandler);
    } else {
      endHandler();
    }
  };
   */

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._closeOldDrawer = function (offcanvas, resolve, reject, drawer, animation) {
    var displayMode = offcanvas[OffcanvasUtils.DISPLAY_MODE_KEY];
    var wrapper = OffcanvasUtils._getAnimateWrapper(offcanvas);

    var endHandler = function () {
      OffcanvasUtils._afterCloseHandler(offcanvas);
      resolve(true);
    };

    // clear transform
    if (displayMode === OffcanvasUtils.DISPLAY_MODE_PUSH) {
      OffcanvasUtils._setTransform(wrapper, '');
    }
    OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, false);

    // dim glassPane
    if (OffcanvasUtils._isModal(offcanvas)) {
      offcanvas[OffcanvasUtils.GLASS_PANE_KEY].removeClass(OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
    }

    if (animation) {
      // Before animation, add transition class
      wrapper.addClass(OffcanvasUtils.TRANSITION_SELECTOR);

      // add transition end listener
      OffcanvasUtils._onTransitionEnd(wrapper, endHandler);
    } else {
      endHandler();
    }
  };

  /**
   * Shows the offcanvas by sliding it into the viewport.  This method fire an ojbeforeopen event which can be vetoed by attaching a listener and returning false.  If the open is not vetoed, this method will fire an ojopen event once animation has completed.
   *
   *<p>Upon opening a offcanvas, focus is automatically moved to the first item that matches the following:</p>
   *<ol>
   *  <li>The first element within the offcanvas with the <code>autofocus</code> attribute</li>
   *  <li>The first <code>:tabbable</code> element inside the offcanvas</li>
   *  <li>The offcanvas itself</li>
   *</ol>
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element.
   * @property {string} offcanvas.content Document selector identifying the main content.
   * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end, top, bottom. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
   * @property {('push'|'overlay')=} offcanvas.displayMode how to show the offcanvas, valid values are push or overlay. Default: defined by theme.
   * @property {('focusLoss'|'none')=} offcanvas.autoDismiss close behavior, valid values are focusLoss and none. If autoDismiss is default(focusLoss) then any click outside the offcanvas will close it.
   * @property {string=} offcanvas.size size width or height of the offcanvas: width if edge is start or end and height if edge is to and bottom. Default to the computed width or height of the offcanvas.
   * @property {('modal'|'modeless')=} offcanvas.modality The modality of the offcanvas. Valid values are modal and modeless. Default: modeless. If the offcanvas is modal, interaction with the main content area is disabled like in a modal dialog.
   * @return {Promise.<boolean>} A promise that is resolved to boolean true when all transitions have completed. The promise is rejected if the ojbeforeopen event is vetoed.
   * @see #.close
   * @see #.toggle
   *
   * @memberof OffcanvasUtils
   *
   * @example <caption>Slide the offcanvas into the viewport:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer",
   *      "content": "#mainContent",
   *      "edge": "start",
   *      "displayMode": "push",
   *      "size": "200px"
   *    };
   *
   * OffcanvasUtils.open(offcanvas);
   *
   */
  OffcanvasUtils.open = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var oldOffcanvas = $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);
    if (oldOffcanvas) {
      // if we are in the middle of closing, then return the previous saved promise
      if (oldOffcanvas[OffcanvasUtils.CLOSE_PROMISE_KEY]) {
        return oldOffcanvas[OffcanvasUtils.CLOSE_PROMISE_KEY];
      }

      // if we are in the middle of opening, then return the previous saved promise
      if (oldOffcanvas[OffcanvasUtils.OPEN_PROMISE_KEY]) {
        return oldOffcanvas[OffcanvasUtils.OPEN_PROMISE_KEY];
      }
    }

    var resolveBusyState;
    var veto = false;
    var promise = new Promise(function (resolve, reject) {
      oj.Assert.assertPrototype(drawer, $);

      // save the edge
      var edge = OffcanvasUtils._saveEdge(offcanvas);

      // fire before open event
      var event = $.Event('ojbeforeopen');
      drawer.trigger(event, offcanvas);
      if (event.result === false) {
        reject(OffcanvasUtils.VETO_BEFOREOPEN_MSG);
        veto = true;
        return;
      }

      var displayMode = OffcanvasUtils._getDisplayMode(offcanvas);
      var isReflow = OffcanvasUtils._isReflow(offcanvas);

      // only support horizontal offcanvas for reflow
      if (isReflow && (edge === OffcanvasUtils.EDGE_TOP || edge === OffcanvasUtils.EDGE_BOTTOM)) {
        displayMode = OffcanvasUtils.DISPLAY_MODE_PUSH;
      }

      // save a copy of offcanvas object in offcanvas jquery data
      var myOffcanvas = $.extend({}, offcanvas);
      myOffcanvas[OffcanvasUtils.DISPLAY_MODE_KEY] = displayMode;
      $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY, myOffcanvas);

      // throw an error if CONTENT_KEY is specified and the html markup contains an inner wrapper.
      if (offcanvas[OffcanvasUtils.CONTENT_KEY]) {
        if (!OffcanvasUtils._noInnerWrapper(offcanvas)) {
          throw new Error(
            "Error: Both main content selector and the inner wrapper <div class='oj-offcanvas-inner-wrapper'> are provided. Please remove the inner wrapper."
          );
        }

        // Add a busy state for the animation.  The busy state resolver will be invoked
        // when the animation is completed
        var busyContext = Context.getContext(drawer[0]).getBusyContext();
        resolveBusyState = busyContext.addBusyState({
          description:
            "The offcanvas selector ='" +
            offcanvas[OffcanvasUtils.SELECTOR_KEY] +
            "' doing the open animation."
        });

        if (isReflow) {
          // OffcanvasUtils._openReflow(myOffcanvas, resolve, reject, edge);
        } else if (displayMode === OffcanvasUtils.DISPLAY_MODE_PUSH) {
          OffcanvasUtils._openPush(myOffcanvas, resolve, reject, edge);
        } else {
          OffcanvasUtils._openOverlay(myOffcanvas, resolve, reject, edge);
        }
      } else {
        OffcanvasUtils._openOldDrawer(myOffcanvas, resolve, reject, edge, displayMode);
      }
    });

    promise = promise.then(
      function (value) {
        if (resolveBusyState) {
          resolveBusyState();
        }
        return value;
      },
      function (error) {
        if (resolveBusyState) {
          resolveBusyState();
        }
        throw error;
      }
    );

    // save away the current promise
    if (!veto) {
      var nOffcanvas = $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);
      if (nOffcanvas) {
        nOffcanvas[OffcanvasUtils.OPEN_PROMISE_KEY] = promise;

        // notify subtree
        Components.subtreeShown(drawer[0]);
      }
    }

    return /** @type{Promise.<boolean>} */ (promise);
  };

  /**
   * Hides the offcanvas by sliding it out of the viewport.  This method fires an ojbeforeclose event which can be vetoed by attaching a listener and returning false.  If the close is not vetoed, this method will fire an ojclose event once animation has completed.
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element
   * @return {Promise.<boolean>} A promise that is resolved to boolean true when all transitions have completed. The promise is rejected if the ojbeforeclose event is vetoed.
   * @see #.open
   * @see #.toggle
   *
   * @memberof OffcanvasUtils
   *
   * @example <caption>Slide the offcanvas out of the viewport:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer"
   *    };
   *
   * OffcanvasUtils.close(offcanvas);
   *
   */
  OffcanvasUtils.close = function (offcanvas) {
    return OffcanvasUtils._close(
      offcanvas[OffcanvasUtils.SELECTOR_KEY],
      offcanvas[OffcanvasUtils.ANIMATE_KEY] === undefined
    );
  };

  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._close = function (selector, animation) {
    var drawer = $(selector);

    oj.Assert.assertPrototype(drawer, $);

    var offcanvas = $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);

    // if we are in the middle of closing, then return the previous saved promise
    if (offcanvas && offcanvas[OffcanvasUtils.CLOSE_PROMISE_KEY]) {
      return offcanvas[OffcanvasUtils.CLOSE_PROMISE_KEY];
    }

    var resolveBusyState;
    var veto = false;
    var promise = new Promise(function (resolve, reject) {
      if (OffcanvasUtils._isOpen(drawer)) {
        // if offcanvas not present, we are done
        if (offcanvas == null) {
          resolve(true);
        }

        if (selector !== offcanvas[OffcanvasUtils.SELECTOR_KEY]) {
          resolve(true);
        }

        // if the outer wrapper doesn't have the correct shift selector, we are done
        if (!OffcanvasUtils._toggleOuterWrapper(offcanvas, drawer, true)) {
          resolve(true);
        }

        // fire before close event
        var event = $.Event('ojbeforeclose');
        drawer.trigger(event, offcanvas);
        if (event.result === false) {
          reject(OffcanvasUtils.VETO_BEFORECLOSE_MSG);
          veto = true;
          return;
        }

        // Add a busy state for the animation.  The busy state resolver will be invoked
        // when the animation is completed
        if (animation) {
          var busyContext = Context.getContext(drawer[0]).getBusyContext();
          resolveBusyState = busyContext.addBusyState({
            description:
              "The offcanvas selector ='" +
              offcanvas[OffcanvasUtils.SELECTOR_KEY] +
              "' doing the close animation."
          });
        }

        var displayMode = offcanvas[OffcanvasUtils.DISPLAY_MODE_KEY];
        if (offcanvas[OffcanvasUtils.CONTENT_KEY]) {
          if (displayMode === OffcanvasUtils.DISPLAY_MODE_PUSH) {
            OffcanvasUtils._closePush(offcanvas, resolve, reject, drawer, animation);
          } else {
            OffcanvasUtils._closeOverlay(offcanvas, resolve, reject, drawer, animation);
          }
        } else {
          OffcanvasUtils._closeOldDrawer(offcanvas, resolve, reject, drawer, animation);
        }
      } else {
        resolve(true);
      }
    });

    promise = promise.then(
      function (value) {
        if (resolveBusyState) {
          resolveBusyState();
        }
        return value;
      },
      function (error) {
        if (resolveBusyState) {
          resolveBusyState();
        }
        throw error;
      }
    );

    // save away the current promise
    if (!veto) {
      offcanvas = $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY);
      if (offcanvas) {
        offcanvas[OffcanvasUtils.CLOSE_PROMISE_KEY] = promise;

        // notify subtree
        Components.subtreeHidden(drawer[0]);
      }
    }

    return /** @type{Promise.<boolean>} */ (promise);
  };

  /**
   * Toggles the offcanvas in or out of the viewport.  This method simply delegates to the open or close methods as appropriate.
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element.
   * @property {string} offcanvas.content Document selector identifying the main content.
   * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end, top, bottom. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
   * @property {('push'|'overlay')=} offcanvas.displayMode how to show the offcanvas, valid values are push or overlay. Default: defined by theme.
   * @property {('focusLoss'|'none')=} offcanvas.autoDismiss close behavior, valid values are focusLoss and none. If autoDismiss is default(focusLoss) then any click outside the offcanvas will close it.
   * @property {string=} offcanvas.size size width or height of the offcanvas: width if edge is start or end and height if edge is to and bottom. Default to the computed width or height of the offcanvas.
   * @property {('modal'|'modeless')=} offcanvas.modality The modality of the offcanvas. Valid values are modal and modeless. Default: modeless. If the offcanvas is modal, interaction with the main content area is disabled like in a modal dialog.
   * @return {Promise.<boolean>} A promise that is resolved to boolean true when all transitions have completed
   * @see #.open
   * @see #.close
   *
   * @memberof OffcanvasUtils
   *
   * @example <caption>Toggle the offcanvas in or out of the viewport:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer",
   *      "edge": "start",
   *      "displayMode": "overlay"
   *    };
   *
   * OffcanvasUtils.toggle(offcanvas);
   *
   */
  OffcanvasUtils.toggle = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    oj.Assert.assertPrototype(drawer, $);

    if (OffcanvasUtils._isOpen(drawer)) {
      return OffcanvasUtils.close(offcanvas);
    }

    return OffcanvasUtils.open(offcanvas);
  };

  /**
   * Creates an overlay div with the oj-offcanvas-glasspane selector
   * append to the end of the drawer's container
   * @param {!jQuery} drawer the drawer
   * @return {jQuery} the overlay div
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._addGlassPane = function (drawer) {
    var overlay = $('<div>');
    overlay.addClass(OffcanvasUtils.GLASSPANE_SELECTOR);
    overlay.attr('role', 'presentation');
    overlay.attr('aria-hidden', 'true');

    // append glassPane at the end
    overlay.appendTo(drawer.parent()); // @HTMLUpdateOK
    overlay.on(
      'keydown keyup keypress mousedown mouseup mouseover mouseout click focusin focus',
      function (event) {
        event.stopPropagation();
        event.preventDefault();
      }
    );

    return overlay;
  };

  /**
   * Creates a script element before the target layer bound to the simple jquery UI
   * surrogate component.
   *
   * @param {!jQuery} layer stacking context
   * @return {jQuery}
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._createSurrogate = function (layer) {
    //  - offcanvas utils use of <script>
    var surrogate = $('<span></span>').css('display', 'none').attr('aria-hidden', 'true');

    var layerId = layer.attr('id');

    var surrogateId;
    if (layerId) {
      surrogateId = [layerId, 'surrogate'].join('_');
      surrogate.attr('id', surrogateId);
    } else {
      surrogateId = surrogate.uniqueId();
    }
    surrogate.insertBefore(layer); // @HTMLUpdateOK

    // loosely associate the offcanvas to the surrogate element
    layer.attr(OffcanvasUtils.SURROGATE_ATTR, surrogateId); // @HTMLUpdateOK

    return surrogate;
  };

  /**
   * bring the drawer to the front to keep this order:  mainContent, glassPane, drawer
   * so we don't need to use z-index
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._swapOrder = function (_offcanvas, drawer) {
    var offcanvas = _offcanvas;
    // create a surrogate in front of the mainContent to be used in _restoreOrder
    offcanvas[OffcanvasUtils.SURROGATE_KEY] = OffcanvasUtils._createSurrogate(drawer);

    drawer.appendTo(drawer.parent()); // @HTMLUpdateOK
  };

  /**
   * restore the order before _swapOrder
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._restoreOrder = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var surrogate = offcanvas[OffcanvasUtils.SURROGATE_KEY];

    if (drawer && surrogate && drawer.attr(OffcanvasUtils.SURROGATE_ATTR) === surrogate.attr('id')) {
      drawer.insertAfter(surrogate); // @HTMLUpdateOK
      // remove link to the surrogate element
      drawer.removeAttr(OffcanvasUtils.SURROGATE_ATTR);
      surrogate.remove();
    }
  };

  /**
   * Apply modality
   * If offcanvas is modal, add a glasspane and keep the dom structure in the following order:
   * mainContent, glassPane and drawer so we don't need to apply z-index
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._applyModality = function (_offcanvas, drawer) {
    var offcanvas = _offcanvas;
    if (OffcanvasUtils._isModal(offcanvas)) {
      // insert glassPane in front of the mainContent
      offcanvas[OffcanvasUtils.GLASS_PANE_KEY] = OffcanvasUtils._addGlassPane(drawer);

      // bring the drawer <div> to the front
      // to keep this order:  mainContent, glassPane, drawer
      OffcanvasUtils._swapOrder(offcanvas, drawer);

      //  - acc: talkback reports on elements on background page whilst navdrawer open
      var $main = $(offcanvas[OffcanvasUtils.CONTENT_KEY]);
      $main.attr('aria-hidden', 'true');

      window.setTimeout(function () {
        offcanvas[OffcanvasUtils.GLASS_PANE_KEY].addClass(OffcanvasUtils.GLASSPANE_DIM_SELECTOR);
      }, 0);
    }
  };

  /**
   * Remove modality
   * If offcanvas is modal, remove glasspane and restore the dom element orders
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._removeModality = function (offcanvas) {
    if (OffcanvasUtils._isModal(offcanvas)) {
      offcanvas[OffcanvasUtils.GLASS_PANE_KEY].remove();
      // restore the order
      OffcanvasUtils._restoreOrder(offcanvas);

      //  - acc: talkback reports on elements on background page whilst navdrawer open
      var $main = $(offcanvas[OffcanvasUtils.CONTENT_KEY]);
      $main.removeAttr('aria-hidden');
    }
  };

  /**
   * Setup offcanvas for pan to reveal.
   * This method adds a touch listener to handle revealing the offcanvas as user pans on the outer wrapper.  The following events are fired by this method:
   * ojpanstart - fired when pan to reveal gesture initiated by the user.  The event includes the direction and distance of the pan.  If it is vetoed
   *              then pan to reveal is terminated
   * ojpanmove  - fired as user continues the pan gesture.  The event includes the direction and distance of the pan.
   * ojpanend   - fired when pan to reveal gesture ends.  The event includes the direction and distance of the pan.  If it is vetoed then the offcanvas
   *              will be closed.
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element
   * @property {('start'|'end'|'top'|'bottom')=} offcanvas.edge the edge of the offcanvas, valid values are start, end. This property is optional if the offcanvas element has a "oj-offcanvas-" + <edge> class specified.
   * @property {string=} offcanvas.size size width of the offcanvas.  Default to the computed width of the offcanvas.
   * @return {void}
   *
   * @memberof OffcanvasUtils
   * @ojtsignore
   *
   * @see #.tearDownPanToReveal
   *
   * @example <caption>Setup the offcanvas:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer"
   *    };
   *
   * OffcanvasUtils.setupPanToReveal(offcanvas);
   *
   */
  OffcanvasUtils.setupPanToReveal = function (_offcanvas) {
    var offcanvas = _offcanvas;
    var drawer;
    var size;
    var outerWrapper;
    var wrapper;
    var mOptions;
    var proceed;
    var direction;
    var ui;
    var evt;
    var delta;
    var edge;
    var endEvents;
    var listener;
    var isRTL;

    if ($(offcanvas).attr('oj-data-pansetup') != null) {
      // already setup
      return;
    }

    // mark as setup
    $(offcanvas).attr('oj-data-pansetup', 'true');

    // pan to reveal only works for push display mode, so enforce it
    offcanvas.displayMode = 'push';

    drawer = OffcanvasUtils._getDrawer(offcanvas);

    outerWrapper = OffcanvasUtils._getOuterWrapper(drawer);

    // use hammer for swipe
    mOptions = {
      // ensure pinch zoom work properly
      touchAction: 'pinch-zoom',
      recognizers: [[Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }]]
    };

    // workaround for Hammer with iOS 13 issue, see: https://github.com/hammerjs/hammer.js/issues/1237
    var agent = oj.AgentUtils.getAgentInfo();
    if (agent.os === oj.AgentUtils.OS.IOS || agent.os === oj.AgentUtils.OS.ANDROID) {
      // force Hammer to only accept TouchEvent and not PointerEvent
      mOptions.inputClass = Hammer.TouchInput;
    }

    // flag to signal whether pan to reveal should proceed
    proceed = false;

    edge = offcanvas.edge;
    if (edge == null) {
      if (drawer.hasClass('oj-offcanvas-start')) {
        edge = 'start';
      } else {
        edge = 'end';
      }
    }

    isRTL = OffcanvasUtils._isRTL();

    $(outerWrapper)
      .ojHammer(mOptions)
      .on('panstart', function (event) {
        direction = null;

        switch (event.gesture.direction) {
          case Hammer.DIRECTION_LEFT:
            // diagonal case
            if (Math.abs(event.gesture.deltaY) < Math.abs(event.gesture.deltaX)) {
              direction = isRTL ? 'end' : 'start';
            }
            break;
          case Hammer.DIRECTION_RIGHT:
            // diagonal case
            if (Math.abs(event.gesture.deltaY) < Math.abs(event.gesture.deltaX)) {
              direction = isRTL ? 'start' : 'end';
            }
            break;
          default:
        }

        if (direction === null) {
          return;
        }

        // check for pan up/down at a certain angle which gives abnormal values
        if (event.gesture.angle < 0 && (event.gesture.deltaX < -100 || event.gesture.deltaY < -100)) {
          return;
        }

        ui = { direction: direction, distance: Math.abs(event.gesture.deltaX) };
        evt = $.Event('ojpanstart');
        drawer.trigger(evt, ui);

        if (!evt.isDefaultPrevented()) {
          var busyContext = Context.getContext(outerWrapper.get(0)).getBusyContext();
          busyContext.whenReady().then(function () {
            // need the size to display the canvas when release
            if (drawer.length > 0 && !isNaN(parseInt(drawer[0].style.width, 10))) {
              drawer[0].style.width = 'auto';
            }
            size = drawer.outerWidth();
            offcanvas.size = size;

            // proceed only when there's content
            if (size > 0) {
              proceed = true;
            } else {
              OffcanvasUtils._toggleClass(offcanvas, wrapper, false);
            }
          });

          // make sure it's in closed state
          offcanvas._closePromise = null;

          // cancel any close animation transition handler
          wrapper = OffcanvasUtils._getAnimateWrapper(offcanvas);
          wrapper.off('.oc');

          // sets the appropriate offcanvas class
          OffcanvasUtils._toggleClass(offcanvas, wrapper, true);

          // stop touch event from bubbling to prevent for example pull to refresh from happening
          event.gesture.srcEvent.stopPropagation();
          // prevent page from scrolling
          event.gesture.srcEvent.preventDefault();

          // stop bubbling
          event.stopPropagation();
        }
      })
      .on('panmove', function (event) {
        // don't do anything if start is vetoed
        if (!proceed) {
          return;
        }

        delta = event.gesture.deltaX;
        if (
          (direction === 'start' && delta > 0 && !isRTL) ||
          (direction === 'start' && delta < 0 && isRTL) ||
          (direction === 'end' && delta < 0 && !isRTL) ||
          (direction === 'end' && delta > 0 && isRTL)
        ) {
          OffcanvasUtils._setTranslationX(wrapper, edge, '0px');
          return;
        }

        delta = Math.abs(delta);
        drawer.css('width', delta);

        // don't do css transition animation while panning
        wrapper.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);
        OffcanvasUtils._setTranslationX(wrapper, edge, delta + 'px');

        ui = { direction: direction, distance: delta };
        evt = $.Event('ojpanmove');
        drawer.trigger(evt, ui);

        // stop touch event from bubbling to prevent for example pull to refresh from happening
        event.gesture.srcEvent.stopPropagation();

        // stop bubbling
        event.stopPropagation();
      })
      .on('panend', function (event) {
        // don't do anything if start is vetoed
        if (!proceed) {
          return;
        }

        // reset flag
        proceed = false;

        delta = Math.abs(event.gesture.deltaX);
        ui = { distance: delta };
        evt = $.Event('ojpanend');
        drawer.trigger(evt, ui);

        // stop bubbling
        event.stopPropagation();

        if (!evt.isDefaultPrevented()) {
          OffcanvasUtils._animateWrapperAndDrawer(wrapper, drawer, edge, size, offcanvas);

          $.data(drawer[0], OffcanvasUtils._DATA_OFFCANVAS_KEY, offcanvas);
          $.data(drawer[0], OffcanvasUtils._DATA_EDGE_KEY, edge);

          OffcanvasUtils._registerCloseHandler(offcanvas);

          return;
        }

        // nothing to animate, still need to close the offcanvas and do clean up
        if (wrapper[0].style.transform === 'translate3d(0px, 0px, 0px)') {
          OffcanvasUtils._toggleClass(offcanvas, wrapper, false);
          wrapper.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);
          drawer.trigger('ojclose', offcanvas);
          return;
        }

        // close the toolbar
        endEvents = 'transitionend webkitTransitionEnd otransitionend oTransitionEnd';
        listener = function () {
          // reset offcanvas class
          OffcanvasUtils._toggleClass(offcanvas, wrapper, false);

          wrapper.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);

          // remove handler
          wrapper.off(endEvents, listener);

          // fire close event after completely closed
          drawer.trigger('ojclose', offcanvas);
        };

        // add transition end listener
        wrapper.on(endEvents, listener);

        // restore item position
        wrapper.addClass(OffcanvasUtils.TRANSITION_SELECTOR);
        OffcanvasUtils._setTranslationX(wrapper, 'start', '0px');
      });
  };

  // animate both the wrapper and drawer at the same time
  /**
   * @memberof OffcanvasUtils
   * @private
   */
  OffcanvasUtils._animateWrapperAndDrawer = function (wrapper, drawer, edge, size, offcanvas) {
    var tt = 400;
    var fps = 60;
    var ifps;
    var matrix;
    var values;
    var current;
    var first;
    var final;
    var reqId;
    var inc;
    var lastFrame;
    var func;
    var currentFrame;
    var adjInc;

    // since we can't synchronize two css transitions, we'll have to do the animation ourselves using
    // requestAnimationFrame
    // make sure wrapper animation is off
    wrapper.removeClass(OffcanvasUtils.TRANSITION_SELECTOR);

    // ideal ms per frame
    ifps = Math.round(1000 / fps);
    matrix = wrapper.css('transform');
    if (matrix === 'none') {
      // could happen if this method was called after canvas is closed
      return;
    }
    values = matrix.split('(')[1].split(')')[0].split(',');
    var agent = oj.AgentUtils.getAgentInfo();
    // this is the position of translateX value (IE11 the matrix looks different)
    var index = agent.browser === 'ie' && agent.browserVersion === 11 ? 12 : 4;
    current = parseInt(values[index], 10);

    first = current;
    // the final size/destination
    final = edge === 'end' ? 0 - size : size;
    if (OffcanvasUtils._isRTL()) {
      final = 0 - final;
    }

    // calculate the increment needed to complete transition in 400ms with 60fps
    inc = Math.max(1, Math.abs(final - current) / (tt / ifps));
    lastFrame = new Date().getTime();
    func = function () {
      // check if it got interrupted by close
      if (first !== current && wrapper.get(0).style.transform === '') {
        window.cancelAnimationFrame(reqId);
        return;
      }

      currentFrame = new Date().getTime();
      // see how much we'll need to compensate if fps drops below ideal
      adjInc = Math.max(inc, inc * Math.max((currentFrame - lastFrame) / ifps));
      lastFrame = currentFrame;
      if (current < final) {
        current = Math.min(final, current + adjInc);
      } else if (current > final) {
        current = Math.max(final, current - adjInc);
      }

      OffcanvasUtils._setTranslationX(wrapper, edge, Math.abs(current) + 'px');
      drawer.css('width', Math.abs(current) + 'px');

      // make sure to cancel the animation frame if we are done
      if (current === final) {
        window.cancelAnimationFrame(reqId);
        wrapper.addClass(OffcanvasUtils.TRANSITION_SELECTOR);

        // fire after completely open
        drawer.trigger('ojopen', offcanvas);
      } else {
        reqId = window.requestAnimationFrame(func);
      }
    };

    reqId = window.requestAnimationFrame(func);
  };

  /**
   * Removes the listener that was added in setupPanToReveal.  Page authors should call tearDownPanToReveal when the offcanvas is no longer needed.
   *
   * @export
   * @param {Object} offcanvas An Object contains the properties in the following table.
   * @property {string} offcanvas.selector Document selector identifying the offcanvas element
   * @return {void}
   * @see #.setupPanToReveal
   *
   * @memberof OffcanvasUtils
   * @ojtsignore
   *
   * @example <caption>TearDown the offcanvas:</caption>
   *    var offcanvas = {
   *      "selector": "#startDrawer"
   *    };
   *
   * OffcanvasUtils.tearDownPanToReveal(offcanvas);
   *
   */
  OffcanvasUtils.tearDownPanToReveal = function (offcanvas) {
    var drawer = OffcanvasUtils._getDrawer(offcanvas);
    var outerWrapper = OffcanvasUtils._getOuterWrapper(drawer);

    // remove all listeners
    $(outerWrapper).off('panstart panmove panend');
  };

  const close = OffcanvasUtils.close;
  const open = OffcanvasUtils.open;
  const setupResponsive = OffcanvasUtils.setupResponsive;
  const setupPanToReveal = OffcanvasUtils.setupPanToReveal;
  const tearDownResponsive = OffcanvasUtils.tearDownResponsive;
  const tearDownPanToReveal = OffcanvasUtils.tearDownPanToReveal;
  const toggle = OffcanvasUtils.toggle;
  const _getOuterWrapper = OffcanvasUtils._getOuterWrapper;

  exports._getOuterWrapper = _getOuterWrapper;
  exports.close = close;
  exports.open = open;
  exports.setupPanToReveal = setupPanToReveal;
  exports.setupResponsive = setupResponsive;
  exports.tearDownPanToReveal = tearDownPanToReveal;
  exports.tearDownResponsive = tearDownResponsive;
  exports.toggle = toggle;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdatacollection-common',['exports', 'ojs/ojcore-base', 'ojs/ojdomutils', 'ojs/ojlogger', 'ojs/ojkeyboardfocus-utils'], function (exports, oj, DomUtils, Logger, ojkeyboardfocusUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * This class contains utility methods used by the data collection components (DataGrid, Listview, and Table).
   * @private
   */
  const DataCollectionUtils = function () {};

  /**
   * @private
   */
  DataCollectionUtils._DATA_OJ_TABMOD = 'data-oj-tabmod';

  /**
   * @private
   */
  DataCollectionUtils._FOCUSABLE_ELEMENTS_TAG = [
    'input',
    'select',
    'button',
    'a',
    'textarea',
    'object'
  ];

  /**
   * Warning message to log when duplicate keys are detected.
   */
  DataCollectionUtils.WARN_DUPLICATE_KEYS_DETAIL =
    'Duplicate keys detected. Though this can occur due to race conditions, it is likely an indication that the underlying data set contains non-unique keys.';

  /**
   * Number of times checkViewport occured during initial fetch before log a warning
   */
  DataCollectionUtils.CHECKVIEWPORT_THRESHOLD = 3;

  /** ********************** custom renderer callback methods *********************/

  /**
   * Applies the renderer content provided to the element specified
   * @param {Element} element
   * @param {string | Element} content
   * @param {boolean=} wrapText
   * @param {function=} subtreeCallback
   * @returns true if content was appended, false otherwise
   */
  DataCollectionUtils.applyRendererContent = function (element, content, wrapText, subtreeCallback) {
    // if an element is returned from the renderer and the parent of that element is null, we will append
    // the returned element to the parentElement.  If non-null, we won't do anything, assuming that the
    // rendered content has already added into the DOM somewhere.
    if (content != null) {
      // allow return of document fragment from jquery create/js document.createDocumentFragment
      if (content.parentNode === null || content.parentNode instanceof DocumentFragment) {
        element.appendChild(content); // @HTMLUpdateOK
        if (subtreeCallback) {
          subtreeCallback(content);
        }
        return true;
      }
      if (content.parentNode != null) {
        // parent node exists, do nothing
        return false;
      }
      if (content.toString) {
        if (wrapText) {
          var textWrapper = document.createElement('span');
          textWrapper.appendChild(document.createTextNode(content.toString())); // @HTMLUpdateOK
          element.appendChild(textWrapper); // @HTMLUpdateOK
        } else {
          element.appendChild(document.createTextNode(content.toString())); // @HTMLUpdateOK
        }
        return true;
      }
    }
    return false;
  };

  /** ******************* focusable/editable element related methods *****************/

  /**
   * Finds all the focusable elements in a node
   * @param {Element} node
   * @param {boolean=} skipVisibilityCheck
   * @return {Element[]} An array of all of the focusable elements in a node
   * @private
   */
  DataCollectionUtils.getFocusableElementsInNode = function (node, skipVisibilityCheck) {
    return ojkeyboardfocusUtils.getFocusableElementsInNode(node, skipVisibilityCheck);
  };

  /**
   * Check if the specified element is visible
   * @param {Element} element
   * @private
   */
  DataCollectionUtils.checkVisibility = function (element) {
    return ojkeyboardfocusUtils.checkVisibility(element);
  };

  /**
   * Make the specified element unfocusable
   * @param {Element} element
   * @private
   */
  DataCollectionUtils.disableElement = function (element) {
    ojkeyboardfocusUtils.disableElement(element);
  };

  /**
   * Make all focusable elements within the specified element unfocusable
   * @param {Element} element
   * @param {boolean=} excludeActiveElement
   * @param {boolean=} includeReadonly
   * @return {Element[]} An array of the disabled elements
   * @private
   */
  DataCollectionUtils.disableAllFocusableElements = function (
    element,
    excludeActiveElement,
    includeReadonly
  ) {
    return ojkeyboardfocusUtils.disableAllFocusableElements(element, excludeActiveElement, includeReadonly);
  };

  /**
   * Enable all focusable elements within the specified element that were previously disabled
   * @param {Element} element
   * @return {Element[]} An array of the enabled elements
   * @private
   */
  DataCollectionUtils.enableAllFocusableElements = function (element) {
    return ojkeyboardfocusUtils.enableAllFocusableElements(element);
  };

  /**
   * Helper method to check if click target is selector
   * @param {Event} event
   * @return {boolean} boolean if the click event target is selector
   * @private
   */
  DataCollectionUtils.isFromDefaultSelector = function (event) {
    return event.target.classList.contains('oj-selectorbox');
  };

  /**
   * Finds all the actionable elements in a node including ones with tabmod on them (disabled by us)
   * @param {Element} element
   * @return {Element[]} An array of the enabled elements
   * @private
   */
  DataCollectionUtils.getActionableElementsInNode = function (element) {
    return ojkeyboardfocusUtils.getActionableElementsInNode(element);
  };

  /**
   * Checks if the element is focusable or is contained inside a focusable element
   * @param {Element|undefined|null} element
   * @param {function=} stopCondition
   */
  DataCollectionUtils.isElementOrAncestorFocusable = function (element, stopCondition) {
    if (element == null || (stopCondition && stopCondition(element))) {
      return false;
    } else if (element.hasAttribute(DataCollectionUtils._DATA_OJ_TABMOD)) {
      return true;
    } else if (element.tabIndex >= 0) {
      return true;
    } else if (
      DataCollectionUtils._FOCUSABLE_ELEMENTS_TAG.indexOf(element.tagName.toLowerCase()) > -1
    ) {
      return true;
    }

    return DataCollectionUtils.isElementOrAncestorFocusable(element.parentElement, stopCondition);
  };

  /**
   * Handle a tab that is pressed when in actionable mode
   * @param {Event} event the event causing the actionable tab
   * @param {Element|undefined|null} element to unset actionable
   * @returns {boolean} true if we have shifted focus within the actionable cell
   * @private
   */
  DataCollectionUtils.handleActionableTab = function (event, element) {
    var focusElems = DataCollectionUtils.getFocusableElementsInNode(element);
    if (focusElems.length === 1) {
      return true;
    }
    if (focusElems.length > 0 && event.target === focusElems[focusElems.length - 1]) {
      // recycle to first focusable element in the cell
      focusElems[0].focus();
      return true;
    }
    // let the tab go to the next item in the cell on its own
    return false;
  };

  /**
   * Handle a tab that is pressed when in actionable mode
   * @param {Event} event the event causing the actionable tab
   * @param {Element|undefined|null} element to unset actionable
   * @returns {boolean} true if we have shifted focus within the actionable cell
   * @private
   */
  DataCollectionUtils.handleActionablePrevTab = function (event, element) {
    var focusElems = DataCollectionUtils.getFocusableElementsInNode(element);
    if (focusElems.length === 1) {
      return true;
    }
    if (focusElems.length > 0 && event.target === focusElems[0]) {
      // recycle to last focusable element in the cell
      focusElems[focusElems.length - 1].focus();
      return true;
    }
    // let the tab go to the previous item in the cell on its own
    return false;
  };

  /**
   * Determines whether or not clickthrough is disabled for the given event
   * @param {Event} event the event to check
   * @param {Element} rootElement the root element
   * @returns {boolean} true if clickthrough is disabled for the given event. false otherwise
   * @private
   */
  DataCollectionUtils.isEventClickthroughDisabled = function (event, rootElement) {
    var node = event.target;
    while (node != null && node !== rootElement) {
      if (DataCollectionUtils.isClickthroughDisabled(node)) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };

  /**
   * Determines whether or not clickthrough is disabled for the given element
   * @param {Element} element the element to check
   * @returns {boolean} true if clickthrough is disabled for the given element. false otherwise
   */
  DataCollectionUtils.isClickthroughDisabled = function (element) {
    return element.dataset.ojClickthrough === 'disabled';
  };

  /** ******************* general collection utility methods *****************/

  /**
   * Get the default scroll bar width of the given element
   * @param {Element} element the element to get the default scroll bar width of
   * @private
   */
  DataCollectionUtils.getDefaultScrollBarWidth = function (element) {
    var scrollBarWidth;
    if (element && element.style) {
      // save current styling to ensure it is restored once completed
      var visibility = element.style.visibility;
      var position = element.style.position;
      var overflowY = element.style.overflowY;
      var height = element.style.height;
      var width = element.style.width;

      /* eslint-disable no-param-reassign */
      element.style.visibility = 'hidden';
      element.style.position = 'absolute';
      element.style.overflowY = 'hidden';
      element.style.height = '50px';
      element.style.width = '50px';

      // since offsetWidth includes padding and borders that clientWidth does not,
      // first save the initial difference when overflow is hidden to use below
      var initialDiff = element.offsetWidth - element.clientWidth;

      // set overflow to 'scroll', and then find the difference in offsetWidth and clientWidth
      // compared to the initial difference found above
      element.style.overflowY = 'scroll';
      scrollBarWidth = element.offsetWidth - element.clientWidth - initialDiff;

      element.style.width = width;
      element.style.height = height;
      element.style.overflowY = overflowY;
      element.style.position = position;
      element.style.visibility = visibility;
      /* eslint-enable no-param-reassign */
    }
    return scrollBarWidth;
  };

  /**
   * Disables unwanted default browser styling on the element specified
   * @param {Element} element the element to disable unwanted browser styling on
   * @private
   */
  DataCollectionUtils.disableDefaultBrowserStyling = function (element) {
    // attribute to disable auto links for phone numbers on ie/edge which break accessibility
    element.setAttribute('x-ms-format-detection', 'none');
  };

  /**
   * Merges additional styling with an element's existing styling.
   * @param {Element} element the element to apply the merged styling to
   * @param {string} initStyle the current style string of the element
   * @param {string} addedStyle the additional style string to apply to the element
   */
  DataCollectionUtils.applyMergedInlineStyles = function (element, initStyle, addedStyle) {
    var addedStyleObj = DataCollectionUtils.convertStringToStyleObj(addedStyle);
    var initStyleObj = DataCollectionUtils.convertStringToStyleObj(initStyle);
    var mergedStyle = Object.assign({}, addedStyleObj, initStyleObj);
    DataCollectionUtils.applyStyleObj(element, mergedStyle);
  };

  /**
   * Converts an HTML inline style string to a style object whose keys represent style properties
   * and whose values represent the style values.
   * @param {string} the HTML inline style string to be converted
   * @private
   */
  DataCollectionUtils.convertStringToStyleObj = function (styleString) {
    var retObj = {};
    if (styleString.split) {
      var splitArr = styleString.split(';');
      for (var i = 0; i < splitArr.length; i++) {
        var property = splitArr[i];
        if (property !== '') {
          var propArr = property.split(':');
          if (propArr.length === 2) {
            retObj[propArr[0].trim()] = propArr[1].trim();
          }
        }
      }
    }
    return retObj;
  };

  /**
   * Applies an object whose keys represent style properties and whose values represent the style
   * values to a given element.
   * @param {element} the element to apply the style object to
   * @param {Object} the style object to be converted
   * @private
   */
  DataCollectionUtils.applyStyleObj = function (element, styleObj) {
    var stylePropArr = Object.keys(styleObj);
    var styleValArr = Object.values(styleObj);
    for (var i = 0; i < stylePropArr.length; i++) {
      /* eslint-disable no-param-reassign */
      element.style[stylePropArr[i]] = styleValArr[i];
    }
  };

  /**
   * Determines if the current environment is a mobile touch device
   * @returns {boolean} true if the current environment is a mobile touch device
   * @private
   */
  DataCollectionUtils.isMobileTouchDevice = function () {
    var agentInfo = oj.AgentUtils.getAgentInfo();

    return (
      agentInfo.os === oj.AgentUtils.OS.IOS ||
      agentInfo.os === oj.AgentUtils.OS.ANDROID ||
      agentInfo.os === oj.AgentUtils.OS.WINDOWSPHONE
    );
  };

  DataCollectionUtils.getNoJQFocusHandlers = function (focusIn, focusOut) {
    return DomUtils.getNoJQFocusHandlers(focusIn, focusOut);
  };

  /** ******************* selected KeySet related methods *****************/

  /**
   * Checks whether the given KeySet instances represent equivalent sets
   * @param {KeySet} keySet1 the first KeySet
   * @param {KeySet} keySet2 the second KeySet
   * @returns {boolean} true if the given KeySet instances represent equivalent sets
   * @private
   */
  DataCollectionUtils.areKeySetsEqual = function (keySet1, keySet2) {
    if (keySet1 === keySet2) {
      return true;
    }
    var isAddAll = keySet1.isAddAll();
    if (isAddAll !== keySet2.isAddAll()) {
      return false;
    }
    var valueSet1;
    var valueSet2;
    if (isAddAll) {
      valueSet1 = keySet1.deletedValues();
      valueSet2 = keySet2.deletedValues();
    } else {
      valueSet1 = keySet1.values();
      valueSet2 = keySet2.values();
    }
    if (valueSet1.size !== valueSet2.size) {
      return false;
    }
    var valueIterator1 = valueSet1.values();
    var valueIterator2 = valueSet2.values();
    var result1 = valueIterator1.next();
    var result2 = valueIterator2.next();
    while (!result1.done) {
      if (!oj.KeyUtils.equals(result1.value, result2.value)) {
        return false;
      }
      result1 = valueIterator1.next();
      result2 = valueIterator2.next();
    }
    return true;
  };

  /** **************** keyboard event handling methods ****************** */

  DataCollectionUtils.KEYBOARD_KEYS = {
    _SPACEBAR: ' ',
    _SPACEBAR_IE: 'SpaceBar',
    _SPACEBAR_CODE: 32,
    _ENTER: 'Enter',
    _ENTER_CODE: 13,
    _UP: 'ArrowUp',
    _UP_IE: 'Up',
    _UP_CODE: 38,
    _DOWN: 'ArrowDown',
    _DOWN_IE: 'Down',
    _DOWN_CODE: 40,
    _LEFT: 'ArrowLeft',
    _LEFT_IE: 'Left',
    _LEFT_CODE: 37,
    _RIGHT: 'ArrowRight',
    _RIGHT_IE: 'Right',
    _RIGHT_CODE: 39,
    _HOME: 'Home',
    _HOME_CODE: 36,
    _END: 'End',
    _END_CODE: 35,
    _TAB: 'Tab',
    _TAB_CODE: 9,
    _ESCAPE: 'Escape',
    _ESCAPE_IE: 'Esc',
    _ESCAPE_CODE: 27,
    _F2: 'F2',
    _F2_CODE: 113,
    _NUM5_KEY: '5',
    _NUM5_KEY_CODE: 53,
    _LETTER_A: 'a',
    _LETTER_A_UPPERCASE: 'A',
    _LETTER_A_CODE: 65,
    _META: 'Meta',
    _META_CODE: 91
  };

  /**
   * @private
   */
  DataCollectionUtils.isEnterKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._ENTER ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._ENTER_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isSpaceBarKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._SPACEBAR ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._SPACEBAR_IE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._SPACEBAR_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isEscapeKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._ESCAPE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._ESCAPE_IE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._ESCAPE_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isTabKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._TAB ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._TAB_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isF2KeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._F2 ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._F2_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isHomeKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._HOME ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._HOME_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isEndKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._END ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._END_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isArrowUpKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._UP ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._UP_IE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._UP_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isArrowDownKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._DOWN ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._DOWN_IE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._DOWN_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isArrowLeftKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._LEFT ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._LEFT_IE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._LEFT_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isArrowRightKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._RIGHT ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._RIGHT_IE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._RIGHT_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isNumberFiveKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._NUM5_KEY ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._NUM5_KEY_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isLetterAKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._LETTER_A ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._LETTER_A_UPPERCASE ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._LETTER_A_CODE
    );
  };

  /**
   * @private
   */
  DataCollectionUtils.isMetaKeyEvent = function (eventKey) {
    return (
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._META ||
      eventKey === DataCollectionUtils.KEYBOARD_KEYS._META_CODE
    );
  };

  /** **************** data mutation event handling methods ****************** */

  /**
   * Returns the resulting array of keys from the handling of an add event.
   * @param {Array} initialKeys
   * @param {Object} addEventDetail
   * @param {boolean} isLoadAll
   */
  DataCollectionUtils.getAddEventKeysResult = function (initialKeys, addEventDetail, isLoadAll) {
    var i;
    var beforeKey;
    var eventKey;
    var eventIndex;
    var beforeIndex;

    // returns an object that stores the required insertion information for a given key
    function _createAddItem(itemKey, itemIndex) {
      return { key: itemKey, index: itemIndex };
    }

    var returnKeys = initialKeys.slice();
    var eventKeys = [];
    addEventDetail.keys.forEach(function (key) {
      eventKeys.push(key);
    });

    var eventBeforeKeys = [];
    // afterKeys is deprecated, but continue to support it until we can remove it.
    // forEach can be called on both array and set.
    var beforeKeyIter = addEventDetail.addBeforeKeys
      ? addEventDetail.addBeforeKeys
      : addEventDetail.afterKeys;
    if (beforeKeyIter != null) {
      beforeKeyIter.forEach(function (key) {
        eventBeforeKeys.push(key);
      });
    }

    var foundDuplicate = false;
    var eventIndexes = addEventDetail.indexes;

    // if beforeKeys are specified, they take precedence over index values.
    if (eventBeforeKeys.length === eventKeys.length) {
      // loop through the beforeKeys, and perform insertions as we find them.
      // some beforeKeys may be in our list of keys to add, so we need to continuously loop through our adds until no insertions are made.
      // at that point, any left over rows are out of our rendered viewport, and we can safely ignore them in not isLoadAll.
      var leftOverLength = 0;
      var requiresAdditionalLooping = true;
      while (requiresAdditionalLooping) {
        while (eventKeys.length !== leftOverLength) {
          leftOverLength = eventKeys.length;
          // loop through in reverse order as most DP impls have an increasing global index order in their events.
          for (i = eventKeys.length - 1; i >= 0; i--) {
            eventKey = eventKeys[i];
            // ensure the key does not already exist in the data set.
            if (!DataCollectionUtils.containsKey(returnKeys, eventKey)) {
              beforeKey = eventBeforeKeys[i];
              if (beforeKey != null) {
                beforeIndex = DataCollectionUtils._indexOfKey(returnKeys, beforeKey);
                if (beforeIndex !== -1) {
                  returnKeys.splice(beforeIndex, 0, eventKey);
                  eventBeforeKeys.splice(i, 1);
                  eventKeys.splice(i, 1);
                }
              } else if (isLoadAll) {
                // null beforeKey is at the end of the data set, only add if isLoadAll
                returnKeys.push(eventKey);
                eventBeforeKeys.splice(i, 1);
                eventKeys.splice(i, 1);
              }
            } else {
              // if duplicate key detected, just remove that key from the set to be added
              eventBeforeKeys.splice(i, 1);
              eventKeys.splice(i, 1);
              foundDuplicate = true;
            }
          }
        }
        // if before keys were not continuous, just do our best to add the remaining ones at the end when isLoadAll
        if (isLoadAll && eventKeys.length !== 0) {
          Logger.error('Invalid "beforeKey" value detected in "add" event.');
          returnKeys.push(eventKeys[0]);
          eventBeforeKeys.splice(0, 1);
          eventKeys.splice(0, 1);
          requiresAdditionalLooping = eventKeys.length !== 0;
        } else {
          requiresAdditionalLooping = false;
        }
      }
    } else if (eventIndexes != null && eventIndexes.length === eventKeys.length) {
      // if beforeKeys are not specified, we need to rely on the index values.
      // in order to be safely added, we need to ensure they are ordered in ascending order
      var indexItems = [];
      for (i = 0; i < eventKeys.length; i++) {
        eventKey = eventKeys[i];
        // ensure the key does not already exist in the data set
        if (!DataCollectionUtils.containsKey(returnKeys, eventKey)) {
          eventIndex = eventIndexes[i];
          if (eventIndex != null) {
            var added = false;
            for (var j = 0; j < indexItems.length; j++) {
              // this is the absolute event index once all updates are made - store it (sorted low to high) and add after
              if (indexItems[j].index > eventIndex) {
                indexItems.splice(j, 0, _createAddItem(eventKey, eventIndex));
                added = true;
                break;
              }
            }
            if (!added) {
              indexItems.push(_createAddItem(eventKey, eventIndex));
            }
          } else if (isLoadAll) {
            // null index is at the end of the data set, only add if isLoadAll
            returnKeys.push(eventKey);
          }
        } else {
          foundDuplicate = true;
        }
      }
      // add the sorted items by index to ensure final index values are correct
      for (i = 0; i < indexItems.length; i++) {
        var indexItem = indexItems[i];
        if (indexItem.index < returnKeys.length) {
          returnKeys.splice(indexItem.index, 0, indexItem.key);
        } else if (isLoadAll) {
          if (indexItem.index !== returnKeys.length) {
            // log error if index values are not correct
            Logger.error('Invalid "index" value detected in "add" event.');
          }
          // add remaining rows to the end when isLoadAll
          returnKeys.push(indexItem.key);
        }
      }
    } else if (isLoadAll) {
      // if neither beforeKeys nor indexes are specified, just add all keys to the end in the current order
      eventKeys.forEach(function (key) {
        returnKeys.push(key);
      });
    }
    if (foundDuplicate) {
      Logger.warn(DataCollectionUtils.WARN_DUPLICATE_KEYS_DETAIL);
    }

    // return updated keys since any remaining beforeKey rows and index rows are not connected to the viewport
    return returnKeys;
  };

  /**
   * @private
   */
  DataCollectionUtils.containsKey = function (array, key) {
    for (var i = 0; i < array.length; i++) {
      if (oj.KeyUtils.equals(array[i], key)) {
        return true;
      }
    }
    return false;
  };

  /**
   * @private
   */
  DataCollectionUtils._indexOfKey = function (array, key) {
    for (var i = 0; i < array.length; i++) {
      if (oj.KeyUtils.equals(array[i], key)) {
        return i;
      }
    }
    return -1;
  };

  /**
   * Helper method to calculate the offsetTop from element to ancestor
   * @param {Element} ancestor the ancestor element
   * @param {Element} element the element
   * @return {number} the distance between the specified element and ancestor
   */
  DataCollectionUtils.calculateOffsetTop = function (ancestor, element) {
    var offset = 0;
    var current = element;
    while (current && current !== ancestor && ancestor.contains(current)) {
      offset += current.offsetTop;
      current = current.offsetParent;
    }

    return offset;
  };

  /**
   * Components that open popups (such as ojSelect, ojCombobox, ojInputDate, etc.) will trigger
   * focusout, but components don't want to exit actionable/edit mode in those cases.
   * This method should be used inside the component's focusout handler.
   * @param elem the component element
   * @return the logical popup element if one has been launched from within the component, null otherwise.
   */
  DataCollectionUtils.getLogicalChildPopup = function (componentElement) {
    return ojkeyboardfocusUtils.getLogicalChildPopup(componentElement);
  };

  /**
   * Helper method to determine if an element is within the current viewport
   * @param {Element} elem
   * @param {Element} scroller
   */
  DataCollectionUtils.isElementIntersectingScrollerBounds = function (elem, scroller) {
    var top;
    var bottom;
    var left;
    var right;
    if (scroller === document.documentElement) {
      top = 0;
      bottom = document.documentElement.clientHeight;
      left = 0;
      right = document.documentElement.clientWidth;
    } else {
      var scrollerBounds = scroller.getBoundingClientRect();
      top = scrollerBounds.top;
      bottom = scrollerBounds.bottom;
      left = scrollerBounds.left;
      right = scrollerBounds.right;
    }
    var bounds = elem.getBoundingClientRect();
    return (
      bounds.top <= bottom && bounds.bottom >= top && bounds.left <= right && bounds.right >= left
    );
  };

  /**
   * Helper method to return the element that 'scroll' event listeners should be registered on based on the given
   * scroller element. Specifically handles cases of document.body and document.documentElement
   */
  DataCollectionUtils.getScrollEventElement = function (scrollerElement) {
    // listening on the window for 'scroll' events is the only way that works consistently across all browsers.
    if (scrollerElement === document.body || scrollerElement === document.documentElement) {
      return window;
    }

    return scrollerElement;
  };

  /**
   * Helper method to complete data and metadata if either is missing from an event.
   * @param {Object} dataProvider
   * @param {Event} eventDetail event detail from dataprovider mutation event.
   */
  DataCollectionUtils.getEventDetail = function (dataProvider, eventDetail) {
    // need to verify keys if we have a DataProvider that supports non-iteration 'fetchByKeys'
    return new Promise((resolve) => {
      if (eventDetail.data && eventDetail.metadata) {
        resolve(eventDetail);
      } else {
        const capability = dataProvider.getCapability('fetchByKeys');
        if (capability && capability.implementation === 'lookup') {
          dataProvider.fetchByKeys({ keys: new Set(eventDetail.keys), scope: 'global' }).then(
            (fetchByKeysResult) => {
              eventDetail.data = [];
              eventDetail.metadata = [];
              eventDetail.keys.forEach((key) => {
                const fetchByKeysValue = fetchByKeysResult.results.get(key);
                eventDetail.data.push(fetchByKeysValue.data);
                eventDetail.metadata.push(fetchByKeysValue.metadata);
              });
              resolve(eventDetail);
            },
            (reason) => {
              // something bad happened, return null.
              Logger.error('Error fetching event detail due to fetchByKeys: ' + reason);
              resolve(null);
            }
          );
        } else {
          // cant validate due to capability, return null
          Logger.error('Error fetching event detail due to fetchByKeys: capability');
          resolve(null);
        }
      }
    });
  };

  /**
   * Check for SDP-specific internal flag - not a public API
   */
  DataCollectionUtils.isIterateAfterDoneNotAllowed = function (dataProvider) {
    if (dataProvider && dataProvider.getCapability) {
      var capability = dataProvider.getCapability('fetchFirst');
      if (capability && capability.iterateAfterDone === 'notAllowed') {
        return true;
      }
    }
    return false;
  };

  /**
   * Whether browser supports requestIdleCallback
   */
  DataCollectionUtils.isRequestIdleCallbackSupported = function () {
    return (
      window.requestIdleCallback != null &&
      window.cancelIdleCallback != null &&
      window.IdleDeadline != null
    );
  };

  /**
   * Returns whether or not the fetch result value signals that an abort was triggered
   * @private
   */
  DataCollectionUtils.isFetchAborted = function (fetchResult) {
    if (fetchResult?.value == null) {
      return false;
    }
    var signal = fetchResult.value.fetchParameters?.signal;
    if (signal == null) {
      Logger.warn(
        'Signal is missing from fetch parameters, which is set by collection component and should be present'
      );
      return false;
    }
    return signal.aborted;
  };

  /**
   * Returns abort reason aka DOMException with info for aborted fetches.
   * @private
   */
  DataCollectionUtils.getAbortReason = function (element) {
    const componentTagName = element ? `<${element.tagName.toLowerCase()}>: ` : '';
    const message = `${componentTagName}Aborting stale fetch for performance – a newer request has been issued`;
    const newDOMException = new DOMException(message, 'AbortError');
    newDOMException.severity = 'info';
    return newDOMException;
  };

  /**
   * Helper function which returns true if the browser is Chrome
   * @private
   */
  DataCollectionUtils.isChrome = function () {
    return oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.CHROME;
  };

  /**
   * Helper function which returns true if the browser is FF
   * @private
   */
  DataCollectionUtils.isFirefox = function () {
    return oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.FIREFOX;
  };

  /**
   * Helper function which returns true if the browser is IE
   * @private
   */
  DataCollectionUtils.isIE = function () {
    return oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.IE;
  };

  /**
   * Helper function which returns true if the browser is Edge
   * @private
   */
  DataCollectionUtils.isEdge = function () {
    return oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.EDGE;
  };

  /**
   * Helper function which returns true if the browser is Safari
   * @private
   */
  DataCollectionUtils.isSafari = function () {
    return oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.SAFARI;
  };

  /**
   * Helper function which returns true if the os is Mac
   * @private
   */
  DataCollectionUtils.isMac = function () {
    return oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.MAC;
  };

  /**
   * Helper function which returns true if the os is Windows
   * @private
   */
  DataCollectionUtils.isWindows = function () {
    return oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.WINDOWS;
  };

  /**
   * Helper function which returns true if the os is IOS
   * @private
   */
  DataCollectionUtils.isIos = function () {
    return oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS;
  };

  /**
   * Helper function which returns true if the os is Android
   * @private
   */
  DataCollectionUtils.isAndroid = function () {
    return oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;
  };

  /**
   * Helper function which returns true if the engine is Blink
   * @private
   */
  DataCollectionUtils.isBlink = function () {
    return oj.AgentUtils.getAgentInfo().engine === oj.AgentUtils.ENGINE.BLINK;
  };

  /**
   * Helper function which returns true if the engine is webkit
   * @private
   */
  DataCollectionUtils.isWebkit = function () {
    return oj.AgentUtils.getAgentInfo().engine === oj.AgentUtils.ENGINE.WEBKIT;
  };

  /**
   * Helper function which returns browser version
   * @private
   */
  DataCollectionUtils.getBrowserVersion = function () {
    return parseInt(oj.AgentUtils.getAgentInfo().browserVersion, 10);
  };

  DataCollectionUtils.doesAttributeExistInFilterCriterion = function (
    attributeName,
    filterCriterion
  ) {
    // handle text filter
    if (filterCriterion.text) {
      return true;
    }
    // handle Nested Filter
    if (filterCriterion.attribute && filterCriterion.op && filterCriterion.op === '$exists') {
      if (this.doesAttributeExistInFilterCriterion(attributeName, filterCriterion.criterion)) {
        return true;
      }
    }
    // handle AttributeExpression filter
    else if (filterCriterion.attribute) {
      if (filterCriterion.attribute === '*') {
        return true;
      } else if (filterCriterion.attribute === attributeName) {
        return true;
      }
    }
    // handle Attribute filter
    // eslint-disable-next-line no-prototype-builtins
    else if (filterCriterion.value && filterCriterion.value.hasOwnProperty(attributeName)) {
      return true;
    }
    // handle Compound Filter
    else if (filterCriterion.criteria && filterCriterion.criteria.length > 0) {
      for (let i = 0; i < filterCriterion.criteria.length; i++) {
        if (this.doesAttributeExistInFilterCriterion(attributeName, filterCriterion.criteria[i])) {
          return true;
        }
      }
    }
    return false;
  };

  const applyMergedInlineStyles = DataCollectionUtils.applyMergedInlineStyles;
  const applyRendererContent = DataCollectionUtils.applyRendererContent;
  const applyStyleObj = DataCollectionUtils.applyStyleObj;
  const areKeySetsEqual = DataCollectionUtils.areKeySetsEqual;
  const containsKey = DataCollectionUtils.containsKey;
  const convertStringToStyleObj = DataCollectionUtils.convertStringToStyleObj;
  const disableElement = DataCollectionUtils.disableElement;
  const disableAllFocusableElements = DataCollectionUtils.disableAllFocusableElements;
  const disableDefaultBrowserStyling = DataCollectionUtils.disableDefaultBrowserStyling;
  const enableAllFocusableElements = DataCollectionUtils.enableAllFocusableElements;
  const getActionableElementsInNode = DataCollectionUtils.getActionableElementsInNode;
  const getAddEventKeysResult = DataCollectionUtils.getAddEventKeysResult;
  const getDefaultScrollBarWidth = DataCollectionUtils.getDefaultScrollBarWidth;
  const isElementOrAncestorFocusable = DataCollectionUtils.isElementOrAncestorFocusable;
  const isIterateAfterDoneNotAllowed = DataCollectionUtils.isIterateAfterDoneNotAllowed;
  const getFocusableElementsInNode = DataCollectionUtils.getFocusableElementsInNode;
  const getLogicalChildPopup = DataCollectionUtils.getLogicalChildPopup;
  const getNoJQFocusHandlers = DataCollectionUtils.getNoJQFocusHandlers;
  const handleActionablePrevTab = DataCollectionUtils.handleActionablePrevTab;
  const handleActionableTab = DataCollectionUtils.handleActionableTab;
  const isArrowDownKeyEvent = DataCollectionUtils.isArrowDownKeyEvent;
  const isArrowLeftKeyEvent = DataCollectionUtils.isArrowLeftKeyEvent;
  const isArrowRightKeyEvent = DataCollectionUtils.isArrowRightKeyEvent;
  const isArrowUpKeyEvent = DataCollectionUtils.isArrowUpKeyEvent;
  const isClickthroughDisabled = DataCollectionUtils.isClickthroughDisabled;
  const isEndKeyEvent = DataCollectionUtils.isEndKeyEvent;
  const isEnterKeyEvent = DataCollectionUtils.isEnterKeyEvent;
  const isEscapeKeyEvent = DataCollectionUtils.isEscapeKeyEvent;
  const isEventClickthroughDisabled = DataCollectionUtils.isEventClickthroughDisabled;
  const isFetchAborted = DataCollectionUtils.isFetchAborted;
  const getAbortReason = DataCollectionUtils.getAbortReason;
  const isFromDefaultSelector = DataCollectionUtils.isFromDefaultSelector;
  const isF2KeyEvent = DataCollectionUtils.isF2KeyEvent;
  const isHomeKeyEvent = DataCollectionUtils.isHomeKeyEvent;
  const isMobileTouchDevice = DataCollectionUtils.isMobileTouchDevice;
  const isSpaceBarKeyEvent = DataCollectionUtils.isSpaceBarKeyEvent;
  const isTabKeyEvent = DataCollectionUtils.isTabKeyEvent;
  const isNumberFiveKeyEvent = DataCollectionUtils.isNumberFiveKeyEvent;
  const isLetterAKeyEvent = DataCollectionUtils.isLetterAKeyEvent;
  const isMetaKeyEvent = DataCollectionUtils.isMetaKeyEvent;
  const KEYBOARD_KEYS = DataCollectionUtils.KEYBOARD_KEYS;
  const CHECKVIEWPORT_THRESHOLD = DataCollectionUtils.CHECKVIEWPORT_THRESHOLD;
  const WARN_DUPLICATE_KEYS_DETAIL = DataCollectionUtils.WARN_DUPLICATE_KEYS_DETAIL;
  const calculateOffsetTop = DataCollectionUtils.calculateOffsetTop;
  const isElementIntersectingScrollerBounds = DataCollectionUtils.isElementIntersectingScrollerBounds;
  const getScrollEventElement = DataCollectionUtils.getScrollEventElement;
  const getEventDetail = DataCollectionUtils.getEventDetail;
  const isRequestIdleCallbackSupported = DataCollectionUtils.isRequestIdleCallbackSupported;
  const isChrome = DataCollectionUtils.isChrome;
  const isFirefox = DataCollectionUtils.isFirefox;
  const isSafari = DataCollectionUtils.isSafari;
  const isEdge = DataCollectionUtils.isEdge;
  const isIE = DataCollectionUtils.isIE;
  const isMac = DataCollectionUtils.isMac;
  const isWindows = DataCollectionUtils.isWindows;
  const isIos = DataCollectionUtils.isIos;
  const isAndroid = DataCollectionUtils.isAndroid;
  const isWebkit = DataCollectionUtils.isWebkit;
  const isBlink = DataCollectionUtils.isBlink;
  const getBrowserVersion = DataCollectionUtils.getBrowserVersion;
  const doesAttributeExistInFilterCriterion = DataCollectionUtils.doesAttributeExistInFilterCriterion;

  exports.CHECKVIEWPORT_THRESHOLD = CHECKVIEWPORT_THRESHOLD;
  exports.KEYBOARD_KEYS = KEYBOARD_KEYS;
  exports.WARN_DUPLICATE_KEYS_DETAIL = WARN_DUPLICATE_KEYS_DETAIL;
  exports.applyMergedInlineStyles = applyMergedInlineStyles;
  exports.applyRendererContent = applyRendererContent;
  exports.applyStyleObj = applyStyleObj;
  exports.areKeySetsEqual = areKeySetsEqual;
  exports.calculateOffsetTop = calculateOffsetTop;
  exports.containsKey = containsKey;
  exports.convertStringToStyleObj = convertStringToStyleObj;
  exports.disableAllFocusableElements = disableAllFocusableElements;
  exports.disableDefaultBrowserStyling = disableDefaultBrowserStyling;
  exports.disableElement = disableElement;
  exports.doesAttributeExistInFilterCriterion = doesAttributeExistInFilterCriterion;
  exports.enableAllFocusableElements = enableAllFocusableElements;
  exports.getAbortReason = getAbortReason;
  exports.getActionableElementsInNode = getActionableElementsInNode;
  exports.getAddEventKeysResult = getAddEventKeysResult;
  exports.getBrowserVersion = getBrowserVersion;
  exports.getDefaultScrollBarWidth = getDefaultScrollBarWidth;
  exports.getEventDetail = getEventDetail;
  exports.getFocusableElementsInNode = getFocusableElementsInNode;
  exports.getLogicalChildPopup = getLogicalChildPopup;
  exports.getNoJQFocusHandlers = getNoJQFocusHandlers;
  exports.getScrollEventElement = getScrollEventElement;
  exports.handleActionablePrevTab = handleActionablePrevTab;
  exports.handleActionableTab = handleActionableTab;
  exports.isAndroid = isAndroid;
  exports.isArrowDownKeyEvent = isArrowDownKeyEvent;
  exports.isArrowLeftKeyEvent = isArrowLeftKeyEvent;
  exports.isArrowRightKeyEvent = isArrowRightKeyEvent;
  exports.isArrowUpKeyEvent = isArrowUpKeyEvent;
  exports.isBlink = isBlink;
  exports.isChrome = isChrome;
  exports.isClickthroughDisabled = isClickthroughDisabled;
  exports.isEdge = isEdge;
  exports.isElementIntersectingScrollerBounds = isElementIntersectingScrollerBounds;
  exports.isElementOrAncestorFocusable = isElementOrAncestorFocusable;
  exports.isEndKeyEvent = isEndKeyEvent;
  exports.isEnterKeyEvent = isEnterKeyEvent;
  exports.isEscapeKeyEvent = isEscapeKeyEvent;
  exports.isEventClickthroughDisabled = isEventClickthroughDisabled;
  exports.isF2KeyEvent = isF2KeyEvent;
  exports.isFetchAborted = isFetchAborted;
  exports.isFirefox = isFirefox;
  exports.isFromDefaultSelector = isFromDefaultSelector;
  exports.isHomeKeyEvent = isHomeKeyEvent;
  exports.isIE = isIE;
  exports.isIos = isIos;
  exports.isIterateAfterDoneNotAllowed = isIterateAfterDoneNotAllowed;
  exports.isLetterAKeyEvent = isLetterAKeyEvent;
  exports.isMac = isMac;
  exports.isMetaKeyEvent = isMetaKeyEvent;
  exports.isMobileTouchDevice = isMobileTouchDevice;
  exports.isNumberFiveKeyEvent = isNumberFiveKeyEvent;
  exports.isRequestIdleCallbackSupported = isRequestIdleCallbackSupported;
  exports.isSafari = isSafari;
  exports.isSpaceBarKeyEvent = isSpaceBarKeyEvent;
  exports.isTabKeyEvent = isTabKeyEvent;
  exports.isWebkit = isWebkit;
  exports.isWindows = isWindows;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojdomscroller',['ojs/ojcore-base', 'jquery', 'ojs/ojdatacollection-common', 'ojs/ojlogger'], function (oj, $, DataCollectionUtils, Logger) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /* jslint browser: true*/
  /**
   * @ignore
   * @class oj.DomScroller
   * @classdesc Adds implicit high-water mark scrolling to DOM element
   * @param {Object} element Scrollable DOM element
   * @param {Object} dataprovider dataprovider
   * @param {Object=} options Options for the DomScroller<p>
   *                  <b>asyncIterator</>the iterator for the dataprovider
   *                  <b>success</b>: a user callback called when a fetch has completed successfully after scroll to bottom. Also called with maxCount information if maxCount is reached after scroll to bottom.<br>
   *                  <b>error</b>: a user callback function called if the fetch fails. The callback is called with the failed fetch content.<br>
   *                  <b>fetchSize</b>: the fetch size. Default is 25.<br>
   *                  <b>maxCount</b>: max row count. DomScroller will not exceed this max count. Default is 500.<br>
   *                  <b>initialRowCount</b>: initial row count. DomScroller will be initialized with this row count. Default is 0.<br>
   *                  <b>fetchTrigger</b>: how close should the scroll position be relative to the maximum scroll position before a fetch is triggered. Default is 1 pixel.<br>
   * @constructor
   * @ojtsmodule
   */
  const DomScroller = function (element, dataprovider, options) {
    // eslint-disable-next-line no-param-reassign
    options = options || {};
    this._data = dataprovider;
    this._asyncIterator = options.asyncIterator;
    this._element = $(element)[0];
    this._contentElement = options.contentElement;
    this._fetchSize = options.fetchSize;
    this._fetchSize = this._fetchSize > 0 ? this._fetchSize : 25;
    this._maxCount = options.maxCount;
    this._maxCount = this._maxCount > 0 ? this._maxCount : 500;
    this._rowCount = options.initialRowCount > 0 ? options.initialRowCount : 0;
    this._controller = options.controller;
    this._successCallback = options.success;
    this._requestCallback = options.request;
    this._errorCallback = options.error;
    this._isOverflowCallback = options.isOverflow;
    this._beforeFetchCallback = options.beforeFetch;
    this._beforeScrollCallback = options.beforeScroll;
    this._localKeyValidator = options.localKeyValidator;
    this._registerDataSourceEventListeners();
    this._fetchTrigger = options.fetchTrigger;
    if (this._fetchTrigger == null || isNaN(this._fetchTrigger)) {
      this._fetchTrigger = 0;
    }
    this._initialScrollTop = this._element.scrollTop;
    this._lastFetchTrigger = 0;
    this._isScrollTriggeredByMouseWheel = false;
    this._checkViewportCount = 0;
    this._fetchThreshold = 0.25;

    var elem = DataCollectionUtils.getScrollEventElement(this._element);
    this._scrollEventListener = function () {
      if (this._isScrollTrackingPaused) {
        // do not trigger any scroll notifications if scroll tracking is paused
        return;
      }
      if (this._beforeScrollCallback) {
        this._beforeScrollCallback();
      }
      var scrollTop = this._element.scrollTop;
      var scrollerHeight = this._element.clientHeight;
      var maxScrollTop = this._element.scrollHeight - scrollerHeight;
      if (maxScrollTop > 0) {
        if (this._contentElement) {
          this._handleExternalScrollerScrollTop(scrollTop, scrollerHeight);
        } else {
          this._handleScrollerScrollTop(scrollTop, maxScrollTop);
        }
      }
    }.bind(this);
    elem.addEventListener('scroll', this._scrollEventListener);

    this._wheelEventListener = function () {
      this._isScrollTriggeredByMouseWheel = true;
    }.bind(this);
    elem.addEventListener('wheel', this._wheelEventListener, { passive: true });

    this._mouseDownEventListener = function () {
      this._isScrollTriggeredByMouseWheel = false;
    }.bind(this);
    elem.addEventListener('mousedown', this._mouseDownEventListener);
  };

  /**
   * Update the async iterator which could have been removed previous because
   * iterator has been exhausted
   */
  DomScroller.prototype.setAsyncIterator = function (asyncIterator) {
    this._asyncIterator = asyncIterator;
  };

  /**
   * Pause scroll tracking for this DomScroller instance
   */
  DomScroller.prototype.pauseScrollTracking = function () {
    this._isScrollTrackingPaused = true;
  };

  /**
   * Resume scroll tracking for this DomScroller instance
   */
  DomScroller.prototype.resumeScrollTracking = function () {
    this._isScrollTrackingPaused = false;
  };

  /**
   * Update value for fetch trigger
   */
  DomScroller.prototype.setFetchTrigger = function (fetchTrigger) {
    if (fetchTrigger != null && !isNaN(fetchTrigger) && fetchTrigger >= 0) {
      this._fetchTrigger = fetchTrigger;
    }
  };

  /**
   * Destroys the dom scroller, unregister any event handlers.
   * @export
   * @expose
   * @memberof! oj.DomScroller
   * @instance
   */
  DomScroller.prototype.destroy = function () {
    this._unregisterDataSourceEventListeners();
    var elem = DataCollectionUtils.getScrollEventElement(this._element);
    if (elem) {
      elem.removeEventListener('scroll', this._scrollEventListener);
      elem.removeEventListener('wheel', this._wheelEventListener, { passive: true });
      elem.removeEventListener('mousedown', this._mouseDownEventListener);
    }
  };

  /**
   * Check the viewport to see if a fetch needs to be done to fill it. Fetch if it does.
   * @param {boolean=} forceFetch true if a fetch should be forced even if overflow is detected
   * @return {Promise} Return a Promise which contains either the content of the fetch
   *                   or maxCount information if it has reached maxCount. Promise resolves to null if no fetch was done.
   * @throws {Error}
   * @export
   * @expose
   * @memberof! oj.DomScroller
   * @instance
   */
  DomScroller.prototype.checkViewport = function (forceFetch) {
    if (
      this._asyncIterator &&
      this._element.clientHeight > 0 &&
      (forceFetch || !this.isOverflow() || this._isEndReached())
    ) {
      this._checkViewportCount += 1;
      if (this._checkViewportCount === DataCollectionUtils.CHECKVIEWPORT_THRESHOLD) {
        Logger.warn(
          'Viewport not satisfied after multiple fetch, make sure the component is height constrained or specify a scroller.'
        );
      }
      if (this._beforeFetchCallback(this._element.scrollTop, true)) {
        return this._fetchMoreRows();
      }
    }
    this._checkViewportCount = 0;
    return Promise.resolve(null);
  };

  /**
   * Fetch more rows if beforeFetch callback allows it
   * @private
   */
  DomScroller.prototype._doFetch = function (scrollTop) {
    var self = this;

    if (this._beforeFetchCallback(scrollTop - this._fetchTrigger, false)) {
      this._lastFetchTrigger = scrollTop;

      var isMouseWheel = self._isScrollTriggeredByMouseWheel;
      this._fetchPromise = this._fetchMoreRows().then(
        function (result) {
          if (self._successCallback) {
            // eslint-disable-next-line no-param-reassign
            result.isMouseWheel = isMouseWheel;
            self._successCallback(result);
            self._fetchPromise = null;
            // re-calculated on next scroll
            self._nextFetchTrigger = undefined;
          }
        },
        function (reason) {
          if (self._errorCallback) {
            var isAbort = self._controller != null ? self._controller.signal.aborted : false;
            self._errorCallback(reason, isAbort);
            self._fetchPromise = null;
            self._nextFetchTrigger = undefined;
          }
        }
      );
    } else {
      // items not rendered yet, reset nextFetchTrigger so it gets calculated again
      this._nextFetchTrigger = undefined;
    }
  };

  DomScroller.prototype._handleExternalScrollerScrollTop = function (scrollTop, scrollerHeight) {
    if (!this._fetchPromise && this._asyncIterator) {
      var contentBounds = this._contentElement.getBoundingClientRect();
      var scrollerBottom =
        this._element === document.body || this._element === document.documentElement
          ? scrollerHeight
          : this._element.getBoundingClientRect().bottom;
      var scrollDiff = contentBounds.bottom - scrollerBottom;
      if (scrollDiff <= this._fetchTrigger + contentBounds.height * this._fetchThreshold) {
        this._doFetch(scrollTop);
      }
    }
  };

  /**
   * Handle scrollTop on scroller
   * @private
   */
  DomScroller.prototype._handleScrollerScrollTop = function (scrollTop, maxScrollTop) {
    if (!this._fetchPromise && this._asyncIterator) {
      if (maxScrollTop !== this._lastMaxScrollTop) {
        this._nextFetchTrigger = Math.max(0, (maxScrollTop - this._fetchTrigger - scrollTop) / 2);
        this._lastMaxScrollTop = maxScrollTop;
      }

      if (
        this._nextFetchTrigger != null &&
        scrollTop - this._lastFetchTrigger > this._nextFetchTrigger
      ) {
        this._doFetch(scrollTop);

        // note beforeFetchCallback would return false if the render queue is non-empty
        // in which case we should just wait until the next idle cycle to clear the queue
        return;
      }
    }

    if (maxScrollTop - scrollTop < 1 && scrollTop > this._fetchTrigger) {
      if (this._fetchPromise) {
        // at the bottom but fetch has not return yet, in which case we will block UI via requestCallback
        if (this._asyncIterator) {
          if (this._requestCallback != null) {
            this._requestCallback();
          }
        } else if (this._errorCallback != null) {
          this._errorCallback();
        }
      } else if (this._asyncIterator) {
        // at the bottom and all items from last fetch are rendered, start a new fetch
        this._doFetch(scrollTop);
      }
    }
  };

  /**
   * Check whether the scroll DOM has overflowed
   * @return {boolean} true if overflowed, false otherwise
   */
  DomScroller.prototype.isOverflow = function () {
    if (this._isOverflowCallback) {
      return this._isOverflowCallback();
    }

    var scrollHeight = this._contentElement
      ? this._contentElement.scrollHeight
      : this._element.scrollHeight;
    var diff = scrollHeight - (this._element.clientHeight + this._fetchTrigger);
    if (diff === 1 && oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.EDGE) {
      // hitting Edge , see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/21405284/
      // note this will only happen with non-height-bounded ListView with loadMoreOnScroll, see 
      diff = 0;
    }

    return diff > 0;
  };

  /**
   * @private
   */
  DomScroller.prototype._isEndReached = function () {
    if (
      this._element.scrollHeight - this._element.clientHeight - this._element.scrollTop <
      Math.max(1, this._fetchTrigger)
    ) {
      // this could happen if the offsetTop is not correct
      return true;
    }
    return false;
  };

  /**
   * Try to fetch more rows
   * @private
   */
  DomScroller.prototype._fetchMoreRows = function () {
    if (!this._fetchPromise) {
      // make sure we don't exceed maxCount
      var remainingCount = this._maxCount - this._rowCount;
      if (remainingCount > 0) {
        var self = this;

        if (this._asyncIterator) {
          this._fetchPromise = this._asyncIterator.next().then(function (_result) {
            var result = _result;
            self._fetchPromise = null;

            if (result != null && result.value != null) {
              let value = result.value;
              var dataLength = value.data.length;
              if (dataLength > 0) {
                self._rowCount += dataLength;
                if (remainingCount <= dataLength) {
                  if (dataLength > remainingCount) {
                    let fetchParameters = value.fetchParameters;
                    if (fetchParameters != null) {
                      fetchParameters = { ...fetchParameters, size: remainingCount };
                    }
                    value = {
                      ...value,
                      data: value.data.slice(0, remainingCount),
                      metadata: value.metadata.slice(0, remainingCount),
                      fetchParameters
                    };
                  }
                  result = { ...result, maxCount: self._maxCount, maxCountLimit: true, value };
                }
              }

              // we have exhausted the iterator, discard so we won't attempt to fetch from it again
              if (result.done || result.maxCountLimit) {
                self._asyncIterator = null;
              }
            }
            return Promise.resolve(result);
          });
          return this._fetchPromise;
        }
      }
      // we need to indicate that we've hit maxCount
      this._asyncIterator = null;
      return Promise.resolve({ maxCount: this._maxCount, maxCountLimit: true });
    }

    return this._fetchPromise;
  };

  /**
   * @private
   */
  DomScroller.prototype._handleDataRowMutateEvent = function (event) {
    // if everything has been fetched already then we don't have to do anything also
    if (this._asyncIterator == null) {
      return;
    }

    var eventDetail;
    var indexes;
    var keys;
    var self = this;

    if (event.detail.add != null) {
      eventDetail = event.detail.add;
      // for add, it exists if index is in range, or before/after key is in range
      if (eventDetail.indexes != null) {
        indexes = eventDetail.indexes;
      } else if (eventDetail.addBeforeKeys != null) {
        keys = eventDetail.addBeforeKeys;
      } else if (eventDetail.afterKeys != null) {
        // deprecated but still needs to support it
        keys = eventDetail.afterKeys;
      } else {
        // no keys and indexes, then it's inserting to the end
        // since we already bail when there are nothing to fetch, the only
        // case is when we have not reached the end yet, in which case
        // we should not do anything since it's outside of range
      }

      this._handleDataRowAddedOrRemoved(keys, indexes, function () {
        self._rowCount += 1;
      });
    }

    if (event.detail.remove != null) {
      eventDetail = event.detail.remove;
      // for remove, it exists if index or key is in range
      if (eventDetail.indexes != null) {
        indexes = eventDetail.indexes;
      } else if (eventDetail.keys != null) {
        keys = eventDetail.keys;
      }

      this._handleDataRowAddedOrRemoved(keys, indexes, function () {
        self._rowCount -= 1;
      });
    }
  };

  /**
   * @private
   */
  DomScroller.prototype._handleDataRowAddedOrRemoved = function (keys, indexes, callback) {
    if (indexes) {
      for (var i = 0; i < indexes.length; i++) {
        var rowIdx = indexes[i];
        // we only care if the row is in our range
        if (rowIdx !== undefined && this._rowCount > 0 && rowIdx <= this._rowCount) {
          callback();
        }
      }
    } else if (keys) {
      var keyValidator = this._localKeyValidator;
      if (keyValidator != null) {
        // forEach works for both Array and Set
        keys.forEach(function (key) {
          if (keyValidator(key)) {
            callback();
          }
        });
      }
    }
  };

  /**
   * Register event listeners which need to be registered datasource.
   * @private
   */
  DomScroller.prototype._registerDataSourceEventListeners = function () {
    // register the listeners on the datasource
    var data = this._data;
    if (data != null) {
      this._unregisterDataSourceEventListeners();

      this._dataProviderEventHandlers = [];
      this._dataProviderEventHandlers.push({
        eventType: 'mutate',
        eventHandler: this._handleDataRowMutateEvent.bind(this)
      });

      var i;
      var ev;
      for (i = 0; i < this._dataProviderEventHandlers.length; i++) {
        ev = data.addEventListener(
          this._dataProviderEventHandlers[i].eventType,
          this._dataProviderEventHandlers[i].eventHandler
        );
        if (ev) {
          this._dataProviderEventHandlers[i].eventHandler = ev;
        }
      }
    }
  };

  /**
   * Unregister event listeners which are registered on datasource.
   * @private
   */
  DomScroller.prototype._unregisterDataSourceEventListeners = function () {
    var data = this._data;
    // unregister the listeners on the datasource
    if (this._dataProviderEventHandlers != null && data != null) {
      var i;
      for (i = 0; i < this._dataProviderEventHandlers.length; i++) {
        data.removeEventListener(
          this._dataProviderEventHandlers[i].eventType,
          this._dataProviderEventHandlers[i].eventHandler
        );
      }
    }
  };

  return DomScroller;

});


define('ojs/ojdataproviderscroller',['exports', 'ojs/ojcore-base', 'jquery', 'ojs/ojcontext', 'ojs/ojdatacollection-common', 'ojs/ojconfig', 'ojs/ojanimation', 'ojs/ojlogger', 'ojs/ojdomscroller', 'ojs/ojset', 'ojs/ojmap'], function (exports, oj, $, Context, DataCollectionUtils, Config, AnimationUtils, Logger, DomScroller, KeySet, KeyMap) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  DomScroller = DomScroller && Object.prototype.hasOwnProperty.call(DomScroller, 'default') ? DomScroller['default'] : DomScroller;
  KeySet = KeySet && Object.prototype.hasOwnProperty.call(KeySet, 'default') ? KeySet['default'] : KeySet;
  KeyMap = KeyMap && Object.prototype.hasOwnProperty.call(KeyMap, 'default') ? KeyMap['default'] : KeyMap;

  /**
   * Base class for IteratingDataProviderContentHandler and TreeDataProviderContentHandler
   * Handler for DataProvider generated content
   * @constructor
   * @ignore
   */
  var DataProviderContentHandler = function (widget, root, data) {
    this.m_root = root;
    this.m_widget = widget;

    this.m_fetching = false;

    this.setDataProvider(data);
    this.Init();
  };
  // Subclass from oj.Object
  oj.Object.createSubclass(DataProviderContentHandler, oj.Object, 'DataProviderContentHandler');

  /**
   * Initializes the instance.
   * @export
   */
  DataProviderContentHandler.prototype.Init = function () {
    DataProviderContentHandler.superclass.Init.call(this);
  };

  /**
   * Handles when the listview is shown due to for example CSS changes (inside a dialog)
   */
  DataProviderContentHandler.prototype.notifyShown = function () {
    // by default do nothing, to be override by subclass
  };

  /**
   * Handles when the listview is re-attached to the DOM (ex: when a children of CCA gets re-attached from slotting)
   */
  DataProviderContentHandler.prototype.notifyAttached = function () {
    // by default do nothing, to be override by subclass
  };

  /**
   * Cleanse all items under the root node
   */
  DataProviderContentHandler.prototype.cleanItems = function (templateEngine, parent) {
    if (templateEngine === undefined) {
      // eslint-disable-next-line no-param-reassign
      templateEngine = this.getTemplateEngine();
    }

    if (parent === undefined) {
      // eslint-disable-next-line no-param-reassign
      parent = this.m_root;
    }

    if (templateEngine && parent) {
      var children = parent.childNodes;
      for (var i = 0; i < children.length; i++) {
        templateEngine.clean(children[i], this.m_widget.GetRootElement()[0]);
      }
    }
  };

  /**
   * Destroy the content handler
   * @protected
   */
  DataProviderContentHandler.prototype.Destroy = function (completelyDestroy) {
    // this.m_root was changed in RenderContent
    if (this.m_superRoot != null) {
      this.m_root = this.m_superRoot;
    }

    this.cleanItems();
    if (completelyDestroy) {
      $(this.m_root).empty();
    }
    this._destroySparkles();
    this.m_widget = null;
    this.m_root = null;
    this.m_superRoot = null;
  };

  /**
   * Determines whether the content handler is in a ready state
   * @return {boolean} true if there's no outstanding fetch, false otherwise.
   * @protected
   */
  DataProviderContentHandler.prototype.IsReady = function () {
    return !this.m_fetching;
  };

  /**
   * Sets any aria attributes on the root element
   * @protected
   */
  DataProviderContentHandler.prototype.setRootAriaProperties = function () {
    if (this.shouldUseGridRole()) {
      this.m_root.setAttribute('role', 'grid');
    } else if (this.IsHierarchical()) {
      this.m_root.setAttribute('role', 'tree');
    } else {
      this.m_root.setAttribute('role', 'listbox');
    }
  };

  /**
   * Renders the content inside the list
   * @protected
   */
  DataProviderContentHandler.prototype.RenderContent = function () {
    this.signalTaskStart('rendering content'); // signal method task start

    this.setRootAriaProperties();
    this.fetchRows(false);
    this.signalTaskEnd(); // signal method task end
  };

  /**
   * Retrieve the key given the item element
   * @param {Element} element
   * @return {Object|null}
   * @protected
   */
  DataProviderContentHandler.prototype.GetKey = function (element) {
    // should be in the element
    return element.key;
  };

  DataProviderContentHandler.prototype.FindElementByKey = function (key) {
    // the later selector is for cards that are in the process of insert animation
    var children = this.m_root.querySelectorAll(
      '.' +
        this.m_widget.getItemElementStyleClass() +
        ', .oj-listview-temp-item.oj-listview-card-animated'
    );
    for (var i = 0; i < children.length; i++) {
      var elem = children[i];
      // use == for the string number compare case
      // make sure item is not marked for deletion or a clone created by dnd
      if (
        // eslint-disable-next-line eqeqeq
        (key == this.GetKey(elem) || oj.Object.compareValues(key, this.GetKey(elem))) &&
        !elem.classList.contains('oj-listview-item-remove') &&
        !elem.classList.contains('oj-drop')
      ) {
        return elem;
      }
    }

    return null;
  };

  DataProviderContentHandler.prototype.getDataProvider = function () {
    return this.m_dataProvider;
  };

  /**
   * @protected
   */
  DataProviderContentHandler.prototype.setDataProvider = function (dataProvider) {
    this._removeDataSourceEventListeners();

    if (dataProvider != null) {
      this.m_handleModelMutateEventListener = this.handleModelMutateEvent.bind(this);
      this.m_handleModelRefreshEventListener = this.handleModelRefreshEvent.bind(this);

      dataProvider.addEventListener('mutate', this.m_handleModelMutateEventListener);
      dataProvider.addEventListener('refresh', this.m_handleModelRefreshEventListener);
    }

    this.m_dataProvider = dataProvider;
  };

  /**
   * Remove data source event listeners
   * @private
   */
  DataProviderContentHandler.prototype._removeDataSourceEventListeners = function () {
    var dataProvider = this.getDataProvider();
    if (dataProvider != null) {
      dataProvider.removeEventListener('mutate', this.m_handleModelMutateEventListener);
      dataProvider.removeEventListener('refresh', this.m_handleModelRefreshEventListener);

      // If dataProvider is a TableDataSourceAdapter, call destroy on it also to remove its listeners
      if (oj.TableDataSourceAdapter && dataProvider instanceof oj.TableDataSourceAdapter) {
        dataProvider.destroy();
      }
    }
  };

  /**
   * Initiate loading of the template engine.  An error is thrown if the template engine failed to load.
   * @return {Promise} resolves to the template engine, or null if:
   *                   1) there's no need because no item template is specified
   *                   2) a renderer is present which takes precedence
   * @protected
   */
  DataProviderContentHandler.prototype.loadTemplateEngine = function () {
    if (this.m_widget.getItemTemplate() != null && this.m_widget._getItemRenderer() == null) {
      return new Promise((resolve) => {
        const templateOptions = {
          customElement: this.m_widget._GetCustomElement()
        };
        Config.__getTemplateEngine(templateOptions).then(
          (engine) => {
            this.m_engine = engine;
            resolve(engine);
          },
          (reason) => {
            throw new Error('Error loading template engine: ' + reason);
          }
        );
      });
    }

    return Promise.resolve(null);
  };

  /**
   * Retrieve the template engine, returns null if it has not been loaded yet
   */
  DataProviderContentHandler.prototype.getTemplateEngine = function () {
    return this.m_engine;
  };

  // eslint-disable-next-line no-unused-vars
  DataProviderContentHandler.prototype.fetchRows = function (forceFetch) {
    this.m_widget.showStatusText();
  };

  /**
   * Returns the tag name of the item element.
   * @return {string} the tag name of the item element.
   * @protected
   */
  DataProviderContentHandler.prototype.GetChildElementTagName = function () {
    return 'LI';
  };

  /**
   * Returns the insert before element given the index, or null if insert at the end.
   * @return {Element|null} the reference element.
   * @protected
   */
  DataProviderContentHandler.prototype.GetReferenceNode = function (parentElement, index) {
    if (index === -1) {
      return null;
    }

    var childElements = $(parentElement).children(
      '.' +
        this.m_widget.getItemElementStyleClass() +
        ', .' +
        this.m_widget.getEmptyTextStyleClass() +
        ', .oj-listview-temp-item'
    );
    return index === childElements.length ? null : childElements[index];
  };

  /**
   * Create a list item and add it to the list
   * @param {Element|DocumentFragment} parentElement the element to add the list items to
   * @param {number} index the index of the item
   * @param {Object|null} data the data for the item
   * @param {Object} metadata the set of metadata for the item
   * @param {Object} templateEngine the template engine to process inline template
   * @param {function(Element, Object)=} callback optional callback function to invoke after item is added
   * @return {Object} contains the list item and the context object
   * @return {Object} itemMetaData the array of metadata
   * @protected
   */
  DataProviderContentHandler.prototype.addItem = function (
    parentElement,
    index,
    data,
    metadata,
    templateEngine,
    callback,
    itemMetaData
  ) {
    var item = document.createElement(this.GetChildElementTagName()); // @HTMLUpdateOK

    $(item).uniqueId();
    var referenceNode = this.GetReferenceNode(parentElement, index);
    // should be optional
    if (this.m_widget.BeforeInsertItem) {
      this.m_widget.BeforeInsertItem();
    }
    parentElement.insertBefore(item, referenceNode); // @HTMLUpdateOK
    var position = $(parentElement).children().index(item);
    return this._addOrReplaceItem(
      item,
      position,
      parentElement,
      index,
      data,
      metadata,
      templateEngine,
      callback,
      false,
      itemMetaData
    );
  };

  /**
   * Replace an existing list item in the list
   * @param {Element} item the list item to change
   * @param {number} index the index of the item
   * @param {Object|null} data the data for the item
   * @param {Object} metadata the set of metadata for the item
   * @param {Object} templateEngine the template engine to process inline template
   * @param {function(Element, Object)} callback callback function to invoke after item is added
   * @param {boolean} restoreFocus flag to restore focus on updated item
   * @protected
   */
  DataProviderContentHandler.prototype.replaceItem = function (
    item,
    index,
    data,
    metadata,
    templateEngine,
    callback,
    restoreFocus
  ) {
    // animate hiding of existing item first
    this.signalTaskStart('replace item'); // signal replace item animation start. Ends in _handleReplaceTransitionEnd() defined in TableDataSourceContentHandler

    // now actually replace the item
    var parentElement = item.parentNode;
    var position = $(parentElement).children().index(item);
    var newItem = document.createElement(this.GetChildElementTagName()); // @HTMLUpdateOK

    // explicit clean when inline template is used
    if (templateEngine) {
      templateEngine.clean(item, this.m_widget.GetRootElement()[0]);
    }

    // this should trigger ko.cleanNode if applicable
    $(item).replaceWith(newItem); // @HTMLUpdateOK newItem is constructed by the component and not yet manipulated by the application

    return this._addOrReplaceItem(
      newItem,
      position,
      parentElement,
      index,
      data,
      metadata,
      templateEngine,
      callback,
      restoreFocus
    );
  };

  /**
   * Handles both add and replace item
   * @private
   */
  DataProviderContentHandler.prototype._addOrReplaceItem = function (
    item,
    position,
    parentElement,
    index,
    data,
    metadata,
    templateEngine,
    callback,
    restoreFocus,
    itemMetaData,
    replaceChildCallback
  ) {
    if (callback == null) {
      // eslint-disable-next-line no-param-reassign
      callback = this.afterRenderItem.bind(this);
    }

    var context = this.createContext(position, data, metadata, item, itemMetaData);
    var renderer = this.m_widget._getItemRenderer();
    var templateElement = this.m_widget.getItemTemplate();
    var isCustomizeItem = false;

    if (renderer != null) {
      DataCollectionUtils.applyRendererContent(item, renderer.call(this, context), true);
    } else if (templateElement != null && templateEngine != null) {
      var componentElement = this.m_widget.GetRootElement()[0];
      var bindingContext = this.GetBindingContext(context);
      var as = this.m_widget.getAs ? this.m_widget.getAs() : null;
      var nodes = templateEngine.execute(componentElement, templateElement, bindingContext, as);
      if (replaceChildCallback) {
        isCustomizeItem = replaceChildCallback(nodes);
      } else {
        var tagName = this.GetChildElementTagName();
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].tagName === tagName) {
            isCustomizeItem = true;
            break;
          }
        }
        if (isCustomizeItem) {
          item.replaceWith(...nodes); // @HTMLUpdateOK
        } else {
          item.append(...nodes); // @HTMLUpdateOK
        }
      }
    } else {
      var textWrapper = document.createElement('span');
      textWrapper.appendChild(document.createTextNode(data == null ? '' : data.toString())); // @HTMLUpdateOK
      item.appendChild(textWrapper); // @HTMLUpdateOK
    }

    // inject suggestion info for accessiblity
    if (itemMetaData && itemMetaData.suggestion) {
      item.appendChild(this._createAccInfoForSuggestion());
    }

    // get the item from root again as template replaces the item element
    var parentItem = parentElement.children
      ? parentElement.children[position]
      : this._getItemFromDocumentFragment(parentElement, position);
    context.parentElement = parentItem;

    // cache data and metadata in item element, this is needed for getDataForVisibleItem.
    $.data(parentItem, 'data', data);
    $.data(parentItem, 'metadata', itemMetaData);

    // do any post processing
    return callback(parentItem, context, isCustomizeItem, restoreFocus);
  };

  /**
   * @private
   */
  DataProviderContentHandler.prototype._createAccInfoForSuggestion = function () {
    const span = document.createElement('span');
    span.classList.add('oj-helper-hidden-accessible');
    span.classList.add('oj-listview-acc-suggestion');
    span.textContent = this.m_widget.ojContext.getTranslatedString('accessibleSuggestion');
    return span;
  };

  /**
   * In IE/Safari, DocumentFragment does not support children property
   * @private
   */
  DataProviderContentHandler.prototype._getItemFromDocumentFragment = function (fragment, index) {
    var nodeIndex = 0;
    var nodes = fragment.childNodes;

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) {
        break;
      }

      if (node.nodeType === 1) {
        if (nodeIndex === index) {
          return node;
        }
        nodeIndex += 1;
      }
    }
    return null;
  };

  /**
   * Creates a binding context based on context object
   * To be override by different ContentHandler
   * @protected
   */
  DataProviderContentHandler.prototype.GetBindingContext = function (context) {
    var current = {};
    current.data = context.data;
    current.index = context.index;
    current.key = context.key;
    current.componentElement = context.componentElement;
    current.item = { data: context.data, metadata: context.metadata };
    return current;
  };

  DataProviderContentHandler.prototype.afterRenderItem = function (item, context) {
    // save the key in the element (cannot use data- here since it could be a non-string)
    // eslint-disable-next-line no-param-reassign
    item.key = context.key;

    var $item = $(item);
    $item.uniqueId();

    // if there's only one element inside the item and it is focusable, set
    // the role on it instead
    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass();
    var elem;
    // in the case where group item is already present
    if (item.firstElementChild && item.firstElementChild.classList.contains(groupItemStyleClass)) {
      elem = this.m_widget.getSingleFocusableElement($(item.firstElementChild));
    } else {
      elem = this.m_widget.getSingleFocusableElement($item);
    }

    if (this.shouldUseGridRole()) {
      if (context.leaf != null && !context.leaf) {
        // it's a group item
        $item.attr('role', 'presentation');
      } else if (this.isCardLayout()) {
        elem.attr('role', 'gridcell');
      } else {
        $item.attr('role', 'row');
        if (elem !== $item) {
          elem.attr('role', 'gridcell');
        } else {
          // we'll need to wrap content with a gridcell role
          var wrapperHTML = "<div role='gridcell' class='oj-listview-cell-element'></div>";
          var children = elem.children();
          if (children.length === 0) {
            elem.get(0).innerHTML = wrapperHTML; // @HTMLUpdateOK
          } else {
            // include comment nodes/ko virtual elements
            var cell = document.createElement('div');
            cell.setAttribute('role', 'gridcell');
            cell.className = 'oj-listview-cell-element';

            while (elem[0].firstChild) {
              // The list is LIVE so it will re-index each call
              cell.appendChild(elem[0].firstChild); // @HTMLUpdateOK
            }
            elem[0].appendChild(cell);
          }
        }
      }
    } else {
      elem.attr('role', this.IsHierarchical() ? 'treeitem' : 'option');
      if (elem !== $item) {
        $item.attr('role', 'presentation');
      }
    }

    elem.addClass(this.m_widget.getFocusedElementStyleClass());

    // tag it if item is not focusable
    if (!this.isFocusable(context)) {
      $item.addClass('oj-skipfocus');
    }

    $item.addClass(this.m_widget.getItemElementStyleClass());

    return Promise.resolve(true);
  };

  /**
   * Creates the context object containing metadata
   * @param {number} index the index
   * @param {Object} key the key
   * @param {Object} data the data
   * @param {Element} parentElem the parent element
   * @return {Object} the context object
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DataProviderContentHandler.prototype.getMetadata = function (index, key, data, parentElem) {
    var context = data.context;
    if (context == null) {
      context = {};
    }

    if (context.index == null) {
      context.index = index;
    }

    if (context.key == null) {
      context.key = key;
    }

    return context;
  };

  /**
   * Model mutate event handler.  Called on rows mutation.
   * @param {Object} event the mutate model event
   * @protected
   */
  DataProviderContentHandler.prototype.handleModelMutateEvent = function (event) {
    if (this.m_root == null || !this.m_widget.isAvailable()) {
      return;
    }

    if (event.detail.remove != null) {
      this.handleModelRemoveEvent(event);
    }
    if (event.detail.add != null) {
      this.handleModelAddEvent(event);
    }
    if (event.detail.update != null) {
      this.handleModelChangeEvent(event);
    }
    if (this.getValidatedEventDetailPromise) {
      this.getValidatedEventDetailPromise.then(() => {
        if (this.m_widget == null) {
          return;
        }

        if (event.detail.remove) {
          this.handleModelRemoveEvent(event);
        }
        this.getValidatedEventDetailPromise = null;
      });
    }
  };

  /**
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DataProviderContentHandler.prototype.handleModelRefreshEvent = function (event) {};

  /**
   * @private
   */
  DataProviderContentHandler.prototype._pushToEventQueue = function (event) {
    if (this.m_eventQueue == null) {
      this.m_eventQueue = [];
    }

    this.m_eventQueue.push(event);
  };

  DataProviderContentHandler.prototype._processEventQueue = function () {
    var event;

    if (this.m_eventQueue != null && this.m_eventQueue.length > 0) {
      // see if we can find a refresh event (without keys field which means it's a full refresh)
      for (var i = 0; i < this.m_eventQueue.length; i++) {
        event = this.m_eventQueue[i].event;
        if (event.type === 'refresh' && (event.detail == null || event.detail.keys == null)) {
          this.handleModelRefreshEvent(event);
          // we are done
          return;
        }
      }

      // we'll just need to handle one event at a time since processEventQueue will be triggered whenever an event is done processing
      event = this.m_eventQueue.shift().event;
      if (event.type === 'mutate') {
        this.handleModelMutateEvent(event);
      } else if (event.type === 'refresh' && event.detail && event.detail.keys) {
        this.handleModelRefreshEvent(event);
      }
    }
  };

  DataProviderContentHandler.prototype._clearEventQueue = function () {
    if (this.m_eventQueue != null) {
      this.m_eventQueue.length = 0;
    }
  };

  /**
   * Override by ContentHandler to do the actual model insert
   * @protected
   */
  DataProviderContentHandler.prototype.addItemsForModelInsert =
    // eslint-disable-next-line no-unused-vars
    function (data, indexes, keys, parentKeys, afterKeys) {};

  /**
   * Retrieve the index of the item with the specified key
   * @protected
   */
  DataProviderContentHandler.prototype.getIndex = function (keys, index) {
    if (keys == null || keys.length === 0 || index >= keys.length) {
      return -1;
    }

    var key = keys[index];
    var elem = this.FindElementByKey(key);
    return elem != null ? $(elem.parentNode).children().index(elem) : -1;
  };

  /**
   * Gets the maximum number of items that can be retrieved from data source
   * @return {number} the maximum fetch count
   * @private
   */
  DataProviderContentHandler.prototype._getMaxCount = function () {
    return this.m_widget.options.scrollPolicyOptions.maxCount;
  };

  /**
   * Callback handler max fetch count.
   * @private
   */
  DataProviderContentHandler.prototype._handleScrollerMaxRowCount = function () {
    // TODO: use resource bundle
    Logger.info('ScrollPolicyOptions max count has been reached.');
  };

  /**
   * Truncate the data if the length of data is greater than max count
   * @param validatedEventDetail validated event detail
   * @param currentDataLength length of current data
   */
  DataProviderContentHandler.prototype.truncateIfOverMaxCount = function (
    validatedEventDetail,
    currentDataLength
  ) {
    const eventDataLength = validatedEventDetail.data.length;
    const potentialDataLength = eventDataLength + currentDataLength;
    const offset = this._getMaxCount() - potentialDataLength;
    // over max count need to truncate
    if (offset < 0) {
      validatedEventDetail.data.splice(offset, eventDataLength);
      validatedEventDetail.metadata.splice(offset, eventDataLength);
      this._handleScrollerMaxRowCount();
    }
  };

  /**
   * Get the validated data and metadata for event detail
   * @param detail event detail
   */
  DataProviderContentHandler.prototype.getValidatedEventDetail = function (detail) {
    const addEventBusyResolve = this.m_widget._addComponentBusyState(
      'validating mutation add event detail'
    );
    return DataCollectionUtils.getEventDetail(this.getDataProvider(), detail).then((validatedEventDetail) => {
      if (validatedEventDetail === null) {
        addEventBusyResolve();
        return null;
      }
      const styleClass = '.' + this.m_widget.getItemElementStyleClass();
      const items = this.m_root.querySelectorAll(styleClass);
      this.truncateIfOverMaxCount(validatedEventDetail, items.length);
      addEventBusyResolve();
      return validatedEventDetail;
    });
  };

  /**
   * @private
   */
  DataProviderContentHandler.prototype.handleModelAddEvent = function (event) {
    // if listview is busy, queue it for processing later
    if (!this.IsReady()) {
      this._pushToEventQueue({ type: event.type, event: event });
      return;
    }

    this.signalTaskStart('handling model add event'); // signal method task start

    // in card layout mode, the root is an additional element created by ListView, and that will be disassociated by ListView when
    // it is empty, re-append it to the root ul (the superRoot)
    if (this.m_superRoot && this.m_root.childElementCount === 0) {
      this.m_superRoot.appendChild(this.m_root.parentNode);
    }

    var addEvent = event.detail.add;
    var data = addEvent.data;
    var keys = [];
    var refKeys;

    addEvent.keys.forEach(function (key) {
      keys.push(key);
    });

    var keyIter;
    var isBeforeKeys = true;
    if (addEvent.addBeforeKeys !== undefined) {
      keyIter = addEvent.addBeforeKeys;
    } else if (addEvent.afterKeys !== undefined) {
      // afterKeys is deprecated, but continue to support it until we can remove it.
      // forEach can be called on both array and set.
      keyIter = addEvent.afterKeys;
      isBeforeKeys = false;
    }

    if (keyIter) {
      refKeys = [];
      keyIter.forEach(function (key) {
        refKeys.push(key);
      });
    }

    // parentKeys would be undefined for non-hierarchical DataProvider
    var parentKeys = addEvent.parentKeys;

    // indexes could be undefined if not supported by DataProvider
    var indexes = addEvent.indexes;

    // metadata could be undefined if not supported by DataProvider
    var metadata = addEvent.metadata;

    if (
      data != null &&
      keys != null &&
      keys.length > 0 &&
      data.length > 0 &&
      keys.length === data.length &&
      (indexes == null || indexes.length === data.length)
    ) {
      this.addItemsForModelInsert(data, indexes, keys, parentKeys, isBeforeKeys, refKeys, metadata);
      this.signalTaskEnd();

      // get validated data when data is missing in add event detail
    } else if ((data == null || metadata == null) && keys != null && keys.length > 0) {
      this.getValidatedEventDetailPromise = this.getValidatedEventDetail(event.detail.add).then(
        (validatedEventDetail) => {
          if (this.m_widget == null) {
            this.signalTaskEnd();
            return;
          }

          if (validatedEventDetail != null && validatedEventDetail.data != null) {
            data = validatedEventDetail.data;
            metadata = validatedEventDetail.metadata;
            if (
              data.length > 0 &&
              keys.length === data.length &&
              (indexes == null || indexes.length === data.length)
            ) {
              this.addItemsForModelInsert(
                data,
                indexes,
                keys,
                parentKeys,
                isBeforeKeys,
                refKeys,
                metadata
              );
            }
          }
          this.signalTaskEnd();
        }
      );
    } else {
      this.signalTaskEnd();
    }
  };

  DataProviderContentHandler.prototype.afterRenderItemForInsertEvent = function (
    item,
    context,
    isCustomizeItem
  ) {
    var action = 'add';

    this.signalTaskStart('after render item from model insert event'); // signal post rendering processing start. Ends at the end of the method.

    item.setAttribute('data-oj-context', '');

    this.afterRenderItem(item, context, isCustomizeItem);

    // hide it before starting animation to show added item
    var elem = $(item);

    var itemStyleClass = item.className;
    // save it for restore later
    // eslint-disable-next-line no-param-reassign
    item._className = itemStyleClass;
    // eslint-disable-next-line no-param-reassign
    item.className = 'oj-listview-temp-item oj-listview-item-add-remove-transition';

    var isCardLayout = this.isCardLayout();

    // add card style class to wrapper/transforming div
    if (isCardLayout) {
      // eslint-disable-next-line no-param-reassign
      item.className =
        item.className + ' oj-listview-card-animated ' + this.m_widget.getItemStyleClass();
    }
    if (!this.shouldUseGridRole()) {
      elem.children().wrapAll('<div></div>'); // @HTMLUpdateOK
    }

    var content = elem.children().first();
    if (!isCardLayout) {
      content[0].className = itemStyleClass;
    }
    // transfer key and role for FindElementByKey lookup that might happen while animating (navlist)
    content[0].key = item.key;

    // transfer aria-selected for selectable checks that might happen while animating (navlist)
    if (!this.shouldUseGridRole()) {
      content.attr('role', item.getAttribute('role'));
      if (elem[0].hasAttribute('aria-selected')) {
        content.attr('aria-selected', item.getAttribute('aria-selected'));
      }
    } else if (!isCardLayout) {
      var firstElem = content[0].firstElementChild;
      if (firstElem) {
        firstElem.classList.add('oj-listview-cell-element');
      }
    }

    var self = this;
    // initially hide it to avoid blinking
    // eslint-disable-next-line no-param-reassign
    item.style.opacity = 0;

    return new Promise(function (resolve) {
      var busyContext = Context.getContext(item).getBusyContext();
      busyContext.whenReady().then(function () {
        if (self.m_widget == null) {
          resolve(true);
          return;
        }

        // disable tab stops for newly inserted item
        self.m_widget.disableAllTabbableElements(item);

        self.signalTaskStart('kick off animation for insert item'); // signal add animation start. Ends in _handleAddTransitionEnd().

        var currentClassName = item.className;
        // now we can reset opacity, this is to avoid AnimationUtils setting opacity to 0 when it restores element styles
        // eslint-disable-next-line no-param-reassign
        item.style.opacity = '';
        var promise = self.m_widget.StartAnimation(item, action);

        // now show it
        promise.then(function () {
          item.removeAttribute('data-oj-context');
          self._handleAddTransitionEnd(context, item, currentClassName);
          resolve(true);
        });

        self.signalTaskEnd(); // signal post rendering processing end. Started at the beginning of the method.
      });
    });
  };

  DataProviderContentHandler.prototype._handleAddTransitionEnd = function (
    context,
    elem,
    currentClassName
  ) {
    // this could have been called after listview is destroyed
    // or it could have been removed immediately
    if (this.m_widget == null || elem.parentNode == null) {
      this.signalTaskEnd();
      return;
    }

    var beforeTransitionClasses = currentClassName.split(' ');
    var afterTransitionClasses = elem.className.split(' ');

    var hasFocus =
      elem.classList.contains('oj-focus') && elem.classList.contains('oj-focus-highlight');
    var isSelected = elem.classList.contains('oj-selected');
    var isCardAnimated = elem.classList.contains('oj-listview-card-animated');
    // restore class name
    // eslint-disable-next-line no-param-reassign
    elem.className = elem._className;
    if (hasFocus) {
      elem.classList.add('oj-focus');
      elem.classList.add('oj-focus-highlight');
    }
    if (isSelected) {
      elem.classList.add('oj-selected');
    }
    if (isCardAnimated) {
      elem.classList.add('oj-listview-card-animated');
    }

    // add classes that might have been added during custom animation callback
    afterTransitionClasses.forEach(function (cls) {
      if (beforeTransitionClasses.indexOf(cls) === -1) {
        elem.classList.add(cls);
      }
    });

    if (this.shouldUseGridRole()) {
      if (!this.isCardLayout()) {
        var firstChild = elem.firstElementChild;
        // should not be null
        if (firstChild) {
          elem._className.split(' ').forEach(function (cls) {
            firstChild.classList.remove(cls);
          });
          firstChild.classList.add('oj-listview-cell-element');

          var firstElem = firstChild.firstElementChild;
          if (firstElem) {
            firstElem.classList.remove('oj-listview-cell-element');
          }
        }
      }
    } else {
      $(elem).children().children().unwrap();
    }

    this.m_widget.itemInsertComplete(elem, context);

    this.signalTaskEnd(); // signal add animation end. Started in afterRenderItemForInsertEvent();
  };

  DataProviderContentHandler.prototype.handleModelRemoveEvent = function (event) {
    var self = this;
    var keys = event.detail.remove.keys;

    if (keys == null || keys.size === 0) {
      return false;
    }

    // if listview is busy, hold that off until later
    if (!this.IsReady()) {
      this._pushToEventQueue({ type: event.type, event: event });
      return false;
    }

    this.signalTaskStart('handling model remove event'); // signal method task start

    var keysToAdd = event.detail.add != null ? event.detail.add.keys : new Set();
    var keysToRemove = [];

    var promises = [];
    keys.forEach(function (key) {
      var isKeyToAdd = keysToAdd.has(key);
      if (!isKeyToAdd) {
        keysToRemove.push(key);
      }

      var elem = self.FindElementByKey(key);
      if (elem != null) {
        self.signalTaskStart('handling model remove event for item: ' + key); // signal removeItem start
        // mark item to be remove so we won't try to remove this again
        elem.classList.add('oj-listview-item-remove');
        // item remove might have been just added (in insert animation phase)
        if (elem.parentNode.classList.contains('oj-listview-temp-item')) {
          elem = elem.parentNode;
        }
        promises.push(self.removeItem(elem, isKeyToAdd));
        self.signalTaskEnd(); // signal removeItem end
      } else {
        Logger.log('handleModelRemoveEvent: cannot find item with key ' + key);
      }
    });

    // checks whether the removed item is selected, and adjust the value as needed
    if (this.isSelectionEnabled()) {
      // do not remove key if there is a pending insert
      if (keysToRemove.length > 0) {
        var selected = this.m_widget.options.selected;
        var newSelected = selected.delete(keysToRemove);

        // update selection option if it did changed
        if (selected !== newSelected) {
          var selectedItems = [];
          if (newSelected.values) {
            newSelected.values().forEach(function (key) {
              selectedItems.push(self.FindElementByKey(key));
            });
          }
          this.m_widget._setSelectionOption(newSelected, null, selectedItems);
        }
      }

      if (keysToAdd.size > 0) {
        // reset flag so that selection will be validated after insert
        this.m_widget.resetInitialSelectionStateValidated();
      }
    }

    this.handleRemoveItemsPromises(promises);

    this.signalTaskEnd(); // signal method task end

    return true;
  };

  /**
   * Invoke after a set of items are removed
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DataProviderContentHandler.prototype.handleRemoveItemsPromises = function (promises) {};

  /**
   * Remove a single item element
   * @param {jQuery|Element} elem the element to remove
   * @param {boolean} isReinsert if the item to remove is to be re-insert in the same event
   * @protected
   */
  DataProviderContentHandler.prototype.removeItem = function (elem, isReinsert) {
    var self = this;
    var action = 'remove';

    this.signalTaskStart('removing an item'); // signal method task start

    // got to do this before wrapAll since that changes activeElement
    var active = document.activeElement;
    var restoreFocus = elem.contains(active);
    if (restoreFocus) {
      // temporarily shift focus since wrapAll will cause the item to lose focus
      this.m_widget._tempShiftFocus();
    }

    var item = $(elem).get(0);
    var itemStyleClass = item.className;
    $(item)
      .children()
      .wrapAll("<div class='" + itemStyleClass + "'></div>"); // @HTMLUpdateOK
    item.className = 'oj-listview-item-add-remove-transition oj-listview-item-remove';
    item.children[0].key = elem.key;

    this.signalTaskStart('kick off animation to remove an item'); // signal remove item animation start. Ends in handleRemoveTransitionEnd()

    // to workaround removing element caused scrolling by resize listener
    // ideally we should be using ResizeObserver, but that caused issues in qunit
    // tests due to https://bugs.chromium.org/p/chromium/issues/detail?id=809574
    this.m_widget.disableResizeListener();

    var promise = this.m_widget.StartAnimation(item, action);

    // now hide it
    promise.then(
      function () {
        self.handleRemoveTransitionEnd(elem, restoreFocus, isReinsert);
        if (self.m_widget) {
          self.m_widget.enableResizeListener();
        }
      },
      function () {
        if (self.m_widget) {
          self.m_widget.enableResizeListener();
        }
      }
    );

    this.signalTaskEnd(); // signal method task end

    return promise;
  };

  /**
   * Handles when remove item animation transition ends
   * @param {Element|jQuery} elem
   * @param {boolean} restoreFocus
   * @param {boolean} isReinsert
   * @protected
   */
  DataProviderContentHandler.prototype.handleRemoveTransitionEnd = function (
    elem,
    restoreFocus,
    isReinsert
  ) {
    // this could have been called after listview is destroyed
    if (this.m_widget == null) {
      this.signalTaskEnd();
      return;
    }

    var $elem = $(elem);
    var parent = $elem.parent();
    // could happen if there is a reset right after model update, the content has already been cleared out
    if (parent.length === 0) {
      this.signalTaskEnd();
      return;
    }

    // invoke hook before actually removing the item
    var currentItemUpdated = this.m_widget.itemRemoveComplete($elem.get(0), restoreFocus, isReinsert);

    // template engine should have already been loaded
    var templateEngine = this.getTemplateEngine();
    if (templateEngine) {
      templateEngine.clean($elem.get(0), this.m_widget.GetRootElement()[0]);
    }

    $elem.remove();

    // since the items are removed, need to clear cache
    this.m_widget.ClearCache();

    // if it's the last item, show empty text
    if (parent.get(0).childElementCount === 0) {
      this.m_widget.renderComplete(true);
      if (restoreFocus) {
        // make sure focus is restore to no data content
        this.m_widget._focusEmptyContent();
      }
    }

    // ensure something is selected if the removed item is the last selected item
    // need to complete after the DOM element is removed
    if (this.isSelectionEnabled()) {
      this.m_widget.enforceSelectionRequired();
    }

    // this should focus on the current item, set by itemRemoveComplete
    if (currentItemUpdated && restoreFocus && !this.m_root.contains(document.activeElement)) {
      this.m_root.focus();
    }

    this.signalTaskEnd(); // signal remove item animation end. Started in _removeItem()
  };

  /**
   * Model change event handler.  Called when a row has been changed from the underlying data.
   * @param {Object} event the model change event
   * @private
   */
  DataProviderContentHandler.prototype.handleModelChangeEvent = function (event) {
    this.signalTaskStart('handling model update event'); // signal method task start

    var changeEvent = event.detail.update;
    var data = changeEvent.data;
    var keys = [];
    changeEvent.keys.forEach(function (key) {
      keys.push(key);
    });

    // template engine should have already been loaded
    var templateEngine = this.getTemplateEngine();

    var restoreFocusElem;

    var callback = (item, context, isCustomizeItem, restoreFocus) => {
      var isFocusHighlight = false;
      if (restoreFocusElem) {
        isFocusHighlight = restoreFocusElem.classList.contains('oj-focus-previous-highlight');
      }
      this.afterRenderItemForChangeEvent(
        item,
        context,
        isCustomizeItem,
        restoreFocus,
        isFocusHighlight
      );
    };

    var updateData = () => {
      // indexes could be undefined if not supported by DataProvider
      var indexes = changeEvent.indexes;
      for (var i = 0; i < keys.length; i++) {
        this.m_widget.updateSelectedKeyData(keys[i], data[i]);

        var elem = this.FindElementByKey(keys[i]);
        if (elem != null) {
          if (
            restoreFocusElem === undefined &&
            (elem.contains(document.activeElement) || this.m_widget.isInShiftingFocus())
          ) {
            restoreFocusElem = elem;
          }
          this.signalTaskStart('handling model update event for item: ' + keys[i]); // signal replace item start
          var index = indexes == null ? -1 : indexes[i];
          this.replaceItem(
            elem,
            index,
            data[i],
            this.getMetadata(index, keys[i], data[i], elem.parentNode),
            templateEngine,
            callback,
            restoreFocusElem != null
          );
          this.signalTaskEnd(); // signal replace item end

          if (restoreFocusElem != null) {
            restoreFocusElem = null; // doing this will ensure we don't do the check again
          }
        }
      }

      // since the item element will change, need to clear cache
      this.m_widget.ClearCache();
    };

    if (data == null) {
      this.getValidatedEventDetailPromise = this.getValidatedEventDetail(changeEvent).then(
        (validatedEventDetail) => {
          if (this.m_widget == null) {
            this.signalTaskEnd();
            return;
          }

          if (validatedEventDetail != null) {
            data = validatedEventDetail.data;
            updateData();
          }
          this.signalTaskEnd(); // signal method task end
        }
      );
    } else {
      updateData();
      this.signalTaskEnd(); // signal method task end
    }
  };

  /**
   * @private
   */
  DataProviderContentHandler.prototype.afterRenderItemForChangeEvent = function (
    item,
    context,
    isCustomizeItem,
    restoreFocus,
    isFocusHighlight
  ) {
    var self = this;
    var action = 'update';

    this.signalTaskStart('after render item for model change event'); // signal method task start

    // adds all neccessary wai aria role and classes
    this.afterRenderItem(item, context, isCustomizeItem);

    var promise = this.m_widget.StartAnimation(item, action);

    // now hide it
    promise.then(function () {
      self._handleReplaceTransitionEnd(item, restoreFocus);
      if (item && isFocusHighlight) {
        item.classList.add('oj-focus', 'oj-focus-highlight');
      }
    });

    this.signalTaskEnd(); // signal method task end
  };

  /**
   * @private
   */
  DataProviderContentHandler.prototype._handleReplaceTransitionEnd = function (item, restoreFocus) {
    // this could have been called after listview is destroyed
    if (this.m_widget == null) {
      this.signalTaskEnd();
      return;
    }

    $(item).removeClass('oj-listview-item-add-remove-transition');

    if (restoreFocus) {
      this.m_widget.restoreCurrentItemFocus(item);
    }

    this.signalTaskEnd(); // signal replace item animation end. Started in replaceItem() from handleModelChangeEvent() (see base class DataSourceContentHandler)
  };

  DataProviderContentHandler.prototype.createContext = function (
    index,
    data,
    metadata,
    elem,
    itemMetaData
  ) {
    var context = {};

    context.parentElement = elem;
    context.index = index;
    context.data = data;
    context.component = this.m_widget.getWidgetConstructor();
    context.datasource = this.getDataProvider();
    context = this.m_widget._FixRendererContext(context);
    context.metadata = itemMetaData;

    // merge properties from metadata into cell context
    // the properties in metadata would have precedence
    var props = Object.keys(metadata);
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      context[prop] = metadata[prop];
    }

    return context;
  };

  DataProviderContentHandler.prototype.isSelectionEnabled = function () {
    return this.m_widget._isSelectionEnabled();
  };

  DataProviderContentHandler.prototype.isFocusable = function (context) {
    return this.m_widget.getItemFocusable(context);
  };

  DataProviderContentHandler.prototype.isSelectable = function (context) {
    return this.m_widget.getItemSelectable(context);
  };

  DataProviderContentHandler.prototype.isCardLayout = function () {
    return this.m_widget.isCardLayout();
  };

  DataProviderContentHandler.prototype.shouldUseGridRole = function () {
    return this.m_widget.ShouldUseGridRole();
  };

  DataProviderContentHandler.prototype.isAsyncRendering = function () {
    return false;
    //    return this.m_widget.ojContext._IsCustomElement() && this.shouldUseGridRole();
  };

  DataProviderContentHandler.prototype.signalTaskStart = function (description) {
    if (this.m_widget) {
      // check that widget exists (e.g. not destroyed)
      this.m_widget.signalTaskStart('DataSource ContentHandler ' + description);
    }
  };

  DataProviderContentHandler.prototype.signalTaskEnd = function () {
    if (this.m_widget) {
      // check that widget exists (e.g. not destroyed)
      this.m_widget.signalTaskEnd();
    }
  };

  // Skeleton rendering related methods
  /**
   * Whether skeleton is supported (current only in Redwood)
   * @protected
   */
  DataProviderContentHandler.prototype.isSkeletonSupport = function () {
    return this.m_widget.isSkeletonSupport();
  };

  /**
   * Gets the height of the root (UL)
   * @protected
   */
  DataProviderContentHandler.prototype.getRootElementHeight = function () {
    if (isNaN(this.m_height)) {
      this.m_height = this.m_widget.GetRootElement()[0].offsetHeight;
    }
    return this.m_height;
  };

  /**
   * Get the dimension of the default skeleton
   * @protected
   */
  DataProviderContentHandler.prototype.getDefaultSkeletonDimension = function () {
    if (this.m_defaultSkeletonDim == null) {
      var root = this.m_widget.GetRootElement()[0];
      var skeleton = this.createSkeleton(true);
      skeleton.style.display = 'block';
      skeleton.style.visibility = 'hidden';
      root.appendChild(skeleton); // @HTMLUpdateOK
      var dim = { width: skeleton.offsetWidth, height: skeleton.offsetHeight };
      root.removeChild(skeleton);
      if (dim.height > 0 && dim.width > 0) {
        // cache the value only if it's valid
        this.m_defaultSkeletonDim = dim;
      }
      return dim;
    }
    return this.m_defaultSkeletonDim;
  };

  /**
   * Creates a skeleton representing a single item.
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DataProviderContentHandler.prototype.createSkeleton = function (initial) {
    return this.createSkeletonItem();
  };

  /**
   * Creates a skeleton representing a single item.
   * @protected
   */
  DataProviderContentHandler.prototype.createSkeletonItem = function () {
    var item = document.createElement('li');
    item.setAttribute('role', 'presentation');
    var content = document.createElement('div');
    item.className = 'oj-listview-item oj-listview-item-layout';
    if (!this.m_widget._isGridlinesVisible()) {
      item.classList.add('gridline-hidden');
    }
    // oj-listview-skeleton is a marker class to identify this is an item skeleton and not skeleton from other component
    content.className =
      'oj-listview-cell-element oj-listview-skeleton oj-listview-skeleton-line-height oj-animation-skeleton';
    item.appendChild(content); // @HTMLUpdateOK
    return item;
  };

  /**
   * Do the animation of fading out the skeletons and fade in the actual content
   * Returns a Promie that resolves to false to signal not to skip post processing
   * @protected
   */
  DataProviderContentHandler.prototype.animateShowContent = function (
    parentElem,
    content,
    shouldEmptyElem
  ) {
    // first fade out the skeletons, if any
    // eslint-disable-next-line no-unused-vars
    return new Promise(
      function (resolve) {
        var root = this.m_superRoot != null ? this.m_superRoot : this.m_root;
        var skeletonContainer = root.querySelector('.oj-listview-skeleton-container');
        if (skeletonContainer != null) {
          // attach content now so it can begin rendering
          parentElem.appendChild(content); // @HTMLUpdateOK
          var children = Array.from(parentElem.children);

          var promises = [];
          // but hide them for now
          children.forEach(function (child) {
            if (child !== skeletonContainer.parentNode) {
              // eslint-disable-next-line no-param-reassign
              child.style.opacity = 0;
              child.setAttribute('data-oj-context', '');
              var promise = Context.getContext(child).getBusyContext().whenReady();
              promises.push(promise);
            }
          });

          // wait for all content to be ready first before fade in the content
          Promise.all(promises).then(
            function () {
              // component could have been destroyed or skeletonContainer no longer valid due to refresh
              // before promises are resolved
              if (this.m_widget == null || !root.contains(skeletonContainer)) {
                resolve(null);
                return;
              }

              AnimationUtils.fadeOut(skeletonContainer, { duration: '100ms' }).then(
                function () {
                  // component could have been destroyed or skeletonContainer no longer valid due to refresh
                  // before promises are resolved
                  if (this.m_widget == null || !root.contains(skeletonContainer)) {
                    resolve(null);
                    return;
                  }

                  // remove skeleton
                  var skeletonContainerRoot = skeletonContainer.parentNode;
                  if (skeletonContainerRoot.classList.contains('oj-listview-initial-skeletons')) {
                    root.removeChild(skeletonContainerRoot);
                  } else {
                    skeletonContainer
                      .querySelectorAll('.oj-listview-skeleton')
                      .forEach(function (skeleton) {
                        var skeletonItem = skeleton.parentNode;
                        if (skeletonItem && skeletonContainer === skeletonItem.parentNode) {
                          skeletonContainer.removeChild(skeletonItem);
                        }
                      });
                  }

                  // issue, if I just start the fadeIn animation here, the animation will end immediately.
                  // To workaround it, we start the fadeIn animation on a slight delay.  However, because of the
                  // delay, we ended up have to set opacity to 0 to avoid the actual content from briefly showing up.
                  // eslint-disable-next-line no-param-reassign
                  parentElem.style.opacity = 0;
                  children.forEach(function (child) {
                    if (child !== skeletonContainer.parentNode) {
                      // eslint-disable-next-line no-param-reassign
                      child.style.opacity = 1;
                      child.removeAttribute('data-oj-context');
                    }
                  });

                  // use setTimeout instead of requestAnimationFrame since that might not invoke by some browser
                  // if the tab/page is hidden for example
                  setTimeout(function () {
                    AnimationUtils.fadeIn(parentElem, { duration: '150ms', persist: 'all' }).then(
                      function () {
                        // force opacity to be 1 in case if CSS transition did not happen
                        if (parseInt(parentElem.style.opacity, 10) === 0) {
                          // eslint-disable-next-line no-param-reassign
                          parentElem.style.opacity = 1;
                        }
                      }
                    );
                  }, 0);

                  // can resolve immediately instead of waiting for fade in
                  resolve(false);
                }.bind(this)
              );
            }.bind(this)
          );
        } else {
          // skeleton is not supported
          if (shouldEmptyElem) {
            $(parentElem).empty();
          }
          parentElem.appendChild(content); // @HTMLUpdateOK
          // can resolve immediately instead of waiting for fade in
          resolve(false);
        }
      }.bind(this)
    );
  };

  /**
   * Destroy any sparkle artifacts and observer
   * @private
   */
  DataProviderContentHandler.prototype._destroySparkles = function () {
    if (this.m_sparklesObserver) {
      this.m_sparklesObserver.disconnect();
      this.m_sparklesObserver = null;
    }

    if (this.m_sparkles) {
      this.m_sparkles.remove();
      this.m_sparkles = null;
    }
  };

  /**
   * Debounce the callback with specified wait time
   * @private
   */
  DataProviderContentHandler.prototype._debounce = function (callback, wait) {
    let timeout = null;
    return (...args) => {
      const next = () => callback(...args);
      clearTimeout(timeout);
      timeout = setTimeout(next, wait);
    };
  };

  /**
   * Gets the number of suggestions which should be at the beginning of the data set.
   * @param {Object} metadata
   * @protected
   */
  DataProviderContentHandler.prototype.handleSuggestions = function (metadata) {
    var suggestionCount = 0;
    for (var i = 0; i < metadata.length; i++) {
      if (metadata[i].suggestion !== undefined) {
        suggestionCount += 1;
      }
    }
    return suggestionCount;
  };

  /**
   * Returns the first N (count) items
   * @protected
   */
  DataProviderContentHandler.prototype.getItems = function (parentElem, count) {
    var items = parentElem.querySelectorAll('.oj-listview-item-element');
    return Array.prototype.slice.call(items, 0, count);
  };

  /**
   * Render sparkles based on the specified items
   * @param {Element} items
   * @protected
   */
  DataProviderContentHandler.prototype.renderSparkles = function (items) {
    // if not specified, we'll find the existing ones
    if (items === undefined) {
      // eslint-disable-next-line no-param-reassign
      items = this.m_root.querySelectorAll('[data-oj-suggestion]');
    }

    if (items == null || items.length === 0) {
      this._destroySparkles();
      return;
    }

    if (this.m_sparkles == null) {
      var sparkles = document.createElement('li');
      sparkles.className = 'oj-listview-sparkles';
      sparkles.setAttribute('role', 'presentation');
      this.m_sparkles = sparkles;
    }

    if (this.m_sparklesObserver == null) {
      var heightMap = new Map();
      // use debounce to prevent loop limit exceed issue in Chrome
      this.m_sparklesObserver = new ResizeObserver(
        this._debounce((entries) => {
          var heightChanged = false;
          entries.forEach((entry) => {
            var currentHeight = heightMap.get(entry.target);
            if (currentHeight != null && Math.abs(currentHeight - entry.contentRect.height) > 1) {
              heightChanged = true;
            }
            heightMap.set(entry.target, entry.contentRect.height);
          });
          // re-render sparkles if the height of any of the suggested items has changed
          if (heightChanged && this.m_widget) {
            this.renderSparkles();
          }
        }, 100)
      );
    }
    var height = 0;
    for (var i = 0; i < items.length; i++) {
      height += items[i].offsetHeight;
      // mark as sparkle (see mutation)
      // eslint-disable-next-line no-param-reassign
      items[i].dataset.ojSuggestion = 'true';
      this.m_sparklesObserver.unobserve(items[i]);
      this.m_sparklesObserver.observe(items[i]);
      // for rendering border
      if (i === items.length - 1) {
        items[i].classList.add('oj-listview-last-suggestion');
      }
    }
    this.m_sparkles.style.top = this.m_root.offsetTop + 'px';
    this.m_sparkles.style.height = height + 'px';
    this.m_sparkles.style.display = 'block';
    if (this.m_sparkles.parentNode == null) {
      this.m_root.insertBefore(this.m_sparkles, this.m_root.firstElementChild); // @HTMLUpdateOK
    }
  };

  /**
   * Handler for IteratingDataProvider generated content
   * @constructor
   * @extends DataProviderContentHandler
   * @ignore
   */
  var IteratingDataProviderContentHandler = function (widget, root, data) {
    IteratingDataProviderContentHandler.superclass.constructor.call(this, widget, root, data);
  };
  // Subclass from oj.DataSourceContentHandler
  oj.Object.createSubclass(
    IteratingDataProviderContentHandler,
    DataProviderContentHandler,
    'IteratingDataProviderContentHandler'
  );

  /**
   * Initializes the instance.
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.Init = function () {
    IteratingDataProviderContentHandler.superclass.Init.call(this);

    this.m_currentEvents = [];
    this.MAX_SKELETON_COLUMN = 10;
  };

  IteratingDataProviderContentHandler.prototype.IsHierarchical = function () {
    return false;
  };

  /**
   * Determines whether the content handler is in a ready state
   * @return {boolean} true if there's no outstanding fetch or outstanding item in render queue, false otherwise.
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.IsReady = function () {
    return !this.m_fetching && this.m_idleCallback == null;
  };

  /**
   * Determines if there's any item to be rendered from a fetch triggered by insert mutation.
   * @private
   */
  IteratingDataProviderContentHandler.prototype._hasPendingInsertKeys = function () {
    return this.m_insertOutOfRangeKeys != null && this.m_insertOutOfRangeKeys.size > 0;
  };

  /**
   * Destroy the internal DomScroller if there is one.  Called when this ContentHandler is destroyed or on refresh.
   * @private
   */
  IteratingDataProviderContentHandler.prototype._destroyDomScroller = function () {
    if (this.m_domScroller != null) {
      this.m_domScroller.destroy();
      this.m_domScroller = null;
    }

    // remove loading indicator if it still exists:
    this._removeLoadingIndicator();

    if (this.m_widget) {
      this.m_widget.unmergeScrollListener();
    }
  };

  /**
   * Destroy the content handler
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.Destroy = function (completelyDestroy) {
    IteratingDataProviderContentHandler.superclass.Destroy.call(this, completelyDestroy);
    this._removeDataSourceEventListeners();
    this._destroyDomScroller();
    this._cancelIdleCallback();

    this.m_loadingIndicator = null;
    this.m_viewportCheckPromise = null;
    this.m_checkViewportPromise = null;
    this.m_controller = null;
    this.m_lastFetchPromise = null;
  };

  /**
   * @private
   */
  IteratingDataProviderContentHandler.prototype._cancelIdleCallback = function () {
    if (this.m_idleCallback != null) {
      if (!DataCollectionUtils.isRequestIdleCallbackSupported()) {
        window.cancelAnimationFrame(this.m_idleCallback);
      } else {
        window.cancelIdleCallback(this.m_idleCallback);
        // requestAnimationFrame might have been used
        window.cancelAnimationFrame(this.m_idleCallback);
      }
      this.m_idleCallback = null;
    }
  };

  IteratingDataProviderContentHandler.prototype.shouldHandleResize = function () {
    // we only care about the high-water mark scrolling case
    return this._isLoadMoreOnScroll();
  };

  IteratingDataProviderContentHandler.prototype.HandleResize = function (width, height) {
    // we only care about the high-water mark scrolling case, and if height changes
    // or we are animating which could cause resize
    if (!this._isLoadMoreOnScroll() || this.m_animationPromise != null) {
      return;
    }

    var currentWidth = this.m_width;
    var currentHeight = this.m_height;
    this.m_height = height;
    this.m_width = width;
    // reset column count so it can be re-calculated again
    this.m_colCount = undefined;

    // the number of skeletons needs to be adjusted because the number of columns might change
    var isCardLayout = this.isCardLayout();
    if (isCardLayout && this.isSkeletonSupport() && currentWidth !== width) {
      // adjust load more skeletons
      if (this.m_loadingIndicator != null) {
        this._adjustLoadMoreSkeletons(this._getRootElementWidth(true));
      } else {
        var container = this.m_root.querySelector('.oj-listview-skeleton-container');
        if (container != null) {
          // this must be the initial skeleton, just re-render them
          this.renderInitialSkeletons();
        }
      }
    }

    // check viewport if the height increased (or also width change if it's card layout)
    if (height > currentHeight || (isCardLayout && width > currentWidth)) {
      this.checkViewport();
    }
  };

  /**
   * @override
   */
  IteratingDataProviderContentHandler.prototype.notifyShown = function () {
    // might need to re-render sparkles
    if (this.m_widget && this.m_suggestions > 0) {
      this.renderSparkles(this.getItems(this.m_root, this.m_suggestions));
    }

    // we only care about the high-water mark scrolling case
    if (!this._isLoadMoreOnScroll()) {
      return;
    }

    // for loadMoreOnScroll case, we will have to make sure the viewport is satisfied
    if (this.m_root.clientHeight > 0) {
      this.checkViewport();
    }
  };

  /**
   * @override
   */
  IteratingDataProviderContentHandler.prototype.notifyAttached = function () {
    // this should only be populated in high-water mark scrolling case with scroller specified
    if (this.m_domScroller != null) {
      var currentFetchTrigger = this._getFetchTrigger();
      if (currentFetchTrigger != null) {
        // this should force the fetch trigger to recalculate
        var fetchTrigger = this._getFetchTrigger();
        if (currentFetchTrigger !== fetchTrigger) {
          // update fetch trigger
          this.m_domScroller.setFetchTrigger(fetchTrigger);
        }

        // check again whether the viewport is satisfied
        if (this.m_root.clientHeight > 0) {
          this.checkViewport();
        }
      }
    }
  };

  /**
   * Sets aria properties on root
   * @override
   */
  IteratingDataProviderContentHandler.prototype.setRootAriaProperties = function () {
    IteratingDataProviderContentHandler.superclass.setRootAriaProperties.call(this);

    // for high-water mark scrolling, we'll need to add additional wai-aria attribute since not
    // all items are in the DOM
    var self = this;
    if (this.shouldUseGridRole() && this._isLoadMoreOnScroll()) {
      this.getDataProvider()
        .getTotalSize()
        .then(function (size) {
          // self.m_root may have been cleared before the getTotalSize promise resolves
          // (this happened in oj-select-single unit tests)
          if (self.m_root) {
            // if count is unknown, then use max count
            self.m_root.setAttribute('aria-rowcount', size === -1 ? self._getMaxCount() : size);
          }
        });
    }
  };

  /**
   * Unsets aria properties on root
   * @override
   */
  IteratingDataProviderContentHandler.prototype.unsetRootAriaProperties = function () {
    IteratingDataProviderContentHandler.superclass.unsetRootAriaProperties.call(this);
    this.m_root.removeAttribute('aria-rowcount');
  };

  /**
   * Is loadMoreOnScroll
   * @return {boolean} true or false
   * @private
   */
  IteratingDataProviderContentHandler.prototype._isLoadMoreOnScroll = function () {
    return this.m_widget.isLoadMoreOnScroll();
  };

  /**
   * Gets the number of items to return in each fetch
   * @return {number} the fetch size
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getFetchSize = function () {
    return Math.max(0, this.m_widget.options.scrollPolicyOptions.fetchSize);
  };

  /**
   * Gets the scroller element used in DomScroller
   * @return {Element} the scroller element
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getScroller = function () {
    return this.m_widget._getScroller();
  };

  /**
   * Gets the offset top differences between the root and the scroller
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getScrollerOffsetTop = function () {
    if (this._scrollerOffsetTop === undefined) {
      var scroller = this._getScroller();
      if (scroller === this.m_widget.GetRootElement()[0]) {
        this._scrollerOffsetTop = 0;
      } else {
        this._scrollerOffsetTop = DataCollectionUtils.calculateOffsetTop(scroller, this.m_root);
      }
    }
    return this._scrollerOffsetTop;
  };

  /**
   * Gets the distance from maximum scroll position that triggers a fetch
   * @return {number|undefined} the distance in pixel or undefined if no scroller is specified
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getFetchTrigger = function () {
    if (this._fetchTrigger === undefined) {
      this._fetchTrigger = this._getLoadingIndicatorHeight();
    }
    return this._fetchTrigger;
  };

  /**
   * Calculates the height of the loading indicator
   * @return {number} the height of the loading indicator
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getLoadingIndicatorHeight = function () {
    var height;
    if (this.isSkeletonSupport()) {
      var skeletonHeight = this.getDefaultSkeletonDimension().height;
      if (!this.isCardLayout()) {
        // for items, it's 3 x default item skeleton height
        height = IteratingDataProviderContentHandler.LOAD_MORE_SKELETONS_ROW_COUNT * skeletonHeight;
      } else {
        // if load more skeletons are available, use that height instead
        var cardHeight = this._getCardDimension();
        height = cardHeight != null ? cardHeight.height : skeletonHeight;
      }
    } else {
      var container = $(document.createElement('div'));
      container
        .addClass(this.m_widget.getItemStyleClass())
        .css({ visibility: 'hidden', overflow: 'hidden', position: 'absolute' });
      var icon = $(document.createElement('div'));
      icon.addClass('oj-icon oj-listview-loading-icon');
      container.append(icon); // @HTMLUpdateOK

      $(this.m_widget.GetRootElement()).append(container); // @HTMLUpdateOK
      height = container.get(0).offsetHeight;
      container.remove();
    }
    return height;
  };

  /**
   * Adjust the dimension of the default skeleton and the content inside it
   * @private
   */
  IteratingDataProviderContentHandler.prototype._adjustSkeletonCardContent = function (
    item,
    width,
    height
  ) {
    // eslint-disable-next-line no-param-reassign
    item.style.width = width + 'px';
    // eslint-disable-next-line no-param-reassign
    item.style.height = height + 'px';
  };

  /**
   * Creates a skeleton representing a single card.
   * @private
   */
  IteratingDataProviderContentHandler.prototype._createSkeletonCard = function () {
    var card = document.createElement('li');
    card.setAttribute('role', 'presentation');
    var content = document.createElement('div');
    card.className = 'oj-listview-skeleton-card';
    // oj-listview-skeleton is a marker class to identify this is an item skeleton and not skeleton from other component
    content.className =
      'oj-listview-skeleton oj-listview-skeleton-card-content oj-animation-skeleton';

    card.appendChild(content); // @HTMLUpdateOK
    return card;
  };

  /**
   * Creates a skeleton representing a single item/card.
   * @protected
   * @override
   */
  IteratingDataProviderContentHandler.prototype.createSkeleton = function (initial) {
    var defaultSkeleton;
    if (this.isCardLayout()) {
      if (initial) {
        if (this.m_defaultItemSkeleton === undefined) {
          this.m_defaultItemSkeleton = this._createSkeletonCard();
        }
        defaultSkeleton = this.m_defaultItemSkeleton;
      } else {
        if (this.m_defaultLoadMoreSkeleton === undefined) {
          var card = this._createSkeletonCard();
          var dim = this._getCardDimension();
          if (dim) {
            this._adjustSkeletonCardContent(card, dim.width, dim.height);
          }
          this.m_defaultLoadMoreSkeleton = card;
        }
        defaultSkeleton = this.m_defaultLoadMoreSkeleton;
      }
    } else {
      if (this.m_defaultItemSkeleton === undefined) {
        this.m_defaultItemSkeleton = this.createSkeletonItem();
      }
      defaultSkeleton = this.m_defaultItemSkeleton;
    }

    return defaultSkeleton.cloneNode(true);
  };

  /**
   * Gets the width of the browser scrollbar
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getScrollbarWidth = function () {
    if (isNaN(this.m_scrollbarWidth)) {
      var root = this.m_widget.GetRootElement()[0];
      var dummy = document.createElement('div');
      root.appendChild(dummy); // @HTMLUpdateOK
      this.m_scrollbarWidth = Math.max(0, DataCollectionUtils.getDefaultScrollBarWidth(dummy));
      root.removeChild(dummy);
    }
    return this.m_scrollbarWidth;
  };

  /**
   * Gets the width of the root (UL)
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getRootElementWidth = function (excludeScrollbar) {
    if (isNaN(this.m_width)) {
      this.m_width = this.m_widget.GetRootElement()[0].offsetWidth;
    }
    return excludeScrollbar ? this.m_width - this._getScrollbarWidth() : this.m_width;
  };

  /**
   * Displays skeletons for initial fetch.  Invoked by the widget.
   */
  IteratingDataProviderContentHandler.prototype.renderInitialSkeletons = function () {
    // empty out root element before adding skeletons
    if (this.m_superRoot) {
      this.m_root = this.m_superRoot;
      this.m_superRoot = null;
    }
    if (this.m_engine && this.m_root.querySelector('.oj-listview-item-element') != null) {
      // we need to clean the items before emptying them
      this.cleanItems(this.m_engine);
    }
    $(this.m_root).empty();

    // determines how many items needed to fill the viewport
    var height = this.getRootElementHeight();

    // figure out how many item/card are needed to fill the viewport
    // use floor to avoid triggering overflow
    var count = 0;
    var skeletonDimension = this.getDefaultSkeletonDimension();
    if (skeletonDimension.width > 0 && skeletonDimension.height > 0) {
      if (this.isCardLayout()) {
        var margin = this.getMargin();
        var width = this._getRootElementWidth();
        var colCount = Math.max(1, Math.floor(width / (skeletonDimension.width + margin)));
        var rowCount = Math.max(1, Math.floor(height / (skeletonDimension.height + margin)));
        count = rowCount * colCount;
      } else {
        count = Math.max(1, Math.floor(height / skeletonDimension.height));
      }
    }

    var container = document.createElement('li');
    container.setAttribute('role', 'presentation');
    container.classList.add('oj-listview-initial-skeletons');
    var list = document.createElement('ul');
    list.setAttribute('role', 'presentation');
    list.className = this.m_widget.getGroupStyleClass() + ' oj-listview-skeleton-container';
    for (var i = 0; i < count; i++) {
      list.appendChild(this.createSkeleton(true)); // @HTMLUpdateOK
    }
    container.appendChild(list); // @HTMLUpdateOK

    this.m_root.appendChild(container); // @HTMLUpdateOK
  };

  IteratingDataProviderContentHandler.LOAD_MORE_SKELETONS_ROW_COUNT = 3;
  IteratingDataProviderContentHandler.MAX_SKELETON_COLUMN = 10;

  /**
   * Adjust the load more skeleton in the case of component resize/reattach
   * @private
   */
  IteratingDataProviderContentHandler.prototype._adjustLoadMoreSkeletons = function (width, force) {
    var cardDim = this._getCardDimension();
    if (cardDim == null || cardDim.width === 0) {
      return;
    }

    if (!force) {
      var margin = this.getMargin();
      var newColCount = Math.floor(width / (cardDim.width + margin));
      var container = this.m_loadingIndicator.get(0).firstElementChild;
      var currentColCount = container.childElementCount;
      var diff = newColCount - currentColCount;
      if (diff === 0) {
        return;
      }
    }

    // remove all skeletons.  note it's better to just recreate the skeletons instead of maniulate them
    // because we have to make sure the animation is synchrionize
    this.m_loadingIndicator.get(0).parentNode.removeChild(this.m_loadingIndicator.get(0));
    if (this.m_fillerSkeletons != null) {
      this.m_fillerSkeletons.parentNode.removeChild(this.m_fillerSkeletons);
    }
    this.m_loadingIndicator = null;
    this.m_fillerSkeletons = null;
    this.m_defaultLoadMoreSkeleton = undefined;

    // repopulate the skeletons
    this._appendLoadingIndicator();
  };

  /**
   * Calculate what the margin is between cards
   * @private
   */
  IteratingDataProviderContentHandler.prototype.getMargin = function () {
    if (this.m_margin === undefined) {
      var elem = document.createElement('li');
      elem.className = this.m_widget.getItemStyleClass();
      this.m_root.appendChild(elem); // @HTMLUpdateOK
      var style = window.getComputedStyle(elem);
      this.m_margin = parseInt(style.marginRight, 10);
      this.m_root.removeChild(elem);
    }
    return this.m_margin;
  };

  /**
   * Gets the dimension of a card (actual not skeleton)
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getCardDimension = function () {
    if (this.m_cardDim === undefined) {
      var elem = this.m_root.querySelector('.' + this.m_widget.getItemElementStyleClass());
      if (elem) {
        var dim = { width: elem.offsetWidth, height: elem.offsetHeight };
        // don't cache the value if it's invalid
        if (dim.width > 0 && dim.height > 0) {
          this.m_cardDim = dim;
        }
        return dim;
      }
    }
    return this.m_cardDim;
  };

  /**
   * Renders a group of skeleton cards/items
   * @private
   */
  IteratingDataProviderContentHandler.prototype._renderSkeletons = function (count) {
    var container = this.createLoadingIndicator();
    container.setAttribute('role', 'presentation');
    container.classList.add('oj-listview-skeleton-container');
    var group = document.createElement('ul');
    group.setAttribute('role', 'presentation');
    group.className = this.isCardLayout() ? 'oj-listview-skeleton-card-group' : 'oj-listview-group';
    container.appendChild(group); // @HTMLUpdateOK

    for (var i = 0; i < count; i++) {
      group.appendChild(this.createSkeleton(false)); // @HTMLUpdateOK
    }

    return container;
  };

  /**
   * Fills any empty space in the last row with skeleton cards
   * @private
   */
  IteratingDataProviderContentHandler.prototype._fillEmptySpaceWithSkeletons = function () {
    var cardDim = this._getCardDimension();
    if (cardDim == null || cardDim.width === 0) {
      return;
    }

    // first check how many do we need
    var lastItem = this.m_root.lastElementChild;
    var cardWidthWithMargin = cardDim.width + this.getMargin();
    var width = this._getRootElementWidth(true);
    var count = Math.min(
      IteratingDataProviderContentHandler.MAX_SKELETON_COLUMN,
      Math.floor((width - lastItem.offsetLeft - cardWidthWithMargin) / cardWidthWithMargin)
    );
    if (count > 0) {
      var container = this._renderSkeletons(count);
      container.style.visibility = 'hidden';
      this.m_root.appendChild(container); // @HTMLUpdateOK
      this.m_fillerSkeletons = container;
    }
  };

  /**
   * Creates the load more skeletons
   * @private
   */
  IteratingDataProviderContentHandler.prototype._createLoadMoreSkeletons = function () {
    var count;
    if (this.isCardLayout()) {
      var width = this._getRootElementWidth(true);
      var cardDimension = this._getCardDimension();
      var cardWidth =
        cardDimension === undefined ? this.getDefaultSkeletonDimension().width : cardDimension.width;
      count =
        cardWidth === 0
          ? 0
          : Math.min(
              IteratingDataProviderContentHandler.MAX_SKELETON_COLUMN,
              Math.floor(width / (cardWidth + this.getMargin()))
            );
    } else {
      count = IteratingDataProviderContentHandler.LOAD_MORE_SKELETONS_ROW_COUNT;
    }
    return this._renderSkeletons(count);
  };

  /**
   * Creates the load more indicator icon
   * @private
   */
  IteratingDataProviderContentHandler.prototype._createLoadMoreIcon = function () {
    var item = $(this.createLoadingIndicator());
    item
      .uniqueId()
      .attr('role', 'presentation')
      .addClass(this.m_widget.getItemStyleClass())
      .addClass('oj-listview-loading-icon-container');

    var icon = $(document.createElement('div'));
    icon.addClass('oj-icon oj-listview-loading-icon');
    item.append(icon); // @HTMLUpdateOK

    return item.get(0);
  };

  /**
   * @return {Element} the loading indicator element
   */
  IteratingDataProviderContentHandler.prototype.createLoadingIndicator = function () {
    return document.createElement('li');
  };

  /**
   * Add a loading indicator to the list for high-water mark scrolling scenario
   * @private
   */
  IteratingDataProviderContentHandler.prototype._appendLoadingIndicator = function () {
    // check if it's already added
    if (this.m_loadingIndicator != null) {
      return;
    }

    this.m_appendLoadingindicator = true;
    if (
      this.isSkeletonSupport() &&
      this.isCardLayout() &&
      this._getCardDimension() != null &&
      this._getCardDimension().width === 0
    ) {
      var self = this;
      var busyContext = Context.getContext(this.m_root).getBusyContext();
      busyContext.whenReady().then(function () {
        // check if we are still appending
        if (self.m_appendLoadingindicator) {
          self._doAppendLoadingIndicator();
        }
      });
    } else {
      this._doAppendLoadingIndicator();
    }
  };

  IteratingDataProviderContentHandler.prototype._doAppendLoadingIndicator = function () {
    // for the card layout case, we might need to fill empty space in the last row with skeletons
    if (this.isSkeletonSupport() && this.isCardLayout()) {
      this._fillEmptySpaceWithSkeletons();
    }

    var loadMoreIndicator = this.isSkeletonSupport()
      ? this._createLoadMoreSkeletons()
      : this._createLoadMoreIcon();
    loadMoreIndicator.style.visibility = 'hidden';
    this.m_root.appendChild(loadMoreIndicator); // @HTMLUpdateOK

    this.m_loadingIndicator = $(loadMoreIndicator);
    this.m_appendLoadingindicator = false;
  };

  /**
   * Remove the loading indicator
   * @private
   */
  IteratingDataProviderContentHandler.prototype._removeLoadingIndicator = function () {
    if (this.m_loadingIndicator != null) {
      this.m_loadingIndicator.remove();
    }
    this.m_loadingIndicator = null;

    if (this.m_fillerSkeletons != null) {
      this.m_fillerSkeletons.remove();
    }
    this.m_fillerSkeletons = null;
    this.m_appendLoadingindicator = false;
  };

  /**
   * Whether there are more items to fetch when scroll policy loadMoreOnScroll is used.
   * @return {boolean} true if there are more items to fetch, false otherwise.
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.hasMoreToFetch = function () {
    return this.m_loadingIndicator != null;
  };

  IteratingDataProviderContentHandler.prototype.getLoadingIndicator = function () {
    return this.m_loadingIndicator != null ? this.m_loadingIndicator.get(0) : null;
  };

  /**
   * Add required attributes to item after it is rendered by the renderer
   * @param {Element} item the item element to modify
   * @param {Object} context the item context
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.afterRenderItem = function (
    item,
    context,
    isCustomizeItem
  ) {
    IteratingDataProviderContentHandler.superclass.afterRenderItem.call(
      this,
      item,
      context,
      isCustomizeItem
    );

    $(item).addClass(this.m_widget.getItemStyleClass());

    // if item root (<LI>) is not specified, add a default layout class if it's supported
    if (!isCustomizeItem && this.m_widget.getItemLayoutStyleClass) {
      item.classList.add(this.m_widget.getItemLayoutStyleClass());
    }

    if (this.isSelectionEnabled() && this.isSelectable(context)) {
      this.m_widget.getFocusItem($(item)).attr('aria-selected', false);
    }

    // for high-water mark scrolling, we'll need to add additional wai-aria attribute since not
    // all items are in the DOM
    if (this._isLoadMoreOnScroll() && !this.isCardLayout()) {
      $(item).attr('aria-rowindex', context.index + 1);
    }

    this.m_widget.itemRenderComplete(item, context);
  };

  /**
   * Empty out root element and create any necessary artifacts before rendering items
   * @private
   */
  IteratingDataProviderContentHandler.prototype._prepareRootElement = function () {
    // reset root if it was manipulated prior
    if (this.m_superRoot) {
      $(this.m_superRoot).empty();
      this.m_root = this.m_superRoot;
      this.m_superRoot = null;
    } else {
      var skeletonContainer = this.m_root.querySelector('.oj-listview-initial-skeletons');
      if (skeletonContainer == null) {
        // empty the root content if skeleton is not supported or not present.
        // if skeleton is supported, the root will be empty out when animation to hide skeletons is completed.
        $(this.m_root).empty();
      }
    }

    if (this.shouldUseGridRole() && this.isCardLayout()) {
      // in card layout, this is going to be a single row, N columns grid
      // so we'll need to wrap all <li> within a row
      var presentation = document.createElement('li');
      presentation.classList.add('oj-listview-group-container');
      var row = document.createElement('ul');
      presentation.appendChild(row); // @HTMLUpdateOK
      $(presentation).attr('role', 'presentation').css('width', '100%');
      $(row).attr('role', 'row').addClass(this.m_widget.getGroupStyleClass());

      this.m_root.appendChild(presentation); // @HTMLUpdateOK
      this.m_superRoot = this.m_root;
      this.m_root = row;
    }

    // this should not happen, there should not be any load more indicator at this point
    if (this.m_loadingIndicator) {
      Logger.log('prepareRootElement: load more indicator detected');
      this.m_loadingIndicator = null;
    }
  };

  /**
   * @private
   */
  IteratingDataProviderContentHandler.prototype._setFetching = function (fetching) {
    this.m_fetching = fetching;
  };

  /**
   * Whether the key is inside the metadata array
   * @private
   */
  IteratingDataProviderContentHandler.prototype._containsKey = function (key, metadata) {
    for (var i = 0; i < metadata.length; i++) {
      if (oj.KeyUtils.equals(metadata[i].key, key)) {
        return true;
      }
    }
    return false;
  };

  /**
   * @param {boolean} forceFetch
   * @override
   */
  IteratingDataProviderContentHandler.prototype.fetchRows = function (forceFetch) {
    var offset = 0;

    this.signalTaskStart('fetching rows'); // signal method task start

    // checks if we are already fetching cells
    if (this.IsReady()) {
      var self = this;

      this._setFetching(true);

      IteratingDataProviderContentHandler.superclass.fetchRows.call(this, forceFetch);

      // this is the key of the item that we want to scroll to initially
      var scrollToKeyPromise = this.m_widget.getScrollToKey();

      // initiate loading of template engine, note it will not load it unless a template has been specified
      var enginePromise = this.loadTemplateEngine();

      // signal fetch started. Ends in fetchEnd() if successful. Otherwise, ends in the reject block of promise below right after _handleFetchError().
      // Cannot end in _handleFetchError() to be consistent with pagingTableDataSource behavior (see comment above)
      this.signalTaskStart('first fetch');

      // Create a clientId symbol that uniquely identify this consumer so that
      // DataProvider which supports it can optimize resources
      this._clientId = this._clientId || Symbol();

      // Create a controller to support aborting request
      var controller = new AbortController();
      this.m_controller = controller;

      var options = { clientId: this._clientId, signal: this.m_controller.signal };

      // use fetch size if loadMoreOnScroll, otherwise specify -1 to fetch all rows
      options.size = this._isLoadMoreOnScroll() ? this._getFetchSize() : -1;

      this.m_dataProviderAsyncIterator = this.getDataProvider()
        .fetchFirst(options)
        [Symbol.asyncIterator]();
      var promise = this.m_dataProviderAsyncIterator.next();
      this.m_lastFetchPromise = promise;
      self.fetchSize = options.size;

      // new helper function to be called in recursion to fetch all data.
      var helperFunction = function (values, currentMetadata, scrollToKey) {
        var updatedScrollToKey = scrollToKey;
        // checks whether the key is fetched, otherwise we'll continue to fetch
        if (scrollToKey == null || self._containsKey(scrollToKey, currentMetadata)) {
          updatedScrollToKey = null;
        }
        // skip additional fetching if done, or if fetchSize is not -1.
        // if it has getPageCount method, it is a pagingTableDataSource so skip this fetch process.
        if (
          values[0].done ||
          (updatedScrollToKey == null &&
            (self.fetchSize !== -1 || typeof self.getDataProvider().getPageCount === 'function'))
        ) {
          return values;
        }

        var nextPromise = self.m_dataProviderAsyncIterator.next();
        var fetchMoreData = nextPromise.then(
          function (value) {
            // eslint-disable-next-line no-param-reassign
            values[0].done = value.done;
            // eslint-disable-next-line no-param-reassign
            values[0].value.data = values[0].value.data.concat(value.value.data);
            // eslint-disable-next-line no-param-reassign
            values[0].value.metadata = values[0].value.metadata.concat(value.value.metadata);
            return helperFunction(values, value.value.metadata, updatedScrollToKey);
          },
          function (reason) {
            self._handleFetchError(reason, controller.signal.aborted);
            self.signalTaskEnd(); // signal fetch stopped. Started above.
          }
        );

        return fetchMoreData;
      };

      Promise.all([promise, enginePromise, scrollToKeyPromise])
        .then(
          function (values) {
            // check if fetch is outdated and skip if that is the case
            if (self.m_lastFetchPromise !== promise) {
              self.signalTaskEnd();
              return Promise.resolve(null);
            }
            return helperFunction(values, values[0].value.metadata, values[2]);
          },
          function (reason) {
            // check if fetch is outdated and skip if that is the case
            if (self.m_lastFetchPromise !== promise) {
              self.signalTaskEnd(); // signal fetch stopped. Started above.
              return Promise.resolve(null);
            }
            self._handleFetchError(reason, controller.signal.aborted);
            self.signalTaskEnd(); // signal fetch stopped. Started above.
            return Promise.reject(reason);
          }
        )
        .then(
          function (values) {
            // values should never be null
            if (values) {
              // check if content handler has been destroyed already
              if (self.m_widget == null) {
                return;
              }

              var value = values[0];
              var templateEngine = values[1];

              // check if the request was already aborted
              // ignore to prevent collision with results from the other incoming request
              if (DataCollectionUtils.isFetchAborted(value)) {
                // since we won't be calling fetchEnd, we'll need to make sure the readiness stack
                // is updated
                self.signalTaskEnd();
                return;
              }

              var dataProvider = self.getDataProvider();
              if (oj.TableDataSourceAdapter && dataProvider instanceof oj.TableDataSourceAdapter) {
                // paging control loadMore mode, offset will not be 0 after first fetch
                offset = dataProvider.offset;
              }

              if (offset === 0) {
                if (templateEngine) {
                  // clean nodes generated by templateengine before
                  self.cleanItems(templateEngine);
                }

                if (self.isSkeletonSupport()) {
                  // should not wait to call this so that the timer gets clear
                  self.m_widget.hideStatusText();
                }

                // empty content now that we have data
                self._prepareRootElement();
              }

              // append loading indicator at the end as needed
              self._handleFetchedData(value, templateEngine, offset === 0);
            }
          },
          function () {}
        );
      this.signalTaskEnd(); // signal method task end
      return;
    }
    this.signalTaskEnd(); // signal method task end
  };

  IteratingDataProviderContentHandler.prototype._handleFetchError = function (msg, isAbort) {
    // TableDataSource aren't giving me any error message
    Logger.error(msg);

    // if the fetch errors out due to abort, we don't want to do any cleanup
    // as there is another fetch started and we don't want to show no data
    if (this.m_widget && isAbort) {
      return;
    }

    // turn off fetching if there is an error
    this._setFetching(false);

    // listview might have been destroyed before fetch error is handled
    if (this.m_widget == null) {
      Logger.info('handleFetchError: widget has already been destroyed');
      return;
    }

    var skeletons = this.m_root.querySelector('.oj-listview-initial-skeletons');
    if (skeletons != null) {
      skeletons.parentNode.removeChild(skeletons);
    }

    if (this._isLoadMoreOnScroll()) {
      this._removeLoadingIndicator();
    }

    this.m_widget.renderComplete(true);
  };

  /**
   * Renders items when browser is idle (if not support, then fallback to requestAnimationFrame)
   * @private
   */
  IteratingDataProviderContentHandler.prototype._renderItemsWhenIdle = function (
    data,
    keys,
    index,
    templateEngine,
    isMouseWheel,
    metadata
  ) {
    var self = this;

    if (data.length === 0 || keys.length === 0) {
      window.requestAnimationFrame(function () {
        // idle callback might have been cancelled
        if (self.m_idleCallback) {
          self._appendLoadingIndicator();
          self.afterItemsInserted(false, true);
          self.signalTaskEnd(); // started in initial renderItemsWhenIdle call
        }
        self.m_idleCallback = null;
      });
      return;
    }

    function addFragmentOnRequestAnimationFrame(fragment) {
      window.requestAnimationFrame(function () {
        // need the check here since listview might have been destroyed before idleCallback is cancelled
        if (self.m_widget != null) {
          self.m_root.appendChild(fragment); // @HTMLUpdateOK

          // schedule next idle callback until all items from the current fetch are rendered
          self._renderItemsWhenIdle(data, keys, index, templateEngine, isMouseWheel, metadata);
        }
      });
    }

    // IE/legacy Edge/Safari do not support requestIdleCallback, use requestAnimationFrame as fall back
    if (!DataCollectionUtils.isRequestIdleCallbackSupported()) {
      this.m_idleCallback = window.requestAnimationFrame(function () {
        var fragment = document.createDocumentFragment();
        var oneData = data.shift();
        var oneMetadata = metadata != null ? metadata.shift() : null;
        var oneKey = keys.shift();
        self.addItem(
          fragment,
          -1,
          oneData,
          self.getMetadata(index, oneKey, oneData),
          templateEngine,
          null,
          oneMetadata
        );

        // eslint-disable-next-line no-param-reassign
        index += 1;
        addFragmentOnRequestAnimationFrame(fragment);
      });
    } else {
      // Chromium has an issue with requestIdleCallback when mouse wheel is used, see Chrome :
      // https://bugs.chromium.org/p/chromium/issues/detail?id=822269
      var options;
      if (isMouseWheel && oj.AgentUtils.getAgentInfo().engine === oj.AgentUtils.ENGINE.BLINK) {
        options = { timeout: 100 };
      }
      this.m_idleCallback = window.requestIdleCallback(function (idleDeadline) {
        // no need to check for whether listview has been destroyed yet since we cancel the callback on destroy
        var timeRemaining = idleDeadline.timeRemaining();
        var lastTimeTaken = 0;
        var fragment = document.createDocumentFragment();
        while (timeRemaining > lastTimeTaken || idleDeadline.didTimeout) {
          if (data.length === 0 || keys.length === 0) {
            break;
          }

          var oneData = data.shift();
          var oneMetadata = metadata != null ? metadata.shift() : null;
          var oneKey = keys.shift();
          self.addItem(
            fragment,
            -1,
            oneData,
            self.getMetadata(index, oneKey, oneData),
            templateEngine,
            null,
            oneMetadata
          );

          // eslint-disable-next-line no-param-reassign
          index += 1;
          lastTimeTaken = timeRemaining - idleDeadline.timeRemaining();
          timeRemaining = idleDeadline.timeRemaining();
        }

        addFragmentOnRequestAnimationFrame(fragment);
      }, options);
    }
  };

  /**
   * Checks whether content is overflowed
   * @private
   */
  IteratingDataProviderContentHandler.prototype._isOverflow = function () {
    var scroller = this._getScroller();
    if (scroller !== this.m_widget.getListContainer()[0]) {
      return this._isOverflowCheckForCustomScroller();
    }
    return this._isOverflowCheckForDefaultScroller();
  };

  /**
   * Checks overflow in the case where scroller wasn't specified (or is the root element)
   * @private
   */
  IteratingDataProviderContentHandler.prototype._isOverflowCheckForDefaultScroller = function () {
    if (this._isLoadMoreOnScroll()) {
      var scroller = this._getScroller();
      var adjustments = this.m_loadingIndicator == null ? 0 : this._getLoadingIndicatorHeight();
      var diff = scroller.scrollHeight - (scroller.clientHeight + adjustments);
      if (diff === 1 && oj.AgentUtils.getAgentInfo().browser === oj.AgentUtils.BROWSER.EDGE) {
        // hitting Edge , see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/21405284/
        // note this will only happen with non-height-bounded ListView with loadMoreOnScroll, see 
        diff = 0;
      }
      return diff > 0;
    }
    return false;
  };

  /**
   * Checks overflow in the case where scroller was specified
   * @private
   */
  IteratingDataProviderContentHandler.prototype._isOverflowCheckForCustomScroller = function () {
    var scroller = this._getScroller();
    if (scroller !== document.documentElement) {
      var adjustments = this.m_loadingIndicator == null ? 0 : this._getLoadingIndicatorHeight();
      return (
        this.m_root.clientHeight + this._getScrollerOffsetTop() - adjustments > scroller.clientHeight
      );
    }
    // for the case where the root element is not the scroller, the DOMScroller isOverflow check
    // might not work, check whether the last element is in the viewport instead
    return this._isLastItemNotInViewport();
  };

  /**
   * Checks whether the last item is outside of the current viewport
   * @private
   */
  IteratingDataProviderContentHandler.prototype._isLastItemNotInViewport = function () {
    var items = this.m_root.children;
    var styleClass = this.m_widget.getItemElementStyleClass();
    var lastItem;
    for (var i = items.length - 1; i >= 0; i--) {
      if (items[i].classList.contains(styleClass)) {
        lastItem = items[i];
        break;
      }
    }

    if (lastItem) {
      return !DataCollectionUtils.isElementIntersectingScrollerBounds(lastItem, this._getScroller());
    }

    // no items
    return false;
  };

  /**
   * Remove any duplicate items given set of keys.  This is currrently needed because of JET-40746.
   * And we are only doing it during the fetch more triggered by insert mutation event.
   * @private
   */
  IteratingDataProviderContentHandler.prototype._removeDuplicateItems = function (keys) {
    if (this._hasPendingInsertKeys()) {
      var self = this;
      // populate initial values using Map instead of KeyMap because we know the keys are unique to avoid
      // the overhead checking logic
      var elemMap = new Map();
      this.m_root
        .querySelectorAll('.' + this.m_widget.getItemElementStyleClass())
        .forEach(function (elem) {
          if (elem.tagName !== 'LI') {
            // this elem is in the middle of insert animation
            // eslint-disable-next-line no-param-reassign
            elem = elem.parentNode;
          }
          var key = self.GetKey(elem);
          if (key != null) {
            elemMap.set(key, elem);
          }
        });

      var keyMap = new KeyMap(elemMap);
      keys.forEach(function (key) {
        var elem = keyMap.get(key);
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      });
    }
  };

  /**
   * Callback for handling fetch success
   * @param {Array} data the array of data
   * @param {Array} keys the array of keys
   * @param {boolean} doneOrMaxLimitReached true if there are no more data or max count limit reached, false otherwise
   * @param {Object} templateEngine the template engine to process inline template
   * @return {boolean} true if items are rendered when idle, false otherwise
   * @return {Promise} a promise that resolves to true to skip post processing, and false otherwise
   * @private
   */
  IteratingDataProviderContentHandler.prototype._handleFetchSuccess = function (
    data,
    keys,
    doneOrMaxLimitReached,
    templateEngine,
    isMouseWheel,
    metadata,
    isInitialFetch
  ) {
    // listview might have been destroyed before fetch success is handled
    if (this.m_widget == null) {
      return Promise.resolve(true);
    }

    this.m_lastFetchedData = data;

    // remove any existing items with the same key first
    this._removeDuplicateItems(keys);

    var index = this.m_root.querySelectorAll('.' + this.m_widget.getItemElementStyleClass()).length;
    if (
      !isInitialFetch &&
      index > 0 &&
      !doneOrMaxLimitReached &&
      this._isLastItemNotInViewport() &&
      this.m_widget.m_scrollPosition == null
    ) {
      // clone the data since we are going to manipulate the array
      // just in case the DataProvider returns something that references internal structure
      this.signalTaskStart('render items during idle time'); // signal task start
      var metadataCopy = metadata != null ? metadata.slice(0) : null;
      this._renderItemsWhenIdle(
        data.slice(0),
        keys.slice(0),
        index,
        templateEngine,
        isMouseWheel,
        metadataCopy
      );
      return Promise.resolve(true);
    }

    var parent = document.createDocumentFragment();

    for (var i = 0; i < data.length; i++) {
      var row = data[i];
      var key = keys[i];
      var callbackFunc = this._isFetchFromInsert(key)
        ? this.afterRenderItemForInsertEvent.bind(this)
        : null;
      // passing -1 for opt since we know it will be inserted at the end of the parent
      this.addItem(
        parent,
        -1,
        row,
        this.getMetadata(index, key, row),
        templateEngine,
        callbackFunc,
        metadata != null ? metadata[i] : null
      );
      index += 1;
    }

    if (this.m_animateShowContentPromise) {
      return this.m_animateShowContentPromise.then(() => {
        if (this.m_widget == null) {
          this.m_animateShowContentPromise = null;
          return Promise.resolve(null);
        }

        const animateShowContentPromise = this.animateShowContent(
          this.m_root,
          parent,
          isInitialFetch
        );
        return this._getAnimateShowContentPromise(animateShowContentPromise, doneOrMaxLimitReached);
      });
    }

    const animateShowContentPromise = this.animateShowContent(this.m_root, parent, isInitialFetch);
    this.m_animateShowContentPromise = animateShowContentPromise;
    return this._getAnimateShowContentPromise(animateShowContentPromise, doneOrMaxLimitReached);
  };

  /**
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getAnimateShowContentPromise = function (
    animateShowContentPromise,
    doneOrMaxLimitReached
  ) {
    return animateShowContentPromise
      .then((skipPostProcessing) => {
        if (
          doneOrMaxLimitReached &&
          this.m_root &&
          this.m_widget &&
          this.shouldUseGridRole() &&
          this._isLoadMoreOnScroll()
        ) {
          // update aria rowcount once all data is loaded
          const root = this.m_superRoot ? this.m_superRoot : this.m_root;
          root.setAttribute('aria-rowcount', this.getItems(this.m_root).length);
        }
        return skipPostProcessing;
      })
      .finally(() => {
        this.m_animateShowContentPromise = null;
      });
  };

  /**
   * Handles fetched data initiated by the DomScroller (scroll and fetch, or checkViewport)
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.handleDomScrollerFetchedData = function (result) {
    if (result != null) {
      this.signalTaskStart('handle results from DomScroller'); // signal task start

      // remove any loading indicator, which is always added to the end after fetch
      this._removeLoadingIndicator();

      if (this.IsReady()) {
        this.signalTaskStart('dummy task'); // start a dummy task to be paired with the fetchEnd() call below if no new data were fetched.
      }

      // in card layout mode, the root is an additional element created by ListView, and that will be disassociated by ListView when
      // it is empty, re-append it to the root ul (the superRoot)
      if (
        this.isCardLayout() &&
        this.m_superRoot &&
        this.m_root.childElementCount === 0 &&
        this.m_root.parentNode
      ) {
        this.m_superRoot.appendChild(this.m_root.parentNode);
      }

      this._handleFetchedData(result, this.getTemplateEngine(), false); // will call fetchEnd(), which signals a task end. Started either in fetchRows() or in a dummy task not involving data fetch.

      if (result.value && result.value.data) {
        if (!this._hasPendingInsertKeys()) {
          this.m_widget.updateStatusFetchEnd(result.value.data.length);
        }
      } else if (result.maxCountLimit) {
        // value could be null but maxCountLimit set, which could happen if for example
        // maxCount is a multiple of fetchSize
        this._handleScrollerMaxRowCount();
        // since fetchEnd would not be called in this case
        this.signalTaskEnd(); // signal task end
      }

      // reset cached scroll height
      this.m_widget.m_scrollHeight = null;

      this.signalTaskEnd(); // signal task end
    } else {
      // when there's no more data or any other unexpected cases
      this._removeLoadingIndicator();
    }
  };

  /**
   * Register the DomScroller
   * @private
   */
  IteratingDataProviderContentHandler.prototype._registerDomScroller = function () {
    var self = this;

    var options = {
      fetchSize: this._getFetchSize(),
      fetchTrigger: this._getFetchTrigger(),
      maxCount: this._getMaxCount(),
      controller: this.m_controller,
      asyncIterator: this.m_dataProviderAsyncIterator,
      initialRowCount: this.m_root.querySelectorAll('.' + this.m_widget.getItemElementStyleClass())
        .length,
      success: function (result) {
        self.signalTaskEnd(); // for beforeFetch
        if (self.m_widget != null) {
          self.handleDomScrollerFetchedData(result);
        }
        if (self.m_root == null || result.value == null) {
          // in this case fetchEnd will not be called so we will need to clean up for signalTaskStart in scrollFetch callback
          self.signalTaskEnd();
          if (self.m_root != null && self.m_widget != null) {
            // this is called as part of fetchEnd, see 
            self.m_widget.renderComplete(true);
          }
        }
      },
      error: function (reason, isAbort) {
        self.signalTaskEnd(); // for beforeFetch
        self.signalTaskEnd(); // for dummy task
        Logger.error(reason);
        if (!isAbort) {
          self._removeLoadingIndicator();
        }
      },
      localKeyValidator: function (key) {
        if (self.m_widget) {
          return self.m_widget.FindElementByKey(key) != null;
        }
        return false;
      },
      beforeFetch: function (scrollTop, isCheckViewport) {
        self.handleBeforeFetch();
        self.m_viewportCheckPromise = null;
        if (self.m_idleCallback != null) {
          return false;
        }

        if (!isCheckViewport) {
          self.signalTaskStart('starts high-water mark scrolling'); // signal domscroller data fetching. Ends either in success call (m_domScrollerMaxCountFunc) or in error call (self.signalTaskEnd)
          self.m_widget.updateStatusFetchStart();
        }
        return true;
      },
      beforeScroll: this.m_widget.mergeScrollListener()
    };

    var scroller = this._getScroller();
    if (scroller !== this.m_widget.getListContainer()[0]) {
      options.contentElement = this.m_root;
      if (scroller === document.documentElement) {
        options.isOverflow = this._isLastItemNotInViewport.bind(this);
      }
    }
    this.m_domScroller = new DomScroller(scroller, this.getDataProvider(), options);
  };

  IteratingDataProviderContentHandler.prototype.handleBeforeFetch = function () {
    if (this.m_loadingIndicator) {
      this.m_loadingIndicator.get(0).style.visibility = 'visible';
    }

    if (this.m_fillerSkeletons) {
      this.m_fillerSkeletons.style.visibility = 'visible';
    }
  };

  IteratingDataProviderContentHandler.prototype._clearEventQueue = function () {
    if (this.m_eventQueue != null) {
      this.m_eventQueue.length = 0;
    }
  };

  IteratingDataProviderContentHandler.prototype.handleModelMutateEvent = function (event) {
    if (this.m_dataProviderAsyncIterator === undefined) {
      return;
    }
    IteratingDataProviderContentHandler.superclass.handleModelMutateEvent.call(this, event);
  };

  /**
   * Model add event handler.
   * @param {Object} event the model add event
   * @return {boolean} true if the event is processed, false otherwise
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.handleModelAddEvent = function (event) {
    this.m_currentEvents.push(event);
    var processed = IteratingDataProviderContentHandler.superclass.handleModelAddEvent.call(
      this,
      event
    );
    if (!processed) {
      this.m_currentEvents.pop();
    }
    return processed;
  };

  /**
   * Returns the insert before element given the index, or null if insert at the end.
   * @return {Element|null} the reference element.
   * @protected
   * @override
   */
  IteratingDataProviderContentHandler.prototype.GetReferenceNode = function (parentElement, index) {
    var referenceNode = IteratingDataProviderContentHandler.superclass.GetReferenceNode.call(
      this,
      parentElement,
      index
    );
    if (referenceNode == null && this.m_loadingIndicator != null) {
      return this.m_loadingIndicator.get(0);
    }
    return referenceNode;
  };

  /**
   * Gets the maximum index for insert event
   * @private
   */
  IteratingDataProviderContentHandler.prototype._getMaxIndexForInsert = function () {
    var max = Number.MAX_VALUE;
    // temporary solution for SDP
    if (
      DataCollectionUtils.isIterateAfterDoneNotAllowed(this.getDataProvider()) &&
      !this.hasMoreToFetch()
    ) {
      return max;
    }

    // only care about child count if there's more to fetch
    if (this._isLoadMoreOnScroll()) {
      max = $(this.m_root).children('li.' + this.m_widget.getItemElementStyleClass()).length;

      // todo: maybe can combine to a single selector
      var itemsToAdd = this.m_root.querySelectorAll('.oj-listview-temp-item');
      var itemsToAddButRemove = this.m_root.querySelectorAll(
        '.oj-listview-temp-item.oj-listview-item-remove'
      );
      max = Math.max(0, max + itemsToAdd.length - itemsToAddButRemove.length);
    }

    return max;
  };

  /**
   * Do the actual adding items to DOM based on model insert event
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.addItemsForModelInsert = function (
    data,
    indexes,
    keys,
    parentKeys,
    isBeforeKeys,
    refKeys,
    metadata
  ) {
    // index to determine whether it's outside of range of not
    var max = this._getMaxIndexForInsert();

    // template engine should have already been loaded
    var templateEngine = this.getTemplateEngine();

    var promises = [];
    for (var i = 0; i < data.length; i++) {
      // ignore if the item with key already exists
      if (this.FindElementByKey(keys[i]) != null) {
        // eslint-disable-next-line no-continue
        continue;
      }

      this.signalTaskStart('handling model add event for item: ' + keys[i]); // signal add item start
      // indexes takes precedence
      var index;
      if (indexes != null) {
        index = indexes[i];
      } else {
        index = this.getIndex(refKeys, i);
        if (index > -1) {
          index = isBeforeKeys ? index : index + 1;
        } else if (this._isLoadMoreOnScroll()) {
          // if append to the end
          if (
            !DataCollectionUtils.isIterateAfterDoneNotAllowed(this.getDataProvider()) ||
            this.hasMoreToFetch()
          ) {
            index = max;
          }
        }
      }
      // we skip any insert/append outside of range if there's still more to fetch
      if (index < max) {
        var promise = this.addItem(
          this.m_root,
          index,
          data[i],
          this.getMetadata(index, keys[i], data[i]),
          templateEngine,
          this.afterRenderItemForInsertEvent.bind(this),
          metadata != null ? metadata[i] : null
        );
        if (promise) {
          promises.push(promise);
        }
        max += 1;
      } else {
        if (this.m_insertOutOfRangeKeys == null) {
          if (this.m_dataProvider.createOptimizedKeySet) {
            this.m_insertOutOfRangeKeys = this.m_dataProvider.createOptimizedKeySet();
          } else {
            this.m_insertOutOfRangeKeys = new KeySet();
          }
        }
        this.m_insertOutOfRangeKeys.add(keys[i]);
      }
      this.signalTaskEnd(); // signal add item end
    }

    if (promises.length < data.length) {
      // there are some items out of range, we'll need to ensure DomScroller is active
      // so that we can get them from checkViewport
      if (this.m_domScroller == null) {
        if (this._isLoadMoreOnScroll()) {
          this._registerDomScroller();
        }
      } else {
        // make sure it is active
        this.m_domScroller.setAsyncIterator(this.m_dataProviderAsyncIterator);
      }
    }

    if (promises.length === 0) {
      // every item to be insert are out of range, but we still need to checkViewport
      this.m_currentEvents.pop();
      if (this.m_currentEvents.length === 0) {
        this.afterItemsInserted(true, true);
      }
    } else {
      var self = this;
      Promise.all(promises).then(function () {
        if (self.m_widget) {
          self.m_currentEvents.pop();
          if (self.m_currentEvents.length === 0) {
            self.afterItemsInserted(true, true);
          }
        }
      });
    }
  };

  /**
   * Checks whether the item with the key is fetched triggered by insert event
   * @private
   */
  IteratingDataProviderContentHandler.prototype._isFetchFromInsert = function (key) {
    if (this.m_insertOutOfRangeKeys == null) {
      return false;
    }
    return this.m_insertOutOfRangeKeys.has(key);
  };

  /**
   * Model remove event handler.
   * @param {Object} event the model remove event
   * @return {boolean} true if the event is processed, false otherwise
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.handleModelRemoveEvent = function (event) {
    this.m_currentEvents.push(event);

    var processed = IteratingDataProviderContentHandler.superclass.handleModelRemoveEvent.call(
      this,
      event
    );
    if (processed) {
      var remainingItem = this.m_root.querySelector('li.' + this.m_widget.getItemElementStyleClass());
      if (remainingItem == null && this.m_loadingIndicator) {
        this.m_loadingIndicator.get(0).style.display = 'none';
      }
    } else {
      this.m_currentEvents.pop();
    }
    return processed;
  };

  IteratingDataProviderContentHandler.prototype.handleRemoveItemsPromises = function (promises) {
    if (promises.length === 0) {
      // all items to be remove are out of range
      this.m_currentEvents.pop();
    } else {
      var self = this;
      // check viewport after multiple items are removed
      Promise.all(promises).then(function () {
        if (self.m_widget) {
          self.m_currentEvents.pop();
          if (self.m_currentEvents.length === 0) {
            self.checkViewport();
          }
        }
      });
    }
  };

  /**
   * Model refresh event handler.  Called when all rows has been removed from the underlying data.
   * @param {Object} event the model refresh event
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.handleModelRefreshEvent = function () {
    if (this.m_root == null) {
      return;
    }

    // any outstanding idle-time rendering should immediately be stopped
    this._cancelIdleCallback();

    // if listview is busy, abort the current request so that we can start a new one
    if (!this.IsReady() && this.m_controller) {
      const wrapper = this.m_widget.OuterWrapper ?? this.m_widget.ojContext.element[0];
      this.m_controller.abort(DataCollectionUtils.getAbortReason(wrapper));
      this._setFetching(false);
    }

    this.signalTaskStart('handling model reset event'); // signal method task start

    // since we are refetching everything, we should just clear out any outstanding model events
    this._clearEventQueue();

    // empty everything (later) and clear cache (including KeyMap)
    this.m_widget.ClearCache(true);

    // it will be recreated with a new asyncIterator
    this._destroyDomScroller();

    // handle scrollPositionPolicy on refresh
    this.m_widget.adjustScrollPositionValueOnFetch();

    // reset focus if needed
    this.m_widget.resetFocusBeforeRefresh();

    // fetch data
    this.fetchRows(true);

    this.signalTaskEnd(); // signal method task end
  };

  /**
   * Handle fetched data, either from a fetch call or from a sync event
   * @param {Object} dataObj the fetched data object
   * @private
   */
  IteratingDataProviderContentHandler.prototype._handleFetchedData = function (
    dataObj,
    templateEngine,
    isInitialFetch
  ) {
    // this could happen if destroy comes before fetch completes (note a refresh also causes destroy)
    if (this.m_root == null || dataObj.value == null) {
      // cleanup DomScroller if max count has been reached as no more fetching will happen
      if (dataObj.maxCountLimit) {
        this._destroyDomScroller();
      }
      return;
    }

    var data = dataObj.value.data;
    var metadata = dataObj.value.metadata;
    var suggestions = 0;
    if (isInitialFetch && !this.isCardLayout()) {
      suggestions = this.handleSuggestions(metadata);
    }
    var keys = metadata.map(function (value) {
      return value.key;
    });

    if (data.length === keys.length) {
      this._handleFetchSuccess(
        data,
        keys,
        dataObj.done || dataObj.maxCountLimit,
        templateEngine,
        dataObj.isMouseWheel,
        metadata,
        isInitialFetch
      ).then(
        function (skipPostProcessing) {
          // component could have been destroyed or another refresh already happened
          if (
            this.m_widget == null ||
            skipPostProcessing === null ||
            this.m_lastFetchedData !== data
          ) {
            if (this.m_widget) {
              // for refresh case, we'll still need to reduce readiness stack, which is usually done in fetchEnd
              this.m_widget.signalTaskEnd();
            }
            Logger.info(
              'handleFetchedData: exit due to either component destroyed or another refresh underway: ' +
                (this.m_widget == null)
            );
            return;
          }

          var nothingInserted = keys != null && keys.length === 0;

          if (this._isLoadMoreOnScroll()) {
            if (!dataObj.done) {
              // if number of items returned is zero but result indicates it's not done
              // log it
              if (nothingInserted) {
                Logger.info('handleFetchedData: zero data returned while done flag is false');
              }

              // always append the loading indicator at the end except the case when max limit has been reached
              if (!skipPostProcessing && !dataObj.maxCountLimit) {
                if (this.m_domScroller == null) {
                  this._registerDomScroller();

                  // in Safari, handleResize would not get invoked with the initial width/height
                  // call getRootElementHeight method to trigger height caching
                  this.getRootElementHeight();
                }

                if (!nothingInserted || this.m_domScroller.isOverflow()) {
                  this._appendLoadingIndicator();
                }
              } else if (dataObj.maxCountLimit) {
                // max count reached, DomScroller will stop fetching
                this._destroyDomScroller();
              }
            } else if (this.m_domScroller) {
              // no more data, but DomScroller still active from before
              this._destroyDomScroller();
            }
          }

          if (isInitialFetch) {
            this.m_suggestions = suggestions;
            if (suggestions > 0) {
              // wait until items completely render otherwise we won't get an accurate height
              var busyContext = Context.getContext(this.m_root).getBusyContext();
              busyContext.whenReady().then(() => {
                // if listview not destroyed and suggetion hasn't change while waiting for render
                // which could happen if there is a refresh event before sparkles are rendered
                if (this.m_widget && this.m_suggestions === suggestions) {
                  this.renderSparkles(this.getItems(this.m_root, suggestions));
                }
              });
            }
          }

          if (dataObj.maxCountLimit) {
            this._handleScrollerMaxRowCount();
          }

          this.fetchEnd(skipPostProcessing, !nothingInserted || !dataObj.done, isInitialFetch);

          // disable tabbable elements once the fetched items are rendered
          if (!nothingInserted) {
            this.disableAllTabbableElements();
          }
        }.bind(this)
      );
    }
  };

  IteratingDataProviderContentHandler.prototype.disableAllTabbableElements = function () {
    var lastItemIndex = this.m_root.childElementCount;
    if (
      this.shouldUseGridRole() &&
      this.m_root.lastElementChild &&
      this.m_root.lastElementChild.getAttribute('role') === 'presentation'
    ) {
      lastItemIndex -= 1;
    }

    var self = this;
    var busyContext = Context.getContext(this.m_root).getBusyContext();
    busyContext.whenReady().then(function () {
      if (self.m_root != null) {
        var children = self.m_root.children;
        for (var i = 0; i < lastItemIndex; i++) {
          if (children[i]) {
            self.m_widget.disableAllTabbableElements(children[i]);
          }
        }
      }
    });
  };

  /**
   * Do any logic after items are inserted into the DOM
   * @private
   */
  IteratingDataProviderContentHandler.prototype.afterItemsInserted = function (
    checkViewport,
    skipSyncScrollPosition
  ) {
    if (this.m_widget) {
      var self = this;
      var _animationPromise = this.m_widget.renderComplete(skipSyncScrollPosition);
      if (_animationPromise) {
        _animationPromise.then(function () {
          self.m_animationPromise = null;
        });
      }
      this.m_animationPromise = _animationPromise;

      // process any outstanding events
      this._processEventQueue();

      // check viewport
      var promise;
      if (checkViewport) {
        if (this.m_widget.ojContext._IsCustomElement()) {
          // for custom element, content could render async so we'll need to wait for content to render completely
          // so that we have the correct height before checking viewport.  For example, we want to avoid excessive
          // fetch if the height expanded which causes overflow.  On the other hand, if the height contracted then
          // we could potentially have an underflow that requires an additional fetch.
          var rootElement = self.m_superRoot != null ? self.m_superRoot : self.m_root;
          var busyContext = Context.getContext(rootElement).getBusyContext();
          var viewportCheckPromise = busyContext.whenReady();
          viewportCheckPromise.then(function () {
            if (self.m_widget != null) {
              // card dimension could be not available until now where the card is fully rendered
              // adjust loadmore skeletons that were previously rendered
              if (
                self.isCardLayout() &&
                self.m_cardDim === undefined &&
                self.m_loadingIndicator != null
              ) {
                self._adjustLoadMoreSkeletons(self._getRootElementWidth(true), true);
              }

              if (self.m_viewportCheckPromise != null) {
                promise = self.checkViewport(_animationPromise);
                if (promise == null) {
                  self._clearInsertOutOfRangeKeys();
                }
              }
            }
          });
          self.m_viewportCheckPromise = viewportCheckPromise;
        } else {
          // for widget, we'll need to keep the old behavior
          promise = this.checkViewport();
          if (promise == null) {
            this._clearInsertOutOfRangeKeys();
          }
        }
      }
    }
  };

  /**
   * Do any logic needed after results from fetch are processed
   * @private
   */
  IteratingDataProviderContentHandler.prototype.fetchEnd = function (
    skipPostProcessing,
    checkViewport,
    isInitialFetch
  ) {
    // fetch is done
    this._setFetching(false);

    if (!skipPostProcessing) {
      this.afterItemsInserted(checkViewport, !isInitialFetch);
    }

    // signal fetch end. Started in either fetchRows() or started as a dummy task whenever this
    // method is called without fetching rows first (e.g. see m_domScrollerMaxCountFunc).
    this.signalTaskEnd();
  };

  /**
   * Checks the viewport for card layout case
   * @private
   */
  IteratingDataProviderContentHandler.prototype._checkHorizontalViewport = function () {
    if (this.isCardLayout()) {
      var items = this.m_root.children;
      var styleClass = this.m_widget.getItemElementStyleClass();
      var lastItem;
      for (var i = items.length - 1; i >= 0; i--) {
        if (items[i].classList.contains(styleClass)) {
          lastItem = items[i];
          break;
        }
      }

      if (lastItem) {
        var scroller = this._getScroller();
        var scrollerHeight =
          scroller === this.m_root ? this.getRootElementHeight() : scroller.clientHeight;
        if (scroller === document.documentElement) {
          var rect = lastItem.getBoundingClientRect();
          if (rect.top <= scrollerHeight && rect.top + rect.height >= 0) {
            this.handleBeforeFetch();
            return this.m_domScroller._fetchMoreRows();
          }
        } else {
          var scrollTop = scroller.scrollTop;
          var offsetTop = lastItem.offsetTop;
          var scrollerOffsetTop = scroller === this.m_root ? 0 : this._getScrollerOffsetTop();
          if (offsetTop > scrollTop && offsetTop < scrollTop + scrollerHeight - scrollerOffsetTop) {
            this.handleBeforeFetch();
            return this.m_domScroller._fetchMoreRows();
          }
        }
      }
    }
    return null;
  };

  /**
   * @private
   */
  IteratingDataProviderContentHandler.prototype._clearInsertOutOfRangeKeys = function () {
    if (this.m_insertOutOfRangeKeys != null) {
      this.m_insertOutOfRangeKeys.clear();
    }
  };

  /**
   * Checks the viewport to see if additional fetch is needed
   * @protected
   */
  IteratingDataProviderContentHandler.prototype.checkViewport = function (animationPromise) {
    var self = this;

    // if we are already in the process of fetch due to checkViewport, bail
    if (this.m_checkViewportPromise) {
      return null;
    }

    this.signalTaskStart('checking viewport'); // signal method task start

    // if loadMoreOnScroll then check if we have underflow and do a fetch if we do
    var fetchPromise;
    if (this.m_domScroller != null && this.IsReady()) {
      fetchPromise = this.m_domScroller.checkViewport();
      if (fetchPromise != null) {
        this.signalTaskStart('got promise from checking viewport'); // signal fetchPromise started. Ends in promise resolution below
        fetchPromise.then(function (result) {
          // make sure listview is not destroyed yet
          if (self.m_widget != null) {
            if (result != null) {
              self.m_checkViewportPromise = null;
              self.handleDomScrollerFetchedData(result);
            } else {
              var _horizontalViewportCheck = function () {
                fetchPromise = self._checkHorizontalViewport();
                if (fetchPromise != null) {
                  self.signalTaskStart('got promise from checking horizontal viewport');
                  fetchPromise.then(function (moreResult) {
                    self.m_checkViewportPromise = null;
                    if (self.m_widget != null && moreResult != null) {
                      self.handleDomScrollerFetchedData(moreResult);
                    }
                    self.signalTaskEnd();
                  }, null);
                } else {
                  self.m_checkViewportPromise = null;
                }
              };

              if (animationPromise) {
                self.signalTaskStart('wait for animation to complete');
                animationPromise.then(function () {
                  self.signalTaskEnd();
                  if (self.m_widget != null && self.m_domScroller != null) {
                    _horizontalViewportCheck();
                  }
                });
              } else {
                _horizontalViewportCheck();
              }
            }
            self.signalTaskEnd(); // signal checkViewport task end. Started above before fetchPromise resolves here;
          }

          // clear all fetch by insert keys
          self._clearInsertOutOfRangeKeys();
        }, null);
      } else {
        this._clearInsertOutOfRangeKeys();
      }

      this.m_checkViewportPromise = fetchPromise;
    }

    this.signalTaskEnd(); // signal method task end

    return fetchPromise;
  };

  exports.DataProviderContentHandler = DataProviderContentHandler;
  exports.IteratingDataProviderContentHandler = IteratingDataProviderContentHandler;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojindexer',['exports', 'ojs/ojcore-base', 'ojs/ojtranslation', 'jquery', 'hammerjs', 'ojs/ojcontext', 'ojs/ojjquery-hammer', 'ojs/ojcomponentcore', 'ojs/ojdomutils'], function (exports, oj, Translations, $, Hammer, Context, ojjqueryHammer, ojcomponentcore, DomUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  (function () {
var __oj_indexer_metadata = 
{
  "properties": {
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "deprecated",
              "since": "14.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaDisabledLabel": {
          "type": "string"
        },
        "ariaInBetweenText": {
          "type": "string"
        },
        "ariaKeyboardInstructionText": {
          "type": "string"
        },
        "ariaOthersLabel": {
          "type": "string"
        },
        "ariaTouchInstructionText": {
          "type": "string"
        },
        "indexerCharacters": {
          "type": "string"
        },
        "indexerOthers": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_indexer_metadata.extension._WIDGET_NAME = 'ojIndexer';
    __oj_indexer_metadata.extension._INNER_ELEM = 'ul';
    __oj_indexer_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-label', 'aria-labelledby'];
    oj.CustomElementBridge.register('oj-indexer', { metadata: __oj_indexer_metadata });
  })();

  /**
   * The interface for oj.IndexerModel which should be implemented by all object instances
   * bound to the data parameter for ojIndexer.
   * @export
   * @since 1.2
   * @interface oj.IndexerModel
   */

  const IndexerModel = function () {};
  oj._registerLegacyNamespaceProp('IndexerModel', IndexerModel);

  // without the at-name tag, JSDoc tool prepends a "." to the field name for some reason, which messes up the QuickNav.
  /**
   * Constant for the section that represents all non-letters including numbers and symbols.
   * @export
   * @expose
   * @type {Object}
   * @property {string} id The id of this section
   * @property {string} label The label of this section
   * @name SECTION_OTHERS
   * @memberof oj.IndexerModel
   */
  IndexerModel.SECTION_OTHERS = {
    id: '__others__',
    label: Translations.getTranslatedString('oj-ojIndexer.indexerOthers')
  };

  /**
   * @typedef {string|Object} oj.IndexerModel.Section
   * @ojsignature {target:"Type", value:"string|{label: string}"}
   */

  /**
   * Make a section current in the Indexer.  The implementation should scroll the associated ListView so that the section becomes visible.
   * @param {string|Object} section the current section
   * @return {Promise.<string>|Promise.<Object>} a Promise which when resolved will return the section that the associated ListView actually scrolls to.
   *                   For example, the implementation could choose to scroll to the next available section in ListView if no data
   *                   exists for that section.
   * @method
   * @name setSection
   * @memberof oj.IndexerModel
   * @instance
   * @ojsignature {target: "Type",
   *               value: "(section: oj.IndexerModel.Section): Promise<oj.IndexerModel.Section>"}
   */

  /**
   * Returns an array of objects each representing a section in the associated ListView.  The section object could either be
   * a String or an object containing at least a 'label' field.  For example, the implementation may return an array of Strings
   * representing letters of the alphabet. Or it may return an array of objects each containing a 'label' field for the section
   * titles.
   * @return {Array.<string>|Array.<Object>} an array of all indexable sections
   * @method
   * @name getIndexableSections
   * @memberof oj.IndexerModel
   * @instance
   * @ojsignature {target: "Type", value: "(): oj.IndexerModel.Section[]"}
   */

  /**
   * Returns an array of objects each representing a section that does not have a corresponding section in the associated ListView.
   * It must be a subset of the return value of <code>getIndexableSections</code>.  Return null or undefined if there's nothing missing.
   * @return {Array.<string>|Array.<Object>} an array of missing sections
   * @method
   * @name getMissingSections
   * @memberof oj.IndexerModel
   * @instance
   * @ojsignature {target: "Type", value: "(): oj.IndexerModel.Section[]"}
   */

  (function () {
    // constants
    const _DATA_INCLUDES = 'data-includes';
    const _DATA_RANGE = 'data-range';
    const _DATA_OTHERS = 'data-others';

    /*!
     * JET Indexer @VERSION
     *
     *
     * Depends:
     *  jquery.ui.widget.js
     */

    /**
     * @ojcomponent oj.ojIndexer
     * @augments oj.baseComponent
     * @since 1.2.0
     *
     * @ojshortdesc An indexer displays a list of sections that corresponds to group headers of a list.
     * @ojrole slider
     *
     * @ojoracleicon 'oj-ux-ico-indexer'
     * @ojuxspecs ['indexer']
     *
     * @classdesc
     * <h3 id="indexerOverview-section">
     *   JET Indexer Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#indexerOverview-section"></a>
     * </h3>
     * <p>Description: The JET Indexer is usually associated with a scrollable JET ListView.  It provides a list of sections that
     *                 corresponds to group headers in ListView.  When a section is selected the corresponding group header will be
     *                 scroll to the top of the ListView.
     * </p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-indexer
     *   aria-controls='listview1'
     *   data='{{data}}'>
     * &lt;/oj-indexer>
     * </code>
     * </pre>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The JET Indexer is accessible - it sets and maintains the appropriate aria- attributes,
     * including <code class="prettyprint">aria-valuenow</code>, <code class="prettyprint">aria-valuemax</code>,
     * <code class="prettyprint">aria-valuemin</code> and <code class="prettyprint">aria-orientation</code>.
     * <p>
     * Application developer should associate a ListView with the Indexer by specifying the id of the ListView in the aria-controls attribute in the Indexer.
     * </p>
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------
    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Characters</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Selects the character in the indexer, which scrolls to the corresponding group header in the associated ListView.
     *           When tap on the ellipsis character, the character in between will be selected.</td>
     *     </tr>
     *     <tr>
     *       <td>Characters</td>
     *       <td><kbd>Pan</kbd></td>
     *       <td>Selects the character in the indexer, which scrolls to the corresponding group header in the associated ListView.
     *           When pan up and down the ellipsis character, the indexer will select the range of characters represented by the ellipsis.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojIndexer
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "3" nowrap>Section</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus to the section below.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus to the section above.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Selects the current section.  No op if the section is already selected.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojIndexer
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the sections within the Indexer.  See the <a href="#getNodeBySubId">getNodeBySubId</a>
     * method for details.</p>
     *
     * @ojsubid oj-indexer-section
     * @memberof oj.ojIndexer
     *
     * @example <caption>Get the node that represents the specified prefix 'A' in the indexer:</caption>
     * var node = myIndexer.getNodeBySubId({'subId': 'oj-indexer-section', 'section': 'A'});
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------
    /**
     * @ojstylevariableset oj-indexer-css-set1
     * @ojstylevariable oj-indexer-text-color {description: "Indexer text color", formats: ["color"], help: "#css-variables"}
     * @ojstylevariable oj-indexer-font-size {description: "Indexer font size", formats: ["length"], help: "#css-variables"}
     * @memberof oj.ojIndexer
     */
    // --------------------------------------------------- oj.ojIndexer Styling End -----------------------------------------------------------

    oj.__registerWidget('oj.ojIndexer', $.oj.baseComponent, {
      defaultElement: '<ul>',
      version: '1.2',
      widgetEventPrefix: 'oj',

      options: {
        /**
         * The data model for the Indexer which must be a oj.IndexerModel.  Currently the <a href="IndexerModelTreeDataProvider.html">IndexerModelTreeDataProvider</a>
         * is available that applications can use as the data for both ListView and the Indexer.  If not specified, then an empty indexer is rendered.
         *
         * @ojshortdesc The data provider for the Indexer.
         * @expose
         * @memberof! oj.ojIndexer
         * @instance
         * @type {Object}
         * @ojsignature {target:"Type", value:"IndexerModel", jsdocOverride:true}
         * @default null
         * @ojwebelementstatus {type: "deprecated", since: "14.0.0",
         *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
         *
         * @example <caption>Initialize the Indexer with an IndexModel:</caption>
         * &lt;oj-indexer data='{{myIndexerModel}}'>&lt;/oj-indexer>
         *
         * @example <caption>Get or set the <code class="prettyprint">data</code> property after initialization:</caption>
         * // getter
         * var dataValue = myIndexer.data;
         *
         * // setter
         * myIndexer.data = myIndexerModel;
         */
        data: null
      },

      /**
       * Creates the indexer
       * @override
       * @memberof! oj.ojIndexer
       * @protected
       */
      _ComponentCreate: function () {
        this._super();
        this._setup();
      },

      /**
       * Initialize the indexer after creation
       * @protected
       * @override
       * @memberof! oj.ojIndexer
       */
      _AfterCreate: function () {
        this._super();
        this._createIndexerContent();
        this._setAriaProperties();
        this._createInstructionText();
      },

      /**
       * Destroy the indexer
       * @memberof! oj.ojIndexer
       * @override
       * @private
       */
      _destroy: function () {
        this._super();

        var container = this._getIndexerContainer();

        this._unregisterResizeListener(container);
        this._unregisterTouchHandler(container);
        this._unsetAriaProperties();
        this.element.removeClass('oj-component-initnode');

        DomUtils.unwrap(this.element, container);
      },

      /**
       * Sets a single option
       * @memberof! oj.ojIndexer
       * @override
       * @private
       */
      // eslint-disable-next-line no-unused-vars
      _setOption: function (key, value) {
        this._superApply(arguments);
        if (key === 'data') {
          this.refresh();
        }
      },

      /**
       * Sets up resources needed by indexer
       * @memberof! oj.ojIndexer
       * @instance
       * @override
       * @protected
       */
      _SetupResources: function () {
        this._super();

        // register a resize listener and swipe handler
        var container = this._getIndexerContainer()[0];
        this._registerResizeListener(container);
        this._registerTouchHandler(container);
      },

      /**
       * Release resources held by indexer
       * @memberof! oj.ojIndexer
       * @instance
       * @override
       * @protected
       */
      _ReleaseResources: function () {
        this._super();

        var container = this._getIndexerContainer()[0];
        this._unregisterResizeListener(container);
        this._unregisterTouchHandler(container);

        // if there's outstanding busy state, release it now
        this._resolveBusyState();
      },

      /**
       * @private
       */
      _resolveBusyState: function () {
        if (this.busyStateResolve) {
          this.busyStateResolve(null);
          this.busyStateResolve = null;
        }
      },

      /**
       * Returns a jQuery object containing the root dom element of the indexer
       * @ignore
       * @expose
       * @override
       * @memberof! oj.ojIndexer
       * @instance
       * @return {jQuery} the root DOM element of the indexer
       */
      widget: function () {
        return this._getIndexerContainer();
      },

      /**
       * Redraw the entire indexer after having made some external modification.
       *
       * <p>This method does not accept any arguments.
       *
       * @ojshortdesc Redraw the entire indexer.
       * @expose
       * @memberof! oj.ojIndexer
       * @instance
       * @return {void}
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * $( ".selector" ).ojIndexer( "refresh" );
       */
      refresh: function () {
        this._super();

        this.element.empty();
        this._createIndexerContent();
        this._setAriaProperties();
        this.m_current = null;
      },

      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element ? this.element[0] : null;
        }

        var subId = locator.subId;
        if (subId === 'oj-indexer-section') {
          var section = locator.section;
          var sections = this.element.children('li');
          for (var i = 0; i < sections.length; i++) {
            var node = sections.get(i);
            var data = $(node).data(_DATA_RANGE);
            if (data === section) {
              return node;
            }

            // it's a separator, check the sections included in the range
            var includes = $(node).data(_DATA_INCLUDES);
            if (includes != null) {
              for (var j = 0; j < includes.length; j++) {
                if (includes[j] === section) {
                  return node;
                }
              }
            }
          }
        }
        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      getSubIdByNode: function (node) {
        if (node != null) {
          var section = $(node).data(_DATA_RANGE);
          if (section != null) {
            return { subId: 'oj-indexer-section', section: section };
          }
        }

        return null;
      },

      /** **************************** core rendering **********************************/
      /**
       * Sets wai-aria properties on root element
       * @private
       */
      _setAriaProperties: function () {
        var firstItem = this.element.children('li').first();
        var valueText = firstItem.data(_DATA_RANGE);
        // convey to screen reader that it's disabled
        if (firstItem.hasClass('oj-disabled')) {
          valueText = valueText + '. ' + this.getTranslatedString('ariaDisabledLabel');
        }

        this.element
          .attr('role', 'slider')
          .attr('aria-orientation', 'vertical')
          .attr('aria-describedby', this.element.prop('id') + ':desc')
          .attr('aria-valuemin', 0)
          .attr('aria-valuemax', Math.max(0, this.element.children().length - 1))
          .attr('aria-valuenow', 0)
          .attr('aria-valuetext', valueText);
      },

      /**
       * Removes wai-aria properties on root element
       * @private
       */
      _unsetAriaProperties: function () {
        this.element
          .removeAttr('role')
          .removeAttr('aria-orientation')
          .removeAttr('aria-describedby')
          .removeAttr('aria-valuemin')
          .removeAttr('aria-valuemax')
          .removeAttr('aria-valuenow')
          .removeAttr('aria-valuetext');
      },

      /**
       * Create instruction text for screen reader
       * @private
       */
      _createInstructionText: function () {
        var key;

        if (DomUtils.isTouchSupported()) {
          key = 'ariaTouchInstructionText';
        } else {
          key = 'ariaKeyboardInstructionText';
        }

        var text = $(document.createElement('div'));
        text.prop('id', this.element.prop('id') + ':desc');
        text.addClass('oj-helper-hidden-accessible').text(this.getTranslatedString(key));

        this._getIndexerContainer().append(text); // @HTMLUpdateOK
      },

      /**
       * Retrieves the div around the root element, create one if needed.
       * @return {jQuery} the div around the root element
       * @private
       */
      _getIndexerContainer: function () {
        if (this.m_container == null) {
          this.m_container = this._createIndexerContainer();
        }
        return this.m_container;
      },

      /**
       * Creates the div around the root element.
       * @return {jQuery} the div around the root element
       * @private
       */
      _createIndexerContainer: function () {
        var container;
        if (this.OuterWrapper) {
          container = $(this.OuterWrapper);
        } else {
          container = $(document.createElement('div'));
          this.element.parent()[0].replaceChild(container[0], this.element[0]);
        }
        container.addClass('oj-indexer oj-component');
        container.prepend(this.element); // @HTMLUpdateOK

        return container;
      },

      /**
       * @private
       */
      _createIndexerContent: function () {
        var model = this._getIndexerModel();
        if (model == null) {
          return;
        }
        var sections = model.getIndexableSections();
        if (sections == null) {
          return;
        }

        var root = this.element;
        var missingSections;
        if (model.getMissingSections) {
          missingSections = model.getMissingSections();
        }
        var sectionOthers = this.getTranslatedString('indexerOthers');
        var height = this.widget().outerHeight();

        // the first character is always present, use it to test height
        var first = this._createItem(sections[0], missingSections);
        root.append(first); // @HTMLUpdateOK

        // remove abbr first otherwise it will affect item height
        this._getIndexerContainer().removeClass('oj-indexer-abbr');
        if (this.m_itemHeight == null) {
          this.m_itemHeight = first.outerHeight();
        }
        // safeguard this.m_itemHeight from being 0, which shouldn't happen
        var itemHeight = Math.max(1, this.m_itemHeight);
        var max = Math.floor(height / itemHeight);

        // first +1 is to include the '#', second +1 is to include rendering of the symbol between letters
        var skip = Math.floor((sections.length + 1) / max) + 1;
        if (skip > 1) {
          // the height of item is a little different
          this._getIndexerContainer().addClass('oj-indexer-abbr');
        }

        for (var i = 1 + skip; i < sections.length; i = i + skip + 1) {
          if (skip > 1) {
            var separator = this._createSeparator(sections, i - skip, i - 1);
            root.append(separator); // @HTMLUpdateOK
          } else {
            i -= 1;
          }

          var section = sections[i];
          var item = this._createItem(section, missingSections);
          root.append(item); // @HTMLUpdateOK
        }

        // the last character is always present
        var last = this._createItem(sections[sections.length - 1], missingSections);
        root.append(last); // @HTMLUpdateOK

        // the special others character is always present
        var others = this._createItem(sectionOthers);
        others.attr('data-others', 'true');
        root.append(others); // @HTMLUpdateOK

        if (this.m_height == null) {
          this.m_height = height;
        }
      },

      /**
       * @private
       */
      _createItem: function (section, missingSections) {
        var label = section.label ? section.label : section;

        var item = $(document.createElement('li'));
        item.data(_DATA_RANGE, section).text(label);

        if (missingSections != null && missingSections.indexOf(section) > -1) {
          item.addClass('oj-disabled');
        }

        return item;
      },

      /**
       * @private
       */
      _createSeparator: function (sections, from, to) {
        var includes = [];
        var item = $(document.createElement('li'));
        item
          .addClass('oj-indexer-ellipsis')
          .data(_DATA_RANGE, sections[from + Math.round((to - from) / 2)]);
        for (var i = from; i <= to; i++) {
          includes.push(sections[i]);
        }
        item.data(_DATA_INCLUDES, includes);
        return item;
      },
      /** ************************** end core rendering **********************************/

      /** ****************************** event handler **********************************/
      /**
       * Initialize the indexer
       * @private
       */
      _setup: function () {
        var self = this;

        this.element.uniqueId().addClass('oj-component-initnode').attr('tabIndex', 0);

        this._on(this.element, {
          click: function (event) {
            self._handleClick(event);
          },
          keydown: function (event) {
            self._handleKeyDown(event);
          },
          focus: function (event) {
            self._handleFocus(event);
          },
          blur: function (event) {
            self._handleBlur(event);
          }
        });

        this._focusable({
          applyHighlight: true,
          setupHandlers: function (focusInHandler, focusOutHandler) {
            self._focusInHandler = focusInHandler;
            self._focusOutHandler = focusOutHandler;
          }
        });
      },

      /**
       * Event handler for when mouse click anywhere in the indexer
       * @param {Event} event mouseclick event
       * @private
       */
      _handleClick: function (event) {
        var target;

        // only perform events on left mouse, (right in rtl culture)
        if (event.button === 0) {
          target = $(event.target);
          this._setCurrent(target);
        }
      },

      /**
       * Handler for focus event
       * @param {Event} event the focus event
       * @private
       */
      // eslint-disable-next-line no-unused-vars
      _handleFocus: function (event) {
        this._getIndexerContainer().addClass('oj-focus-ancestor');
        if (this.m_current == null) {
          this._setFocus(this.element.children('li').first());
        } else {
          this._setFocus(this.m_current);
        }
      },

      /**
       * Handler for blur event
       * @param {Event} event the blur event
       * @private
       */
      // eslint-disable-next-line no-unused-vars
      _handleBlur: function (event) {
        this._getIndexerContainer().removeClass('oj-focus-ancestor');
      },

      /**
       * Event handler for when user press down a key
       * @param {Event} event keydown event
       * @private
       */
      _handleKeyDown: function (event) {
        var next;
        var processed = false;

        switch (event.keyCode) {
          // UP key
          case 38:
            next = this.m_current.prev();
            break;
          // DOWN key
          case 40:
            next = this.m_current.next();
            break;
          // ENTER key
          case 13:
            this._setCurrent(this.m_current);
            processed = true;
            break;
          default:
            break;
        }

        if (next != null && next.length > 0) {
          processed = true;
          this._setFocus(next);
        }

        if (processed) {
          event.preventDefault();
        }
      },

      _setFocus: function (item) {
        if (this.m_current != null) {
          this._focusOutHandler(this.m_current);
        }
        this._focusInHandler(item);

        this._updateAriaProperties(item);
        this.m_current = item;
      },

      /**
       * Retrieves the indexer model.
       * @private
       */
      _getIndexerModel: function () {
        var model = this.option('data');
        if (
          model != null &&
          (model.setSection === undefined || model.getIndexableSections === undefined)
        ) {
          throw new Error('Invalid IndexerModel');
        }
        return model;
      },

      /**
       * Sets the character item as current
       * @param {jQuery} item
       * @private
       */
      _setCurrent: function (item) {
        var section = item.data(_DATA_RANGE);
        if (item.attr(_DATA_OTHERS)) {
          section = IndexerModel.SECTION_OTHERS;
        }

        this._setCurrentSection(section);
      },

      /**
       * Sets the section as current
       * @param {Object} section
       * @private
       */
      _setCurrentSection: function (section) {
        var self = this;
        var busyContext = Context.getContext(this.element[0]).getBusyContext();
        this.busyStateResolve = busyContext.addBusyState({ description: 'setCurrentSection' });

        // sets on the IndexerModel
        var promise = /** @type {Promise} */ (this._getIndexerModel().setSection(section));
        promise.then(
          function (val) {
            // the resolve value is the section that actually scrolls to
            if (val != null) {
              var item = self._findItem(val);
              if (item != null) {
                self._setFocus(item);
              }
            }

            self._resolveBusyState();
          },
          function () {
            self._resolveBusyState();
          }
        );
      },

      /**
       * Update wai-aria properties
       * @param {jQuery} item the item
       * @private
       */
      _updateAriaProperties: function (item) {
        var includes = item.data(_DATA_INCLUDES);
        var valueText = '';

        if (includes != null) {
          // length should always be > 0
          if (includes.length > 0) {
            var first = includes[0].label ? includes[0].label : includes[0];
            var second = includes[includes.length - 1].label
              ? includes[includes.length - 1].label
              : includes[includes.length - 1];
            valueText = this.getTranslatedString('ariaInBetweenText', {
              first: first,
              second: second
            });
          }
        } else {
          var val = item.data(_DATA_RANGE);
          // checks if it's the special others section
          if (val === IndexerModel.SECTION_OTHERS) {
            valueText = this.getTranslatedString('ariaOthersLabel');
          } else {
            valueText = val;
          }
        }

        // convey to screen reader that it's disabled
        if (item.hasClass('oj-disabled')) {
          valueText = valueText + '. ' + this.getTranslatedString('ariaDisabledLabel');
        }

        this.element.attr('aria-valuetext', valueText);
        this.element.attr('aria-valuenow', item.index());
      },

      /**
       * Finds the item with the specified section
       * @param {Object} section
       * @return {jQuery} the item, null if not found
       * @private
       */
      _findItem: function (section) {
        var children = this.element.children();

        for (var i = 0; i < children.length; i++) {
          var item = children.get(i);
          var value = $(item).data(_DATA_RANGE);
          var includes = $(item).data(_DATA_INCLUDES);
          var others = $(item).attr(_DATA_OTHERS);

          if (
            (value != null && value === section) ||
            (includes != null && includes.indexOf(section) > -1) ||
            others !== undefined
          ) {
            return $(item);
          }
        }

        return null;
      },

      /**
       * Unregister event listeners for resize the container DOM element.
       * @param {Element} element the container DOM element
       * @private
       */
      _unregisterResizeListener: function (element) {
        if (element && this._resizeHandler) {
          // remove existing listener
          DomUtils.removeResizeListener(element, this._resizeHandler);
        }
      },

      /**
       * Register event listeners for resize the container DOM element.
       * @param {Element} element  DOM element
       * @private
       */
      _registerResizeListener: function (element) {
        if (element) {
          if (this._resizeHandler == null) {
            this._resizeHandler = this._handleResize.bind(this);
          }

          DomUtils.addResizeListener(element, this._resizeHandler);
        }
      },

      /**
       * Unregister panning handler
       * @param {Element} element  DOM element
       * @private
       */
      _unregisterTouchHandler: function (element) {
        if (this.hammer) {
          this.hammer.off('panstart panmove panend');
          $(element).ojHammer('destroy');
        }
        this.hammer = null;
      },

      /**
       * Register panning handler
       * @param {Element} element  DOM element
       * @private
       */
      _registerTouchHandler: function (element) {
        var self = this;
        var x;
        var y;
        var currentTarget;
        var currentSection;
        var currentY;

        var options = {
          recognizers: [[Hammer.Pan, { direction: Hammer.DIRECTION_VERTICAL }]]
        };

        this.hammer = $(element)
          .ojHammer(options)
          .on('panstart', function (event) {
            var target = event.gesture.target;
            // for x, don't use the target, use x relative to the indexer to ensure it reflects item in Indexer
            // even if the finger is off the Indexer
            x = self.element[0].getBoundingClientRect().left + 5;
            y = target.getBoundingClientRect().top;
            self._setCurrent($(target));

            currentTarget = target;
            currentSection = $(target).data(_DATA_RANGE);
            currentY = y;
          })
          .on('panmove', function (event) {
            // calculate point instead of using screenX/Y from touch is better since
            // 1) x stays constant
            // 2) in voiceover user could have pan anywhere on the screen
            var previousY = currentY;
            currentY = y + event.gesture.deltaY;

            var target = document.elementFromPoint(x, currentY);

            // should not happen
            if (target == null) {
              return;
            }

            var delta = currentY - previousY;
            var range;
            var section;

            if (currentTarget === target) {
              range = $(target).data(_DATA_INCLUDES);
              // if the section is a range (dot), then try to set the next section inside the range current
              // for example, if move on * which represents range BCD, if current is C then move up should go to B and move down should go to D
              if (range != null) {
                var index = range.indexOf(currentSection);
                section = null;
                if (delta > 0 && index < range.length - 1) {
                  section = range[index + 1];
                } else if (delta < 0 && index > 0) {
                  section = range[index - 1];
                }

                if (section != null) {
                  currentSection = section;
                  self._setCurrentSection(section);
                }
              }
            } else if ($(target).data(_DATA_RANGE)) {
              range = $(target).data(_DATA_INCLUDES);
              section = null;
              // if the target is a range (dot), check to see if we should set the section to the beginning of
              // range or end of range.  For example, if you have A * E with * represents BCD, coming from A should go to B
              // where as coming from E should go to D.
              if (range != null) {
                if (delta > 0 && target === currentTarget.nextElementSibling) {
                  section = range[0];
                } else if (delta < 0 && target === currentTarget.previousElementSibling) {
                  section = range[range.length - 1];
                }
              }

              if (section == null) {
                section = $(target).data(_DATA_RANGE);
              }

              currentTarget = target;
              currentSection = section;

              self._setCurrentSection(currentSection);
            }
          })
          .on('panend', function () {
            currentTarget = null;
            currentSection = null;
            currentY = null;
          });
      },

      /**
       * The resize handler.
       * @param {number} width the new width
       * @param {number} height the new height
       * @private
       */
      _handleResize: function (width, height) {
        if (height > 0 && height !== this.m_height) {
          this.refresh();
          this.m_height = height;
        }
      }
    });
  })();

  /**
   * Implementation of the IndexerModel used by ListView.  This implementation groups the data based on the first letter of the
   * group header text and the alphabet of the current locale.
   * @export
   * @ojtsnoexport
   * @param {Object} listview the internal ListView instance
   * @class oj.ListViewIndexerModel
   * @implements oj.IndexerModel
   * @classdesc Implementation of IndexerModel used by ListView.
   * @extends EventSource
   * @constructor
   * @ignore
   */
  const ListViewIndexerModel = function (listview) {
    this.listview = listview;
    this.Init();
  };
  oj._registerLegacyNamespaceProp('ListViewIndexerModel', ListViewIndexerModel);
  // Subclass from oj.EventSource
  oj.Object.createSubclass(ListViewIndexerModel, oj.EventSource, 'oj.ListViewIndexerModel');

  /**
   * @export
   * Returns the sections displayed by the Indexer.
   * @returns {Array.<Object>} an array of sections
   * @memberof! oj.ListViewIndexerModel
   */
  ListViewIndexerModel.prototype.getIndexableSections = function () {
    var sections = this.listview.ojContext.getTranslatedString('indexerCharacters');
    return sections.split('|');
  };

  /**
   * @export
   * Returns the sections that are missing in the associated ListView.
   * @return {Array.<Object>} an array of sections that are missing.
   * @memberof! oj.ListViewIndexerModel
   */
  ListViewIndexerModel.prototype.getMissingSections = function () {
    if (this.missingSections == null) {
      this.missingSections = this._getMissingSections();
    }

    return this.missingSections;
  };

  /**
   * Returns the sections that are currently missing.
   * @private
   */
  ListViewIndexerModel.prototype._getMissingSections = function () {
    var results = [];
    var groupItems = this.listview._getGroupItemsCache();
    var sections = this.getIndexableSections();
    var i;

    for (i = 0; i < sections.length; i++) {
      var section = sections[i];
      var found = false;
      // eslint-disable-next-line no-loop-func
      groupItems.each(function () {
        var content = $(this).text();
        if (content.length > 0 && content.charAt(0) === section) {
          found = true;
          return false;
        }
        return true;
      });

      if (!found) {
        results.push(section);
      }
    }

    return results;
  };

  /**
   * @export
   * Sets the current section.  When associated with a ListView, this will scroll the ListView to the corresponding group header.
   * @param {Object} section the current section
   * @return {Promise} a Promise object which when resolve will return the section that the IndexerModel actually sets as current.
   * @memberof! oj.ListViewIndexerModel
   */
  ListViewIndexerModel.prototype.setSection = function (section) {
    if (section === IndexerModel.SECTION_OTHERS) {
      return this._setOtherSection();
    }

    return this._setSection(section);
  };

  /**
   * Sets the 'Other' section as current
   * @private
   */
  ListViewIndexerModel.prototype._setOtherSection = function () {
    var sections = this.getIndexableSections();
    var self = this;

    return new Promise(function (resolve) {
      var match = null;

      // find the group header that DOES NOT match ANY of the sections
      self.listview._getGroupItemsCache().each(function () {
        var content = $(this).text();
        for (var i = 0; i < sections.length; i++) {
          var section = sections[i];
          if (content.indexOf(section) === 0) {
            // skip and check next group header
            return true;
          }
        }

        match = this;
        return false;
      });

      if (match) {
        self.listview._scrollToGroupHeader(match);
        resolve(IndexerModel.SECTION_OTHERS);
      } else {
        resolve(null);
      }
    });
  };

  /**
   * Sets the specified section as current.
   * @private
   */
  ListViewIndexerModel.prototype._setSection = function (section) {
    var sections = this.getIndexableSections();
    var index = sections.indexOf(section);
    var self = this;

    return new Promise(function (resolve) {
      if (index === -1) {
        // if it's not even in the indexable sections, then we don't need to process anymore
        resolve(null);
      } else {
        var match = null;

        // try to find the group header, use the next section as needed
        for (; index < sections.length; index++) {
          var _section = sections[index];
          var groupHeader = self._findGroupHeader(_section);
          if (groupHeader != null) {
            self.listview._scrollToGroupHeader(groupHeader);
            match = _section;
            break;
          }
        }

        resolve(match);
      }
    });
  };

  /**
   * Finds the group header with the specified section
   * @private
   */
  ListViewIndexerModel.prototype._findGroupHeader = function (section) {
    var match;

    this.listview._getGroupItemsCache().each(function () {
      var content = $(this).text();
      if (content.indexOf(section) === 0) {
        match = this;
        return false;
      }
      return true;
    });

    return match;
  };

  exports.ListViewIndexerModel = ListViewIndexerModel;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojlistview',['require', 'ojs/ojcore-base', 'jquery', 'ojs/ojcustomelement', 'ojs/ojdataproviderscroller', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojdatacollection-common', 'ojs/ojanimation', 'ojs/ojlogger', 'ojs/ojkeyset', 'ojs/ojmap', 'ojs/ojdomutils', 'ojs/ojdataprovideradapter', 'ojs/ojcustomelement-utils', 'ojs/ojkeyboardfocus-utils', 'ojs/ojindexer'], function (require, oj, $, ojcustomelement, DataProviderScroller, Context, Config, ThemeUtils, Components, DataCollectionUtils, AnimationUtils, Logger, ojkeyset, KeyMap, DomUtils, ojdataprovideradapter, ojcustomelementUtils, ojkeyboardfocusUtils, ojindexer) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = {};
      if (e) {
        Object.keys(e).forEach(function (k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        });
      }
      n['default'] = e;
      return n;
    }
  }

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  KeyMap = KeyMap && Object.prototype.hasOwnProperty.call(KeyMap, 'default') ? KeyMap['default'] : KeyMap;

  (function () {
var __oj_list_view_metadata = 
{
  "properties": {
    "as": {
      "type": "string",
      "value": ""
    },
    "currentItem": {
      "type": "any",
      "writeback": true
    },
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "unsupported",
              "since": "13.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "display": {
      "type": "string",
      "enumValues": [
        "card",
        "list"
      ],
      "value": "list"
    },
    "dnd": {
      "type": "object",
      "properties": {
        "drag": {
          "type": "object",
          "properties": {
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "drag": {
                  "type": "function"
                },
                "dragEnd": {
                  "type": "function"
                },
                "dragStart": {
                  "type": "function"
                }
              }
            }
          }
        },
        "drop": {
          "type": "object",
          "properties": {
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            }
          }
        },
        "reorder": {
          "type": "object",
          "properties": {
            "items": {
              "type": "string",
              "enumValues": [
                "disabled",
                "enabled"
              ],
              "value": "disabled"
            }
          }
        }
      }
    },
    "drillMode": {
      "type": "string",
      "enumValues": [
        "collapsible",
        "none"
      ],
      "value": "collapsible"
    },
    "expanded": {
      "type": "KeySet",
      "writeback": true
    },
    "firstSelectedItem": {
      "type": "object",
      "writeback": true,
      "readOnly": true,
      "value": {
        "key": null,
        "data": null
      }
    },
    "gridlines": {
      "type": "object",
      "properties": {
        "item": {
          "type": "string",
          "enumValues": [
            "hidden",
            "visible",
            "visibleExceptLast"
          ],
          "value": "visible"
        }
      }
    },
    "groupHeaderPosition": {
      "type": "string",
      "enumValues": [
        "static",
        "sticky"
      ],
      "value": "sticky"
    },
    "item": {
      "type": "object",
      "properties": {
        "focusable": {
          "type": "boolean|function",
          "value": true
        },
        "renderer": {
          "type": "function"
        },
        "selectable": {
          "type": "boolean|function",
          "value": true
        }
      }
    },
    "scrollPolicy": {
      "type": "string",
      "enumValues": [
        "auto",
        "loadAll",
        "loadMoreOnScroll"
      ],
      "value": "auto"
    },
    "scrollPolicyOptions": {
      "type": "Object<string, number>",
      "properties": {
        "fetchSize": {
          "type": "number",
          "value": 25
        },
        "maxCount": {
          "type": "number",
          "value": 500
        },
        "scroller": {
          "type": "Element|string"
        }
      }
    },
    "scrollPosition": {
      "type": "object",
      "writeback": true,
      "value": {
        "x": 0,
        "y": 0
      },
      "properties": {
        "index": {
          "type": "number"
        },
        "key": {
          "type": "any"
        },
        "offsetX": {
          "type": "number"
        },
        "offsetY": {
          "type": "number"
        },
        "parent": {
          "type": "any"
        },
        "x": {
          "type": "number"
        },
        "y": {
          "type": "number"
        }
      }
    },
    "scrollToKey": {
      "type": "string",
      "enumValues": [
        "always",
        "auto",
        "capability",
        "never"
      ],
      "value": "auto"
    },
    "selected": {
      "type": "KeySet",
      "writeback": true
    },
    "selection": {
      "type": "Array<any>",
      "writeback": true,
      "value": []
    },
    "selectionMode": {
      "type": "string",
      "enumValues": [
        "multiple",
        "none",
        "single"
      ],
      "value": "none"
    },
    "selectionRequired": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleExpandCollapseInstructionText": {
          "type": "string"
        },
        "accessibleGroupCollapse": {
          "type": "string"
        },
        "accessibleGroupExpand": {
          "type": "string"
        },
        "accessibleNavigateSkipItems": {
          "type": "string"
        },
        "accessibleReorderAfterItem": {
          "type": "string"
        },
        "accessibleReorderBeforeItem": {
          "type": "string"
        },
        "accessibleReorderInsideItem": {
          "type": "string"
        },
        "accessibleReorderTouchInstructionText": {
          "type": "string"
        },
        "accessibleSuggestion": {
          "type": "string"
        },
        "indexerCharacters": {
          "type": "string"
        },
        "labelCopy": {
          "type": "string"
        },
        "labelCut": {
          "type": "string"
        },
        "labelPaste": {
          "type": "string"
        },
        "labelPasteAfter": {
          "type": "string"
        },
        "labelPasteBefore": {
          "type": "string"
        },
        "msgFetchCompleted": {
          "type": "string"
        },
        "msgFetchingData": {
          "type": "string"
        },
        "msgItemsAppended": {
          "type": "string"
        },
        "msgNoData": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getContextByNode": {},
    "getDataForVisibleItem": {},
    "getIndexerModel": {},
    "getProperty": {},
    "refresh": {},
    "scrollToItem": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeCollapse": {},
    "ojBeforeCurrentItem": {},
    "ojBeforeExpand": {},
    "ojCollapse": {},
    "ojCopy": {},
    "ojCut": {},
    "ojExpand": {},
    "ojItemAction": {},
    "ojPaste": {},
    "ojReorder": {}
  },
  "extension": {}
};
    __oj_list_view_metadata.extension._WIDGET_NAME = 'ojListView';
    __oj_list_view_metadata.extension._INNER_ELEM = 'ul';
    __oj_list_view_metadata.extension._GLOBAL_TRANSFER_ATTRS = ['aria-label', 'aria-labelledby'];
    oj.CustomElementBridge.register('oj-list-view', { metadata: __oj_list_view_metadata });
  })();

  /**
   * Handler for static HTML content
   * @constructor
   * @ignore
   */
  const StaticContentHandler = function (widget, root) {
    this.m_widget = widget;
    this.m_root = root;
  };

  // Subclass from oj.Object
  oj._registerLegacyNamespaceProp('StaticContentHandler', StaticContentHandler);
  oj.Object.createSubclass(StaticContentHandler, oj.Object, 'oj.StaticContentHandler');

  /**
   * Initializes the instance.
   * @protected
   */
  StaticContentHandler.prototype.Init = function () {
    StaticContentHandler.superclass.Init.call(this);
  };

  /**
   * Destroy the content handler
   * @protected
   */
  StaticContentHandler.prototype.Destroy = function () {
    // check if it's been destroyed or in process
    if (!this.m_root.hasAttribute('role')) {
      return;
    }

    this.restoreContent(this.m_root, 0);
    this.unsetRootAriaProperties();
  };

  /**
   * Determine whether the content handler is ready
   * @return {boolean} returns true there's no outstanding request, false otherwise.
   * @protected
   */
  StaticContentHandler.prototype.IsReady = function () {
    // static content does not fetch
    return true;
  };

  StaticContentHandler.prototype.notifyShown = function () {
    // do nothing since all items are present
  };

  StaticContentHandler.prototype.notifyAttached = function () {
    // do nothing since all items are present
  };

  StaticContentHandler.prototype.RenderContent = function () {
    var root = this.m_root;
    if (
      this.shouldUseGridRole() &&
      this.isCardLayout() &&
      !this.IsHierarchical() &&
      $(root).children('li').length > 0
    ) {
      // in card layout, this is going to be a single row, N columns grid
      // so we'll need to wrap all <li> within a row
      // prettier-ignore
      $(this.m_root)
        .children()
        .wrapAll( // @HTMLUpdateOK
          "<li role='presentation'><ul role='row' class='" +
            this.m_widget.getGroupStyleClass() +
            "'></ul></li>"
        );
      var wrapped = $(this.m_root).children('li').first().get(0);
      wrapped.style.width = '100%';
      wrapped.classList.add('oj-listview-group-container');
      root = wrapped.firstElementChild;
    }
    this.modifyContent(root, 0);
    this.setRootAriaProperties();
    this.m_widget.renderComplete(false);

    var self = this;
    var busyContext = Context.getContext(root).getBusyContext();
    busyContext.whenReady().then(function () {
      if (root != null) {
        var children = $(root).find('li.' + self.m_widget.getItemElementStyleClass());
        for (var i = 0; i < children.length; i++) {
          self.m_widget.disableAllTabbableElements(children[i]);
        }
      }
    });
  };

  StaticContentHandler.prototype.Expand = function (item, successCallback) {
    var selector = '.' + this.m_widget.getGroupStyleClass();
    var groupItem = $(item).children(selector)[0];
    $(groupItem).css('display', '');

    successCallback.call(null, groupItem);
  };

  StaticContentHandler.prototype.Collapse = function (item) {
    var groupItem = item.get(0);
    groupItem.style.display = 'none';
  };

  StaticContentHandler.prototype.IsHierarchical = function () {
    if (this.m_hier == null) {
      this.m_hier = $(this.m_root).children('li').children('ul').length > 0;
    }
    return this.m_hier;
  };

  /**
   * Restore the static content into its original format by removing all ListView specific style classes and attributes.
   * @param {Element} elem the element it is currently restoring
   * @param {number} depth the depth of the element it is currently restoring
   * @private
   */
  StaticContentHandler.prototype.restoreContent = function (elem, depth) {
    var groupStyleClass = this.m_widget.getGroupStyleClass();
    var groupCollapseStyleClass = this.m_widget.getGroupCollapseStyleClass();
    var groupExpandStyleClass = this.m_widget.getGroupExpandStyleClass();
    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass();
    var itemStyleClass = this.m_widget.getItemStyleClass();
    var itemElementStyleClass = this.m_widget.getItemElementStyleClass();
    var itemLayoutStyleClass = null;
    if (this.m_widget.getItemLayoutStyleClass) {
      itemLayoutStyleClass = this.m_widget.getItemLayoutStyleClass();
    }

    var firstChild = elem.firstElementChild;
    if (firstChild && firstChild.classList.contains('oj-listview-group-container')) {
      $(firstChild).children().unwrap().children().unwrap();
    }

    var items = elem.children;
    for (var i = 0; i < items.length; i++) {
      var item = $(items[i]);
      // skip children that are not modified, this could happen if ko:foreach backed by an observable array is used to generate
      // the content, and the observable array has changed
      if (item.hasClass(itemElementStyleClass)) {
        this.unsetAriaProperties(item.get(0));
        if (item.hasClass('oj-listview-card')) {
          item.removeClass('oj-listview-card').removeClass('oj-listview-card-animated');
          item[0].style.opacity = 'unset';
          item[0].style.transform = 'unset';
        }
        item
          .removeClass(itemElementStyleClass)
          .removeClass(itemStyleClass)
          .removeClass(itemLayoutStyleClass)
          .removeClass(this.m_widget.getDepthStyleClass(depth))
          .removeClass('gridline-hidden')
          .removeClass('oj-listview-item')
          .removeClass('oj-listview-item-element')
          .removeClass('oj-skipfocus')
          .removeClass('oj-focus')
          .removeClass('oj-hover')
          .removeClass('oj-expanded')
          .removeClass('oj-collapsed')
          .removeClass('oj-selected');

        var groupItems = item.children('ul');
        if (groupItems.length > 0) {
          item
            .children('.' + groupItemStyleClass)
            .children()
            .unwrap();
          if (this.shouldUseGridRole()) {
            this.unsetGroupAriaProperties(item);
          }
          item.children('.oj-component-icon').remove();

          var groupItem = $(groupItems[0]);
          groupItem
            .removeClass(groupStyleClass)
            .removeClass(groupExpandStyleClass)
            .removeClass(groupCollapseStyleClass)
            .removeAttr('role');
          this.restoreContent(groupItem[0], depth + 1);
        }
      }
    }
  };

  /**
   * Modify the static content to include ListView specific style classes and attributes.
   * @param {Element} elem the element it is currently modifying
   * @param {number} depth the depth of the element it is currently modifying
   * @private
   */
  StaticContentHandler.prototype.modifyContent = function (elem, depth) {
    var itemStyleClass = this.m_widget.getItemStyleClass();
    var itemElementStyleClass = this.m_widget.getItemElementStyleClass();
    var groupStyleClass = this.m_widget.getGroupStyleClass();
    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(true);
    var groupCollapseStyleClass = this.m_widget.getGroupCollapseStyleClass();
    var collapseClass = this.m_widget.getCollapseIconStyleClass();
    var focusedElementStyleClass = this.m_widget.getFocusedElementStyleClass();

    var items = elem.children;
    var expandable = this.m_widget.isExpandable();

    for (var i = 0; i < items.length; i++) {
      var item = $(items[i]);
      var context = this.createContext(item);

      this.setAriaProperties(item, context);

      item.uniqueId().addClass(itemElementStyleClass);
      if (depth > 0) {
        item.addClass(this.m_widget.getDepthStyleClass(depth));
      }

      // tag it if item is not focusable
      if (!this.isFocusable(context)) {
        item.addClass('oj-skipfocus');
      }

      var groupItems = item.children('ul');
      if (groupItems.length > 0) {
        this.m_hier = true;

        item.children(':not(ul)').wrapAll('<div></div>'); // @HTMLUpdateOK

        var content = item.children().first();
        content.addClass(groupItemStyleClass);

        var count = this.getItemsCount(groupItems[0]);
        if (count > 0) {
          if (item.hasClass(focusedElementStyleClass)) {
            item.removeClass(focusedElementStyleClass);
            content.addClass(focusedElementStyleClass).attr('aria-expanded', 'false');
          } else {
            content.attr('role', 'presentation');
            content.find('.' + focusedElementStyleClass).attr('aria-expanded', 'false');
          }

          // add the expand icon
          if (expandable) {
            item.addClass('oj-collapsed');

            content.uniqueId();

            // add the expand icon
            var icon = document.createElement('a');
            $(icon)
              .attr('role', 'button')
              .attr('aria-labelledby', content.get(0).id)
              .addClass('oj-component-icon oj-clickable-icon-nocontext')
              .addClass(collapseClass);

            content.prepend(icon); // @HTMLUpdateOK
          }
        } else {
          content.addClass('oj-empty');
        }

        if (this.shouldUseGridRole()) {
          this.setGroupAriaProperties(content, count);
        }

        var groupItem = $(groupItems[0]);
        var role;
        if (this.shouldUseGridRole()) {
          if (this.isCardLayout()) {
            role = 'row';
          } else {
            role = 'presentation';
          }
        } else {
          role = 'group';
        }
        groupItem
          .addClass(groupStyleClass)
          .addClass(groupCollapseStyleClass)
          .attr('role', role)
          .css('display', 'none');
        this.modifyContent(groupItem[0], depth + 1);
      } else {
        item.addClass(itemStyleClass);
      }

      if (this.m_widget._isSelectionEnabled() && this.isSelectable(context)) {
        this.m_widget.getFocusItem(item).attr('aria-selected', false);
      }

      this.m_widget.itemRenderComplete(item[0], context);
    }
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.setRootAriaProperties = function () {
    if (this.shouldUseGridRole()) {
      this.m_root.setAttribute('role', 'grid');
    } else if (this.IsHierarchical()) {
      this.m_root.setAttribute('role', 'tree');
    } else {
      this.m_root.setAttribute('role', 'listbox');
    }
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.unsetRootAriaProperties = function () {
    this.m_root.removeAttribute('role');
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.getItemsCount = function (item) {
    return $(item).children('li').length;
  };

  /**
   * Creates the object with context information for the specified item
   * @param {jQuery} item the item to create context info object for
   * @return {Object} the context object
   * @private
   */
  StaticContentHandler.prototype.createContext = function (item) {
    var context = {};
    context.key = item.attr('id');
    context.parentElement = item.children().first()[0];
    context.index = item.index();
    context.data = item[0];
    context.component = this.m_widget.getWidgetConstructor();
    context = this.m_widget._FixRendererContext(context);

    // additional context info for hierarhical data
    if (this.IsHierarchical()) {
      context.leaf = item.children('ul').length === 0;
      var parents = item.parents('li.' + this.m_widget.getItemElementStyleClass());
      context.depth = parents.length;
      if (parents.length === 0) {
        context.parentKey = null;
      } else {
        context.parentKey = parents.first().attr('id');
      }
    }

    return context;
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.setAriaProperties = function (item, context) {
    // if there's only one element inside the item and it is focusable, set
    // the role on it instead
    var elem = this.m_widget.getSingleFocusableElement(item);
    if (this.shouldUseGridRole()) {
      if (context.leaf != null && !context.leaf) {
        // it's a group item
        item.attr('role', 'presentation');
        if (elem !== item) {
          elem.attr('role', 'gridcell');
        }
      } else if (this.isCardLayout()) {
        elem.attr('role', 'gridcell');
      } else {
        item.attr('role', 'row');
        if (elem !== item) {
          elem.attr('role', 'gridcell');
        } else {
          // we'll need to wrap content with a gridcell role
          elem.children().wrapAll("<div role='gridcell' class='oj-listview-cell-element'></div>"); // @HTMLUpdateOK
        }
      }
    } else {
      elem.attr('role', this.IsHierarchical() ? 'treeitem' : 'option');
      if (elem !== item) {
        item.attr('role', 'presentation');
      }
    }

    elem.addClass(this.m_widget.getFocusedElementStyleClass());
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.setGroupAriaProperties = function (group, count) {
    var focusedElementStyleClass = this.m_widget.getFocusedElementStyleClass();

    // aria-expanded should be in the cell
    group.get(0).removeAttribute('aria-expanded');
    group.removeClass(focusedElementStyleClass);
    group.attr('role', 'row');
    // prettier-ignore
    group.children().wrapAll( // @HTMLUpdateOK
      "<div role='gridcell' aria-expanded='false' class='oj-listview-cell-element " +
        focusedElementStyleClass +
        "'></div>"
    );

    if (this.isCardLayout() && count > 1) {
      group.children().first().attr('aria-colspan', count);
    }
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.unsetGroupAriaProperties = function (item) {
    item.children('div').first().children().unwrap();
  };

  /**
   * @private
   */
  StaticContentHandler.prototype.unsetAriaProperties = function (item) {
    DataCollectionUtils.enableAllFocusableElements(item);

    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(true);
    var focusedElementStyleClass = this.m_widget.getFocusedElementStyleClass();
    var firstElementChild = item.firstElementChild;
    var elem;
    if (firstElementChild && $(firstElementChild).hasClass(groupItemStyleClass)) {
      elem = $(firstElementChild)
        .children('.' + focusedElementStyleClass)
        .first();
      if (elem.length === 0) {
        // should not happen
        return;
      }
    } else {
      elem = this.m_widget.getSingleFocusableElement($(item));
    }

    elem.removeAttr('role');
    elem.removeAttr('aria-selected');
    elem.removeAttr('aria-expanded');
    elem.removeClass(this.m_widget.getFocusedElementStyleClass());

    // need to unwrap since in non-card layout we wrap the content with a div for gridcell role
    if (this.shouldUseGridRole() && !this.isCardLayout()) {
      if (elem !== item) {
        $(item).removeAttr('role');
        elem.children().first().children().unwrap();
      } else {
        elem.children().first().children().unwrap().children().unwrap();
      }
    }
  };

  StaticContentHandler.prototype.GetKey = function (element) {
    return $(element).attr('id');
  };

  StaticContentHandler.prototype.FindElementByKey = function (key) {
    return document.getElementById(key);
  };

  StaticContentHandler.prototype.isFocusable = function (context) {
    return this.m_widget.getItemFocusable(context);
  };

  StaticContentHandler.prototype.isSelectable = function (context) {
    return this.m_widget.getItemSelectable(context);
  };

  StaticContentHandler.prototype.isCardLayout = function () {
    return this.m_widget.isCardLayout();
  };

  StaticContentHandler.prototype.shouldUseGridRole = function () {
    return this.m_widget.ShouldUseGridRole();
  };

  StaticContentHandler.prototype.createKeyMap = function (initialMap) {
    var map = new KeyMap();
    if (initialMap) {
      initialMap.forEach(function (value, key) {
        map.set(key, value);
      });
      return map;
    }
    return map;
  };

  StaticContentHandler.prototype.createKeySet = function (initialSet) {
    return new ojkeyset.KeySet(initialSet);
  };

  /**
   * Handler for TreeDataProvider generated content
   * @constructor
   * @extends oj.DataSourceContentHandler
   * @ignore
   */
  const TreeDataProviderContentHandler = function (widget, root, data) {
    TreeDataProviderContentHandler.superclass.constructor.call(this, widget, root, data);
  };

  // Subclass from oj.DataSourceContentHandler
  oj._registerLegacyNamespaceProp('TreeDataProviderContentHandler', TreeDataProviderContentHandler);
  oj.Object.createSubclass(
    TreeDataProviderContentHandler,
    DataProviderScroller.DataProviderContentHandler,
    'oj.TreeDataProviderContentHandler'
  );

  // number of skeleton items to render for expand node
  TreeDataProviderContentHandler.NUM_CHILD_SKELETONS = 3;

  /**
   * Initializes the instance.
   * @protected
   */
  TreeDataProviderContentHandler.prototype.Init = function () {
    TreeDataProviderContentHandler.superclass.Init.call(this);
    this.m_childDataProviders = new KeyMap();
    this.m_fetchCalls = new Set();
  };

  /**
   * Determines whether the conent is hierarchical.
   * @return {boolean} returns true if content is hierarhical, false otherwise.
   * @protected
   */
  TreeDataProviderContentHandler.prototype.IsHierarchical = function () {
    return true;
  };

  /**
   * Destroy the content handler
   * @protected
   */
  TreeDataProviderContentHandler.prototype.Destroy = function (completelyDestroy) {
    TreeDataProviderContentHandler.superclass.Destroy.call(this, completelyDestroy);

    this.m_controller = null;
  };

  /**
   * @private
   */
  TreeDataProviderContentHandler.prototype._getChildDataProvider = function (key) {
    if (key === null) {
      return this.getDataProvider();
    }

    var childDataProvider = this.m_childDataProviders.get(key);
    if (childDataProvider == null) {
      childDataProvider = this.getDataProvider().getChildDataProvider(key);
      if (childDataProvider) {
        this.m_childDataProviders.set(key, childDataProvider);
      }
    }

    return childDataProvider;
  };

  /**
   * @protected
   */
  TreeDataProviderContentHandler.prototype.fetchRows = function (forceFetch) {
    this.signalTaskStart('fetching rows'); // signal method task start

    TreeDataProviderContentHandler.superclass.fetchRows.call(this, forceFetch);

    this.m_fetchCalls.clear();
    this._fetchChildren(null, this.m_root, null);

    this.signalTaskEnd(); // signal method task end
  };

  /**
   * @private
   */
  TreeDataProviderContentHandler.prototype._fetchChildren = function (
    parent,
    parentElem,
    successCallback,
    errorCallback
  ) {
    var self = this;

    this.signalTaskStart('fetching children from parent: ' + parent); // signal method task start

    // initiate loading of template engine, note it will not load it unless a template has been specified
    var enginePromise = this.loadTemplateEngine();

    // root node would not have expand/collapse icon
    if (parent != null) {
      var anchor = parentElem.parentNode.firstElementChild.firstElementChild.firstElementChild;
      if (anchor) {
        anchor = $(anchor);
        var collapseClass = this.m_widget.getCollapseIconStyleClass();
        // switch to loading icon
        if (anchor.hasClass(collapseClass)) {
          var expandingClass = this.isSkeletonSupport()
            ? this.m_widget.getExpandIconStyleClass()
            : this.m_widget.getExpandingIconStyleClass();
          anchor.removeClass(collapseClass).addClass(expandingClass);
        }
      }
    }

    // no need to check ready since multiple fetch from different parents can occur at the same time
    this.m_fetching = true;
    if (parent != null) {
      this.m_fetchCalls.add(parent);
    }

    // Create a clientId symbol that uniquely identify this consumer so that
    // DataProvider which supports it can optimize resources
    this._clientId = this._clientId || Symbol();

    // Create a controller to support aborting request, same controller is used for all child
    // fetch requests
    if (parent == null || this.m_controller == null) {
      this.m_controller = new AbortController();
    }

    // use -1 to fetch all child rows
    var options = { clientId: this._clientId, size: -1, signal: this.m_controller.signal };

    this.signalTaskStart('first fetch');

    var dataProvider = this._getChildDataProvider(parent);
    var dataProviderAsyncIterator = dataProvider.fetchFirst(options)[Symbol.asyncIterator]();
    var promise = dataProviderAsyncIterator.next();

    // new helper function to be called in recursion to fetch all data.
    var helperFunction = function (values) {
      // skip additional fetching if done
      if (values[0].done) {
        return values;
      }
      var nextPromise = dataProviderAsyncIterator.next();
      var fetchMoreData = nextPromise.then(
        function (value) {
          // eslint-disable-next-line no-param-reassign
          values[0].done = value.done;
          // eslint-disable-next-line no-param-reassign
          values[0].value.data = values[0].value.data.concat(value.value.data);
          // eslint-disable-next-line no-param-reassign
          values[0].value.metadata = values[0].value.metadata.concat(value.value.metadata);
          return helperFunction(values);
        },
        function (reason) {
          if (parent != null) {
            self.m_fetchCalls.delete(parent);
          }
          if (errorCallback) {
            errorCallback(reason);
          }
          self._handleFetchError(reason, parentElem);
          self.signalTaskEnd(); // first fetch
        }
      );

      return fetchMoreData;
    };

    Promise.all([promise, enginePromise])
      .then(
        function (values) {
          return helperFunction(values);
        },
        function (reason) {
          if (parent != null) {
            self.m_fetchCalls.delete(parent);
          }
          self._handleFetchError(reason, parentElem);
          self.signalTaskEnd(); // first fetch
        }
      )
      .then(function (values) {
        // values would be undefined for error case
        if (values) {
          // check if content handler has been destroyed already
          if (self.m_widget == null) {
            self.signalTaskEnd(); // first fetch
            return;
          }

          var value = values[0];
          var templateEngine = values[1];

          // check if the request was already aborted
          // ignore to prevent collision with results from the other incoming request
          if (DataCollectionUtils.isFetchAborted(value)) {
            // since we won't be calling fetchEnd, we'll need to make sure the readiness stack
            // is updated
            self.signalTaskEnd();
            return;
          }

          if (templateEngine) {
            // clean nodes generated by templateengine before
            self.cleanItems(templateEngine, parentElem);
          }

          // append loading indicator at the end as needed
          self._handleFetchSuccess(value, parent, parentElem, successCallback, templateEngine);
          self.signalTaskEnd(); // first fetch
        }
      });

    this.signalTaskEnd(); // signal method task end
  };

  /**
   * Promise that is resolved when all fetchChildren calls triggered by a single fetch
   * has been completed.
   * @private
   */
  TreeDataProviderContentHandler.prototype._getAtomicFetchChildPromise = function () {
    var self = this;
    // eslint-disable-next-line no-unused-vars
    return new Promise(function (resolve, reject) {
      self.m_fetchResolve = resolve;
    });
  };

  TreeDataProviderContentHandler.prototype._handleFetchSuccess = function (
    dataObj,
    parent,
    parentElem,
    successCallback,
    templateEngine
  ) {
    var self = this;

    // listview might have been destroyed before fetch success is handled
    if (this.m_widget == null || dataObj.value == null) {
      return;
    }

    this.signalTaskStart('handling successful fetch'); // signal method task start

    // fetch is done
    this.m_fetching = false;
    if (parent != null) {
      this.m_fetchCalls.delete(parent);
    }

    function postProcessing() {
      if (self.m_widget) {
        // if a callback is specified (as it is in the expand case), then invoke it
        if (successCallback != null) {
          successCallback.call(null, parentElem);
        }

        // tracking whether data-oj-context already exists since we don't want to
        // remove it if it wasn't added from here
        let removeOjContext = false;
        if (!parentElem.hasAttribute('data-oj-context')) {
          parentElem.setAttribute('data-oj-context', '');
          removeOjContext = true;
        }
        let busyContext = Context.getContext(parentElem).getBusyContext();
        busyContext
          .whenReady()
          .then(function () {
            if (self.m_widget != null) {
              // calling DataCollectionUtils directly instead of the one
              // on widget since we want to visit all children in this case
              DataCollectionUtils.disableAllFocusableElements(parentElem);
            }
          })
          .finally(function () {
            if (removeOjContext) {
              parentElem.removeAttribute('data-oj-context');
            }
          });

        self.m_widget.renderComplete(false);

        // process any outstanding events
        self._processEventQueue();
      }
    }

    var data = dataObj.value.data;
    var metadata = dataObj.value.metadata;
    var suggestions = 0;
    // we only handle suggestions in the root during initial fetch, and non-card view
    if (!this.isCardLayout() && parent == null) {
      suggestions = this.handleSuggestions(metadata);
    }

    var keys = metadata.map(function (value) {
      return value.key;
    });

    if (data.length === keys.length) {
      var index = 0;
      var fragment = document.createDocumentFragment();
      for (var i = 0; i < data.length; i++) {
        var row = data[i];
        // passing -1 for opt since we know it will be inserted at the end of the parent
        this.addItem(
          fragment,
          -1,
          row,
          this.getMetadata(index, keys[i], row, parentElem),
          templateEngine,
          null,
          metadata[i]
        );

        index += 1;
      }

      // check whether we are still expanding and therefore hold off appending child nodes
      // also, we'll switch this off for NavList since it breaks the drill replace mode
      if (this.m_fetchResolve != null || !this.shouldUseGridRole()) {
        // subtree of what is currently expanding, so we should just be able to add it immediately
        // (the root is still not attached yet)
        $(parentElem).empty();
        parentElem.appendChild(fragment); // @HTMLUpdateOK
        if (!this.shouldUseGridRole()) {
          // NavList case
          postProcessing();
        } else if (successCallback != null) {
          successCallback.call(null, parentElem);
        }
      } else if (this.m_fetchCalls.size > 0) {
        this.m_widget.signalTaskStart('Animating in content');
        this._getAtomicFetchChildPromise().then(
          function () {
            this.animateShowContent(parentElem, fragment, true).then(
              function () {
                if (this.m_widget) {
                  this.m_widget.signalTaskEnd();
                  this.renderSparkles(this.getItems(parentElem, suggestions));
                }
                postProcessing();
              }.bind(this)
            );
          }.bind(this)
        );
      } else {
        this.m_widget.signalTaskStart('Animating in content');
        this.animateShowContent(parentElem, fragment, true).then(
          function () {
            if (this.m_widget) {
              this.m_widget.signalTaskEnd();
              if (suggestions) {
                this.renderSparkles(this.getItems(parentElem, suggestions));
              }
            }
            postProcessing();
          }.bind(this)
        );
      }

      // update aria-colspan on the gridcell representing the group header
      if (this.shouldUseGridRole() && this.isCardLayout() && parent != null && index > 0) {
        var gridcell = parentElem.parentNode.firstElementChild.firstElementChild;
        $(gridcell).attr('aria-colspan', index + 1);
      }
    }
    // check if there's no more outstanding fetch children calls
    if (this.m_fetchCalls.size === 0) {
      if (this.m_fetchResolve != null) {
        this.m_fetchResolve();
        this.m_fetchResolve = null;
      }
    }

    this.m_initialized = true;

    this.signalTaskEnd(); // signal method task end
  };

  /**
   * Creates the context object containing metadata
   * @param {Element} parent the parent element
   * @param {number} index the index
   * @param {Object} key the key
   * @param {Object} data the data
   * @return {Object} the context object
   * @private
   */
  TreeDataProviderContentHandler.prototype.getMetadata = function (index, key, data, parentElem) {
    var context = TreeDataProviderContentHandler.superclass.getMetadata.call(
      this,
      index,
      key,
      data,
      parentElem
    );

    var childDataProvider = this._getChildDataProvider(key);
    context.leaf = childDataProvider === null;
    context.parentKey = null;
    if (parentElem && parentElem !== this.m_root && parentElem.parentElement) {
      context.parentKey = this.GetKey(parentElem.parentElement);
    }
    // walk up to calculate the depth
    var depth = 0;
    var curr = parentElem;
    while (curr && curr !== this.m_root) {
      curr = curr.parentElement.parentElement;
      depth += 1;
    }
    context.depth = depth;

    return context;
  };

  /**
   * Creates a binding context based on context object
   * To be override by different ContentHandler
   * @protected
   */
  TreeDataProviderContentHandler.prototype.GetBindingContext = function (context) {
    var bindingContext = TreeDataProviderContentHandler.superclass.GetBindingContext.call(
      this,
      context
    );
    bindingContext.depth = context.depth;
    bindingContext.leaf = context.leaf;
    bindingContext.parentKey = context.parentKey;

    return bindingContext;
  };

  TreeDataProviderContentHandler.prototype.afterRenderItem = function (
    item,
    context,
    isCustomizeItem
  ) {
    this.signalTaskStart('after rendering an item'); // signal method task start

    TreeDataProviderContentHandler.superclass.afterRenderItem.call(
      this,
      item,
      context,
      isCustomizeItem
    );

    var groupStyleClass = this.m_widget.getGroupStyleClass();
    var itemStyleClass = this.m_widget.getItemStyleClass();
    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(true);
    var groupCollapseStyleClass = this.m_widget.getGroupCollapseStyleClass();
    var collapseClass = this.m_widget.getCollapseIconStyleClass();
    var focusedStyleClass = this.m_widget.getFocusedElementStyleClass();

    // eslint-disable-next-line no-param-reassign
    item = $(item);

    if (context.leaf === false) {
      // check if group item already present
      if (item.get(0).querySelector('.' + groupItemStyleClass) == null) {
        item.children().wrapAll('<div></div>'); // @HTMLUpdateOK
      }

      // collapsed by default
      if (item.hasClass(focusedStyleClass)) {
        item
          .removeClass(focusedStyleClass)
          .children()
          .first()
          .addClass(focusedStyleClass)
          .attr('aria-expanded', 'false');
      } else {
        item
          .children()
          .first()
          .attr('role', 'presentation')
          .find('.' + focusedStyleClass)
          .attr('aria-expanded', 'false');
      }

      var content = item.children().first();
      content.uniqueId().addClass(groupItemStyleClass);

      // add the expand icon
      if (
        this.m_widget.isExpandable() &&
        !(item.hasClass('oj-expanded') || item.hasClass('oj-collapsed'))
      ) {
        item.addClass('oj-collapsed');

        var icon = document.createElement('div');
        $(icon).addClass('oj-component-icon oj-clickable-icon-nocontext').addClass(collapseClass);

        content.prepend(icon); // @HTMLUpdateOK
      }

      if (this.shouldUseGridRole()) {
        content.get(0).removeAttribute('aria-expanded');
        content.removeClass(focusedStyleClass);
        content.attr('role', 'row');
        // prettier-ignore
        content.children().wrapAll( // @HTMLUpdateOK
          "<div role='gridcell' aria-expanded='false' class='oj-listview-cell-element " +
            focusedStyleClass +
            "'></div>"
        );
      }

      // the yet to be expand group element
      // check if group already present
      if (item.get(0).querySelector('.' + groupStyleClass) == null) {
        var groupItem = document.createElement('ul');
        var role;
        if (this.shouldUseGridRole()) {
          if (this.isCardLayout()) {
            role = 'row';
          } else {
            role = 'presentation';
          }
        } else {
          role = 'group';
        }
        $(groupItem).addClass(groupStyleClass).addClass(groupCollapseStyleClass).attr('role', role);
        item.append(groupItem); // @HTMLUpdateOK
      }

      if (this.m_widget.isExpandable()) {
        let elem = this.m_widget.getFocusItem(item);
        elem.attr('aria-describedby', this.m_widget.m_accExpdescId);
      }
    } else if (context.leaf === true) {
      item.addClass(itemStyleClass);

      // if item root (<LI>) is not specified, add a default layout class
      if (!isCustomizeItem && this.m_widget.getItemLayoutStyleClass) {
        item.addClass(this.m_widget.getItemLayoutStyleClass());
      }
    }

    if (this.m_widget._isSelectionEnabled() && this.isSelectable(context)) {
      this.m_widget.getFocusItem(item).attr('aria-selected', false);
    }
    // Add group depth class
    if (context.depth > 0) {
      item.addClass(this.m_widget.getDepthStyleClass(context.depth));
    }
    // callback to widget
    this.m_widget.itemRenderComplete(item[0], context);

    this.signalTaskEnd(); // signal method task end
  };

  TreeDataProviderContentHandler.prototype._handleFetchError = function (status, parentElem) {
    // listview might have been destroyed before fetch error is handled
    if (this.m_widget == null) {
      Logger.info('handleFetchError: widget has already been destroyed');
      return;
    }

    // TableDataSource aren't giving me any error message
    Logger.error(status);

    // turn off fetching if there is an error
    this.m_fetching = false;

    if (parentElem) {
      this._destroySkeletons(parentElem);
    }

    // the above might not have remove initial skeleton if the fetch
    // comes from initial expand all
    var skeletons = this.m_root.querySelector('.oj-listview-initial-skeletons');
    if (skeletons != null) {
      skeletons.parentNode.removeChild(skeletons);
    }

    // show whatever we have so far
    if (this.m_fetchCalls.size === 0) {
      if (this.m_fetchResolve != null) {
        this.m_fetchResolve();
        this.m_fetchResolve = null;
      }
    }

    this.m_widget.renderComplete(true);
  };

  TreeDataProviderContentHandler.prototype.Expand = function (item, successCallback) {
    this.signalTaskStart('expanding an item'); // signal method task start

    var parentKey = this.GetKey(item[0]);
    var parentElem = item.children('ul')[0];
    var showSkeletonTimeout;
    if (this.isSkeletonSupport()) {
      // prettier-ignore
      showSkeletonTimeout = setTimeout( // @HTMLUpdateOK
        function () {
          this._renderExpandSkeletons(parentElem);
        }.bind(this),
        this.m_widget._getShowStatusDelay()
      );
    }

    this._fetchChildren(
      parentKey,
      parentElem,
      function (args) {
        if (showSkeletonTimeout) {
          clearTimeout(showSkeletonTimeout);
        }
        successCallback(args);
        parentElem.classList.remove('oj-listview-skeleton-container');
      },
      function () {
        this._handleFetchError();
      }.bind(this)
    );

    this.m_widget.updateStatusGroupExpandCollapse(true);

    this.signalTaskEnd(); // signal method task end
  };

  TreeDataProviderContentHandler.prototype.Collapse = function (item) {
    // template engine should have already been loaded
    var templateEngine = this.getTemplateEngine();
    if (templateEngine) {
      templateEngine.clean(item.get(0), this.m_widget.GetRootElement().get(0));
    }

    // remove all children nodes
    item.empty();

    this.m_widget.updateStatusGroupExpandCollapse(false);
  };

  /**
   * @protected
   */
  TreeDataProviderContentHandler.prototype.addItemsForModelInsert = function (
    data,
    indexes,
    keys,
    parentKeys,
    isBeforeKeys,
    refKeys,
    metadata
  ) {
    // template engine should have already been loaded
    var templateEngine = this.getTemplateEngine();

    for (var i = 0; i < data.length; i++) {
      this.signalTaskStart('handling model add event for item: ' + keys[i]); // signal add item start

      var parentElem = this.m_root;
      if (parentKeys !== undefined) {
        parentElem = parentKeys[i] == null ? this.m_root : this.FindElementByKey(parentKeys[i]);
        if (parentElem && parentElem !== this.m_root) {
          // take the <ul> inside the <li>
          parentElem = parentElem.lastElementChild;
        }
      }

      // indexes takes precedence
      var index;
      if (indexes != null) {
        index = indexes[i];
      } else {
        index = this.getIndex(refKeys, i);
        if (index > -1) {
          index = isBeforeKeys ? index : index + 1;
        }
      }

      this.addItem(
        parentElem,
        index,
        data[i],
        this.getMetadata(index, keys[i], data[i], parentElem),
        templateEngine,
        this.afterRenderItemForInsertEvent.bind(this),
        metadata != null ? metadata[i] : null
      );

      this.signalTaskEnd(); // signal add item end
    }

    this.m_widget.renderComplete(true);
  };

  /**
   * @protected
   */
  TreeDataProviderContentHandler.prototype.afterRenderItemForInsertEvent = function (
    item,
    context,
    isCustomizeItem
  ) {
    if (context.leaf === false) {
      // if it's a group node, we just need to call afterRenderItem
      this.afterRenderItem(item, context, isCustomizeItem);
    } else {
      TreeDataProviderContentHandler.superclass.afterRenderItemForInsertEvent.call(
        this,
        item,
        context,
        isCustomizeItem
      );
    }
  };

  /**
   * @protected
   */
  TreeDataProviderContentHandler.prototype.removeItem = function (elem, isReinsert) {
    var key = elem.key;
    if (key) {
      this.m_childDataProviders.delete(key);
    }
    TreeDataProviderContentHandler.superclass.removeItem.call(this, elem, isReinsert);
  };

  /**
   * @private
   */
  TreeDataProviderContentHandler.prototype._isExpandedGroupItem = function (item) {
    var drillMode = this.m_widget.GetOption('drillMode');
    return drillMode === 'none' || item.classList.contains('oj-expanded');
  };

  /**
   * @private
   */
  TreeDataProviderContentHandler.prototype._replaceGroupItemCallback = function (
    item,
    context,
    isCustomizeItem,
    restoreFocus
  ) {
    // callback to widget
    if (!this.shouldUseGridRole()) {
      this.afterRenderItem(item, context, isCustomizeItem, restoreFocus);
    } else {
      this.m_widget.itemRenderComplete(item, context);
    }
  };

  /**
   * @private
   */
  TreeDataProviderContentHandler.prototype._replaceGroupItem = function (
    item,
    index,
    data,
    metadata,
    templateEngine,
    restoreFocus
  ) {
    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass(false);
    var groupItem = item.querySelector('.' + groupItemStyleClass);
    var shouldUseGridRole = this.shouldUseGridRole();
    if (groupItem) {
      var cellNode = shouldUseGridRole ? groupItem.firstElementChild : groupItem;
      var contentNode = cellNode.lastElementChild;
      if (contentNode) {
        // explicit clean when inline template is used
        if (templateEngine) {
          templateEngine.clean(groupItem, this.m_widget.GetRootElement().get(0));
        }
        cellNode.removeChild(contentNode);

        // now actually replace the item
        var parentElement = item.parentNode;
        var position = $(parentElement).children().index(item);
        var tagName = this.GetChildElementTagName();
        this._addOrReplaceItem(
          item,
          position,
          parentElement,
          index,
          data,
          metadata,
          templateEngine,
          this._replaceGroupItemCallback.bind(this),
          restoreFocus,
          null,
          function (nodes) {
            for (var i = 0; i < nodes.length; i++) {
              // only NavList supports <li> in group node
              if (nodes[i].tagName === tagName && !shouldUseGridRole) {
                groupItem.innerHTML = nodes[i].innerHTML; // @HTMLUpdateOK
                return true;
              }
              cellNode.appendChild(nodes[i]); // @HTMLUpdateOK
            }
            return false;
          }
        );
      }
    }
  };

  /**
   * @protected
   */
  TreeDataProviderContentHandler.prototype.replaceItem = function (
    item,
    index,
    data,
    metadata,
    templateEngine,
    callback,
    restoreFocus
  ) {
    var key = item.key;
    if (key) {
      this.m_childDataProviders.delete(key);
    }

    if (!metadata.leaf && this._isExpandedGroupItem(item)) {
      this._replaceGroupItem(item, index, data, metadata, templateEngine, restoreFocus);
    } else {
      TreeDataProviderContentHandler.superclass.replaceItem.call(
        this,
        item,
        index,
        data,
        metadata,
        templateEngine,
        callback,
        restoreFocus
      );
    }
  };

  /**
   * Handles granular branch refresh
   * @private
   */
  TreeDataProviderContentHandler.prototype._handleChildRefresh = function (keys) {
    var templateEngine = this.getTemplateEngine();
    var groupStyleClass = this.m_widget.getGroupStyleClass();
    var groupItemStyleClass = this.m_widget.getGroupItemStyleClass();

    keys.forEach(
      function (key) {
        var elem = this.FindElementByKey(key);
        if (elem != null && this._isExpandedGroupItem(elem)) {
          var group = elem.querySelector('.' + groupStyleClass);
          var groupItem = elem.querySelector('.' + groupItemStyleClass);
          if (group != null && groupItem != null) {
            if (templateEngine != null) {
              templateEngine.clean(group, this.m_widget.GetRootElement().get(0));
            }
            group.innerHTML = ''; // @HTMLUpdateOK

            this.m_childDataProviders.delete(key);
            // reset aria-expanded so children gets re-populated
            var ariaExpandedNode = groupItem.querySelector('[aria-expanded]');
            if (ariaExpandedNode) {
              ariaExpandedNode.setAttribute('aria-expanded', 'false'); // @HTMLUpdateOK
            }
            this.m_widget.itemRenderComplete(elem, { key: key, data: null });
          }
        }
      }.bind(this)
    );
  };

  /**
   * @protected
   */
  TreeDataProviderContentHandler.prototype.handleModelRefreshEvent = function (event) {
    if (this.m_root == null) {
      return;
    }

    // granular branch refresh, we don't support granular abort
    if (this.IsReady() && event.detail && event.detail.keys) {
      this._handleChildRefresh(event.detail.keys);
      return;
    }

    // if listview is busy, abort the current request (and all child requests)
    // so that we can start a new one
    if (!this.IsReady() && this.m_controller) {
      const wrapper = this.m_widget.OuterWrapper ?? this.m_widget.ojContext.element[0];
      this.m_controller.abort(DataCollectionUtils.getAbortReason(wrapper));
      this.m_fetching = false;
    }

    this.signalTaskStart('handling model refresh event'); // signal method task start

    // since we are refetching everything, we should just clear out any outstanding model events
    this._clearEventQueue();

    // empty everything (later) and clear cache
    this.m_widget.ClearCache(true);

    // clear cached child DataProviders
    this.m_childDataProviders.clear();

    // reset focus if needed
    this.m_widget.resetFocusBeforeRefresh();

    // fetch data
    this.fetchRows(true);

    this.signalTaskEnd(); // signal method task end
  };

  TreeDataProviderContentHandler.prototype.renderInitialSkeletons = function () {
    // empty out root element before adding skeletons
    if (this.m_superRoot) {
      this.m_root = this.m_superRoot;
      this.m_superRoot = null;
    }
    $(this.m_root).empty();

    // determines how many items needed to fill the viewport
    var height = this.getRootElementHeight();
    var skeletonDimension = this.getDefaultSkeletonDimension();
    var count = 0;
    if (skeletonDimension.width > 0 && skeletonDimension.height > 0) {
      var skeletonSetHeight =
        skeletonDimension.height * (1 + TreeDataProviderContentHandler.NUM_CHILD_SKELETONS); // one parent + 3 children
      count = Math.ceil(height / skeletonSetHeight);
    }

    var container = document.createElement('li');
    container.setAttribute('role', 'presentation');
    container.classList.add('oj-listview-initial-skeletons');
    var list = document.createElement('ul');
    list.setAttribute('role', 'presentation');
    list.classList.add(this.m_widget.getGroupStyleClass());
    list.classList.add('oj-listview-skeleton-container');
    for (var i = 0; i < count; i++) {
      list.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK
      var parent = document.createElement('li');
      parent.setAttribute('role', 'presentation');
      var children = document.createElement('ul');
      children.setAttribute('role', 'presentation');
      children.classList.add('oj-listview-child-skeleton');
      parent.appendChild(children);
      children.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK
      children.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK
      children.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK
      list.appendChild(parent);
    }
    container.appendChild(list); // @HTMLUpdateOK

    this.m_root.appendChild(container); // @HTMLUpdateOK
  };

  TreeDataProviderContentHandler.prototype._renderExpandSkeletons = function (elem) {
    // make sure maxHeight wasn't set
    // eslint-disable-next-line no-param-reassign
    elem.style.maxHeight = 'none';
    for (var i = 0; i < TreeDataProviderContentHandler.NUM_CHILD_SKELETONS; i++) {
      elem.appendChild(this.createSkeletonItem()); // @HTMLUpdateOK
    }
    elem.classList.add('oj-listview-skeleton-container');
    elem.setAttribute('data-oj-initial-height', this._getExpandSkeletonHeight(elem));
  };

  TreeDataProviderContentHandler.prototype._destroySkeletons = function (elem) {
    $(elem).empty();
    elem.classList.remove('oj-listview-skeleton-container');
  };

  TreeDataProviderContentHandler.prototype._getExpandSkeletonHeight = function (elem) {
    if (this.m_expandSkeletonHeight == null || this.m_expandSkeletonHeight === 0) {
      this.m_expandSkeletonHeight = elem.offsetHeight;
    }
    return this.m_expandSkeletonHeight;
  };

  // mixin to inject createKeyMap and createKeySet functions to ContentHandlers
  var ContentHandlerMixin = function () {
    this.createKeyMap = function (initialMap) {
      var map = new KeyMap();
      if (initialMap) {
        initialMap.forEach(function (value, key) {
          map.set(key, value);
        });
        return map;
      }
      return map;
    };

    this.createKeySet = function (initialSet) {
      return new ojkeyset.KeySet(initialSet);
    };
  };

  ContentHandlerMixin.call(StaticContentHandler.prototype);
  ContentHandlerMixin.call(TreeDataProviderContentHandler.prototype);
  ContentHandlerMixin.call(DataProviderScroller.IteratingDataProviderContentHandler.prototype);

  /**
   * Default ExpandedKeySet class
   * Need a way to distinguish ExpandedKeySet set by application vs default one created by ListView
   * @extends {ExpandedKeySet}
   * @constructor
   * @ignore
   */
  const _ojListViewExpandedKeySet = function () {
    _ojListViewExpandedKeySet.superclass.constructor.call(this);
  };

  // Subclass from KeySet
  oj._registerLegacyNamespaceProp('_ojListViewExpandedKeySet', _ojListViewExpandedKeySet);
  oj.Object.createSubclass(_ojListViewExpandedKeySet, oj.ExpandedKeySet, 'ListViewExpandedKeySet');

  /**
   * todo: create common utility class between combobox and listview
   * @private
   */
  var _ListViewUtils = {
    clazz: function (SuperClass, methods) {
      var constructor = function () {};
      oj.Object.createSubclass(constructor, SuperClass, '');
      constructor.prototype = $.extend(constructor.prototype, methods);
      return constructor;
    }
  };

  /**
   * @export
   * @class oj._ojListView
   * @classdesc Listview
   * @constructor
   * @ignore
   * @private
   */
  const _ojListView = _ListViewUtils.clazz(
    Object,
    /** @lends oj._ojListView.prototype */ {
      // constants for key codes, todo: move to ListViewUtils
      LEFT_KEY: 37,
      RIGHT_KEY: 39,
      DOWN_KEY: 40,
      UP_KEY: 38,
      TAB_KEY: 9,
      ENTER_KEY: 13,
      ESC_KEY: 27,
      F2_KEY: 113,
      SPACE_KEY: 32,

      // constants for disclosure state
      /** @protected **/
      STATE_EXPANDED: 0,
      /** @protected **/
      STATE_COLLAPSED: 1,
      /** @protected **/
      STATE_NONE: 2,

      // minimum height of an item
      MINIMUM_ITEM_HEIGHT: 20,

      /**
       * Initialize the listview at creation
       * Invoked by widget
       */
      init: function (opts) {
        var self = this;

        this.readinessStack = [];
        this.element = opts.element;
        this.ojContext = opts.ojContext;
        this.OuterWrapper = opts.OuterWrapper;
        this.options = opts;

        this.element.uniqueId().addClass(this.GetStyleClass() + ' oj-component-initnode');

        if (this.OuterWrapper) {
          this.element[0].setAttribute('data-oj-context', '');
        }
        this.signalTaskStart('Initializing'); // Move component out of ready state; component is initializing. End in afterCreate()

        this._rootTabIndexSet = false;
        this.SetRootElementTabIndex();
        var dndContext = this.GetDnDContext();
        // listens for dnd events if ListViewDndContext is defined
        if (dndContext) {
          this.m_dndContext = dndContext;

          this.ojContext._on(this.element, {
            dragstart: function (event) {
              return dndContext._handleDragStart(event);
            },
            dragenter: function (event) {
              return dndContext._handleDragEnter(event);
            },
            dragover: function (event) {
              return dndContext._handleDragOver(event);
            },
            dragleave: function (event) {
              return dndContext._handleDragLeave(event);
            },
            dragend: function (event) {
              // mouseup will not be invoked on drag so resetting it to false.
              self.m_preActive = false;
              return dndContext._handleDragEnd(event);
            },
            drag: function (event) {
              return dndContext._handleDrag(event);
            },
            drop: function (event) {
              // mouseup will not be invoked on drag so resetting it to false.
              self.m_preActive = false;
              return dndContext._handleDrop(event);
            }
          });
        }
        this._touchStartListener = function (event) {
          // convert to jQuery event for downstream code expecting it
          if (!event.originalEvent) {
            // eslint-disable-next-line no-param-reassign
            event = $.Event(event);
          }
          self.touchStartEvent = event;
          self.HandleMouseDownOrTouchStart(event);
        };
        if (this.ojContext._IsCustomElement()) {
          this.element[0].addEventListener('touchstart', this._touchStartListener, { passive: true });
        } else {
          this.ojContext._on(this.element, {
            touchstart: this._touchStartListener
          });
        }
        if (this.ShouldUseGridRole() && this.OuterWrapper != null) {
          this.ojContext._on(this.OuterWrapper, {
            mousedown: function (event) {
              // JET-62332 spot focus lost to body when mousedown the region e.g. between items or the padding around listview,
              // because these regions are not focusable i.e. no tabindex.
              if (event.target.closest('oj-list-view [tabIndex]') === null) {
                // prevent focus lost
                event.preventDefault();
                var item = self.FindItem(event.target);
                if (item && item.length > 0) {
                  // if event target is between items
                  // if oj-list-view has no focus, we will focus item, otherwise we will let
                  // the mousedown event listener on ul element handle that
                  if (!self.OuterWrapper.contains(document.activeElement)) {
                    self._focusItem(item, event);
                  }
                } else {
                  // if event target is within listview, but not around items, e.g. the padding
                  var active = self.m_active && self.m_active.elem;
                  if (active == null && self.element.attr('tabIndex') === '0') {
                    self.element.focus();
                  } else if (active != null) {
                    self._makeFocusable(active);
                    self.HighlightActive();
                    self._focusItem(active);
                  }
                }
              }
            }
          });
        }
        this.ojContext._on(this.element, {
          click: function (event) {
            self.HandleMouseClick(event);
            self.touchStartEvent = null;
          },
          touchend: function (event) {
            if (self.touchStartEvent && event.changedTouches.length) {
              var overElem = document.elementFromPoint(
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
              );
              if (overElem !== self.touchStartEvent.target) {
                self.touchStartEvent = null;
              }
            }
            self.HandleTouchEndOrCancel(event);
          },
          touchcancel: function (event) {
            self.touchStartEvent = null;
            self.HandleTouchEndOrCancel(event);
          },
          mousedown: function (event) {
            if (event.button === 0) {
              if (!self._recentTouch()) {
                self.HandleMouseDownOrTouchStart(event);
              }
            } else {
              // on right click we should prevent focus from shifting to first item
              self.m_preActive = true;
            }
          },
          mouseup: function (event) {
            self._handleMouseUpOrPanMove(event);
            self.m_preActive = false;
          },
          mouseout: function (event) {
            self._handleMouseOut(event);
          },
          mouseover: function (event) {
            self._handleMouseOver(event);
          },
          keydown: function (event) {
            self.HandleKeyDown(event);
          },
          keyup: function (event) {
            self.HandleKeyUp(event);
          },
          ojpanmove: function (event) {
            self._handleMouseUpOrPanMove(event);
          }
        });
        this.ojContext._on(this.ojContext.element, {
          focus: function (event) {
            self.HandleFocus(event);
          },
          blur: function (event) {
            self.HandleBlur(event);
          }
        });

        // in Firefox, need to explicitly make list container not focusable otherwise first tab will focus on the list container
        // don't do it for tabbar/navlist
        if (
          DataCollectionUtils.isFirefox() &&
          this._isComponentFocusable() &&
          this.ShouldUseGridRole()
        ) {
          this._rootTabIndexSet = true;
          this.getListContainer().attr('tabIndex', -1);
        }

        // for item focus mode (aka roving focus), we'll need to use focusout handler instead
        // of blur because blur doesn't bubble
        this.ojContext._on(this.ojContext.element, {
          focusin: function (event) {
            self.HandleFocus(event);
          },
          focusout: function (event) {
            self.HandleFocusOut(event);
          }
        });

        this.ojContext._focusable({
          applyHighlight: self.ShouldApplyHighlight(),
          recentPointer: self.RecentPointerCallback(),
          setupHandlers: function (focusInHandler, focusOutHandler) {
            self._focusInHandler = focusInHandler;
            self._focusOutHandler = focusOutHandler;
          }
        });
      },

      /**
       * Whether ListView is available or offline/detached
       * Invoked by widget
       */
      isAvailable: function () {
        return this.m_contentHandler != null;
      },

      /**
       * Initialize ContentHandler and any post processes
       * @private
       */
      _initContentHandler: function () {
        this.signalTaskStart('Initialize ContentHandler'); // signal method task start

        var self = this;
        var postProcess = function (contentHandler) {
          self.m_contentHandler = contentHandler;

          // kick start rendering
          contentHandler.RenderContent();

          self.signalTaskEnd(); // signal method task end

          // register a resize listener
          self._registerResizeListener(self.getListContainer()[0]);
          // register a scroll/scrollwheel listener
          self._registerScrollHandler();
        };

        var data = this.GetOption('data');
        if (data != null) {
          this.CreateDataContentHandler(data).then(postProcess, function () {
            self.signalTaskEnd(); // signal method task end
          });
        } else {
          // remove existing no data content now before StaticContentHandler modifies content
          this._removeNoData();
          // StaticContentHandler will handle cases where children are invalid or empty
          postProcess(new StaticContentHandler(this, this.element[0]));
        }
      },

      /**
       * Setup resources on listview after connect
       * Invoked by widget
       */
      setupResources: function () {
        this.ojContext.document.bind(
          'touchend.ojlistview touchcancel.ojlistview',
          this.HandleTouchEndOrCancel.bind(this)
        );
        // sync selection with KeySet, including the case where selection option
        // was updated after detach
        this._syncSelectionWithKeySet();

        // setup selection change listener to support browser selection.
        this._setupSelectionChangedListener();

        this._initContentHandler();
        this._updateGridlines();
      },

      /**
       * Release resources held by listview after disconnect
       * Invoked by widget
       */
      releaseResources: function () {
        this.ojContext.document.off('.ojlistview');

        this.DestroyContentHandler(true);
        this._unregisterResizeListener(this.getListContainer());
        this._unregisterScrollHandler();
        this._clearSelectionChangedListener();
        this.SetRootElementTabIndex();
        this._resetState();
      },

      /**
       * @private
       */
      _isTextSelectionEnabled: function () {
        const isRedwood = ThemeUtils.parseJSONFromFontFamily('oj-theme-json').behavior === 'redwood';
        return this.ShouldUseGridRole() && isRedwood;
      },

      /**
       * Sets up context menu
       * Invoked by widget
       */
      setupContextMenu: function () {
        const options = {};
        if (this._isTextSelectionEnabled()) {
          options.allowBrowserContextMenu = true;
        }
        return options;
      },

      /**
       * Whether the selected option is exposed at the component
       * @private
       */
      _isSelectedOptionExposed: function () {
        // currently this is override by NavList, always true for ListView
        return this.ShouldUseGridRole();
      },

      /**
       * Sync up legacy selection with KeySet during initialization
       * @private
       */
      _syncSelectionWithKeySet: function () {
        var selection = this.GetOption('selection');
        var selected = this.GetOption('selected');

        // first check if selected is specified and sync that up with selection
        // if selected option is not exposed then we don't need to sync selected with selection
        if (
          this._isSelectedOptionExposed() &&
          selected &&
          (selected.isAddAll() || (selected.values && selected.values().size > 0))
        ) {
          selection = [];
          if (selected.isAddAll()) {
            selection.inverted = true;
            selected.deletedValues().forEach(function (key) {
              selection.push(key);
            });
          } else {
            selected.values().forEach(function (key) {
              selection.push(key);
            });
          }

          this.SetOption('selection', selection, {
            _context: {
              internalSet: true
            },
            changed: true
          });

          return;
        }

        // now sync selected with selection
        var needsUpdate = false;

        // NavList do not have this property, need to initialize it
        if (selected == null) {
          selected = new ojkeyset.KeySetImpl();
          needsUpdate = true;
        }

        // detect if it's out of sync
        if (selection.length > 0 && selected.values && selected.values().size === 0) {
          selected = selected.add(selection);
          needsUpdate = true;
        }

        if (needsUpdate) {
          this.SetOption('selected', selected, {
            _context: {
              internalSet: true
            },
            changed: true
          });
        }
      },

      /**
       * Sets up selection change event listener.
       * @private
       */
      _setupSelectionChangedListener: function () {
        this._clearSelectionChangedListener();
        if (this._isTextSelectionEnabled() && !DataCollectionUtils.isIos()) {
          this._browserSelectionChangeListener = () => {
            const selection = document.getSelection();
            if (
              selection.type === 'Range' ||
              (selection.anchorNode !== selection.focusNode &&
                selection.anchorOffset !== selection.focusOffset)
            ) {
              this._allowSelectionOnClick = false;
            }
          };
          document.addEventListener('selectionchange', this._browserSelectionChangeListener, {
            passive: true
          });
        }
      },

      /**
       * Clears selection change event listener.
       * @private
       */
      _clearSelectionChangedListener: function () {
        if (this._browserSelectionChangeListener != null) {
          document.removeEventListener('selectionchange', this._browserSelectionChangeListener, {
            passive: true
          });
          delete this._browserSelectionChangeListener;
          delete this._allowSelectionOnClick;
        }
      },

      /**
       * Initialize the listview after creation
       * Invoked by widget
       */
      afterCreate: function () {
        this._buildList();
        this.signalTaskEnd(); // resolve component initializing task. Started in init()
      },

      /**
       * @private
       */
      _isAnimateCards: function () {
        return (
          this.isCardDisplayMode() && this.m_contentHandler && !this.m_contentHandler.IsHierarchical()
        );
      },

      /**
       * Redraw the entire list view after having made some external modifications.
       * Invoked by widget
       */
      refresh: function () {
        var cards = this.element[0].querySelectorAll('.oj-listview-card');
        if (cards.length > 0) {
          var self = this;
          this.signalTaskStart('Exit animation');
          this._applyExitAnimation(cards).then(function () {
            self._refresh();
            self.signalTaskEnd();
          });
        } else {
          this._refresh();
        }
      },

      /**
       * @private
       */
      _applyExitAnimation(cards) {
        var self = this;
        var promise;
        cards.forEach(function (card) {
          promise = self.StartAnimation(card, 'cardExit');
        });

        // promise should never be null since cards must be non-empty
        return promise;
      },

      /**
       * @private
       */
      _refresh: function () {
        // reset content, wai aria properties, and ready state
        this._resetInternal();

        this.signalTaskStart('Refresh'); // signal method task start

        // set the wai aria properties
        this.SetAriaProperties();

        // recreate the content handler
        this._initContentHandler();

        // update top/bottom gridlines
        this._updateGridlines();

        // if active element is inside an item, we'll need to shift focus to
        // the root otherwise focus is lost when all items are removed
        this.resetFocusBeforeRefresh();

        this.signalTaskEnd(); // signal method task end
      },

      /**
       * Invoked before refresh, including DataProviderRefresh event
       */
      resetFocusBeforeRefresh: function () {
        this.m_active = null;
        this.SetRootElementTabIndex();
        if (this.element[0].contains(document.activeElement)) {
          this.element[0].focus();
        }
      },

      /**
       * Returns a Promise that resolves when the component is ready, i.e. after data fetching, rendering, and animations complete.
       * Invoked by widget
       * @return {Promise} A Promise that resolves when the component is ready.
       */
      whenReady: function () {
        return this.readyPromise;
      },

      /**
       * Destroy the list view
       * Invoked by widget
       */
      destroy: function () {
        this.element.removeClass(this.GetStyleClass() + ' oj-component-initnode');

        this._unregisterResizeListener(this.getListContainer());
        this._resetInternal();

        //  - DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout
        DomUtils.unwrap(this.element, this.getListContainer());
      },

      /**
       * Returns true if ListView should handle key based scrollPosition, false otherwise.
       */
      _isScrollToKey: function () {
        var scrollToKey = this.GetOption('scrollToKey');
        if (scrollToKey === 'never') {
          return false;
        } else if (scrollToKey === 'always') {
          return true;
        }

        var data = this.GetOption('data');
        if (data == null || !oj.DataProviderFeatureChecker.isDataProvider(data)) {
          return true;
        } else if (data.getCapability) {
          var capability = data.getCapability('fetchFirst');
          if (capability && capability.iterationSpeed === 'immediate') {
            return true;
          }
        }
        return false;
      },

      /**
       * Adjust the value of scrollPosition based on the value from scrollPositionPolicy
       */
      adjustScrollPositionValueOnFetch: function () {
        var scrollPosition =
          this.GetOption('scrollPosition') == null ? {} : this.GetOption('scrollPosition');
        var selection = this.GetOption('selection');

        if (this._isSelectionEnabled() && selection.length > 0 && this._isScrollToKey()) {
          // use selection anchor if available
          if (this.m_selectionFrontier != null && this.m_selectionFrontier.length > 0) {
            scrollPosition.key = this.GetKey(this.m_selectionFrontier[0]);
          } else {
            // selection is programmatically set
            scrollPosition.key = selection[0];
          }
        } else {
          // remain at the top
          scrollPosition.y = 0;
          scrollPosition.key = null;
          scrollPosition.index = 0;
        }
        scrollPosition.x = 0;
        scrollPosition.offsetX = 0;
        scrollPosition.offsetY = 0;

        // explicitly set changed to false so option change will not be triggered, syncScrollPosition after rendered will
        // complete the scrollPosition value and fire the option change event
        this.SetOption('scrollPosition', scrollPosition, {
          _context: {
            internalSet: true
          },
          changed: false
        });
      },

      /**
       * Force busy state to be resolve and flush the readiness stack
       * @private
       */
      _clearBusyState: function () {
        if (this.readinessStack && this.readinessStack.length > 0) {
          Logger.warn(
            'ListView did not end with a clean state, this could happen if ListView is detached before fetch is complete.  State: ' +
              this.readinessStack
          );

          // this should resolve all the Promises, safe to assume the Promises should already been resolve if readinessStack is empty
          while (this.readinessStack.length > 0) {
            this.signalTaskEnd();
          }
        }
      },

      /**
       * Remove any wai-aria properties and listview specific attributes.
       * Reset anything done by the content handler.
       * @private
       */
      _resetInternal: function () {
        this.UnsetAriaProperties();
        this._cleanupTabbableElementProperties(this.element);
        this.DestroyContentHandler();
        this._resetState();
      },

      /**
       * Reset internal state and cache
       * @private
       */
      _resetState: function () {
        this.m_active = null;
        this.m_isExpandAll = null;
        this.m_disclosing = null;
        this.m_itemHeight = null;
        this.m_keyElemMap = null;
        this.m_clientHeight = null;
        this.m_scrollHeight = null;
        this.m_clientWidth = null;
        this.m_scrollWidth = null;
        this.m_closestParent = null;
        this.m_gridlinesVisible = null;
        this.m_gridlinePlaceholder = null;
        this.m_scroller = null;
        this.m_initialSelectionStateValidated = null;
        this.m_validatedSelectedKeyData = null;
        this.m_selectionFrontier = null;
        this.m_initialCardAnimationPromise = null;

        this.ClearCache();
        this._clearFocusoutTimeout();
        this._clearFocusoutBusyState();
        this._clearScrollPosBusyState();

        // give dnd context a chance to clear internals
        if (this.m_dndContext != null) {
          this.m_dndContext.reset();
        }
      },

      /**
       * Called when listview root element is re-attached to DOM tree.
       * Invoke by widget
       */
      notifyAttached: function () {
        // make sure component is not destroyed and is not fetching
        if (this.m_contentHandler != null && this.m_contentHandler.IsReady()) {
          // restore scroll position as needed since some browsers reset scroll position
          this.syncScrollPosition();

          // call ContentHandler in case for example fetch is needed
          this.m_contentHandler.notifyAttached();
        }
      },

      /**
       * In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content,
       * so for detached content only, we must use this hook to remove the focus and hover classes.
       * Invoke by widget.
       */
      notifyDetached: function () {
        // Remove focus/hover/active style classes when listview element got detached from document.
        // For details see related button .
        this.getListContainer().removeClass('oj-focus-ancestor');

        if (this.m_active != null) {
          $(this.m_active.elem).removeClass('oj-focus oj-focus-highlight');
        }

        if (this.m_hoverItem != null) {
          this._unhighlightElem(this.m_hoverItem, 'oj-hover');
        }
      },

      /**
       * Called when application programmatically change the css style so that the ListView becomes visible
       */
      notifyShown: function () {
        // make sure component is not destroyed and is not fetching
        if (this.m_contentHandler != null && this.m_contentHandler.IsReady()) {
          // restore scroll position as needed since some browsers reset scroll position
          this.syncScrollPosition();
          // clears the accessibility information in status when listviews goes from
          // hidden to shown
          this._clearAccInfoText();
          // call ContentHandler in case for example fetch is needed
          this.m_contentHandler.notifyShown();
        }
      },

      /**
       * Return the subcomponent node represented by the documented locator attribute values.
       * Invoked by widget
       * @param {Object} locator An Object containing at minimum a subId property
       *        whose value is a string, documented by the component, that allows
       *         the component to look up the subcomponent associated with that
       *        string.  It contains:<p>
       *        component: optional - in the future there may be more than one
       *        component contained within a page element<p>
       *        subId: the string, documented by the component, that the component
       *        expects in getNodeBySubId to locate a particular subcomponent
       * @returns {Array.<(Element|null)>|Element|null} the subcomponent located by the subId string passed
       *          in locator, if found.<p>
       */
      getNodeBySubId: function (locator) {
        var key;

        if (locator == null) {
          return this.element[0];
        }

        var subId = locator.subId;
        if (subId === 'oj-listview-disclosure' || subId === 'oj-listview-icon') {
          key = locator.key;
          if (key != null) {
            var item = this.FindElementByKey(key);
            if (item != null) {
              // this should be the anchor
              var anchor = $(item).find('.oj-clickable-icon-nocontext').first();
              if (this._isExpandCollapseIcon(anchor)) {
                return anchor.get(0);
              }
            }
          }
        } else if (subId === 'oj-listview-item') {
          key = locator.key;
          if (key != null) {
            return this.FindElementByKey(key);
          }
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      /**
       * Returns the subId locator for the given child DOM node.
       * Invoked by widget
       * @param {!Element} node - child DOM node
       * @return {Object|null} The subId for the DOM node, or null when none is found.
       */
      getSubIdByNode: function (node) {
        // check to see if it's expand/collapse icon
        if (node != null && this._isExpandCollapseIcon(node)) {
          var item = this.FindItem(node);
          if (item != null && item.length > 0) {
            var key = this.GetKey(item[0]);
            if (key != null) {
              return { subId: 'oj-listview-disclosure', key: key };
            }
          }
        }

        return null;
      },

      /**
       * Returns an object with context for the given child DOM node.
       * This will always contain the subid for the node, defined as the 'subId' property on the context object.
       * Additional component specific information may also be included. For more details on returned objects, see context objects.
       * Invoked by widget
       *
       * @param {!Element} node the child DOM node
       * @returns {Object|null} the context for the DOM node, or null when none is found.
       */
      getContextByNode: function (node) {
        var item = this.FindItem(node);
        if (item != null && item.length > 0) {
          var key = this.GetKey(item[0]);
          if (key != null) {
            var parent = item.parent();
            var index = parent.children('.' + this.getItemElementStyleClass()).index(item);
            var context = { subId: 'oj-listview-item', key: key, index: index };

            // group item should return the li
            if (parent.get(0) !== this.element.get(0)) {
              context.parent = parent.parent().get(0);
            }

            // check if it's a group item
            if (item.children().first().hasClass(this.getGroupItemStyleClass())) {
              context.group = true;
            } else {
              context.group = false;
            }

            return context;
          }
        }

        return null;
      },

      /**
       * Return the raw data for an item in ListView.
       * Invoked by widget
       *
       * @param {Object} context the context of the item to retrieve raw data.
       * @param {any=} context.key The key of the item.  If both index and key are specified, then key takes precedence.
       * @param {number=} context.index the index of the item relative to its parent.
       * @param {Element=} context.parent the parent node, not required if parent is the root.
       * @returns {any} data for the item.  Returns null if the item is not available locally.  Returns the item element if static HTML is used as data.
       */
      getDataForVisibleItem: function (context) {
        var item;
        var key = context.key;

        // key takes precedence
        if (key != null) {
          item = this.FindElementByKey(key);
        }

        // if we can't find the item with key, try to use index, if specified
        if (item == null) {
          var index = context.index;
          var parent = context.parent;

          if (parent == null) {
            // use the root element
            parent = this.element.get(0);
            // If contex.parent is undefined, after getting the root element, for card display
            // we need to find the appropriate group element
            if (this.isCardDisplayMode()) {
              parent = parent.querySelector('.' + this.getGroupStyleClass());
            }
          } else {
            // find the appropriate group element
            parent = $(parent)
              .children('ul.' + this.getGroupStyleClass())
              .first();
          }

          item = $(parent).children('li').get(index);
        }

        if (item != null && $(item).hasClass(this.getItemElementStyleClass())) {
          return this._getDataForItem(item);
        }

        return null;
      },

      /**
       * Retrieve data stored in dom
       * @param {Element} item
       * @return {any} data for item
       * @private
       */
      _getDataForItem: function (item) {
        // if static HTML, returns the item's dom element
        if (this.GetOption('data') == null) {
          return item;
        }

        return $.data(item, 'data');
      },

      /**
       * Retrieve metadata stored in dom
       * @param {Element} item
       * @return {any} data for item
       * @private
       */
      _getMetadataForItem: function (item) {
        return $.data(item, 'metadata');
      },

      /**
       * To be override by NavList
       * @protected
       */
      ShouldRegisterResizeListener: function (element) {
        return (
          element &&
          this.m_contentHandler &&
          this.m_contentHandler.HandleResize &&
          this.m_contentHandler.shouldHandleResize &&
          this.m_contentHandler.shouldHandleResize()
        );
      },

      /**
       * Unregister event listeners for resize the container DOM element.
       * @param {Element} element  DOM element
       * @private
       */
      _unregisterResizeListener: function (element) {
        if (element && this._resizeHandler) {
          // remove existing listener
          DomUtils.removeResizeListener(element, this._resizeHandler);
        }
      },

      /**
       * Register event listeners for resize the container DOM element.
       * @param {Element} element  DOM element
       * @private
       */
      _registerResizeListener: function (element) {
        this._unregisterResizeListener(element);

        // register resize listener if needed
        if (this.ShouldRegisterResizeListener(element)) {
          if (this._resizeHandler == null) {
            this._resizeHandler = this.HandleResize.bind(this);
          }

          DomUtils.addResizeListener(element, this._resizeHandler);
        }
      },

      /**
       * Invoked by ContentHandler
       */
      disableResizeListener: function () {
        var container = this.getListContainer()[0];
        this._unregisterResizeListener(container);
      },

      /**
       * Invoked by ContentHandler
       */
      enableResizeListener: function () {
        var container = this.getListContainer()[0];
        this._registerResizeListener(container);
      },

      /**
       * Returns DnD Context, needed to override in navigationlist
       * @protected
       */
      GetDnDContext: function () {
        // if dnd is not enabled, we should not do anything also even if ojlistviewdnd is required
        var dndOptions = this.GetOption('dnd');
        if (
          dndOptions === null ||
          (dndOptions.drag === null &&
            dndOptions.drop === null &&
            dndOptions.reorder &&
            dndOptions.reorder.items === 'disabled')
        ) {
          return undefined;
        }

        if (typeof oj.ListViewDndContext !== 'undefined') {
          return new oj.ListViewDndContext(this);
        }
        return undefined;
      },

      /**
       * The resize handler.
       * @param {number} width the new width
       * @param {number} height the new height
       * @private
       */
      HandleResize: function (width, height) {
        if (
          width > 0 &&
          height > 0 &&
          this.m_contentHandler != null &&
          this.m_contentHandler.HandleResize
        ) {
          this.m_contentHandler.HandleResize(width, height);
        }

        this.m_clientHeight = null;
        this.m_scrollHeight = null;
        this.m_clientWidth = null;
        this.m_scrollWidth = null;
      },

      /**
       * Whether focus highlight should be applied
       * @return {boolean} true if should apply focus highlight, false otherwise
       * @protected
       */
      ShouldApplyHighlight: function () {
        return true;
      },

      /**
       * check Whether recent pointer acivity happened or not.
       * Only used for sliding navlist to avoid focus ring on new focusable item
       * after completing expand/collapse animation.
       * @protected
       */
      RecentPointerCallback: function () {
        return function () {
          return false;
        };
      },

      /**
       * Whether ListView should refresh if certain option is updated
       * @param {Object} options the options to check
       * @return {boolean} true if should refresh, false otherwise
       * @protected
       */
      ShouldRefresh: function (options) {
        return (
          options.data != null ||
          options.drillMode != null ||
          options.groupHeaderPosition != null ||
          options.item != null ||
          options.scrollPolicy != null ||
          options.scrollPolicyOptions != null ||
          options.gridlines != null ||
          options.display != null
        );
      },

      /**
       * Returns true if value is a KeySet, false otherwise
       * @private
       */
      _isKeySet: function (value) {
        return (
          value.isAddAll !== undefined &&
          (value.values !== undefined || value.deletedValues !== undefined)
        );
      },

      /**
       * Returns true if key is expandable, false otherwise
       * @private
       */
      _shouldExpand: function (key, expanded) {
        if (this._isKeySet(expanded)) {
          return expanded.has(key);
        } else if (!this.ojContext._IsCustomElement() && expanded === 'all') {
          return true;
        } else if (Array.isArray(expanded)) {
          return expanded.indexOf(key) > -1;
        }
        return false;
      },

      /**
       * Sets multiple options
       * Invoke by widget
       * @param {Object} options the options object
       * @param {Object} flags additional flags for option
       * @return {boolean} true to refresh, false otherwise
       */
      // eslint-disable-next-line no-unused-vars
      setOptions: function (options, flags) {
        if (this.ShouldRefresh(options)) {
          // data updated, need to refresh
          // we still need to handle conversion of legacy selection value
          if (options.selection != null && options.selected == null) {
            this.HandleSelectionOption(options);
          }
          return true;
        }

        if (options.expanded != null) {
          // should only apply if data is hierarchical
          // q: could expanded be change if drillMode is 'expanded'?
          if (this.m_contentHandler.IsHierarchical()) {
            // clear collapsed items var
            this._collapsedKeys = undefined;

            var expanded = options.expanded;

            this.signalTaskStart('Set expanded option'); // signal task start

            // itemRenderComplete would check expanded option to expand nodes as needed
            // however, since options has not been updated yet this will cause previous
            // expanded nodes to expand
            // an option would be to clear the expanded option to null when doing collapseAll
            // but the issue is that optionChange would be fired AND even if we can suppress
            // the optionChange event, when the actual optionChange event is fired, the
            // previousValue param would be wrong (it would be null)
            // so instead we'll use to flag so that itemRenderComplete would detect and ignore
            // the expanded option
            this._ignoreExpanded = true;

            try {
              var selector = '.' + this.getGroupItemStyleClass();
              var groupItems = this.element.find(selector);
              for (var i = 0; i < groupItems.length; i++) {
                var groupItem = groupItems[i];
                var key = this.GetKey(groupItem.parentNode);
                var expand = this._shouldExpand(key, expanded);
                if (expand) {
                  this.expandKey(key, true, true, true, false);
                } else {
                  this.collapseKey(key, true, true, false);
                }
              }
            } finally {
              this._ignoreExpanded = undefined;

              this.signalTaskEnd(); // signal task end
            }
          }
        }

        if (options.currentItem != null) {
          var elem = this.FindElementByKey(options.currentItem, true);
          if (elem != null) {
            elem = $(elem);
            if (!this.SkipFocus(elem)) {
              var active = document.activeElement;
              // update tab index and focus only if listview currently has focus
              if (active && this.element.get(0).contains(active)) {
                this.ActiveAndFocus(elem, null);
              } else {
                // update internal state only
                this._setActive(elem, null, true);
              }
            }
          }
        } else if (options.currentItem === null) {
          // currentItem is deliberately set to null if this case is entered; deliberately clear active element and its focus
          this.UnhighlightActive();
          if (this.m_active && this.m_active.elem) {
            this.m_active.elem.get(0).classList.remove('oj-listview-current-item');
          }
          this.m_active = null;
          this.SetRootElementTabIndex();
        }
        this.HandleSelectionOption(options);

        if (options.selectionMode != null) {
          // reset wai aria properties
          this.SetAriaProperties();

          // update aria-selected on item
          this.UpdateItemAriaProperties(options.selectionMode);
        }

        if (options.scrollTop != null) {
          var scroller = this._getScroller();
          var pos = options.scrollTop;
          if (pos != null && !isNaN(pos)) {
            scroller.scrollTop = pos;
          }
        }

        if (options.scrollPosition != null) {
          this.syncScrollPosition(options.scrollPosition);
          // remove it so it doesn't trigger an option change
          // eslint-disable-next-line no-param-reassign
          delete options.scrollPosition;
        }

        // if reorder switch to enabled/disabled, we'll need to make sure any reorder styling classes are added/removed from focused item
        if (
          this._shouldDragSelectedItems() &&
          this.m_active != null &&
          options.dnd != null &&
          options.dnd.reorder != null
        ) {
          if (options.dnd.reorder.items === 'enabled') {
            this.m_dndContext._setItemDraggable(this.m_active.elem);
          } else if (options.dnd.reorder.items === 'disabled') {
            this.m_dndContext._unsetItemDraggable(this.m_active.elem);
          }
        }

        return false;
      },
      /**
       * @private
       */
      _isFirstSelectedItem: function (key) {
        var firstSelectedData = this.GetOption('firstSelectedItem');
        return firstSelectedData && oj.KeyUtils.equals(firstSelectedData.key, key);
      },
      /**
       * @private
       */
      _setFirstSelectedItem: function (key, data) {
        var value = {
          key: key,
          data: data
        };

        this.SetOption('firstSelectedItem', value, {
          _context: {
            originalEvent: null,
            internalSet: true
          },
          changed: true
        });
      },
      /**
       * @private
       */
      _updateFirstSelectedItem: function (selected) {
        var key;
        if (selected.isAddAll()) {
          var items = this._getItemsCache();
          for (var j = 0; j < items.length; j++) {
            var currentKey = this.m_contentHandler.GetKey(items[j]);
            if (selected.has(currentKey)) {
              key = currentKey;
              break;
            }
          }
        } else {
          key = selected.values().values().next().value;
        }

        if (key != null) {
          var data = this._getLocalData(key);
          this._setFirstSelectedItem(key, data);
        }
      },
      /**
       * Invoked by ContentHandler on update mutation event
       */
      updateSelectedKeyData: function (key, data) {
        if (this._isFirstSelectedItem(key)) {
          this._setFirstSelectedItem(key, data);
        }

        if (this.m_validatedSelectedKeyData && this.m_validatedSelectedKeyData.has(key)) {
          this.m_validatedSelectedKeyData.set(key, data);
        }
      },
      /**
       * Set Selection option. Overriden by Navlist.
       * @param {Object} options the options object
       * @protected
       */
      HandleSelectionOption: function (options) {
        if (options.selection != null || options.selected != null) {
          var selected = options.selected;
          if (selected != null && selected.isAddAll()) {
            var items = this._getItemsCache();
            for (var j = 0; j < items.length; j++) {
              var key = this.m_contentHandler.GetKey(items[j]);
              if (selected.has(key)) {
                this._applySelection(items[j], key);
              } else {
                this._unhighlightElem(items[j], 'oj-selected');
              }
            }

            // eslint-disable-next-line no-param-reassign
            options.selection = ojkeyset.KeySetUtils.toArray(selected);
          } else {
            var set = selected != null ? selected.values() : options.selection;

            // we used to filter non-selectable items, but not anymore, but we are still
            // cloning by converting iterable into array
            var newSelection = this._cloneSelection(set);
            // validate the selection, invalid keys could get removed from newSelection
            this._validateAndUpdateSelection(newSelection);

            // eslint-disable-next-line no-param-reassign
            options.selection = newSelection;

            // eslint-disable-next-line no-param-reassign
            selected = this.GetOption('selected');
            selected = selected.clear();
            selected = selected.add(newSelection);
            // eslint-disable-next-line no-param-reassign
            options.selected = selected;

            // keep selection frontier if it's part of selection
            var selectionFrontier;
            if (this.m_selectionFrontier) {
              var frontierKey = this.GetKey(this.m_selectionFrontier.get(0));
              selectionFrontier = selected.has(frontierKey) ? this.m_selectionFrontier : undefined;
            }

            // clear selection first
            this._clearSelection(false, selectionFrontier);

            // selects each key
            for (var i = 0; i < newSelection.length; i++) {
              var elem = this.FindElementByKey(newSelection[i], true);
              if (elem != null) {
                this._applySelection(elem, newSelection[i]);
              }
            }
          }

          if (selected != null) {
            this._updateFirstSelectedItem(selected);
          }
        }
      },

      /**
       * Trigger an event to fire.
       * @param {string} type the type of event
       * @param {Object} event the jQuery event to fire
       * @param {Object} ui the ui param
       * @protected
       */
      Trigger: function (type, event, ui) {
        return this.ojContext._trigger(type, event, ui);
      },

      /**
       * Sets an option on the widget
       * @param {string} key the option key
       * @param {Object} value the option value
       * @param {Object=} flags any optional parameters
       * @protected
       */
      SetOption: function (key, value, flags) {
        this.ojContext.option(key, value, flags);
      },

      /**
       * Gets the value of an option from the widget
       * @param {string} key the option key
       * @return {Object} the value of the option
       * @protected
       */
      GetOption: function (key) {
        return this.ojContext.option(key);
      },

      /**
       * Compose a description for busy state
       * @param {string} description the description
       * @return {string} the busy state description
       * @private
       */
      _getBusyDescription: function (description) {
        var id = this.ojContext._IsCustomElement()
          ? this.GetRootElement().attr('id')
          : this.element.attr('id');
        return "The component identified by '" + id + "', " + description;
      },

      /**
       * Invoke whenever a task is started. Moves the component out of the ready state if necessary.
       * @param {string=} description the description of the task
       */
      signalTaskStart: function (description) {
        var self = this;

        if (this.readinessStack) {
          if (this.readinessStack.length === 0) {
            this.readyPromise = new Promise(function (resolve) {
              self.readyResolve = resolve;
            });

            // whenReady is deprecated in favor of page busystate (but we still need to support old syntax)
            var busyContext = Context.getContext(this.element[0]).getBusyContext();
            var options =
              description != null ? { description: this._getBusyDescription(description) } : {};
            self.busyStateResolve = busyContext.addBusyState(options);
          }
          this.readinessStack.push(description != null ? description : 'unknown task');
        }
      },

      /**
       * Invoke whenever a task finishes. Resolves the readyPromise if component is ready to move into ready state.
       */
      signalTaskEnd: function () {
        if (this.readinessStack && this.readinessStack.length > 0) {
          this.readinessStack.pop();
          if (this.readinessStack.length === 0) {
            this.readyResolve(null);

            // whenReady is deprecated in favor of page busystate (but we still need to support old syntax)
            this.busyStateResolve(null);
            this.busyStateResolve = null;
          }
        }
      },

      /**
       * Checks whether ListView is in ready state.  Called by the ContentHandler.
       * @return {boolean} true if ListView is in ready state, false otherwise
       */
      isReady: function () {
        return this.busyStateResolve == null;
      },

      /**
       * Throw an error.  Do any neccessary cleanup.
       */
      throwError: function (err) {
        if (this.readinessStack) {
          while (this.readinessStack.length > 0) {
            this.signalTaskEnd();
          }
        }

        throw err;
      },

      /**
       * Gets an array of items based on specified ids.
       * @param {Array} ids an array of item ids.
       * @return {Array} an array of elements matching the item ids.
       */
      getItems: function (ids) {
        var self = this;
        var items = [];

        $.each(ids, function (index, value) {
          var elem = self.FindElementByKey(value);
          if (elem != null) {
            items.push(elem);
          }
        });

        return items;
      },

      /** ************************************ Core rendering ********************************/
      /**
       * Whether display option is set to 'card'.  Note this is different than isCardLayout which includes
       * the legacy way to switch to card layout mode using marker style class.
       * @private
       */
      isCardDisplayMode: function () {
        return this.GetOption('display') === 'card';
      },

      /**
       * Whether the listview is in card layout mode
       * @return {boolean} true if it is in card layout mode, false otherwise
       */
      isCardLayout: function () {
        var elem = this.ojContext._IsCustomElement() ? this.GetRootElement() : this.element;
        // legacy marker class has precedence to ensure backward compatibility
        if (elem.hasClass('oj-listview-card-layout')) {
          return true;
        }
        return this.isCardDisplayMode();
      },

      /**
       * Whether to use grid role for ListView, to be override by NavList
       * @protected
       */
      ShouldUseGridRole: function () {
        return true;
      },

      /**
       * Whether to scrollPosition is supported, NavList for example do not support this
       * @protected
       */
      ShouldUpdateScrollPosition: function () {
        return this.ShouldUseGridRole() && this.ojContext._IsCustomElement();
      },

      /**
       * Destroy the content handler
       * @protected
       */
      DestroyContentHandler: function (completelyDestroy) {
        if (this.m_contentHandler != null) {
          this.m_contentHandler.Destroy(completelyDestroy);
          delete this.m_contentHandler;
          this.m_contentHandler = null;
        }

        // ensure all busy states caused by outstanding fetch are resolved
        this._clearBusyState();
      },

      /**
       * Create the content handler based on data type
       * @return {Promise} which resolves to a ContentHandler
       * @protected
       */
      CreateDataContentHandler: function (data) {
        this.showStatusText();

        var contentHandler;
        if (typeof oj.TableDataSource !== 'undefined' && data instanceof oj.TableDataSource) {
          // TODO: load the adapter as needed
          contentHandler = new DataProviderScroller.IteratingDataProviderContentHandler(
            this,
            this.element[0],
            new oj.TableDataSourceAdapter(data)
          );
        } else if (typeof oj.TreeDataSource !== 'undefined' && data instanceof oj.TreeDataSource) {
          var adapterPromise = new Promise(function (resolve, reject) { require(['ojs/ojtreedataprovideradapter'], function (m) { resolve(_interopNamespace(m)); }, reject) });
          if (!adapterPromise) {
            throw new Error('Error adapting a TreeDataSource');
          }
          return adapterPromise.then(
            (TreeDataSourceAdapter) =>
              new TreeDataProviderContentHandler(
                this,
                this.element[0],
                // eslint-disable-next-line new-cap
                new TreeDataSourceAdapter.default(data)
              )
          );
        } else if (oj.DataProviderFeatureChecker.isTreeDataProvider(data)) {
          contentHandler = new TreeDataProviderContentHandler(this, this.element[0], data);
        } else if (oj.DataProviderFeatureChecker.isDataProvider(data)) {
          contentHandler = new DataProviderScroller.IteratingDataProviderContentHandler(
            this,
            this.element[0],
            data
          );
        } else {
          this.throwError('Invalid data or missing module');
        }

        return Promise.resolve(contentHandler);
      },

      /**
       * Update active descendant attribute
       * @param {jQuery} elem the active item element
       * @protected
       */
      UpdateActiveDescendant: function (elem) {
        this.element.attr('aria-activedescendant', elem.attr('id'));
      },

      /**
       * Sets wai-aria properties on root element
       * @protected
       */
      SetAriaProperties: function () {
        if (this._isMultipleSelection()) {
          this.element.attr('aria-multiselectable', true);
        } else if (this._isSelectionEnabled()) {
          this.element.attr('aria-multiselectable', false);
        }
      },

      /**
       * Removes wai-aria properties on root element
       * @protected
       */
      UnsetAriaProperties: function () {
        this.element.removeAttr('aria-activedescendant').removeAttr('aria-multiselectable');
      },

      /**
       * When selectionMode option is updated, the aria-selected
       * attribute must be remove or updated
       * @param {string} selectionMode the new selection mode
       * @protected
       */
      UpdateItemAriaProperties: function (selectionMode) {
        var self = this;
        var func;

        if (selectionMode === 'none') {
          this.element.removeAttr('aria-multiselectable');

          func = function (item) {
            self.getFocusItem(item).removeAttr('aria-selected');
          };
        } else {
          if (selectionMode === 'single') {
            this.element.attr('aria-multiselectable', false);
          } else {
            this.element.attr('aria-multiselectable', true);
          }

          func = function (item) {
            var focusElem = self.getFocusItem(item);
            var parentElem = focusElem.parent();
            focusElem.attr('aria-selected', parentElem.hasClass('oj-selected'));
          };
        }

        var items = this._getItemsCache();
        for (var i = 0; i < items.length; i++) {
          func($(items[i]));
        }
      },

      /**
       * Build the elements inside and around the root
       * @param {Element} root the root element
       * @private
       */
      // eslint-disable-next-line no-unused-vars
      _buildList: function (root) {
        var container = this.getListContainer();
        this.SetAriaProperties();

        this.m_elementOffset = this.element.get(0).offsetTop;

        var status = this._buildStatus();
        container.append(status); // @HTMLUpdateOK
        this.m_status = status;

        if (this.ShouldUseGridRole()) {
          var accInfo = this._buildAccInfo();
          container.append(accInfo); // @HTMLUpdateOK
          this.m_accInfo = accInfo;

          this._buildFocusCaptureDiv(container[0]);
        }

        if (this.isExpandable()) {
          const accInfoExpandCollapse = this._buildAccExpdesc();
          container.append(accInfoExpandCollapse); // @HTMLUpdateOK
        }
      },

      /**
       * Build a status bar div
       * @return {jQuery} the root of the status bar
       * @private
       */
      _buildStatus: function () {
        var icon = $(document.createElement('div'));
        icon.addClass('oj-icon').addClass(this.getLoadingStatusIconStyleClass());

        var root = $(document.createElement('div'));
        root
          .addClass(this.getStatusMessageStyleClass())
          .addClass(this.getStatusStyleClass())
          .attr({
            id: this._createSubId('status'),
            role: this.ShouldUseGridRole() ? 'status' : 'presentation'
          });
        root.append(icon); // @HTMLUpdateOK

        return root;
      },

      /**
       * Build the accessible text info div
       * @return {jQuery} the root of the acc info div
       * @private
       */
      _buildAccInfo: function () {
        var root = $(document.createElement('div'));
        // Due to JET-61285, changed role=status to aria-live=polite as suggested by apo
        // It would fix the issue on iOS, but not MacOS
        root.addClass('oj-helper-hidden-accessible').attr({
          id: this._createSubId('info'),
          'aria-live': 'polite'
        });
        root.attr({ tabIndex: -1 });

        return root;
      },

      /**
       * Build the accessible text instruction div for expand or collapse
       * @return {jQuery} the root of the acc instruction div
       * @private
       */
      _buildAccExpdesc: function () {
        const root = $(document.createElement('div'));
        const msg = this.ojContext.getTranslatedString('accessibleExpandCollapseInstructionText');
        this.m_accExpdescId = this._createSubId('expdesc');

        root
          .addClass('oj-helper-hidden-accessible')
          .attr({
            id: this.m_accExpdescId
          })
          .html(msg); // @HTMLUpdateOK

        return root;
      },

      /**
       * Build a non-keyboard accessible div used to capture manual focus from JAWS.
       * @private
       */
      _buildFocusCaptureDiv: function (container) {
        if (!DataCollectionUtils.isMobileTouchDevice()) {
          var elem = document.createElement('div');
          elem.setAttribute('tabindex', '-1');
          elem.classList.add('oj-helper-hidden-accessible');
          elem.innerHTML = '&nbsp'; // @HTMLUpdateOK
          container.insertBefore(elem, this.element[0]); // @HTMLUpdateOK
          elem.addEventListener('focus', () => {
            this.element[0].focus();
          });
        }
      },

      /**
       * Sets the accessible text info
       * @param {string} text the text to set on accessible info div
       * @private
       */
      _setAccInfoText: function (text) {
        if (this.m_accInfo == null) {
          return;
        }
        if (this.m_clearAccInfoTimeout) {
          clearTimeout(this.m_clearAccInfoTimeout);
        }
        if (text !== '' && this.m_accInfo.text() !== text) {
          this.m_accInfo.text(text);
          this.m_clearAccInfoTimeout = setTimeout(() => {
            this._clearAccInfoText();
            this.m_clearAccInfoTimeout = null;
          }, 1000);
        }
      },

      /**
       * Sets the accessible text info to an empty string
       * @private
       */
      _clearAccInfoText: function () {
        if (this.m_accInfo) {
          this.m_accInfo.text('');
        }
      },

      /**
       * Update role status text to reflect that it is fetching data
       * @private
       */
      updateStatusFetchStart: function () {
        var msg = this.ojContext.getTranslatedString('msgFetchingData');
        this._setAccInfoText(msg);
      },

      /**
       * Update role status text to reflect that fetched items are added to the end
       * @private
       */
      updateStatusFetchEnd: function (count) {
        var msg;
        if (count === 0) {
          msg = this.ojContext.getTranslatedString('msgFetchCompleted');
        } else {
          msg = this.ojContext.getTranslatedString('msgItemsAppended', { count: count });
        }
        this._setAccInfoText(msg);
      },

      /**
       * Update role status text to reflect that group header is expanded
       * @private
       */
      updateStatusGroupExpandCollapse: function (expanded) {
        let msg;
        if (expanded) {
          msg = this.ojContext.getTranslatedString('accessibleGroupExpand');
        } else {
          msg = this.ojContext.getTranslatedString('accessibleGroupCollapse');
        }
        this._setAccInfoText(msg);
      },

      /**
       * Whether skeletons should be shown for initial fetch.  Invoked by ContentHandler
       */
      isSkeletonSupport: function () {
        // don't show for NavList
        if (this.ShouldUseGridRole() && this.m_contentHandler.renderInitialSkeletons) {
          var defaults = this._getOptionDefaults();
          return defaults.loadIndicator === 'skeleton';
        }
        return false;
      },

      /**
       * @protected
       */
      showLoadingIcon: function () {
        var msg = this.ojContext.getTranslatedString('msgFetchingData');

        var container = this.getListContainer();
        this.m_status
          .attr('aria-label', msg)
          .css('left', Math.max(0, container.outerWidth() / 2 - this.m_status.outerWidth() / 2))
          .css('top', Math.max(0, container.outerHeight() / 2 - this.m_status.outerHeight() / 2))
          .show();

        // make sure the container is tall enough to show the indicator
        var statusHeight = this.m_status.get(0).offsetHeight;
        var containerHeight = container.get(0).offsetHeight;
        var minHeightStyle = container.get(0).style.minHeight;
        var minHeight = parseInt(minHeightStyle, 10);
        if (isNaN(minHeight)) {
          minHeight = 0;
        }
        if (containerHeight < statusHeight && minHeight < statusHeight) {
          container.css(
            'minHeight',
            Math.max(containerHeight, statusHeight + this.getListContainerBorderWidth())
          );
          // save it to restore later
          if (!isNaN(minHeight)) {
            container.get(0).setAttribute('data-oj-min-height', minHeightStyle);
          }
        }
      },

      /**
       * @private
       */
      _showLoadingSkeleton: function () {
        this.m_contentHandler.renderInitialSkeletons();
      },

      /**
       * Displays the 'fetching' status message
       * @private
       */
      showStatusText: function () {
        var self = this;

        // it's already shown
        if (this.m_showStatusTimeout) {
          return;
        }

        this.m_showStatusTimeout = setTimeout(function () {
          // remove any empty text div
          $(document.getElementById(self._createSubId('empty'))).remove();

          // listview might have already been destroyed
          if (self.m_contentHandler != null) {
            if (self.isSkeletonSupport()) {
              self._showLoadingSkeleton();
            } else {
              self.showLoadingIcon();
            }
          }
          self.m_showStatusTimeout = null;
        }, this._getShowStatusDelay());
      },

      /**
       * Retrieve the delay before showing status
       * @return {number} the delay in ms
       * @private
       */
      _getShowStatusDelay: function () {
        var defaultOptions = this._getOptionDefaults();
        var delay = DomUtils.getCSSTimeUnitAsMillis(defaultOptions.showIndicatorDelay);

        return isNaN(delay) ? 0 : delay;
      },

      /**
       * Hide the 'fetching' status message
       * @private
       */
      hideStatusText: function () {
        if (this.m_showStatusTimeout) {
          clearTimeout(this.m_showStatusTimeout);
          this.m_showStatusTimeout = null;
        }
        this.m_status.hide();

        var container = this.getListContainer().get(0);
        if (container.hasAttribute('data-oj-min-height')) {
          container.style.minHeight = container.getAttribute('data-oj-min-height');
          container.removeAttribute('data-oj-min-height');
        }
      },

      /**
       * Retrieves the root element
       * Invoke by widget
       * @protected
       * @return {jQuery} root element
       */
      GetRootElement: function () {
        return this.getListContainer();
      },

      /**
       * Retrieves the div around the root element, create one if needed.
       * @return {jQuery} the div around the root element
       */
      getListContainer: function () {
        if (this.m_container == null) {
          this.m_container = this._createListContainer();
        }
        return this.m_container;
      },

      /**
       * Creates the div around the root element.
       * @return {jQuery} the div around the root element
       * @private
       */
      _createListContainer: function () {
        var listContainer;

        if (this.OuterWrapper) {
          listContainer = $(this.OuterWrapper);
        } else {
          listContainer = $(document.createElement('div'));
          this.element.parent()[0].replaceChild(listContainer[0], this.element[0]);
        }

        listContainer.addClass(this.GetContainerStyleClass()).addClass('oj-component');
        if (!this._isTextSelectionEnabled()) {
          listContainer.addClass('oj-listview-no-text-selection');
        }
        listContainer.prepend(this.element); // @HTMLUpdateOK
        return listContainer;
      },

      /**
       * If the empty text option is 'default' return default empty translated text,
       * otherwise return the emptyText set in the options
       * @return {string} the empty text
       * @private
       */
      _getEmptyText: function () {
        return this.ojContext.getTranslatedString('msgNoData');
      },

      /**
       * Build an empty text div and populate it with empty text
       * @return {Element} the empty text element
       * @private
       */
      _buildEmptyText: function () {
        var emptyText = this._getEmptyText();
        var isListView = this.ShouldUseGridRole();
        if (isListView || emptyText !== '') {
          var emptyRow = document.createElement('li');
          emptyRow.setAttribute('role', 'row');
          emptyRow.id = this._createSubId('empty');
          emptyRow.classList.add(this.getNoDataItemStyleClass());
          if (this.isCardDisplayMode()) {
            emptyRow.classList.add(this.getNoDataCardStyleClass());
          }
          emptyRow.classList.add(this.getEmptyTextStyleClass());
          emptyRow.classList.add(this.getEmptyTextMarkerClass());

          var emptyCell = document.createElement('span');
          emptyCell.setAttribute('role', 'gridcell');
          emptyCell.textContent = emptyText;
          emptyCell.classList.add(this.getNoDataCellElementStyleClass());

          emptyRow.appendChild(emptyCell);

          return emptyRow;
        }

        return null;
      },

      /**
       * Determines whether the specified item is expanded
       * @param {jQuery} item the item element
       * @return {number} 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
       * @protected
       */
      GetState: function (item) {
        var expanded = this.getFocusItem(item).attr('aria-expanded');
        if (expanded === 'true') {
          return this.STATE_EXPANDED;
        } else if (expanded === 'false') {
          return this.STATE_COLLAPSED;
        }

        return this.STATE_NONE;
      },

      /**
       * Sets the disclosed state of the item
       * @param {jQuery} item the item element
       * @param {number} state 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
       * @protected
       */
      SetState: function (item, state) {
        var expandable = this.isExpandable();

        if (state === this.STATE_EXPANDED) {
          this.getFocusItem(item).attr('aria-expanded', 'true');
          if (expandable) {
            item.removeClass('oj-collapsed').addClass('oj-expanded');
          }
        } else if (state === this.STATE_COLLAPSED) {
          this.getFocusItem(item).attr('aria-expanded', 'false');
          if (expandable) {
            item.removeClass('oj-expanded').addClass('oj-collapsed');
          }
        }
      },

      /**
       * Gets the item option
       * @param {string} name the name of the option
       * @param {Object} context the context object
       * @param {boolean} resolve true evaluate if return value is a function, false otherwise
       * @return {function(Object)|Object|null} returns the item option
       * @private
       */
      _getItemOption: function (name, context, resolve) {
        var option = this.GetOption('item');
        var value = option[name];

        if (typeof value === 'function' && resolve) {
          return value.call(this, context);
        }

        return value;
      },

      /**
       * Gets the item.focusable option.
       * @param {Object} context the context object
       * @return {boolean} true if item.focusable option is derieved to be true, false otherwise
       */
      getItemFocusable: function (context) {
        return this._getItemOption('focusable', context, true);
      },

      /**
       * Gets the item.selectable option.
       * @param {Object} context the context object
       * @return {boolean} true if item.selectable option is derieved to be true, false otherwise
       */
      getItemSelectable: function (context) {
        // if it's not focusable, it's not selectable also
        return this.getItemFocusable(context) && this._getItemOption('selectable', context, true);
      },

      /**
       * Gets the item renderer
       * @return {function(Object)|null} returns the item renderer
       * @private
       */
      _getItemRenderer: function () {
        var renderer = this._getItemOption('renderer', null, false);
        if (typeof renderer !== 'function') {
          // cannot be non-function
          return null;
        }
        return this._WrapCustomElementRenderer(renderer);
      },

      /**
       * Returns the inline template element inside oj-list-view
       * @return {Element|null} the inline template element
       */
      getItemTemplate: function () {
        if (this.m_template === undefined) {
          // cache the template, assuming replacing template will require refresh
          this.m_template = null;
          if (this.ojContext._IsCustomElement()) {
            var slotMap = this.GetSlotMap();
            var slot = slotMap.itemTemplate;
            if (slot && slot.length > 0 && slot[0].tagName.toLowerCase() === 'template') {
              this.m_template = slot[0];
            }
          }
        }
        return this.m_template;
      },

      /**
       * Returns the value of as option
       * @return {string}
       */
      getAs: function () {
        return this.GetOption('as');
      },

      /**
       * Returns the slot map object.
       * @return {object} slot Map
       */
      GetSlotMap: function () {
        return ojcustomelementUtils.CustomElementUtils.getSlotMap(this.GetRootElement()[0]);
      },

      /**
       * Called by content handler once the content of an item is rendered triggered by an insert event
       * @param {Element} elem the item element
       * @param {Object} context the context object used for the item
       */
      // eslint-disable-next-line no-unused-vars
      itemInsertComplete: function (elem, context) {
        // clear cached height
        this.m_clientHeight = null;
        this.m_scrollHeight = null;
      },

      /**
       * Called by content handler once the content of an item is rendered triggered by an insert event
       */
      BeforeInsertItem: function () {
        // hook for NavList
      },

      /**
       * Called by content handler once the content of an item is removed triggered by an remove event
       * @param {Element} elem the item element
       * @param {boolean} restoreFocus true if focus should be restore, false otherwise
       * @param {boolean} isReinsert true if the item is going to be re-insert in the same event
       */
      itemRemoveComplete: function (elem, restoreFocus, isReinsert) {
        var currentItemUpdated = false;

        // if it's the current focus item, try to focus on the next/prev item.  If there are none, then focus on the root element
        if (this.m_active != null && oj.Object.compareValues(this.m_active.key, this.GetKey(elem))) {
          // make sure we exit actionable mode, otherwise focus will be lost
          this._setActionableMode(false, true);

          // do not change currentItem if the item is going to be inserted in the same event
          if (!isReinsert) {
            let next = null;
            let items = this._getItemsCache().toArray();
            items = items.filter((item) => !item.classList.contains('oj-skipfocus'));
            const elemIndex = items.findIndex((item) => elem.contains(item));
            if (elemIndex === -1) {
              this.SetOption('currentItem', null);
            } else {
              // when the next element is from the other group, we set the next element
              // to the last element of current group if there is one
              const elemGroup = elem.closest('ul.oj-listview-group');
              const nextElem = items[elemIndex + 1];
              const prevElem = items[elemIndex - 1];
              if (
                elemGroup &&
                nextElem &&
                prevElem &&
                nextElem.closest('ul') !== elemGroup &&
                prevElem.closest('ul') === elemGroup
              ) {
                next = prevElem;
              } else {
                next = nextElem;
                if (
                  next == null ||
                  (!next.classList.contains(this.getItemElementStyleClass()) &&
                    !next.classList.contains('oj-listview-temp-item'))
                ) {
                  next = prevElem;
                  if (next == null || !next.classList.contains(this.getItemElementStyleClass())) {
                    this.SetOption('currentItem', null);
                  }
                }
              }
            }

            if (
              next != null &&
              (next.classList.contains(this.getItemElementStyleClass()) ||
                next.classList.contains('oj-listview-temp-item'))
            ) {
              this.SetCurrentItem($(next), null, !restoreFocus);
              currentItemUpdated = true;
            }
          }
        }

        // disassociate element from key map
        if (elem != null && elem.id && this.m_keyElemMap != null) {
          this.m_keyElemMap.delete(elem.id);
        }

        // clear cached height
        this.m_clientHeight = null;
        this.m_scrollHeight = null;

        return currentItemUpdated;
      },

      /**
       * Called by content handler once the content of an item is rendered
       * @param {Element} elem the item element
       * @param {Object} context the context object used for the item
       */
      itemRenderComplete: function (elem, context) {
        // dnd
        if (this.m_dndContext != null) {
          this.m_dndContext.itemRenderComplete(elem);
        }

        var key = context.key;

        // update as selected if it is in selection, check if something already selected in single selection
        if (this._isSelectionEnabled()) {
          var selected = this.GetOption('selected');
          var selectedItems;
          var exists = selected.has(key);
          if (this.IsSelectable(elem)) {
            if (exists) {
              this._applySelection(elem, key);

              // if it's single selection, then bail
              if (!this._isMultipleSelection()) {
                if (selected.values().size > 1) {
                  // we'll have to modify the value
                  selectedItems = this.FindElementByKey(key);
                  selected = selected.clear().add([key]);
                  this._setSelectionOption(selected, null, selectedItems, context.data);
                }
              }
            }

            // if selectionRequired is set to true and selection is empty, selects the first selectable item
            // this should be run once since selection won't be empty afterwards
            if (selected.values && selected.values().size === 0 && this._isSelectionRequired()) {
              this._applySelection(elem, key);
              // need to pass data since 1) to avoid unneccesary lookup 2) since item is not in live dom, getDataForVisibleItem would not work
              selected = selected.clear().add([key]);
              this._setSelectionOption(selected, null, [elem], context.data);
            }
          } else if (exists && !selected.isAddAll()) {
            // the selection is invalid, remove it from selection
            selectedItems = [];

            selected = selected.delete([key]);
            selected.values().forEach(function (aKey) {
              selectedItems.push(this.FindElementByKey(aKey));
            }, this);

            this._setSelectionOption(selected, null, selectedItems);
          }
        }

        var self = this;

        // update if it is in expanded, ensure data is hierarchical
        if (this.m_contentHandler.IsHierarchical() && this._ignoreExpanded == null) {
          // checks if it is expandable && is collapsed
          if (this.GetState($(elem)) === this.STATE_COLLAPSED) {
            var expanded = this.GetOption('expanded');
            // checks if expand all
            if (this._isExpandAll(key)) {
              // for legacy syntax, expanded is not real-time in certain cases, i.e. you
              // can have expanded='all' but some itms are collapsed
              // for custom element we don't care about collapsedKeys since KeySet is keeping track of it
              if (this.ojContext._IsCustomElement() || this._collapsedKeys == null) {
                // don't animate
                this.ExpandItem($(elem), null, false, null, false, false, false);
              }
            } else if (!this.ojContext._IsCustomElement() && Array.isArray(expanded)) {
              // legacy syntax array of expanded keys
              // checks if specified expanded
              $.each(expanded, function (_index, value) {
                // if it was explicitly collapsed
                if (
                  value === key &&
                  (self._collapsedKeys == null || self._collapsedKeys.indexOf(value) === -1)
                ) {
                  // don't animate
                  self.ExpandItem($(elem), null, false, null, false, false, false);
                }
              });
            } else if (expanded.has) {
              // KeySet case
              if (expanded.has(key)) {
                // don't animate
                this.ExpandItem($(elem), null, false, null, false, false, false);
              }
            }
          }
        }

        // checks if the active element has changed, this could happen in TreeDataSource, where the element gets remove when collapsed
        // or when the item updated (mutation event) is the current item
        if (
          this.m_active != null &&
          key === this.m_active.key &&
          this.m_active.elem != null &&
          elem !== this.m_active.elem.get(0)
        ) {
          this.m_active.elem = $(elem);
        }
      },

      /**
       * Returns the noData template element inside oj-list-view
       * @return {Element|null} the content of noData slot
       * @private
       */
      _addNoData: function () {
        if (this.ojContext._IsCustomElement()) {
          var slotMap = this.GetSlotMap();
          var slot = slotMap.noData;
          if (slot && slot.length > 0 && slot[0].tagName.toLowerCase() === 'template') {
            var noDataContentRoot = document.createElement('li');
            noDataContentRoot.setAttribute('role', 'row');
            noDataContentRoot.id = this._createSubId('empty');
            noDataContentRoot.classList.add(this.getNoDataItemStyleClass());
            noDataContentRoot.classList.add('oj-listview-no-data-container');

            var noDataContent = document.createElement('div');
            noDataContent.setAttribute('role', 'gridcell');
            noDataContent.setAttribute('tabIndex', '0');
            noDataContent.classList.add(this.getNoDataCellElementStyleClass());
            noDataContent.classList.add('oj-listview-no-data-container');

            noDataContentRoot.appendChild(noDataContent);

            var root = this.element;
            root.addClass('oj-listview-no-data-container');
            root.append(noDataContentRoot); // @HTMLUpdateOK

            var self = this;
            this.signalTaskStart('run no data template');
            const templateOptions = {
              customElement: this._GetCustomElement()
            };
            Config.__getTemplateEngine(templateOptions).then(
              function (engine) {
                var nodes = engine.execute(self.GetRootElement(), slot[0], {}, null);
                nodes.forEach(function (node) {
                  noDataContent.appendChild(node); // @HTMLUpdateOK
                });
                self.m_engine = engine;
                self.signalTaskEnd();
              },
              function (reason) {
                self.signalTaskEnd();
                throw new Error('Error loading template engine: ' + reason);
              }
            );
            return;
          }
        }
        // non-custom element or when noData slot is specified
        this.element.append(this._buildEmptyText()); // @HTMLUpdateOK
      },

      /**
       * Remove empty element artifacts from list
       * @private
       */
      _removeNoData: function () {
        this.element.removeClass('oj-listview-no-data-container');

        var elem = document.getElementById(this._createSubId('empty'));
        if (elem) {
          if (this.m_engine) {
            this.m_engine.clean(elem, this.GetRootElement().get(0));
          }
          elem.parentNode.removeChild(elem);
        }
      },

      /**
       * Called by content handler see handleModelRemoveEvent
       */
      resetInitialSelectionStateValidated: function () {
        this.m_initialSelectionStateValidated = false;
      },

      /**
       * Called by content handler once content of all items are rendered
       */
      renderComplete: function (skipSyncScrollPosition) {
        var self = this;

        this.hideStatusText();

        // remove any empty text div
        this._removeNoData();

        // clear items cache
        this.m_items = null;
        this.m_groupItems = null;

        // clear cached scrollHeight
        this.m_scrollHeight = null;

        // if grid role and card layout and non-heirarchical and presentation div is empty, remove presentation div to clear out the element
        if (this._isEmptyGrid()) {
          this.element[0].removeChild(this.element[0].children[0]);
        }

        // check if it's empty
        if (this._isEmpty()) {
          this._addNoData();

          // fire ready event
          this.Trigger('ready', null, {});

          return null;
        }

        // check if current is specified
        var current = this.GetOption('currentItem');
        if (current != null) {
          var elem = this.FindElementByKey(current, true);
          if (elem == null) {
            // it's not valid anymore, reset current
            this.SetOption('currentItem', null);
          } else if (
            (this.m_active == null || !oj.KeyUtils.equals(this.m_active.key, current)) &&
            !this.SkipFocus($(elem))
          ) {
            var active = document.activeElement;
            // update tab index and focus only if listview currently has focus
            if (active && this.element.get(0).contains(active)) {
              this.ActiveAndFocus($(elem), null);
            } else {
              // update internal state only
              this._setActive($(elem), null, true);
            }
          }
        }

        // if listview has focus but there's no active element, then set focusable item
        // this could happen after refresh from context menu
        if (
          this.getListContainer().hasClass('oj-focus-ancestor') &&
          this.m_active == null &&
          current == null &&
          !this._isTouchSupport()
        ) {
          this._initFocus();
        }

        // clear the scroll and fetch flag before calling syncScrollPosition
        this.m_scrollAndFetch = undefined;

        // update scroll position if it's not in sync, make sure we are not in the middle of scrolling
        if (this.m_scrollPosition != null || (!skipSyncScrollPosition && !this.m_ticking)) {
          this.syncScrollPosition();
        }

        // validate selection as needed
        // only do the validation once for initial render/refresh
        if (
          !this.m_initialSelectionStateValidated &&
          this._isSelectionEnabled() &&
          this._isSelectionRequired()
        ) {
          // take a snapshot of the value since the value is live and mutable
          var selection = this.GetOption('selection').slice(0);
          this._validateAndUpdateSelection(selection);
          this.m_initialSelectionStateValidated = true;
        }

        // update firstSelectedItem as needed
        if (this._isSelectionEnabled()) {
          var firstSelectedItem = this.GetOption('firstSelectedItem');
          if (firstSelectedItem == null || firstSelectedItem.key == null) {
            var selected = this.GetOption('selected');
            if (selected != null) {
              this._updateFirstSelectedItem(selected);
            }
          }
        }

        // about gridlines for last item
        if (this.m_gridlinePlaceholder != null && this.m_gridlinePlaceholder.parentNode != null) {
          this.m_gridlinePlaceholder.parentNode.removeChild(this.m_gridlinePlaceholder);
        }
        if (
          (this.m_contentHandler.hasMoreToFetch === undefined ||
            (this.m_contentHandler.hasMoreToFetch && !this.m_contentHandler.hasMoreToFetch())) &&
          this._shouldRenderGridlineForLastItem()
        ) {
          var gridlinePlaceholder = document.createElement('li');
          gridlinePlaceholder.setAttribute('role', 'presentation');
          gridlinePlaceholder.className = 'oj-listview-gridline-placeholder';
          this.element[0].appendChild(gridlinePlaceholder);

          this.m_gridlinePlaceholder = gridlinePlaceholder;
        }

        var _animationPromise = null;

        // apply card entrance animation
        if (this._isAnimateCards()) {
          var isInitial = this.element[0].querySelector('.oj-listview-card-animated') == null;
          var delay = 0;
          var increment = this._getCardEntranceAnimationDelay();
          // so that scrollbar would not be shown when slide in
          if (isInitial) {
            this.element[0].classList.add('oj-animation-host-viewport');
          }
          this.element[0]
            .querySelectorAll('.oj-listview-card:not(.oj-listview-card-animated)')
            .forEach(function (card) {
              // mark as animated so we can filter it next time
              card.classList.add('oj-listview-card-animated');
              if (isInitial) {
                var effects = self.getAnimationEffect('cardEntrance');
                if (effects) {
                  effects.forEach(function (effect) {
                    // eslint-disable-next-line no-param-reassign
                    effect.delay = delay + 'ms';
                  });
                }
                _animationPromise = self.StartAnimation(card, 'cardEntrance', effects);
                delay = Math.min(1000, delay + increment);
              } else if (self.m_initialCardAnimationPromise) {
                // eslint-disable-next-line no-param-reassign
                card.style.opacity = 0;
                self.m_initialCardAnimationPromise.then(function () {
                  AnimationUtils.fadeIn(card, { duration: '150ms', persist: 'all' });
                });
              } else {
                AnimationUtils.fadeIn(card, { duration: '150ms' });
              }

              if (_animationPromise) {
                _animationPromise.then(function () {
                  self.element[0].classList.remove('oj-animation-host-viewport');
                });
              }
            });
          if (_animationPromise) {
            this.m_initialCardAnimationPromise = _animationPromise;
          }
        }

        // fire ready event
        this.Trigger('ready', null, {});

        return _animationPromise;
      },

      /**
       * Retrieve the animation delay between card entrance animation
       * @return {number} the delay in ms
       * @private
       */
      _getCardEntranceAnimationDelay: function () {
        var defaultOptions = this._getOptionDefaults();
        var delay = parseInt(defaultOptions.cardAnimationDelay, 10);

        return isNaN(delay) ? 0 : delay;
      },

      /**
       * Gets all the keys that are already fetched
       * @private
       */
      _getLocalKeys: function () {
        var keys = [];
        var items = this._getItemsCache();
        for (var i = 0; i < items.length; i++) {
          keys.push(this.GetKey(items[i]));
        }
        return keys;
      },

      /**
       * Validate keys and update selection, enforce selection required as needed
       * @private
       */
      _validateAndUpdateSelection: function (selection) {
        if (this._isSelectionRequired() && selection.length > 0) {
          var previousLength = selection.length;
          var validateSelectionPromise = this._validateSelection(selection);
          if (validateSelectionPromise) {
            this.signalTaskStart('validating selection-required keys');
            validateSelectionPromise.then(
              function (validSelection) {
                var newSelected = this.GetOption('selected').clear().add(validSelection);
                this._setSelectionOption(newSelected, null, null, null);
                this.enforceSelectionRequired();
                this.signalTaskEnd();
              }.bind(this)
            );
          } else if (previousLength !== selection.length) {
            var newSelected = this.GetOption('selected').clear().add(selection);
            this._setSelectionOption(newSelected, null, null, null);
            this.enforceSelectionRequired();
          }
        }
      },

      /**
       * Validate keys in selection
       * @private
       */
      _validateSelection: function (selection) {
        this.m_validatedSelectedKeyData = null;

        var validatedKeys = selection;
        var localKeys = this._getLocalKeys();
        var invalidLocalKeys = [];
        selection.forEach(function (key) {
          if (localKeys.indexOf(key) === -1) {
            invalidLocalKeys.push(key);
          }
        });

        // if any keys are not locally available, attempt to validate keys in the data provider
        if (invalidLocalKeys.length > 0) {
          var validRowKeyDataPromise = this._fetchValidRowKeyData(invalidLocalKeys);
          if (validRowKeyDataPromise) {
            var validateSelectionPromise = validRowKeyDataPromise.then(
              function (validRowKeyData) {
                this.m_validatedSelectedKeyData = validRowKeyData.validKeyData;
                validRowKeyData.validKeys.forEach(function (key) {
                  invalidLocalKeys.splice(invalidLocalKeys.indexOf(key), 1);
                });
                for (var i = validatedKeys.length - 1; i >= 0; i--) {
                  if (invalidLocalKeys.indexOf(validatedKeys[i]) > -1) {
                    validatedKeys.splice(i, 1);
                  }
                }
                return validatedKeys;
              }.bind(this)
            );
            return validateSelectionPromise;
          }

          for (var i = validatedKeys.length - 1; i >= 0; i--) {
            if (invalidLocalKeys.indexOf(validatedKeys[i]) > -1) {
              validatedKeys.splice(i, 1);
            }
          }
        }
        return null;
      },

      /**
       * Validate keys in selected
       * @private
       */
      _fetchValidRowKeyData: function (keys) {
        // need to verify keys if we have a DataProvider that supports non-iteration 'fetchByKeys'
        var dataProvider = this.m_contentHandler.getDataProvider();
        if (dataProvider && dataProvider.getCapability) {
          var capability = dataProvider.getCapability('fetchByKeys');
          if (capability && capability.implementation === 'lookup') {
            return new Promise(function (resolve) {
              dataProvider.fetchByKeys({ keys: new Set(keys), scope: 'global' }).then(
                function (fetchResult) {
                  var validKeys = [];
                  var validKeyData = new KeyMap();
                  var validKeysResult = fetchResult.results;
                  validKeysResult.forEach(function (value, key) {
                    validKeys.push(key);
                    validKeyData.set(key, value.data);
                  });
                  resolve({ validKeys: validKeys, validKeyData: validKeyData });
                },
                function () {
                  // something bad happened, treat keys as invalid
                  resolve({ validKeys: [], validData: new Map() });
                }
              );
            });
          }
        }
        // if we can't validate, return null
        return null;
      },

      /**
       * Returns whether or not the li presentation div is present and empty.
       * @private
       * @returns {boolean} true if li presentation div is present and empty.
       */
      _isEmptyGrid: function () {
        return (
          this.ShouldUseGridRole() &&
          this.isCardLayout() &&
          !this.m_contentHandler.IsHierarchical() &&
          this.element[0].children[0] &&
          this.element[0].children[0].children[0].childElementCount === 0
        );
      },

      /**
       * @private
       */
      _setScrollY: function (scroller, y) {
        var initialScrollTop = scroller.scrollTop;
        Logger.info('Setting scroll y: ' + y + ' initial scrollTop: ' + initialScrollTop);

        if (!this._skipScrollUpdate) {
          this._setScrollPosBusyState();
        }

        // flag it so that handleScroll won't do anything
        this._skipScrollUpdate = true;
        // eslint-disable-next-line no-param-reassign
        scroller.scrollTop = y;

        // update sticky header as needed
        this._handlePinGroupHeader();

        // if scroll didn't happen, clear busy state
        Logger.info('scrollTop after updating: ' + scroller.scrollTop);
        if (initialScrollTop === scroller.scrollTop) {
          Logger.info('scrollPosBusyState getting clear');
          this._clearScrollPosBusyState();
          return false;
        }
        return true;
      },

      /**
       * Sets the bidi independent position of the horizontal scroll position that
       * is consistent across all browsers.
       * @private
       */
      _setScrollX: function (scroller, x) {
        // flag it so that handleScroll won't do anything
        this._skipScrollUpdate = true;

        DomUtils.setScrollLeft(scroller, x);
      },

      /**
       * Retrieve the bidi independent position of the horizontal scroll position that
       * is consistent across all browsers.
       * @private
       */
      _getScrollX: function (scroller) {
        return Math.abs(scroller.scrollLeft);
      },

      /**
       * Invoked by ContentHandler
       */
      getScrollToKey: function () {
        var scrollPosition = this.GetOption('scrollPosition');
        if (scrollPosition) {
          var key = scrollPosition.key;
          if (key) {
            var self = this;
            return new Promise(function (resolve) {
              var result = self._validateKeyForScroll(key, true);
              if (result == null) {
                resolve(null);
              } else {
                result.then(function (value) {
                  resolve(value ? key : null);
                });
              }
            });
          }
        }
        return Promise.resolve(null);
      },

      /**
       * Validate a key for scrolling purposes
       * @param {any} key the key to validate
       * @param {boolean} skipLocal whether to skip checking of local cache
       * @return {Promise|null} a Promise that resolves to true if one of the keys specified is valid, false otherwise.
       *                        Returns null if it cannot validate the keys or scrollByKey behavior is set to 'never'.
       * @private
       */
      _validateKeyForScroll: function (key, skipLocal) {
        var self = this;

        // scrollToKey set to never or DataProvider cannot have the right capability
        if (!this._isScrollToKey()) {
          return null;
        }

        // found the key in cache, we are done
        if (!skipLocal && this.FindElementByKey(key) != null) {
          return Promise.resolve(true);
        }

        // need to verify key if we have a DataProvider that supports ContainsKeys
        if (
          this.m_contentHandler instanceof DataProviderScroller.IteratingDataProviderContentHandler
        ) {
          var dataProvider = this.m_contentHandler.getDataProvider();
          if (dataProvider.containsKeys) {
            return new Promise(function (resolve) {
              // IE 11 does not support specifying value in constructor
              var set = new Set();
              set.add(key);

              self.signalTaskStart('Checking for keys');
              dataProvider.containsKeys({ keys: set }).then(
                function (value) {
                  resolve(value.results.size > 0);
                  self.signalTaskEnd();
                },
                function () {
                  // something bad happened, treat it as invalid key
                  self.signalTaskEnd();
                  resolve(false);
                }
              );
            });
          }
        }
        // else we can't verify, so just return null and let syncScrollPosition tries to fetch
        // and find the item
        return null;
      },

      /**
       * @private
       */
      _getScrollHeight: function () {
        if (this.m_scrollHeight == null) {
          this.m_scrollHeight = this._getScroller().scrollHeight;
        }
        return this.m_scrollHeight;
      },

      /**
       * @private
       */
      _getClientHeight: function () {
        if (this.m_clientHeight == null) {
          this.m_clientHeight = this._getScroller().clientHeight;
        }
        return this.m_clientHeight;
      },

      /**
       * @private
       */
      _getScrollWidth: function () {
        if (this.m_scrollWidth == null) {
          this.m_scrollWidth = this._getScroller().scrollWidth;
        }
        return this.m_scrollWidth;
      },

      /**
       * @private
       */
      _getClientWidth: function () {
        if (this.m_clientWidth == null) {
          this.m_clientWidth = this._getScroller().clientWidth;
        }
        return this.m_clientWidth;
      },

      /**
       * @private
       */
      _isScrollable: function () {
        return this._isScrollableY() || this._isScrollableX();
      },

      _isScrollableX: function () {
        return Math.abs(this._getScrollWidth() - this._getClientWidth()) > 1;
      },

      _isScrollableY: function () {
        var adjustments = 0;
        if (this.m_contentHandler.getLoadingIndicator) {
          var loadingIndicator = this.m_contentHandler.getLoadingIndicator();
          if (loadingIndicator != null) {
            adjustments = loadingIndicator.offsetHeight;
          }
        }
        // don't use cache value, since that could be incorrect due to animation and timing
        var scroller = this._getScroller();
        var scrollHeight = scroller.scrollHeight;
        var clientHeight = scroller.clientHeight;
        return Math.abs(scrollHeight - clientHeight) - adjustments > 1;
      },

      /**
       * Synchronize the scroll position
       * @protected
       */
      syncScrollPosition: function (position, validateKey) {
        var self = this;
        var coord;
        var x;
        var y;
        var scrollTop;

        // we do not need to handle scrollPosition for NavList
        if (!this.ShouldUseGridRole()) {
          return;
        }

        // eslint-disable-next-line no-param-reassign
        validateKey = validateKey === undefined ? true : validateKey;

        // check if it's even scrollable, note due to sub-pixel issue, doing
        // an exact match will not work at all times
        if (!this._isScrollable()) {
          return;
        }

        if (this.ShouldUpdateScrollPosition()) {
          if (this.m_scrollPosition != null) {
            // eslint-disable-next-line no-param-reassign
            position = this.m_scrollPosition;
          } else if (position === undefined) {
            // eslint-disable-next-line no-param-reassign
            position = this.GetOption('scrollPosition');
          }

          if (validateKey && position.key != null) {
            var promise = this._validateKeyForScroll(position.key, false);
            if (promise) {
              promise.then(function (valid) {
                if (self.m_contentHandler != null) {
                  if (!valid) {
                    // remove invalid or non-existing key
                    // eslint-disable-next-line no-param-reassign
                    delete position.key;
                  }
                  // try again
                  self.syncScrollPosition(position, false);
                }
              });
            }
            // if _validateKeys returns null it means either 1) the key is not fetched yet and the DataProvider
            // is not capable of supporting fast (immediate) iteration speed on fetchFirst or 2) scrollToKey
            // behavior is set to 'never'
            return;
          }

          // if the scroll to key is one that is to be fetched due to insert at the end
          // we'll scroll to the bottom and kept it so that it will sync up after fetch
          if (
            this.m_contentHandler._isFetchFromInsert &&
            position.key != null &&
            this.m_contentHandler._isFetchFromInsert(position.key)
          ) {
            this._setScrollY(this._getScroller(), this._getScrollHeight());
            this.m_scrollAndFetch = true;
            this.m_scrollPosition = position;
            return;
          }

          // figure out what the final y should be
          coord = this._getScrollCoordinates(position);
          x = coord.x;
          y = coord.y;

          if (isNaN(x) && isNaN(y)) {
            // invalid scroll position
            if (this.m_scrollPosition != null) {
              // we'll still need to report current scroll position, which could have changed because of scroll and fetch
              this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
                _context: {
                  originalEvent: null,
                  internalSet: true
                }
              });

              // free signalTaskStart from earlier when m_scrollPosition is saved
              this.signalTaskEnd();
              this.m_scrollPosition = null;
            }
            return;
          }
        }

        if (coord === undefined) {
          // legacy scrollTop attribute
          y = this.GetOption('scrollTop');
        }

        var scroller = this._getScroller();
        scrollTop = scroller.scrollTop;
        // check if only x updated
        if (
          (!isNaN(x) && isNaN(y)) ||
          (!isNaN(x) && y === scrollTop && x !== this._getScrollX(scroller, x))
        ) {
          // if not horizontally scrollable then bail
          if (!this._isScrollableX()) {
            this._clearOutstandingScrollPosition();
            return;
          }

          this._setScrollX(scroller, x);
          var scrollPosition = this.GetOption('scrollPosition');
          x = this._getScrollX(scroller);
          var newScrollPosition = {
            x: x,
            y: scrollPosition.y,
            index: scrollPosition.index,
            key: scrollPosition.key,
            offsetX: x,
            offsetY: scrollPosition.offsetY
          };
          if (scrollPosition.parent) {
            newScrollPosition.parent = scrollPosition.parent;
          }
          this.SetOption('scrollPosition', newScrollPosition, {
            _context: {
              originalEvent: null,
              internalSet: true
            }
          });
        } else if (Math.abs(scrollTop - y) >= 1) {
          var scrollUpdated = false;
          // flag it so that handleScroll won't do anything
          if (this._isScrollableY()) {
            scrollUpdated = this._setScrollY(scroller, y);
          }
          if (!isNaN(x) && x !== this._getScrollX(scroller, x) && this._isScrollableX()) {
            this._setScrollX(scroller, x);
            scrollUpdated = true;
          }

          // if nothing is updated, just bail
          if (!scrollUpdated) {
            // still need to update scrollPosition for the scroll and fetch case
            if (this.m_scrollPosition) {
              this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
                _context: {
                  originalEvent: null,
                  internalSet: true
                }
              });
            }
            this._clearOutstandingScrollPosition();
            return;
          }

          // checks if further scrolling is needed
          scrollTop = scroller.scrollTop;
          // cannot use scrollTop === y, as browser sub-pixel could be off by < 1px
          if (
            Math.abs(scrollTop - y) >= 1 &&
            this.m_contentHandler.hasMoreToFetch &&
            this.m_contentHandler.hasMoreToFetch()
          ) {
            if (this.m_scrollPosition == null) {
              // we don't need to signalTaskStart again if we are already in one
              this.signalTaskStart('Scroll position needs to resolve further');
            }
            this.m_scrollAndFetch = true;

            // yes, save the scrollPosition to set and bail
            this.m_scrollPosition = position;
            return;
          }

          // ok to update scrollPosition option
          this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
            _context: {
              originalEvent: null,
              internalSet: true
            }
          });
        } else if (position && (position.key == null || isNaN(position.index))) {
          // if x and y is present, but position value is not complete, get it
          // ok to update scrollPosition option
          this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
            _context: {
              originalEvent: null,
              internalSet: true
            }
          });
        }

        this._clearOutstandingScrollPosition();
      },

      /**
       * Clear the variable for intermediate scrollPosition (that require fetch)
       * @private
       */
      _clearOutstandingScrollPosition: function () {
        if (this.m_scrollPosition != null) {
          // free signalTaskStart from earlier when m_scrollPosition is saved
          this.signalTaskEnd();
          this.m_scrollPosition = null;
        }
      },

      /**
       * When an item is updated, if the item happens to be the current item and it previously has focus, then
       * we'll need to restore focus.
       * @protected
       */
      restoreCurrentItemFocus: function (elem) {
        if (this._isInViewport(elem)) {
          this._setActive($(elem), null, false);
        }
      },
      /**
       * Called by content handler to reset the state of ListView
       * @private
       */
      ClearCache: function (clearKeyMap) {
        // clear any element dependent cache
        this.m_items = null;
        this.m_groupItems = null;
        if (clearKeyMap && this.m_keyElemMap != null) {
          this.m_keyElemMap.clear();
        }
      },

      /**
       * Determine the minimum number of items needed to fill the viewport
       * @protected
       */
      getMinimumCountForViewport: function () {
        var itemHeight = this._getItemHeight();
        var clientHeight = this._getClientHeight();
        if (!isNaN(itemHeight) && itemHeight > 0) {
          var numOfItems = Math.ceil(clientHeight / itemHeight);
          return numOfItems;
        }
        return 1;
      },

      /**
       * Checks whether the specified element is within the viewport
       * @private
       */
      _isInViewport: function (elem) {
        return DataCollectionUtils.isElementIntersectingScrollerBounds(elem, this._getScroller());
      },

      /**
       * Gets a list of actions that supports animation
       * @private
       */
      _getAnimatedActions: function () {
        return ['add', 'remove', 'update', 'expand', 'collapse'];
      },

      /**
       * Utility method to start animation
       * @param {Element} elem element to animate
       * @param {string} action the animation action
       * @param {Object=} effect optional animation effect, if not specified then it will be derived based on action
       * @return {Promise} the promise which will be resolve when animation ends
       * @protected
       */
      StartAnimation: function (elem, action, effect) {
        // if it's not in viewport, don't animate.  Only do this for default animations.
        // For example, do not do this optimization for NavList specific animations.
        if (this._getAnimatedActions().indexOf(action) > -1 && !this._isInViewport(elem)) {
          return Promise.resolve(null);
        }

        if (effect == null) {
          // eslint-disable-next-line no-param-reassign
          effect = this.getAnimationEffect(action);
        }

        var originalHeight;
        var originalMaxHeight;
        if (action === 'expand') {
          var initialHeight = elem.getAttribute('data-oj-initial-height');
          if (initialHeight != null && !isNaN(initialHeight)) {
            // clone it to inject additional effect options
            // eslint-disable-next-line no-param-reassign
            effect = Object.assign({}, effect);
            // eslint-disable-next-line no-param-reassign
            effect.startMaxHeight = initialHeight + 'px';
            var contentHeight = elem.offsetHeight;
            // in the shrink case (skeleton height is taller than actual content height)
            if (contentHeight < initialHeight) {
              originalMaxHeight = elem.style.maxHeight;
              originalHeight = elem.style.height;
              // eslint-disable-next-line no-param-reassign
              elem.style.maxHeight = 'none';
              // eslint-disable-next-line no-param-reassign
              elem.style.height = initialHeight + 'px';
              // eslint-disable-next-line no-param-reassign
              effect.effect = 'collapse';
              // eslint-disable-next-line no-param-reassign
              effect.endMaxHeight = contentHeight + 'px';
            }
            elem.removeAttribute('data-oj-initial-height');
          }
        }

        // eslint-disable-next-line no-undef
        var promise = AnimationUtils.startAnimation(elem, action, effect, this.ojContext);
        if (originalHeight !== undefined) {
          promise.then(function () {
            // eslint-disable-next-line no-param-reassign
            elem.style.height = originalHeight;
            // eslint-disable-next-line no-param-reassign
            elem.style.maxHeight = originalMaxHeight;
          });
        }
        return promise;
      },

      /** ******************* context menu methods *****************/
      /**
       * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
       * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
       * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
       * Invoked by widget
       */
      notifyContextMenuGesture: function (menu, event, eventType) {
        // first check if we are invoking on an editable or clickable element If so bail
        var noData = this.element[0].querySelector('.oj-listview-no-data-item');
        if (noData == null && this.IsNodeEditableOrClickable($(event.target))) {
          return false;
        }

        // set the item right click on active
        var parent = $(event.target).closest('.' + this.getItemElementStyleClass());
        if (parent.length > 0 && !this.SkipFocus($(parent[0]))) {
          this.SetCurrentItem($(parent[0]), null);
        }

        // for Tabbar/NavList, the custom element is the focusable element, so using
        // this.element (<ul>) won't work, use this.ojContext.element instead
        // which works for ListView as well as Tabbar/NavList
        var openOptions = { launcher: this.ojContext.element, initialFocus: 'menu' };

        if (eventType === 'keyboard') {
          var posOf = this.m_active != null ? this.m_active.elem : this.element;
          openOptions.position = { my: 'start top', at: 'start bottom', of: posOf };
        }

        if (this.ojContext._GetContextMenu() == null) {
          // wait for menu to be close first
          Context.getContext(menu)
            .getBusyContext()
            .whenReady()
            .then(
              function () {
                // prepare the context menu that have listview specific menu items
                this.PrepareContextMenu(parent);
                this.ojContext._OpenContextMenu(event, eventType, openOptions);
              }.bind(this)
            );
        } else {
          this.PrepareContextMenu(parent);
          this.ojContext._OpenContextMenu(event, eventType, openOptions);
        }
        return undefined;
      },

      /**
       * Decorates or prepares context menu items. Navlist need overrides this to decorate remove menu item.
       * @param {jQuery} item  Item
       * @protected
       * @ignore
       */
      // eslint-disable-next-line no-unused-vars
      PrepareContextMenu: function (item) {
        var contextMenu = this.ojContext._GetContextMenu();
        if (this.m_dndContext != null && contextMenu) {
          this.m_dndContext.prepareContextMenu(contextMenu);
        }
      },

      /**
       * Override helper for NavList to override checks for whether a node is editable or clickable.
       * @param {jQuery} node  Node
       * @return {boolean} true or false
       * @protected
       */
      IsElementEditableOrClickable: function (node) {
        var nodeName = node.prop('nodeName');
        return nodeName.match(/^INPUT|SELECT|OPTION|BUTTON|^A\b|TEXTAREA/) != null;
      },

      /**
       * Return whether the node is editable or clickable.  Go up the parent node as needed.
       * @param {jQuery} node  Node
       * @return {boolean} true or false
       * @protected
       */
      IsNodeEditableOrClickable: function (node) {
        while (node != null && node[0] !== this.element[0] && node.prop('nodeName') !== 'LI') {
          // If the node is a text node, move up the hierarchy to only operate on elements
          // (on at least the mobile platforms, the node may be a text node)
          if (node[0].nodeType === 3) {
            // 3 is Node.TEXT_NODE
            // eslint-disable-next-line no-param-reassign
            node = node.parent();
          } else {
            var tabIndex = node.attr('tabIndex');
            // listview overrides the tab index, so we should check if the data-oj-tabindex is populated
            var origTabIndex = node.attr('data-oj-tabindex');

            if (
              tabIndex != null &&
              tabIndex >= 0 &&
              !node.hasClass(this.getFocusedElementStyleClass()) &&
              !node.hasClass('oj-listview-cell-element')
            ) {
              return true;
            } else if (this.IsElementEditableOrClickable(node)) {
              // ignore elements with tabIndex === -1
              if (tabIndex !== -1 || origTabIndex !== -1) {
                return true;
              }
            }
            // eslint-disable-next-line no-param-reassign
            node = node.parent();
          }
        }
        return false;
      },

      /** ******************* focusable/editable element related methods *****************/
      /**
       * Make all tabbable elements within the specified cell un-tabbable
       * @param {Element} element
       * @param {boolean=} excludeActiveElement see inline comment for details
       */
      disableAllTabbableElements: function (element, excludeActiveElement) {
        var elem = $(element);

        // if it's a group item, inspect the direct div only so it will skip all children
        if (!elem.hasClass(this.getItemStyleClass())) {
          elem = $(elem.get(0).firstElementChild);
        }

        // a group cell could have contained a cell element, which should be skip also
        if (elem.children().first().hasClass('oj-listview-cell-element')) {
          elem = $(elem.get(0).firstElementChild);
        }

        // should exclude non-visible elements, but doing a visible check here causes re-layout and since it's done
        // on every item on render, it becomes expensive.  Do the filter later in enableTabbableElements, which is only
        // triggered by entering actionable mode.
        if (elem[0]) {
          var elems = $(
            DataCollectionUtils.disableAllFocusableElements(elem[0], excludeActiveElement)
          );

          elems.each(function () {
            $(this).removeAttr('data-first').removeAttr('data-last');
          });
        }
      },

      /**
       * Make all tabbable elements before and include current item un-tabbable
       * @param {Element} item
       * @private
       */
      _disableAllTabbableElementsBeforeItem: function (item) {
        var items = this._getItemsCache();
        var index = items.index(item);

        // if -1 it will just bail
        for (var i = 0; i <= index; i++) {
          this.disableAllTabbableElements(items[i], true);
        }
      },

      /**
       * Make all tabbable elements after and include current item un-tabbable
       * @param {Element} item
       * @private
       */
      _disableAllTabbableElementsAfterItem: function (item) {
        var items = this._getItemsCache();
        var index = items.index(item);

        if (index === -1) {
          return;
        }

        for (var i = index; i <= items.length - 1; i++) {
          this.disableAllTabbableElements(items[i], true);
        }
      },

      /**
       * Make all previously tabbable elements within the element tabbable again
       * @param {jQuery} elem
       * @private
       */
      _enableAllTabbableElements: function (elem) {
        var elems = $(DataCollectionUtils.enableAllFocusableElements(elem[0]));

        // mark first and last tabbable element for fast retrieval later
        elems = elems.filter(':visible');
        elems.first().attr('data-first', 'true');
        elems.last().attr('data-last', 'true');
      },

      /**
       * Cleanup any attributes added by tabbing logic
       * @param {Element} elem the element to cleanup
       * @private
       */
      _cleanupTabbableElementProperties: function (elem) {
        DataCollectionUtils.enableAllFocusableElements(elem[0]).forEach(function (node) {
          node.removeAttribute('data-first');
          node.removeAttribute('data-last');
        });
      },

      /**
       * Checks whether the element is focusable
       * @param {jQuery} item the item to check
       * @return {boolean} true if the item should not be focusable, false otherwise
       * @protected
       */
      SkipFocus: function (item) {
        return item.hasClass('oj-skipfocus');
      },

      /** ************************************* Event handlers *****************************/
      /**
       * Returns the focus element, or the root element if nothing inside ListView has focus
       * @return {Element} the focus element inside ListView or the root element
       * @protected
       */
      GetFocusElement: function () {
        if (this.getListContainer().hasClass('oj-focus-ancestor')) {
          // find the focus item
          if (this.m_active) {
            return this.getFocusItem(this.m_active.elem)[0];
          }

          // empty text could have focus
          var emptyText = this.element.children('.' + this.getEmptyTextStyleClass()).first();
          if (emptyText.length > 0 && emptyText.attr('tabIndex') === 0) {
            return emptyText[0];
          }
        }

        return this.element[0];
      },

      /**
       * Determine whether the event is triggered by interaction with element inside ListView
       * Note that Firefox 48 does not support relatedTarget on blur event, see
       * _supportRelatedTargetOnBlur method
       * @param {Event} event the focus or blur event
       * @return {boolean} true if focus/blur is triggered by interaction with element within listview, false otherwise.
       * @private
       */
      _isFocusBlurTriggeredByDescendent: function (event) {
        if (event.relatedTarget === undefined) {
          return true;
        }

        if (
          event.relatedTarget == null ||
          !$.contains(this.ojContext.element.get(0), /** @type {Element} */ (event.relatedTarget))
        ) {
          return false;
        }
        return true;
      },

      /**
       * Handler for focus event
       * @param {Event} event the focus event
       * @protected
       */
      HandleFocus: function (event) {
        this._clearFocusoutTimeout();
        this._clearFocusoutBusyState();
        this.getListContainer().addClass('oj-focus-ancestor');

        // first time tab into listview, focus on first item
        if (this.m_active == null) {
          // checks whether there's pending click to active, and the focus target is not inside any item (if it is the focus will shift to that item) or it's a unfocusable item
          var item = this.FindItem($(event.target));
          if (
            !this.m_preActive &&
            !this._isFocusBlurTriggeredByDescendent(event) &&
            (item == null || item.length === 0 || this.SkipFocus(item))
          ) {
            this._initFocus(event);
          }
        } else {
          // focus could be caused by pending click to active
          // do not do this on iOS or Android, otherwise VO/talkback will not work correctly
          // Only one exception is when ever root node gets focus we should highlight active element
          // otherwise vo doesn't follow the focus. ex: when offcanvas is opened,
          // focus will be moved to root node
          if (
            !this.m_preActive &&
            event.target === this.ojContext.element[0] &&
            !this._isFocusBlurTriggeredByDescendent(event)
          ) {
            this._makeFocusable(this.m_active.elem);
            this.HighlightActive();
            this._focusItem(this.m_active.elem);
          }

          // remove tab index from root and restore tab index on focus item
          this.RemoveRootElementTabIndex();
          this._setTabIndex(this.m_active.elem);
        }
      },

      /**
       * Invoked by dnd context after drag end
       */
      restoreFocusAfterDrag: function () {
        if (this.m_active == null) {
          this._initFocus(null);
        } else {
          this._makeFocusable(this.m_active.elem);
          this.HighlightActive();
          this._focusItem(this.m_active.elem);
          this.RemoveRootElementTabIndex();
        }

        if (this.m_active) {
          this.m_active.elem.removeClass('oj-focus-highlight');
        }
      },
      /**
       * Initialize focus by finding the first focusable item and set focus on it
       * @private
       */
      _initFocus: function (event) {
        var items = this._getItemsCache();
        for (var i = 0; i < items.length; i++) {
          var item = $(items[i]);
          // make sure item can receive focus
          if (!this.SkipFocus(item)) {
            this.SetCurrentItem(item, event);
            break;
          }
        }

        if (items.length === 0) {
          // we need to focus on empty text
          this._focusEmptyContent();
        }
      },

      /**
       * Handles focusing on no data content
       * @private
       */
      _focusEmptyContent: function () {
        // we need to focus on empty text
        var emptyText = this.element.children('.' + this.getEmptyTextStyleClass()).first();
        if (emptyText.length === 0) {
          emptyText = this.element.find('.oj-listview-no-data-container[role="row"]').first();
        }
        if (emptyText.length > 0) {
          emptyText.children().first().attr('tabIndex', 0);
          this._highlightElem(emptyText, 'oj-focus');
          emptyText.children().first().focus();

          this.RemoveRootElementTabIndex();
        }
      },

      /**
       * temporarily shift focus to an internal div inside listview
       * @private
       */
      _tempShiftFocus: function () {
        var container = this.getListContainer()[0];
        var tempFocusDiv = container.querySelector('.oj-listview-temp-focus');
        if (tempFocusDiv == null) {
          tempFocusDiv = document.createElement('div');
          tempFocusDiv.classList.add('oj-listview-temp-focus');
          tempFocusDiv.setAttribute('tabindex', '-1');
          container.appendChild(tempFocusDiv);
        }
        tempFocusDiv.focus({ preventScroll: true });
      },

      /**
       * Handler for focus out event
       * @param {Event} event the focusout event
       * @protected
       */
      HandleFocusOut: function (event) {
        this.HandleBlur(event);
      },

      /**
       * Checks whether the browser supports relatedTarget field for blur event
       * @return {boolean} true if supported, false otherwise
       * @private
       */
      _supportRelatedTargetOnBlur: function () {
        if (DataCollectionUtils.isFirefox() && DataCollectionUtils.getBrowserVersion() < 48) {
          return false;
        }

        return true;
      },

      /**
       * Detects whether this is a double blur event fired by IE11
       * @param {Event} event the blur event
       * @private
       */
      _isExtraBlurEvent: function (event) {
        if (
          event.relatedTarget == null &&
          DataCollectionUtils.isIE() &&
          event.target === this.ojContext.element.get(0)
        ) {
          return true;
        }

        return false;
      },

      /**
       * Clears any pending focusout timeout.
       * @private
       */
      _clearFocusoutTimeout: function () {
        if (this._focusoutTimeout) {
          clearTimeout(this._focusoutTimeout);
          this._focusoutTimeout = null;
        }
      },

      /**
       * Sets the 'focusout' busy state.
       * @private
       */
      _setFocusoutBusyState: function () {
        if (!this._focusoutResolveFunc) {
          this._focusoutResolveFunc = this._addComponentBusyState('is handling focusout.');
        }
      },

      /**
       * Sets the 'scrollPos' busy state.
       * @private
       */
      _setScrollPosBusyState: function () {
        if (!this.ojContext._IsCustomElement()) {
          // for widget based ListView, consumers rely on the widget's whenReady method
          // which relies on signalTaskStart/signalTaskEnd, changing it requires a lot of work
          this.signalTaskStart('waiting for scroll handler');
        } else if (!this._scrollPosResolveFunc) {
          this._scrollPosResolveFunc = this._addComponentBusyState('is waiting for scroll handler.');
        }
      },

      /**
       * Called by component to add a busy state and return the resolve function
       * to call when the busy state can be removed.
       * @param {String} msg the description of the busy state
       * @private
       */
      _addComponentBusyState: function (msg) {
        var busyContext = Context.getContext(this.element[0]).getBusyContext();
        var options = {
          description: "The component identified by '" + this.element[0].id + "' " + msg
        };
        return busyContext.addBusyState(options);
      },

      /**
       * Clears the 'focusout' busy state.
       * @private
       */
      _clearFocusoutBusyState: function () {
        if (this._focusoutResolveFunc) {
          this._focusoutResolveFunc();
          this._focusoutResolveFunc = null;
        }
      },

      /**
       * Clears the 'scrollPos' busy state.
       * @private
       */
      _clearScrollPosBusyState: function () {
        if (!this.ojContext._IsCustomElement()) {
          this.signalTaskEnd();
        } else if (this._scrollPosResolveFunc) {
          this._scrollPosResolveFunc();
          this._scrollPosResolveFunc = null;
        }
      },

      /**
       * Handler for blur event
       * @param {Event} event the blur event
       * @protected
       */
      HandleBlur: function (event) {
        this._clearFocusoutTimeout();

        // remove focus class on blur of expand/collapse icon
        if (this._isExpandCollapseIcon(event.target)) {
          this._focusOutHandler($(event.target));
        }
        if (this._isActionableMode()) {
          // checks if the focusout event is triggered by popup originated from within listview
          // if it is don't do anything as we do not want to exit actionable mode.
          if (ojkeyboardfocusUtils.getLogicalChildPopup(this.getListContainer()) != null) {
            return;
          }

          this._setFocusoutBusyState();
          // set timeout to stay in editable/actionable mode if focus comes back into the listview
          // prettier-ignore
          this._focusoutTimeout = setTimeout( // @HTMLUpdateOK
            function () {
              if (
                this.m_active == null ||
                !this.m_active.elem.get(0).contains(document.activeElement)
              ) {
                this._doBlur();
              }
              this._clearFocusoutBusyState();
            }.bind(this),
            100
          );

          // event.relatedTarget would be null if focus out of page
          // the other check is to make sure the blur is not caused by shifting focus within listview
        } else if (!this._isFocusBlurTriggeredByDescendent(event) && !this.m_preActive) {
          // when a blur is triggered by switching windows for example
          // the activeElement remains the same, in such case, we don't want to
          // change tabindex to ul as well otherwise when switched back to document
          // the focus will get lost and assigned to body
          if (this.m_active == null || !this.m_active.elem.get(0).contains(document.activeElement)) {
            this._doBlur();
          }
        }
      },

      /**
       * @private
       */
      _doBlur: function () {
        if (this._isActionableMode()) {
          this._exitActionableMode();
        }

        this.getListContainer().removeClass('oj-focus-ancestor');
        this.UnhighlightActive();

        // remove tab index from focus item and restore tab index on list
        // and remove any aria-labelled by set by card navigation
        if (this.m_active != null) {
          this._resetTabIndex(this.m_active.elem);
          this._removeSkipItemAriaLabel(this.m_active.elem);
        } else {
          var emptyText = this.element.children('.' + this.getEmptyTextStyleClass()).first();
          if (emptyText.length === 0) {
            emptyText = this.element.find('.oj-listview-no-data-container[role="row"]').first();
          }
          if (emptyText.length > 0) {
            emptyText.children().first().removeAttr('tabIndex');
            this._unhighlightElem(emptyText, 'oj-focus');
          }
        }
        this.SetRootElementTabIndex();
      },

      /**
       * Event handler for when user exits an item in list
       * @param {Event} event mouseout event
       * @private
       */
      _handleMouseOut: function (event) {
        var item = this.FindItem(event.target);
        if (item != null) {
          this.m_hoverItem = null;
          this._unhighlightElem(item, 'oj-hover');
        }
      },

      /**
       * Event handler for when user hovers over list
       * @param {Event} event mouseover event
       * @private
       */
      _handleMouseOver: function (event) {
        // do this for real mouse enters, but not 300ms after a tap
        // skip if we are in the middle of dnd
        if (
          !this._isShowHover() ||
          this._recentTouch() ||
          (this.m_dndContext && this.m_dndContext.isDndInProgress())
        ) {
          return;
        }

        var item = this.FindItem(event.target);
        if (item != null && !this.SkipFocus(item)) {
          // skip hover if item is not expandable/collapsible group header
          if (
            !this._isSelectionEnabled() &&
            !item.children().first().hasClass(this.getGroupItemStyleClass())
          ) {
            return;
          }
          // have to remember it so we can clear it when listview is detached from DOM
          this.m_hoverItem = item;
          this._highlightElem(item, 'oj-hover');
        }
      },

      /**
       * Whether to show hover or not.  Currently we only show hover if selection is enabled
       * and drag is enabled (without affordance, which requires selection to be enabled)
       * @private
       */
      _isShowHover: function () {
        var isRedWood = ThemeUtils.parseJSONFromFontFamily('oj-theme-json').behavior === 'redwood';
        // Hover only over redwood listview collapsible group header
        return (
          this._isSelectionEnabled() || (isRedWood && this.isExpandable() && this.ShouldUseGridRole())
        );
      },

      _recentTouch: function () {
        return Date.now() - this._lastTouch < 500; // must be at least 300 for the "300ms" delay
      },

      /**
       * Event handler for when user press down a key
       * @param {Event} event keydown event
       * @protected
       */
      HandleKeyDown: function (event) {
        if (this.isExpandable()) {
          var key = event.key || event.keyCode;
          if (
            key === 'ArrowLeft' ||
            key === 'Left' ||
            key === this.LEFT_KEY ||
            key === 'ArrowRight' ||
            key === 'Right' ||
            key === this.RIGHT_KEY
          ) {
            var current = this.m_active.elem;
            var isRTL = this.ojContext._GetReadingDirection() === 'rtl';

            if (key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY) {
              if (this.GetState(current) === this.STATE_EXPANDED && !isRTL) {
                this.CollapseItem(current, event, true, this.m_active.key, true, true);
                return;
              } else if (this.GetState(current) === this.STATE_COLLAPSED && isRTL) {
                this.ExpandItem(current, event, true, this.m_active.key, true, true, true);
                return;
              }
            }
            if (key === 'ArrowRight' || key === 'Right' || key === this.RIGHT_KEY) {
              if (this.GetState(current) === this.STATE_COLLAPSED && !isRTL) {
                this.ExpandItem(current, event, true, this.m_active.key, true, true, true);
                return;
              } else if (this.GetState(current) === this.STATE_EXPANDED && isRTL) {
                this.CollapseItem(current, event, true, this.m_active.key, true, true);
                return;
              }
            }
          }
        }
        var processed = this.HandleSelectionOrActiveKeyDown(event);

        // dnd
        if (this.m_dndContext != null) {
          processed = processed || this.m_dndContext.HandleKeyDown(event);
        }

        if (processed === true) {
          event.preventDefault();
          event.stopPropagation();
        }

        this.m_keyProcessed = processed;
      },

      /**
       * Event handler for whenever press up occurred
       * @param {Event} event keyup event
       * @protected
       */
      HandleKeyUp: function (event) {
        // popup process esc key on keyup so we have to stop keyup from bubbling
        var key = event.key || event.keyCode;
        if ((key === 'Escape' || key === 'Esc' || key === this.ESC_KEY) && this.m_keyProcessed) {
          event.stopPropagation();
        }
        this.m_keyProcessed = undefined;
      },

      /**
       * @private
       */
      _handleMouseUpOrPanMove: function (event) {
        // unhighlight item that got focus in mousedown
        if (this.m_preActiveItem) {
          this._unhighlightElem(this.m_preActiveItem, 'oj-focus');
        }

        // dnd
        if (this.m_dndContext != null && this.m_dragger && this.m_dragger.get(0) !== event.target) {
          this.m_dndContext._unsetDraggable(this.m_dragger);
          this.m_dragger = null;
        }
      },

      /**
       * @private
       */
      _isNodeFocusable: function (node) {
        var itemStyleClass = this.getItemElementStyleClass();
        return DataCollectionUtils.isElementOrAncestorFocusable(node, function (element) {
          return (
            element.classList.contains(itemStyleClass) ||
            element.classList.contains('oj-listview-cell-element')
          );
        });
      },

      /**
       * Event handler for when mouse down or touch start anywhere in the list
       * @param {Event} event mousedown or touchstart event
       * @protected
       */
      HandleMouseDownOrTouchStart: function (event) {
        // click on item
        var target = $(event.target);

        // dnd
        if (this.m_dndContext != null) {
          this.m_dndContext._setDraggable(target);
          this.m_dragger = target;
        }

        var item = this.FindItem(target);
        // bail if clickthrough disabled legacy syntax is detected
        // we'll still need to set the flag so that the focus do not shift
        if (
          item != null &&
          item.length > 0 &&
          this._isLegacyClickthroughDisabled(event, item.get(0))
        ) {
          this.m_preActive = true;
          item = null;
        }

        if (
          item == null ||
          item.length === 0 ||
          this.SkipFocus(item) ||
          target.hasClass('oj-listview-drag-handle')
        ) {
          // one of the following happened:
          // 1) can't find item
          // 2) item cannot be focus
          // 3) target is an oj-component
          // 4) target or one of its ancestors has the oj-clickthrough-disabled marker class
          // 5) target is the drag handle
          return;
        }

        this._preventNativeShiftSelection(event);

        this.m_preActive = true;

        // make sure listview has focus
        if (!this.getListContainer().hasClass('oj-focus-ancestor')) {
          this.getListContainer().addClass('oj-focus-ancestor');
        }

        // we'll need to remove focus in case the actual focus item is different
        this.m_preActiveItem = item;

        if (!DataCollectionUtils.isIos() && this._isTextSelectionEnabled()) {
          this._allowSelectionOnClick = true;
        }

        // apply focus
        this._highlightElem(item, 'oj-focus');

        // focus on item, we need to do it on mousedown instead of click otherwise click handler will
        // steal focus from popup and causes it to close prematurely
        this._makeFocusable(item);
        // checks whether focus is already inside some in item, if it is don't try to steal focus away from it (combobox)
        // if target is focusable by itself, don't try to steal focus either
        // if active element is outside of the list, as in the case of things inside popup, don't try to steal focus
        if (
          this.element[0].contains(document.activeElement) &&
          !item.get(0).contains(document.activeElement) &&
          !this._isNodeFocusable(target[0])
        ) {
          this._focusItem(item);
        }

        // make sure ul is not tabbable
        this.RemoveRootElementTabIndex();
        // reset tab index must be done after focusing another item
        if (this.m_active != null && this.m_active.elem.get(0) !== item.get(0)) {
          this._resetTabIndex(this.m_active.elem);
        }

        // need this on touchend
        if (event.originalEvent.touches && event.originalEvent.touches.length > 0) {
          this.m_touchPos = {
            x: event.originalEvent.changedTouches[0].pageX,
            y: event.originalEvent.changedTouches[0].pageY
          };
        }

        // mouse down on input element inside item should trigger actionable mode
        if (this.isInputOrEditableContentElement(target.get(0))) {
          this._enterActionableMode(item);
        }
      },

      /**
       * Prevents text getting selected during shift+click
       * @private
       */
      _preventNativeShiftSelection: function (event) {
        const isTextSelection = this._isTextSelectionEnabled();
        const isMultiSelect = this.GetOption('selectionMode') === 'multiple';
        if (isTextSelection && event.shiftKey && this.m_selectionFrontier && isMultiSelect) {
          event.preventDefault();
        }
      },

      /**
       * Event handler for when touch end/cancel happened
       * @param {Event} event touchend or touchcancel event
       * @protected
       */
      HandleTouchEndOrCancel: function (event) {
        var action = 'pointerUp';

        // unhighlight item that got focus in touchstart
        if (this.m_preActiveItem != null) {
          this._unhighlightElem(this.m_preActiveItem, 'oj-focus');

          // start ripple effect
          if (this.m_touchPos != null) {
            var offset = this.m_preActiveItem.offset();

            // find where to start the ripple effect based on touch location
            var effect = this.getAnimationEffect(action);
            effect.offsetX = this.m_touchPos.x - offset.left + 'px';
            effect.offsetY = this.m_touchPos.y - offset.top + 'px';

            var groupItem = this.m_preActiveItem.children('.' + this.getGroupItemStyleClass());
            var elem;
            if (groupItem.length > 0) {
              elem = /** @type {Element} */ (groupItem.get(0));
            } else {
              elem = /** @type {Element} */ (this.getFocusItem(this.m_preActiveItem).get(0));
            }

            // don't apply ripple effect on the item when target is one of these controls
            var target = event.target;
            if (elem) {
              var nodes = elem.querySelectorAll(
                "input, select, button, a, textarea, object, [tabIndex]:not([tabIndex='-1']), [data-oj-tabmod], [contenteditable='true']"
              );
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].contains(target)) {
                  elem = null;
                  break;
                }
              }
            }

            // we don't really care when animation ends
            if (elem != null) {
              this.StartAnimation(elem, action, effect);
            }

            this.m_touchPos = null;
          }
        }

        // need this so that on mouse over handler would not apply the styles if the last touch was within the last n ms
        this._lastTouch = Date.now();
        this._handleMouseOut(event);
      },

      /**
       * Enters actionable mode
       * @private
       */
      _enterActionableMode: function (item) {
        var current = item === undefined ? this.m_active.elem : item;

        if (current) {
          // in case content has been updated under the cover
          this.disableAllTabbableElements(current);

          // re-enable all tabbable elements
          this._enableAllTabbableElements(current);

          // only go into actionable mode if there is something to focus
          var first = current.find('[data-first]');
          if (first.length > 0) {
            this._setActionableMode(true);
          }
        }
      },

      /**
       * Exits actionable mode
       * @private
       */
      _exitActionableMode: function () {
        this._setActionableMode(false);

        // disable all tabbable elements in the item again
        if (this.m_active) {
          this.disableAllTabbableElements(this.m_active.elem);
          this.m_active.elem.removeClass('oj-focus-previous-highlight');
        }
      },

      /**
       * Event handler for when mouse click anywhere in the list
       * @param {Event} event mouseclick event
       * @protected
       */
      HandleMouseClick: function (event) {
        // only perform events on left mouse, (right in rtl culture)
        if (event.button === 0) {
          var collapseIconClass = this.getCollapseIconStyleClass();
          var expandIconClass = this.getExpandIconStyleClass();
          var target = $(event.target);
          if (target.hasClass(expandIconClass)) {
            this._collapse(event);
            event.preventDefault();
          } else if (target.hasClass(collapseIconClass)) {
            this._expand(event);
            event.preventDefault();
          } else {
            // click on item
            var item = this.FindItem(target);
            if (item == null || item.length === 0) {
              // can't find item
              return;
            }

            // bail if legacy clickthrough syntax is detected
            if (this._isLegacyClickthroughDisabled(event, item[0])) {
              return;
            }

            // if item is not focusable
            if (this.SkipFocus(item)) {
              // still need to expand/collapse header
              this._handleHeaderClick(event, target, item);
              return;
            }

            if (
              this._isActionableMode() &&
              this.m_active != null &&
              this.m_active.elem.get(0) !== item.get(0) &&
              !this.isInputOrEditableContentElement(target.get(0))
            ) {
              // click on item other than current focus item should exit actionable mode
              this._exitActionableMode();
            }

            // make sure listview has focus
            if (!this.getListContainer().hasClass('oj-focus-ancestor')) {
              this.getListContainer().addClass('oj-focus-ancestor');
            }

            var allowSelection =
              this._isTextSelectionEnabled() === false || this._allowSelectionOnClick !== false;
            var clickthroughDisabled = this._isClickthroughDisabled(event, item);

            // check if selection is enabled
            if (
              !clickthroughDisabled &&
              allowSelection &&
              this._isSelectionEnabled() &&
              this.IsSelectable(item[0])
            ) {
              var sourceCapabilityTouch =
                event.originalEvent.sourceCapabilities &&
                event.originalEvent.sourceCapabilities.firesTouchEvents;
              var isTouch =
                this._isTouchSupport() &&
                (sourceCapabilityTouch ||
                  (this.touchStartEvent != null && this.touchStartEvent.target === event.target));

              var processed = true;
              if (isTouch) {
                processed = this._handleTouchSelection(item, event);
              } else {
                processed = this.HandleClickSelection(item, event);
              }

              // if not processed, then we'll still need to make sure it's active
              if (!processed) {
                this.HandleClickActive(item, event);
              }

              // if user hits the padding part of item, since LI does not have tabindex anymore, item will not get focus
              if (this.ShouldUseGridRole() && event.target === item.get(0)) {
                this._focusItem(item);
              }

              // need to make sure every item in the selection have the draggable cursor
              if (this._shouldDragSelectedItems()) {
                this.m_dndContext.setSelectionDraggable();
              }
            } else {
              // if selection or clickthrough is disable, we'll still need to highlight the active item
              this.HandleClickActive(item, event);
            }

            // triger action event
            if (!clickthroughDisabled) {
              this._fireActionEvent(item.get(0), event, true);
              // clicking on header will expand/collapse item
              this._handleHeaderClick(event, target, item);
            }
          }
        }
      },

      /**
       * Handle click on group header
       * @private
       */
      _handleHeaderClick: function (event, target, item) {
        var groupItemClass = this.getGroupItemStyleClass();

        // clicking on header will expand/collapse item
        if (this.isExpandable() && target.closest('.' + groupItemClass)) {
          if (this.GetState(item) === this.STATE_COLLAPSED) {
            this._expand(event);
          } else if (this.GetState(item) === this.STATE_EXPANDED) {
            this._collapse(event);
          }
        }
      },

      /**
       * Fires an item action event
       * @private
       */
      _fireActionEvent: function (item, event, ignoreActionable) {
        if (!ignoreActionable && this._isActionableMode()) {
          return;
        }

        var key = this.GetKey(item);
        var data = this._getDataForItem(item);
        var metadata = this._getMetadataForItem(item);
        var ui = { context: { key: key, data: data, metadata: metadata } };
        this.Trigger('itemAction', event, ui);
      },

      /**
       * Return true if Dnd is supported on selected items only.
       * @private
       * @returns {boolean}
       */
      _shouldDragSelectedItems: function () {
        return this.m_dndContext != null && !this.m_dndContext.shouldDragCurrentItem();
      },
      /** ********************************* end Event handlers *****************************/

      /** ************************************* helper methods *****************************/
      /**
       * Whether touch is supported
       * @return {boolean} true if touch is supported, false otherwise
       * @private
       */
      _isTouchSupport: function () {
        return DomUtils.isTouchSupported();
      },

      /**
       * Whether it is non-window touch device (iOS or Android)
       * @return {boolean} true if it is a non-window touch device
       * @private
       */
      _isNonWindowTouch: function () {
        return this._isTouchSupport() && !DataCollectionUtils.isWindows();
      },

      /**
       * Returns either the ctrl key or the command key in Mac OS
       * @param {!Object} event
       * @private
       */
      _ctrlEquivalent: function (event) {
        return DomUtils.isMetaKeyPressed(event);
      },

      /**
       * Helper method to create subid based on the root element's id
       * @param {string} subId the id to append to the root element id
       * @return {string} the subId to append to the root element id
       * @private
       */
      _createSubId: function (subId) {
        var id = this.element.attr('id');
        return [id, subId].join(':');
      },

      /**
       * Find the item element
       * @param {jQuery} elem
       * @return {jQuery|null}
       * @protected
       */
      FindItem: function (elem) {
        if ($(elem).hasClass(this.getGroupStyleClass())) {
          return null;
        }

        return $(elem).closest('.' + this.getItemElementStyleClass());
      },

      /**
       * Determine if click should be processed based on the element based on legacy syntax (marker class).
       * @param {Event} event
       * @param {Element} item the item element
       * @return {boolean} returns true if the element contains the special marker class, false otherwise.
       * @private
       */
      _isLegacyClickthroughDisabled: function (event, item) {
        var node = event.target;
        while (node != null && node !== item) {
          if (node.classList.contains('oj-clickthrough-disabled')) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      },

      /**
       * Determine if click should be processed based on the element.
       * @param {Event|null} event the event that triggered this check
       * @param {jQuery} elem the element to check
       * @return {boolean} returns true if the element contains the special marker class, false otherwise.
       * @private
       */
      _isClickthroughDisabled: function (event, elem) {
        return elem.length > 0 && DataCollectionUtils.isEventClickthroughDisabled(event, elem.get(0));
      },

      /**
       * Compute the total top and bottom border width of the list container
       * @return {number} the sum of top and bottom border width of the list container
       * @private
       */
      getListContainerBorderWidth: function () {
        if (this.m_borderWidth == null) {
          this.m_borderWidth =
            parseInt(this.getListContainer().css('border-top-width'), 10) +
            parseInt(this.getListContainer().css('border-bottom-width'), 10);
        }

        return this.m_borderWidth;
      },

      /**
       * Scroll as needed to make the specified item visible
       * @param {Object} item the item to make visible
       */
      scrollToItem: function (item) {
        var key = item.key;
        if (key == null) {
          return;
        }

        var elem = this.FindElementByKey(key);
        if (elem == null) {
          return;
        }

        if ($(elem).hasClass(this.getItemStyleClass())) {
          this._scrollToVisible(elem);
        } else {
          // group item
          var group = $(elem)
            .children('.' + this.getGroupItemStyleClass())
            .first();
          this._scrollToGroupHeader(group.get(0));
        }
      },

      /**
       * Scroll as needed to make an element visible in the viewport
       * @param {Element} elem the element to make visible
       * @private
       */
      _scrollToVisible: function (elem) {
        var offset = 0;
        var top;
        var height;
        var container = this.getListContainer()[0];
        var containerScrollTop = container.scrollTop;
        var containerHeight = container.offsetHeight;

        if (elem.classList.contains(this.getItemStyleClass())) {
          top = elem.offsetTop;
          height = elem.offsetHeight;
        } else if (elem.children.length > 0) {
          var groupItemContainer = elem.children[0];
          if (groupItemContainer.classList.contains(this.getGroupItemStyleClass())) {
            top = groupItemContainer.offsetTop;
            height = groupItemContainer.offsetHeight;
          }
        }
        if (isNaN(top) || isNaN(height)) {
          return;
        }

        // if there's sticky header, make sure the elem is not behind it
        if (this.m_groupItemToPin != null) {
          var headerTop = parseInt(this.m_groupItemToPin.style.top, 10);
          var headerHeight = $(this.m_groupItemToPin).outerHeight();
          if (top <= headerTop && headerTop < top + height) {
            offset = (height + top - headerTop) / 2;
          } else if (top >= headerTop && top < headerTop + headerHeight) {
            offset = (headerTop + headerHeight - top) / 2;
          }
        } else if (this.m_closestParent != null) {
          // when native position sticky is used
          var stickyHeader = this.m_closestParent.firstElementChild;
          if (stickyHeader.classList.contains('oj-sticky')) {
            offset = stickyHeader.offsetTop + stickyHeader.offsetHeight - top;
          }
        }

        // if it's within viewport do nothing
        if (top >= containerScrollTop && top + height <= containerScrollTop + containerHeight) {
          if (offset > 0) {
            container.scrollTop = containerScrollTop - offset;
          }
          return;
        }

        // how much need to scroll to see the entire element, and to make sure the element top is always visible
        var scrollTop = Math.max(0, Math.min(top - offset, Math.abs(top + height - containerHeight)));
        if (scrollTop > containerScrollTop) {
          scrollTop += this.getListContainerBorderWidth();
        }
        container.scrollTop = scrollTop;
      },

      /**
       * Get the key associated with an item element
       * @param {Element} elem the item element to retrieve the key
       * @return {Object|null} the key associated with the item element
       * @protected
       */
      GetKey: function (elem) {
        return this.m_contentHandler.GetKey(elem);
      },

      /**
       * Get the element associated with a key
       * @param {Object} key the key to retrieve the item element
       * @return {Element|null} the item element associated with the key
       * @protected
       */
      FindElementByKey: function (key, checkIfAnimating) {
        if (this.m_keyElemMap != null) {
          var id = this.m_keyElemMap.get(key);
          if (id != null) {
            return document.getElementById(id);
          }
        }

        // ask the content handler
        if (this.m_contentHandler) {
          var elem = this.m_contentHandler.FindElementByKey(key);
          // checkIfAnimating should always be set to true, but since this
          // method is called a lot so making this optional to lower potential risk
          // of regression
          if (
            checkIfAnimating &&
            elem &&
            elem.parentNode &&
            elem.parentNode.classList.contains('oj-listview-temp-item')
          ) {
            elem = elem.parentNode;
          }
          return elem;
        }
        // this should not happen
        return null;
      },

      /**
       * Special version of array indexOf to take care of object comparison cases
       * @param {Array} arr the array
       * @param {Object} key the key to find the index for in the array
       * @return {number} the index of the key in the array, or -1 if the key does not exists in the array
       */
      GetIndexOf: function (arr, key) {
        for (var i = 0; i < arr.length; i++) {
          if (key === arr[i] || oj.Object.compareValues(key, arr[i])) {
            return i;
          }
        }

        return -1;
      },

      /**
       * Checks whether element is an expand/collapse icon
       * @param {Element|jQuery} elem the element to check
       * @return {boolean} true if it's an expand/collapse icon, false otherwise
       */
      _isExpandCollapseIcon: function (elem) {
        return (
          $(elem).hasClass(this.getExpandIconStyleClass()) ||
          $(elem).hasClass(this.getCollapseIconStyleClass())
        );
      },

      /**
       * Determine whether gridlines/dividers should be shown
       * @return {boolean} true if visible, false if hidden
       * @private
       */
      _isGridlinesVisible: function () {
        if (this.m_gridlinesVisible == null) {
          var gridlines = this.GetOption('gridlines');
          // would be null for NavList
          if (gridlines == null) {
            return true;
          }
          this.m_gridlinesVisible = gridlines.item !== 'hidden';
        }
        return this.m_gridlinesVisible;
      },

      /**
       * Gets the option defaults for top and bottom border/gridline
       * @private
       */
      _isTopBottomGridlinesVisible: function () {
        var defaultOptions = this._getOptionDefaults();
        var defaultGridlines = defaultOptions.gridlines;
        if (defaultGridlines) {
          return { top: defaultGridlines.top, bottom: defaultGridlines.bottom };
        }
        // like NavList which doesn't have that option defaults
        return { top: true, bottom: true };
      },

      /**
       * Update the style class based on gridline option defaults
       * @private
       */
      _updateGridlines: function () {
        var root = this.GetRootElement()[0];
        if (this._isGridlinesVisible()) {
          root.classList.remove('oj-listview-gridlines-hidden');
        } else {
          root.classList.add('oj-listview-gridlines-hidden');
        }

        var gridlines = this._isTopBottomGridlinesVisible();
        root.classList.remove('gridline-top-hidden');
        root.classList.remove('gridline-bottom-hidden');

        if (gridlines.top === 'hidden') {
          root.classList.add('gridline-top-hidden');
        }

        if (gridlines.bottom === 'hidden') {
          root.classList.add('gridline-bottom-hidden');
        }
      },

      /**
       * Determine whether ListView needs to render a placeholder to show gridline for the last item
       * @private
       */
      _shouldRenderGridlineForLastItem: function () {
        // no effect on card layout
        if (this.isCardLayout()) {
          return false;
        }
        var gridlines = this.GetOption('gridlines');
        if (gridlines != null) {
          var topBottomGridlines = this._isTopBottomGridlinesVisible();
          if (gridlines.item === 'visible' && topBottomGridlines.bottom === 'hidden') {
            return true;
          }
        }
        return false;
      },
      /** ********************************** end helper methods *****************************/

      /** ************************************* Navigation Common **************************/
      /**
       * Determine whether the key code is an arrow key
       * @param {string} key
       * @return {boolean} true if it's an arrow key, false otherwise
       * @protected
       */
      IsArrowKey: function (key) {
        if (this.isCardLayout()) {
          return (
            key === 'ArrowUp' ||
            key === 'Up' ||
            key === this.UP_KEY ||
            key === 'ArrowDown' ||
            key === 'Down' ||
            key === this.DOWN_KEY ||
            key === 'ArrowLeft' ||
            key === 'Left' ||
            key === this.LEFT_KEY ||
            key === 'ArrowRight' ||
            key === 'Right' ||
            key === this.RIGHT_KEY
          );
        }

        return (
          key === 'ArrowUp' ||
          key === 'Up' ||
          key === this.UP_KEY ||
          key === 'ArrowDown' ||
          key === 'Down' ||
          key === this.DOWN_KEY
        );
      },

      /**
       * Retrieve the visible (flattened) items cache, create one if it is null.
       * @return {jQuery} a list of items
       * @private
       */
      _getItemsCache: function () {
        if (this.m_items == null) {
          var disclosureStyleClass = this.getGroupCollapseStyleClass();
          var selector = '.' + this.getItemElementStyleClass() + ':visible';
          this.m_items = this.element
            .find(selector)
            .filter(function () {
              var isGroup = $(this).parent().hasClass(disclosureStyleClass);
              if (isGroup) {
                return !$(this).parent().parent().hasClass('oj-collapsed');
              }
              if (this.tagName !== 'LI') {
                var parentElement = this.parentElement;
                // skip items that are about to be remove
                if (parentElement && parentElement.classList.contains('oj-animate-remove')) {
                  return false;
                }
              }
              return true;
            })
            .map(function (index, elem) {
              var parentElement = elem.parentElement;
              if (
                parentElement &&
                (parentElement.classList.contains('oj-animate-add') ||
                  parentElement.classList.contains('oj-listview-temp-item'))
              ) {
                return parentElement;
              }
              return elem;
            });
        }
        return this.m_items;
      },

      /**
       * Handles when navigate to the last item
       * @param {jQuery} item the item element
       */
      _handleLastItemKeyboardFocus: function (item) {
        var next = item.get(0).nextElementSibling;
        if (next == null || !$(next).hasClass(this.getItemElementStyleClass())) {
          // it could be the last element of the group, if so, make sure it's the last group
          if (
            this.m_contentHandler.IsHierarchical() &&
            item.parent().hasClass(this.getGroupStyleClass())
          ) {
            if (item.parent().parent().get(0).nextElementSibling != null) {
              // bail if it's not the last group
              return;
            }
          }

          // it's the last element, check scroll bar to make sure it scrolls all the way to the bottom
          var scroller = this._getScroller();
          var scrollHeight = this._getScrollHeight();
          if (scroller.scrollTop < scrollHeight) {
            scroller.scrollTop = scrollHeight;
          }
        }
      },

      /**
       * Handles arrow keys navigation on item
       * @param {string} key description
       * @param {boolean} isExtend
       * @param {Event} event the DOM event causing the arrow keys
       * @protected
       */
      HandleArrowKeys: function (key, isExtend, event) {
        // ensure that there's no outstanding fetch requests
        if (!this.m_contentHandler.IsReady()) {
          // act as if processed to prevent page scrolling before fetch done
          return true;
        }

        var current;
        if (!isExtend || this.m_isNavigate) {
          current = this.m_active.elem;
        } else {
          current = this.m_selectionFrontier;
        }

        // invoke different function for handling focusing on active item depending on whether selection is enabled
        var processed = false;

        switch (key) {
          case this.UP_KEY:
          case 'Up':
          case 'ArrowUp':
            if (this.isCardLayout() && $(current).hasClass(this.getItemStyleClass())) {
              this._gotoItemAbove(current, isExtend, event);
            } else {
              this._gotoPrevItem(current, isExtend, event);
            }

            // according to James we should still consume the event even if list view did not perform any action
            processed = true;
            break;
          case this.DOWN_KEY:
          case 'Down':
          case 'ArrowDown':
            if (this.isCardLayout() && $(current).hasClass(this.getItemStyleClass())) {
              this._gotoItemBelow(current, isExtend, event);
            } else {
              this._gotoNextItem(current, isExtend, event);
            }

            // according to James we should still consume the event even if list view did not perform any action
            processed = true;
            break;
          case this.LEFT_KEY:
          case 'Left':
          case 'ArrowLeft':
          case this.RIGHT_KEY:
          case 'Right':
          case 'ArrowRight':
            if (this.isCardLayout()) {
              if (this.ojContext._GetReadingDirection() === 'rtl') {
                // eslint-disable-next-line no-param-reassign
                key =
                  key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY
                    ? 'ArrowRight'
                    : 'ArrowLeft';
              }

              if (key === 'ArrowLeft' || key === 'Left' || key === this.LEFT_KEY) {
                this._gotoPrevItem(current, isExtend, event);
              } else {
                this._gotoNextItem(current, isExtend, event);
              }
              processed = true;
            }
            break;
          default:
            break;
        }

        return processed;
      },

      /**
       * Go to the next item in the list
       * @private
       */
      _gotoNextItem: function (current, isExtend, event) {
        var items = this._getItemsCache();
        var currentIndex = items.index(current) + 1;

        if (currentIndex < items.length) {
          var next = $(items[currentIndex]);
          // make sure it's focusable, otherwise find the next focusable item
          while (this.SkipFocus(next)) {
            currentIndex += 1;
            if (currentIndex === items.length) {
              return;
            }
            next = $(items[currentIndex]);
          }

          if (isExtend) {
            this._extendSelection(next, event);
            this.m_isNavigate = false;
          } else {
            this.SetCurrentItem(next, event);
            this.m_isNavigate = true;
          }

          this._handleLastItemKeyboardFocus(next);
        }
      },

      /**
       * Go to the previous item in the list
       * @private
       */
      _gotoPrevItem: function (current, isExtend, event) {
        var items = this._getItemsCache();
        var currentIndex = items.index(current) - 1;

        if (currentIndex >= 0) {
          var prev = $(items[currentIndex]);
          // make sure it's focusable, otherwise find the next focusable item
          while (this.SkipFocus(prev)) {
            currentIndex -= 1;
            if (currentIndex < 0) {
              return;
            }
            prev = $(items[currentIndex]);
          }

          if (isExtend) {
            this._extendSelection(prev, event);
            this.m_isNavigate = false;
          } else {
            this.SetCurrentItem(prev, event);
            this.m_isNavigate = true;
          }
        }
      },

      /**
       * Calculate the number of the columns in this group
       * @param {jQuery} children the children iterator
       * @return {number} the number of columns
       * @private
       */
      _getColumnCount: function (children) {
        var count;
        var currentOffsetTop;

        children.each(function (index) {
          var offsetTop = this.offsetTop;

          if (currentOffsetTop === undefined) {
            currentOffsetTop = offsetTop;
          } else if (currentOffsetTop !== offsetTop) {
            // on a different row, return immediately
            return false;
          }

          count = index;
          return undefined;
        });

        return count + 1;
      },

      /**
       * Inform screen reader that X number of items have been skipped during up/down arrow key navigation
       * @param {jQuery} next the item to navigate to
       * @param {number} count number of items skipped
       * @private
       */
      _updateSkipItemAriaLabel: function (next, count) {
        var id = this._createSubId('extra_info');
        if (this.m_skipAriaLabelText == null) {
          var root = $(document.createElement('div'));
          root.addClass('oj-helper-hidden-accessible').attr('id', id);
          this.getListContainer().append(root); // @HTMLUpdateOK
          this.m_skipAriaLabelText = root;
        }
        this.m_skipAriaLabelText.text(
          this.ojContext.getTranslatedString('accessibleNavigateSkipItems', { numSkip: count })
        );

        var focusElem = this.getFocusItem(next);
        // make sure it has an id for aria-labelledby
        focusElem.uniqueId().attr('aria-labelledby', id + ' ' + focusElem.prop('id'));
      },

      /**
       * Undo what _updateSkipItemAriaLabel did to active element
       * @param {jQuery} current the item to remove aria property from
       * @private
       */
      _removeSkipItemAriaLabel: function (current) {
        var focusElem = this.getFocusItem(current);
        if (focusElem.length > 0) {
          focusElem.get(0).removeAttribute('aria-labelledby');
        }
      },

      /**
       * Go to the item above the current item in the list
       * @private
       */
      _gotoItemAbove: function (current, isExtend, event) {
        var above;
        var numOfItemSkip;

        // if it's a group, just go to the previous item (which would be the last focusable item in the previous group)
        if (!current.hasClass(this.getItemElementStyleClass())) {
          this._gotoPrevItem(current);
          return;
        }

        var parent = current.parent();
        var items = parent.children('li.' + this.getItemElementStyleClass());
        var numOfCols = this._getColumnCount(items);
        var index = items.index(current);
        var aboveIndex = index - numOfCols;
        if (aboveIndex < 0) {
          // go to header, or stop if there's no header
          if (
            parent.hasClass(this.getGroupStyleClass()) &&
            parent.parent().hasClass(this.getItemElementStyleClass())
          ) {
            above = parent.parent();
            numOfItemSkip = index;
          }
        } else {
          above = $(items.get(aboveIndex));
          numOfItemSkip = numOfCols - 1;
        }

        if (above && above.length > 0) {
          // make sure it's focusable, otherwise no-op
          if (this.SkipFocus(above)) {
            return;
          }

          if (isExtend) {
            this._extendSelection(above, event);
            this.m_isNavigate = false;
          } else {
            if (numOfItemSkip != null && numOfItemSkip > 0) {
              this._updateSkipItemAriaLabel(above, numOfItemSkip);
            }
            this.SetCurrentItem(above, event);
            this.m_isNavigate = true;
          }
        }
      },

      /**
       * Go to the item below the current item in the list
       * @private
       */
      _gotoItemBelow: function (current, isExtend, event) {
        var below;
        var numOfItemSkip;

        // if it's a group, just go to the next item (which would be the first focusable item in the next group)
        if (!current.hasClass(this.getItemElementStyleClass())) {
          this._gotoNextItem(current);
          return;
        }

        var parent = current.parent();
        var items = parent.children('li.' + this.getItemElementStyleClass());
        var numOfCols = this._getColumnCount(items);
        var index = items.index(current);
        var belowIndex = index + numOfCols;
        if (belowIndex >= items.length) {
          var numOfRows = Math.ceil(items.length / numOfCols);
          numOfItemSkip = items.length - 1 - index;
          // if the current item is not on the last row, then go to the last item within group
          if (index < Math.max(0, (numOfRows - 1) * numOfCols)) {
            below = items.last();
            // skip one less since going to an item within the same group
            numOfItemSkip -= 1;
          } else if (parent.hasClass(this.getGroupStyleClass())) {
            // go to header, or stop if there's no header
            below = parent.parent().next('li.' + this.getItemElementStyleClass());
          }
        } else {
          below = $(items.get(belowIndex));
          numOfItemSkip = numOfCols - 1;
        }

        if (below.length > 0) {
          // make sure it's focusable, otherwise no-op
          if (this.SkipFocus(below)) {
            return;
          }

          if (isExtend) {
            this._extendSelection(below, event);
            this.m_isNavigate = false;
          } else {
            if (numOfItemSkip != null && numOfItemSkip > 0) {
              this._updateSkipItemAriaLabel(below, numOfItemSkip);
            }
            this.SetCurrentItem(below, event);
            this.m_isNavigate = true;
          }

          this._handleLastItemKeyboardFocus(below);
        }
      },

      /**
       * Determine if the data grid is in actionable mode.
       * @return {boolean} true if the data grid is in actionable mode, false otherwise.
       * @private
       */
      _isActionableMode: function () {
        return this.m_keyMode === 'actionable';
      },

      /**
       * Sets whether the data grid is in actionable mode
       * @param {boolean} flag true to set grid to actionable mode, false otherwise
       * @param {boolean=} skipFocus true if focus should not shift, if not defined then default to false
       * @private
       */
      _setActionableMode: function (flag, skipFocus) {
        this.m_keyMode = flag ? 'actionable' : 'navigation';

        if (!flag && !skipFocus) {
          // focus should be shift back to active descendant container
          this.element[0].focus();
        }
      },
      /** ********************************** end Navigation Common **************************/

      /** ********************************** Active item ******************************/
      /**
       * Retrieve the focus element
       * @param {jQuery} item the list item
       * @return {jQuery} the focus element
       * @private
       */
      getFocusItem: function (item) {
        if (!item.hasClass(this.getFocusedElementStyleClass())) {
          return $(item.find('.' + this.getFocusedElementStyleClass()).first());
        }

        if (this.ShouldUseGridRole() && item.attr('role') === 'row') {
          var cell = item.children('.oj-listview-cell-element').first();
          return cell.length === 0 ? item.children().first() : cell;
        }

        return item;
      },

      /**
       * Sets the tab index attribute of the root element
       * To be change by NavList
       * @protected
       */
      SetRootElementTabIndex: function () {
        if (this._isComponentFocusable()) {
          this.element.attr('tabIndex', 0);
        }
      },

      /**
       * Removes the tab index attribute of the root element
       * To be change by NavList
       * @protected
       */
      RemoveRootElementTabIndex: function () {
        this.element.removeAttr('tabIndex');
      },

      /**
       * Whether application has mark the component as not focusable in the first place
       * @private
       */
      _isComponentFocusable: function () {
        var root = this.ojContext._IsCustomElement() ? this.GetRootElement() : this.element;
        return this._rootTabIndexSet || parseInt(root.attr('tabIndex'), 10) !== -1;
      },

      /**
       * Sets the tab index on focus item
       * @param {jQuery} item the focus item
       * @private
       */
      _setTabIndex: function (item) {
        // note that page author should not set any tabindex on the item
        if (this._isComponentFocusable()) {
          this.getFocusItem(item).attr('tabIndex', 0);
        }
      },

      /**
       * Resets the tab index set on focus item
       * @param {jQuery} item the focus item
       * @private
       */
      _resetTabIndex: function (item) {
        var removeAttr = true;
        if (item.attr('role') === 'presentation') {
          removeAttr = false;
        }

        var focusItem = this.getFocusItem(item);
        if (removeAttr) {
          focusItem.removeAttr('tabIndex');
        } else {
          focusItem.attr('tabIndex', -1);
        }
      },

      /**
       * Make an item focusable
       * @param {jQuery} item the item to focus
       * @private
       */
      _makeFocusable: function (item) {
        this._setTabIndex(item);
      },

      /**
       * Determine the only focusable element inside an item, if the item does not have any or have
       * more than one focusable element, then just return the item.
       * (Update) Note this method now always returns item since we do not want to change the role of
       * the content specified by application.
       * @param {jQuery} item the list item
       * @return {jQuery} see above for what's get returned
       * @private
       */
      getSingleFocusableElement: function (item) {
        return item;
      },

      /**
       * Sets the selection option with a new value
       * @param {Object} newValue the new value for selection option
       * @param {Event|null} event the DOM event
       * @param {Element} currentElem the current item DOM element
       * @private
       */
      _setCurrentItemOption: function (newValue, event, currentElem) {
        var extra = { item: this.ojContext._IsCustomElement() ? currentElem : $(currentElem) };
        this.SetOption('currentItem', newValue, {
          _context: {
            originalEvent: event,
            internalSet: true,
            extraData: extra
          },
          changed: true
        });
      },

      /**
       * Sets the active item
       * @param {jQuery} item the item to set as active
       * @param {Event} event the event that triggers set active
       * @param {boolean=} skipFocus true if to skip focusing the item
       * @return {boolean} true if item becomes active, false for all other cases
       * @private
       */
      _setActive: function (item, event, skipFocus) {
        var active;

        // set key info
        if (item != null) {
          var elem = item[0];
          var key = this.GetKey(elem);

          if (this.m_active == null || key !== this.m_active.key) {
            // fire beforecurrentItem
            var ui = { key: key, item: item };
            if (this.m_active != null) {
              ui.previousKey = this.m_active.key;
              ui.previousItem = this.m_active.elem;
              // for touch, remove draggable when active item changed
              if (this._shouldDragSelectedItems() && this._isTouchSupport()) {
                this.m_dndContext._unsetDraggable(ui.previousItem);
              }

              // remove aria-labelledby set by arrow key navigation
              this._removeSkipItemAriaLabel(ui.previousItem);
            }

            var cancelled = !this.Trigger('beforeCurrentItem', event, ui);
            if (cancelled) {
              return false;
            }

            if (this.m_active != null && this.m_active.elem) {
              this.m_active.elem.get(0).classList.remove('oj-listview-current-item');
            }

            active = { key: key, elem: item };
            this.m_active = active;

            // for touch, set draggable when item becomes active
            if (this._shouldDragSelectedItems() && this._isTouchSupport()) {
              this.m_dndContext._setDraggable(item);
            }

            item.get(0).classList.add('oj-listview-current-item');

            // update tab index
            if (skipFocus === undefined || !skipFocus) {
              // make item focusable
              this._makeFocusable(item);

              // style should be updated before currentItem change event is fired
              this.HighlightActive();

              // focus on it only for non-click events or when done programmatically
              // the issue is we can't shift focus on click since it will steal focus from the popups
              // the focusing on item is done already on mousedown
              if (event == null || (event.originalEvent && event.originalEvent.type !== 'click')) {
                this._focusItem(item);
              }

              // reset tabindex of previous focus item, note this has to be done after focusing on a new item
              // because in Chrome 57, resetting tabindex on a focus item will cause a blur event
              // note also it seems this only happens when removing tabindex, if you set it to -1 this does not happen
              this.RemoveRootElementTabIndex();
              if (ui.previousItem) {
                this._resetTabIndex(ui.previousItem);
              }
            }

            return true;
          } else if (key === this.m_active.key) {
            active = { key: key, elem: item };
            this.m_active = active;

            // update tab index
            if (skipFocus === undefined || !skipFocus) {
              this._makeFocusable(item);
              // make sure ul is not tabbable
              this.RemoveRootElementTabIndex();
              this._focusItem(item);
            }
          }
        } else {
          // item is null, just clears the current values
          this.m_active = null;
        }

        return false;
      },

      /**
       * Whether focus is in the process of shifting to item
       */
      isInShiftingFocus: function () {
        return this.m_inShiftingFocus === undefined ? false : this.m_inShiftingFocus;
      },

      /**
       * Put browser focus on item (or children of item)
       * @private
       */
      _focusItem: function (item) {
        var elem = this.getFocusItem(item).get(0);
        if (elem) {
          try {
            this.m_inShiftingFocus = true;
            elem.focus();
          } finally {
            this.m_inShiftingFocus = false;
          }
        }
      },

      /**
       * Highlight active element
       * @protected
       */
      HighlightActive: function () {
        // don't highlight and focus item if ancestor does not have focus
        if (this.m_active != null && this.getListContainer().hasClass('oj-focus-ancestor')) {
          var item = this.m_active.elem;
          this._highlightElem(item, 'oj-focus');
        }
      },

      /**
       * Unhighlight the active index, and turn the active index to selected instead if selectActive is true.
       * @protected
       */
      UnhighlightActive: function () {
        if (this.m_active != null) {
          this._unhighlightElem(this.m_active.elem, 'oj-focus');
        }
      },

      HandleClickActive: function (item, event) {
        // if click is triggered by target inside the active item, then do nothing
        var active = this.m_active != null ? this.m_active.elem.get(0) : null;
        // if it's a group, use the group header div instead otherwise active.contains check will not be valid
        if (active != null && !$(active).hasClass(this.getItemStyleClass())) {
          active = active.firstElementChild;
        }

        if (
          event != null &&
          active != null &&
          active !== event.target &&
          active.contains(event.target)
        ) {
          return;
        }

        this.SetCurrentItem(
          item,
          event,
          this.ShouldUseGridRole() ? event.target !== item.get(0) : true
        );
      },

      /**
       * Sets the active item and bring focus to it.  Update the currentItem option.
       * @protected
       */
      SetCurrentItem: function (item, event, skipFocus) {
        var proceed = this.ActiveAndFocus(item, event, skipFocus);
        if (proceed) {
          this._setCurrentItemOption(this.GetKey(item[0]), event, item.get(0));
        }
      },

      /**
       * Sets the active item and bring focus to it.
       * @protected
       */
      ActiveAndFocus: function (item, event, skipFocus) {
        // make sure that it is visible
        this._scrollToVisible(item[0]);

        // unhighlight any previous active item
        this.UnhighlightActive();

        // update active and frontier
        var proceed = this._setActive(item, event, skipFocus);

        // highlight active
        this.HighlightActive();

        return proceed;
      },
      /** ********************************** end Active item ******************************/

      /** *********************************** Selection ***********************************************/
      /**
       * If selection is enabled and at least one item has to be selected, then
       * make sure the first selectable item is selected in the list.
       */
      enforceSelectionRequired: function () {
        if (this._isSelectionEnabled() && this._isSelectionRequired()) {
          var selection = this.GetOption('selection');
          if (selection == null || (selection.length === 0 && selection.inverted !== true)) {
            this._selectFirstSelectableItem();
          }
        }
      },

      /**
       * Returns the first selectable item in the list.
       * @private
       */
      _getFirstSelectableItem: function () {
        // currently, an item will have the aria-selected attribute defined only if it's selectable
        // so we are using that here to find all selectable items.
        var elem = this.element[0].querySelector('.oj-listview-cell-element[aria-selected]');
        return elem == null ? null : elem.parentNode;
      },

      /**
       * Selects the first selectable item
       * @private
       */
      _selectFirstSelectableItem: function () {
        var item = this._getFirstSelectableItem();

        // select the item if found
        if (item) {
          var key = this.m_contentHandler.GetKey(item);
          if (key != null) {
            this._applySelection(item, key);
            var selected = this.GetOption('selected');
            this._setSelectionOption(selected.clear().add([key]), null, [item]);
          }
        }
      },

      /**
       * Check if selection enabled by options on the list
       * @return {boolean} true if selection enabled
       * @private
       */
      _isSelectionEnabled: function () {
        return this.GetOption('selectionMode') !== 'none';
      },

      /**
       * Check if there should be at least one item selected in the list
       * @return {boolean} true if selection is required
       * @private
       */
      _isSelectionRequired: function () {
        return this.GetOption('selectionRequired');
      },

      /**
       * Check whether multiple selection is allowed by options on the list
       * @return {boolean} true if multiple selection enabled
       * @private
       */
      _isMultipleSelection: function () {
        return this.GetOption('selectionMode') === 'multiple';
      },

      /**
       * Check whether the item is selectable
       * @param {Element} item the item element
       * @return {boolean} true if item is selectable
       * @protected
       */
      IsSelectable: function (item) {
        var focusItem = this.getFocusItem($(item)).get(0);
        if (focusItem == null) {
          Logger.log(
            'The focusItem has an unexpected value of null.\nItem classlist: ' +
              item.classList +
              '\nItem role: ' +
              item.role
          );
          return false;
        }
        return focusItem.hasAttribute('aria-selected');
      },

      /**
       * Convert selection as an iterable to an array of selection.
       * We used to remove any items that are not selectable, or if there are more than one items
       * when selectionMode is single, but not anymore.
       * @param {Array|Set} selection array of selected items
       * @return {Array} array of items
       * @private
       */
      _cloneSelection: function (selection) {
        var arr = [];
        // Array.from is not supported in IE11 and we do not have the polyfill
        selection.forEach(function (key) {
          arr.push(key);
        });

        return arr;
      },

      /**
       * @private
       */
      _getLocalData: function (key) {
        var data = this.getDataForVisibleItem({ key: key });
        if (data == null && this.m_validatedSelectedKeyData) {
          data = this.m_validatedSelectedKeyData.get(key);
        }
        return data;
      },

      /**
       * Sets the selection option with a new value
       * @param {Object} newValue the new value for selection option
       * @param {Event|null} event the DOM event
       * @param {Array.<Element>=} selectedElems an array of DOM Elements
       * @param {any=} firstSelectedItemData the data for first selected item
       * @private
       */
      _setSelectionOption: function (newValue, event, selectedElems, firstSelectedItemData) {
        var selection = ojkeyset.KeySetUtils.toArray(newValue);

        // check if the value has actually changed, based on key
        // firstSelectedItem should never be null and should always have 'key'
        var firstSelectedItem = this.GetOption('firstSelectedItem');

        // NavList firstSelectedItem would be undefined
        if (firstSelectedItem != null) {
          if (newValue.isAddAll()) {
            this._updateFirstSelectedItem(newValue);
          } else {
            this._handleFirstSelectedItem(firstSelectedItem, selection, event, firstSelectedItemData);
          }
        }

        var items;
        if (this.ojContext._IsCustomElement()) {
          items = selectedElems;
        } else if (selectedElems == null) {
          items = $({});
        } else {
          items = $(selectedElems);
        }

        var extra = { items: items };

        this.SetOption('selected', newValue, {
          _context: {
            originalEvent: event,
            internalSet: true,
            extraData: extra
          },
          changed: true
        });

        // update legacy selection last
        this.SetOption('selection', selection, {
          _context: {
            originalEvent: event,
            internalSet: true,
            extraData: extra
          },
          changed: true
        });
      },

      // used by _setSelectionOption
      _handleFirstSelectedItem: function (
        firstSelectedItem,
        selection,
        event,
        firstSelectedItemData
      ) {
        var value = { key: null, data: null };

        // first condition is if new value is empty and existing item is non null
        // second condition is if new value is not empty and does not match the existing item
        if (
          (selection.length === 0 && firstSelectedItem.key != null) ||
          !(
            selection[0] === firstSelectedItem.key ||
            oj.Object.compareValues(selection[0], firstSelectedItem.key)
          )
        ) {
          // update firstSelectedItem also
          if (selection.length > 0) {
            value = {
              key: selection[0],
              data:
                firstSelectedItemData != null
                  ? firstSelectedItemData
                  : this._getLocalData(selection[0])
            };
          }

          this.SetOption('firstSelectedItem', value, {
            _context: {
              originalEvent: event,
              internalSet: true
            },
            changed: true
          });
        } else if (firstSelectedItem.data === undefined) {
          if (firstSelectedItemData == null) {
            // eslint-disable-next-line no-param-reassign
            firstSelectedItemData = this._getLocalData(selection[0]);
          }
          value = { key: firstSelectedItem.key, data: firstSelectedItemData };
          this.SetOption('firstSelectedItem', value, {
            _context: {
              originalEvent: null,
              internalSet: true
            },
            changed: true
          });
        }
      },

      /**
       * Unhighlights the selection.  Does not change selection, focus, anchor, or frontier
       * @private
       */
      _unhighlightSelection: function () {
        if (this.m_keyElemMap == null) {
          return;
        }

        var self = this;
        var selected = this.GetOption('selected');
        if (selected.isAddAll()) {
          var items = this._getItemsCache();
          for (var i = 0; i < items.length; i++) {
            self._unhighlightElem(items[i], 'oj-selected');
          }
        } else {
          selected.values().forEach(function (key) {
            var elem = self.FindElementByKey(key);
            if (elem != null) {
              self._unhighlightElem(elem, 'oj-selected');
            }
          });
        }
      },

      _highlightElem: function (elem, style) {
        this.HighlightUnhighlightElem(elem, style, true);
      },

      _unhighlightElem: function (elem, style) {
        this.HighlightUnhighlightElem(elem, style, false);
      },

      /**
       * Highlight or unhighlight an element
       * @param {jQuery|Element} elem the element the highlight or unhighlight
       * @param {string} style the style to add or remove
       * @param {boolean} highlight true if it's to highlight, false if it's to unhighlight
       * @protected
       */
      HighlightUnhighlightElem: function (elem, style, highlight) {
        var $elem = $(elem);

        if (style === 'oj-selected') {
          this.getFocusItem($elem).attr('aria-selected', highlight ? 'true' : 'false');
        }

        // if item is a group, the highlight should be apply to the group item element
        var group = $elem.children('.' + this.getGroupItemStyleClass());
        if (group.length > 0) {
          $elem = $(group[0]);
        }

        if (style === 'oj-focus') {
          if (highlight) {
            // don't apply focus ring on item if we are in actionable mode
            if (this.m_keyMode !== 'actionable') {
              this._focusInHandler($elem);
            }
          } else {
            this._focusOutHandler($elem);
          }
        } else if (highlight) {
          $elem.addClass(style);
        } else {
          $elem.removeClass(style);
        }
      },

      /**
       * Handles click to select multiple cells/rows
       * @param {jQuery} item the item clicked on
       * @param {Event} event the click event
       * @protected
       */
      HandleClickSelection: function (item, event) {
        // make sure that it is visible
        this._scrollToVisible(item[0]);

        var ctrlKey = this._ctrlEquivalent(event);
        var shiftKey = event.shiftKey;
        var processed = true;
        if (this._isMultipleSelection()) {
          if (!ctrlKey && !shiftKey) {
            processed = this.SelectAndFocus(item, event);
          } else if (!ctrlKey && shiftKey) {
            // active item doesn't change in this case
            processed = this._extendSelection(item, event);
          } else {
            // processed is always true in this case
            this._augmentSelectionAndFocus(item, event);
          }
        } else {
          processed = this.SelectAndFocus(item, event, ctrlKey);
        }

        return processed;
      },

      /**
       * Handles tap to select multiple cells/rows
       * @param {jQuery} item the item clicked on
       * @param {Event} event the click event
       * @private
       */
      _handleTouchSelection: function (item, event) {
        var processed = true;
        if (this._isMultipleSelection()) {
          if (event.shiftKey) {
            // for touch device with keyboard support
            processed = this._extendSelection(item, event);
          } else {
            // treat this as like ctrl+click
            this._augmentSelectionAndFocus(item, event);
          }
        } else {
          processed = this.SelectAndFocus(item, event, true);
        }

        return processed;
      },

      /**
       * Clear the current selection.
       * @param {boolean} updateOption true if the underlying selection option should be updated, false otherwise.
       * @param {jQuery=} newSelectionFrontier new value to set the selection frontier. If none specified, set to null
       * @private
       */
      _clearSelection: function (updateOption, newSelectionFrontier) {
        // unhighlight previous selection
        this._unhighlightSelection();

        if (updateOption) {
          // if the intend is to empty selection option, we have to make sure if
          // selectionRequired is set to true that something is selected
          if (this._isSelectionRequired()) {
            this._selectFirstSelectableItem();
          } else {
            var selected = this.GetOption('selected');
            selected = selected.clear();
            this._setSelectionOption(selected, null, null);
          }
        }

        // clear selection frontier also
        this.m_selectionFrontier = newSelectionFrontier === undefined ? null : newSelectionFrontier;
      },

      /**
       * Selects the focus on the specified element
       * Select and focus is an asynchronus call
       * @param {jQuery} item the item clicked on
       * @param {Event} event the click event
       * @param {isToggle=} isToggle true if this is a toggle selection event
       * @protected
       */
      SelectAndFocus: function (item, event, isToggle) {
        var key = this.GetKey(item[0]);
        var selected = this.GetOption('selected');
        var exists = selected.has(key);

        // check if there's only one item selected and selection is required
        if (
          exists &&
          selected.values &&
          selected.values().size === 1 &&
          this._isSelectionRequired()
        ) {
          return false;
        }

        var isRedwood = ThemeUtils.parseJSONFromFontFamily('oj-theme-json').behavior === 'redwood';
        // if it's already selected, deselect it and update options
        if (exists && (isToggle || !isRedwood)) {
          this._clearSelection(true);
        } else {
          this._clearSelection(false);
          // add the elem to selection
          this._augmentSelectionAndFocus(item, event, selected.clear());
        }

        return true;
      },

      /**
       * Shift+click to extend the selection
       * @param {jQuery} item the item to extend selection to
       * @param {Event} event the key event
       * @private
       */
      _extendSelection: function (item, event) {
        if (this.m_active == null) {
          return false;
        }

        // checks if selection has changed
        var current = this.m_selectionFrontier;
        if (current === item) {
          return false;
        }

        // remove focus style on the item click on
        this._unhighlightElem(item, 'oj-focus');

        this._extendSelectionRange(this.m_active.elem, item, event);

        return true;
      },

      /**
       * Extend the selection
       * @param {jQuery} from the item to extend selection from
       * @param {jQuery} to the item to extend selection to
       * @param {Event} event the event that triggers extend
       * @param {boolean=} keepSelectionFrontier true if we don't want to modify the selectionFrontier
       * @private
       */
      _extendSelectionRange: function (from, to, event, keepSelectionFrontier) {
        if (keepSelectionFrontier === true) {
          // clear selection as we'll be just re-highlight the entire range
          this._clearSelection(false, this.m_selectionFrontier);
        } else {
          this._clearSelection(false, to);
        }

        // highlights the items between active item and new item
        this._highlightRange(from, to, event);
        this.HighlightActive();

        // make sure that it is visible
        this._scrollToVisible(to[0]);
      },

      /**
       * Highlight the specified range
       * @param {jQuery} start the start of the range
       * @param {jQuery} end the end of the range
       * @param {Event} event the event that triggers the highlight
       * @private
       */
      _highlightRange: function (start, end, event) {
        var from;
        var to;
        var selected = this.GetOption('selected').clear();
        var selectedItems = [];
        var items = this._getItemsCache();
        var startIndex = items.index(start);
        var endIndex = items.index(end);

        if (startIndex > endIndex) {
          from = endIndex;
          to = startIndex;
        } else {
          from = startIndex;
          to = endIndex;
        }

        // exclude start and include end
        for (var i = from; i <= to; i++) {
          var item = items[i];
          if (this.IsSelectable(item)) {
            var key = this.m_contentHandler.GetKey(item);

            this._applySelection(item, key);
            selected = selected.add([key]);
            selectedItems.push(item);
          }
        }

        // trigger the optionChange event
        this._setSelectionOption(selected, event, selectedItems);
      },

      /**
       * Apply selection to the element
       * @param {jQuery|Element} element the item to apply selection
       * @param {Object} key the key of the item
       * @private
       */
      _applySelection: function (element, key) {
        // update map that keeps track of key->element
        if (this.m_keyElemMap == null) {
          this.m_keyElemMap = this.m_contentHandler.createKeyMap();
        }
        this.m_keyElemMap.set(key, $(element).attr('id'));

        // highlight selection
        this._highlightElem(element, 'oj-selected');
      },

      /**
       * Ctrl+click to add item to the current selection
       * @param {jQuery} item the item to augment selection to
       * @param {Event} event the event that triggers the selection
       * @param {KeySet=} selected the optional selection to augment, if not specified, use current selection
       * @private
       */
      _augmentSelectionAndFocus: function (item, event, selected) {
        var active = item;
        var key = this.GetKey(item[0]);

        if (selected == null) {
          // eslint-disable-next-line no-param-reassign
          selected = this.GetOption('selected');
        }

        // update active only if target is not inside the active item
        var currentActive = this.m_active != null ? this.m_active.elem.get(0) : null;
        // if it's a group, use the group header div instead otherwise currentActive.contains check will not be valid
        if (currentActive != null && !$(currentActive).hasClass(this.getItemStyleClass())) {
          currentActive = currentActive.firstElementChild;
        }

        if (
          event != null &&
          (currentActive == null ||
            currentActive === event.target ||
            !currentActive.contains(event.target))
        ) {
          this.UnhighlightActive();

          // update active cell and frontier
          var proceed = this._setActive(active, event);
          if (proceed) {
            // update current option
            this._setCurrentItemOption(key, event, active.get(0));
          }

          // highlight index
          this.HighlightActive();
        }

        // checks if setActive was successful
        currentActive = this.m_active != null ? this.m_active.elem.get(0) : null;
        if (currentActive == null || currentActive !== active.get(0)) {
          // update selection if it was cleared
          if (selected != null && selected.values().size === 0) {
            this._setSelectionOption(selected, event, []);
          }
          return;
        }

        if (selected.has(key)) {
          if (selected.values && selected.values().size === 1 && this._isSelectionRequired()) {
            // only one selected item and selection is required, do nothing
            return;
          }

          // it was selected, deselect it
          this._unhighlightElem(item, 'oj-selected');
          // eslint-disable-next-line no-param-reassign
          selected = selected.delete([key]);
        } else {
          this.m_selectionFrontier = item;
          this._applySelection(item, key);
          // eslint-disable-next-line no-param-reassign
          selected = selected.add([key]);
        }

        var selectedItems = [];
        if (selected.values) {
          selected.values().forEach(function (aKey) {
            selectedItems.push(this.FindElementByKey(aKey));
          }, this);
        }

        // trigger option change
        this._setSelectionOption(selected, event, selectedItems);
      },

      /**
       * Toggle selection of an item.  If an item was selected, it deselects it.  If an item was not selected, it selects it.
       * @param {Event} event the event that triggers the selection
       * @param {boolean} keepCurrentSelection true if selecting an item would not deselect other selected items, false otherwise
       * @param {boolean} skipIfNotSelected true if an selected item should not be deselected, false otherwise
       * @protected
       */
      ToggleSelection: function (event, keepCurrentSelection, skipIfNotSelected) {
        // if it's currently selected, deselect it
        var selected = this.GetOption('selected');
        var item = this.m_active.elem;
        var key = this.m_active.key;

        var isAll = selected.isAddAll();
        if (selected.has(key)) {
          // do not deselect the item if it's the last selected item and selection is required
          if (
            skipIfNotSelected ||
            (!isAll && selected.values().size === 1 && this._isSelectionRequired())
          ) {
            return;
          }

          // it was selected, deselect it
          this._unhighlightElem(item, 'oj-selected');
          selected = selected.delete([key]);

          if (!isAll && selected.values().size === 0) {
            this.m_selectionFrontier = null;
          }
        } else if (this.IsSelectable(item[0])) {
          // deselect any selected items
          if (!keepCurrentSelection) {
            this._clearSelection(false);
            selected = selected.clear();
          }

          this.m_selectionFrontier = item;

          // select current item
          this._applySelection(item, key);
          selected = selected.add([key]);
        }

        var selectedItems = [];
        if (!isAll) {
          selected.values().forEach(function (aKey) {
            selectedItems.push(this.FindElementByKey(aKey));
          }, this);
        }

        // trigger option change
        this._setSelectionOption(selected, event, selectedItems);
      },

      /**
       * Checks whether the element is an input element or editable element
       * @param {Element} elem the element to check
       * @return {boolean} true if it's input or editable, false otherwise
       * @private
       */
      isInputOrEditableContentElement: function (elem) {
        var inputRegExp = /^INPUT|SELECT|OPTION|TEXTAREA/;
        return (
          (elem.nodeName.match(inputRegExp) != null ||
            elem.getAttribute('contenteditable') === 'true') &&
          !elem.readOnly
        );
      },

      /**
       * Handles key event for selection or active
       * @param {Event} event
       * @return {boolean} true if the event is processed
       * @protected
       */
      HandleSelectionOrActiveKeyDown: function (event) {
        var ctrlKey;
        var shiftKey;
        var processed = false;
        var first;

        // this could happen if nothing in the list is focusable
        // or if the key is handled by a descendant already and explicitly do not want parent to handle
        if (this.m_active == null || event.isDefaultPrevented()) {
          return false;
        }

        var key = event.key || event.keyCode;
        var current = this.m_active.elem;

        if (this._isActionableMode()) {
          // Esc key goes to navigation mode
          // F2 key can also be used to exit actionable mode if already in actionable mode
          if (
            key === 'Escape' ||
            key === 'Esc' ||
            key === this.ESC_KEY ||
            key === 'F2' ||
            key === this.F2_KEY
          ) {
            // force focus back on the active cell
            this._focusItem(current);

            // exit actionable mode should be done after focusItem due to JET-63051
            this._exitActionableMode();

            // set focus style after exit actioinable due to JET-63292
            this.HighlightActive();

            // make sure active item has tabindex set
            this._setTabIndex(current);
            processed = true;
          } else if (key === 'Tab' || key === this.TAB_KEY) {
            var focusElem = this.getFocusItem(current).get(0);
            // see JET-66869, dynamic content might have elements with data-oj-mod
            DataCollectionUtils.enableAllFocusableElements(focusElem);
            if (event.shiftKey) {
              processed = DataCollectionUtils.handleActionablePrevTab(event, focusElem);
            } else {
              processed = DataCollectionUtils.handleActionableTab(event, focusElem);
            }

            if ((!event.shiftKey && processed) || (event.shiftKey && !processed)) {
              var firstFocuasble = DataCollectionUtils.getFocusableElementsInNode(focusElem)[0];
              if (firstFocuasble && this._isExpandCollapseIcon(firstFocuasble)) {
                this._focusInHandler($(firstFocuasble));
              }
            }

            // otherwise don't process and let browser handles tab
          }
        } else if (key === 'F2' || key === this.F2_KEY) {
          // F2 key goes to actionable mode
          event.stopPropagation();
          this._enterActionableMode();

          // focus on first focusable item in the cell
          first = current.find('[data-first]');
          if (first.length > 0) {
            first[0].focus();

            if (this._isExpandCollapseIcon(first)) {
              this._focusInHandler(first);
            }

            // check if it's group item
            if (!current.hasClass(this.getItemStyleClass())) {
              current = current.children('.' + this.getGroupItemStyleClass()).first();
            }
            current.removeClass('oj-focus-highlight').addClass('oj-focus-previous-highlight');
          }
        } else if (
          (key === ' ' || key === 'Spacebar' || key === this.SPACE_KEY) &&
          this._isSelectionEnabled() &&
          !this.isInputOrEditableContentElement(event.target)
        ) {
          ctrlKey = this._ctrlEquivalent(event);
          shiftKey = event.shiftKey;
          if (
            shiftKey &&
            !ctrlKey &&
            this.m_selectionFrontier != null &&
            this._isMultipleSelection()
          ) {
            if (this.GetOption('selected').has(this.m_active.key)) {
              // deselect the selected item only, keep previous items selected
              this.ToggleSelection(event, !ctrlKey && shiftKey && this._isMultipleSelection(), false);
            } else {
              // selects contiguous items from last selected item to current item
              this._extendSelectionRange(this.m_selectionFrontier, this.m_active.elem, event, true);
            }
          } else {
            // toggle selection, deselect previous selected items
            this.ToggleSelection(event, ctrlKey && !shiftKey && this._isMultipleSelection(), false);
          }
          processed = true;
        } else if (key === 'Enter' || key === this.ENTER_KEY) {
          if (this._isSelectionEnabled()) {
            // selects it if it's not selected, do nothing if it's already selected
            this.ToggleSelection(event, false, true);
          }
          this._fireActionEvent(current.get(0), event, false);
        } else if (this.IsArrowKey(key)) {
          ctrlKey = this._ctrlEquivalent(event);
          shiftKey = event.shiftKey;
          if (!ctrlKey) {
            processed = this.HandleArrowKeys(
              key,
              shiftKey && this._isSelectionEnabled() && this._isMultipleSelection(),
              event
            );
          }
        } else if (key === 'Tab' || key === this.TAB_KEY) {
          // content could have changed, disable all elements in items before or after the active item
          if (event.shiftKey) {
            this._disableAllTabbableElementsBeforeItem(current);
          } else {
            this._disableAllTabbableElementsAfterItem(current);
          }
        }

        return processed;
      },

      /** ******************************** End Selection **********************************************/

      /** ******************************** Disclosure **********************************************/
      /**
       * Whether the group item is currently in the middle of expanding/collapsing
       * @param {Object} key the key of the group item
       * @return {boolean} true if it's expanding/collapsing, false otherwise
       * @private
       */
      _isDisclosing: function (key) {
        if (key && this.m_disclosing) {
          return this.m_disclosing.indexOf(key) > -1;
        }

        return false;
      },

      /**
       * Marks a group item as currently in the middle of expanding/collapsing
       * @param {Object} key the key of the group item
       * @param {boolean} flag true or false
       * @private
       */
      _setDisclosing: function (key, flag) {
        if (key == null) {
          return;
        }

        if (this.m_disclosing == null) {
          this.m_disclosing = [];
        }

        if (flag) {
          this.m_disclosing.push(key);
        } else {
          // there should be at most one entry, but just in case remove all occurrences
          var index = this.m_disclosing.indexOf(key);
          while (index > -1) {
            this.m_disclosing.splice(index, 1);
            index = this.m_disclosing.indexOf(key);
          }
        }
      },

      /**
       * Gets the option defaults
       * @private
       */
      _getOptionDefaults: function () {
        if (this.defaultOptions == null) {
          this.defaultOptions = this.getStyleValues();
        }
        if (this.defaultOptions == null) {
          Logger.error(
            'Cannot find oj-list-view option defaults, which might be caused by missing JET css file'
          );
          return {};
        }
        return this.defaultOptions;
      },

      /**
       * Gets the animation effect for the specific action
       * @param {string} action the action to retrieve the effect
       * @return {Object} the animation effect for the action
       */
      getAnimationEffect: function (action) {
        var defaultOptions = this._getOptionDefaults();
        var defaultAnimations = defaultOptions.animation;
        return defaultAnimations == null ? null : defaultAnimations[action];
      },

      /**
       * Whether group items can be expand/collapse.
       * @return {boolean} true if group items can be expand/collapse, false otherwise.
       */
      isExpandable: function () {
        return this.GetOption('drillMode') !== 'none';
      },

      /**
       * Whether ListView should expand all expandable items.
       * @param {any} key the key of the item to check
       * @return {boolean} true if expand all, false otherwise
       * @private
       */
      _isExpandAll: function (key) {
        var expanded = this.GetOption('expanded');
        // for legacy syntax, which supports 'auto' and 'all'
        // TODO: should add check for custom element, but can't do it until NavList also move to KeySet
        if (expanded === 'auto') {
          // if drillMode is none and no expanded state is specified, expand all
          if (!this.isExpandable()) {
            return true;
          }
        } else if (expanded === 'all') {
          return true;
        }

        // for custom element and also legacy syntax that uses the new KeySet"expand
        if (expanded.isAddAll) {
          // if drillMode is none and no expanded state is specified, expand all
          return !this.isExpandable() && expanded instanceof _ojListViewExpandedKeySet
            ? true
            : expanded.isAddAll() && expanded.has(key);
        }

        return false;
      },

      /**
       * Expand an item with specified key.
       * Invoked by widget
       * @param {Object} key the key of the group item to expand
       * @param {boolean} beforeVetoable true if beforeExpand event can be veto, false otherwise
       * @param {boolean} fireBefore true if this should trigger a beforeExpand event
       * @param {boolean} fireAfter true if this should trigger an expand event
       * @param {boolean} animate true if animate the expand operation, false otherwise
       */
      expandKey: function (key, beforeVetoable, fireBefore, fireAfter, animate) {
        var item = this.FindElementByKey(key);
        if (item != null) {
          this.ExpandItem($(item), null, animate, key, beforeVetoable, fireAfter, fireBefore);
        }
      },

      /**
       * Handle expand operation
       * @param {Event} event the event that triggers the expand
       * @private
       */
      _expand: function (event) {
        var item = this.FindItem(event.target);
        if (item != null && item.length > 0) {
          this.SetCurrentItem(item, event);
          this.ExpandItem(item, event, true, null, true, true, true);
        }
      },

      /**
       * Expand an item
       * @param {jQuery} item the item to expand
       * @param {Event} event the event that triggers expand.  Note that event could be null in the case where this is programmatically done by the widget
       * @param {boolean} animate true if animate the expand operation, false otherwise
       * @param {Object|null} key the key of the item, if not specified, the logic will figure it out from the item
       * @param {boolean} beforeVetoable true if beforeExpand event can be veto, false otherwise
       * @param {boolean} fireEvent true if fire expand event, false otherwise
       * @param {boolean} fireBeforeEvent true if fire beforeexpand event, false otherwise
       * @protected
       */
      ExpandItem: function (item, event, animate, key, beforeVetoable, fireEvent, fireBeforeEvent) {
        // checks if it's already collapsed or not collapsible at all
        if (this.GetState(item) !== this.STATE_COLLAPSED) {
          return;
        }

        // if key wasn't specified, find it
        if (key == null) {
          // eslint-disable-next-line no-param-reassign
          key = this.GetKey(item[0]);
        }

        // bail if it's in the middle of expanding/collapsing
        if (animate && this._isDisclosing(key)) {
          return;
        }

        var ui = { item: item, key: key };

        if (fireBeforeEvent) {
          var cancelled = !this.Trigger('beforeExpand', event, ui);
          if (cancelled && beforeVetoable) {
            return;
          }
        }

        this.signalTaskStart('Expand item: ' + key); // signal method task start

        if (animate) {
          this._setDisclosing(key, true);
        }
        this.m_contentHandler.Expand(
          item,
          function (groupItem) {
            this._expandSuccess(groupItem, animate, event, ui, fireEvent);
          }.bind(this)
        );

        // clear items cache
        this.m_items = null;

        // prevent item click handler to trigger
        if (event != null) {
          event.stopPropagation();
        }

        // update var that keeps track of collapsed items
        if (!this.ojContext._IsCustomElement() && this._collapsedKeys != null) {
          var index = this._collapsedKeys.indexOf(key);
          if (index !== -1) {
            this._collapsedKeys.splice(index, 1);
          }
        }

        this.signalTaskEnd(); // signal method task end
      },

      /**
       * @param {Element} groupItem
       * @param {boolean} animate
       * @param {Event} event
       * @param {Object} ui
       * @param {boolean} fireEvent
       * @private
       */
      _expandSuccess: function (groupItem, animate, event, ui, fireEvent) {
        var self = this;

        this.signalTaskStart('Handle results from successful expand'); // signal method task start

        // save the key for use when expand complete
        // eslint-disable-next-line no-param-reassign
        groupItem.key = ui.key;

        var animationPromise = this.AnimateExpand($(groupItem), animate, event);

        var item = groupItem.parentNode;

        item = $(item);
        // update aria expanded
        this.SetState(item, this.STATE_EXPANDED);
        // update icon
        var collapseClass = this.getCollapseIconStyleClass();
        var expandClass = this.getExpandIconStyleClass();
        var expandingClass = this.getExpandingIconStyleClass();
        var groupItemStyleClass = this.getGroupItemStyleClass();
        item
          .children('.' + groupItemStyleClass)
          .find('.' + collapseClass + ', .' + expandingClass)
          .removeClass(collapseClass)
          .removeClass(expandingClass)
          .addClass(expandClass);

        // fire expand event after expand animation completes
        if (fireEvent) {
          animationPromise.then(function () {
            // update option.  As an optimization do it only when fireEvent is true since this is the
            // only time when it's not triggered by API, in which case the value is already current
            if (self.ojContext._IsCustomElement()) {
              var currValue = self.GetOption('expanded');
              if (self._isKeySet(currValue) && !currValue.has(groupItem.key)) {
                var newValue = currValue.add([groupItem.key]);
                self.SetOption('expanded', newValue, {
                  _context: {
                    originalEvent: event,
                    internalSet: true
                  },
                  changed: true
                });
              }
            }

            self.Trigger('expand', event, ui);
          });
        }

        animationPromise.then(function () {
          // clear cached height
          self.m_clientHeight = null;
          self.m_scrollHeight = null;
          self.signalTaskEnd(); // signal method task end
        });
      },

      /**
       * Adjust the max height of ancestors of a group items.
       * @param {jQuery} groupItem the group item where we want to adjust its ancestors max height
       * @param {number} delta the height to increase
       * @private
       */
      _adjustAncestorsMaxHeight: function (groupItem, delta) {
        groupItem
          .parentsUntil('ul.oj-component-initnode', 'ul.' + this.getGroupStyleClass())
          .each(function () {
            var maxHeight = parseInt($(this).css('maxHeight'), 10);
            if (maxHeight > 0) {
              $(this).css('maxHeight', maxHeight + delta + 'px');
            }
          });
      },

      /**
       * Animate expand operation
       * @param {jQuery} groupItem the group item that is expand (todo: not consistent with animateCollapse)
       * @param {boolean} animate true if animate expand, false otherwise
       * @param {Event} event the event that triggers expand.  Note that event could be null in the case where this is programmatically done by the widget
       * @return {Promise} A Promise that resolves when expand animation completes
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      AnimateExpand: function (groupItem, animate, event) {
        var totalHeight = 0;
        var animationResolve;
        var self = this;
        var action = 'expand';

        var animationPromise = new Promise(function (resolve) {
          animationResolve = resolve;
        });

        if (animate) {
          var elem = /** @type {Element} */ (groupItem.get(0));
          elem.setAttribute('data-oj-context', '');

          // we have to wait for the items content to finish rendering before we calculate the height
          var busyContext = Context.getContext(elem).getBusyContext();
          busyContext.whenReady().then(function () {
            if (!self.isAvailable()) {
              return;
            }

            elem.removeAttribute('data-oj-context');

            self.signalTaskStart('Animate expand of group item'); // signal task start

            // reset max height to 100% first so we can get the correct outerHeight
            groupItem.css('maxHeight', '100%');
            groupItem.children().each(function () {
              totalHeight += $(this).outerHeight(true);
            });

            // for touch we'll need to re-adjust the max height of parent nodes since max height doesn't get remove
            if (self._isNonWindowTouch()) {
              self._adjustAncestorsMaxHeight(groupItem, totalHeight);
            }

            groupItem.css('maxHeight', totalHeight + 'px');

            self.signalTaskStart('Kick off expand animation'); // signal expand animation started. Ends in _handleExpandTransitionEnd()

            // now show it
            var promise = self.StartAnimation(elem, action);
            promise.then(function () {
              self._handleExpandTransitionEnd(groupItem, animationResolve);
            });

            self.signalTaskEnd(); // signal task end
          });
        } else {
          // if we are not animating, then we don't really care about setting max height
          groupItem.css('maxHeight', '');

          this.AnimateExpandComplete(groupItem);
          animationResolve(null); // resolve animationPromise
        }
        return animationPromise;
      },

      _handleExpandTransitionEnd: function (groupItem, animationResolve) {
        // on ios removing max-height will cause double animation
        if (!this._isNonWindowTouch()) {
          groupItem.css('maxHeight', '');
        }

        this.AnimateExpandComplete(groupItem);
        animationResolve(null); // resolve animationPromise

        this.signalTaskEnd(); // signal expand animation ended. Started in this.AnimateExpand()
      },

      /**
       * Invoked when expand animation is completed.  Class who overrides AnimateExpand
       * must call this method upon finish animation.
       * @param {jQuery} groupItem the item to collapse
       * @protected
       */
      AnimateExpandComplete: function (groupItem) {
        groupItem
          .removeClass(this.getGroupCollapseStyleClass())
          .addClass(this.getGroupExpandStyleClass());
        this._setDisclosing(groupItem[0].key, false);
      },

      /**
       * Collapse an item with specified key.
       * Invoked by widget
       * @param {Object} key the key of the group item to collapse
       * @param {boolean} fireBefore true if this should trigger a beforeCollapse event
       * @param {boolean} fireAfter true if this should trigger a collapse event
       * @param {boolean} animate true if animate the collapse operation, false otherwise
       */
      collapseKey: function (key, fireBefore, fireAfter, animate) {
        var item = this.FindElementByKey(key);
        if (item != null) {
          this.CollapseItem($(item), null, animate, key, fireBefore, fireAfter);
        }
      },

      _collapse: function (event) {
        var item = this.FindItem(event.target);
        if (item != null && item.length > 0) {
          this.SetCurrentItem(item, event);
          this.CollapseItem(item, event, true, null, true, true);
        }
      },

      /**
       * Collapse an item
       * @param {jQuery} item the item to expand
       * @param {Event} event the event that triggers collapse.  Note that event could be null in the case where this is programmatically done by the widget
       * @param {boolean} animate true if animate the collapse operation, false otherwise
       * @param {Object|null} key the key of the item, if not specified, the logic will figure it out from the item
       * @param {boolean} beforeVetoable true if beforeCollapse event can be veto, false otherwise
       * @param {boolean} fireEvent true if fire collapse event, false otherwise
       * @protected
       */
      CollapseItem: function (item, event, animate, key, beforeVetoable, fireEvent) {
        var self = this;

        // checks if it's already collapsed or not collapsible at all
        if (this.GetState(item) !== this.STATE_EXPANDED) {
          return;
        }

        // fire beforeCollapse event
        if (key == null) {
          // eslint-disable-next-line no-param-reassign
          key = this.GetKey(item[0]);
        }

        // bail if it is in the middle of expanding/collapsing
        if (animate && this._isDisclosing(key)) {
          return;
        }

        var ui = { item: item, key: key };

        var cancelled = !this.Trigger('beforeCollapse', event, ui);
        if (cancelled && beforeVetoable) {
          return;
        }

        this.signalTaskStart('Collapse item: ' + key); // signal method task start

        if (animate) {
          this._setDisclosing(key, true);
        }

        // animate collapse
        var animationPromise = this.AnimateCollapse(item, key, animate, event);

        // update aria expanded
        this.SetState(item, this.STATE_COLLAPSED);
        // update icon
        var collapseClass = this.getCollapseIconStyleClass();
        var expandClass = this.getExpandIconStyleClass();
        item
          .find('.' + expandClass)
          .first()
          .removeClass(expandClass)
          .addClass(collapseClass);

        // clear items cache
        this.m_items = null;

        // prevent item click handler to trigger
        if (event != null) {
          event.stopPropagation();
        }

        // fire collapse event after collapse animation completes
        if (fireEvent) {
          animationPromise.then(function () {
            // update option.  As an optimization do it only when event is not null since this is the
            // only time when it's not triggered by API, in which case the value is already current
            if (event != null && self.ojContext._IsCustomElement()) {
              var currValue = self.GetOption('expanded');
              if (self._isKeySet(currValue)) {
                var newValue = currValue.delete([key]);
                self.SetOption('expanded', newValue, {
                  _context: {
                    originalEvent: event,
                    internalSet: true
                  },
                  changed: true
                });
              }
            }

            self.Trigger('collapse', event, ui);
          });
        }

        // _collapsedKeys should only be used in the legacy syntax case
        if (!this.ojContext._IsCustomElement()) {
          // keep track of collapsed item
          if (this._collapsedKeys == null) {
            this._collapsedKeys = [];
          }

          if (this._collapsedKeys.indexOf(key) === -1) {
            this._collapsedKeys.push(key);
          }
        }

        animationPromise.then(function () {
          // clear cached height
          self.m_clientHeight = null;
          self.m_scrollHeight = null;
          self.signalTaskEnd(); // signal method task end
        });
      },

      /**
       * Animate collapse operation
       * To be change by NavList
       * @param {jQuery} item the item to collapse
       * @param {Object} key the key of the group item
       * @param {boolean} animate true if animate the collapse operation, false otherwise
       * @param {Event} event the event that triggers collapse.  Note that event could be null in the case where this is programmatically done by the widget
       * @return {Promise} A Promise that resolves when collapse animation completes
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      AnimateCollapse: function (item, key, animate, event) {
        var totalHeight = 0;
        var animationResolve;
        var self = this;
        var action = 'collapse';

        var animationPromise = new Promise(function (resolve) {
          animationResolve = resolve;
        });

        var groupItem = item.children('ul').first();
        // save the key for collapse animation complete
        groupItem[0].key = key;

        if (animate) {
          this.signalTaskStart('Animate collapse'); // signal task start

          groupItem.children().each(function () {
            totalHeight += $(this).outerHeight();
          });

          groupItem.css('maxHeight', totalHeight + 'px');

          var effect = this.getAnimationEffect(action);
          // max-height = 0 needs to stick around, especially needed for static content
          effect.persist = 'all';

          this.signalTaskStart('Kick off collapse animation'); // signal collapse animation started. Ends in _handleCollapseTransitionEnd()

          // now hide it
          var elem = /** @type {Element} */ (groupItem.get(0));
          var promise = this.StartAnimation(elem, action, effect);
          promise.then(function () {
            self._handleCollapseTransitionEnd(groupItem, animationResolve);
          });

          this.signalTaskEnd(); // signal task end
        } else {
          groupItem.css('maxHeight', '0px');

          this.AnimateCollapseComplete(groupItem);
          animationResolve(null); // resolve animationPromise
        }
        return animationPromise;
      },

      _handleCollapseTransitionEnd: function (groupItem, animationResolve) {
        this.AnimateCollapseComplete(groupItem);

        animationResolve(null); // resolve animationPromise

        this.signalTaskEnd(); // signal collapse animation ended. Started in AnimateCollapse()
      },

      /**
       * Invoked when collapse animation is completed.  Class who overrides AnimateCollapse
       * must call this method upon finish animation.
       * @param {jQuery} groupItem the item to collapse
       * @private
       */
      AnimateCollapseComplete: function (groupItem) {
        groupItem
          .removeClass(this.getGroupExpandStyleClass())
          .addClass(this.getGroupCollapseStyleClass());

        // ask the content handler to do the collapse operation
        // content handler might have been destroyed if animation ended after destroy is called
        if (this.m_contentHandler != null) {
          this.m_contentHandler.Collapse(groupItem);
        }

        this._setDisclosing(groupItem[0].key, false);
      },

      /**
       * Gets the keys of currently expanded items.
       * Invoke by widget
       * @return {Array} array of keys of currently expanded items.
       */
      getExpanded: function () {
        var expanded = [];
        var self = this;
        var items = this._getItemsCache();

        items.each(function () {
          var item = $(this);
          if (self.GetState(item) === self.STATE_EXPANDED) {
            expanded.push(self.GetKey(item[0]));
          }
        });

        return expanded;
      },
      /** ******************************* End Disclosure *******************************************/

      /**
       * Returns widget constructor.  Used by ContentHandler
       */
      getWidgetConstructor: function () {
        return Components.__GetWidgetConstructor(this.element);
      },

      /** ********************************* Style Classes *********************************************/
      /**
       * To be change by NavList
       * @return {string} the container style class
       * @protected
       */
      GetContainerStyleClass: function () {
        // do not set overflow to scroll for windows touch enabled devices
        if (this._isNonWindowTouch()) {
          return 'oj-listview oj-listview-container-touch';
        }

        return 'oj-listview oj-listview-container';
      },

      /**
       * To be change by NavList
       * @return {string} the main element style class
       * @protected
       */
      GetStyleClass: function () {
        return 'oj-listview-element';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @return {string} the list item style class
       */
      getItemStyleClass: function () {
        if (this.isCardDisplayMode()) {
          return 'oj-listview-card';
        }
        return 'oj-listview-item';
      },

      getNoDataCardStyleClass: function () {
        return 'oj-listview-no-data-card';
      },

      getNoDataItemStyleClass: function () {
        return 'oj-listview-no-data-item';
      },

      getNoDataCellElementStyleClass: function () {
        return 'oj-listview-no-data-cell-element';
      },

      /**
       * Gets the item layout class
       */
      getItemLayoutStyleClass: function () {
        // we don't have a default layout style class for card yet
        return this.isCardLayout() ? null : 'oj-listview-item-layout';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @return {string} the focused element style class
       */
      getFocusedElementStyleClass: function () {
        return 'oj-listview-focused-element';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @return {string} the list item element style class
       */
      getItemElementStyleClass: function () {
        return 'oj-listview-item-element';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @param {boolean=} includeSupplement optional flag to indicate whether to include any supplement classes
       * @return {string} the group item element style class
       */
      getGroupItemStyleClass: function (includeSupplement) {
        if (includeSupplement && this._isPinGroupHeader() && this._isPositionStickySupported()) {
          return 'oj-listview-group-item oj-sticky';
        }

        return 'oj-listview-group-item';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @return {string} the group element style class
       */
      getGroupStyleClass: function () {
        return this.isCardDisplayMode() ? 'oj-listview-card-group' : 'oj-listview-group';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @return {string} the group expand style class
       */
      getGroupExpandStyleClass: function () {
        return '';
      },

      /**
       * To be change by NavList.  Access by ContentHandler.
       * @return {string} the group collapse style class
       */
      getGroupCollapseStyleClass: function () {
        return this.getGroupExpandStyleClass();
      },

      /**
       * To be change by NavList
       * @return {string} the collapse icon style class
       */
      getCollapseIconStyleClass: function () {
        return 'oj-listview-collapse-icon';
      },

      /**
       * To be change by NavList
       * @return {string} the expand icon style class
       */
      getExpandIconStyleClass: function () {
        return 'oj-listview-expand-icon';
      },

      /**
       * To be change by NavList
       * @return {string} the expanding icon style class
       */
      getExpandingIconStyleClass: function () {
        return 'oj-listview-expanding-icon';
      },

      /**
       * To be change by NavList
       * @return {string} the empty text style class
       */
      getEmptyTextStyleClass: function () {
        return 'oj-listview-no-data-message';
      },

      /**
       * To be change by NavList
       * @return {string} the empty text marker class
       */
      getEmptyTextMarkerClass: function () {
        return 'oj-listview-empty-text';
      },

      /**
       * To be change by NavList
       * @return {string} the depth style class
       */
      // eslint-disable-next-line no-unused-vars
      getDepthStyleClass: function (depth) {
        return '';
      },

      /**
       * To be change by NavList
       * @return {Object} default styles values
       */
      getStyleValues: function () {
        const defaultOptions = {};
        Object.entries(_ojListView._CSS_Vars).forEach(([key, value]) => {
          if (key === 'animation' || key === 'gridlines') {
            defaultOptions[key] = _ojListView.getComplexCSSVariable(value);
          } else {
            defaultOptions[key] = ThemeUtils.getCachedCSSVarValues([value])[0];
          }
        });
        return defaultOptions;
      },

      /**
       * To be change by NavList
       * @return {string} Loading status icon style class
       */
      getLoadingStatusIconStyleClass: function () {
        return 'oj-listview-loading-icon';
      },
      /**
       * To be change by NavList
       * @return {string} status message style class
       */
      getStatusMessageStyleClass: function () {
        return 'oj-listview-status-message';
      },
      /**
       * To be change by NavList
       * @return {string} status style class
       */
      getStatusStyleClass: function () {
        return 'oj-listview-status';
      },

      /** ******************************* End Style Classes *******************************************/

      /** ********************************* Pin Header *********************************************/
      _isPositionStickySupported: function () {
        // use native position sticky support for all platforms except IE11
        return !DataCollectionUtils.isIE() && !DataCollectionUtils.isEdge();
      },

      /**
       * Helper method to prevent scroll by mouse wheel causes the page to scroll because it has reached the start/end of the list
       * @param {Element} scroller the scroller
       * @param {Event} event the mouse wheel event
       * @private
       */
      _preventMouseWheelOverscroll: function (scroller, event) {
        var delta = event.originalEvent.deltaY;
        // should only be applicable to TableDataSourceContentHandler for now
        if (isNaN(delta) || this.m_contentHandler.hasMoreToFetch === undefined) {
          return;
        }

        var scrollTop = scroller.scrollTop;
        if (delta > 0) {
          // scroll down
          var scrollHeight = this._getScrollHeight();
          if (
            this.m_contentHandler.hasMoreToFetch() &&
            scrollTop + this._getClientHeight() + Math.abs(delta) >= scrollHeight
          ) {
            // eslint-disable-next-line no-param-reassign
            scroller.scrollTop = scrollHeight;
            event.preventDefault();
          }
        } else if (scrollTop > 0 && scrollTop + delta <= 0) {
          // scroll up
          // eslint-disable-next-line no-param-reassign
          scroller.scrollTop = 0;
          event.preventDefault();
        }
      },

      /**
       * Retrieve the element where the scroll listener is registered on.
       * @private
       */
      _getScrollEventElement: function () {
        var scroller = this._getScroller();

        // if scroller is the body, listen for window scroll event.  This is the only way that works consistently across all browsers.
        if (scroller === document.body || scroller === document.documentElement) {
          return window;
        }

        return scroller;
      },

      /**
       * Find the element closest to the top of the viewport
       * @param {number} currScrollTop the current scrolltop
       * @prarm {boolean} isHierData if this supports hierarchical data
       * @param {number} itemHeight the item height
       * @private
       */
      _findClosestElementToTop: function (currScrollTop, isHierData, itemHeight) {
        // getItemsCache returns a flat view of all expanded items
        var items = isHierData
          ? this._getItemsCache()
          : $(this._getRootNodeForItems()).children('li.' + this.getItemElementStyleClass());
        if (items == null || items.length === 0) {
          return null;
        }

        // if the previous scroll position is relatively close to the current one
        // we'll use the previous index as the starting point
        var index;
        var prevScrollPosition = this.GetOption('scrollPosition');
        if (
          Math.abs(prevScrollPosition.y - currScrollTop) < this.MINIMUM_ITEM_HEIGHT &&
          prevScrollPosition.key != null &&
          !isNaN(prevScrollPosition.index)
        ) {
          if (isHierData) {
            var element = this.FindElementByKey(prevScrollPosition.key);
            if (element != null) {
              index = items.index(element);
            }
          } else {
            index = prevScrollPosition.index;
          }
        }

        // we'll need to approximate the index
        if (isNaN(index)) {
          index = Math.floor(currScrollTop / itemHeight);
        }
        // ensure estimated index is valid
        index = Math.min(Math.max(index, 0), items.length - 1);

        // Sanitize scrollTop values for negative values.
        // This is to address Safari negative scrollTop when scroll "bounces" at the top
        var scrollTop = Math.max(currScrollTop, 0);

        var elem = items[index];
        var offsetTop;
        if (index === 0) {
          offsetTop = 0;
        } else {
          offsetTop = elem.offsetTop;
        }
        var diff = scrollTop - offsetTop;
        var firstInGroup = { index: index, elem: elem, offsetTop: offsetTop, offset: diff };

        // scroll position perfectly line up with the top of item (take sub-pixels into account), we are done
        if (Math.abs(diff) < 1) {
          return firstInGroup;
        }

        // go forward or backward to find the item, keep that fix to avoid
        // potentially going back and forth (shouldn't happen)
        var forward = diff > 0;
        if (forward) {
          index += 1;
        } else {
          index -= 1;
        }
        var found = false;
        while (!found && index >= 0 && index < items.length) {
          elem = items[index];
          offsetTop = elem.offsetTop;
          diff = Math.abs(scrollTop - offsetTop);

          found = diff < 1 || (forward ? scrollTop <= offsetTop : scrollTop >= offsetTop);
          if (found) {
            // the one closer to the top wins
            if (diff < 1 || !forward) {
              // the current one is closer
              firstInGroup = { index: index, elem: elem, offsetTop: offsetTop, offset: diff };
            }
            break;
          }
          // for card layout, we want to return the first item among items that have the same scrollTop (same row)
          // note when scrolling backward, you'll always want the last one encountered
          if (!forward || firstInGroup.offsetTop !== offsetTop) {
            firstInGroup = { index: index, elem: elem, offsetTop: offsetTop, offset: diff };
          }
          if (forward) {
            index += 1;
          } else {
            index -= 1;
          }
        }

        if (!found) {
          // then it's the first/last item in the group/root
          index = forward ? items.length - 1 : 0;
          firstInGroup.index = index;
          firstInGroup.elem = items[index];
        }
        return firstInGroup;
      },

      /**
       * Returns the element which is the direct parent of all item elements.  Only for non-hier data.
       * @private
       */
      _getRootNodeForItems: function () {
        return this.isCardLayout()
          ? this.element.get(0).firstElementChild.firstElementChild
          : this.element.get(0);
      },

      /**
       * Gets the item height. Will set it if it is NaN
       * @return {number} item height
       * @private
       */
      _getItemHeight: function () {
        if (this.m_itemHeight == null) {
          var firstItem;
          var isHierData = this.m_contentHandler.IsHierarchical();
          if (isHierData) {
            // could be a group
            firstItem = this.element.children('li.' + this.getItemElementStyleClass()).first();
            if (firstItem.length > 0) {
              this.m_itemHeight = firstItem.get(0).firstElementChild.offsetHeight;
            }
          } else {
            firstItem = $(this._getRootNodeForItems())
              .children('li.' + this.getItemElementStyleClass())
              .first();
            if (firstItem.length > 0) {
              this.m_itemHeight = firstItem.get(0).offsetHeight;
            }
          }
        }

        return this.m_itemHeight;
      },

      /**
       * Returns the scroll position object containing info about current scroll position.
       * @private
       */
      _getCurrentScrollPosition: function (scrollTop) {
        var scrollPosition = {};
        var scroller = this._getScroller();

        if (scrollTop === undefined) {
          // eslint-disable-next-line no-param-reassign
          scrollTop = scroller.scrollTop;
        }

        scrollPosition.x = this._getScrollX(scroller);
        scrollPosition.y = scrollTop;

        var isHierData = this.m_contentHandler.IsHierarchical();
        var itemHeight = this._getItemHeight();

        // we used the item height to approximate where to begin the search
        // for the top most item.  This var should be populated in renderComplete
        // if there's no data then we should skip
        if (!isNaN(itemHeight) && itemHeight > 0) {
          var result = this._findClosestElementToTop(scrollTop, isHierData, itemHeight);
          if (result != null) {
            var elem = result.elem;
            if (isHierData) {
              var header;
              var parent = elem.parentNode;
              if (parent !== this.element.get(0)) {
                this.m_closestParent = parent.parentNode;
                scrollPosition.parent = this.GetKey(this.m_closestParent);
                header = this.m_closestParent.firstElementChild;
              } else {
                header = result.elem.firstElementChild;
              }
              scrollPosition.key = this.GetKey(result.elem);
              scrollPosition.index = $(parent).children().index(elem);

              // handle sticky header here too
              if (header && header.classList.contains('oj-sticky')) {
                if (this.m_stuckHeader && this.m_stuckHeader !== header) {
                  this.m_stuckHeader.classList.remove('oj-stuck');
                }
                header.classList.add('oj-stuck');
                this.m_stuckHeader = header;
              }
            } else {
              scrollPosition.index = result.index;
              scrollPosition.key = this.GetKey(result.elem);
            }
            scrollPosition.offsetY = Math.max(0, result.offset);
            // offsetX is the same as x, even when card layout is used
            // since listview wraps card on space available, there will never be a listview
            // having 2 or more columns with a horizontal scrollbar
            scrollPosition.offsetX = scrollPosition.x;
          }
        }

        return scrollPosition;
      },

      /**
       * @private
       */
      _getOffsetTop: function (elem) {
        var elemOffsetTop = elem.offsetTop;
        if (this.isCardLayout() && this.m_contentHandler.getMargin) {
          var margin = this.m_contentHandler.getMargin();
          if (!isNaN(margin)) {
            elemOffsetTop = Math.max(0, elemOffsetTop - margin);
          }
        }

        var offsetTop = this.element.get(0).offsetTop;
        if (!isNaN(this.m_elementOffset) && this.m_elementOffset !== offsetTop) {
          return Math.max(0, elemOffsetTop - offsetTop);
        }

        return elemOffsetTop;
      },

      /**
       * Retrieve the scroll top value based on item index (optionally with parent key)
       * @private
       */
      _getScrollTopByIndex: function (index, parent) {
        var parentElem;

        if (parent != null) {
          parentElem = this.FindElementByKey(parent);
          if (parentElem != null) {
            // find the ul element
            parentElem = $(parentElem).children('ul').first();
          }
        } else {
          // avoid doing offsetTop
          if (index === 0) {
            return 0;
          }

          parentElem = this.element.get(0);
          if (this.isCardLayout()) {
            parentElem = parentElem.firstElementChild.firstElementChild;
          }
        }

        if (parentElem != null) {
          var elem = $(parentElem).children('.' + this.getItemElementStyleClass())[index];
          if (elem != null) {
            return this._getOffsetTop(elem);
          }
        }

        // we got here because one of the following happened:
        // 1) item has not been fetched yet
        // 2) index is large than the number of items, including reaching maxCount
        // 3) parent key specified does not exists or has not been fetched yet
        if (this.m_contentHandler.hasMoreToFetch && this.m_contentHandler.hasMoreToFetch()) {
          return this._getScrollHeight();
        }

        return undefined;
      },

      /**
       * Retrieve the scroll top value based on item key
       * @private
       */
      _getScrollTopByKey: function (key) {
        var elem = this.FindElementByKey(key);
        if (elem != null) {
          return this._getOffsetTop(elem);
        }

        // we got here because one of the following happened:
        // 1) item has not been fetched yet
        // 2) key does not exists or invalid
        if (this.m_contentHandler.hasMoreToFetch && this.m_contentHandler.hasMoreToFetch()) {
          return this._getScrollHeight();
        }
        return undefined;
      },

      /**
       * Gets the scroll coordinate based on value of scrollPosition.
       * @return {Object} the coordinate to scroll to, see syncScrollPosition
       * @private
       */
      _getScrollCoordinates: function (scrollPosition) {
        var y;
        var x = scrollPosition.x;
        var offsetX = scrollPosition.offsetX;
        if (!isNaN(x) && !isNaN(offsetX)) {
          x += offsetX;
        }

        // key first
        var key = scrollPosition.key;
        if (isNaN(y) && key != null) {
          y = this._getScrollTopByKey(key);
        }

        // then index
        var parent = scrollPosition.parent;
        var index = scrollPosition.index;
        if (isNaN(y) && !isNaN(index)) {
          y = this._getScrollTopByIndex(index, parent);
        }

        var offsetY = scrollPosition.offsetY;
        if (!isNaN(y) && !isNaN(offsetY)) {
          y += offsetY;
        }

        // then pixel position last
        if (isNaN(y) && !isNaN(scrollPosition.y)) {
          y = scrollPosition.y;
        }

        return { x: x, y: y };
      },

      /**
       * Whether there are no items in the list
       */
      _isEmpty: function () {
        // can't just use childElementCount as there could be no data content or skeletons
        var root = this.element[0];
        var item = root.querySelector('li.' + this.getItemElementStyleClass());
        var tempItem = root.querySelector('li.oj-listview-temp-item');
        return item == null && tempItem == null;
      },

      /**
       * Scroll handler
       * @private
       */
      _handleScroll: function (event) {
        // since we are calling it from requestAnimationFrame, ListView could have been destroyed already
        // do not handle scroll for NavList, or when it is empty (could scroll due to rendering of skeletons)
        if (this.m_contentHandler == null || !this.ShouldUseGridRole() || this._isEmpty()) {
          return;
        }

        // update scrollPosition
        var scrollTop = this._getScroller().scrollTop;
        if (!this.ojContext._IsCustomElement()) {
          this.SetOption('scrollTop', scrollTop, {
            _context: {
              originalEvent: event,
              internalSet: true
            }
          });
        }

        if (this.ShouldUpdateScrollPosition()) {
          this.SetOption('scrollPosition', this._getCurrentScrollPosition(scrollTop), {
            _context: {
              originalEvent: event,
              internalSet: true
            }
          });
        }

        // handle pinning group header, does not need if position sticky is supported
        this._handlePinGroupHeader();
      },

      /**
       * Whether high-watermark scrolling is specified
       * @protected
       */
      isLoadMoreOnScroll: function () {
        // for legacy DataSource, we will maintain the behavior for 'auto'
        var scrollPolicy = this.GetOption('scrollPolicy');
        if (scrollPolicy === 'auto') {
          var data = this.GetOption('data');
          if (
            data != null &&
            ((typeof oj.TableDataSource !== 'undefined' && data instanceof oj.TableDataSource) ||
              (typeof oj.TreeDataSource !== 'undefined' && data instanceof oj.TreeDataSource))
          ) {
            return false;
          }
        }

        return scrollPolicy !== 'loadAll';
      },

      /**
       * Un-register scroll listener
       * @private
       */
      _unregisterScrollHandler: function () {
        var scrollElem = $(this._getScrollEventElement());
        if (this._scrollListener) {
          scrollElem[0].removeEventListener('scroll', this._scrollListener);
        }

        if (this.ojContext._IsCustomElement()) {
          // remove wheel listener add with addEventListener
          scrollElem[0].removeEventListener('wheel', this._wheelListener, { passive: false });
          delete this._wheelListener;
        } else {
          // remove wheel listener added with jQuery
          this.ojContext._off(scrollElem, 'wheel');
        }
        return scrollElem;
      },

      /**
       * Register scroll listener
       * @private
       */
      _registerScrollHandler: function () {
        var self = this;
        var scrollElem = this._unregisterScrollHandler();

        this._scrollListener = function (event) {
          // throttle the event using requestAnimationFrame for performance reason
          // don't update if scroll is triggered by listview internally setting scrollLeft/scrollTop
          if (!self._skipScrollUpdate && !self.m_ticking) {
            window.requestAnimationFrame(function () {
              self._handleScroll(event);
              self.m_ticking = false;
            });

            self.m_ticking = true;
          }

          Logger.info('scroll listener: ' + self._skipScrollUpdate);
          if (self._skipScrollUpdate) {
            Logger.info('clearing scrollPosBusyState');
            self._clearScrollPosBusyState();
          }

          self._skipScrollUpdate = false;
        };
        scrollElem[0].addEventListener('scroll', this._scrollListener);

        // only do this for high-water mark scrolling as other cases we have (and should not care) no knowledge about the scroller
        if (this.isLoadMoreOnScroll() && this._getScroller() !== document.documentElement) {
          this._wheelListener = function (event) {
            // add originalEvent for downstream code expecting it
            if (!event.originalEvent) {
              // eslint-disable-next-line no-param-reassign
              event.originalEvent = event;
            }
            self._preventMouseWheelOverscroll(self._getScroller(), event);
          };
          this._scrollElem = scrollElem;
          if (this.ojContext._IsCustomElement()) {
            this._scrollElem[0].addEventListener('wheel', this._wheelListener, { passive: false });
          } else {
            this.ojContext._on(this._scrollElem, {
              wheel: this._wheelListener
            });
          }
        }
      },

      /**
       * Invoked by ContentHandler
       * Merge scroll event handling with DomScroller so that:
       * 1) we rely on scroll event handling in a certain order, so this gives us more control over that
       * 2) scroll handling happens at the same time
       * @private
       */
      mergeScrollListener: function () {
        if (this._scrollListener) {
          var scrollElem = this._getScrollEventElement();
          scrollElem.removeEventListener('scroll', this._scrollListener);
        }
        return this._scrollListener;
      },

      /**
       * Invoked by ContentHandler
       * Unmerge scroll event handling.  This happens when DomScroller is destroyed.
       * @private
       */
      unmergeScrollListener: function () {
        if (this._scrollListener) {
          var scrollElem = this._getScrollEventElement();
          scrollElem.removeEventListener('scroll', this._scrollListener);
          scrollElem.addEventListener('scroll', this._scrollListener);
        }
      },

      /**
       * Whether group header should be pin
       * @return {boolean} true if group header should be pin or false otherwise
       * @private
       */
      _isPinGroupHeader: function () {
        return (
          this.GetOption('groupHeaderPosition') !== 'static' && this.m_contentHandler.IsHierarchical()
        );
      },

      /**
       * Retrieve the visible (flattened) group items cache, create one if it is null.
       * @return {jQuery} a list of group items
       * @private
       */
      _getGroupItemsCache: function () {
        if (this.m_groupItems == null) {
          var selector = '.' + this.getGroupItemStyleClass() + ':visible';
          this.m_groupItems = this.element.find(selector).filter(function () {
            // if it's expanded and it has children
            if (!$(this).parent().hasClass('oj-collapsed')) {
              if ($(this).next().children().length > 0) {
                return true;
              }
            }

            return false;
          });
        }
        return this.m_groupItems;
      },

      /**
       * Unpin a pinned group header
       * @param {Element} groupItem the group header element to unpin
       * @private
       */
      _unpinGroupItem: function (groupItem) {
        $(groupItem).removeClass('oj-pinned');
        // eslint-disable-next-line no-param-reassign
        groupItem.style.top = 'auto';
        // eslint-disable-next-line no-param-reassign
        groupItem.style.width = 'auto';
      },

      /**
       * Gets the next group item.  This could be a group item from a different parent.
       * @param {Element} groupItem the reference group item.
       * @return {Element|null} the next group item or null if one cannot be found
       * @private
       */
      _getNextGroupItem: function (groupItem) {
        var groupItems = this._getGroupItemsCache();
        var index = groupItems.index(groupItem);
        if (index > -1 && index < groupItems.length - 1) {
          return groupItems[index + 1];
        }

        return null;
      },

      /**
       * Pin a group header
       * @param {Element} groupItem the group header element to pin
       * @param {number} scrollTop the scrolltop position of the listview container
       * @private
       */
      _pinGroupItem: function (groupItem, scrollTop) {
        var width = groupItem.offsetWidth;
        var height = groupItem.offsetHeight;
        var next = this._getNextGroupItem(groupItem);

        // todo: get rid of 5
        if (next != null && next.offsetTop <= scrollTop + height + 5) {
          // eslint-disable-next-line no-param-reassign
          scrollTop -= height;
        }

        $(groupItem).addClass('oj-pinned');
        // eslint-disable-next-line no-param-reassign
        groupItem.style.top = scrollTop + 'px';
        // eslint-disable-next-line no-param-reassign
        groupItem.style.width = width + 'px';
      },

      /**
       * Pin the header as neccessary when user scrolls.
       * @private
       */
      _handlePinGroupHeader: function () {
        var groupItemToPin;

        // if groupHeaderPosition is not sticky or if position:sticky is supported natively in the browser
        if (!this._isPinGroupHeader() || this._isPositionStickySupported()) {
          return;
        }

        var scroller = this._getScroller();
        var scrollTop = scroller.scrollTop;

        // see if we are at the top
        if (this.m_groupItemToPin != null && scrollTop === 0) {
          this._unpinGroupItem(this.m_groupItemToPin);
          this.m_groupItemToPin = null;
          return;
        }

        // find the group item to pin
        var groupItems = this._getGroupItemsCache();
        var pinHeaderHeight = 0;
        if (this.m_groupItemToPin != null) {
          pinHeaderHeight = this.m_groupItemToPin.offsetHeight;
        }

        for (var i = 0; i < groupItems.length; i++) {
          var groupItem = groupItems[i];
          if (this.m_groupItemToPin !== groupItem) {
            var top = groupItems[i].offsetTop;
            var bottom = top + groupItem.parentNode.offsetHeight;

            // if bottom half is in view but not the top half
            if (top < scrollTop && bottom > scrollTop + pinHeaderHeight) {
              groupItemToPin = groupItem;
              break;
            }
          }
        }

        // found the group item to pin
        if (groupItemToPin != null && groupItemToPin !== this.m_groupItemToPin) {
          // unpin the previous item
          if (this.m_groupItemToPin != null) {
            this._unpinGroupItem(this.m_groupItemToPin);
          }

          this._pinGroupItem(groupItemToPin, scrollTop);
          this.m_groupItemToPin = groupItemToPin;
        } else if (this.m_groupItemToPin != null) {
          // is the current pin header touching the next item
          var next = this._getNextGroupItem(this.m_groupItemToPin);
          if (next != null && next.offsetTop <= scrollTop + pinHeaderHeight) {
            // make sure they really touches
            this.m_groupItemToPin.style.top = next.offsetTop - pinHeaderHeight + 'px';
            return;
          }

          this.m_groupItemToPin.style.top = scrollTop + 'px';
        }
      },

      /**
       * Gets the scroller element, which is either the listview container or the scroller element
       * specified in scrollPolicyOptions
       * @return {Element} the scroller element
       */
      _getScroller: function () {
        if (this.m_scroller != null) {
          return this.m_scroller;
        }

        var scroller;
        var options = this.GetOption('scrollPolicyOptions');
        if (options != null) {
          scroller = options.scroller;
          if (scroller != null) {
            if (typeof scroller === 'string') {
              scroller = document.querySelector(scroller);
              if (scroller == null) {
                Logger.error(
                  'the css selector string specified in scroller attribute does not resolve to any element'
                );
              }
            }

            // make sure the scroller is an ancestor
            if (scroller != null && !scroller.contains(this.getListContainer()[0])) {
              Logger.error('the specified scroller must be an ancestor of the component');
              scroller = null;
            }
          }
        }

        this.m_scroller = scroller != null ? scroller : this.getListContainer().get(0);
        return this.m_scroller;
      },

      /**
       * Scroll to the specified group header
       * @param {Element} groupHeader the group header div element
       * @private
       */
      _scrollToGroupHeader: function (groupHeader) {
        var scroller = this._getScroller();
        var currentScrollTop = scroller.scrollTop;

        // unpin any pinned group header first before scroll to header
        if (this.m_groupItemToPin != null) {
          this._unpinGroupItem(this.m_groupItemToPin);
          this.m_groupItemToPin = null;
        }

        var newScrollTop = groupHeader.offsetTop;
        // when scrolling backwards, the offsetTop is going to take position sticky into account, so it will
        // scroll to the minimum where the header is visible, and as a result all children items would not be visible
        if (
          this._isPinGroupHeader() &&
          this._isPositionStickySupported() &&
          newScrollTop < currentScrollTop
        ) {
          newScrollTop = Math.max(
            0,
            newScrollTop - groupHeader.parentNode.offsetHeight + groupHeader.offsetHeight
          );
        }
        scroller.scrollTop = newScrollTop;

        // if it wasn't scroll (ex: already at the end), we'll have to explicitly try to see if we need to pin again
        if (currentScrollTop === scroller.scrollTop) {
          this._handlePinGroupHeader();
        }

        // set the first item in group current
        this._setFirstFocusableItemInGroupCurrent(groupHeader);
      },

      /**
       * Find the first focusable item within the group and make it current
       * @param {Element} groupHeader the group header
       * @private
       */
      _setFirstFocusableItemInGroupCurrent: function (groupHeader) {
        var self = this;
        var items = $(groupHeader).next().children();
        items.each(function () {
          var item = $(this);

          // make sure item can receive focus
          if (!self.SkipFocus(item)) {
            self.SetOption('currentItem', this.key);
            return false;
          }
          return undefined;
        });
      }
      /** ******************************* End Pin Header *******************************************/
    }
  );

  _ojListView._CSS_Vars = {
    animation: {
      add: '--oj-private-list-view-global-add-animation-default',
      remove: '--oj-private-list-view-global-remove-animation-default',
      update: '--oj-private-list-view-global-update-animation-default',
      expand: '--oj-private-list-view-global-expand-animation-default',
      collapse: '--oj-private-list-view-global-collapse-animation-default',
      pointerUp: '--oj-private-list-view-global-pointerUp-animation-default',
      cardEntrance: '--oj-private-list-view-global-card-entrance-animation-default',
      cardExit: '--oj-private-list-view-global-card-exit-animation-default'
    },
    gridlines: {
      item: '--oj-private-list-view-global-gridlines-item-default',
      top: '--oj-private-list-view-global-gridlines-top-default',
      bottom: '--oj-private-list-view-global-gridlines-bottom-default'
    },
    loadIndicator: '--oj-private-list-view-global-load-indicator-default',
    showIndicatorDelay: '--oj-private-core-global-loading-indicator-delay-duration',
    cardAnimationDelay: '--oj-private-animation-global-card-entrance-delay-increment'
  };

  _ojListView.getComplexCSSVariable = function (varsObject) {
    const defaultOptions = {};
    const keys = Object.keys(varsObject);
    const vars = keys.map((key) => varsObject[key]);
    const values = ThemeUtils.getCachedCSSVarValues(vars);
    keys.forEach((key, i) => {
      const value = /^(\[|{)/.test(values[i]) ? JSON.parse(values[i]) : values[i];
      defaultOptions[key] = value;
    });
    return defaultOptions;
  };

  oj._registerLegacyNamespaceProp('_ojListView', _ojListView);

  /**
   * @ojcomponent oj.ojListView
   * @augments oj.baseComponent
   * @since 1.1.0
   * @ojimportmembers oj.ojSharedContextMenu
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider", "ItemMetadata", "Item"]}
   * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["KeySet"]}
   * @ojtsimport {module: "ojcommontypes", type: "AMD", importName: ["CommonTypes"]}
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojListView<K, D> extends baseComponent<ojListViewSettableProperties<K,D>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojListViewSettableProperties<K,D> extends baseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @ojshortdesc A list view displays data items as a list or a grid with highly interactive features.
   * @ojrole grid
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["selectionMode"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data", "selected"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-list'
   * @ojuxspecs ['list-view']
   *
   * @classdesc
   * <h3 id="listViewOverview-section">
   *   JET ListView Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#listViewOverview-section"></a>
   * </h3>
   *
   * <p>Description: The JET ListView enhances a HTML list element into a themable, WAI-ARIA compliant, mobile friendly component with advance interactive features.</p>
   *
   * <p>The child content can be configured via inline HTML content or a DataProvider.
   * It is recommended that inline HTML content should only be used for static data and the DataProvider should always be used for mutable data.
   * </p>
   *
   * <h3 id="data-section">
   *   Data
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
   * </h3>
   * <p>The JET ListView gets its data in three different ways.  The first way is from a DataProvider/TableDataSource.  There are several types of DataProvider/TableDataSource
   * that are available out of the box:</p>
   * <ul>
   * <li>ArrayDataProvider</li>
   * <li>CollectionTableDataSource</li>
   * <li>PagingTableDataSource</li>
   * </ul>
   * <p>Note that TableDataSource has been deprecated, please find the equivalent DataProvider implementation.</p>
   *
   * <p><b>oj.ArrayDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, ListView will automatically react
   * when items are added or removed from the array.  See the documentation for oj.ArrayDataProvider for more details on the available options.</p>
   *
   * <p><b>oj.CollectionTableDataSource</b> - Use this when oj.Collection is the model for the underlying data.  Note that the ListView will automatically react to model event from
   * the underlying oj.Collection.  See the documentation for oj.CollectionTableDataSource for more details on the available options.</p>
   *
   * <p><b>PagingTableDataSource</b> - Use this when the ListView is driven by an associating ojPagingControl.  See the documentation for PagingTableDataSource for more
   * details on the available options.</p>
   *
   * <p>The second way is from a TreeDataProvider/TreeDataSource.  This is typically used to display data that are logically categorized in groups.  There are several types
   * of TreeDataProvider/TreeDataSource that are available out of the box:</p>
   * <ul>
   * <li>oj.ArrayTreeDataProvider</li>
   * <li>oj.CollectionTreeDataSource</li>
   * </ul>
   *
   * <p><b>oj.ArrayTreeDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, ListView will automatically react
   * when items are added or removed from the array.  See the documentation of oj.ArrayTreeDataProvider for more details on the available options.</p>
   *
   * <p><b>oj.CollectionTreeDataSource</b> - Use this when oj.Collection is the model for each group of data.  See the documentation for oj.CollectionTableDataSource
   * for more details on the available options.</p>
   *
   * <p>Finally, ListView also supports static HTML content as data.  The structure of the content can be either flat or hierarhical.</p>
   * <p>Any manipulation of static HTML content, including manipulating content generated through Knockout (for example, updating observableArray in a foreach binding), is not supported.<p>
   *
   * <p>A note about hierarchical data, even though ListView supports data with > 2 levels, it is not recommended because it does not render depth, for that case you should look at using ojTreeView<p>
   *
   *
   * <p>Example of flat static content</p>
   * <pre class="prettyprint">
   * <code>&lt;oj-list-view id="listView">
   *   &lt;ul>
   *     &lt;li>&lt;a id="item1" href="#">Item 1&lt;/a>&lt;/li>
   *     &lt;li>&lt;a id="item2" href="#">Item 2&lt;/a>&lt;/li>
   *     &lt;li>&lt;a id="item3" href="#">Item 3&lt;/a>&lt;/li>
   *   &lt;/ul>
   * &lt;/oj-list-view>
   * </code></pre>
   *
   * <p>Example of hierarchical static content</p>
   * <pre class="prettyprint">
   * <code>&lt;oj-list-view id="listView">
   *   &lt;ul>
   *     &lt;li>&lt;a id="group1" href="#">Group 1&lt;/a>
   *       &lt;ul>
   *         &lt;li>&lt;a id="item1-1" href="#">Item 1-1&lt;/a>&lt;/li>
   *         &lt;li>&lt;a id="item1-2" href="#">Item 1-2&lt;/a>&lt;/li>
   *       &lt;/ul>
   *     &lt;/li>
   *     &lt;li>&lt;a id="group2" href="#">Group 2&lt;/a>
   *       &lt;ul>
   *         &lt;li>&lt;a id="item2-1" href="#">Item 2-1&lt;/a>&lt;/li>
   *         &lt;li>&lt;a id="item2-2" href="#">Item 2-2&lt;/a>&lt;/li>
   *       &lt;/ul>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-list-view>
   * </code></pre>
   *
   * <p>Example of data provider content</p>
   * <pre class="prettyprint"><code>
   *   &lt;oj-list-view data="[[dataProvider]]">
   *   &lt;/oj-list-view>
   * </code></pre>
   * <p>Check out the Listview Basic demo</a>
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="context-section">
   *   Item Context
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
   * </h3>
   *
   * <p>For all item options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular item.  This gives developers the flexibility to return different value depending on the context.</p>
   *
   * <p>The context paramter contains the following keys:</p>
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>componentElement</kbd></td>
   *       <td>A reference to the root element of ListView.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>datasource</kbd></td>
   *       <td>A reference to the data source object. (Not available for static content)</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>index</kbd></td>
   *       <td>The index of the item, where 0 is the index of the first item.  In the hierarchical case the index is relative to its parent.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>key</kbd></td>
   *       <td>The key of the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>data</kbd></td>
   *       <td>The data object for the item.</td>
   *     </tr>
   *      <tr>
   *       <td><kbd>metadata</kbd></td>
   *       <td>The metadata object for the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>parentElement</kbd></td>
   *       <td>The list item element.  The renderer can use this to directly append content.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <p></p>
   * <p>If the data is hierarchical, the following additional contextual information are available:</p>
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>depth</kbd></td>
   *       <td>The depth of the item.  The depth of the first level children under the invisible root is 1.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>parentKey</kbd></td>
   *       <td>The key of the parent item.  The parent key is null for root node.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>leaf</kbd></td>
   *       <td>Whether the item is a leaf or a group item.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>Application should specify a value for the aria-label attribute with a meaningful description of the purpose of this list.</p>
   *
   * <p>To facilitate drag and drop including item reordering using only keyboard, application must ensure that either to expose the functionality using context menu, and/or
   * allow users to perform the functionality with the appropriate keystroke.  You can find examples of how this can be done in the cookbook demos.</p>
   *
   * <p>Note that ListView uses the grid role and follows the <a href="https://www.w3.org/TR/wai-aria-practices/examples/grid/LayoutGrids.html">Layout Grid</a> design as outlined in the <a href="https://www.w3.org/TR/wai-aria-practices/#grid">grid design pattern</a></p>.
   * <p>Nesting collection components such as ListView, Table, TreeView, and ListView inside of ListView is not supported.</p>
   * <h4>Custom Colours</h4>
   * <p>Using colors, including background and text colors, is not accessible if it is the only way information is conveyed.
   * Low vision users may not be able to see the different colors, and in high contrast mode the colors are removed.
   * The Redwood approved way to show status is to use badge.</p>
   *
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>Several components will replace oj-list-view in core pack. For a basic list the oj-c-list-view component is available (more information about that below).
   * However the following features will not be added to oj-c-list-view, instead they will be supported in the future in separate, specialized core-pack components.</p>
   * <ul>
   *    <li>Card grid and waterfall layouts</li>
   *    <li>Hierarchical and grouped list views</li>
   *    <li>Expandable list items</li>
   * </ul>
   *
   * <h5>Migration to oj-c-list-view</h5>
   *
   * <p>To migrate from oj-list-view to oj-c-list-view, you need to revise the import statement and references to oj-c-list-view in your app. Please note the changes between the two components below.</p>
   *
   * <p>These features are not yet available in oj-c-list-view, they will be available in a forthcoming version.</p>
   * <ul>
   *    <li>Drag and drop with other components</li>
   *    <li>Save and restore scroll position</li>
   * </ul>
   *
   * <p>The first step is to determine if your list view requires any of the not yet released features (see above list).</p>
   *
   * <p>The next step is to determine compatibility with your DataSource.  Here are some changes.</p>
   * <ul>
   *  <li>DataProvider is the only currently supported data source</li>
   *  <li>Static content lists are no longer supported</li>
   * </ul>
   * <p>
   *
   * <p>In addition, if you have implemented your own custom-elements which are tabbable (capable of receiving keyboard focus via the Tab key)
   * you will need to implement the <code>useTabbableMode</code> API contract.<p>
   *
   * <p>Finally review the list below for specific API changes and changes to ItemContext typing.</p>
   *
   * <h5>No static lists</h5>
   * <p>Support for static lists has not been brought forward,
   * purely typographic, non-interactive lists can be created using native HTML and typography API.</p>
   *
   * <strong>An example of a static list.</strong>
   * <pre class="prettyprint">
   * <code>&lt;oj-list-view id="listView">
   *   &lt;ul>
   *     &lt;li>&lt;a id="item1" href="#">Item 1&lt;/a>&lt;/li>
   *     &lt;li>&lt;a id="item2" href="#">Item 2&lt;/a>&lt;/li>
   *     &lt;li>&lt;a id="item3" href="#">Item 3&lt;/a>&lt;/li>
   *   &lt;/ul>
   * &lt;/oj-list-view>
   * </code></pre>
   *
   * <h5>F2 Interaction Mode Change</h5>
   * <p>oj-c-list-view no longer mutates the DOM to manage tab-stops,
   * sub-components in the template need to implement the "isTabbable" API.
   * More information to come on that soon.
   * </p>
   *
   * <h5>Enter Key Behavior Change</h5>
   * <p>Enter key no longer selects an item.  Only space key should be used
   * to select an item as recommended by the W3C accessibility guideline.
   * </p>
   *
   * <h5>Styling Class Changes</h5>
   * <p><code>oj-listview-item-padding-off</code> is no longer relevant, by default padding is no longer added to List items.</p>
   *
   * <h5>Item Context Changes</h5>
   * <p>The types have changed.</p>
   *
   * <p>The context parameter contains the following keys:</p>
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>data</kbd></td>
   *       <td>The data object for the item.</td>
   *     </tr>
   *      <tr>
   *       <td><kbd>metadata</kbd></td>
   *       <td>The metadata object for the item.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <p>The following keys are not currently supported</p>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>componentElement</kbd></td>
   *       <td>A reference to the root element of ListView.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>datasource</kbd></td>
   *       <td>A reference to the data source object.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>index</kbd></td>
   *       <td>The index of the item, where 0 is the index of the first item.  In the hierarchical case the index is relative to its parent.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>key</kbd></td>
   *       <td>The key of the item (this duplicates metadata.key and has been deprecated)</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>parentElement</kbd></td>
   *       <td>This will be supported by the Hierarchical list component and no longer applies to list view..</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h5>itemTemplate slot</h5>
   * <p>The root node can now take text, and no longer has to be an element. </p>
   *
   * <h5 id="context-menu-migration"></h5>
   *
   * <h5>current-item attribute</h5>
   * <p>This is currently a read-only property.</p>
   *
   * <h5>gridlines attribute</h5>
   * <p>The <code>gridlines</code> property shape has changed. It now takes the keys `item`, `top` and `bottom`,
   * each of which are optional and take a value of "hidden" or "visible". <br/>
   * `item` toggles the presence of bottom gridlines except the last item,
   * and `top` and `bottom` toggle the initial and trailing gridlines.
   * </p>
   *
   * <h5>item.renderer attribute</h5>
   * <p>This is not supported, everything this attribute did can be accomplished through the template.</p>
   *
   * <h5>scroll-policy-options.maxCount attribute</h5>
   * <p>This is no longer supported.</p>
   *
   * <h5>ojBeforeCurrentItem event</h5>
   * <p>
   * this cancellable event is slated for deprecation.
   * It is being replaced with <code>onCurrentItemChanged</code> read-only property change event.
   * </p>
   *
   * <h5>refresh method</h5>
   * <p>This is not supported.  Refresh was so that the elements could reread state from the DOM, this is no longer necessary.</p>
   *
   * <h5>selection-required attribute</h5>
   * <p>This attribute is now replaced by the new <code>singleRequired</code> selection mode.</p>
   *
   * <h5>first-selected-item attribute</h5>
   * <p> This feature is now changed to an event <code> on-oj-first-selected-item</code>, not an attribute anymore. This event is only fired when <code>selection-mode</code> is <code>singleRequired</code></p>
   *
   * <h5>reorder</h5>
   * <p>The reorder API has changed.</p>
   * <ul>
   *   <li>
   *     <code>dnd.reorder.items</code> has renamed to <code>reorderable.items</code>. The values remain the same.</p>
   *   </li>
   *   <li>
   *     The <code>event.detail</code> of <code>ojReorder</code> has been updated. It has changed to key based and now provides `reorderedKeys`, `itemKeys`, and `referenceKey`.
   *     It will no longer provide `position`. The position will always be after the `referenceKey`. If the `referenceKey` is null, that implies that the item is moved to the beginning of the list.
   *   </li>
   *   <li>
   *     Applications should use the new <code>oj-c-drag-handle</code> to show drag icon, instead of the <code>oj-listview-drag-handle</code> style class.
   *   </li
   * </ul>
   *
   * <h5>The following APIs are not yet supported</h5>
   *
   * <ul>
   *   <li>dnd attribute</li>
   *   <li>item.selectable attribute</li>
   *   <li>scroll-policy attribute (currently only load more on scroll is supported)</li>
   *   <li>scroll-position attribute</li>
   *   <li>scroll-to-key attribute</li>
   *   <li>getContextByNode method</li>
   *   <li>getDataForVisibleItem method</li>
   * </ul>
   *
   * <h5>The following APIs are no longer applicable to ListView</h5>
   * <p>Instead they will be considered as API for separate, specialized, core-pack components.</p>
   *
   * <ul>
   *   <li>display attribute (applies to Card view only)</li>
   *   <li>drill-mode attribute</li>
   *   <li>expanded attribute</li>
   *   <li>group-header-position attribute</li>
   *   <li>ojBeforeCollapse event</li>
   *   <li>ojCollapse event</li>
   *   <li>ojExpand event</li>
   *   <li>ojBeforeExpand event</li>
   * </ul>
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Data Set Size</h4>
   * <p>As a rule of thumb, it's recommended that applications limit the amount of data to display.  Displaying large
   * number of items in ListView makes it hard for user to find what they are looking for, but affects the load time and
   * scrolling performance as well.  If displaying large number of items is neccessary, use a paging control with ListView
   * to limit the number of items to display at a time.  Setting <code class="prettyprint">scrollPolicy</code> to
   * 'loadMoreOnScroll' will also reduce the number of items to display initially.</p>
   *
   * <h4>Item Content</h4>
   * <p>ListView allows developers to specify arbitrary content inside its item. In order to minimize any negative effect on
   * performance, you should avoid putting a large number of heavy-weight components inside because as you add more complexity
   * to the structure, the effect will be multiplied because there can be many items in the ListView.</p>
   *
   * <h4>Expand All</h4>
   * <p>While ListView provides a convenient way to initially expand all group items in the ListView, it might have an impact
   * on the initial rendering performance since expanding each group item might cause a fetch from the server depending on
   * the TreeDataSource.  Other factors that could impact performance includes the depth of the tree, and the number of children
   * in each level.</p>
   *
   * <h3 id="animation-section">
   *   Animation
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#animation-section"></a>
   * </h3>
   *
   * <p>Applications can customize animations triggered by actions in ListView by either listening for <code class="prettyprint">animateStart/animateEnd</code>
   * events or overriding action specific style classes on the animated item.  See the documentation of <a href="AnimationUtils.html">AnimationUtils</a>
   * class for details</p>
   *
   * <p>The following are actions in which applications can use to customize animation effects.
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Action</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>add</kbd></td>
   *       <td>When a new item is added to the TableDataSource associated with ListView.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>remove</kbd></td>
   *       <td>When an existing item is removed from the TableDataSource associated with ListView.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>update</kbd></td>
   *       <td>When an existing item is updated in the TableDataSource associated with ListView.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>expand</kbd></td>
   *       <td>When user expands a group item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>collapse</kbd></td>
   *       <td>When user collapses a group item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>pointerUp</kbd></td>
   *       <td>When user finish pressing an item (on touch).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>cardEntrance</kbd></td>
   *       <td>When a card is initially rendered.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>cardExit</kbd></td>
   *       <td>When a card is removed due to the entire data set being refreshed.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h3 id="data-attributes-section">
   *   Custom Data Attributes
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
   * </h3>
   *
   * <p>ListView supports the following custom data attributes.
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Name</th>
   *       <th>Description</th>
   *       <th>Example</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>data-oj-as</kbd></td>
   *       <td>Provides an alias for a specific template instance and has the same subproperties as the $current variable.</td>
   *       <td>
   *         <pre class="prettyprint"><code>&lt;oj-list-view id="listView">
   *   &lt;template slot="itemTemplate" data-oj-as="item">
   *   &lt;/template>
   * &lt;/oj-list-view></code></pre>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td><kbd>data-oj-clickthrough</kbd></td>
   *       <td><p>Specify on any element inside an item where you want to control whether ListView should perform actions triggered by
   *           a click event originating from the element or one of its descendants.</p>
   *           <p>For example, if you specify this attribute with a value of "disabled" on a button inside an item, then ListView
   *           will not select or trigger itemAction event to be fired when user clicks on the button. Expand/collapse will also
   *           be ignored if the button is inside the group header.</p>
   *           <p>Note that the currentItem will still be updated to the item that the user clicked on.</p>
   *       </td>
   *       <td>
   *         <pre class="prettyprint"><code>&lt;oj-list-view id="listView">
   *   &lt;template slot="itemTemplate">
   *     &lt;oj-button data-oj-clickthrough="disabled">&lt;/oj-button
   *   &lt;/template>
   * &lt;/oj-list-view></code></pre>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h3 id="suggestion-items-section">
   *   Suggestion Items
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#suggestion-items-section"></a>
   * </h3>
   *
   * <p>If <a href="ItemMetadata.html">ItemMetadata</a> returned by the DataProvider contains suggestion field, ListView will apply special visual to those
   *    items. The DataProvider must ensure the suggestion items are the first items returned by the initial fetchFirst call. Suggestion items are only supported
   *    when display is 'item'.  Applications should not allow users to reorder suggestion items.</p>
   */
  // --------------------------------------------------- oj.ojListView Styling Start -----------------------------------------------------------
  // ---------------- oj-clickthrough-disabled --------------
  /**
   * Use on any element inside an item where you do not want ListView to process the click event.
   * @ojstyleclass oj-clickthrough-disabled
   * @ojdisplayname Click Disabled
   * @ojstyleselector oj-list-view, oj-list-view *
   * @ojdeprecated {since: '10.0.0', description: 'Specify data-oj-clickthrough attribute with value disabled instead.'}
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-clickthrough-disabled">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-focus-highlight --------------
  /**
   * Under normal circumstances this class is applied automatically.
   * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
   * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
   * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
   * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
   * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
   * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
   * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
   * @ojstyleclass oj-focus-highlight
   * @ojdisplayname Focus Styling
   * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-focus-highlight">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-full-width --------------
  /**
   * Use when ListView occupies the entire width of the page. Removes left and right borders in card-layout mode and adjust positioning of cards to improve visual experience.
   * @ojstyleclass oj-full-width
   * @ojdisplayname Full Width
   * @ojdeprecated {since: '10.0.0', description: 'Use oj-listview-full-width instead.'}
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-full-width">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-group-header-sm --------------
  /**
   * Use to style group headers as small size group headers according to the current theme.
   * @ojstyleclass oj-group-header-sm
   * @ojdisplayname Small Group Header
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-group-header-sm">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-group-header-md --------------
  /**
   * Use to style group headers as medium size group headers according to the current theme.
   * @ojstyleclass oj-group-header-md
   * @ojdisplayname Medium Group Header
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-group-header-md">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-group-header-lg --------------
  /**
   * Use to style group headers as large size group headers according to the current theme.
   * @ojstyleclass oj-group-header-lg
   * @ojdisplayname Large Group Header
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-group-header-lg">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-listview-card-layout --------------
  /**
   * Shows items as cards and lay them out in a grid.
   * @ojstyleclass oj-listview-card-layout
   * @ojdisplayname Card Layout
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-listview-card-layout">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-listview-drag-handle --------------
  /**
   * Use to show a drag handle in the item to facilitate item reordering or drag and drop.
   * @ojstyleclass oj-listview-drag-handle
   * @ojdisplayname Drag Handle
   * @ojstyleselector oj-list-view *
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view>
   *   &lt;template slot="itemTemplate" data-oj-as="item">
   *     ...
   *     &lt;div class="oj-flex-bar-end oj-sm-align-items-center">
   *      &lt;div role="button" tabindex="0" class="oj-flex-item oj-listview-drag-handle">
   *      &lt;/div>
   *     &lt;/div>
   *   &lt;/template>
   * &lt;/oj-list-view>
   */
  // ---------------- oj-listview-drill-icon --------------
  /**
   * Use to show a drill-to-detail icon in the item.
   * @ojstyleclass oj-listview-drill-icon
   * @ojdisplayname Drill Icon
   * @ojstyleselector oj-list-view *
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-listview-card-layout">
   *   &lt;template slot="itemTemplate" data-oj-as="item">
   *     ...
   *     &lt;div class="oj-flex-bar-end oj-sm-align-items-center">
   *      &lt;div role="presentation" class="oj-flex-item oj-fwk-icon oj-listview-drill-icon">
   *      &lt;/div>
   *     &lt;/div>
   *   &lt;/template>
   * &lt;/oj-list-view>
   */
  // ---------------- oj-listview-full-width --------------
  /**
   * Use when ListView occupies the entire width of the page. Removes left and right borders in card-layout mode and adjust positioning of cards to improve visual experience.
   * @ojstyleclass oj-listview-full-width
   * @ojdisplayname Full Width
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-listview-full-width">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  // ---------------- oj-listview-item-layout --------------
  /**
   * Use when the page author overrides the default styling on the item root element and wants to apply the item style on some other element.
   * @ojstyleclass oj-listview-item-layout
   * @ojdisplayname Item Layout
   * @ojstyleselector oj-list-view *
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="">
   *   &lt;template slot="itemTemplate" data-oj-as="item">
   *     &lt;div class="oj-listview-item-layout">
   *     ...
   *     &lt;/div>
   *   &lt;/template>
   * &lt;/oj-list-view>
   */
  // ---------------- oj-listview-item-padding-off --------------
  /**
   * Use when the page author wants to remove the default padding around the item.  This is mostly used in the case where the component used inside the
   * itemTemplate already supply its own padding (ex: oj-list-item-layout), and therefore the default padding provided by ListView should be remove.
   * @ojstyleclass oj-listview-item-padding-off
   * @ojdisplayname Item Padding Off
   * @ojstyleselector oj-list-view
   * @memberof oj.ojListView
   * @ojtsexample
   * &lt;oj-list-view class="oj-listview-item-padding-off">
   *   &lt;!-- Content -->
   * &lt;/oj-list-view>
   */
  /**
   * @ojstylevariableset oj-list-view-css-set1
   * @ojdisplayname List view item padding CSS
   * @ojstylevariable oj-list-view-item-padding-horizontal {description: "List view horizontal item padding",formats: ["length"], help: "#oj-list-view-css-set1"}
   * @memberof oj.ojListView
   */
  /**
   * CSS variables that specify list view group header styles
   * @ojstylevariableset oj-list-view-css-set2
   * @ojdisplayname List view group header CSS
   * @ojstylevariable oj-list-view-group-header-bg-color {description: "List view group header background color", formats: ["color"], help: "#oj-list-view-css-set2"}
   * @ojstylevariable oj-list-view-group-header-bg-color-sticky {description: "List view group header sticky background color", formats: ["color"], help: "#oj-list-view-css-set2"}
   * @ojstylevariable oj-list-view-group-header-font-weight {description: "List view group header font weight", formats: ["font_weight"], help: "#oj-list-view-css-set2"}
   * @ojstylevariable oj-list-view-group-header-font-size {description: "List view group header font size", formats: ["length"], help: "#oj-list-view-css-set2"}
   * @ojstylevariable oj-list-view-group-header-line-height {description: "List view group header horizontal line height", formats: ["number"], help: "#oj-list-view-css-set2"}
   * @memberof oj.ojListView
   */
  // --------------------------------------------------- oj.listView Styling End -----------------------------------------------------------

  oj.__registerWidget('oj.ojListView', $.oj.baseComponent, {
    widgetEventPrefix: 'oj',
    options: {
      /**
       * An alias for the current item when referenced inside the item template. This can be especially useful
       * if oj-bind-for-each element is used inside the item template since it has its own scope of data access.
       *
       * @ojshortdesc Specifies the alias for the current item when referenced inside the item template.
       *
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojListView
       * @type {string}
       * @default ''
       * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">as</code> attribute specified:</caption>
       * &lt;oj-list-view as='item'>
       *   &lt;template slot='itemTemplate'>
       *     &lt;p>&lt;oj-bind-text value='[[item.data.name]]'>&lt;/oj-bind-text>&lt;/p>
       *   &lt;/template>
       * &lt;/oj-list-view>
       */
      as: '',
      /**
       * The item that currently have keyboard focus.  Note that if current item
       * is set to an item that is not available in the view (either not fetched in high-water mark scrolling case or
       * hidden inside a collapsed parent node), then the value is not applied.
       *
       * @ojshortdesc Specifies the key of the item that should have keyboard focus. See the Help documentation for more information.
       * @expose
       * @public
       * @instance
       * @memberof! oj.ojListView
       * @type {any}
       * @ojsignature {target:"Type", value:"K"}
       * @default null
       * @ojwriteback
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">current-item</code> attribute specified:</caption>
       * &lt;oj-list-view current-item='{{myCurrentItem}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">currentItem</code> property after initialization:</caption>
       * // getter
       * var currentItemValue = myListView.currentItem;
       *
       * // setter
       * myListView.currentItem = "item2";
       */
      currentItem: null,
      /**
       * The data source for ListView.  Must be of type oj.TableDataSource, oj.TreeDataSource, DataProvider
       * See the data source section in the introduction for out of the box data source types.
       * If the data attribute is not specified, the child elements are used as content.  If there's no
       * content specified, then an empty list is rendered.
       *
       * @ojshortdesc Specifies the data for the list. See the Help documentation for more information.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {Object}
       * @default null
       * @ojwebelementstatus {type: "unsupported", since: "13.0.0",
       *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">data</code> attribute specified:</caption>
       * &lt;oj-list-view data='{{myDataSource}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">data</code> property after initialization:</caption>
       * // getter
       * var dataValue = myListView.data;
       *
       * // setter
       * myListView.data = myDataSource;
       * @ojsignature [{target: "Type", value: "DataProvider<K, D>"},
       *               {target: "Type", value: "oj.TableDataSource|oj.TreeDataSource|DataProvider", consumedBy:"js"}]
       */
      data: null,
      /**
       * Whether to display items as list items or as cards.
       *
       * @ojshortdesc Specifies how the items should be displayed.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {string}
       * @default "list"
       * @ojvalue {string} "list" Display items as list items.
       * @ojvalue {string} "card" Display items as cards.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">display</code> attribute specified:</caption>
       * &lt;oj-list-view display='card'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
       * // getter
       * var displayValue = myListView.display;
       *
       * // setter
       * myListView.display = 'card';
       */
      display: 'list',
      /**
       * Enable drag and drop functionality.
       * Note the ojlistviewdnd module must be imported in order to use the dnd functionality.<br><br>
       * JET provides support for HTML5 Drag and Drop events.  Please refer to {@link https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop third party documentation}
       * on HTML5 Drag and Drop to learn how to use it.
       *
       * @ojshortdesc Customizes the drag and drop functionality. See the Help documentation for more information.
       * @expose
       * @memberof! oj.ojListView
       * @type {Object}
       * @instance
       */
      dnd: {
        /**
         * Enables and customizes the drag functionality.
         *
         * @ojshortdesc Customizes the drag functionality.
         * @expose
         * @name dnd.drag
         * @memberof! oj.ojListView
         * @instance
         * @type {Object}
         * @ojsignature { target: "Type",
         *                value: "?"}
         */
        drag: null,
        /**
         * @ojshortdesc Customizes the drop functionality.
         * @expose
         * @name dnd.drop
         * @memberof! oj.ojListView
         * @instance
         * @type {Object}
         * @ojsignature { target: "Type", value: "?"}
         */
        drop: null,
        /**
         * The reorder option contains a subset of options for reordering items.
         *
         * @ojshortdesc Customizes the item reordering functionality.
         * @expose
         * @name dnd.reorder
         * @memberof! oj.ojListView
         * @instance
         * @type {Object}
         * @ojsignature { target: "Type", value: "?"}
         */
        reorder: {
          /**
           * Enable or disable reordering the items within the same listview using drag and drop.<br><br>
           * Specify 'enabled' to enable reordering.  Setting the value 'disabled' or setting the <code class="prettyprint">"dnd"</code> property
           * to <code class="prettyprint">null</code> (or omitting it), disables reordering support.
           *
           * @ojshortdesc Specify the item reordering functionality. See the Help documentation for more information.
           * @expose
           * @name dnd.reorder.items
           * @memberof! oj.ojListView
           * @instance
           * @type {string}
           * @ojvalue {string} "enabled" Item reordering is enabled.
           * @ojvalue {string} "disabled" Item reordering is disabled.
           * @default "disabled"
           *
           * @example <caption>Initialize the ListView with the <code class="prettyprint">reorder</code> attribute specified:</caption>
           * &lt;oj-list-view dnd.reorder.items='enabled'>&lt;/oj-list-view>
           *
           * @example <caption>Get or set the <code class="prettyprint">reorder</code> property after initialization:</caption>
           * // getter
           * var reorderValue = myListView.dnd.reorder.items;
           *
           * // setter
           * myListView.dnd.reorder.items = 'enabled';
           */
          items: 'disabled'
        }
      },
      /**
       * Changes the expand and collapse operations on ListView.  If "none" is specified, then
       * the current expanded state is fixed and user cannot expand or collapse an item.
       *
       * @ojshortdesc Specifies whether expand or collapse operations are allowed.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {string}
       * @default "collapsible"
       * @ojvalue {string} "collapsible" Group item can be expanded or collapsed by user.
       * @ojvalue {string} "none" The expand state of a group item cannot be changed by user.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">drill-mode</code> attribute specified:</caption>
       * &lt;oj-list-view drill-mode='none'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">drillMode</code> property after initialization:</caption>
       * // getter
       * var drillModeValue = myListView.drillMode;
       *
       * // setter
       * myListView.drillMode = 'none';
       */
      drillMode: 'collapsible',
      /**
       * Specifies the key set containing the keys of the items that should be expanded.
       *
       * Use the <a href="ExpandedKeySet.html">ExpandedKeySet</a> class to specify items to expand.
       * Use the <a href="ExpandAllKeySet.html">ExpandAllKeySet</a> class to expand all items.
       *
       * @ojshortdesc Specifies the key set containing the keys of the items that should be expanded. See the Help documentation for more information.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @default new ExpandedKeySet();
       * @type {KeySet}
       * @ojsignature {target:"Type", value:"oj.KeySet<K>"}
       *
       * @ojwriteback
       *
       * @example <caption>Initialize the ListView with specific items expanded:</caption>
       * myListView.expanded = new ExpandedKeySet(['item1', 'item2']);
       *
       * @example <caption>Initialize the ListView with all items expanded:</caption>
       * myListView.expanded = new ExpandAllKeySet();
       */
      expanded: new _ojListViewExpandedKeySet(),
      /**
       * Gets the key and data of the first selected item.  The first selected item is defined as the first
       * key returned by the <a href="#selection">selection</a> property.  The value of this property contains:
       * <ul>
       * <li>key - the key of the first selected item.</li>
       * <li>data - the data of the first selected item.  If the selected item is not locally available, this will
       *        be null.  If the <a href="#data">data</a> property is not set and that static HTML element is used
       *        as data, then this will be the item element.</li>
       * </ul>
       * If no items are selected then this property will return an object with both key and data properties set to null.
       *
       * @expose
       * @ojshortdesc Specifies the key and data of the first selected item. See the Help documentation for more information.
       * @memberof! oj.ojListView
       * @instance
       * @default {'key': null, 'data': null}
       * @type {Object}
       * @ojsignature {target:"Type", value:"CommonTypes.ItemContext<K,D>", jsdocOverride:true}
       *
       * @ojwriteback
       * @readonly
       *
       * @example <caption>Get the data of the first selected item:</caption>
       * // getter
       * var firstSelectedItemValue = myListView.firstSelectedItem;
       */
      firstSelectedItem: { key: null, data: null },
      /**
       * The gridlines option contains a subset of options for gridlines.
       *
       * @ojshortdesc Customizes the functionality of how gridlines are shown in various parts of the list.
       * @expose
       * @memberof! oj.ojListView
       * @type {Object}
       * @instance
       */
      gridlines: {
        /**
         * Specifies whether the horizontal grid lines should be visible.  Note this attribute has no effect when ListView is in card display mode.
         * <p>The default value varies by theme.
         *
         * @ojshortdesc Specifies whether the grid lines should be visible.
         * @expose
         * @name gridlines.item
         * @memberof! oj.ojListView
         * @instance
         * @default "visible"
         * @type {string}
         * @ojvalue {string} "visible" The horizontal gridlines are visible.
         * @ojvalue {string} "visibleExceptLast" The horizontal gridlines are visible, except for the last item.  Note this will not have an effect for themes that renders a bottom border for the component.
         * @ojvalue {string} "hidden" The horizontal gridlines are hidden.
         *
         * @example <caption>Initialize the ListView with the <code class="prettyprint">gridlines</code> attribute specified:</caption>
         * &lt;oj-list-view gridlines.item='visible'>&lt;/oj-list-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">gridlines</code> property after initialization:</caption>
         * // getter
         * var gridlinesValue = myListView.gridlines.item;
         *
         * // setter
         * myListView.gridlines.item = 'visible';
         *
         */
        item: 'visible'
      },
      /**
       * Specifies how the group header should be positioned.  If "sticky" is specified, then the group header
       * is fixed at the top of the ListView as the user scrolls.
       *
       * @ojshortdesc Specifies whether group header should stick to the top as user scrolls.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @default "sticky"
       * @type {string}
       * @ojvalue {string} "static" The group header position updates as user scrolls.
       * @ojvalue {string} "sticky" The group header is fixed at the top when user scrolls.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">group-header-position</code> attribute specified:</caption>
       * &lt;oj-list-view group-header-position='static'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">groupHeaderPosition</code> property after initialization:</caption>
       * // getter
       * var groupHeaderPositionValue = myListView.groupHeaderPosition;
       *
       * // setter
       * myListView.groupHeaderPosition = 'static';
       */
      groupHeaderPosition: 'sticky',
      /**
       * The item option contains a subset of options for items.
       *
       * @ojshortdesc Customizes the functionality of each item on the list.
       * @expose
       * @memberof! oj.ojListView
       * @type {Object}
       * @instance
       */
      item: {
        /**
         * @typedef {Object} oj.ojListView.ItemContext
         * @property {DataProvider<K, D>} datasource the data source/data provider
         * @property {number} index the zero based index of the item, relative to its parent during initial rendering.  Note the index is not updated in response to item additions and removals.
         * @property {K} key the key of the item
         * @property {D} data the data object of the item
         * @property {oj.ItemMetadata<K>} metadata the metadata object of the item
         * @property {Element} parentElement the item DOM element
         * @property {number=} depth the depth of the item
         * @property {K=} parentKey the key of the parent item
         * @property {boolean=} leaf whether the item is a leaf
         * @ojsignature [{target:"Type", value:"<K,D>", for:"genericTypeParameters"}]
         */
        /**
         * The knockout template used to render the content of the item.
         *
         * This attribute is only exposed via the <code class="prettyprint">ojComponent</code> binding, and is not a
         * component option.
         *
         * @ojbindingonly
         * @name item.template
         * @memberof! oj.ojListView
         * @instance
         * @type {string|null}
         * @default null
         *
         * @example <caption>Specify the <code class="prettyprint">template</code> when initializing ListView:</caption>
         * // set the template
         * &lt;ul id="listview" data-bind="ojComponent: {component: 'ojListView', data: dataSource, item: {template: 'my_template'}}"&gt;&lt;/ul&gt;
         */
        /**
         * Whether the item is focusable.  An item that is not focusable cannot be clicked on or navigated to.
         * See <a href="#context-section">itemContext</a> in the introduction to see the object passed into the focusable function.
         *
         * @ojshortdesc Specifies whether the item can receive keyboard focus. See the Help documentation for more information.
         * @expose
         * @name item.focusable
         * @memberof! oj.ojListView
         * @instance
         * @type {boolean|function(Object):boolean}
         * @ojsignature { target: "Type",
         *                value: "?((param0: oj.ojListView.ItemContext<K,D>) => boolean)|boolean",
         *                jsdocOverride: true}
         *  @ojdeprecated {since: '13.0.0', description: 'Not accessible by screen reader.'}
         *  @default true
         *
         * @example <caption>Initialize the ListView with the <code class="prettyprint">focusable</code> attribute specified:</caption>
         * &lt;oj-list-view item.focusable='{{myFocusableFunc}}'>&lt;/oj-list-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">focusable</code> property after initialization:</caption>
         * // getter
         * var focusable = myListView.item.focusable;
         *
         * // setter
         * myListView.item.focusable = myFocusableFunc;
         */
        focusable: true,
        /**
         * The renderer function that renders the content of the item. See <a href="#context-section">itemContext</a>
         * in the introduction to see the object passed into the renderer function.
         * The function should return one of the following:
         * <ul>
         *   <li>An Object with the following property:
         *     <ul><li>insert: HTMLElement | string - A string or a DOM element of the content inside the item.</li></ul>
         *   </li>
         *   <li>undefined: If the developer chooses to manipulate the list element directly, the function should return undefined.</li>
         * </ul>
         * If no renderer is specified, ListView will treat the data as a string.
         *
         * @ojshortdesc Specifies the renderer for the item. See the Help documentation for more information.
         * @expose
         * @name item.renderer
         * @memberof! oj.ojListView
         * @instance
         * @type {null|function(Object):Object}
         * @ojsignature { target: "Type",
         *                value: "?((param0: oj.ojListView.ItemContext<K,D>) => {insert: Element|string}|undefined)|null",
         *                jsdocOverride: true}
         * @default null
         *
         * @example <caption>Initialize the ListView with the <code class="prettyprint">renderer</code> attribute specified:</caption>
         * &lt;oj-list-view item.renderer='{{myRendererFunc}}'>&lt;/oj-list-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">renderer</code> property after initialization:</caption>
         * // getter
         * var renderer = myListView.item.renderer;
         *
         * // setter
         * myListView.item.renderer = myRendererFunc;
         */
        renderer: null,
        /**
         * Whether the item is selectable.  Note that if selectionMode is set to "none" this option is ignored.  In addition,
         * if focusable is set to false, then the selectable option is automatically overridden and set to false also.
         * See <a href="#context-section">itemContext</a> in the introduction to see the object passed into the selectable function.
         *
         * @ojshortdesc Specifies whether the item can be selected. See the Help documentation for more information.
         * @expose
         * @name item.selectable
         * @memberof! oj.ojListView
         * @instance
         * @type {boolean|function(Object):boolean}
         * @ojsignature { target: "Type",
         *                value: "?((param0: oj.ojListView.ItemContext<K,D>) => boolean)|boolean",
         *                jsdocOverride: true}
         * @default true
         *
         * @example <caption>Initialize the ListView with the <code class="prettyprint">selectable</code> attribute specified:</caption>
         * &lt;oj-list-view item.selectable='{{mySelectableFunc}}'>&lt;/oj-list-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">selectable</code> property after initialization:</caption>
         * // getter
         * var selectable = myListView.item.selectable;
         *
         * // setter
         * myListView.item.selectable = mySelectableFunc;
         */
        selectable: true
      },
      /**
       * Specifies the behavior when ListView needs to scroll to a position based on an item key.  This includes the case where 1) a value of
       * scrollPosition attribute is specified with a key property, 2) ListView scrolls to the selection anchor after a refresh has occurred.
       *
       * @ojshortdesc Specifies the behavior when ListView needs to scroll to a position based on an item key.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {string|null}
       * @default "auto"
       * @ojvalue {string} "auto" The behavior is determined by the component.  By default the behavior is the same as "capability" except
       *                          when legacy TableDataSource/TreeDataSource is used, in which case the behavior is the same as "always".
       * @ojvalue {string} "capability" ListView will only scroll to a position based on an item key if associated DataProvider
       *                                supports 'immediate' iterationSpeed for 'fetchFirst' capability.
       * @ojvalue {string} "always" ListView will scroll to a position based on an item key as long as the key is valid.
       * @ojvalue {string} "never" ListView will not change the scroll position if the request is based on an item key.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-by-key</code> attribute specified:</caption>
       * &lt;oj-list-view scroll-to-key='never'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">scrollToKey</code> property after initialization:</caption>
       * // getter
       * var scrollToKeyBehavior = myListView.scrollToKey;
       *
       * // setter
       * myListView.scrollToKey = 'never';
       */
      scrollToKey: 'auto',
      /**
       * Specifies the mechanism used to scroll the data inside the list view. Possible values are: "auto", "loadMoreOnScroll", and "loadAll".
       * When "loadMoreOnScroll" is specified, additional data is fetched when the user scrolls to the bottom of the ListView.
       * Note that currently this option is only available when non-hierarchical DataProvider is used.
       * When "loadAll" is specified, ListView will fetch all the data when it is initially rendered.
       * If you are using Paging Control with the ListView, please note that "loadMoreOnScroll" scroll-policy is not compatible with
       * Paging Control "loadMore" mode.
       *
       * @ojshortdesc Specifies how data are fetched as user scrolls down the list.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {string|null}
       * @default "auto"
       * @ojvalue {string} "auto" The behavior is determined by the component.  By default the behavior is the same as "loadMoreOnScroll" except
       *                          when legacy TableDataSource is used, in which case the behavior is the same as "loadAll".
       * @ojvalue {string} "loadAll" Fetch and render all data.
       * @ojvalue {string} "loadMoreOnScroll" Additional data is fetched when the user scrolls towards the bottom of the ListView.
       *                    <br/>Not compatible when used with Paging Control "loadMore" mode.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-policy</code> attribute specified:</caption>
       * &lt;oj-list-view scroll-policy='loadMoreOnScroll'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">scrollPolicy</code> property after initialization:</caption>
       * // getter
       * var scrollPolicyValue = myListView.scrollPolicy;
       *
       * // setter
       * myListView.scrollPolicy = 'loadMoreOnScroll';
       */
      scrollPolicy: 'auto',
      /**
       * scrollPolicy options.
       * <p>
       * The following options are supported:
       * <ul>
       *   <li>fetchSize: The number of items fetched each time when scroll to the end.</li>
       *   <li>maxCount: Maximum rows which will be displayed before fetching more rows will be stopped.</li>
       *   <li>scroller: The element which listview uses to determine the scroll position as well as the maximum scroll position where scroll to the end will trigger a fetch.  If not specified then the widget element of listview is used.</li>
       * </ul>
       * When scrollPolicy is loadMoreOnScroll, the next block of rows is fetched
       * when the user scrolls to the end of the list/scroller. The fetchSize option
       * determines how many rows are fetched in each block.
       * Note that currently this option is only available when non-hierarchical DataProvider or TableDataSource is used.
       *
       * @ojshortdesc Specifies fetch options for scrolling behaviors that trigger data fetches. See the Help documentation for more information.
       * @expose
       * @instance
       * @memberof! oj.ojListView
       * @type {Object.<string, number>|null}
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-policy-options</code> attribute specified:</caption>
       * &lt;oj-list-view scroll-policy-options.fetch-size='30'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">scroll-policy-options</code> attribute after initialization:</caption>
       * // getter
       * var fetchSizeValue = myListView.scrollPolicyOptions.fetchSize;
       *
       * // setter
       * myListView.scrollPolicyOptions.fetchSize = 30;

       * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-policy-options</code> attribute specified:</caption>
       * &lt;!-- Using dot notation -->
       * &lt;oj-list-view scroll-policy-options.fetch-size='30' scroll-policy-options.max-count='1000'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">scrollPolicyOptions</code> property after initialization:</caption>
       * // Get one
       * var fetchSizeValue = myListView.scrollPolicyOptions.fetchSize;
       *
       * // Get all
       * var scrollPolicyOptionsValues = myListView.scrollPolicyOptions;
       *
       * // Set one, leaving the others intact
       * myListView.setProperty('scrollPolicyOptions.fetchSize', 30);
       *
       * // Set all.
       * myListView.scrollPolicyOptions = {fetchSize: 30, maxCount: 1000};
       */
      scrollPolicyOptions: { fetchSize: 25, maxCount: 500 },
      /**
       * The current scroll position of ListView. The scroll position is updated when either the vertical or horizontal scroll position
       * (or its scroller, as specified in scrollPolicyOptions.scroller) has changed.  The value contains the x and y scroll position,
       * the index and key information of the item closest to the top of the viewport, as well as horizontal and vertical offset from the
       * position of the item to the actual scroll position.
       * <p>
       * The default value contains just the scroll position.  Once data is fetched the 'index' and 'key' sub-properties will be added.
       * If there is no data then the 'index' and 'key' sub-properties will not be available.
       * </p>
       * <p>
       * When setting the scrollPosition property, applications can change any combination of the sub-properties.
       * If multiple sub-properties are set at once they will be used in key, index, pixel order where the latter serves as hints.
       * If offsetX or offsetY are specified, they will be used to adjust the scroll position from the position where the key or index
       * of the item is located.
       * </p>
       * <p>
       * If a sparse object is set the other sub-properties will be populated and updated once ListView has scrolled to that position.
       * </p>
       * <p>
       * Also, if <a href="#scrollPolicy">scrollPolicy</a> is set to 'loadMoreOnScroll' and the scrollPosition is set to a value outside
       * of the currently rendered region, then ListView will attempt to fetch until the specified scrollPosition is satisfied or the end
       * is reached (either at max count or there's no more items to fetch), in which case the scroll position will remain at the end.
       * The only exception to this is when the key specified does not exists and a DataProvider is specified for <a href="#data">data</a>,
       * then the scroll position will not change (unless other sub-properties like index or x/y are specified as well).
       * </p>
       * Lastly, when a re-rendered is triggered by a <a href="DataProviderRefreshEvent.html">refresh event</a> from the DataProvider,
       * or if the value for <a href="#data">data</a> attribute has changed, then the scrollPosition will be adjusted such that the selection
       * anchor (typically the last item selected by the user) prior to refresh will appear at the top of the viewport after refresh.  If
       * selection is disabled or if there is no selected items, then the scrollPosition will remain at the top.
       * </p>
       *
       * @ojshortdesc Specifies the current scroll position of the list. See the Help documentation for more information.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {Object}
       * @default {"x": 0, "y": 0}
       * @property {number=} x The horizontal position in pixels.
       * @property {number=} y The vertical position in pixels.
       * @property {number=} index The zero-based index of the item.  If <a href="#scrollPolicy">scrollPolicy</a> is set to 'loadMoreOnScroll'
       * and the index is greater than maxCount set in <a href="#scrollPolicyOptions">scrollPolicyOptions</a>, then it will scroll and fetch
       * until the end of the list is reached and there's no more items to fetch.
       * @property {any=} parent The key of the parent where the index is relative to.  If not specified, then the root is assumed
       * @property {any=} key The key of the item.  If DataProvider is used for <a href="#data">data</a> and the key does not exists in the
       * DataProvider, then the value is ignored.  If DataProvider is not used then ListView will fetch and scroll until the item is found
       * or the end of the list is reached and there's no more items to fetch.
       * @property {number=} offsetX The horizontal offset in pixels relative to the item identified by key/index.
       * @property {number=} offsetY The vertical offset in pixels relative to the item identified by key/index.
       *
       * @ojsignature [{target:"Type", value:"K", for:"parent"},
       *               {target:"type", value:"K", for:"key"}]
       * @ojwriteback
       * @example <caption>Initialize the ListView with the <code class="prettyprint">scroll-position</code> attribute specified:</caption>
       * &lt;!-- Using dot notation -->
       * &lt;oj-list-view scroll-position.index='10'>&lt;/oj-list-view>
       *
       * &lt;!-- Using JSON notation -->
       * &lt;oj-list-view scroll-position='{"index": 10}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">scrollPosition</code> property after initialization:</caption>
       * // Get one
       * var scrollPositionValue = myListView.scrollPosition.index;
       *
       * // Set one, leaving the others intact
       * myListView.setProperty('scrollPosition.index', 10);
       *
       * // Get all
       * var scrollPositionValues = myListView.scrollPosition;
       *
       * // Set all.  Those not listed will be lost until the scroll completes and the remaining fields are populated.
       * myListView.scrollPosition = {x: 0, y: 150};
       */
      scrollPosition: { x: 0, y: 0 },
      /**
       * The vertical scroll position of ListView.
       *
       * @ignore
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {number}
       * @default 0
       *
       * @example <caption>Initialize the list view to a specific scroll position:</caption>
       * $( ".selector" ).ojListView({ "scrollTop": 100 });
       */
      scrollTop: 0,
      /**
       * The current selected items in the ListView. An empty KeySet indicates nothing is selected.
       * Note that property change event for the deprecated selection property will still be fire when
       * selected property has changed. In addition, <a href="AllKeySetImpl.html">AllKeySetImpl</a> set
       * can be used to represent select all state. In this case, the value for selection would have an
       * 'inverted' property set to true, and would contain the keys of the items that are not selected.
       *
       * @ojshortdesc Specifies the keys of the current selected items. See the Help documentation for more information.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @default new KeySetImpl();
       * @type {KeySet}
       * @ojsignature {target:"Type", value:"oj.KeySet<K>"}
       * @ojwriteback
       * @ojeventgroup common
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">selected</code> attribute specified:</caption>
       * &lt;oj-list-view selected='{{mySelectedItemsKeySet}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">selected</code> property after initialization:</caption>
       * // getter
       * var selectedValue = myListView.selected;
       *
       * // setter
       * myListView.selected = ['item1', 'item2', 'item3'];
       */
      selected: new ojkeyset.KeySetImpl(),
      /**
       * The current selections in the ListView. An empty array indicates nothing is selected.
       *
       * @ojshortdesc Specifies the current selections in the list. See the Help documentation for more information.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {Array.<any>}
       * @ojsignature {target:"Type", value:"Array<K>"}
       * @default []
       * @ojwriteback
       * @ojdeprecated {since: '7.0.0', description: 'Use selected attribute instead.'}
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">selection</code> attribute specified:</caption>
       * &lt;oj-list-view selection='{{mySelection}}'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">selection</code> property after initialization:</caption>
       * // getter
       * var selectionValue = myListView.selection;
       *
       * // setter
       * myListView.selection = ['item1', 'item2', 'item3'];
       */
      selection: [],
      /**
       * <p>The type of selection behavior that is enabled on the ListView. This attribute controls the number of selections that can be made via selection gestures at any given time.
       *
       * <p>If <code class="prettyprint">single</code> or <code class="prettyprint">multiple</code> is specified, selection gestures will be enabled, and the ListView's selection styling will be applied to all items specified by the <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes.
       * If <code class="prettyprint">none</code> is specified, selection gestures will be disabled, and the ListView's selection styling will not be applied to any items specified by the <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes.
       *
       * <p>Changing the value of this attribute will not affect the value of the <a href="#selection">selection</a> or <a href="#selected">selected</a> attributes.
       *
       * @ojshortdesc Specifies the selection mode.
       * @expose
       * @memberof! oj.ojListView
       * @instance
       * @type {string}
       * @default "none"
       * @ojvalue {string} "none" Selection is disabled.
       * @ojvalue {string} "single" Only a single item can be selected at a time.
       * @ojvalue {string} "multiple" Multiple items can be selected at the same time.
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">selection-mode</code> attribute specified:</caption>
       * &lt;oj-list-view selection-mode='multiple'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">selectionMode</code> property after initialization:</caption>
       * // getter
       * var selectionModeValue = myListView.selectionMode;
       *
       * // setter
       * myListView.selectionMode = 'multiple';
       */
      selectionMode: 'none',
      /**
       * <p>Specifies whether selection is required on the ListView. This attribute will only take effect when selection is enabled and at least
       * one selectable item is present. When <code class="prettyprint">true</code>, the ListView will ensure that at least one valid item is
       * selected at all times. If no items are specified by the <a href="#selection">selection</a> or <a href="#selected">selected</a> attributes,
       * the first selectable item in the ListView will be added to the selection state during initial render. Additionally, selection gestures that
       * would otherwise leave the ListView with no selected items will be disabled.
       *
       * <p>When <code class="prettyprint">true</code>, the ListView will also attempt to validate all items specified by the
       * <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes. If any items specified are not immediately
       * available, the ListView's underlying <a href="DataProvider.html">DataProvider</a> will be queried. This will only occur if the
       * data provider supports <a href="DataProvider.html#getCapability">getCapability</a>, and returns a
       * <a href="FetchByKeysCapability.html#implementation">fetchByKeys capability implementation</a> of <code class="prettyprint">lookup</code>.
       * Any items that fail this validation process will be removed from the <a href="#selection">selection</a> and <a href="#selected">selected</a>
       * attributes. This guarantees that the ListView's <a href="#firstSelectedItem">firstSelectedItem</a> attribute is populated at all times.
       *
       * <p>See <a href="#selectionMode">selectionMode</a> for information on how to enable or disable selection on the ListView.
       * <p>See <a href="#item.selectable">item.selectable</a> for information on how to enable or disable selection for individual items.
       *
       * @ojshortdesc Specifies whether selection is required on the ListView.
       * @expose
       *
       * @memberof! oj.ojListView
       * @instance
       * @type {boolean}
       * @default false
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">selection-required</code> attribute specified:</caption>
       * &lt;oj-list-view selection-required='true'>&lt;/oj-list-view>
       *
       * @example <caption>Get or set the <code class="prettyprint">selectionRequired</code> property after initialization:</caption>
       * // getter
       * var selectionRequiredValue = myListView.selectionRequired;
       *
       * // setter
       * myListView.selectionRequired = true;
       */
      selectionRequired: false,
      /**
       * Triggered when the default animation of a particular action is about to start.  The default animation can be cancelled by calling event.preventDefault.
       *
       * @ojshortdesc Triggered when the default animation of a particular action is about to start.
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {string} action the action that triggers the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
       * @property {Element} element the target of animation.
       * @property {function():void} endCallback if the event listener calls event.preventDefault to cancel the default animation, it must call the endCallback function when it finishes its own animation handling and when any custom animation ends.
       */
      animateStart: null,
      /**
       * Triggered when the default animation of a particular action has ended. Note this event will not be triggered if application cancelled the default animation on animateStart.
       *
       * @ojshortdesc Triggered when the default animation of a particular action has ended.
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {string} action the action that triggered the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
       * @property {Element} element the target of animation.
       */
      animateEnd: null,
      /**
       * Triggered before the current item is changed via the <code class="prettyprint">current</code> option or via the UI.
       *
       * @ojshortdesc Triggered before the current item is changed.
       * @ojcancelable
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {any} previousKey the key of the previous item
       * @property {Element} previousItem the previous item
       * @property {any} key the key of the new current item
       * @property {Element} item the new current item
       * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
       *               {target:"Type", value:"K", for:"previousKey"},
       *               {target:"Type", value:"K", for:"key"}]
       */
      beforeCurrentItem: null,
      /**
       * Triggered before an item is expanded via the <code class="prettyprint">expanded</code> option,
       * the <code class="prettyprint">expand</code> method, or via the UI.
       *
       * @ojshortdesc Triggered before an item is expanded.
       * @ojcancelable
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {any} key the key of the item to be expanded
       * @property {Element} item the item to be expanded
       * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
       *               {target:"Type", value:"K", for:"key"}]
       */
      beforeExpand: null,
      /**
       * Triggered before an item is collapsed via the <code class="prettyprint">expanded</code> option,
       * the <code class="prettyprint">collapse</code> method, or via the UI.
       *
       * @ojshortdesc Triggered before an item is collapsed.
       * @ojcancelable
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {any} key the key of the item to be collapsed
       * @property {Element} item the item to be collapsed
       * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
       *               {target:"Type", value:"K", for:"key"}]
       */
      beforeCollapse: null,
      /**
       * Triggered after an item has been collapsed via the <code class="prettyprint">expanded</code> option or via the UI.
       * Note if the collapse is triggered by updating the expanded option, applications should avoid vetoing the beforeCollapse event.
       * In addition, due to internal optimizations, when multiple items are collapsed due to update of expanded option,
       * there is no guarantee that this event will be fired for all the collapsible items.
       *
       * @ojshortdesc Triggered after an item has been collapsed. See the Help documentation for more information.
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {any} key The key of the item that was just collapsed.
       * @property {Element} item The list item that was just collapsed.
       * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
       *               {target:"Type", value:"K", for:"key"}]
       */
      collapse: null,
      /**
       * Triggered when the copy action is performed on an item via context menu or keyboard shortcut.
       *
       * @ojshortdesc Triggered when the copy action is performed on an item.
       * @expose
       * @event
       * @ojdeprecated {since: '11.0.0', description: 'Use event from context menu or KeyEvent instead.'}
       * @memberof oj.ojListView
       * @instance
       * @property {Element[]} items an array of items in which the copy action is performed on
       */
      copy: null,
      /**
       * Triggered when the cut action is performed on an item via context menu or keyboard shortcut.
       *
       * @ojshortdesc Triggered when the cut action is performed on an item.
       * @expose
       * @event
       * @ojdeprecated {since: '11.0.0', description: 'Use event from context menu or KeyEvent instead.'}
       * @memberof oj.ojListView
       * @instance
       * @property {Element[]} items an array of items in which the cut action is performed on
       */
      cut: null,
      /**
       * Triggered after an item has been expanded via the <code class="prettyprint">expanded</code> option or via the UI.
       * Note if the expand is triggered by updating the expanded option, applications should avoid vetoing the beforeExpand event.
       * In addition, due to internal optimizations, when multiple items are collapsed due to update of expanded option,
       * there is no guarantee that this event will be fired for all the expandable items.
       *
       * @ojshortdesc Triggered after an item has been expanded. See the Help documentation for more information.
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {any} key The key of the item that was just expanded.
       * @property {Element} item The list item that was just expanded.
       * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
       *               {target:"Type", value:"K", for:"key"}]
       */
      expand: null,
      /**
       * Triggered when user performs an action gesture on an item while ListView is in navigation mode.  The action gestures include:
       * <ul>
       *   <li>User clicks anywhere in an item</li>
       *   <li>User taps anywhere in an item</li>
       *   <li>User pressed enter key while an item or its content has focus</li>
       * </ul>
       *
       * @ojshortdesc Triggered when user performs an action gesture on an item.
       * @expose
       * @event
       * @ojbubbles
       * @memberof oj.ojListView
       * @instance
       * @property {any} context the context information about the item where the action gesture is performed on.
       * @property {Event} originalEvent the DOM event that triggers the action.
       * @ojsignature [{target:"Type", value:"<K,D>", for:"genericTypeParameters"},
       *               {target:"Type", value:"CommonTypes.ItemContext<K,D>", for:"context", jsdocOverride:true}]
       */
      itemAction: null,
      /**
       * Triggered when the paste action is performed on an item via context menu or keyboard shortcut.
       *
       * @ojshortdesc Triggered when the paste action is performed on an item.
       * @expose
       * @event
       * @ojdeprecated {since: '11.0.0', description: 'Use event from context menu or KeyEvent instead.'}
       * @memberof oj.ojListView
       * @instance
       * @property {Element} item the element in which the paste action is performed on
       */
      paste: null,
      /**
       * Triggered after all items in the ListView has been rendered.  Note that in the high-water mark scrolling case,
       * all items means the items that are fetched so far.
       *
       * @ignore
       * @event
       * @deprecated 2.0.0 Use the <a href="#whenReady">whenReady</a> method instead.
       * @memberof oj.ojListView
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       *
       * @example <caption>Initialize the ListView with the <code class="prettyprint">ready</code> callback specified:</caption>
       * $( ".selector" ).ojListView({
       *     "ready": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojready</code> event:</caption>
       * $( ".selector" ).on( "ojready", function( event, ui ) {
       *     // verify that the component firing the event is a component of interest
       *     if ($(event.target).is(".mySelector")) {}
       * });
       */
      ready: null,
      /**
       * Triggered after items are reorder within listview via drag and drop or cut and paste.
       *
       * @ojshortdesc Triggered after items are reordered, whether through a drag and drop action or a cut and paste action.
       * @expose
       * @event
       * @memberof oj.ojListView
       * @instance
       * @property {Element[]} items an array of items that are moved
       * @property {string} position the drop position relative to the reference item.  Possible values are "before", "after", "inside"
       * @property {Element} reference the item where the moved items are drop on
       */
      reorder: null
    },

    /**
     * Create the listview
     * @override
     * @memberof! oj.ojListView
     * @protected
     */
    _ComponentCreate: function () {
      this._super();
      this._setup();
    },

    /**
     * Initialize the listview
     * @private
     */
    _setup: function () {
      var opts = {};

      opts.element = this.element;
      opts.OuterWrapper = this.OuterWrapper;
      opts.ojContext = this;

      // for backward compatibility, the default for expanded for legacy syntax
      // should be the same as before
      if (!this._IsCustomElement()) {
        var expanded = this.options.expanded;
        // check if it's been updated by applications
        if (expanded instanceof _ojListViewExpandedKeySet) {
          this.options.expanded = 'auto';
        }
      }

      opts = $.extend(this.options, opts);

      this.listview = new _ojListView();
      this.listview.init(opts);

      DataCollectionUtils.disableDefaultBrowserStyling(this.element[0]);
    },

    /**
     * Initialize the listview after creation
     * @protected
     * @override
     * @memberof! oj.ojListView
     */
    _AfterCreate: function () {
      this._super();

      // inject helper function for ContentHandler and custom renderer to use
      var self = this;
      this.listview._FixRendererContext = function (context) {
        return self._FixRendererContext(context);
      };
      this.listview._WrapCustomElementRenderer = function (renderer) {
        return self._WrapCustomElementRenderer(renderer);
      };
      this.listview._GetCustomElement = function () {
        return self._GetCustomElement();
      };

      this.listview.afterCreate();
    },

    /**
     * Sets up resources needed by listview
     * @memberof! oj.ojListView
     * @instance
     * @override
     * @protected
     */
    _SetupResources: function () {
      this._super();
      this.listview.setupResources();
    },

    /**
     * Release resources held by listview
     * @memberof! oj.ojListView
     * @instance
     * @override
     * @protected
     */
    _ReleaseResources: function () {
      this._super();
      this.listview.releaseResources();
    },

    /**
     * Sets contextmenu adds allowBrowserContextMenu to allow browser context menu on text
     * @protected
     * @override
     * @memberof! oj.ojListView
     */
    _SetupContextMenu: function () {
      const options = this.listview.setupContextMenu();
      this._super(options);
    },

    /**
     * Gets the focus element
     * @override
     * @memberof! oj.ojListView
     * @instance
     * @protected
     * @since 5.0.0
     */
    GetFocusElement: function () {
      return this.listview != null ? this.listview.GetFocusElement() : this._super();
    },

    /**
     * Destroy the list view
     * @memberof! oj.ojListView
     * @private
     */
    _destroy: function () {
      this.listview.destroy();
      this._super();
    },

    /**
     * When the <a href="#contextMenu">contextMenu</a> option is set, this method is called when the user invokes the context menu via
     * the default gestures: right-click, pressHold, and <kbd>Shift-F10</kbd>.  Components should not call this method directly.
     *
     * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
     * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
     * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
     * @private
     */
    _NotifyContextMenuGesture: function (menu, event, eventType) {
      this.listview.notifyContextMenuGesture(menu, event, eventType);
    },

    /**
     * Sets multiple options
     * @param {Object} options the options object
     * @param {Object} flags additional flags for option
     * @override
     * @private
     */
    _setOptions: function (options, flags) {
      if (!this.listview.isAvailable()) {
        // ListView might have been detached, just update the options.  When ListView becomes available again, the update options will take effect.
        this._super(options, flags);
        return;
      }

      var needRefresh = this.listview.setOptions(options, flags);

      // updates the options last
      this._super(options, flags);

      if (needRefresh) {
        if (options.data) {
          this.listview.adjustScrollPositionValueOnFetch();
        }
        this.listview.refresh();
      } else if (options.selectionRequired || options.selection || options.selectionMode) {
        // if listview is not refresh, we'll need to ensure selectionRequired is enforced if set to true
        this.listview.enforceSelectionRequired();
      }
    },

    /**
     * Sets a single option
     * @param {Object} key the key for the option
     * @param {Object} value the value for the option
     * @param {Object} flags any flags specified for the option
     * @override
     * @private
     */
    _setOption: function (key, value, flags) {
      // checks whether value is valid for the key
      var valid = true;
      var extraData;

      if (key === 'selectionMode') {
        valid = value === 'none' || value === 'single' || value === 'multiple';
      } else if (key === 'drillMode') {
        valid = value === 'collapsible' || value === 'none';
      } else if (key === 'scrollPolicy') {
        valid = value === 'auto' || value === 'loadMoreOnScroll' || value === 'loadAll';
      } else if (key === 'groupHeaderPosition') {
        valid = value === 'static' || value === 'sticky';
      } else if (key === 'firstSelectedItem') {
        // read only
        valid = false;
      }

      // update option if it's valid otherwise throw an error
      if (valid) {
        if (this.listview.isAvailable()) {
          // inject additional metadata for selection
          if (key === 'selection') {
            extraData = this.listview.getItems(value);
            // eslint-disable-next-line no-param-reassign
            flags = {
              _context: {
                extraData: {
                  items: this._IsCustomElement() ? extraData : $(extraData)
                }
              }
            };
          } else if (key === 'currentItem') {
            extraData = this.listview.getItems([value])[0];
            // eslint-disable-next-line no-param-reassign
            flags = {
              _context: {
                extraData: {
                  items: this._IsCustomElement() ? extraData : $(extraData)
                }
              }
            };
          }
        }
        this._super(key, value, flags);
      } else {
        throw new Error('Invalid value: ' + value + ' for key: ' + key);
      }
    },

    /**
     * Invoked when application calls oj.Components.subtreeAttached.
     * @override
     * @private
     */
    _NotifyAttached: function () {
      this.listview.notifyAttached();
    },

    /**
     * In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content,
     * so for detached content only, we must use this hook to remove the focus and hover classes.
     * @override
     * @private
     */
    _NotifyDetached: function () {
      this.listview.notifyDetached();
    },

    /**
     * Invoked when application calls oj.Components.subtreeShown.
     * @override
     * @private
     */
    _NotifyShown: function () {
      this.listview.notifyShown();
    },

    /**
     * Override to do the delay connect/disconnect
     * @memberof oj.ojListView
     * @override
     * @protected
     */
    _VerifyConnectedForSetup: function () {
      return true;
    },

    /**
     * Override to allow component to be "suspended"
     * @memberof oj.ojListView
     * @override
     * @protected
     */
    _AllowConnectedSuspension: function () {
      return true;
    },

    /** ******************************* public methods **************************************/
    /**
     * Returns a jQuery object containing the root dom element of the listview.
     *
     * <p>This method does not accept any arguments.
     *
     * @ignore
     * @expose
     * @override
     * @memberof oj.ojListView
     * @instance
     * @return {jQuery} the root DOM element of list
     */
    widget: function () {
      return this.listview.GetRootElement();
    },

    /**
     * Redraw the entire list view after having made some external modifications.
     *
     * <p>This method does not accept any arguments.
     *
     * @ojshortdesc Redraw the entire list.
     * @expose
     * @memberof oj.ojListView
     * @return {void}
     * @instance
     *
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * myListView.refresh();
     */
    refresh: function () {
      this._super();
      this.listview.refresh();
    },

    /**
     * Returns a Promise that resolves when the component is ready, i.e. after data fetching, rendering, and animations complete.
     * Note that in the high-water mark scrolling case, component is ready after data fetching, rendering, and associated animations of items fetched so far are complete.
     *
     * <p>This method does not accept any arguments.
     *
     * @ignore
     * @ojshortdesc Returns a Promise that resolves when this component becomes ready.
     * @expose
     * @memberof oj.ojListView
     * @instance
     * @return {Promise} A Promise that resolves when the component is ready.
     */
    whenReady: function () {
      return this.listview.whenReady();
    },

    // @inheritdoc
    getNodeBySubId: function (locator) {
      return this.listview.getNodeBySubId(locator);
    },

    // @inheritdoc
    getSubIdByNode: function (node) {
      return this.listview.getSubIdByNode(node);
    },

    /**
     * @typedef {Object} oj.ojListView.ContextByNode
     * @property {string} subId the sub id that represents the element
     * @property {K} key the key of the item
     * @property {number} index the zero based index of the item, relative to its parent
     * @property {Element=} parent the parent group DOM element
     * @property {boolean=} group whether the item is a group item
     * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"}]
     */
    /**
     * {@ojinclude "name":"nodeContextDoc"}
     * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
     * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
     * @ojsignature { target: "Type",
     *                value: "oj.ojListView.ContextByNode<K>|null",
     *                jsdocOverride: true,
     *                for: "returns"}
     *
     * @example {@ojinclude "name":"nodeContextExample"}
     *
     * @expose
     * @instance
     * @memberof oj.ojListView
     * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
     */
    getContextByNode: function (node) {
      return this.listview.getContextByNode(node);
    },

    /**
     * Return the raw data for an item in ListView.  The item must have been already fetched.
     * @param {Object} context The context of the item to retrieve raw data.
     * @param {any=} context.key The key of the item.  If both index and key are specified, then key takes precedence.
     * @param {number=} context.index The index of the item relative to its parent.
     * @param {Element=} context.parent The parent node, not required if parent is the root.
     * @returns {any} data of the item.  If the item is not found or not yet fetched, returns null.  Also,
     * if static HTML is used as data (data attribute is not specified), then the element for the item is returned.
     * @ojshortdesc Gets the raw data of an item.
     * @export
     * @expose
     * @memberof oj.ojListView
     * @instance
     * @example <caption>Invoke the <code class="prettyprint">getDataForVisibleItem</code> method:</caption>
     * var data = myListView.getDataForVisibleItem( {'index': 2} );
     * @ojsignature [{target:"Type", value:"K", for:"context.key"},
     *               {target:"Type", value:"D", for:"returns"}]
     */
    getDataForVisibleItem: function (context) {
      return this.listview.getDataForVisibleItem(context);
    },

    /**
     * Expand an item.<p>
     * Note when vetoable is set to false, beforeExpand event will still be fired but the event cannot be veto.<p>
     *
     * @ignore
     * @expose
     * @memberof oj.ojListView
     * @instance
     * @param {Object} key the key of the item to expand
     * @param {boolean} vetoable whether the event should be vetoable
     */
    expand: function (key, vetoable) {
      this.listview.expandKey(key, vetoable, true, true);
    },

    /**
     * Collapse an item.<p>
     * Note when vetoable is set to false, beforeCollapse event will still be fired but the event cannot be veto.<p>
     *
     * @ignore
     * @expose
     * @memberof oj.ojListView
     * @instance
     * @param {Object} key the key of the item to collapse
     * @param {boolean} vetoable whether the event should be vetoable
     */
    collapse: function (key, vetoable) {
      this.listview.collapseKey(key, vetoable, true);
    },

    /**
     * Gets the key of currently expanded items.
     *
     * @ignore
     * @expose
     * @memberof oj.ojListView
     * @instance
     * @return {Array} array of keys of currently expanded items
     */
    getExpanded: function () {
      return this.listview.getExpanded();
    },

    /**
     * Gets the IndexerModel which can be used with the ojIndexer.  The IndexerModel provided by ListView
     * by defaults returns a list of locale dependent characters.  See translations for the key used to return
     * all characters.  When a user selects a character in the ojIndexer ListView will scroll to the group
     * header (or the closest one) with the character as its prefix.
     *
     * @expose
     * @ojshortdesc Gets the IndexerModel which can be used with the ojIndexer.
     * @memberof oj.ojListView
     * @ojdeprecated {since:"3.0.0", description:'Implements your own IndexerModel or use the <a href="IndexerModelTreeDataSource.html">IndexerModelTreeDataSource</a> class instead.'}
     * @instance
     * @return {Object} ListView's IndexerModel to be used with the ojIndexer
     */
    getIndexerModel: function () {
      if (this.indexerModel == null && ojindexer.ListViewIndexerModel) {
        this.indexerModel = new ojindexer.ListViewIndexerModel(this.listview);
      }
      return this.indexerModel;
    },

    /**
     * Scrolls the list until the specified item is visible.  If the item is not yet loaded (if scrollPolicy is set to 'loadMoreOnScroll'), then no action is taken.
     *
     * @ojshortdesc Scrolls a loaded item until it is visible.
     * @param {Object} item An object with a 'key' property that identifies the item to scroll to.
     * @property {K} item.key the key of the item to scroll to.
     * @expose
     * @memberof oj.ojListView
     * @return {void}
     * @instance
     * @ojdeprecated {since: "13.0.0", description: "The scrollToItem method is deprecated. Use scrollPosition instead."}
     */
    scrollToItem: function (item) {
      this.listview.scrollToItem(item);
    },

    _CompareOptionValues: function (option, value1, value2) {
      switch (option) {
        case 'currentItem':
        case 'scrollPolicyOptions':
          return oj.Object.compareValues(value1, value2);
        case 'selection':
          if (value1 && value1.inverted === undefined) {
            // eslint-disable-next-line no-param-reassign
            value1.inverted = false;
          }
          if (value2 && value2.inverted === undefined) {
            // eslint-disable-next-line no-param-reassign
            value2.inverted = false;
          }
          if (value1 && value2 && value1.inverted !== value2.inverted) {
            return false;
          }
          return oj.Object.compareValues(value1, value2);
        default:
          return this._super(option, value1, value2);
      }
    }
  });

  //-----------------------------------------------
  //                  Slots
  //-----------------------------------------------
  /**
   * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the list. The slot content must be a &lt;template> element.
   * The content of the template could either include the &lt;li> element, in which case that will be used as
   * the root of the item.  Or it can be just the content which excludes the &lt;li> element.</p>
   * <p>When the template is executed for each item, it will have access to the binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojListView.ItemTemplateContext]{@link oj.ojListView.ItemTemplateContext} or the table below for a list of properties available on $current)</li>
   *  <li>alias - if as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   * @ojslot itemTemplate
   * @ojshortdesc The itemTemplate slot is used to specify the template for rendering each item in the list. See the Help documentation for more information.
   * @ojmaxitems 1
   * @memberof oj.ojListView
   * @ojtemplateslotprops oj.ojListView.ItemTemplateContext
   *
   * @example <caption>Initialize the ListView with an inline item template specified:</caption>
   * &lt;oj-list-view>
   *   &lt;template slot='itemTemplate'>
   *     &lt;span>&lt;oj-bind-text value='[[$current.data.name]]'>&lt;/span>
   *   &lt;template>
   * &lt;/oj-list-view>
   */

  /**
   * <p>The <code class="prettyprint">noData</code> slot is used to specify the content to display when the list is empty.
   * The slot content must be a &lt;template> element.  If not specified then a default no data message will be displayed.
   *
   * @ojslot noData
   * @ojshortdesc The noData slot is used to specify the content to render when the list is empty.
   * @ojmaxitems 1
   * @memberof oj.ojListView
   * @ojtemplateslotprops {}
   * @ojtemplateslotrendertype "RenderNoDataTemplate"
   *
   * @example <caption>Initialize the ListView with a noData slot specified:</caption>
   * &lt;oj-list-view>
   *   &lt;template slot='noData'>
   *     &lt;span>&lt;oj-button>Add item&lt;/span>
   *   &lt;template>
   * &lt;/oj-list-view>
   */

  //------------------------------------------------
  //                    Fragments
  //------------------------------------------------
  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="2">List Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Focus on the item.  If <code class="prettyprint">selectionMode</code> is enabled, selects the item as well.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display context menu</td>
   *     </tr>
   *     <tr>
   *       <td rowspan="2">Group Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Expand or collapse the group item if <code class="prettyprint">drillMode</code> is set to collapsible.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display context menu</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojListView
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan = "20" nowrap>List Item</td>
   *       <td><kbd>F2</kbd></td>
   *       <td>Enters Actionable mode.  This enables keyboard action on elements inside the item, including navigate between focusable elements inside the item. It can also be used to exit actionable mode if already in actionable mode.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Exits Actionable mode.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>When in Actionable Mode, navigates to next focusable element within the item.  If the last focusable element is reached, shift focus back to the first focusable element.
   *           When not in Actionable Mode, navigates to next focusable element on page (outside ListView).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+Tab</kbd></td>
   *       <td>When in Actionable Mode, navigates to previous focusable element within the item.  If the first focusable element is reached, shift focus back to the last focusable element.
   *           When not in Actionable Mode, navigates to previous focusable element on page (outside ListView).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Move focus to the item below.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Move focus to the item above.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>When display in card layout, move focus to the item on the left.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>When display in card layout, move focus to the item on the right.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+DownArrow</kbd></td>
   *       <td>Extend the selection to the item below.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+UpArrow</kbd></td>
   *       <td>Extend the selection to the item above.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+LeftArrow</kbd></td>
   *       <td>When display in card layout, extend the selection to the item on the left.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+RightArrow</kbd></td>
   *       <td>When display in card layout, extend the selection to the item on the right.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+F10</kbd></td>
   *       <td>Launch the context menu if there is one associated with the current item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Selects the current item.  No op if the item is already selected.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Space</kbd></td>
   *       <td>Toggles to select and deselect the current item.  If previous items have been selected, deselects them and selects the current item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+Space</kbd></td>
   *       <td>Selects contiguous items from the last selected item to the current item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+Space</kbd></td>
   *       <td>Toggles to select and deselect the current item while maintaining previous selected items.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+X</kbd></td>
   *       <td>Marks the selected items to move if dnd.reorder is enabled.  This has been deprecated.  Applications should designate their own shortcut key and handle the KeyEvent directly.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+C</kbd></td>
   *       <td>Marks the selected items to copy if dnd.reorder is enabled.  This has been deprecated.  Applications should designate their own shortcut key and handle the KeyEvent directly.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+V</kbd></td>
   *       <td>Paste the items that are marked to directly before the current item (or as the last item if the current item is a folder).  This has been deprecated.  Applications should designate their own shortcut key and handle the KeyEvent directly.</td>
   *     </tr>
   *     <tr>
   *       <td rowspan = "2" nowrap>Group Item</td>
   *       <td><kbd>LeftArrow (RightArrow in RTL)</kbd></td>
   *       <td>Collapse the current item if it is expanded and is collapsible.  For non-hierarchical data, do nothing.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow (LeftArrow in RTL)</kbd></td>
   *       <td>Expand the current item if it has children and is expandable.  For non-hierarchical data, do nothing.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojListView
   */

  //-------------------------------------------------------
  //                  SUB-IDS
  //-------------------------------------------------------

  /**
   * <p>Sub-ID for ListView's disclosure icon in group items.  See the <a href="#getNodeBySubId">getNodeBySubId</a>
   * method for details.</p>
   *
   * @ojdeprecated {since: "2.0.0", description: 'Use the <a href="#oj-listview-disclosure">oj-listview-disclosure</a> option instead.'}
   * @ojsubid oj-listview-icon
   * @memberof oj.ojListView
   *

   * @example <caption>Get the disclosure icon for the group item with key 'foo':</caption>
   * var node = myListView.getNodeBySubId( {'subId': 'oj-listview-icon', 'key': 'foo'} );
   */

  /**
   * <p>Sub-ID for ListView's disclosure icon in group items.  See the <a href="#getNodeBySubId">getNodeBySubId</a>
   * method for details.</p>
   *
   * @ojsubid oj-listview-disclosure
   * @memberof oj.ojListView
   *
   * @example <caption>Get the disclosure icon for the group item with key 'foo':</caption>
   * var node = myListView.getNodeBySubId( {'subId': 'oj-listview-disclosure', 'key': 'foo'} );
   */

  /**
   * <p>Context for items within ListView.</p>
   *
   * @property {number} index the zero based item index relative to its parent
   * @property {Object} key the key of the item
   * @property {Element} parent the parent group item.  Only available if item has a parent.
   * @property {boolean} group whether the item is a group.
   *
   * @ojnodecontext oj-listview-item
   * @memberof oj.ojListView
   */

  // ////////////////     SUB-PROPERTIES (dnd, scrollPolicyOptions)     //////////////////

  /**
   * If this object is specified, listview will initiate drag operation when the user drags on either a drag handle, which is an element with oj-listview-drag-handle class, or
   * selected items if no drag handle is set on the item.
   * @expose
   * @name dnd.drag.items
   * @ojshortdesc An object that describes drag functionality for a selected set of items. See the Help documentation for more information.
   * @memberof! oj.ojListView
   * @instance
   * @type {Object}
   */
  /**
   * The MIME types to use for the dragged data in the dataTransfer object. This can be a string if there is only one
   * type, or an array of strings if multiple types are needed.<br><br>
   * For example, if selected items of employee data are being dragged, dataTypes could be "application/employees+json". Drop targets can examine the data types and decide
   * whether to accept the data. A text input may only accept "text" data type, while a chart for displaying employee data may be configured to accept the "application/employees+json" type.<br><br>
   * For each type in the array, dataTransfer.setData will be called with the specified type and the JSON version of the selected item data as the value. The selected item data
   * is an array of objects, with each object representing a model object from the underlying data source.  For example, if the underlying data is an oj.Collection, then this
   * would be a oj.Model object.  Note that when static HTML is used, then the value would be the html string of the selected item.<br><br>
   * This property is required unless the application calls setData itself in a dragStart callback function.
   * @expose
   * @name dnd.drag.items.dataTypes
   * @ojshortdesc Specifies one or more MIME types to use for the dragged data in the dataTransfer object. See the Help documentation for more information.
   * @memberof! oj.ojListView
   * @instance
   * @type {string|Array.<string>}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * A callback function that receives the "dragstart" event and context information as its arguments.  The ontext information has the following properties:<br>
   * <ul>
   *   <li><code class="prettyprint">items</code>: An array of items being dragged
   *   </li>
   * </ul><br><br>
   * This function can set its own data and drag image as needed. If dataTypes is specified, event.dataTransfer is already populated with the default data when this function is invoked.
   * If dataTypes is not specified, this function must call event.dataTransfer.setData to set the data or else the drag operation will be cancelled.  In either case, the drag image is
   * set to an image of the dragged rows on the listview.
   * @expose
   * @name dnd.drag.items.dragStart
   * @ojshortdesc A callback function that receives the "dragstart" event and context information as its arguments.
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event, {items: Array.<Element>}):void}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * An optional callback function that receives the "drag" event as its argument.
   * @expose
   * @name dnd.drag.items.drag
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event)}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * An optional callback function that receives the "dragend" event as its argument.
   * @expose
   * @name dnd.drag.items.dragEnd
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event)}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * @typedef {Object} oj.ojListView.ItemsDropContext
   * @property {Element} item the item being dropped on
   * @property {'before'|'after'|'inside'} position the drop position relative to the item being dropped on
   * @property {boolean} reorder true if the drop was a reorder in the same listview, false otherwise
   */
  /**
   @typedef {Object} oj.ojListView.ItemTemplateContext
   @property {Element} componentElement The &lt;oj-list-view> custom element
   @property {Object} data The data for the current item being rendered
   @property {Object} item The current item being rendered
   @property {number} index The zero-based index of the current item during initial rendering. Note the index is not updated in response to item additions and removals.
   @property {string} key The key of the current item being rendered
   @property {number} depth The depth of the current item (available when hierarchical data is provided) being rendered. The depth of the first level children under the invisible root is 1.
   @property {boolean} leaf True if the current item is a leaf node (available when hierarchical data is provided).
   @property {string} parentKey The key of the parent item (available when hierarchical data is provided). The parent key is null for root nodes.
   @ojsignature [{target:"Type", value:"<K = any,D = any>", for:"genericTypeParameters"},
   {target:"Type", value:"D", for:"data", jsdocOverride: true},
   {target: "Type", value:"Item<K, D>", for:"item", jsdocOverride: true},
   {target:"Type", value:"K", for:"key", jsdocOverride: true},
  {target:"Type", value:"K", for:"parentKey", jsdocOverride: true}]
   */

  /**
   * An object that specifies callback functions to handle dropping items.
   * @expose
   * @name dnd.drop.items
   * @ojshortdesc An object that describes drop functionality for a selected set of items.
   * @memberof! oj.ojListView
   * @instance
   * @type {Object}
   */
  /**
   * A data type or an array of data types this component can accept.<br><br>
   * This property is required unless dragEnter, dragOver, and drop callback functions are specified to handle the corresponding events.
   * @expose
   * @name dnd.drop.items.dataTypes
   * @ojshortdesc Specifies one or more data types that this component can accept. See the Help documentation for more information.
   * @memberof! oj.ojListView
   * @instance
   * @type {string | Array.<string>}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * An optional callback function that receives the "dragenter" event and context information as its arguments.  The context information has the following properties:<br>
   * <ul>
   *   <li><code class="prettyprint">item</code>: the item being entered
   *   </li>
   * </ul><br><br>
   * This function should call <code class="prettyprint">event.preventDefault</code> to indicate the dragged data can be accepted.<br><br>
   * @expose
   * @name dnd.drop.items.dragEnter
   * @ojshortdesc An optional callback function that receives the "dragenter" event and context information as its arguments.
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event, {item: Element}):void}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * An optional callback function that receives the "dragover" event and context information as its arguments.  The context information has the following properties:<br>
   * <ul>
   *   <li><code class="prettyprint">item</code>: the item being dragged over
   *   </li>
   * </ul><br><br>
   * Similar to dragEnter, this function should call <code class="prettyprint">event.preventDefault</code> to indicate the dragged data can be accepted.
   * @expose
   * @name dnd.drop.items.dragOver
   * @ojshortdesc An optional callback function that receives the "dragover" event and context information as its arguments.
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event, {item: Element}):void}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * An optional callback function that receives the "dragleave" event and context information as its arguments.  The context information has the following properties:<br>
   * <ul>
   *   <li><code class="prettyprint">item</code>: the item that was last entered
   *   </li>
   * </ul><br><br>
   * @expose
   * @name dnd.drop.items.dragLeave
   * @ojshortdesc An optional callback function that receives the "dragleave" event and context information as its arguments.
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event, {item: Element}):void}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * A callback function that receives the "drop" event and context information as its arguments.  The context information has the following properties:<br>
   * <ul>
   *   <li><code class="prettyprint">item</code>: the item being dropped on
   *   <li><code class="prettyprint">position</code>: the drop position relative to the item being dropped on
   *   <li><code class="prettyprint">reorder</code>: true if the drop was a reorder in the same listview, false otherwise
   *   </li>
   * </ul><br><br>
   * This function should call <code class="prettyprint">event.preventDefault</code> to indicate the dragged data is accepted.<br><br>
   * If the application needs to look at the data for the item being dropped on, it can use the getDataForVisibleItem method.
   * @expose
   * @name dnd.drop.items.drop
   * @ojshortdesc An optional callback function that receives the "drop" event and context information as its arguments.
   * @memberof! oj.ojListView
   * @instance
   * @type {function(Event, Object):void}
   * @default null
   * @ojsignature { target: "Type",
   *                value: "?((param0: Event, param1: oj.ojListView.ItemsDropContext)=> void)",
   *                jsdocOverride: true}
   */
  /**
   * The number of items to fetch in each block
   * @expose
   * @name scrollPolicyOptions.fetchSize
   * @memberof! oj.ojListView
   * @instance
   * @type {number}
   * @default 25
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * The maximum total number of items to fetch
   * @expose
   * @name scrollPolicyOptions.maxCount
   * @memberof! oj.ojListView
   * @instance
   * @type {number}
   * @default 500
   * @ojsignature { target: "Type",
   *                value: "?"}
   */
  /**
   * The element or a CSS selector string to an element which listview uses to determine the scroll position as well as the maximum scroll position.  For example in a lot of mobile use cases where ListView occupies the entire screen, developers should set the scroller option to document.documentElement.
   * @expose
   * @name scrollPolicyOptions.scroller
   * @ojshortdesc The element used to determine the scroll position as well as the maximum scroll position. See the Help documentation for more information.
   * @memberof! oj.ojListView
   * @instance
   * @type {Element|string}
   * @ojsignature {target:"Type", value:"? | Element | keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap | string"}
   */

  // Set theme-based defaults
  Components.setDefaultOptions({
    ojListView: {
      gridlines: Components.createDynamicPropertyGetter(function () {
        const gridlinesObject = _ojListView._CSS_Vars.gridlines;
        var defaults = {
          gridlines: _ojListView.getComplexCSSVariable(gridlinesObject)
        };
        if (defaults == null) {
          Logger.error(
            'Cannot find oj-list-view option defaults, which might be caused by missing JET css file'
          );
          defaults = { gridlines: {} };
        } else if (defaults.gridlines == null) {
          Logger.error(
            'Cannot find gridlines default option, which might be caused by a mismatch between JET js and css files'
          );
          defaults = { gridlines: {} };
        }
        return { item: defaults.gridlines.item };
      })
    }
  });

});


define('ojs/ojlistitemlayout',['exports', 'preact/jsx-runtime', 'ojs/ojvcomponent', 'preact', 'preact/hooks'], function (exports, jsxRuntime, ojvcomponent, preact, hooks) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class ListItemLayoutProps {
    }
    exports.ListItemLayout = class ListItemLayout extends preact.Component {
        constructor() {
            super(...arguments);
            this._hasContent = (slotContent) => (Array.isArray(slotContent) && slotContent.length > 0) || slotContent;
        }
        _getWrappedSlotContent(slotContent, wrapperClasses, isAdditionalTabIndexNeeded) {
            if (this._hasContent(slotContent)) {
                let defaultTabIndex = 0;
                if (wrapperClasses && wrapperClasses.length > 0 && isAdditionalTabIndexNeeded) {
                    return (jsxRuntime.jsx("div", { class: wrapperClasses, tabIndex: defaultTabIndex, children: slotContent }));
                }
                else if (wrapperClasses && wrapperClasses.length > 0) {
                    return jsxRuntime.jsx("div", { class: wrapperClasses, children: slotContent });
                }
                else if (isAdditionalTabIndexNeeded) {
                    return jsxRuntime.jsx("div", { tabIndex: defaultTabIndex, children: slotContent });
                }
                else {
                    return jsxRuntime.jsx("div", { children: slotContent });
                }
            }
            return null;
        }
        _getWrappedSlotContentWithClickThroughDisabled(slotContent, wrapperClasses, isAdditionalTabIndexNeeded) {
            if (this._hasContent(slotContent)) {
                let defaultTabIndex = 0;
                if (wrapperClasses && wrapperClasses.length > 0 && isAdditionalTabIndexNeeded) {
                    return (jsxRuntime.jsx("div", { "data-oj-clickthrough": "disabled", class: wrapperClasses, tabIndex: defaultTabIndex, children: slotContent }));
                }
                else if (wrapperClasses && wrapperClasses.length > 0) {
                    return (jsxRuntime.jsx("div", { "data-oj-clickthrough": "disabled", class: wrapperClasses, children: slotContent }));
                }
                else if (isAdditionalTabIndexNeeded) {
                    return (jsxRuntime.jsx("div", { "data-oj-clickthrough": "disabled", tabIndex: defaultTabIndex, children: slotContent }));
                }
                else {
                    return jsxRuntime.jsx("div", { "data-oj-clickthrough": "disabled", children: slotContent });
                }
            }
            return null;
        }
        render(props) {
            const layoutRef = hooks.useRef(null);
            let primaryClass = hooks.useRef();
            hooks.useEffect(() => {
                if (layoutRef.current.parentElement) {
                    const hasPaddingOff = layoutRef.current.parentElement.classList.contains('oj-listitemlayout-padding-off');
                    primaryClass.current = hasPaddingOff ? 'oj-listitemlayout-primary' : '';
                }
            }, [props.children]);
            const hasExtra = this._hasContent(props.metadata) ||
                this._hasContent(props.action) ||
                this._hasContent(props.trailing);
            let tertiaryClass = '';
            if (this._hasContent(props.secondary) && this._hasContent(props.tertiary)) {
                tertiaryClass = 'oj-listitemlayout-tertiary';
            }
            let leadingClass = 'oj-listitemlayout-leading';
            if (this._hasContent(props.selector) && this._hasContent(props.leading)) {
                leadingClass = leadingClass + ' oj-listitemlayout-start-padding';
            }
            let quaternaryClass = 'oj-listitemlayout-quaternary';
            let textSlotClass = 'oj-listitemlayout-textslots';
            if (this._hasContent(props.selector) || this._hasContent(props.leading)) {
                textSlotClass = textSlotClass + ' oj-listitemlayout-start-padding';
                quaternaryClass = quaternaryClass + ' oj-listitemlayout-start-padding';
            }
            return (jsxRuntime.jsxs("div", { class: "oj-listitemlayout-grid", ref: layoutRef, children: [this._getWrappedSlotContent(props.selector, 'oj-listitemlayout-selector', false), this._getWrappedSlotContent(props.leading, leadingClass, true), jsxRuntime.jsxs("div", { class: textSlotClass, children: [this._getWrappedSlotContent(props.overline, null, true), this._getWrappedSlotContent(props.children, primaryClass.current, true), this._getWrappedSlotContent(props.secondary, null, true), this._getWrappedSlotContent(props.tertiary, tertiaryClass, true)] }), hasExtra ? (jsxRuntime.jsxs("div", { class: "oj-listitemlayout-extra", children: [this._getWrappedSlotContent(props.metadata, 'oj-listitemlayout-metadata oj-listitemlayout-start-padding', true), this._getWrappedSlotContent(props.trailing, 'oj-listitemlayout-trailing oj-listitemlayout-image oj-listitemlayout-start-padding', true), this._getWrappedSlotContentWithClickThroughDisabled(props.action, 'oj-listitemlayout-action oj-listitemlayout-start-padding', false)] })) : null, this._getWrappedSlotContent(props.quaternary, quaternaryClass, true), this._getWrappedSlotContentWithClickThroughDisabled(props.navigation, 'oj-listitemlayout-navigation', false)] }));
        }
    };
    exports.ListItemLayout._metadata = { "slots": { "": {}, "overline": {}, "selector": {}, "leading": {}, "secondary": {}, "tertiary": {}, "metadata": {}, "trailing": {}, "action": {}, "quaternary": {}, "navigation": {} } };
    exports.ListItemLayout = __decorate([
        ojvcomponent.customElement('oj-list-item-layout')
    ], exports.ListItemLayout);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojlistviewdnd',['exports', 'ojs/ojcore', 'jquery', 'ojs/ojlogger', 'ojdnd', 'ojs/ojlistview'], function (exports, oj, $, Logger, ojdnd, ojlistview) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  /**
   * @ignore
   * @export
   * @class oj.ListViewDndContext
   * @classdesc Drag and Drop Utils for ojListView
   * @param {Object} listview the ListView instance
   * @constructor
   */
  const ListViewDndContext = function (listview) {
    this.listview = listview;
  };
  oj._registerLegacyNamespaceProp('ListViewDndContext', ListViewDndContext);
  // Subclass from oj.Object
  oj.Object.createSubclass(ListViewDndContext, oj.Object, 'oj.ListViewDndContext');

  ListViewDndContext.C_KEY = 67;
  ListViewDndContext.V_KEY = 86;
  ListViewDndContext.X_KEY = 88;

  ListViewDndContext.CUT_COMMAND = 'cut';
  ListViewDndContext.COPY_COMMAND = 'copy';
  ListViewDndContext.PASTE_COMMAND = 'paste';
  ListViewDndContext.PASTE_BEFORE_COMMAND = 'pasteBefore';
  ListViewDndContext.PASTE_AFTER_COMMAND = 'pasteAfter';

  /**
   * Clears the internal of dnd context.  Called by _resetInternal in ListView.
   */
  ListViewDndContext.prototype.reset = function () {
    // this cache might not be clear if dnd never did happened
    this._unsetSelectionDraggable();

    this.m_itemsDragged = null;
    this.m_dragImage = null;
    this.m_currentDragItem = null;
    this.m_dragItems = null;
    this.m_contextMenuItem = null;
    this.m_cachedOffset = null;
    this.m_dropTarget = null;
    this.m_firstDropTarget = null;
  };

  /** ****************************** common helpers ***********************************************/

  /**
   * Retrieve options for drag or drop
   * @param {string} op either drag or drop
   * @return {Object} options for drag or drop
   * @private
   */
  ListViewDndContext.prototype._getDndOptions = function (op) {
    var dnd = this.listview.GetOption('dnd');
    if (dnd != null && dnd[op]) {
      return dnd[op].items;
    }

    return null;
  };

  /**
   * Retrieve options for drag
   * @return {Object} options for drag
   * @private
   */
  ListViewDndContext.prototype._getDragOptions = function () {
    return this._getDndOptions('drag');
  };

  /**
   * Retrieve options for drop
   * @return {Object} options for drop
   * @private
   */
  ListViewDndContext.prototype._getDropOptions = function () {
    return this._getDndOptions('drop');
  };

  /**
   * Return true if reordering enabled.
   * @return {boolean} whether item reordering is enable
   * @protected
   */
  ListViewDndContext.prototype.IsItemReOrdering = function () {
    var option = this._getDndOptions('reorder');
    return option === 'enabled';
  };

  /**
   * Gets the default drag affordance marker class
   * @return {string} affordance marker class
   * @protected
   */
  ListViewDndContext.prototype.GetDragAffordanceClass = function () {
    return 'oj-listview-drag-handle';
  };

  /**
   * Gets the drag Image class. Need to be override by navlist.
   * @return {string} drag image class
   * @protected
   */
  ListViewDndContext.prototype.GetDragImageClass = function () {
    return 'oj-listview-drag-image';
  };

  /**
   * Gets the drag Item class.  Need to be override by navlist.
   * @return {string} drag Item class
   * @protected
   */
  ListViewDndContext.prototype.GetDragItemClass = function () {
    return 'oj-listview-drag-item';
  };

  /**
   * Gets the cut command style class.  Need to be override by navlist.
   * @return {string} cut command style class
   * @protected
   */
  ListViewDndContext.prototype.GetCutStyleClass = function () {
    return 'oj-listview-cut';
  };

  /**
   * Gets the style class prefix.  Need to be override by navlist.
   * @return {string} style class prefix
   * @protected
   */
  ListViewDndContext.prototype.GetCommandPrefix = function () {
    return 'oj-listview-';
  };

  ListViewDndContext.prototype._findItem = function (target) {
    if ($(target).get(0).classList.contains('oj-listview-first-drop-target')) {
      return $(this.m_dropTargetElem);
    }
    return this.listview.FindItem(target);
  };

  /**
   * Gets selected items
   * @param {boolean=} excludeContextMenuItem true if to exclude the the item user right clicked on, false or undefined otherwise.
   * @return {Array.<Element>} an array of selected item's elements.
   * @private
   */
  ListViewDndContext.prototype._getSelectedItems = function (excludeContextMenuItem) {
    var items = [];

    if (this.listview._isSelectionEnabled()) {
      // if it's item then use selection
      var selection = this.listview.GetOption('selection');
      for (var i = 0; i < selection.length; i++) {
        var elem = this.listview.FindElementByKey(selection[i]);
        // make sure item is focusable also
        if (elem != null && !this.listview.SkipFocus($(elem))) {
          items.push(elem);
        }
      }
    } else {
      // if there's no selection, use the active item
      var activeElem = this._getActiveItem();
      if (activeElem != null) {
        items.push(activeElem);
      }
    }

    // if the rightclicked item is not in the selection, we will only use that item.
    if (
      !excludeContextMenuItem &&
      this.m_contextMenuItem != null &&
      this.m_contextMenuItem.length > 0
    ) {
      // verify contextMenuItem is still valid
      if (!this.listview.element.get(0).contains(this.m_contextMenuItem.get(0))) {
        this.m_contextMenuItem = null;
      } else if (items.indexOf(this.m_contextMenuItem.get(0)) === -1) {
        items = [this.m_contextMenuItem.get(0)];
      }
    }

    return items;
  };

  /**
   * @return {Element}
   * @private
   */
  ListViewDndContext.prototype._getActiveItem = function () {
    if (this.listview.m_active == null) {
      return null;
    }

    return this.listview.m_active.elem[0];
  };

  /**
   * Called by content handler once the content of an item is rendered
   * @param {Element} elem the item element
   * @param {Object} context the context object used for the item
   */
  // eslint-disable-next-line no-unused-vars
  ListViewDndContext.prototype.itemRenderComplete = function (elem, context) {
    // if it's a group, use the div instead
    if (!$(elem).hasClass(this.listview.getItemStyleClass())) {
      // eslint-disable-next-line no-param-reassign
      elem = elem.firstElementChild;
    }

    var dragHandle = $(elem).find('.' + this.GetDragAffordanceClass());
    // for touch draggable needs to be set prior to touch interaction
    if (dragHandle != null && dragHandle.length > 0 && this.listview._isTouchSupport()) {
      dragHandle.attr('draggable', 'true');
    }
    // needs to set tabindex='-1' due to the issue that causes reorder doesn't work during first click
    // detail documented in JET-65969
    dragHandle.attr('tabindex', '-1');
  };
  /** ****************************** Mouse down/up, touch start/end helpers ***********************************************/
  ListViewDndContext.prototype._unsetSelectionDraggable = function () {
    if (this.m_draggableSelection) {
      $.each(
        this.m_draggableSelection,
        function (index, elem) {
          $(elem).removeClass('oj-draggable');
          if (this.listview._isTouchSupport()) {
            $(elem).removeAttr('draggable');
          }
        }.bind(this)
      );
    }
  };

  /**
   * Make every item in the current selection draggable.
   * Invoke by listview when selection has changed
   * @private
   */
  ListViewDndContext.prototype.setSelectionDraggable = function () {
    var elems = [];

    // clear previous draggable selections
    this._unsetSelectionDraggable();

    // make current selection draggable
    var selection = this.listview.GetOption('selection');
    for (var i = 0; i < selection.length; i++) {
      var elem = this.listview.FindElementByKey(selection[i]);
      // make sure item is focusable also
      if (elem != null && !this.listview.SkipFocus($(elem))) {
        elems.push(elem);
        $(elem).addClass('oj-draggable');
        // for touch draggable needs to be set prior to touch interaction
        if (this.listview._isTouchSupport()) {
          $(elem).attr('draggable', 'true');
        }
      }
    }

    this.m_draggableSelection = elems;
  };

  /**
   * Sets draggable style class on item
   * @param {jQuery} item the listview item
   * @return {boolean} true if no style class has applied, false otherwise
   * @private
   */
  ListViewDndContext.prototype._setItemDraggable = function (item) {
    // if the item contains the drag affordance, then bail
    var cls = this.GetDragAffordanceClass();
    var dragHandle = item.find('.' + cls);
    if (dragHandle != null && dragHandle.length > 0) {
      return true;
    }

    item.addClass('oj-draggable');
    return false;
  };

  /**
   * Unsets draggable style class on item
   * @param {jQuery} item the listview item
   * @private
   */
  ListViewDndContext.prototype._unsetItemDraggable = function (item) {
    // would be no-op if there's an affordance
    item.removeClass('oj-draggable');
  };

  /**
   * Sets draggable attribute on either the item or affordance.
   * See HandleMouseDownOrTouchStart method
   * @param {jQuery} target target from mouse down or touch start event
   * @private
   */
  ListViewDndContext.prototype._setDraggable = function (target) {
    if (this._getDragOptions() != null || this.IsItemReOrdering()) {
      var cls = this.GetDragAffordanceClass();
      var dragger;

      if (target.hasClass(cls)) {
        dragger = $(target);
      } else {
        var item = this._findItem(target);
        if (!this.shouldDragCurrentItem()) {
          if (item != null) {
            var skipped = this._setItemDraggable(item);
            if (skipped) {
              // contains affordance, bail out.
              return;
            }
          }

          // if dragging an item, it must be already the current item or one of the selected item
          var selectedItems = this._getSelectedItems(true);
          if (selectedItems.length > 0) {
            // in order to initiate drag the item must be the current active item
            if (item != null && selectedItems.indexOf(item[0]) > -1) {
              dragger = item;
            } else {
              // the active item would change, so remove oj-draggable now
              // note for multiple selection case see setSelectionDraggable
              $(selectedItems[0]).removeClass('oj-draggable');
            }
          }
        } else {
          dragger = item;
        }
      }

      if (dragger != null) {
        dragger.attr('draggable', true);
      }
    }
  };

  /**
   * Unsets draggable attribute on either the item or affordance.
   * See HandleMouseUpOrPanMove method
   * @param {jQuery} target target from mouse up or touch end event
   * @private
   */
  ListViewDndContext.prototype._unsetDraggable = function (target) {
    if (this._getDragOptions() != null || this.IsItemReOrdering()) {
      var cls = this.GetDragAffordanceClass();
      var dragger;

      if (target.hasClass(cls)) {
        dragger = $(target);
      } else {
        dragger = this._findItem(target);
      }

      if (dragger != null) {
        dragger.removeAttr('draggable');
        this._unsetItemDraggable(dragger);
      }
    }
  };

  /**
   * Determine if drag and drop is currently in progress
   * @return {boolean} true if dnd is in progress, false otherwise
   */
  ListViewDndContext.prototype.isDndInProgress = function () {
    return this.m_dragImage != null;
  };
  /** ********************************* Drag and drop handler ***********************************************/
  /**
   * Invoke user callback function specified in a drag or drop option
   * @param {string} dndType  the dnd option type ('drag' or 'drop')
   * @param {string} callbackType  the callback type such as 'dragStart'
   * @param {Event} event  the jQuery Event object from drag and drop event
   * @param {Object} [ui]  additional properties to pass to callback function
   * @return {boolean|undefined|number} the return value from the callback function, returns -1 if there's no callback function
   * @private
   */
  ListViewDndContext.prototype._invokeDndCallback = function (dndType, callbackType, event, ui) {
    var returnValue;

    var options = dndType === 'drag' ? this._getDragOptions() : this._getDropOptions();
    if (options) {
      // First let the callback decide if data can be accepted
      var callback = options[callbackType];
      if (callback && typeof callback === 'function') {
        try {
          if (this.listview.ojContext._IsCustomElement()) {
            // For custom element, pass original DOM event and ignore return value.
            callback(event.originalEvent, ui);

            // preventDefault is called on the original event
            if (event.originalEvent.defaultPrevented) {
              event.preventDefault();
            }
          } else {
            // Hoist dataTransfer object from DOM event to jQuery event
            // eslint-disable-next-line no-param-reassign
            event.dataTransfer = event.originalEvent.dataTransfer;

            // Invoke callback function
            returnValue = callback(event, ui);
          }
        } catch (e) {
          Logger.error('Error: ' + e);
        }
      } else {
        returnValue = -1;
      }
    } else {
      returnValue = -1;
    }

    return returnValue;
  };

  /**
   * Sets the data and drag image on the data transfer object
   * @param {Event} event  the jQuery Event object from drag and drop event
   * @param {Array.<string>} dataTypes the datatypes specified in option
   * @param {Array.<Element>} items an array of item elements
   * @private
   */
  ListViewDndContext.prototype._setDragItemDataTransfer = function (event, dataTypes, items) {
    var itemDataArray = [];

    for (var i = 0; i < items.length; i++) {
      var data = this.listview._getDataForItem(items[i]);
      if (data) {
        // for Elements we'll use the the inner HTML in data transfer
        // prettier-ignore
        if (data.innerHTML && data.tagName && data.tagName === 'LI') { // @HTMLUpdateOK
          itemDataArray.push(data.innerHTML); // @HTMLUpdateOK
        } else {
          itemDataArray.push(data);
        }
      }
    }

    // Use the row data array as drag data and create drag image
    if (itemDataArray.length > 0) {
      this._setDragItemData(event.originalEvent, dataTypes, itemDataArray);
      this.SetDragItemImage(event.originalEvent, items);

      return { items: itemDataArray };
    }

    return null;
  };

  /**
   * Set the data of the selected rows into the dataTransfer object
   * @param {Event} nativeEvent  DOM event object
   * @param {string | Array.<string>} dataTypes  a data type or array of data types
   * @param {Array.<Object>} itemDataArray  array of row data
   * @private
   */
  ListViewDndContext.prototype._setDragItemData = function (nativeEvent, dataTypes, itemDataArray) {
    var dataTransfer = nativeEvent.dataTransfer;
    var jsonStr = JSON.stringify(itemDataArray);

    if (typeof dataTypes === 'string') {
      dataTransfer.setData(dataTypes, jsonStr);
    } else if (dataTypes) {
      for (var i = 0; i < dataTypes.length; i++) {
        dataTransfer.setData(dataTypes[i], jsonStr);
      }
    }

    // tag datatransfer so we could determine whether this is dnd within same listview
    dataTransfer.setData(this.GetDragSourceType(), this.listview.element.get(0).id);
  };

  /**
   * Creates the drag image element
   * @private
   */
  ListViewDndContext.prototype._createDragImage = function () {
    var dragImage = document.createElement('ul');
    dragImage.className = this.listview.element.get(0).className;
    dragImage.classList.add(this.GetDragImageClass());

    if (this.listview.ojContext._IsCustomElement()) {
      var predefined = ['oj-component', 'oj-complete'].concat(
        this.listview.GetContainerStyleClass().split(' ')
      );
      this.listview
        .GetRootElement()
        .get(0)
        .classList.forEach(function (name) {
          if (predefined.indexOf(name) === -1) {
            dragImage.classList.add(name);
          }
        });
    }

    return dragImage;
  };

  ListViewDndContext.prototype._calculateOffset = function (elem) {
    var style = window.getComputedStyle(elem);
    var offset =
      parseFloat(style.marginLeft) +
      parseFloat(style.marginRight) +
      parseFloat(style.paddingLeft) +
      parseFloat(style.paddingRight) +
      parseFloat(style.borderLeftWidth) +
      parseFloat(style.borderRightWidth);

    return offset;
  };

  ListViewDndContext.prototype._calculateAffordanceOffset = function (item, affordance) {
    if (this.m_cachedOffset == null) {
      this.m_cachedOffset =
        Math.max(0, affordance.offsetLeft - item.offsetLeft) + affordance.offsetWidth / 2;

      var isCardLayout = this.listview.isCardLayout();
      var isRtl = this.listview.ojContext._GetReadingDirection() === 'rtl';
      var itemOffset = this._calculateOffset(item);
      if (isCardLayout && isRtl) {
        itemOffset += this.listview.getListContainer().get(0).offsetWidth;
      }
      var listviewOffset = this._calculateOffset(this.listview.getListContainer().get(0));
      this.m_cachedOffset += Math.max(listviewOffset, itemOffset - listviewOffset);
    }

    return this.m_cachedOffset;
  };

  /**
   * Create and sets the drag image into the dataTransfer object
   * @param {Event} nativeEvent  DOM event object
   * @param {Array.<Element>} items array of row data
   * @protected
   */
  ListViewDndContext.prototype.SetDragItemImage = function (nativeEvent, items) {
    var dragImage;
    var offsetTop;
    var clone;
    var left = 0;
    var top = 0;
    var target = nativeEvent.target;
    var isCardLayout = this.listview.isCardLayout();

    if (items.length > 1) {
      dragImage = $(this._createDragImage());
      dragImage.css({
        width: this.listview.element.css('width'),
        height: this.listview.element.css('height')
      });

      var i;
      var minTop = Number.MAX_VALUE;

      // need to figure out which is the top item
      for (i = 0; i < items.length; i++) {
        minTop = Math.min(minTop, items[i].offsetTop);
      }

      // now construct the drag image
      for (i = 0; i < items.length; i++) {
        offsetTop = items[i].offsetTop - minTop;
        var offsetWidth = items[i].offsetWidth;
        clone = $(items[i].cloneNode(true));
        clone.removeClass('oj-selected oj-focus oj-hover').css({
          position: 'absolute',
          top: offsetTop,
          width: offsetWidth
        });
        if (!isCardLayout) {
          clone.addClass('oj-listview-item-drag-image');
        }
        dragImage.append(clone); // @HTMLUpdateOK
      }
    } else {
      // calculate offset if drag on affordance
      if ($(target).hasClass(this.GetDragAffordanceClass())) {
        offsetTop = 0;
        if ($.contains(items[0], target.offsetParent)) {
          offsetTop = target.offsetTop;
        }

        left = this._calculateAffordanceOffset(items[0], target);
        top = offsetTop + target.offsetHeight / 2;
      } else {
        left = Math.max(0, nativeEvent.offsetX);
        top = Math.max(0, nativeEvent.offsetY);
      }

      clone = $(items[0].cloneNode(true));
      clone.removeClass('oj-selected oj-focus oj-hover').addClass('oj-drag');
      if (!isCardLayout) {
        clone.addClass('oj-listview-item-drag-image');
      }

      dragImage = $(this._createDragImage());
      dragImage
        .css({
          width: this.GetDragImageWidth(items[0]),
          height: items[0].offsetHeight * 2
        })
        .append(clone); // @HTMLUpdateOK
    }

    // copying class might not be sufficient since it could be on the custom element root
    if (isCardLayout) {
      dragImage.addClass('oj-listview-card-layout');
    }

    $('body').append(dragImage); // @HTMLUpdateOK
    this.m_dragImage = dragImage;
    nativeEvent.dataTransfer.setDragImage(dragImage.get(0), left, top);
  };

  /**
   * Returns the Drag image width. Need to be overriden by navlist.
   * @return {string} width
   * @protected
   */
  ListViewDndContext.prototype.GetDragImageWidth = function () {
    return this.listview.element.css('width');
  };

  /**
   * Returns the default data type. Need to be overriden by navlist
   * @return {string} the default data type
   * @protected
   */
  ListViewDndContext.prototype.GetDefaultDataType = function () {
    return 'text/ojlistview-items-data';
  };

  /**
   * Drag start event handler
   * @param {Event} event  jQuery event object
   * @return {boolean|number|undefined} a value passed back to jQuery.  Returning false will
   *         cause jQuery to call event.preventDefault and event.stopPropagation.
   *         Returning true or other values has no side effect.
   *         In the case of dragstart, returning false cancels the drag operation.
   * @private
   */
  ListViewDndContext.prototype._handleDragStart = function (event) {
    var options = this._getDragOptions();
    if (options != null || this.IsItemReOrdering()) {
      var dataTypes;
      if (options != null) {
        dataTypes = options.dataTypes;
      } else {
        dataTypes = this.GetDefaultDataType();
      }

      var items;
      if ($(event.target).hasClass(this.GetDragAffordanceClass()) || this.shouldDragCurrentItem()) {
        // if it's affordance then use event target
        items = [];
        items.push(this._findItem(event.target)[0]);
      } else {
        items = this._getSelectedItems(true);
      }

      if (items.length > 0) {
        this.m_dragItems = items;
        this.m_currentDragItem = $(items[0]);

        var ui = this._setDragItemDataTransfer(event, dataTypes, items);
        if (ui) {
          var ret = this._invokeDndCallback('drag', 'dragStart', event, ui);

          // dragStart is optional
          if (ret === -1) {
            return undefined;
          }

          // but if it's specified, it could abort drag by returning false
          return ret;
        }

        // no data, abort drag
        return false;
      }
    }

    // don't return anything since apps can register their own custom event handler
    return undefined;
  };

  /**
   * Drag event handler
   * @param {Event} event  jQuery event object
   * @private
   */
  ListViewDndContext.prototype._handleDrag = function (event) {
    // invoke callback
    return this._invokeDndCallback('drag', 'drag', event);
  };

  /**
   * Delete the drag image
   * @private
   */
  ListViewDndContext.prototype._destroyDragImage = function () {
    if (this.m_dragImage != null) {
      this.m_dragImage.remove();
      this.m_dragImage = null;
    }
  };

  /**
   * Drag end event handler
   * @param {Event} event  jQuery event object
   * @private
   */
  ListViewDndContext.prototype._handleDragEnd = function (event) {
    if (this.m_dragEndCallCheck) {
      window.cancelAnimationFrame(this.m_dragEndCallCheck);
      this.m_dragEndCallCheck = null;
    }

    // remove css class and make sure it's visible again
    if (this.m_currentDragItem != null && this.m_dragItems != null) {
      // for drag affordance case
      this.m_currentDragItem.find('.' + this.GetDragAffordanceClass()).removeAttr('draggable');

      this.m_currentDragItem.removeClass('oj-drag oj-draggable').removeAttr('draggable');

      for (var i = 0; i < this.m_dragItems.length; i++) {
        var dragItem = this.m_dragItems[i];
        dragItem.classList.remove('oj-listview-drag-source');
        dragItem.classList.remove(this.GetDragItemClass());
        $(dragItem).css('display', '');
      }
    }

    // remove drop target, if any
    this._cleanupDropTarget();

    // clean up drag image
    this._destroyDragImage();

    // remove style classes from selected items that were draggable
    this._unsetSelectionDraggable();

    // invoke callback
    this._invokeDndCallback('drag', 'dragEnd', event);

    // save dragItems for potential drop within same listview (reordering)
    this.m_itemsDragged = this.m_dragItems;

    // reset drag variables (except this.m_dragItems)
    this.m_dragImage = null;
    this.m_currentDragItem = null;
    this.m_dragItems = null;

    // focus should now be at document body, restore focus
    this.listview.restoreFocusAfterDrag();
  };

  /**
   * Return true if the data types from dnd event match one of the values in an array
   * @param {Event} event  jQuery event object for a drag and drop event
   * @return {boolean} true if one of the types in dragDataTypes and allowedTypes matches
   * @private
   */
  ListViewDndContext.prototype._matchDragDataType = function (event) {
    var options = this._getDropOptions();
    if (options && options.dataTypes) {
      var allowedTypes = options.dataTypes;
      var allowedTypeArray = typeof allowedTypes === 'string' ? [allowedTypes] : allowedTypes;

      // dragDataTypes can be either an array of strings (Chrome) or a
      // DOMStringList (Firefox and IE).  For cross-browser compatibility, use its
      // length and index to traverse it.
      var dragDataTypes = event.originalEvent.dataTransfer.types;
      for (var i = 0; i < dragDataTypes.length; i++) {
        if (allowedTypeArray.indexOf(dragDataTypes[i]) >= 0) {
          return true;
        }
      }
    }

    return false;
  };

  /**
   * Invoke user callback function specified in a drop option
   * @param {string} callbackType  the callback type such as 'dragStart'
   * @param {Event} event  the jQuery Event object from drag and drop event
   * @param {Object} [ui]  additional properties to pass to callback function
   * @return {boolean|undefined|number} the return value from the callback function, returns -1 if there is no callback function
   * @private
   */
  ListViewDndContext.prototype._invokeDropCallback = function (callbackType, event, ui) {
    var returnValue = this._invokeDndCallback('drop', callbackType, event, ui);
    if (returnValue === undefined || returnValue === -1) {
      if (this._matchDragDataType(event)) {
        event.preventDefault();
      }
    }

    return returnValue;
  };

  /**
   * @private
   */
  ListViewDndContext.prototype._getDropIndicator = function () {
    return this.m_dragItems != null ? 'space' : 'line';
  };

  /**
   * Create drop target based on item
   * @param {jQuery} item the item to create drop target based on
   * @return {jQuery} the drop target
   * @private
   */
  ListViewDndContext.prototype._createDropTarget = function (item) {
    var type = this._getDropIndicator();

    if (this.m_dropTarget == null) {
      var dropTarget;
      if (type === 'space') {
        dropTarget = $(item.get(0).cloneNode(false));
        dropTarget.addClass('oj-drop').removeClass('oj-drag oj-draggable oj-hover oj-focus').css({
          display: 'block',
          height: item.outerHeight(),
          width: item.outerWidth()
        });
      } else if (type === 'line') {
        dropTarget = document.createElement('li');
        dropTarget.classList.add('oj-listview-drop-target');
      }

      this.m_dropTarget = $(dropTarget);
    }

    var elem = item.get(0);
    if (type === 'line') {
      elem.classList.add('oj-drop');
      if (this.m_dropTargetElem != null) {
        this.m_dropTargetElem.classList.remove('oj-drop');
      }
      this.m_dropTargetElem = elem;
      var top = elem.offsetTop + elem.offsetHeight - this._getDropIndicatorHeight();
      // if it's the last item and gridlines are visible, need to make an adjustment
      if (elem.nextElementSibling == null && this.listview._isGridlinesVisible()) {
        top -= 1;
      }
      this.m_dropTarget.get(0).style.top = top + 'px';
    } else if (type === 'space') {
      this.m_dropTarget.get(0).key = elem.key;
    }

    return this.m_dropTarget;
  };

  /**
   * Gets and cached the height of the drop indicator
   * @private
   */
  ListViewDndContext.prototype._getDropIndicatorHeight = function () {
    if (!isNaN(this.m_dropIndicatorHeight)) {
      return this.m_dropIndicatorHeight;
    }

    if (this.m_dropTarget) {
      var dropIndicator = this.m_dropTarget.get(0);
      this.listview.element.get(0).appendChild(dropIndicator);
      this.m_dropIndicatorHeight = dropIndicator.offsetHeight;
      if (this.listview._isGridlinesVisible()) {
        this.m_dropIndicatorHeight -= 1;
      }
      return this.m_dropIndicatorHeight;
    }
    return 0;
  };

  /**
   * Clean up group item drop target artifacts
   * @private
   */
  ListViewDndContext.prototype._cleanupGroupItem = function () {
    // for group item
    if (this.m_currentDropItem != null && this.m_dropTargetIndex === -1) {
      this.m_currentDropItem
        .children('.' + this.listview.getGroupItemStyleClass())
        .removeClass('oj-drop');
    }
  };

  /**
   * Clean up for the case of empty list
   * @private
   */
  ListViewDndContext.prototype._cleanupEmptyList = function () {
    // if it's drop on an empty list
    if (
      this.m_currentDropItem != null &&
      this.m_currentDropItem.hasClass(this.listview.getEmptyTextStyleClass())
    ) {
      this.m_currentDropItem.removeClass('oj-drop');
      this.m_currentDropItem.get(0).textContent = this.listview._getEmptyText();
    }
  };

  /**
   * Clean up drop target artifacts
   * @private
   */
  ListViewDndContext.prototype._cleanupDropTarget = function () {
    if (this.m_dropTarget != null) {
      this.m_dropTarget.css('height', '0');
      this.m_dropTarget.remove();
      this.m_dropTarget = null;
    }

    if (this.m_dropTargetElem != null) {
      this.m_dropTargetElem.classList.remove('oj-drop');
    }

    if (this.m_firstDropTarget != null) {
      if (this.m_firstDropTarget.parentNode) {
        this.m_firstDropTarget.parentNode.removeChild(this.m_firstDropTarget);
      }
      this.m_firstDropTarget = null;
    }

    this._cleanupEmptyList();
    this._cleanupGroupItem();
  };

  /**
   * Drag enter event handler
   * @param {Event} event  jQuery event object
   * @private
   */
  ListViewDndContext.prototype._handleDragEnter = function (event) {
    var item = this._findItem(event.target);
    if (item != null && item.length > 0) {
      var returnValue = this._invokeDropCallback('dragEnter', event, { item: item.get(0) });
      if (returnValue !== -1) {
        return returnValue;
      }
    }
    return undefined;
  };

  /**
   * Sets the current drop item
   * @param {jQuery} item the item to set as current drop item
   * @private
   */
  ListViewDndContext.prototype._setCurrentDropItem = function (item) {
    if (this.m_currentDropItem != null) {
      this.m_currentDropItem.removeClass('oj-valid-drop oj-invalid-drop');
    }

    this.m_currentDropItem = item;
    this.m_currentDropItem.addClass('oj-valid-drop');
  };

  /**
   * Sets the accessible text according to the drop position
   * @param {jQuery} item the drop target reference
   * @param {string} position either 'before' or 'after'
   * @private
   */
  ListViewDndContext.prototype._setAccInfo = function (item, position) {
    // we'll see if there is a label associated with the item, if not, look for text inside the item
    var label = item.attr('aria-label');
    if (label == null) {
      label = item.text();
    }

    var key = 'accessibleReorder' + position.charAt(0).toUpperCase() + position.substr(1) + 'Item';
    var msg = this.listview.ojContext.getTranslatedString(key, { item: label });
    this.listview._setAccInfoText(msg);
  };

  /**
   * Adjust the max height of group item
   * @private
   */
  ListViewDndContext.prototype._adjustGroupItemStyle = function () {
    // for touch we'll need to remove max height set
    if (this.m_maxHeightAdjusted == null && this.listview._isTouchSupport()) {
      this.listview.element.find('ul.' + this.listview.getGroupStyleClass()).each(function () {
        $(this).attr('oldMaxHeight', $(this).css('maxHeight').toString());
        $(this).css('maxHeight', 10000);
      });

      this.m_maxHeightAdjusted = 'adjusted';
    }
  };

  /**
   * Reverse of _adjustGroupItemStyle
   * @private
   */
  ListViewDndContext.prototype._restoreGroupItemStyle = function () {
    if (this.listview._isTouchSupport()) {
      this.listview.element.find('ul.' + this.listview.getGroupStyleClass()).each(function () {
        $(this).css('maxHeight', parseInt($(this).attr('oldMaxHeight'), 10));
        $(this).removeAttr('oldMaxHeight');
      });
    }

    this.m_maxHeightAdjusted = null;
  };

  /**
   * Sets/updates the drop position
   * @private
   */
  ListViewDndContext.prototype._setDropPosition = function (item, dropTarget) {
    var type = this._getDropIndicator();

    if (type === 'line') {
      dropTarget.insertAfter(item); // @HTMLUpdateOK
      return 'after';
    }

    var index = item.index();
    if (this.m_dropTargetIndex == null || this.m_dropTargetIndex < index) {
      dropTarget.insertAfter(item); // @HTMLUpdateOK
      return 'after';
    }

    dropTarget.insertBefore(item); // @HTMLUpdateOK
    return 'before';
  };

  /**
   * Handles the special case of inserting before the first item (at root or in group node)
   * @private
   */
  ListViewDndContext.prototype._checkFirstItemDropTarget = function (item, dropTarget, target) {
    if (target.classList.contains('oj-listview-first-drop-target')) {
      // in the top drop area
      this.m_dropPosition = 'before';
      // eslint-disable-next-line no-param-reassign
      dropTarget.style.top = '0px';
      return;
    }

    if (this._getDropIndicator() === 'line') {
      if (item.previousElementSibling === null) {
        // first item
        if (this.m_firstDropTarget == null) {
          var topDropTarget = document.createElement('li');
          topDropTarget.classList.add('oj-listview-first-drop-target');
          topDropTarget.style.top = '0px';
          item.parentNode.appendChild(topDropTarget);
          this.m_firstDropTarget = topDropTarget;
        } else {
          // first item, but not in the top drop area
          this.m_dropPosition = 'after';
          // eslint-disable-next-line no-param-reassign
          dropTarget.style.top =
            item.offsetTop + item.offsetHeight - this._getDropIndicatorHeight() + 'px';
        }
      } else if (this.m_firstDropTarget) {
        // not the first item, remove any first drop target artifacts
        if (this.m_firstDropTarget.parentNode) {
          this.m_firstDropTarget.parentNode.removeChild(this.m_firstDropTarget);
        }
        this.m_firstDropTarget = null;
      }
    }
  };

  /**
   * Return true if the drop target is the same as the drag item from the same ListView
   */
  ListViewDndContext.prototype._isDropOnDragItem = function (event, item) {
    // key equality test is fine if they are really from the same element reference
    return (
      this._matchDragDataType(event) &&
      this.m_dragItems != null &&
      this.m_dragItems.length >= 0 &&
      this.m_dragItems[0].key === item.get(0).key
    );
  };

  /**
   * Drag over event handler
   * @param {Event} event  jQuery event object
   * @private
   */
  ListViewDndContext.prototype._handleDragOver = function (event) {
    var item;
    var dropTarget;
    var returnValue;

    // do any neccessary group item
    this._adjustGroupItemStyle();

    // checks whether this is initially dragging over the drag item
    if (this.m_dragItems != null && $(this.m_dragItems[0]).css('display') !== 'none') {
      // take out the current drag item and create drop target
      item = $(this.m_dragItems[0]);

      // this will check for matching data types
      returnValue = this._invokeDropCallback('dragOver', event, { item: item.get(0) });

      // note drop is allowed in the case where reordering is enabled and drag source is itself, but only if there's no dragOver callback
      // to prevent the drop
      if (
        (returnValue === -1 && this.IsItemReOrdering() && this.isDndInProgress()) ||
        returnValue === false ||
        event.isDefaultPrevented()
      ) {
        dropTarget = this._createDropTarget(item);

        for (var i = 0; i < this.m_dragItems.length; i++) {
          // we have to override inline style instead of doing it inside style class since
          // custom style class could override it
          $(this.m_dragItems[i]).addClass(this.GetDragItemClass()).css('display', 'none');
        }

        dropTarget.insertBefore(item); // @HTMLUpdateOK
        this.m_dropTargetIndex = dropTarget.index();
      } else {
        // not reorder or dnd within ListView, so apply dnd across collection styling
        item.get(0).classList.remove('oj-hover');
        item.get(0).classList.add('oj-listview-drag-source');
      }
    } else {
      // if drag over callback allows drop or if it's item reordering
      item = this._findItem(event.target);
      if (item != null && item.length > 0) {
        // check if drop over the same item in the same listview
        if (this._isDropOnDragItem(event, item)) {
          // do not call _invokeDropCallback as it will call preventDefault if it's the same type
          returnValue = this._invokeDndCallback('drop', 'dragOver', event, { item: item.get(0) });
          if (!event.isDefaultPrevented()) {
            // if callback did not explicitly allow drop, we can bail here
            return -1;
          }
        } else {
          // this will check for matching data types
          returnValue = this._invokeDropCallback('dragOver', event, { item: item.get(0) });
        }

        // note drop is allowed in the case where reordering is enabled and drag source is itself, but only if there's no dragOver callback
        // to prevent the drop
        if (
          (returnValue === -1 && this.IsItemReOrdering() && this.isDndInProgress()) ||
          returnValue === false ||
          event.isDefaultPrevented()
        ) {
          // if it is non-group item
          if (item.hasClass(this.listview.getItemStyleClass())) {
            this._cleanupGroupItem();

            // if a drop target has not been created for this item
            if (!item.hasClass('oj-drop')) {
              dropTarget = this._createDropTarget(item);
              this.m_dropPosition = this._setDropPosition(item, dropTarget);
              this._setAccInfo(item, this.m_dropPosition);
              this._setCurrentDropItem(item);
              this.m_dropTargetIndex = dropTarget.index();
            } else {
              dropTarget = this.m_dropTarget;
            }
            // handle special case for first item (root or in a group)
            this._checkFirstItemDropTarget(item.get(0), dropTarget.get(0), event.target);
          } else {
            // there won't be a drop target placeholder, remove any previous ones
            this._cleanupDropTarget();

            // for group item
            item.children('.' + this.listview.getGroupItemStyleClass()).addClass('oj-drop');
            this._setCurrentDropItem(item);
            this.m_dropTargetIndex = -1;
            this.m_dropPosition = 'inside';
            this._setAccInfo(item, this.m_dropPosition);
          }
          event.preventDefault();
        } else if (!$(event.target).hasClass(this.listview.getGroupStyleClass())) {
          // don't remove the drop target if we have inside the empty area of the list of a group item
          // this happens mostly in card layout view
          // not a valid drop target
          item.addClass('oj-invalid-drop');

          // remove any drop target placeholder
          this._cleanupDropTarget();
        }
      } else {
        // drop on an empty list
        var emptyItem = this._getAndUpdateEmptyItem();
        if (emptyItem != null && emptyItem.length > 0) {
          this._setCurrentDropItem(emptyItem);
          event.preventDefault();
        }
      }
    }

    return returnValue;
  };

  /**
   * @private
   */
  ListViewDndContext.prototype._getAndUpdateEmptyItem = function () {
    var emptyItem = this.listview.element.children('.' + this.listview.getEmptyTextStyleClass());
    if (emptyItem.length === 0) {
      emptyItem = $(this.listview.element[0].querySelector('.oj-listview-no-data-item'));
    } else {
      emptyItem.get(0).textContent = '';
    }
    emptyItem.addClass('oj-drop');
    return emptyItem;
  };

  /**
   * Return true if the mouse/touch point of a dnd event is in an element.
   * This is identical to _isDndEventInElement in TableDndContext.js
   * @param {Event} event  jQuery event object
   * @param {EventTarget} element  DOM element
   * @return {boolean} whether mouse/touch point is in an element
   */
  ListViewDndContext.prototype._isDndEventInElement = function (event, element) {
    var rect = element.getBoundingClientRect();
    var domEvent = event.originalEvent;

    // clientX and clientY are only available on the original DOM event
    return (
      domEvent.clientX >= rect.left &&
      domEvent.clientX < rect.right &&
      domEvent.clientY >= rect.top &&
      domEvent.clientY < rect.bottom
    );
  };

  /**
   * Drag leave event handler
   * @param {Event} event  jQuery event object
   * @private
   */
  ListViewDndContext.prototype._handleDragLeave = function (event) {
    var returnValue;

    if (this.m_currentDropItem == null) {
      return undefined;
    }

    var item = this._findItem(event.target);
    if (item != null && item.length > 0) {
      item.removeClass('oj-valid-drop oj-invalid-drop');

      returnValue = this._invokeDropCallback('dragLeave', event, { item: item.get(0) });

      // Remove the drop target indicator if we are no longer in listview since
      // this may be the last dnd event we get.
      if (!this._isDndEventInElement(event, event.currentTarget) && item.hasClass('oj-drop')) {
        this._cleanupDropTarget();
        this._restoreGroupItemStyle();
      }
    } else if (!this._isDndEventInElement(event, event.currentTarget)) {
      // empty list case
      this._cleanupEmptyList();
    }

    if (returnValue !== -1) {
      return returnValue;
    }
    return undefined;
  };

  /**
   * @private
   */
  ListViewDndContext.prototype._isEmptyItem = function (item) {
    return (
      item.hasClass(this.listview.getEmptyTextStyleClass()) ||
      item.hasClass('oj-listview-no-data-item')
    );
  };

  /**
   * Drop event handler
   * @param {Event} event  jQuery event object
   * @private
   */
  ListViewDndContext.prototype._handleDrop = function (event) {
    if (this.m_currentDropItem == null) {
      return undefined;
    }

    var source = event.originalEvent.dataTransfer.getData(this.GetDragSourceType());

    // invoke callback
    var ui;
    if (this._isEmptyItem(this.m_currentDropItem)) {
      ui = {};
    } else {
      ui = { item: this.m_currentDropItem.get(0), position: this.m_dropPosition };
    }

    // add the reorder param
    if (this.IsItemReOrdering() && source === this.listview.element.get(0).id) {
      ui.reorder = true;
    } else {
      ui.reorder = false;
    }

    // cleanup artifacts before firing events
    if (this.m_currentDropItem != null) {
      this.m_currentDropItem.removeClass('oj-valid-drop');
    }
    this._cleanupDropTarget();
    this._restoreGroupItemStyle();
    this._destroyDragImage();

    // fire drop event
    var returnValue = this._invokeDropCallback('drop', event, ui);

    // fire reorder event
    if (ui.reorder) {
      // the order in which dragEnd and drop event is called is inconsistent, hence the check
      // Always we should check for this.m_dragItems as it will be null only if dragend already invoked
      // and items are copied to this.m_itemsDragged.
      ui.items = this.m_dragItems == null ? this.m_itemsDragged : this.m_dragItems;

      this.listview.Trigger(
        'reorder',
        event,
        this.CreateReorderPayload(ui.items, ui.position, ui.item)
      );

      // the drop should be complete regardless the value of callback
      event.preventDefault();

      // this is to ensure the handleDragEnd is invoked.  On Chrome, the dragEnd event handler
      // is not called if the scroll position of the source has changed.
      this.m_dragEndCallCheck = window.requestAnimationFrame(() => {
        if (this.m_currentDragItem) {
          this._handleDragEnd(event);
        }
      });
    }

    // reset drop variables
    this.m_currentDropItem = null;
    this.m_dropTargetIndex = -1;
    this.m_dropPosition = null;
    this.m_itemsDragged = null;

    if (returnValue === -1) {
      return undefined;
    }

    return returnValue;
  };

  /**
   * Returns payload object for reorder event. Navlist overrides this.
   * @param {Array} items, items to be moved.
   * @param {string} position, the drop position relative to the reference item.
   * @param {Element} reference, the item where the moved items are drop on.
   * @returns {Object} payload object
   * @protected
   */
  ListViewDndContext.prototype.CreateReorderPayload = function (items, position, reference) {
    return {
      items: items,
      position: position,
      reference: reference
    };
  };

  /** ********************************* Context menu ***********************************************/
  /**
   * Prepares the context menu before it is opened.  Invoked by notifyContextMenuGesture.
   * @param {Element} contextMenu the context menu root element
   */
  ListViewDndContext.prototype.prepareContextMenu = function (contextMenu) {
    var self = this;

    var menuContainer = $(contextMenu);
    if (this.m_contextMenu !== contextMenu) {
      this.m_contextMenu = contextMenu;

      if (contextMenu.tagName === 'OJ-MENU') {
        contextMenu.addEventListener('ojBeforeOpen', this._handleContextMenuBeforeOpen.bind(this));
        contextMenu.addEventListener('ojAction', this._handleContextMenuSelect.bind(this));
      } else {
        menuContainer.on('ojbeforeopen', this._handleContextMenuBeforeOpen.bind(this));
        menuContainer.on('ojselect', this._handleContextMenuSelect.bind(this));
      }
    }

    var menuItemsSet = this._getCommands(contextMenu, function (menuItem, command) {
      var newListItem = self._buildContextMenuItem(command, menuItem.tagName);
      if (menuItem.tagName === 'OJ-OPTION') {
        // eslint-disable-next-line no-param-reassign
        menuItem.innerHTML = newListItem.get(0).innerHTML; // @HTMLUpdateOK
        $(menuItem).attr('data-oj-command', newListItem.attr('data-oj-command'));
      } else {
        newListItem.get(0).className = $(menuItem).get(0).className;
        $(menuItem).replaceWith(newListItem); // @HTMLUpdateOK
      }
    });

    // this keeps track of which menu items were generated by the listview dynamically
    // this way on a refresh we know to recreate them in case there was a locale or
    // translations change
    this.m_menuItemsSet = menuItemsSet;

    if (menuItemsSet.length > 0) {
      if (menuContainer.data('oj-ojMenu')) {
        if (contextMenu.tagName === 'OJ-MENU') {
          contextMenu.refresh();
        } else {
          $(contextMenu).ojMenu('refresh');
        }
      }
    }
  };

  /**
   * Returns selector to extract only the context menu items with valid commands.
   * Navlist has remove menu item which needs to be ignored by listview.
   * @returns {string} jquery selector string.
   */
  ListViewDndContext.prototype._getDndContextMenuItemSelector = function () {
    var self = this;
    var query = '';
    var commands = [
      'cut',
      'copy',
      'paste',
      'paste-before',
      'paste-after',
      'pasteBefore',
      'pasteAfter'
    ];

    if (!this.m_dndMenuItemSelector) {
      commands.forEach(function (command, index) {
        query += '[data-oj-command=' + self.GetCommandPrefix() + command + '],';
        query += '[data-oj-command=' + command + ']';
        if (index < commands.length - 1) {
          query += ',';
        }
      });
      this.m_dndMenuItemSelector = query;
    }
    return this.m_dndMenuItemSelector;
  };

  /**
   * Retrieves a list of commands from the context menu.
   * @param {Element} contextMenu the context menu element
   * @param {function(Element, string)=} callback the function to invoke on each menu item found
   * @return {Array} a list of commands
   * @private
   */
  ListViewDndContext.prototype._getCommands = function (contextMenu, callback) {
    var self = this;
    var capabilities = [];
    var listItems = $(contextMenu).find(this._getDndContextMenuItemSelector());
    listItems.each(function () {
      var command;
      var anchor = $(this).children('a');

      if (anchor.length === 0) {
        if ($(this).attr('data-oj-command').indexOf(self.GetCommandPrefix()) === 0) {
          command = $(this).attr('data-oj-command').substring(self.GetCommandPrefix().length);
          if (callback) {
            callback(this, command);
          }
        }
      } else {
        command = $(this).attr('data-oj-command');

        // mapping for paste
        if (command === ListViewDndContext.PASTE_BEFORE_COMMAND) {
          command = 'paste-before';
        } else if (command === ListViewDndContext.PASTE_AFTER_COMMAND) {
          command = 'paste-after';
        }
      }

      if (command) {
        capabilities.push(command);
      }
    });

    return capabilities;
  };

  /**
   * Builds a menu for a command, takes care of submenus where appropriate
   * @param {string} command the command that the listview should build a menu item for
   * @param {string} tagName to use to create the menu item
   * @private
   */
  ListViewDndContext.prototype._buildContextMenuItem = function (command, tagName) {
    if (command === 'paste-before') {
      return this._buildContextMenuListItem(ListViewDndContext.PASTE_BEFORE_COMMAND, tagName);
    } else if (command === 'paste-after') {
      return this._buildContextMenuListItem(ListViewDndContext.PASTE_AFTER_COMMAND, tagName);
    }

    return this._buildContextMenuListItem(command, tagName);
  };

  /**
   * Builds a context menu list item from a command
   * @param {string} command the string to look up command value for as well as translation
   * @param {string} tagName to use to create the menu item
   * @return {Object} a jQuery object with HTML containing a list item
   * @private
   */
  ListViewDndContext.prototype._buildContextMenuListItem = function (command, tagName) {
    var listItem = $(document.createElement(tagName)); // @HTMLUpdateOK
    listItem.attr('data-oj-command', command);
    listItem.append(this._buildContextMenuLabel(command, tagName === 'OJ-OPTION')); // @HTMLUpdateOK
    return listItem;
  };

  /**
   * Builds a context menu label by looking up command translation
   * @param {string} command the string to look up translation for
   * @param {boolean=} useOjOption whether oj-option tag should be used
   * @return {jQuery|string} a jQuery object with HTML containing a label
   * @private
   */
  ListViewDndContext.prototype._buildContextMenuLabel = function (command, useOjOption) {
    // convert to the translation key convention
    var key = 'label' + command.charAt(0).toUpperCase() + command.slice(1);
    var textNode = document.createTextNode(this.listview.ojContext.getTranslatedString(key));

    // for custom elements, no <a> tag is required
    if (useOjOption) {
      return textNode;
    }
    return $('<a href="#"></a>').append(textNode); // @HTMLUpdateOK
  };

  /**
   * Handles cut action
   * @param {Event} event jQuery event
   * @private
   */
  ListViewDndContext.prototype._handleCut = function (event) {
    // first restore style of any previously cut items
    if (this.m_clipboard != null) {
      $(this.m_clipboard).removeClass(this.GetCutStyleClass());
    }

    var items = this.GetCutItems(event);
    // focus should be moved back to listview after context menu is closed
    this.listview.ojContext.element.focus();
    $(items).addClass(this.GetCutStyleClass());
    this.m_clipboard = items;

    // fire cut event
    this.listview.Trigger('cut', event, { items: items });
  };

  /**
   * Returns cut items. Navlist overrides this.
   * @param {Event} event jQuery event
   * @returns {Array} array of items to be moved
   */
  // eslint-disable-next-line no-unused-vars
  ListViewDndContext.prototype.GetCutItems = function (event) {
    return this._getSelectedItems();
  };

  /**
   * Handles copy action
   * @param {Event} event jQuery event
   * @private
   */
  ListViewDndContext.prototype._handleCopy = function (event) {
    // first restore style of any previously cut items
    if (this.m_clipboard != null) {
      $(this.m_clipboard).removeClass(this.GetCutStyleClass());
    }

    var items = this._getSelectedItems();
    this.m_clipboard = items;

    // fire cut event
    this.listview.Trigger('copy', event, { items: items });
  };

  /**
   * Handles paste action
   * @param {Event} event jQuery event
   * @param {jQuery} item the reference item of the paste
   * @param {string} position either before/after/inside
   * @private
   */
  ListViewDndContext.prototype._handlePaste = function (event, item, position) {
    // fire paste event
    this.listview.Trigger('paste', event, { item: item.get(0) });

    // restore cut item style
    $(this.m_clipboard).removeClass(this.GetCutStyleClass());

    // fire reorder event
    this.listview.Trigger(
      'reorder',
      event,
      this.CreateReorderPayload(this.m_clipboard, position, /** @type {Element} */ (item.get(0)))
    );

    // clear the clipboard
    this.m_clipboard = null;
  };

  /**
   * Select handler for context menu items
   * @param {Event} event jQuery event object
   * @param {Object=} ui additional info from event
   * @private
   */
  ListViewDndContext.prototype._handleContextMenuSelect = function (event, ui) {
    // should never happen
    if (this.m_contextMenuItem == null) {
      return;
    }

    var item = ui ? ui.item : $(event.target);
    switch (item.attr('data-oj-command')) {
      case ListViewDndContext.CUT_COMMAND:
        this._handleCut(event);
        break;

      case ListViewDndContext.COPY_COMMAND:
        this._handleCopy(event);
        break;

      case ListViewDndContext.PASTE_COMMAND:
        this._handlePaste(event, this.m_contextMenuItem, 'inside');

        // cleanup
        this.m_contextMenuItem = null;
        break;

      case ListViewDndContext.PASTE_BEFORE_COMMAND:
        this._handlePaste(event, this.m_contextMenuItem, 'before');

        // cleanup
        this.m_contextMenuItem = null;
        break;

      case ListViewDndContext.PASTE_AFTER_COMMAND:
        this._handlePaste(event, this.m_contextMenuItem, 'after');

        // cleanup
        this.m_contextMenuItem = null;

        break;

      default:
        break;
    }
  };

  /**
   * Append or show menu item based on command
   * @param {jQuery} menuContainer the menu container
   * @param {string} command the command of the menu item
   * @private
   */
  ListViewDndContext.prototype._appendToMenuContainer = function (menuContainer, command) {
    // whether default context menu is used
    if (this.m_menuItemsSet != null) {
      if (command === 'paste-before') {
        // eslint-disable-next-line no-param-reassign
        command = ListViewDndContext.PASTE_BEFORE_COMMAND;
      } else if (command === 'paste-after') {
        // eslint-disable-next-line no-param-reassign
        command = ListViewDndContext.PASTE_AFTER_COMMAND;
      }

      // show the menu item
      menuContainer.find("[data-oj-command='" + command + "']").removeClass('oj-disabled');
    }
  };

  /**
   * Before open handler so that ListView can customize content of context menu based on item
   * @param {Event} event jQuery event object
   * @param {Object=} ui ui object
   * @private
   */
  ListViewDndContext.prototype._handleContextMenuBeforeOpen = function (event, ui) {
    var item;
    var posOf = ui ? ui.openOptions.position.of : event.detail.openOptions.position.of;
    if (posOf) {
      if (posOf.target) {
        // mouse case
        item = this.listview.FindItem(posOf.target);
      } else if (posOf.hasClass && posOf.hasClass(this.listview.getItemStyleClass())) {
        // keyboard case
        item = posOf;
      }
    }

    if (!this.IsItemReOrdering()) {
      this.m_contextMenuItem = item;
      return;
    }

    var menuContainer = $(event.target);

    // disable all menu items first, needs to be done even if there's no default menu items since
    // there could be one from before refresh
    menuContainer.find(this._getDndContextMenuItemSelector()).addClass('oj-disabled');

    if (item == null || this.m_menuItemsSet == null || this.m_menuItemsSet.length === 0) {
      // refresh to take effect
      if (menuContainer.get(0).tagName !== 'OJ-MENU') {
        menuContainer.ojMenu('refresh');
      }
      return;
    }

    // now add menu items
    if (item.children().first().hasClass(this.listview.getGroupItemStyleClass())) {
      // check if cut action was performed
      if (this.m_clipboard != null) {
        this._appendToMenuContainer(menuContainer, 'paste');
      }
    } else {
      this._appendToMenuContainer(menuContainer, 'cut');
      this._appendToMenuContainer(menuContainer, 'copy');
      // check if cut action was performed
      if (this.m_clipboard != null) {
        this._appendToMenuContainer(menuContainer, 'paste-before');
        this._appendToMenuContainer(menuContainer, 'paste-after');
      }
    }

    // refresh to take effect
    if (menuContainer.get(0).tagName !== 'OJ-MENU') {
      menuContainer.ojMenu('refresh');
    }

    this.m_contextMenuItem = item;
  };

  /**
   * Handles key down event
   * @param {Event} event the keydown event
   * @return {boolean} true if key event is handled, false otherwise
   * @private
   */
  ListViewDndContext.prototype.HandleKeyDown = function (event) {
    if (event.ctrlKey || event.metaKey) {
      var keyCode = event.keyCode;
      // quickly short circuit it if it's not one of the supported keys
      if (
        keyCode === ListViewDndContext.X_KEY ||
        keyCode === ListViewDndContext.C_KEY ||
        keyCode === ListViewDndContext.V_KEY
      ) {
        // capabilities depends on what's specified in context menu
        var contextMenu = this.listview.ojContext._GetContextMenu();
        if (contextMenu == null) {
          return false;
        }

        // no clipboard commands found
        var commands = this._getCommands(contextMenu);
        if (commands.length === 0) {
          return false;
        }

        if (keyCode === ListViewDndContext.X_KEY && commands.indexOf('cut') > -1) {
          this._handleCut(event);
          return true;
        } else if (keyCode === ListViewDndContext.C_KEY && commands.indexOf('copy') > -1) {
          this._handleCopy(event);
          return true;
        } else if (keyCode === ListViewDndContext.V_KEY) {
          var active = $(this._getActiveItem());
          if (this.m_clipboard != null) {
            var position;
            if (active.children().first().hasClass(this.listview.getGroupItemStyleClass())) {
              if (commands.indexOf('paste') > -1) {
                position = 'inside';
              }
            } else if (commands.indexOf('paste-before') > -1) {
              position = 'before';
            } else if (commands.indexOf('paste-after') > -1) {
              position = 'after';
            }

            if (position != null) {
              this._handlePaste(event, active, position);
              return true;
            }
          } else {
            this.listview.Trigger('paste', event, { item: active.get(0) });
          }
        }
      }
    }

    return false;
  };

  /**
   * Return true to drag current item. Need to be overriden by navlist.
   * @return {boolean} true to drag current item.
   * @private
   */
  ListViewDndContext.prototype.shouldDragCurrentItem = function () {
    return false;
  };

  /**
   * Returns drag source type. Need to be overriden by navlist.
   * @return {string} drag source type.
   * @private
   */
  ListViewDndContext.prototype.GetDragSourceType = function () {
    return 'text/ojlistview-dragsource-id';
  };

  exports.ListViewDndContext = ListViewDndContext;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojnavigationlistdnd',['exports', 'jquery', 'ojs/ojcore-base', 'ojs/ojlistviewdnd'], function (exports, $, oj, ojlistviewdnd) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @ignore
   * @export
   * @class NavigationListDndContext
   * @classdesc Drag and Drop Utils for ojNavigationList
   * @param {Object} navlist the NavigationList instance
   * @constructor
   */
  const NavigationListDndContext = function (navlist) {
    NavigationListDndContext.superclass.constructor.call(this, navlist);
  };
  oj._registerLegacyNamespaceProp('NavigationListDndContext', NavigationListDndContext);

  // Subclass from ListViewDndContext
  oj.Object.createSubclass(
    NavigationListDndContext,
    oj.ListViewDndContext,
    'oj.NavigationListDndContext'
  );

  /**
   * Gets the default drag affordance marker class
   * @return {string} affordance marker class
   * @override
   * @protected
   */
  NavigationListDndContext.prototype.GetDragAffordanceClass = function () {
    return 'oj-tabbar-drag-handle';
  };

  /**
   * Gets the drag Image class
   * @return {string} drag image class
   * @override
   * @protected
   */
  NavigationListDndContext.prototype.GetDragImageClass = function () {
    return 'oj-tabbar-drag-image';
  };

  /**
   * Gets the drag Item class
   * @return {string} drag Item class
   * @override
   * @protected
   */
  NavigationListDndContext.prototype.GetDragItemClass = function () {
    return 'oj-tabbar-drag-item';
  };

  /**
   * Gets the cut command style class
   * @return {string} cut command style class
   * @override
   * @protected
   */
  NavigationListDndContext.prototype.GetCutStyleClass = function () {
    return 'oj-tabbar-cut';
  };

  /**
   * Gets the style class prefix
   * @return {string} style class prefix
   * @override
   * @protected
   */
  NavigationListDndContext.prototype.GetCommandPrefix = function () {
    return 'oj-tabbar-';
  };

  /**
   * Return true to drag current item.
   * @return {boolean} true to drag current item.
   * @override
   */
  NavigationListDndContext.prototype.shouldDragCurrentItem = function () {
    return true;
  };

  /**
   * Override to return the Drag image width.
   * @return {string} width
   * @protected
   * @override
   */
  NavigationListDndContext.prototype.GetDragImageWidth = function (item) {
    var edge = this.listview.GetOption('edge');
    return edge === 'top' || edge === 'bottom'
      ? item.offsetWidth
      : oj.NavigationListDndContext.superclass.GetDragImageWidth.call(this, item);
  };

  /**
   * overide to return drag source type.
   * @return {string} drag source type.
   * @protected
   * @ignore
   * @override
   */
  NavigationListDndContext.prototype.GetDragSourceType = function () {
    return 'text/ojnavigationlist-dragsource-id';
  };

  /**
   * Returns payload object for reorder event.
   * @param {Array} items, items to be moved.
   * @param {string} position, the drop position relative to the reference item.
   * @param {Element} reference, the item where the moved items are drop on.
   * @returns {Object} payload object
   * @protected
   * @override
   */
  NavigationListDndContext.prototype.CreateReorderPayload = function (items, position, reference) {
    return {
      item: items[0],
      position: position,
      reference: reference
    };
    // ignore other events
  };

  /**
   * Override to verify whether item reordering enabled or not
   * @protected
   * @override
   */
  NavigationListDndContext.prototype.IsItemReOrdering = function () {
    var option = this.listview.GetOption('reorderable');
    return option === 'enabled';
  };

  /**
   * Returns the default data type. Need to be overriden by navlist
   * @return {string} the default data type
   * @protected
   */
  NavigationListDndContext.prototype.GetDefaultDataType = function () {
    return 'text/ojnavigationlist-items-data';
  };

  /**
   * Create and sets the drag image into the dataTransfer object
   * @param {Event} nativeEvent  DOM event object
   * @param {Array.<Element>} items array of row data
   * @protected
   */
  NavigationListDndContext.prototype.SetDragItemImage = function (nativeEvent, items) {
    var left = Math.max(0, nativeEvent.offsetX);
    var top = Math.max(0, nativeEvent.offsetY);
    var clone = $(items[0].cloneNode(true));

    clone.removeClass('oj-selected oj-focus oj-focus-highlight  oj-hover').addClass('oj-drag');
    var dragImage = $(document.createElement('div'));
    dragImage.get(0).className = this.listview.ojContext.element.get(0).className;
    dragImage
      .addClass(this.GetDragImageClass())
      .css({ width: this.GetDragImageWidth(items[0]), height: items[0].offsetHeight })
      .append(clone); // @HTMLUpdateOK
    $('body').append(dragImage); // @HTMLUpdateOK
    this.m_dragImage = dragImage;
    nativeEvent.dataTransfer.setDragImage(dragImage.get(0), left, top);
  };

  /**
   * Returns cut items. Navlist overrides this.
   * @param {Event} event jQuery event
   * @returns {Array} array of items to be moved
   */
  // eslint-disable-next-line no-unused-vars
  NavigationListDndContext.prototype.GetCutItems = function (event) {
    var items = [];
    items.push(
      this.m_contextMenuItem && this.m_contextMenuItem.length > 0
        ? this.m_contextMenuItem[0]
        : this._getActiveItem()
    );
    return items;
  };

  exports.NavigationListDndContext = NavigationListDndContext;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojnavigationlist',['ojs/ojcore-base', 'ojs/ojcomponentcore', 'ojs/ojthemeutils', 'jquery', 'ojs/ojdomutils', 'ojs/ojnavigationlistdnd', 'ojs/ojlistview', 'ojs/ojdatacollection-common', 'ojs/ojmenu', 'ojs/ojbutton'], function (oj, Components, ThemeUtils, $, DomUtils, ojnavigationlistdnd, ojlistview, DataCollectionUtils, ojmenu, ojbutton) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  (function () {
var __oj_navigation_list_metadata = 
{
  "properties": {
    "as": {
      "type": "string",
      "value": ""
    },
    "currentItem": {
      "type": "any",
      "writeback": true
    },
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "unsupported",
              "since": "13.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "display": {
      "type": "string",
      "enumValues": [
        "all",
        "icons"
      ],
      "value": "all"
    },
    "drillMode": {
      "type": "string",
      "enumValues": [
        "collapsible",
        "none",
        "sliding"
      ],
      "value": "none"
    },
    "edge": {
      "type": "string",
      "enumValues": [
        "bottom",
        "start",
        "top"
      ],
      "value": "start"
    },
    "expanded": {
      "type": "KeySet",
      "writeback": true
    },
    "hierarchyMenuThreshold": {
      "type": "number",
      "value": 0
    },
    "item": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        },
        "selectable": {
          "type": "function|boolean",
          "value": true
        }
      }
    },
    "overflow": {
      "type": "string",
      "enumValues": [
        "hidden",
        "popup"
      ],
      "value": "hidden"
    },
    "rootLabel": {
      "type": "string",
      "value": "Navigation List"
    },
    "selection": {
      "type": "any",
      "writeback": true
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleExpandCollapseInstructionText": {
          "type": "string"
        },
        "defaultRootLabel": {
          "type": "string"
        },
        "hierMenuBtnLabel": {
          "type": "string"
        },
        "msgFetchingData": {
          "type": "string"
        },
        "msgNoData": {
          "type": "string"
        },
        "overflowItemLabel": {
          "type": "string"
        },
        "previousIcon": {
          "type": "string"
        },
        "selectedLabel": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getContextByNode": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeCollapse": {},
    "ojBeforeCurrentItem": {},
    "ojBeforeExpand": {},
    "ojBeforeSelect": {},
    "ojCollapse": {},
    "ojExpand": {},
    "ojSelectionAction": {}
  },
  "extension": {}
};
    __oj_navigation_list_metadata.extension._WIDGET_NAME = 'ojNavigationList';
    __oj_navigation_list_metadata.extension._ALIASED_PROPS = {
      hierarchyMenuThreshold: 'hierarchyMenuDisplayThresholdLevel'
    };
    oj.CustomElementBridge.register('oj-navigation-list', {
      metadata: __oj_navigation_list_metadata
    });

var __oj_tab_bar_metadata = 
{
  "properties": {
    "as": {
      "type": "string",
      "value": ""
    },
    "currentItem": {
      "type": "any",
      "writeback": true
    },
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "deprecated",
              "since": "14.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "display": {
      "type": "string",
      "enumValues": [
        "all",
        "icons",
        "stacked"
      ],
      "value": "all"
    },
    "edge": {
      "type": "string",
      "enumValues": [
        "bottom",
        "end",
        "start",
        "top"
      ],
      "value": "start"
    },
    "item": {
      "type": "object",
      "properties": {
        "renderer": {
          "type": "function"
        },
        "selectable": {
          "type": "function|boolean",
          "value": true
        }
      }
    },
    "layout": {
      "type": "string",
      "enumValues": [
        "condense",
        "stretch"
      ],
      "value": "stretch"
    },
    "overflow": {
      "type": "string",
      "enumValues": [
        "hidden",
        "popup"
      ],
      "value": "hidden"
    },
    "reorderable": {
      "type": "string",
      "enumValues": [
        "disabled",
        "enabled"
      ],
      "value": "disabled"
    },
    "selection": {
      "type": "any",
      "writeback": true
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "accessibleReorderAfterItem": {
          "type": "string"
        },
        "accessibleReorderBeforeItem": {
          "type": "string"
        },
        "accessibleReorderTouchInstructionText": {
          "type": "string"
        },
        "labelCut": {
          "type": "string"
        },
        "labelPasteAfter": {
          "type": "string"
        },
        "labelPasteBefore": {
          "type": "string"
        },
        "labelRemove": {
          "type": "string"
        },
        "msgFetchingData": {
          "type": "string"
        },
        "msgNoData": {
          "type": "string"
        },
        "overflowItemLabel": {
          "type": "string"
        },
        "removeCueText": {
          "type": "string"
        },
        "selectedLabel": {
          "type": "string"
        }
      }
    },
    "truncation": {
      "type": "string",
      "enumValues": [
        "none",
        "progressive"
      ],
      "value": "none"
    }
  },
  "methods": {
    "getContextByNode": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeCurrentItem": {},
    "ojBeforeDeselect": {},
    "ojBeforeRemove": {},
    "ojBeforeSelect": {},
    "ojDeselect": {},
    "ojRemove": {},
    "ojReorder": {}
  },
  "extension": {}
};
    /* global __oj_tab_bar_metadata */
    __oj_tab_bar_metadata.extension._WIDGET_NAME = 'ojNavigationList';
    oj.CustomElementBridge.register('oj-tab-bar', {
      metadata: __oj_tab_bar_metadata
    });
  })();

  const _ARIA_HIDDEN = 'aria-hidden';
  const _ARIA_LABEL = 'aria-label';
  const _OJ_DEFAULT = 'oj-default';
  const _OJ_DISABLED = 'oj-disabled';

  /**
   * todo: create common utility class between combobox, listview and navlist
   * @private
   */
  var _NavigationListUtils = {
    clazz: function (SuperClass, methods) {
      var constructor = function () {};
      oj.Object.createSubclass(constructor, SuperClass, '');
      $.extend(constructor.prototype, methods);
      return constructor;
    }
  };
  /**
   * @export
   * @class _ojNavigationListView
   * @classdesc NavigationList
   * @constructor
   * @ignore
   */
  const _ojNavigationListView = _NavigationListUtils.clazz(
    oj._ojListView,
    /** @lends _ojNavigationListView.prototype */
    {
      OPTION_DRILL_MODE: 'drillMode',
      OPTION_DRILL_MODE_NONE: 'none',
      OPTION_DRILL_MODE_COLLAPSIBLE: 'collapsible',
      OPTION_DRILL_MODE_SLIDING: 'sliding',
      OPTION_DISPLAY: 'display',
      OPTION_DISPLAY_ICONS: 'icons',
      OPTION_DISPLAY_ALL: 'all',
      OPTION_DISPLAY_STACKED: 'stacked',
      OPTION_LAYOUT_STRETCH: 'stretch',
      OPTION_LAYOUT_CONDENSE: 'condense',
      OPTION_EDGE: 'edge',
      OPTION_EDGE_TOP: 'top',
      OPTION_EDGE_END: 'end',
      OPTION_EDGE_START: 'start',
      OPTION_EDGE_BOTTOM: 'bottom',
      OPTION_SELECTION: 'selection',
      OPTION_CURRENT_ITEM: 'currentItem',
      OPTION_ITEM: 'item',
      TAG_NAME_TAB_BAR: 'oj-tab-bar',
      NAVLIST_ITEM_SUBID_KEY: {
        navlist: 'oj-navigationlist-item',
        tabbar: 'oj-tabbar-item'
      },
      NAVLIST_EXPANDED_STYLE_CLASS: {
        navlist: 'oj-navigationlist-expanded',
        tabbar: 'oj-tabbar-expanded'
      },
      NAVLIST_COLLAPSIBLE_STYLE_CLASS: {
        navlist: 'oj-navigationlist-collapsible',
        tabbar: 'oj-tabbar-collapsible'
      },
      NAVLIST_VERTICAL_STYLE_CLASS: {
        navlist: 'oj-navigationlist-vertical',
        tabbar: 'oj-tabbar-vertical'
      },

      ITEM_CONTENT_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-content',
        tabbar: 'oj-tabbar-item-content'
      },
      NAVLIST_DIVIDERS_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-dividers',
        tabbar: 'oj-tabbar-item-dividers'
      },
      LAST_ITEM_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-last-child',
        tabbar: 'oj-tabbar-item-last-child'
      },
      EXPANDED_STYLE_CLASS: 'oj-expanded',
      COLLAPSED_STYLE_CLASS: 'oj-collapsed',
      CONDENSE_STYLE_CLASS: 'oj-condense',
      SLIDING_NAVLIST_CURRENT_STYLE_CLASS: 'oj-navigationlist-current',
      DIVIDER_STYLE_CLASS: {
        navlist: 'oj-navigationlist-divider',
        tabbar: 'oj-tabbar-divider'
      },
      NAVLIST_OVERFLOW_MENU_ITEM: {
        navlist: 'oj-navigationlist-overflow-menu-item',
        tabbar: 'oj-tabbar-overflow-menu-item'
      },
      NAVLIST_OVERFLOW_MENU: {
        navlist: 'oj-navigationlist-overflow-menu',
        tabbar: 'oj-tabbar-overflow-menu'
      },
      NAVLIST_OVERFLOW_ITEM_ICON: {
        navlist: 'oj-navigationlist-overflow-item-icon',
        tabbar: 'oj-tabbar-overflow-item-icon'
      },
      _CATEGORY_DIVIDER_STYLE_CLASS: {
        navlist: 'oj-navigationlist-category-divider',
        tabbar: 'oj-tabbar-category-divider'
      },
      _ITEM_LABEL_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-label',
        tabbar: 'oj-tabbar-item-label'
      },
      _ICON_ONLY_STYLE_CLASS: {
        navlist: 'oj-navigationlist-icon-only',
        tabbar: 'oj-tabbar-icon-only'
      },
      _STACK_ICON_STYLE_CLASS: {
        navlist: 'oj-navigationlist-stack-icon-label',
        tabbar: 'oj-tabbar-stack-icon-label'
      },
      _ITEM_ICON_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-icon',
        tabbar: 'oj-tabbar-item-icon'
      },
      _ITEM_BADGE_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-end',
        tabbar: 'oj-tabbar-item-end'
      },
      _HORIZONTAL_NAVLIST_STYLE_CLASS: {
        navlist: 'oj-navigationlist-horizontal',
        tabbar: 'oj-tabbar-horizontal'
      },
      _NAVLIST_END_EDGE_STYLE_CLASS: {
        navlist: 'oj-navigationlist-vertical-end',
        tabbar: 'oj-tabbar-vertical-end'
      },
      _NAVLIST_BOTTOM_EDGE_STYLE_CLASS: {
        navlist: 'oj-navigationlist-horizontal-bottom',
        tabbar: 'oj-tabbar-horizontal-bottom'
      },
      _NAVLIST_HAS_ICONS: {
        navlist: 'oj-navigationlist-has-icons',
        tabbar: 'oj-tabbar-has-icons'
      },
      _NAVLIST_ITEM_HAS_NO_ICON: {
        navlist: 'oj-navigationlist-item-no-icon',
        tabbar: 'oj-tabbar-item-no-icon'
      },
      _NAVLIST_ITEM_TITLE: {
        navlist: 'oj-navigationlist-item-title',
        tabbar: 'oj-tabbar-item-title'
      },
      _NAVLIST_STYLE_CLASS: {
        navlist: 'oj-navigationlist',
        tabbar: 'oj-tabbar'
      },
      _NAVLIST_TOUCH_STYLE_CLASS: {
        navlist: 'oj-navigationlist-touch',
        tabbar: 'oj-tabbar-touch'
      },
      _NAVLIST_LISTVIEW_CONTAINER_STYLE_CLASS: {
        navlist: 'oj-navigationlist-listview-container',
        tabbar: 'oj-tabbar-listview-container'
      },
      _IS_TITLE_ATTR_ADDED_DUE_TO_TRUNCATION: 'IsTitleAttrDueToTruncation',
      _APPLICATION_LEVEL_NAV_STYLE_CLASS: 'oj-navigationlist-app-level',
      _PAGE_LEVEL_NAV_STYLE_CLASS: 'oj-navigationlist-page-level',
      _NAVLIST_ITEM_ICON_HAS_TITLE: 'navigationListItemIconHastitle',
      _NAVLIST_NO_FOLLOW_LINK_CLASS: {
        navlist: 'oj-navigationlist-nofollow-link',
        tabbar: 'oj-tabbar-nofollow-link'
      },
      _CONTAINER_STYLE_CLASS: {
        navlist: 'oj-navigationlist-listview',
        tabbar: 'oj-tabbar-listview'
      },
      _ELEMENT_STYLE_CLASS: {
        navlist: 'oj-navigationlist-element',
        tabbar: 'oj-tabbar-element'
      },
      _ELEMENT_EMPTY_TEXT_STYLE_CLASS: {
        navlist: 'oj-navigationlist-empty-text',
        tabbar: 'oj-tabbar-empty-text'
      },
      _ELEMENT_NO_DATA_MSG_STYLE_CLASS: {
        navlist: 'oj-navigationlist-no-data-message',
        tabbar: 'oj-tabbar-no-data-message'
      },
      _FOCUSED_ELEMENT_STYLE_CLASS: {
        navlist: 'oj-navigationlist-focused-element',
        tabbar: 'oj-tabbar-focused-element'
      },
      _ITEM_ELEMENT_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item-element',
        tabbar: 'oj-tabbar-item-element'
      },
      _ITEM_STYLE_CLASS: {
        navlist: 'oj-navigationlist-item',
        tabbar: 'oj-tabbar-item'
      },
      _OPTION_DEFAULT_STYLE_CLASS: {
        navlist: 'oj-navigationlist-option-defaults',
        tabbar: 'oj-tabbar-option-defaults'
      },
      _LOADING_STATUS_ICON_STYLE_CLASS: {
        navlist: 'oj-navigationlist-loading-icon',
        tabbar: 'oj-tabbar-loading-icon'
      },
      _STATUS_MSG_STYLE_CLASS: {
        navlist: 'oj-navigationlist-status-message',
        tabbar: 'oj-tabbar-status-message'
      },
      _STATUS_STYLE_CLASS: {
        navlist: 'oj-navigationlist-status',
        tabbar: 'oj-tabbar-status'
      },
      /**
       * Returns Item label text
       * @returns {string|null} Item label
       */
      getItemLabel: function (target) {
        var itemContent = this.getItemContentElement(target);
        if (itemContent.is('a')) {
          // When using simple <a> markup
          var itemLabelClass = this.getItemLabelStyleClass();
          var itemLabelElement = itemContent[0].querySelector('.' + itemLabelClass);
          // Only the label's textContent is required.
          return $.trim(itemLabelElement.textContent).replace('CORE PACK', '');
        }
        // When using arbitrary content, extract item title from element having marker class .oj-navigationlist-item-title.
        return $.trim(itemContent.find('.' + this.getItemTitleStyleClass()).text());
      },

      /**
       * Returns Item content root element.
       * @returns {Object} Returns jquery object for item content root
       */
      getItemContentElement: function (item) {
        var itemContent = item.children('.' + this.getItemContentStyleClass());
        if (itemContent.length === 0) {
          itemContent = item
            .children('.' + this.getGroupItemStyleClass())
            .children('.' + this.getItemContentStyleClass());
          if (itemContent.length === 0) {
            // This case is when item label is invoked before complete initialization of listview
            itemContent = item
              .children('.' + this.getGroupItemStyleClass())
              .children(
                ':not(.' +
                  this.getExpandIconStyleClass() +
                  '):not(.' +
                  this.getCollapseIconStyleClass() +
                  ')'
              );
          }
        }
        return itemContent;
      },

      /**
       * Return true when page is in rtl mode otherwise false.
       * @returns {boolean} true if page is in rtl mode
       */
      isRtl: function () {
        return this.ojContext._GetReadingDirection() === 'rtl';
      },

      _initNavigationMode: function (rootElement) {
        var tagName = rootElement[0].tagName.toLowerCase();

        if (tagName === this.TAG_NAME_TAB_BAR) {
          this._navigationMode = 'tabbar';
        } else {
          this._navigationMode = 'navlist'; // if user uses div jquery widget continue with application level
        }
      },

      _getNavigationMode: function () {
        return this._navigationMode;
      },

      /**
       * Called by content handler once content of all items are rendered
       * @override
       */
      renderComplete: function () {
        this.m_listHandler.BeforeRenderComplete();
        _ojNavigationListView.superclass.renderComplete.apply(this, arguments);
      },

      /**
       * Called by content handler once the content of an item is rendered triggered by an insert event
       * @param {Element} elem the item element
       * @param {Object} context the context object used for the item
       */
      itemInsertComplete: function (elem, context) {
        this.m_listHandler.ItemInsertComplete(elem, context);
        _ojNavigationListView.superclass.itemInsertComplete.apply(this, arguments);
      },

      /**
       * Called by content handler once the content of an item is removed triggered by an remove event
       * @param {Element} elem the item element
       * @param {boolean} restoreFocus true if focus should be restore, false otherwise
       */
      // eslint-disable-next-line no-unused-vars
      itemRemoveComplete: function (elem, restoreFocus) {
        this.m_listHandler.ItemRemoveComplete(elem);
        return _ojNavigationListView.superclass.itemRemoveComplete.apply(this, arguments);
      },
      /**
       * Restore content while restroying list
       * @private
       */
      _restoreContent: function (list) {
        var items = list.children();
        list.removeAttr('style').removeClass(this.getHasIconsStyleClass()).removeAttr(_ARIA_HIDDEN);
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          item = $(item);
          if (item.hasClass(this.getDividerStyleClass())) {
            item.remove();
          } else {
            var itemContent = this.getItemContentElement(item);
            itemContent
              .removeClass(this.getItemContentStyleClass())
              .removeClass(this.getHasNoIconStyleClass())
              .removeAttr('aria-haspopup');
            var itemIcon = itemContent.children('.' + this.getItemIconStyleClass());
            if (itemIcon && itemIcon.length > 0) {
              itemIcon.removeAttr('role');
              itemIcon.removeAttr(_ARIA_LABEL);
              this._removeToolTipOnIcon(itemIcon);
            }

            item
              .removeClass(_OJ_DEFAULT)
              .removeAttr('role')
              .removeAttr('aria-disabled')
              .removeAttr('aria-expanded')
              .removeAttr(_ARIA_HIDDEN)
              .removeAttr('aria-pressed');
            var focusableItem = this.getFocusItem(item);
            focusableItem.removeAttr('role').removeAttr(_ARIA_HIDDEN).removeAttr('aria-pressed');
            itemContent
              .children('.' + this.getItemLabelStyleClass())
              .contents()
              .unwrap();
            item.find('.' + this.getNavListRemoveIcon()).remove();
            if (focusableItem.data(this._IS_TITLE_ATTR_ADDED_DUE_TO_TRUNCATION)) {
              focusableItem.removeAttr('title');
            }
            var sublist = item.children('ul');
            if (sublist.length > 0) {
              this.m_listHandler.RestoreItem(item, itemContent, sublist);
              this._restoreContent(sublist);
            } else {
              this.m_listHandler.RestoreItem(item, itemContent);
            }
          }
        }
      },

      /**
       * Returns DnD Context
       * @private
       * @override
       */
      GetDnDContext: function () {
        if (
          typeof ojnavigationlistdnd.NavigationListDndContext !== 'undefined' &&
          this.ojContext.element[0].tagName.toLowerCase() === this.TAG_NAME_TAB_BAR
        ) {
          return new ojnavigationlistdnd.NavigationListDndContext(this);
        }
        return undefined;
      },

      /**
       * Overriding to exclude oj-navigationlist-item-content from clickable components.
       * @override
       * @protected
       */
      IsNodeEditableOrClickable: function (node) {
        if (
          node.hasClass(this.getItemContentStyleClass()) ||
          node.hasClass(this.getExpandIconStyleClass()) ||
          node.hasClass(this.getCollapseIconStyleClass())
        ) {
          return false;
        }
        return _ojNavigationListView.superclass.IsNodeEditableOrClickable.apply(this, arguments);
      },

      /**
       * checks for whether a node is editable or clickable.
       * @param {jQuery} node  Node
       * @return {boolean} true or false
       * @override
       * @protected
       */
      IsElementEditableOrClickable: function (node) {
        var nodeName = node.prop('nodeName');
        // Exclude navlist item content <a> tag from below list and also checking for oj-component class as it is needed for toggle button.
        return (
          (nodeName.match(/^INPUT|SELECT|OPTION|BUTTON|^A\b|TEXTAREA/) &&
            !node.hasClass(this.getItemContentStyleClass())) ||
          node.hasClass('oj-component')
        );
      },

      _focusable: function (context) {
        if ($(context.data).is('li')) {
          return !$(context.data).hasClass(_OJ_DISABLED);
        }
        return !$(context.parentElement).hasClass(_OJ_DISABLED);
      },

      /**
       * Prepare options to initialize ListView base class
       * @private
       */
      _prepareListViewOptions: function (navlistOptions) {
        var opts = $.extend({}, navlistOptions);

        opts.drillMode = navlistOptions.drillMode !== 'none' ? 'collapsible' : 'none';
        opts.selection = navlistOptions.selection !== null ? [navlistOptions.selection] : [];
        opts.selectionMode = 'single';
        opts.item = $.extend(
          {
            focusable: this._focusable
          },
          navlistOptions.item
        );

        opts.element = this._list;
        return opts;
      },

      /**
       * Update cloned option to make it compatible with listview
       * @private
       */
      updateListViewOption: function (key, value) {
        switch (key) {
          case this.OPTION_DRILL_MODE:
            this.options[this.OPTION_DRILL_MODE] = value !== 'none' ? 'collapsible' : 'none';
            break;
          case this.OPTION_SELECTION:
            this.options[this.OPTION_SELECTION] = value !== null ? [value] : [];
            break;
          case this.OPTION_ITEM:
            this.options[this.OPTION_ITEM] = $.extend(
              {
                focusable: this._focusable
              },
              value
            );
            break;
          default:
            this.options[key] = value;
            break;
        }
      },

      /**
       * Returns root label for navigation list.
       * otherwise return the emptyText set in the options
       * @return {string} Label for navigation list
       */
      getRootLabel: function () {
        if (this.ojContext.options.rootLabel) {
          return this.ojContext.options.rootLabel;
        }

        return this.ojContext.getTranslatedString('defaultRootLabel');
      },

      /**
       * Sets wai-aria properties on root element
       * @override
       * @protected
       */
      SetAriaProperties: function () {
        // add aria-multiselectable attribute only on tabbar
        if (this._getNavigationMode() === 'tabbar') {
          this.ojContext.element.attr('aria-multiselectable', false);
        }
      },

      /**
       * Whether this is a horizontal tablist
       * @private
       */
      _isHorizontalTablist: function () {
        const root = this.ojContext.element.get(0);
        if (
          root.getAttribute('role') === 'tablist' &&
          root.getAttribute('aria-orientation') !== 'vertical'
        ) {
          return true;
        }
        return false;
      },

      /**
       * Place initial focus on selected tab, if any
       * @private
       */
      _focusSelectedTab: function (event) {
        if (!this.m_preActive && this.m_active == null) {
          const elem = this.ojContext.element
            .get(0)
            .querySelector('.' + this.getItemElementStyleClass() + '.oj-selected');
          if (elem) {
            this._setActive($(elem), event, true);
          }
        }
      },

      /**
       * Handler for focus event
       * @param {Event} event the focus event
       * @protected
       * @override
       */
      HandleFocus: function (event) {
        if (this._isHorizontalTablist()) {
          this._focusSelectedTab(event);
        }
        return this.m_listHandler.HandleFocus(event);
      },

      /**
       * Handler for blur event
       * @param {Event} event the blur event
       * @protected
       * @override
       */
      HandleBlur: function (event) {
        return this.m_listHandler.HandleBlur(event);
      },

      /**
       * Sets the tab index attribute of the root element
       * @override
       */
      SetRootElementTabIndex: function () {
        this.ojContext.element.attr('tabIndex', 0);
      },

      /**
       * Removes the tab index attribute of the root element
       * @override
       */
      RemoveRootElementTabIndex: function () {
        this.ojContext.element.removeAttr('tabIndex');
      },

      /**
       * Removes wai-aria properties on root element
       * @override
       * @protected
       */
      UnsetAriaProperties: function () {
        this.ojContext.element.removeAttr('aria-activedescendant').removeAttr('aria-multiselectable');
      },

      /**
       * Whether high-watermark scrolling is specified
       * @override
       */
      isLoadMoreOnScroll: function () {
        return false;
      },

      /**
       * Whether to use grid role
       * @override
       */
      ShouldUseGridRole: function () {
        return false;
      },

      /**
       * Overriding init to initialize list with respective List handler.
       * @override
       */
      init: function (navlistopts) {
        var self = this;
        var element = navlistopts.ojContext.element;

        this._initNavigationMode(element);

        element.addClass(this.getNavListStyleClass());

        if (DomUtils.isTouchSupported()) {
          element.addClass(this.getNavListTouchStyleClass());
        }

        this._list = element.children('ul:first');
        if (this._list.length === 0) {
          this._list = $(document.createElement('ul'));
          element.append(this._list); // @HTMLUpdateOK
        }

        var listViewContainer = $(document.createElement('div'));
        listViewContainer.addClass(this.getNavListContainerStyleClass());
        listViewContainer.attr('role', 'presentation');

        this._list.wrap(listViewContainer); // @HTMLUpdateOK
        var opts = this._prepareListViewOptions(navlistopts);

        _ojNavigationListView.superclass.init.call(this, opts);
        this.getListContainer().attr('role', 'presentation');
        this.element.removeClass('oj-component-initnode');
        this.ojContext._on(this.ojContext.element, {
          click: function (event) {
            self.m_listHandler.HandleClick(event);
          },

          keydown: function (event) {
            self.m_listHandler.HandleKeydown(event);
          },

          mouseup: function (event) {
            self._clearActiveState(event);
          },

          mouseover: function (event) {
            if ($(event.target).closest('a.' + self.getItemContentStyleClass()).length > 0) {
              var $itemLink = $(event.target).closest('a.' + self.getItemContentStyleClass());
              // OverflowItem, which is icon only upon initial render has aria-label so skip
              var isOverflowItem =
                $itemLink.find('.' + self.getOverflowItemIconStyleClass()).length > 0;
              if (isOverflowItem) {
                return;
              }
              var $label = $itemLink.find('.' + self.getItemLabelStyleClass());
              // Add title attribute only when the text is truncated.
              if ($label[0].offsetWidth < $label[0].scrollWidth && !$itemLink.attr('title')) {
                $itemLink.attr('title', $label.text().trim());
                $itemLink.data(self._IS_TITLE_ATTR_ADDED_DUE_TO_TRUNCATION, 'true');
              }
            }
          },

          mouseout: function (event) {
            if ($(event.target).closest('a.' + self.getItemContentStyleClass()).length > 0) {
              // Remove title attribute on mouseleave.
              var $itemLink = $(event.target).closest('a.' + self.getItemContentStyleClass());
              if ($itemLink.data(self._IS_TITLE_ATTR_ADDED_DUE_TO_TRUNCATION)) {
                $itemLink.removeData(self._IS_TITLE_ATTR_ADDED_DUE_TO_TRUNCATION);
                $itemLink.removeAttr('title');
              }
              self._clearActiveState(event);
            }
          }
        });
      },

      _initListHandler: function () {
        var drillMode = this.ojContext.options.drillMode;
        var edge = this.ojContext.options.edge;

        if (drillMode === this.OPTION_DRILL_MODE_SLIDING) {
          this.m_listHandler = new oj.SlidingNavListHandler(
            this,
            this.ojContext.element,
            this.ojContext
          );
        } else if (drillMode === this.OPTION_DRILL_MODE_COLLAPSIBLE) {
          this.m_listHandler = new oj.CollapsibleNavListHandler(
            this,
            this.ojContext.element,
            this.ojContext
          );
        } else if (
          drillMode === this.OPTION_DRILL_MODE_NONE &&
          (edge === this.OPTION_EDGE_TOP || edge === this.OPTION_EDGE_BOTTOM)
        ) {
          this.m_listHandler = new oj.HorizontalNavListHandler(
            this,
            this.ojContext.element,
            this.ojContext
          );
        } else {
          this.m_listHandler = new oj.DefaultNavListHandler(
            this,
            this.ojContext.element,
            this.ojContext
          );
        }

        this.m_listHandler.Init(this.options);
        var navigationLevel = this.ojContext.options.navigationLevel;
        this._setNavigationLevel(navigationLevel);
      },

      _setNavigationLevel: function (navigationLevel) {
        var drillMode = this.ojContext.options.drillMode;
        if (drillMode === 'none') {
          if (
            navigationLevel === 'application' ||
            this.ojContext.element[0].tagName.toLowerCase() === 'oj-navigation-list'
          ) {
            this.ojContext.element.addClass(this._APPLICATION_LEVEL_NAV_STYLE_CLASS);
            this.ojContext.element.removeClass(this._PAGE_LEVEL_NAV_STYLE_CLASS);
          } else if (navigationLevel === 'page') {
            this.ojContext.element.addClass(this._PAGE_LEVEL_NAV_STYLE_CLASS);
            this.ojContext.element.removeClass(this._APPLICATION_LEVEL_NAV_STYLE_CLASS);
          }
        }
      },

      _clearActiveState: function (event) {
        var item = this.FindItem($(event.target));
        if (item != null) {
          this.HighlightUnhighlightElem(item, 'oj-active', false);
        }
      },

      /**
       * Initialize the listview after creation
       * @override
       */
      afterCreate: function () {
        this._initListHandler();
        _ojNavigationListView.superclass.afterCreate.apply(this, arguments);
      },

      /**
       * Gets the animation effect for the specific action
       * @param {string} action the action to retrieve the effect
       * @return {Object} the animation effect for the action
       */
      getAnimationEffect: function (action) {
        return this.m_listHandler.GetAnimationEffect(action);
      },

      notifyAttached: function () {
        _ojNavigationListView.superclass.notifyAttached.apply(this, arguments);
        this.m_listHandler.NotifyAttached();
      },

      ShouldRegisterResizeListener: function () {
        return true;
      },

      HandleResize: function (width, height) {
        var self = this;
        _ojNavigationListView.superclass.HandleResize.apply(this, arguments);
        if (width > 0 && height > 0 && this.m_listHandler != null) {
          self.m_listHandler.HandleResize(width, height);
        }
      },

      BeforeInsertItem: function () {
        this.m_listHandler.BeforeInsertItem();
      },

      /**
       * Event handler for when mouse down or touch start anywhere in the list
       * @param {Event} event mousedown or touchstart event
       * @protected
       */
      HandleMouseDownOrTouchStart: function (event) {
        _ojNavigationListView.superclass.HandleMouseDownOrTouchStart.apply(this, arguments);
        var item = this.FindItem($(event.target));
        if (item && !item.hasClass(_OJ_DISABLED)) {
          this.HighlightUnhighlightElem(item, 'oj-active', true);
        }
      },

      /**
       * Event handler for when touch end/cancel happened
       * @param {Event} event touchend or touchcancel event
       * @protected
       */
      HandleTouchEndOrCancel: function (event) {
        this._clearActiveState(event);
        _ojNavigationListView.superclass.HandleTouchEndOrCancel.apply(this, arguments);
      },
      getItemContentStyleClass: function () {
        return this.ITEM_CONTENT_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListExpandedStyleClass: function () {
        return this.NAVLIST_EXPANDED_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListCollapsibleStyleClass: function () {
        return this.NAVLIST_COLLAPSIBLE_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListVerticalStyleClass: function () {
        return this.NAVLIST_VERTICAL_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListItemsDividerStyleClass: function () {
        return this.NAVLIST_DIVIDERS_STYLE_CLASS[this._getNavigationMode()];
      },
      getLastItemStyleClass: function () {
        return this.LAST_ITEM_STYLE_CLASS[this._getNavigationMode()];
      },
      getItemBadgeStyleClass: function () {
        return this._ITEM_BADGE_STYLE_CLASS[this._getNavigationMode()];
      },
      getDividerStyleClass: function () {
        return this.DIVIDER_STYLE_CLASS[this._getNavigationMode()];
      },
      getOverflowItemStyleClass: function () {
        return this.NAVLIST_OVERFLOW_MENU_ITEM[this._getNavigationMode()];
      },
      getOverflowMenuStyleClass: function () {
        return this.NAVLIST_OVERFLOW_MENU[this._getNavigationMode()];
      },
      getOverflowItemIconStyleClass: function () {
        return this.NAVLIST_OVERFLOW_ITEM_ICON[this._getNavigationMode()];
      },
      getCategoryDividerStyleClass: function () {
        return this._CATEGORY_DIVIDER_STYLE_CLASS[this._getNavigationMode()];
      },
      getItemLabelStyleClass: function () {
        return this._ITEM_LABEL_STYLE_CLASS[this._getNavigationMode()];
      },
      getIconOnlyStyleClass: function () {
        return this._ICON_ONLY_STYLE_CLASS[this._getNavigationMode()];
      },
      getStackedIconStyleClass: function () {
        return this._STACK_ICON_STYLE_CLASS[this._getNavigationMode()];
      },
      getItemIconStyleClass: function () {
        return this._ITEM_ICON_STYLE_CLASS[this._getNavigationMode()];
      },
      getHorizontalNavListStyleClass: function () {
        return this._HORIZONTAL_NAVLIST_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListEndEdgeStyleClass: function () {
        return this._NAVLIST_END_EDGE_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListBottomEdgeStyleClass: function () {
        return this._NAVLIST_BOTTOM_EDGE_STYLE_CLASS[this._getNavigationMode()];
      },
      getHasIconsStyleClass: function () {
        return this._NAVLIST_HAS_ICONS[this._getNavigationMode()];
      },
      getHasNoIconStyleClass: function () {
        return this._NAVLIST_ITEM_HAS_NO_ICON[this._getNavigationMode()];
      },
      getItemTitleStyleClass: function () {
        return this._NAVLIST_ITEM_TITLE[this._getNavigationMode()];
      },
      getNavListStyleClass: function () {
        return this._NAVLIST_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListTouchStyleClass: function () {
        return this._NAVLIST_TOUCH_STYLE_CLASS[this._getNavigationMode()];
      },
      getNavListContainerStyleClass: function () {
        return this._NAVLIST_LISTVIEW_CONTAINER_STYLE_CLASS[this._getNavigationMode()];
      },
      getNoFollowLinkStyleClass: function () {
        return this._NAVLIST_NO_FOLLOW_LINK_CLASS[this._getNavigationMode()];
      },
      getCondenseStyleClass: function () {
        return this.CONDENSE_STYLE_CLASS;
      },

      getItemSubIdKey: function () {
        if (this.isTabBar()) {
          return this.NAVLIST_ITEM_SUBID_KEY.tabbar;
        }
        return this.NAVLIST_ITEM_SUBID_KEY.navlist;
      },

      /**
       * Returns Navlist specific container style class
       * @override
       * @protected
       */
      GetContainerStyleClass: function () {
        return this._CONTAINER_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Returns Navlist specific root element style class
       * @override
       * @protected
       */
      GetStyleClass: function () {
        return this._ELEMENT_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Returns Navlist specific Item style class
       * @override
       */
      getEmptyTextMarkerClass: function () {
        return this._ELEMENT_EMPTY_TEXT_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Returns Navlist specific Item style class
       * @override
       */
      getEmptyTextStyleClass: function () {
        return this._ELEMENT_NO_DATA_MSG_STYLE_CLASS[this._getNavigationMode()];
      },

      getNavListRemoveIcon: function () {
        return 'oj-tabbar-remove-icon';
      },

      getNavListRemoveCommand: function () {
        return 'oj-tabbar-remove';
      },

      getRemovableStyleClass: function () {
        return 'oj-removable';
      },

      /**
       * Returns Navlist specific Item style class
       * @override
       */
      getItemStyleClass: function () {
        return this._ITEM_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * NavList doesn't have item layout style class
       * @override
       */
      getItemLayoutStyleClass: function () {
        return this.getItemStyleClass();
      },

      getFocusedElementStyleClass: function () {
        return this._FOCUSED_ELEMENT_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Returns Navlist specific Item element style class
       * @override
       */
      getItemElementStyleClass: function () {
        return this._ITEM_ELEMENT_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Returns Navlist specific collapse icon style class
       * @override
       */
      getCollapseIconStyleClass: function () {
        return 'oj-navigationlist-collapse-icon';
      },

      /**
       * Returns Navlist specific expand icon style class
       * @override
       */
      getExpandIconStyleClass: function () {
        return 'oj-navigationlist-expand-icon';
      },

      /**
       * Returns Navlist specific depth style class
       * @override
       */
      getDepthStyleClass: function (depth) {
        return 'oj-navigationlist-depth-' + depth;
      },

      /**
       * Returns Navlist specific Group Item style class
       * @override
       */
      getGroupItemStyleClass: function () {
        return 'oj-navigationlist-group-item';
      },

      /**
       * Returns Navlist specific Group style class
       * @override
       */
      getGroupStyleClass: function () {
        return 'oj-navigationlist-group';
      },

      /**
       * Returns Navlist specific group expand style class
       * @override
       */
      getGroupExpandStyleClass: function () {
        return 'oj-navigationlist-collapsible-transition';
      },

      /**
       * Returns Navlist specific group collapse style class
       * @override
       */
      getGroupCollapseStyleClass: function () {
        return this.getGroupExpandStyleClass();
      },

      /**
       * Override default styles values
       * @return {Object} default styles values
       */
      getStyleValues: function () {
        const defaultOptions = {};
        Object.entries(_ojNavigationListView._CSS_Vars[this._getNavigationMode()]).forEach(
          ([key, value]) => {
            if (key === 'animation') {
              defaultOptions.animation = oj._ojListView.getComplexCSSVariable(value);
            } else {
              defaultOptions[key] = ThemeUtils.getCachedCSSVarValues([value])[0];
            }
          }
        );
        return defaultOptions;
      },
      /**
       * Returns Navlist specific Loaidng status icon style class
       * @override
       * @return {string} Loading status icon style class
       */
      getLoadingStatusIconStyleClass: function () {
        return this._LOADING_STATUS_ICON_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * @override
       */
      showLoadingIcon: function () {
        var isRedWood = ThemeUtils.parseJSONFromFontFamily('oj-theme-json').behavior === 'redwood';
        if (!isRedWood) {
          _ojNavigationListView.superclass.showLoadingIcon.apply(this, arguments);
        }
      },

      /**
       * Returns Navlist specific status message style class
       * @override
       * @return {string} status message style class
       */
      getStatusMessageStyleClass: function () {
        return this._STATUS_MSG_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Returns Navlist specific status style class
       * @override
       * @return {string} status style class
       */
      getStatusStyleClass: function () {
        return this._STATUS_STYLE_CLASS[this._getNavigationMode()];
      },

      /**
       * Override expand animation behaviour to support differnet types of navlists.
       * Returns a Promise that resolves when animation completes
       * @override
       * @protected
       */
      AnimateExpand: function (groupItem, animate, event) {
        return this.m_listHandler.Expand(groupItem, animate, event);
      },

      /**
       * Override collapse animation behaviour to support differnet types of navlists.
       * Returns a Promise that resolves when animation completes
       * @override
       * @protected
       */
      AnimateCollapse: function (item, key, animate, event) {
        return this.m_listHandler.Collapse(item, key, animate, event);
      },

      /**
       * Handles arrow keys navigation on item
       * @param {number} keyCode description
       * @param {boolean} isExtend
       * @param {Event} event the DOM event causing the arrow keys
       * @override
       * @protected
       */
      HandleArrowKeys: function (keyCode, isExtend, event) {
        // Arrow key's should work independent of Alt key
        return !event.altKey && this.m_listHandler.HandleArrowKeys(keyCode, isExtend, event);
      },

      /**
       * Determine whether the key code is an arrow key
       * @param {number} keyCode
       * @return {boolean} true if it's an arrow key, false otherwise
       * @override
       * @protected
       */
      IsArrowKey: function (keyCode) {
        return this.m_listHandler.IsArrowKey(keyCode);
      },

      /**
       * Determines whether the specified item is expanded
       * @param {jQuery} item the item element
       * @return {number} 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
       * @override
       * @protected
       */
      GetState: function (item) {
        return this.m_listHandler.GetState(item);
      },

      /**
       * Sets the disclosed state of the item
       * @param {jQuery} item the item element
       * @param {number} state 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
       * @override
       * @protected
       */
      SetState: function (item, state) {
        this.m_listHandler.SetState(item, state);
      },

      /**
       * Handle clicking the 'X' inside the anchor representing the tab
       * see JET-63881
       * @private
       */
      _handleRemovableLink: function (event) {
        var $target = $(event.target);
        var item = this.FindItem($target);
        if (item == null || item.length === 0) {
          // this should not happen as the listener is register on the item
          return;
        }

        // click on the 'X' should not change selection, but it should still change currentItem
        this.HandleClickActive(item, event);
        var contentElement = this.getItemContentElement(item);
        if (contentElement.length > 0) {
          // make sure it gets focus otherwise focus goes to the body as 'X' is no longer in DOM
          contentElement[0].focus();
        }
        event.preventDefault();
        event.stopPropagation();
        this._handleRemove(event, item);
      },

      /**
       * Override to expand and collapse events on clicking item instead of icon. Also avoids expand/collapse when user click on arbitrary clickable elements.
       * @override
       * @protected
       */
      HandleMouseClick: function (event) {
        var $target = $(event.target);
        var parentNode = $target[0].parentNode;
        var item = this.FindItem($target);
        if (item == null || item.length === 0) {
          // can't find item or if item cannot be focus
          return;
        }

        if (this.SkipFocus(item)) {
          event.preventDefault();
          return;
        }

        // For Mobile mode only: if the target is a div of animation check it's parent contains the expand/collapse icon and reset target
        if (parentNode.classList.contains('oj-animate-pointerUp')) {
          $target = $(parentNode);
        }

        // TODO , once it is fixd in listview probably don't need to override HandleMouseClick

        if (this.IsNodeEditableOrClickable($target)) {
          return;
        }

        var itemContent = this.getItemContentElement(item);
        var url = itemContent.attr('href');
        if (url && url !== '#') {
          if (event.button === 0 && (event.shiftKey || event.ctrlKey)) {
            return; // Do nothing, as Browser will launch  target it in new tab or browser
          }
        }

        var previousKey = this.GetOption('selection')[0];

        _ojNavigationListView.superclass.HandleMouseClick.apply(this, arguments);

        if (!this.isTabBar() && !this._skipSelectionAction) {
          this.FireSelectionAction(event, item, previousKey);
        }

        event.preventDefault();
      },

      /**
       * Override to support flip left/right arrows for expand and collapse actions.
       * @override
       * @protected
       */
      HandleKeyDown: function (event) {
        if (!this.m_active) {
          // If there is no active item, generally happes when user click on disabled item
          // and immediately press a key.
          return;
        }
        var keyCode = event.keyCode;
        var current = this.m_active.elem;
        var currentItemKey = this.m_active.key;

        if (keyCode === $.ui.keyCode.HOME || keyCode === $.ui.keyCode.END) {
          var item;
          if (keyCode === $.ui.keyCode.HOME) {
            item = this.element
              .find('.' + this.getItemContentStyleClass() + ':visible')
              .first()
              .closest('.' + this.getItemElementStyleClass());
          } else {
            item = this.element
              .find('.' + this.getItemContentStyleClass() + ':visible')
              .last()
              .closest('.' + this.getItemElementStyleClass());
          }
          this.SetCurrentItem(item, event);
          event.preventDefault();
        } else if (keyCode === $.ui.keyCode.DELETE && this.isTabBar()) {
          this._handleRemove(event, current);
        } else {
          var previousKey = this.GetOption('selection')[0];

          var processed = this.HandleSelectionOrActiveKeyDown(event);
          var processExpansion = this.m_listHandler.HandleExpandAndCollapseKeys(
            event,
            keyCode,
            current,
            currentItemKey
          );
          processed =
            processed ||
            processExpansion ||
            (this.m_dndContext != null && this.m_dndContext.HandleKeyDown(event));

          if (
            !this.isTabBar() &&
            (event.keyCode === $.ui.keyCode.ENTER || event.keyCode === $.ui.keyCode.SPACE)
          ) {
            this.FireSelectionAction(event, current, previousKey);
            this._skipSelectionAction = event.keyCode === $.ui.keyCode.ENTER;
            window.requestAnimationFrame(() => {
              this._skipSelectionAction = false;
            });
          }

          if (processed) {
            event.preventDefault();
          }
        }
      },

      AvoidFocusHighLight: function (flag) {
        this._avoidFocusHighLight = flag;
      },

      /**
       * check Whether recent pointer acivity happened or not.
       * Only used for sliding navlist to avoid focus ring on new focusable item
       * after completing expand/collapse animation.
       * @protected
       * @override
       */
      RecentPointerCallback: function () {
        var self = this;
        return function () {
          return !!self._avoidFocusHighLight;
        };
      },
      /**
       * Whether focus highlight should be applied
       * @return {boolean} true if should apply focus highlight, false otherwise
       * @protected
       */
      ShouldApplyHighlight: function () {
        return true;
      },
      /**
       * Override to trigger beforeSelect event when user selecets an item.
       * @override
       * @protected
       */
      // eslint-disable-next-line no-unused-vars
      ToggleSelection: function (event, keepCurrentSelection, skipIfNotSelected) {
        var item = this.m_active.elem;

        if (!this.IsSelectable(item[0])) {
          return;
        }
        if (this._isSelected(item)) {
          return;
        }
        var shouldSelect = this._fireBeforeSelectEvent(event, item);
        if (shouldSelect) {
          _ojNavigationListView.superclass.ToggleSelection.apply(this, arguments);
          this._initiateNavigation(item);
        }
      },
      /**
       * Highlight or unhighlight an element
       * @param {jQuery|Element} elem the element the highlight or unhighlight
       * @param {string} style the style to add or remove
       * @param {boolean} highlight true if it's to highlight, false if it's to unhighlight
       * @override
       * @protected
       */
      HighlightUnhighlightElem: function (elem, style, highlight) {
        var jqElem = $(elem);

        if (style === 'oj-selected') {
          this.m_listHandler.UpdateAriaPropertiesOnSelectedItem(this.getFocusItem(jqElem), highlight);
        }

        // if item is a group, the highlight should be apply to the group item element
        var group = jqElem.children('.' + this.getGroupItemStyleClass());
        if (group.length > 0) {
          jqElem = $(group[0]);
        }

        if (style === 'oj-focus') {
          if (highlight) {
            this._focusInHandler(jqElem);
          } else {
            this._focusOutHandler(jqElem);
          }
        } else if (highlight) {
          jqElem.addClass(style);
        } else {
          jqElem.removeClass(style);
        }

        if (
          jqElem.hasClass('oj-selected') ||
          jqElem.hasClass('oj-focus') ||
          jqElem.hasClass('oj-hover') ||
          jqElem.hasClass('oj-active') ||
          jqElem.hasClass(_OJ_DISABLED)
        ) {
          // show trailing icon on tabbar only when state is active, hover, selected or has focus
          if (jqElem.hasClass(this.getRemovableStyleClass()) && this.isTabBar()) {
            jqElem.find('.' + this.getNavListRemoveIcon()).css('visibility', 'visible');
          }
          jqElem.removeClass(_OJ_DEFAULT);
        } else {
          // remove trailing icon on tabbar  when state is not active, hover, selected or focused
          if (this.isTabBar()) {
            jqElem.find('.' + this.getNavListRemoveIcon()).css('visibility', 'hidden');
          }
          jqElem.addClass(_OJ_DEFAULT);
        }
      },

      /**
       * In Navlist,it is not gaurenteed that item will have aria-selected. So overriding it to make all items selectable.
       * @override
       * @protected
       */
      IsSelectable: function (item) {
        return !$(item).hasClass(_OJ_DISABLED) && this.m_listHandler.IsSelectable($(item));
      },

      /**
       * Override to skip firing events like ready which are not needed for navlist.
       * @override
       * @protected
       */
      Trigger: function (type, event, ui) {
        if (type !== 'ready') {
          return this.ojContext._trigger(type, event, ui);
        }
        return true;
      },

      /**
       * Override to convert selection option value from array to string before setting on component.
       * @override
       * @protected
       */
      SetOption: function (key, value, flags) {
        if (this.m_listHandler.IsOptionUpdateAllowed(key, value, flags)) {
          var modifiedValue = null;
          if (key === 'selection') {
            // selection Data type is different for listview and navlist
            // change items to item as navlist does't allow multiple selection.
            var context = flags._context;
            var selectedItem = context && context.extraData && context.extraData.items;

            if (selectedItem) {
              // extraData['items'] is a jquery object(not an array) and in case of navlist it will always have single item.
              if (this.ojContext._IsCustomElement()) {
                if (selectedItem.length === 0) {
                  context.extraData.item = null;
                } else {
                  context.extraData.item = selectedItem[0];
                }
              } else {
                context.extraData.item = selectedItem;
              }
              context.extraData.items = undefined;
            }

            if (value && value.length > 0) {
              modifiedValue = value[0];
            }
            this._fireDeselectEvent(context.originalEvent, selectedItem, value);
          } else {
            modifiedValue = value;
          }

          // Common options
          this.ojContext.option(key, modifiedValue, flags);
          this.options[key] = value;
          this.m_listHandler.OptionUpdated(key, modifiedValue, flags);
        }
      },

      /**
       * Whether ListView should refresh if certain option is updated
       * @param {Object} options the options to check
       * @return {boolean} true if should refresh, false otherwise
       * @override
       * @protected
       */
      ShouldRefresh: function (options) {
        return (
          options.data != null ||
          options.drillMode != null ||
          options.item != null ||
          options.display != null ||
          options.layout != null ||
          options.edge != null
        );
      },

      /**
       * Sets multiple options
       * @param {Object} options the options object
       * @param {Object} flags additional flags for option
       * @return {Object} result result object holding skipUpdate and needRefresh flags.
       * @override
       */
      setOptions: function (options, flags) {
        var result = {
          skipOptions: []
        };
        var newSelectionValue;

        this.m_listHandler.SetOptions(options);

        if (options.navigationLevel !== undefined) {
          this._setNavigationLevel(options.navigationLevel);
        }
        const hasSelectionProperty = Object.hasOwn(options, 'selection');
        if (hasSelectionProperty) {
          newSelectionValue = options.selection;
        }
        result.needRefresh = _ojNavigationListView.superclass.setOptions.call(this, options, flags);
        // if previously selection propery existed but it does not exist now then skip it
        if (hasSelectionProperty && !Object.hasOwn(options, 'selection')) {
          result.skipOptions.push('selection');
        }
        // Restore original user provided selection value
        if (hasSelectionProperty) {
          // eslint-disable-next-line no-param-reassign
          options.selection = newSelectionValue;
        }
        return result;
      },

      compareValues: function (value1, value2) {
        return value1 === value2 || oj.Object.compareValues(value1, value2);
      },

      /**
       * Set Selection option.
       * @param {Object} options the options object
       * @override
       */
      HandleSelectionOption: function (options) {
        if (!Object.hasOwn(options, 'selection')) {
          return;
        }

        var newSelectionValue = options.selection;
        if (newSelectionValue !== null && newSelectionValue !== undefined) {
          var selection = this.GetOption('selection');
          if (
            !selection ||
            selection.length === 0 ||
            !this.compareValues(selection[0], newSelectionValue)
          ) {
            var item = this.FindElementByKey(newSelectionValue);
            if (!item || this.IsSelectable(item)) {
              var shouldSelect = this._fireBeforeSelectEvent(null, $(item), newSelectionValue);
              if (shouldSelect) {
                this._fireDeselectEvent(null, item, newSelectionValue);
                // eslint-disable-next-line no-param-reassign
                options.selection = [newSelectionValue];
                this.m_listHandler.HandleSelectionChange(item);
                if (item) {
                  this._initiateNavigation($(item));
                }
              } else {
                // eslint-disable-next-line no-param-reassign
                delete options.selection;
              }
            } else {
              // eslint-disable-next-line no-param-reassign
              delete options.selection;
            }
          } else {
            // When new value is same as existing one, no need to update it on listview.
            // eslint-disable-next-line no-param-reassign
            delete options.selection;
          }
        } else {
          // eslint-disable-next-line no-param-reassign
          options.selection = [];
        }

        _ojNavigationListView.superclass.HandleSelectionOption.call(this, options);
      },

      /**
       * Override to convert selection option value from string to array before setting on component.
       * @override
       * @protected
       */
      GetOption: function (key) {
        var optionValue = this.ojContext.option(key);
        if (key === 'selection') {
          // selection Data type is different for listview and navlist
          if (optionValue != null) {
            // in navlist & tabbar item with index 0 is not getting selected
            return [optionValue];
          }
          return [];
        }

        if (key === 'item' && !optionValue.focusable) {
          optionValue.focusable = this._focusable;
        }

        if (optionValue === null) {
          // if the option is only applicable to listview
          return this.options[key];
        }
        return optionValue;
      },

      /**
       * Override to return widget constructor
       * @override
       */
      getWidgetConstructor: function () {
        return Components.__GetWidgetConstructor(this.ojContext.element);
      },

      /**
       * Override to skip intermediate nodes(only in case of collapsible) and disabled items from selection.
       * @override
       * @protected
       */
      SelectAndFocus: function (item, event) {
        // Disabled items are not selectable and focuable.
        if (item.hasClass(_OJ_DISABLED)) {
          return;
        }

        if (!this.IsSelectable(item[0])) {
          return;
        }

        if (!this._isSelected(item) && this._fireBeforeSelectEvent(event, item)) {
          _ojNavigationListView.superclass.SelectAndFocus.apply(this, arguments);
          this._initiateNavigation(item);
        } else {
          // clicking on selected item/item whose selection is prevented should also get focus.
          this.HandleClickActive(item, event);
        }
      },

      isTabBar: function () {
        return this.ojContext.element[0].tagName.toLowerCase() === this.TAG_NAME_TAB_BAR;
      },

      _fireBeforeDeselectEvent: function (event, item, key) {
        if (!key) {
          // eslint-disable-next-line no-param-reassign
          key = this.GetKey(item[0]);
        }

        var fromKey = this.GetOption('selection');
        var fromItem = this.FindElementByKey(fromKey);
        return this.Trigger('beforeDeselect', event, {
          toItem: item,
          toKey: key,
          fromItem: fromItem,
          fromKey: fromKey
        });
      },

      _fireBeforeSelectEvent: function (event, item, key) {
        var beforeDeselect = true;

        if (!key) {
          // eslint-disable-next-line no-param-reassign
          key = this.GetKey(item[0]);
        }

        if (this.isTabBar()) {
          beforeDeselect = this._fireBeforeDeselectEvent(event, item, key);
        }
        return (
          beforeDeselect &&
          this.Trigger('beforeSelect', event, {
            item: item,
            key: key
          })
        );
      },

      _fireRemoveEvent: function (event, item) {
        var key = this.GetKey(item[0]);
        var beforeRemove = this.Trigger('beforeRemove', event, {
          item: item,
          key: key
        });
        return (
          beforeRemove &&
          this.Trigger('remove', event, {
            item: item,
            key: key
          })
        );
      },

      _fireDeselectEvent: function (event, item, key) {
        var fromKey = this.GetOption('selection');
        var fromItem = this.FindElementByKey(fromKey);
        this.Trigger('deselect', event, {
          toItem: item,
          toKey: key,
          fromItem: fromItem,
          fromKey: fromKey
        });
      },

      FireSelectionAction: function (event, item, previousKey) {
        var key = this.GetKey(item[0] || item);
        this.Trigger('selectionAction', event, {
          value: key,
          previousValue: previousKey
        });
      },

      _initiateNavigation: function (item) {
        if (this.ojContext.element.hasClass(this.getNoFollowLinkStyleClass())) {
          return false;
        }

        var itemContent = this.getItemContentElement(item);
        var url = itemContent.attr('href');
        var target = itemContent.attr('target');
        if (url && url !== '#') {
          // In case of javascript uri, javascript will get executed on assigning it to href.
          // Ideally user can use beforeSelect/optionChange events to do this,Will there be any issue in supporting this?
          if (!target || target === '_self') {
            window.location.href = url;
          } else {
            window.open(url, target);
          }

          return true;
        }
        return false;
      },

      _isSelected: function (item) {
        var selection = this.GetOption('selection');
        var key = this.GetKey(item[0]);
        if (selection && selection.length === 1 && this.compareValues(selection[0], key)) {
          return true;
        }
        return false;
      },

      _setToolTipOnIcon: function (icon, itemLabel) {
        if (!icon.attr('title')) {
          icon.attr('title', itemLabel);
        }
      },

      _removeToolTipOnIcon: function (icon) {
        if (!icon.data(this._NAVLIST_ITEM_ICON_HAS_TITLE)) {
          icon.removeAttr('title');
        } else {
          icon.removeData(this._NAVLIST_ITEM_ICON_HAS_TITLE);
        }
      },

      /**
       * Retrieves the root element
       * @override
       * @return {jQuery} root element
       */
      GetRootElement: function () {
        return this.ojContext.element;
      },

      /**
       * Override to ignore remove icon link.
       * @param {jQuery} item  Item
       * @override
       * @private
       * @ignore
       */
      getSingleFocusableElement: function (item) {
        var self = this;
        var selector = 'a, input, select, textarea, button';
        var childElements = item.children(selector).filter(function () {
          return !(
            $(this).hasClass(self.getNavListRemoveIcon()) ||
            $(this).hasClass(self.getExpandIconStyleClass())
          );
        });

        if (
          childElements.length === 1 && // check for only one focusbale child
          childElements
            .first()
            .find(selector)
            .filter(function () {
              return !$(this).hasClass(self.getNavListRemoveIcon());
            }).length === 0
        ) {
          // check to ensure no nested focusable elements.
          return childElements.first();
        }
        return item;
      },

      /**
       * Override to decorate remove menu item
       * @param {jQuery} item  Item
       * @override
       * @ignore
       */
      PrepareContextMenu: function (item) {
        var contextMenu = this.ojContext._GetContextMenu();

        if (this.m_dndContext != null && contextMenu) {
          this.m_dndContext.prepareContextMenu(contextMenu);
        }

        if (item.hasClass(this.getRemovableStyleClass()) && contextMenu) {
          if (this.m_contextMenu !== contextMenu) {
            this.m_contextMenu = contextMenu;
            contextMenu.addEventListener('ojAction', this._handleContextMenuSelect.bind(this));
          }

          // Element that is going to be removed from the tab bar
          this.m_contextMenuItem = item;

          var removeItem = $(contextMenu).find(
            '[data-oj-command=' + this.getNavListRemoveCommand() + ']'
          );
          var textNode = this.ojContext.getTranslatedString('labelRemove');
          if (!this.ojContext._IsCustomElement()) {
            removeItem.empty().append($('<a href="#"></a>').text(textNode)); // @HTMLUpdateOK
          } else {
            removeItem.empty().append(document.createTextNode(textNode)); // @HTMLUpdateOK
          }
          contextMenu.refresh();
        }
      },

      _handleContextMenuSelect: function (event) {
        var item = $(event.target);
        if (item.attr('data-oj-command') === this.getNavListRemoveCommand()) {
          this._handleRemove(event, this.m_contextMenuItem);
        }
      },

      _handleRemove: function (event, item) {
        if (item.hasClass(this.getRemovableStyleClass())) {
          this._fireRemoveEvent(event, item);
        }
      },

      _wrapInner: function (ele, wrapper) {
        var children = ele.childNodes;
        while (children.length > 0) {
          wrapper.appendChild(children[0]);
        }
        ele.appendChild(wrapper);
      },

      /**
       * Called by content handler once the content of an item is rendered
       * @param {Element} elem the item element
       * @param {Object} context the context object used for the item
       */
      // eslint-disable-next-line no-unused-vars
      itemRenderComplete: function (elem, context) {
        var $item = $(elem);
        var self = this;

        if ($item.hasClass(this.getCategoryDividerStyleClass())) {
          $item.removeClass(this.getItemElementStyleClass());
          $item.removeClass(this.getFocusedElementStyleClass());
          $item.removeClass(this.getItemStyleClass());
          $item.removeAttr('aria-selected');
          $item.children().remove();
          $item.attr('role', 'separator');
          return;
        }

        var groupItemClass = this.getGroupItemStyleClass();
        var collapseIconClass = this.getCollapseIconStyleClass();
        var expandIconClass = this.getExpandIconStyleClass();
        var itemIconClass = this.getItemIconStyleClass();
        var itemBadgeClass = this.getItemBadgeStyleClass();
        var groupItem = $item.children('.' + groupItemClass);
        var itemContent;

        if (groupItem.length > 0) {
          // Adding oj-navigationlist-item class on group node. Listview does't add this any more.
          groupItem.addClass(this.getItemStyleClass());
          itemContent = groupItem.children(
            ':not(.' + expandIconClass + '):not(.' + collapseIconClass + ')'
          );
          var groupIcon = groupItem.children('.' + expandIconClass);
          if (groupIcon.length === 0) {
            groupIcon = groupItem.children('.' + collapseIconClass);
          }
          groupIcon.removeAttr('aria-labelledby');
          if ($item.hasClass(_OJ_DISABLED)) {
            groupItem.addClass(_OJ_DISABLED);
          }
        } else {
          itemContent = $item.children().first();
        }

        if (itemContent.length > 0) {
          itemContent.addClass(this.getItemContentStyleClass());
          var itemLabelClass = this.getItemLabelStyleClass();
          var itemLabelElement = itemContent[0].querySelector('.' + itemLabelClass);
          var icon = itemContent.find('.' + itemIconClass);
          var badge = itemContent.find('.' + itemBadgeClass);
          // if element with label style class already exists, no need to create wrapper
          // or rearrange the icon/badge
          if (itemLabelElement == null) {
            itemLabelElement = document.createElement('span');
            itemLabelElement.classList.add(itemLabelClass);
            this._wrapInner(itemContent[0], itemLabelElement);

            if (badge.length > 0) {
              badge.insertAfter(itemLabelElement); // @HTMLUpdateOK
            }

            if (icon.length > 0) {
              icon.insertBefore(itemLabelElement); // @HTMLUpdateOK
            }
          }
          if (icon.length > 0) {
            if (icon.attr('title')) {
              // preserve the title to restore it after destroy.
              icon.data(this._NAVLIST_ITEM_ICON_HAS_TITLE, icon.attr('title'));
            }

            if (this.ojContext.options.display === 'icons') {
              this.ojContext.element.addClass(this.getIconOnlyStyleClass());
              var itemLabel = this.getItemLabel($item);
              if (itemLabel !== null || itemLabel.length > 0) {
                icon.attr(_ARIA_LABEL, itemLabel); // @HTMLUpdateOK
                icon.attr('role', 'img');
                this._setToolTipOnIcon(icon, itemLabel);
              }
            }

            if (this.ojContext.options.display === 'stacked') {
              if (!this.ojContext.element.hasClass(this.getStackedIconStyleClass())) {
                this.ojContext.element.addClass(this.getStackedIconStyleClass());
                this.isStackedIconClassAdded = true;
              }
              icon.attr('role', 'img');
            }
            this.element.closest('ul').addClass(self.getHasIconsStyleClass());
          } else {
            itemContent.addClass(this.getHasNoIconStyleClass());
          }

          if ($item.hasClass(this.getRemovableStyleClass()) && this.isTabBar()) {
            // we'll need to move icon/label into its own layout since the
            // removable icon cannot be in the same layout as this
            var labelIconContainer = document.createElement('div');
            labelIconContainer.classList.add('oj-tabbar-icon-label-container');
            if (icon.length > 0) {
              labelIconContainer.appendChild(icon[0]);
            }
            labelIconContainer.appendChild(itemLabelElement);
            if (badge.length > 0) {
              labelIconContainer.appendChild(badge[0]);
            }
            itemContent[0].appendChild(labelIconContainer);

            if (this.m_handleRemovableLink == null) {
              this.m_handleRemovableLink = this._handleRemovableLink.bind(this);
            }

            var removableLink = $('<a>');
            removableLink
              .addClass(this.getNavListRemoveIcon())
              .addClass('oj-clickable-icon-nocontext oj-component-icon')
              .attr(_ARIA_LABEL, this.ojContext.getTranslatedString('removeCueText')) // @HTMLUpdateOK
              .attr('role', 'img'); // @HTMLUpdateOK
            removableLink[0].addEventListener('click', this.m_handleRemovableLink);
            // Touch devices, the trailing icon will be always visible
            if ($item.hasClass(_OJ_DISABLED)) {
              removableLink.css('visibility', 'visible');
            } else {
              removableLink.css('visibility', 'hidden');
            }
            itemContent.append(removableLink); // @HTMLUpdateOK
            itemContent.attr('aria-describedby', removableLink.uniqueId().attr('id'));
          }
        }

        if ($item.hasClass(_OJ_DISABLED)) {
          this.getFocusItem($item).attr('aria-disabled', 'true');
        } else if (groupItem.length > 0) {
          groupItem.addClass(_OJ_DEFAULT);
        } else {
          $item.addClass(_OJ_DEFAULT);
        }

        this.m_listHandler.ModifyListItem($item, itemContent);
        _ojNavigationListView.superclass.itemRenderComplete.apply(this, arguments);
      },

      /**
       * Destroy the content handler
       * @protected
       * @override
       */
      // eslint-disable-next-line no-unused-vars
      DestroyContentHandler: function (completelyDestroy) {
        var data = this.GetOption('data');
        if (data === null) {
          this._restoreContent(this.element);
        }
        _ojNavigationListView.superclass.DestroyContentHandler.apply(this, arguments);
      },

      /**
       * Return node for given locator
       *
       * @override
       */
      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.ojContext.element ? this.ojContext.element[0] : null;
        }

        var item = this.m_listHandler.GetNodeBySubId(locator);

        if (!item) {
          var subId = locator.subId;
          if (subId === this.getItemSubIdKey()) {
            var key = locator.key;
            item = this.FindElementByKey(key);
          }
        }

        return item;
      },

      /**
       * Returns the subId locator for the given child DOM node.
       * Invoked by widget
       * @param {!Element} node - child DOM node
       * @return {Object|null} The locator for the DOM node, or <code class="prettyprint">null</code> when none is found.
       */
      getSubIdByNode: function (node) {
        var subId = null;

        if (node != null) {
          subId = this.m_listHandler.GetSubIdByNode(node);

          if (!subId) {
            var item = this.FindItem(node);
            if (item != null && item.length > 0) {
              var key = this.GetKey(item[0]);
              if (key != null) {
                subId = {
                  subId: this.getItemSubIdKey(),
                  key: key
                };
              }
            }
          }
        }

        return subId;
      },

      /**
       * Returns an object with context for the given child DOM node.
       * This will always contain the subid for the node, defined as the 'subId' property on the context object.
       * Additional component specific information may also be included. For more details on returned objects, see context objects.
       * Invoked by widget
       *
       * @param {!Element} node the child DOM node
       * @returns {Object|null} the context for the DOM node, or null when none is found.
       */
      getContextByNode: function (node) {
        var context = _ojNavigationListView.superclass.getContextByNode.call(this, node);
        if (context && context.subId === 'oj-listview-item') {
          context.subId = this.getItemSubIdKey();
          return context;
        }
        return null;
      },

      /**
       * Refresh navlist
       * @override
       */
      refresh: function () {
        this._resetNavlist();
        this._initListHandler();
        _ojNavigationListView.superclass.refresh.apply(this, arguments);
      },

      /**
       * Uninitialize dom.
       * @private
       */
      _resetNavlist: function () {
        this.ojContext.element.removeClass(this.getIconOnlyStyleClass());
        if (this.isStackedIconClassAdded) {
          this.ojContext.element.removeClass(this.getStackedIconStyleClass());
        }
        this.ojContext.element.removeClass(this.getCondenseStyleClass());
        this.ojContext.element.removeClass(this._APPLICATION_LEVEL_NAV_STYLE_CLASS);
        this.ojContext.element.removeClass(this._PAGE_LEVEL_NAV_STYLE_CLASS);
        this._restoreContent(this.element);
        this.m_listHandler.Destroy();
      },

      /**
       * Destroy the Navigation List
       * @override
       */
      destroy: function () {
        this._resetNavlist();
        _ojNavigationListView.superclass.destroy.apply(this, arguments);
        this._list.unwrap();
        // for data source, this will be empty.
        if (this._list.is(':empty')) {
          this._list.remove();
        }
        this.ojContext.element.removeClass(
          this.getNavListStyleClass() + ' ' + this.getNavListTouchStyleClass()
        );
        this.ojContext._off(this.element, 'click');
        this.ojContext._off(this.element, 'focus');
        this.ojContext._off(this.element, 'blur');
        this.ojContext._off(this.element, 'mouseover');
        this.ojContext._off(this.element, 'mousein');
        this.ojContext._off(this.element, 'mouseout');
        this.ojContext._off(this.element, 'keydown');
        this.m_handleRemovableLink = null;
      }
    }
  );

  _ojNavigationListView._CSS_Vars = {
    navlist: {
      animation: {
        addHorizontalItem: '--oj-private-navigation-list-global-horizontal-add-animation-default',
        removeHorizontalItem:
          '--oj-private-navigation-list-global-horizontal-remove-animation-default',
        add: '--oj-private-navigation-list-global-add-animation-default',
        remove: '--oj-private-navigation-list-global-remove-animation-default',
        update: '--oj-private-navigation-list-global-update-animation-default',
        expand: '--oj-private-navigation-list-global-expand-animation-default',
        collapse: '--oj-private-navigation-list-global-collapse-animation-default',
        sliderExpand: '--oj-private-navigation-list-global-slider-expand-animation-default',
        sliderCollapse: '--oj-private-navigation-list-global-slider-collapse-animation-default',
        pointerUp: '--oj-private-navigation-list-global-pointer-up-animation-default'
      },
      hierarchyMenuDisplayThresholdLevel:
        '--oj-private-navigation-list-global-hierarchy-menu-threshold-default',
      showIndicatorDelay: '--oj-private-core-global-loading-indicator-delay-duration'
    },
    tabbar: {
      animation: {
        addHorizontalItem: '--oj-private-tab-bar-global-horizontal-add-animation-default',
        removeHorizontalItem: '--oj-private-tab-bar-global-horizontal-remove-animation-default',
        add: '--oj-private-tab-bar-global-add-animation-default',
        remove: '--oj-private-tab-bar-global-remove-animation-default',
        update: '--oj-private-tab-bar-global-update-animation-default',
        pointerUp: '--oj-private-tab-bar-global-pointerUp-animation-default'
      },
      showIndicatorDelay: '--oj-private-core-global-loading-indicator-delay-duration'
    }
  };

  (function () {
    /**
     * @ojcomponent oj.ojNavigationList
     * @augments oj.baseComponent
     * @since 1.1.0
     *
     * @ojrole menu
     * @ojrole tree
     * @ojrole listbox
     * @ojrole toolbar
     * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
     * @ojtsimport {module: "ojkeyset", type: "AMD", imported:["KeySet"]}
     * @ojsignature [{
     *                target: "Type",
     *                value: "class ojNavigationList<K, D> extends baseComponent<ojNavigationListSettableProperties<K,D>>",
     *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
     *               },
     *               {
     *                target: "Type",
     *                value: "ojNavigationListSettableProperties<K,D> extends baseComponentSettableProperties",
     *                for: "SettableProperties"
     *               }
     *              ]
     * @ojshortdesc A navigation list allows navigation between different content sections.
     *
     * @ojpropertylayout {propertyGroup: "common", items: ["display", "drillMode", "rootLabel"]}
     * @ojpropertylayout {propertyGroup: "data", items: ["data", "selection"]}
     * @ojvbdefaultcolumns 2
     * @ojvbmincolumns 1
     *
     * @ojoracleicon 'oj-ux-ico-navigation'
     * @ojuxspecs ['nav-list']
     *
     * @classdesc
     * <h3 id="navlistOverview-section">
     *   JET Navigation List
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#navlistOverview-section"></a>
     * </h3>
     *
     * <p>Description: JET Navigation List enhances a HTML list element into a themable, WAI-ARIA compliant, mobile friendly component with advance interactive features.
     * <h3 id="data-section">
     *   Data
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
     * </h3>
     * <p>The JET NavigationList gets its data in three different ways.  The first way is from a DataProvider/TableDataSource.  There are several types of DataProvider/TableDataSource
     * that are available out of the box:</p>
     * <ul>
     * <li>oj.ArrayDataProvider</li>
     * <li>oj.CollectionTableDataSource</li>
     * </ul>
     *
     * <p><b>oj.ArrayDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, Navigation List will automatically react
     * when items are added or removed from the array.  See the documentation for <a href="ArrayDataProvider.html">ArrayDataProvider</a> for more details on the available options.</p>
     *
     * <p><b>oj.CollectionTableDataSource</b> - Use this when oj.Collection is the model for the underlying data.  Note that the Navigation List will automatically react to model event from
     * the underlying oj.Collection.  See the documentation for <a href="CollectionTableDataSource.html">CollectionTableDataSource</a> for more details on the available options.</p>
     *
     * <p> NOTE: PagingTableDataSource is not supported by Navigation List.
     *
     * <p>The second way is from a TreeDataProvider/TreeDataSource.  This is typically used to display data that are logically categorized in groups.  There are several types
     * of TreeDataProvider/TreeDataSource that are available out of the box:</p>
     * <ul>
     * <li>oj.ArrayTreeDataProvider</li>
     * <li>oj.CollectionTreeDataSource</li>
     * </ul>
     *
     * <p><b>oj.ArrayTreeDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, NavigationList will
     * automatically  react when items are added or removed from the array.  See the documentation of <a href="ArrayTreeDataProvider.html">oj.ArrayTreeDataProvider</a> for more details on the available options.</p>
     *
     * <p><b>oj.CollectionTreeDataSource</b> - Use this when oj.Collection is the model for each group of data.  See the documentation for <a href="CollectionTreeDataSource.html">oj.CollectionTreeDataSource</a>
     * for more details on the available options.</p>
     *
     * <p>Finally, Navigation List also supports static HTML content as data.  The structure of the content can be either flat or hierarhical. Note: <code class="prettyprint">data</code> attribute should not be set when static HTML content is used.</p>
     * <p>Note that any manipulation of static HTML content, including manipulating content generated through Knockout (for example, updating observableArray in a foreach binding), is not supported.<p>
     *
     * <p>Example of flat static content</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-navigation-list>
     *  &lt;ul>
     *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
     *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
     *   &lt;li>&lt;a href="#">Item 3&lt;/a>&lt;/li>
     *  &lt;/ul>
     * &lt;/oj-navigation-list>
     * </code></pre>
     *
     * <p>Example of hierarchical static content</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-navigation-list>
     *  &lt;ul >
     *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
     *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
     *   &lt;li>&lt;a href="#">Item 3&lt;/a>
     *     &lt;ul>
     *       &lt;li>&lt;a href="#">Item 3-1&lt;/a>&lt;/li>
     *       &lt;li>&lt;a href="#">Item 3-2&lt;/a>&lt;/li>
     *       &lt;li>&lt;a href="#">Item 3-3&lt;/a>&lt;/li>
     *       &lt;li>&lt;a href="#">Item 3-4&lt;/a>&lt;/li>
     *       &lt;li>&lt;a href="#">Item 3-5&lt;/a>&lt;/li>
     *     &lt;/ul>
     *   &lt;/li>
     *   &lt;li>&lt;a href="#">Item 4&lt;/a>&lt;/li>
     *   &lt;li>&lt;a href="#">Item 5&lt;/a>&lt;/li>
     *  &lt;/ul>
     * &lt;/oj-navigation-list>
     * </code></pre>
     *
     * <p>Example of data provider content</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-navigation-list data="[[dataProvider]]">&lt;/oj-navigation-list>
     * </code></pre>
     *
     * <p>The child content can be configured via inline HTML content or a DataProvider.
     * It is recommended that inline HTML content should only be used for static data and the DataProvider should always be used for mutable data.
     * </p>
     *
     * <h4 id="treeJSON-section"> JSON Tree Node Format</h4>
     * </br>
     * Each node object typically have an
     * <code class="prettyprint">attr</code> property. This attr value will be provided as <code class="prettyprint">itemContext.data</code> to renderer function. See <a href="#context-section">itemContext</a> section. Any node can be defined as a parent by supplying
     * a <code class="prettyprint">children</code> property, which is an array of one or more node definitions.
     * (Note: lazy-loading is not supported in navigation list so <code class="prettyprint">children</code> property should be a non empty array)
     * <p>Example: Basic JSON Tree definition
     * <pre class="prettyprint">
     * <code>
     *[
     *   {
     *     "attr": {
     *               "id": "home",
     *               "title": "Home"
     *             },
     *   },
     *   {
     *     "attr": {
     *               "id": "news",
     *               "title": "News"
     *             }
     *   },
     *   {
     *      "attr": {
     *                "id": "blogs",
     *                "title": "Blogs"
     *              },
     *      "children": [ {
     *
     *                       "attr": {
     *                                   "id": "today",
     *                                   "title": "Today"
     *                               }
     *                    },
     *                    {
     *                       "attr": {
     *                                   "id": "yesterday",
     *                                   "title": "Yesterday"
     *                               }
     *                    }
     *                  ]
     *   }
     *]
     *</code></pre>
     *</p></br>
     *
     * <h3 id="key-section">
     *   Key
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#key-section"></a>
     * </h3>
     * <p>Key is an identifier which uniquely identifies an item in Navigation List.
     *  <ul>
     *  <li>When static html is used, it will be the <code class="prettyprint">id</code> attribute of <code class="prettyprint">&lt;li></code>. If no <code class="prettyprint">id</code> is specified then component will generate an id and will use it as key.</li>
     *  <li>When data source is used, it will be the <code class="prettyprint">id</code> attribute of item's data object.
     *  </ul>
     * <h3 id="icons-section">
     *   Icons
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#icons-section"></a>
     * </h3>
     *
     * <p>Sublist icons are inserted automatically.  To add other icons to list items, include them in the markup and include the <code class="prettyprint">oj-navigationlist-item-icon</code> class, as follows:
     *
     * <pre class="prettyprint">
     * <code>&lt;oj-navigation-list>
     *   &lt;ul>
     *     &lt;li id="foo">&lt;a href="#">&lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">&lt;/span>Foo&lt;/a>&lt;/li>
     *   &lt;/ul>
     *  &lt;/oj-navigation-list>
     * </code></pre>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * {@ojinclude "name":"keyboardDoc"}
     *
     *
     *<h3 id="context-section">
     *   Item Context
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
     * </h3>
     *
     * <p>For all item options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular item.  This gives developers the flexibility to return different value depending on the context.</p>
     *
     * <p>The context paramter contains the following keys:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>componentElement</kbd></td>
     *       <td>oj-navigation-list element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>datasource</kbd></td>
     *       <td>A reference to the data source object. (Not available for static content)</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>index</kbd></td>
     *       <td>The index of the item, where 0 is the index of the first item.  In the hierarchical case the index is relative to its parent.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>key</kbd></td>
     *       <td>The <a href="#key-section">Key</a> of the item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data</kbd></td>
     *       <td>The data object for the item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parentElement</kbd></td>
     *       <td>The list item element.  The renderer can use this to directly append content.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p></p>
     * <p>If the data is hierarchical, the following additional contextual information are available:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>depth</kbd></td>
     *       <td>The depth of the item.  The depth of the first level children under the invisible root is 1.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parentKey</kbd></td>
     *       <td>The <a href="#key-section">Key</a> of the parent item.  The parent key is null for root node.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>leaf</kbd></td>
     *       <td>Whether the item is a leaf or a group item.</td>
     *     </tr>
     *   </tbody>
     * </table>
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Data Set Size</h4>
     * <p>As a rule of thumb, it's recommended that applications limit the amount of data to display.  Displaying large
     * number of items in Navigation List makes it hard for user to find what they are looking for, but affects the load time.
     * If displaying large number of items is neccessary, it is recommended to group the items in to hierarchial navigation list.
     *
     * <h4>Item Content</h4>
     * <p>Navigation List allows developers to specify arbitrary content inside its item. In order to minimize any negative effect on
     * performance, you should avoid putting a large number of heavy-weight components inside because as you add more complexity
     * to the structure, the effect will be multiplied because there can be many items in the Navigation List.</p>
     *
     * <h4>Expand All</h4>
     * <p>While Navigation List provides a convenient way to initially expand all group items, it might have an impact
     * on the initial rendering performance since expanding each group item might cause a fetch from the server depending on
     * the TreeDataSource.  Other factors that could impact performance includes the depth of the tree, and the number of children
     * in each level.</p>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET custom element, in the unusual case that the reading direction
     * is changed post-init, the navigation list must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
     *
     *
     * <h3 id="animation-section">
     *   Animation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#animation-section"></a>
     * </h3>
     *
     * <p>Applications can customize animations triggered by actions in Navigation List by overriding action specific style classes on the animated item.  See the documentation of <a href="AnimationUtils.html">AnimationUtils</a>
     *    class for details.</p>
     *
     * <p>The following are actions in which applications can use to customize animation effects.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Action</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>horizontal add</kbd></td>
     *       <td>When a new item is added to the TableDataSource associated with Horizontal Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>add</kbd></td>
     *       <td>When a new item is added to the TableDataSource associated with Vertical Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>horizontal remove</kbd></td>
     *       <td>When an existing item is removed from the TableDataSource associated with Horizontal Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>remove</kbd></td>
     *       <td>When an existing item is removed from the TableDataSource associated with Vertical Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>update</kbd></td>
     *       <td>When an existing item is updated in the TableDataSource associated with Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>expand</kbd></td>
     *       <td>When user expands a group item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>slider expand</kbd></td>
     *       <td>When user expands a group item in sliding navigation list.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>collapse</kbd></td>
     *       <td>When user collapses a group item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>slider collapse</kbd></td>
     *       <td>When user collapses a group item in sliding navigation list.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>pointerUp</kbd></td>
     *       <td>When user finish pressing an item (on touch).</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     */

    //-----------------------------------------------------
    //                   Slots
    //-----------------------------------------------------

    /**
     * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the list. The slot content must be a &lt;template> element.
     * The content of the template could either include the &lt;li> element, in which case that will be used as
     * the root of the item.  Or it can be just the content which excludes the &lt;li> element.</p>
     * <p>When the template is executed for each item, it will have access to the binding context containing the following properties:</p>
     * <ul>
     *   <li>$current - an object that contains information for the current item. (See [oj.ojNavigationList.ItemTemplateContext]{@link oj.ojNavigationList.ItemTemplateContext} or the table below for a list of properties available on $current)</li>
     *  <li>alias - if as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
     * </ul>
     *
     * @ojslot itemTemplate
     * @ojmaxitems 1
     * @memberof oj.ojNavigationList
     * @ojshortdesc The itemTemplate slot is used to specify the template for rendering each item in the list. See the Help documentation for more information.
     * @ojtemplateslotprops oj.ojNavigationList.ItemTemplateContext
     *
     * @example <caption>Initialize the ListView with an inline item template specified:</caption>
     * &lt;oj-navigation-list>
     *   &lt;template slot='itemTemplate' data-oj-as='item'>
     *     &lt;li>&lt;a href="#">&lt;oj-bind-text value='[[item.data.name]]'>&lt;/oj-bind-text>&lt;/a>&lt;/li>
     *   &lt;/template>
     * &lt;/oj-navigation-list>
     */
    /**
     * @typedef {Object} oj.ojNavigationList.ItemTemplateContext
     * @property {Element} componentElement The &lt;oj-navigation-list> custom element
     * @property {Object} data The data for the current item being rendered
     * @property {number} index The zero-based index of the current item
     * @property {any} key The key of the current item being rendered
     * @property {number} depth The depth of the current item (available when hierarchical data is provided) being rendered. The depth of the first level children under the invisible root is 1.
     * @property {boolean} leaf True if the current item is a leaf node (available when hierarchical data is provided).
     * @property {any} parentkey The key of the parent item (available when hierarchical data is provided). The parent key is null for root nodes.
     */

    //-----------------------------------------------------
    //                   Fragments
    //-----------------------------------------------------

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="2">List Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Selects the item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Press & Hold</kbd></td>
     *       <td>Display context menu</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Group Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Expand or collapse the group item if <code class="prettyprint">drillMode</code> is set to collapsible.
     *       When <code class="prettyprint">drillMode</code> is set to sliding, sublist will silde in.
     *       When <code class="prettyprint">drillMode</code> is set to none, group item will be selecetd.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Press & Hold</kbd></td>
     *       <td>Display context menu</td>
     *     </tr>
     *     <tr>
     *       <td>Hierarchical Menu button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Open menu. Refer <a href="oj.ojButton.html#touch-section">menu button</a> touch documentation. Note: This is applicable only for Sliding Navigation List. </td>
     *     </tr>
     *     <tr>
     *       <td>Previous Icon or List Header</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Collapses the sublist and slides to parent list. Note: This is applicable only for Sliding Navigation List. </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
     * @memberof oj.ojNavigationList
     */

    /**
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="10">List Item</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Selects list item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Moves focus to the previous visible list item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Moves focus to the next  visible list item</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
     *       <td>For horizontal navigation list,focus will be moved to next visible item.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
     *       <td>For horizontal navigation list,focus will be moved to previous visible item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Home</kbd></td>
     *       <td>Moves focus to the first visible list item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>End</kbd></td>
     *       <td>Moves focus to the last visible list item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>F2</kbd></td>
     *       <td>If focus is on a list item, pressing F2 will make its contents accessible using TAB. It can also be used to exit actionable mode if already in actionable mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>When F2 mode is enabled, press Esc to exit F2 mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>Move fous to hierarchical menu button.Only applicable for sliding navigation list and when hierarchial menu button is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Group Item</td>
     *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
     *       <td>If focus is on collapsed node, expands the sub list.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
     *       <td>If focus is on expanded node, collapses the sub list.</td>
     *     </tr>
     *     <tr>
     *       <td>List Item in sublist</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Applicable only for sliding navigation list. If focus is in a sub list, closes the sublist and moves focus to the parent list item.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="3">Hierarchical Menu button</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Open menu. Refer <a href="oj.ojButton.html#keyboard-section">menu button</a> keyboard documentation. Note: This target is visible only for Sliding Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Moves focus to current list item. Note: This target is visible only for Sliding Navigation List. </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Moves focus to Previous Icon. Note: This target is visible only for Sliding Navigation List.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Previous Icon or List Header</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Collapses the sublist and slides to parent list.Note: This target is visible only for Sliding Navigation List. </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Moves focus to Hierarchical Menu button. Note: This target is visible only for Sliding Navigation List. </td>
     *     </tr>
     *
     *   </tbody>
     * </table>
     *
     *
     * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
     * @memberof oj.ojNavigationList
     */

    //-----------------------------------------------------
    //                   Sub-ids
    //-----------------------------------------------------

    /**
     * <p>Sub-ID for the oj-navigtion-list component's list item element.</p>
     *
     * <p>
     * To lookup the list items the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-navigationlist-item'</li>
     * <li><b>key</b>: the <a href="#key-section">Key</a> of the item</li>
     * </ul>
     *
     * @ojsubid oj-navigationlist-item
     * @memberof oj.ojNavigationList
     *
     * @example <caption>Get the list item element with key 'foo':</caption>
     * var node = myNavList.getNodeBySubId({'subId': 'oj-navigationlist-item', 'key': 'foo'} );
     */
    /**
     * <p>Sub-ID for the oj-navigtion-list component's previous link element.</p>
     *
     * To lookup the previous link the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-navigationlist-previous-link'</li>
     * </ul>
     * @ojsubid oj-navigationlist-previous-link
     * @memberof oj.ojNavigationList
     *
     * @example <caption>Get the previous link element:</caption>
     * var node = myNavList.getNodeBySubId({'subId': 'oj-navigationlist-previous-link'} );
     */
    /**
     * <p>Sub-ID for the oj-navigtion-list component's hierarchical menu button element.
     * See the <a href="#getNodeBySubId">getNodeBySubId</a> method for details.</p>
     *
     * To lookup the hierarchical menu button the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-navigationlist-hierarchical-button'</li>
     * </ul>
     * @ojsubid
     * @name oj-navigationlist-hierarchical-button
     * @memberof oj.ojNavigationList
     *
     * @example <caption>Get the hierarchical menu button element:</caption>
     * var node = myNavList.getNodeBySubId({'subId': 'oj-navigationlist-hierarchical-button'} );
     */
    /**
     * <p>Sub-ID for the oj-navigation-list component's hierarchical menu element.</p>
     *
     * To lookup the hierarchical menu the locator object should have the following:
     * <ul>
     * <li><b>subId</b>: 'oj-navigationlist-hierarchical-menu'</li>
     * </ul>
     * @ojsubid
     * @name oj-navigationlist-hierarchical-menu
     * @memberof oj.ojNavigationList
     *
     * @example <caption>Get the hierarchical menu element:</caption>
     * var node = myNavList.getNodeBySubId({'subId': 'oj-navigationlist-hierarchical-menu'} );
     */

    // Node Context Objects *********************************************
    /**
     * <p>Context for the oj-navigation-list component's items.</p>
     *
     * @property {number} index the zero based item index relative to its parent
     * @property {Object|string} key the <a href="#key-section">Key</a> of the item
     * @property {Element} parent the parent group item.  Only available if item has a parent.
     * @property {boolean} group whether the item is a group.
     *
     * @ojnodecontext oj-navigationlist-item
     * @memberof oj.ojNavigationList
     */

    //-----------------------------------------------------
    //                   Styling
    //-----------------------------------------------------

    // ---------------- oj-navigationlist-stack-icon-label --------------
    /**
     * Use this class to display a Navigation List with icons and labels stacked.
     * @ojstyleclass oj-navigationlist-stack-icon-label
     * @ojdisplayname Stack Icon
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-navigationlist-stack-icon-label" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-category-divider --------------
    /**
     * Use this class to add a horizontal divider line between two categories of items.
     * @ojstyleclass oj-navigationlist-category-divider
     * @ojdisplayname Category Divider
     * @ojstyleselector "oj-navigation-list li"
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list>
     *   &lt;ul>
     *     &lt;li ...>&lt;/li>
     *     &lt;li class="oj-navigationlist-category-divider">&lt;/li>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-item-icon --------------
    /**
     * Use this class to add an icon to a list item.
     * @ojstyleclass oj-navigationlist-item-icon
     * @ojdisplayname Icon
     * @ojstyleselector "oj-navigation-list span"
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-navigationlist-stack-icon-label" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-item-end --------------
    /**
     * Use this class to add an badge/metadata/icon to a list item.
     * @ojstyleclass oj-navigationlist-item-end
     * @ojdisplayname Icon
     * @ojstyleselector "oj-navigation-list span"
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list>
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-end">
     *            &lt;span class="oj-badge oj-badge-subtle">3
     *            &lt;/span>
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-item-title --------------
    /**
     * When arbitrary content is placed inside an item's content area, its title text can be marked using this style class. This helps the component in identifying the Item's label.
     * @ojstyleclass oj-navigationlist-item-title
     * @ojdisplayname Title
     * @ojstyleselector "oj-navigation-list span"
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;li id="foo">
     *   &lt;div>
     *     &lt;span class="oj-navigationlist-item-title">Play&lt;/span>
     *       &lt;button>Button&lt;/button>
     *   &lt;/div>
     * &lt;/li>
     */
    // ---------------- oj-navigationlist-item-text-wrap --------------
    /**
     * Use this class to wrap item label text.
     * @ojstyleclass oj-navigationlist-item-text-wrap
     * @ojdisplayname Text Wrap
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-navigationlist-item-text-wrap" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-item-dividers --------------
    /**
     * Use this class to render a divider between list items.
     * @ojstyleclass oj-navigationlist-item-dividers
     * @ojdisplayname Item Dividers
     * @memberof oj.ojNavigationList
     * @ojunsupportedthemes ["Redwood"]
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-navigationlist-item-dividers" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-[size]-condense --------------
    /**
     * Use this class to condense horizontal navigation list items depending on screen size.
     * @ojstyletemplate oj-[size]-condense
     * @ojstyletemplatetokens ["StylingTemplateTokens.[size]"]
     * @ojdisplayname Condense
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-sm-condense" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-nofollow-link --------------
    /**
     * Use this class to prevent automatic navigation to the url specified on an &lt;a> tag's href attribute. <br/>
     * In this case, navigation can be handled programmatically by using selectionChanged event. <br/>
     * This is useful to execute some custom logic before browser triggers navigation.
     * @ojstyleclass oj-navigationlist-nofollow-link
     * @ojdisplayname No Follow Link
     * @ojshortdesc Use this class to prevent automatic navigation to a URL within a list item. See the Help documentation for more information.
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-navigationlist-nofollow-link" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-navigationlist-item-label --------------
    /**
     * Use this class to specify the element with the label.  This will eliminate the need for NavigationList to automatically
     * wrap any child element that is not an icon or a badge with this class.  Note the content must have the correct
     * order (icon element first, then the label element, then the badge element) as NavigationList in this case will not attempt
     * to reorder the content.
     * @ojstyleclass oj-navigationlist-item-label
     * @ojdisplayname Label
     * @ojstyleselector "oj-navigation-list span"
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-navigationlist-stack-icon-label" >
     *   &lt;ul>
     *     &lt;li id="foo">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         &lt;span class="oj-navigationlist-item-label">
     *         Foo
     *         &lt;/span>
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-focus-highlight --------------
    /**
     * Under normal circumstances this class is applied automatically.
     * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
     * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
     * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
     * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
     * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
     * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
     * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
     * @ojstyleclass oj-focus-highlight
     * @ojdisplayname Focus Styling
     * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list class="oj-focus-highlight">
     *   &lt;!-- Content -->
     * &lt;/oj-navigation-list>
     */
    // ---------------- oj-disabled --------------
    /**
     * Any list item can be disabled by adding the oj-disabled class to that element
     * @ojdeprecated {since: "17.0.0", description: "Deprecated in oj-navigation-list as it is a Redwood anti-pattern. Instead items should be hidden in cases where the user doesn't have permission"}
     * @ojstyleclass oj-disabled
     * @ojdisplayname Disabled Item
     * @ojstyleselector "oj-navigation-list li"
     * @memberof oj.ojNavigationList
     * @ojtsexample
     * &lt;oj-navigation-list>
     *   &lt;ul>
     *     &lt;li id="foo" class="oj-disabled">
     *       &lt;a href="#">
     *         &lt;span class="oj-navigationlist-item-icon demo-icon-font-24 demo-palette-icon-24">
     *         &lt;/span>
     *         Foo
     *       &lt;/a>
     *     &lt;/li>
     *   &lt;/ul>
     * &lt;/oj-navigation-list>
     */
    /**
     * @ojstylevariableset oj-navigation-list-css-set1
     * @ojstylevariable oj-navigation-list-font-size {description: "Navigation list font size", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-font-weight {description: "Navigation list font weight", formats: ["font_weight"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-icon-margin {description: "Navigation list icon margin", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-icon-to-text-padding {description: "Padding between icon and text", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-icon-size {description: "Navigation list icon size", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-item-min-height {description: "Navigation list item minimum height", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-item-margin {description: "Navigation list item margin", formats: ["length"], help: "#css-variables"}
     * @ojstylevariable oj-navigation-list-item-padding {description: "Navigation list item padding", formats: ["length"], help: "#css-variables"}
     * @memberof oj.ojNavigationList
     */
    /**
     * @ojstylevariableset oj-navigation-list-css-set2
     * @ojdisplayname Default
     * @ojstylevariable oj-navigation-list-item-label-color {description: "Default navigation list item label color", formats: ["color"], help: "#oj-navigation-list-css-set2"}
     * @memberof oj.ojNavigationList
     */
    /**
     * @ojstylevariableset oj-navigation-list-css-set3
     * @ojdisplayname Hovered
     * @ojstylevariable oj-navigation-list-item-label-color-hover {description: "Navigation list item label color when hovered", formats: ["color"], help: "#oj-navigation-list-css-set3"}
     * @ojstylevariable oj-navigation-list-item-bg-color-hover {description: "Navigation list item background color when hovered",formats: ["color"], help: "#oj-navigation-list-css-set3"}
     * @memberof oj.ojNavigationList
     */
    /**
     * @ojstylevariableset oj-navigation-list-css-set4
     * @ojdisplayname Selected
     * @ojstylevariable oj-navigation-list-item-label-color-selected {description: "Navigation list item label color when selected", formats: ["color"], help: "#oj-navigation-list-css-set4"}
     * @ojstylevariable oj-navigation-list-item-bg-color-selected {description: "Navigation list item background color when selected", formats: ["color"], help: "#oj-navigation-list-css-set4"}
     * @ojstylevariable oj-navigation-list-item-border-color-selected {description: "Navigation list item border color when selected", formats: ["color"], help: "#oj-navigation-list-css-set4"}
     * @memberof oj.ojNavigationList
     */
    /**
     * @ojstylevariableset oj-navigation-list-css-set5
     * @ojdisplayname Sliding navigation list
     * @ojstylevariable oj-navigation-list-sliding-heading-font-size {description: "Sliding navigation list heading font size", formats: ["length"], help: "#oj-navigation-list-css-set5"}
     * @ojstylevariable oj-navigation-list-sliding-heading-font-weight {description: "Sliding navigation list heading font weight", formats: ["font_weight"], help: "#oj-navigation-list-css-set5"}
     * @ojstylevariable oj-navigation-list-sliding-heading-line-height {description: "Sliding navigation list heading line height", formats: ["number"], help: "#oj-navigation-list-css-set5"}
     * @memberof oj.ojNavigationList
     */
    // --------------------------------------------------- oj.ojNavigationList Styling End -----------------------------------------------------------

    oj.__registerWidget('oj.ojNavigationList', $.oj.baseComponent, {
      widgetEventPrefix: 'oj',
      options: {
        /**
         * An alias for the current item when referenced inside the item template. This can be especially useful
         * if oj-bind-for-each element is used inside the item template since it has its own scope of data access.
         *
         * @ojshortdesc Specifies the alias for the current item when referenced inside the item template.
         *
         * @expose
         * @public
         * @instance
         * @memberof! oj.ojNavigationList
         * @type {string}
         * @default ''
         * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
         *
         * @example <caption>Initialize the NavigationList with the <code class="prettyprint">as</code> attribute specified:</caption>
         * &lt;oj-navigation-list as='item'>
         *   &lt;template slot='itemTemplate'>
         *     &lt;li>
         *     &lt;a href='#'>&lt;oj-bind-text value='[[item.data.name]]'>&lt;/oj-bind-text>&lt;/a>
         *     &lt;/li>
         *   &lt;/template>
         * &lt;/oj-navigation-list>
         */
        as: '',
        /**
         * <a href="#key-section">Key</a> of the current item.  Current item is the list item which is having active focus.  Note that if currentItem
         * is set to an item that is currently not available (not fetched or
         * inside a collapsed parent node), then the value is ignored.
         * <p>
         * When the current item is changed, the <code class="prettyprint">event.detail</code> of the <code class="prettyprint">currentItemChanged</code> event will contain the following additional properties:<br><br>
         * <table class="props">
         *   <thead>
         *     <tr>
         *       <th>Name</th>
         *       <th>Type</th>
         *       <th>Description</th>
         *     </tr>
         *   </thead>
         *   <tbody>
         *     <tr>
         *       <td class="name"><code>item</code></td>
         *       <td class="type">Element</td>
         *       <td class="description">Current Item element</td>
         *     </tr>
         *   </tbody>
         * </table>
         *
         * @expose
         * @ojshortdesc Specifies the key of the item that should have keyboard focus. See the Help documentation for more information.
         * @public
         * @instance
         * @memberof! oj.ojNavigationList
         * @type {any}
         * @ojsignature {target:"Type", value:"K"}
         * @default null
         * @ojwriteback
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">current-item</code> attribute specified:</caption>
         *  &lt;oj-navigation-list current-item='settings'> ... &lt;/oj-navigation-list>
         * @example <caption>Get the current item:</caption>
         * var currentItem = myNavList.currentItem;
         *
         * @example <caption>Set the current item on the NavigationList during initialization:</caption>
         * myNavList.currentItem = "newItem";
         */
        currentItem: null,
        /**
         * Defines style of navigation used to drill down hierarchical list items.
         * <ul>
         * <li>none</li>
         * <li>collapsible</li>
         * <li>sliding</li>
         * </ul>
         *
         * @ojshortdesc Specifies whether expand/collapse or sliding operations are allowed.
         * @expose
         * @memberof oj.ojNavigationList
         * @instance
         * @type {string}
         * @default none
         * @ojvalue {string} "none" All group items are expanded by default and user not allowed to collapse them.
         * @ojvalue {string} "collapsible" Allows user to expand and collapse group items. If there are more than two levels in hierarchy, <code class="prettyprint">sliding</code> is preferred drill mode.
         * @ojvalue {string} "sliding" This is typically used for hierarchical lists. This allows user to view one level at a time.
         *
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">drill-mode</code> attribute specified:</caption>
         *  &lt;oj-navigation-list drill-mode='collapsible'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Set <code class="prettyprint">drillMode</code> property:</caption>
         * myNavList.drillMode = "collapsible";
         *
         * @example <caption>Get the <code class="prettyprint">drillMode</code> property:</caption>
         * // getter
         * var drillMode = myNavList.drillMode;
         */
        drillMode: 'none',
        reorderable: 'disabled',
        truncation: 'none',
        /**
         * The position of the Navigation List. Valid Values: start.
         * @ojshortdesc Specifies the edge position of the Navigation List.
         * @expose
         * @name edge
         * @memberof oj.ojNavigationList
         * @instance
         * @type {string}
         * @ojvalue {string} "top" This renders list items horizontally. Generally used when navlist placed on top of content section.
         * @ojvalue {string} "bottom" This renders list items horizontally. Generally used when navlist placed on bottom of content section.
         * @ojvalue {string} "start" This renders list items vertically. Generally used when navlist placed on left/start of content section.
         * @default start
         * @ojdeprecated {since: '17.0.0', description: 'Horizontal layout in oj-navigation-list is deprecated. Use oj-tab-bar instead. Since <code class="prettyprint">start</code> is the only supported and default value, it need not be specified using <code class="prettyprint">edge</code> attribute.'}
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">edge</code> attribute specified:</caption>
         *  &lt;oj-navigation-list edge='start'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Get the edge:</caption>
         * var edge = myNavList.edge;
         *
         * @example <caption>Set the edge on the Navigation List:</caption>
         * myNavList.edge = "start";
         */
        edge: 'start',
        /**
         * Specifies the level at which user can see hiearchical menu button. This is only valid when <code class="prettyprint">drillMode</code> set to <code class="prettyprint">sliding</code>.
         * Default value is 0, shows hiearchical menu always. If value is -1, then it will never be shown.
         *
         * <p>The default value for hierarchyMenuThreshold varies by theme.
         *
         * @ojshortdesc Specifies the level at which the user can see hierarchical menu button. See the Help documentation for more information.
         * @expose
         * @name hierarchyMenuThreshold
         * @memberof oj.ojNavigationList
         * @instance
         * @type {number}
         * @default 0
         * @ojdeprecated {since: "13.0.0", description: "The hierarchyMenuThreshold property is deprecated as it is not supported in the Redwood theme."}
         *
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">hierarchy-menu-threshold</code> attribute specified:</caption>
         *  &lt;oj-navigation-list hierarchy-menu-threshold='4'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Get or set the <code class="prettyprint">hierarchyMenuThreshold</code> property:</caption>
         * // getter
         * var hierarchyMenuThreshold = myNavList.hierarchyMenuThreshold;
         *
         * // setter
         * myNavList.hierarchyMenuThreshold = "4";
         *
         */
        hierarchyMenuDisplayThresholdLevel: 0,
        /**
         * Label for top level list items.
         * <p>NOTE: This is needed only for sliding navigation list where
         * this will be used as title for the top level list elements.
         *
         * @ojshortdesc Specifies the label for top level list items.
         * @type {?string}
         * @default Navigation List
         * @expose
         * @instance
         * @memberof oj.ojNavigationList
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">root-label</code> attribute specified:</caption>
         *  &lt;oj-navigation-list root-label='Global Navigation'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Get or set the <code class="prettyprint">rootLabel</code> property:</caption>
         * // getter
         * var rootLabel = myNavList.rootLabel;
         *
         * // setter
         * myNavList.rootLabel = "4";
         */
        rootLabel: null,
        /**
         * Item <a href="#key-section">Key</a> of currently selected list item. If the value is modified
         * by an application, navigation list UI is modified to match the new value and the <code class="prettyprint">event.detail</code> of the <code class="prettyprint">selectionChanged</code> event will contain the following additional properties:<br><br>
         * <table class="props">
         *   <thead>
         *     <tr>
         *       <th>Name</th>
         *       <th>Type</th>
         *       <th>Description</th>
         *     </tr>
         *   </thead>
         *   <tbody>
         *     <tr>
         *       <td class="name"><code>item</code></td>
         *       <td class="type">Element</td>
         *       <td class="description">Selected Item element</td>
         *     </tr>
         *   </tbody>
         * </table>
         * @ojshortdesc Specifies the key of the selected item. See the Help documentation for more information.
         * @type {any}
         * @ojsignature {target:"Type", value:"K"}
         * @default null
         * @expose
         * @instance
         * @ojeventgroup common
         * @memberof oj.ojNavigationList
         * @ojwriteback
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">selection</code> attribute specified:</caption>
         *  &lt;oj-navigation-list selection='settings'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Get the selection:</caption>
         * var selection = myNavList.selection;
         *
         * @example <caption>Set the selection on the Navigation List:</caption>
         * myNavList.selection = "settings";
         */
        selection: null,

        /**
         * Specifies the key set containing the keys of the items that should be expanded.
         *
         * Use the <a href="KeySetImpl.html">KeySetImpl</a> class to specify items to expand.
         * Use the <a href="AllKeySetImpl.html">AllKeySetImpl</a> class to expand all items.
         *
         * @expose
         * @ojshortdesc Specifies the key set containing the keys of the items that should be expanded. See the Help documentation for more information.
         * @memberof! oj.ojNavigationList
         * @instance
         * @default new AllKeySetImpl();
         * @type {KeySet}
         * @ojsignature {target:"Type", value:"oj.KeySet<K>"}
         * @ojwriteback
         *
         * @example <caption>Initialize the NavigationList with specific items expanded:</caption>
         * myNavList.expanded = new KeySetImpl(['item1', 'item2']);
         *
         * @example <caption>Initialize the NavigationList with all items expanded:</caption>
         * myNavList.expanded = new AllKeySetImpl();
         */
        expanded: new oj._ojListViewExpandedKeySet(),
        /**
         * The data source for the NavigationList accepts either a TableDataSource or oj.TreeDataSource.
         * See the data source section in the introduction for out of the box data source types.
         * If the data attribute is not specified, the child elements are used as content.  If there's no
         * content specified, then an empty list is rendered.
         *
         * @ojshortdesc Specifies the data provider for the Navigation List. See the Help documentation for more information.
         * @expose
         * @memberof! oj.ojNavigationList
         * @instance
         * @type {Object|null}
         * @default null
         * @ojwebelementstatus {type: "unsupported", since: "13.0.0",
         *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
         *
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">data</code> attribute specified:</caption>
         *  &lt;oj-navigation-list data='[[tableDataSource]]'> ... &lt;/oj-navigation-list>
         * @example <caption>Get the data:</caption>
         * var dataSource = myNavList.data;
         *
         * @example <caption>Set the data attribute using one-dimensional array:</caption>
         * myNavList.data = new oj.ArrayTableDataSource([1,2,3]);
         *
         * @example <caption>Set the data attribute using oj.Collection:</caption>
         * myNavList.data = new oj.CollectionTableDataSource(collection);
         * @ojsignature [{target: "Type", value: "DataProvider<K, D>|null"},
         *               {target: "Type", value: "TableDataSource|oj.TreeDataSource|DataProvider|null", consumedBy:"js"}]
         */
        data: null,
        /**
         * Whether to display both the label and icons (<code class="prettyprint">"all"</code>) or just the icons (<code class="prettyprint">"icons"</code>).
         * In the latter case, the label is displayed in a tooltip instead, unless a tooltip was already supplied at create time.
         * Note: <code class="prettyprint">display="icons"</code> is valid only when <code class="prettyprint">drillMode=none</code> and navigation list is a flat list.
         * It is also mandatory to provide icons for each item as stated in <a href="#icons-section">icons section</a>.
         *
         * @ojshortdesc Specifies what needs to be displayed. See the Help documentation for more information.
         * @expose
         * @memberof oj.ojNavigationList
         * @instance
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @default all
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">display</code> attribute specified:</caption>
         *  &lt;oj-navigation-list display='icons'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Get or set the <code class="prettyprint">display</code> property:</caption>
         * // getter
         * var display = myNavList.display;
         *
         * // setter
         * myNavList.display = "icons";
         */
        display: 'all',
        /**
         * Navigation List supports two different look-and-feel depends on its usage level, one is <code class="prettyprint">application</code> level and other is <code class="prettyprint">page</code> level.
         *
         * @expose
         * @ignore
         * @deprecated 4.0.0 Use oj-tab-bar custom element for page level navigation list. In future ojNavigationList will only support application level by default.
         * @memberof oj.ojNavigationList
         * @instance
         * @type {string}
         * @ojvalue {string} "application" Render Navigation List for application level navigation.
         * @ojvalue {string} "page" Render Navigation List for page level navigation.
         * @default page
         *
         * @example <caption>Initialize the NavigationList with the <code class="prettyprint">navigationLevel</code> option specified:</caption>
         *  &lt;oj-navigation-list navigation-level='application'> ... &lt;/oj-navigation-list>
         *
         * @example <caption>Get or set the <code class="prettyprint">navigationLevel</code> option, after initialization:</caption>
         * // getter
         * var display = navList.navigationLevel;
         *
         * // setter
         * navList.navigationLevel = "application";
         */
        navigationLevel: 'page',
        /**
         * Specifies the overflow behaviour.
         *
         * @ojshortdesc Specifies overflow behaviour for the Navigation List.
         * @expose
         * @memberof oj.ojNavigationList
         * @instance
         * @type {string}
         * @ojvalue {string} "popup" Popup menu will be shown with overflowed items.<p> Note that setting <code class="prettyprint">overflow</code> to <code class="prettyprint">popup</code> can trigger browser reflow, so only set it when it is actually required.
         * @ojvalue {string} "hidden" Overflow is clipped, and the rest of the content will be invisible.
         * @default hidden
         * @ojdeprecated {since: '17.0.0', description: 'Since horizontal layout in oj-navigation-list is deprecated this should not be used any more. Use oj-tab-bar instead.'}
         * @since 3.0.0
         * @example <caption>Initialize the Navigation List with the <code class="prettyprint">overflow</code> attribute specified:</caption>
         *  &lt;oj-navigation-list overflow='popup'> ... &lt;/oj-navigation-list>
         * @example <caption>Get or set the <code class="prettyprint">overflow</code> property:</caption>
         * // getter
         * var overflow = myNavList.overflow;
         *
         * // setter
         * myNavList.overflow = "hidden";
         */
        overflow: 'hidden',

        /**
         * @typedef {Object} oj.ojNavigationList.ItemContext
         * @property {Element} componentElement oj-navigation-list element
         * @property {DataProvider<K, D>} [datasource] A reference to the data source object. (Not available for static content)
         * @property {number} index The index of the item, where 0 is the index of the first item.
         * @property {any} key The Key of the item.
         * @property {any} data The data object for the item.
         * @property {Element} parentElement The list item element. The renderer can use this to directly append content.
         * @property {number=} depth the depth of the item
         * @property {K=} parentKey the key of the parent item
         * @property {boolean=} leaf whether the item is a leaf
         * @ojsignature [{target:"Type", value:"<K,D>", for:"genericTypeParameters"}]
         */

        /**
         * The item property contains a subset of properties for items.
         *
         * @ojshortdesc Customize the functionality of each item in Navigation List.
         * @expose
         * @memberof oj.ojNavigationList
         * @instance
         * @name item
         * @type {Object}
         */
        item: {
          /**
           * The renderer function that renders the content of the item. See <a href="#context-section">itemContext</a>
           * in the introduction to see the object passed into the renderer function.
           * The function should return one of the following:
           * <ul>
           *   <li>An Object with the following property:
           *     <ul><li>insert: HTMLElement | string - A string or a DOM element of the content inside the item.</li></ul>
           *   </li>
           *   <li>undefined: If the developer chooses to manipulate the item element directly, the function should return undefined.</li>
           * </ul>
           * If no renderer is specified, Navigation List will treat the data as a String.
           *
           * @ojshortdesc Specifies the renderer for the item. See the Help documentation for more information.
           * @expose
           * @name item.renderer
           * @memberof! oj.ojNavigationList
           * @instance
           * @type {function(Object)|null}
           * @ojsignature { target: "Type",
           *                value: "?(((context: oj.ojNavigationList.ItemContext<K,D>) => void)|null)",
           *                jsdocOverride: true}
           * @default null
           * @example <caption>Initialize the Navigation List with the <code class="prettyprint">item.renderer</code> attribute specified:</caption>
           *  &lt;oj-navigation-list item.renderer="{{oj.KnockoutTemplateUtils.getRenderer('template', true)}}"> ... &lt;/oj-navigation-list>
           *
           * @example <caption>Get or set the <code class="prettyprint">renderer</code> property:</caption>
           * // set the renderer function
           * myNavList.item.renderer = rendererFn;
           *
           * // get the renderer function
           * var rendererFn = myNavList.item.renderer;
           */
          renderer: null,
          /**
           * Whether the item is selectable.
           * See <a href="#context-section">itemContext</a> in the introduction to see the object passed into the selectable function.
           *
           * @ojshortdesc Specifies whether the item can be selected. See the Help documentation for more information.
           * @expose
           * @name item.selectable
           * @memberof! oj.ojNavigationList
           * @instance
           * @ojsignature { target: "Type",
           *                value: "?(((context: oj.ojNavigationList.ItemContext<K,D>) => boolean)|boolean)",
           *                jsdocOverride: true}
           * @type {function(Object)|boolean}
           * @default true
           *
           * @example <caption>Initialize the NavigationList such that the first 3 items are not selectable:</caption>
           *  <oj-navigation-list item.selectable="[[skipFirstThreeElementsFn]]"></oj-navigation-list>
           *
           *  var skipFirstThreeElementsFn = function(itemContext) {
           *                                      return itemContext['index'] > 3;
           *                                 }
           */
          selectable: true
        },
        // Events
        /**
         * Triggered when the default animation of a particular action is about to start.  The default animation can be cancelled by calling event.preventDefault.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @ojshortdesc Event handler for when the default animation of a particular action is about to start.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @property {string} action the action that triggers the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
         * @property {Element} element the target of animation.
         * @property {function():void} endCallback if the event listener calls event.preventDefault to cancel the default animation, it must call the endCallback function when it finishes its own animation handling and when any custom animation ends.
         */
        animateStart: null,
        /**
         * Triggered when the default animation of a particular action has ended.  Note this event will not be triggered if application cancelled the default animation on animateStart.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @ojshortdesc Event handler for when the default animation of a particular action has ended.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @property {string} action the action that triggered the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
         * @property {Element} element the target of animation.
         */
        animateEnd: null,
        /**
         * <p>Triggered before this list item is selected.
         * To prevent the item selection, invoke <code class="prettyprint">event.preventDefault()</code>.
         *
         * @ojshortdesc Event handler for when before the selection is changed.
         * @expose
         * @event
         * @ojcancelable
         * @memberof oj.ojNavigationList
         * @instance
         * @property {any} key Selected list item <a href="#key-section">Key</a>.
         * @property {Element} item Selected list item.
         */
        beforeSelect: null,
        /**
         * Triggered before an item is collapse via the <code class="prettyprint">expanded</code> property,
         * the <code class="prettyprint">collapse</code> method, or via the UI.
         * To prevent the item being collapsed, invoke <code class="prettyprint">event.preventDefault()</code>.
         *
         * @ojshortdesc Event handler for when an item is about to collapse.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @ojcancelable
         * @property {any} key the <a href="#key-section">Key</a> of the item to be collapse
         * @property {Element} item the item to be collapse
         */
        beforeCollapse: null,
        /**
         * Triggered before the current item is changed via the <code class="prettyprint">currentItem</code> property or via the UI.
         * To prevent the item being focused, invoke <code class="prettyprint">event.preventDefault()</code>.
         *
         * @ojshortdesc Event handler for when before the current item is changed.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @ojcancelable
         * @property {any} previousKey the <a href="#key-section">Key</a> of the previous item
         * @property {Element} previousItem the previous item
         * @property {any} key the <a href="#key-section">Key</a> of the new current item
         * @property {Element} item the new current item
         */
        beforeCurrentItem: null,
        beforeDeselect: null,
        /**
         * Triggered after an item has been collapsed via the <code class="prettyprint">expanded</code> property,
         * the <code class="prettyprint">collapse</code> method, or via the UI.
         *
         * @ojshortdesc Event handler for after an item has collapsed.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @property {any} key The <a href="#key-section">Key</a> of the item that was just collapsed.
         * @property {Element} item The list item that was just collapsed.
         */
        collapse: null,
        deselect: null,
        /**
         * Triggered before an item is expand via the <code class="prettyprint">expanded</code> property,
         * the <code class="prettyprint">expand</code> method, or via the UI.
         * To prevent the item being expanded, invoke <code class="prettyprint">event.preventDefault()</code>.
         *
         * @ojshortdesc Event handler for when an item is about to expand.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @ojcancelable
         * @property {any} key the <a href="#key-section">Key</a> of the item to be expand
         * @property {Element} item the item to be expand
         */
        beforeExpand: null,
        /**
         * Triggered after an item has been expanded via the <code class="prettyprint">expanded</code> property,
         * the <code class="prettyprint">expand</code> method, or via the UI.
         *
         * @ojshortdesc Event handler for after an item has expanded.
         * @expose
         * @event
         * @memberof oj.ojNavigationList
         * @instance
         * @property {any} key The <a href="#key-section">Key</a> of the item that was just expanded.
         * @property {Element} item The list item that was just expanded.
         */
        expand: null,
        reorder: null,
        /**
         * Triggered anytime when user performs an action gesture on a tab, no matter the tab is selected or not. The action gestures include:
         * <ul>
         *   <li>User clicks anywhere in a tab</li>
         *   <li>User taps anywhere in a tab</li>
         *   <li>User pressed enter key while a tab or its content has focus</li>
         * </ul>
         *
         * @ojshortdesc Triggered when user performs an action gesture on a tab.
         * @expose
         * @event
         * @ojbubbles
         * @memberof oj.ojNavigationList
         * @instance
         * @property {any} value the value of new selection.
         * @property {any} previousValue the value of previous selection, which can have the same as key if user selects the same tab/item.
         * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
         *               {target:"Type", value:"K", for:"value", jsdocOverride:true},
         *               {target:"Type", value:"K", for:"previousValue", jsdocOverride:true}]
         */
        selectionAction: null
      },

      /**
       * Create the Navigation List
       * @override
       * @memberof! oj.ojNavigationList
       * @protected
       */
      _ComponentCreate: function () {
        this._super();
        this._setup();
      },
      /**
       * Initialize the NavigationList after creation
       * @protected
       * @override
       * @memberof! oj.ojNavigationList
       */
      _AfterCreate: function () {
        this._super();

        // inject helper functions for ContentHandler and custom renderer to use
        var self = this;
        this.navlist._FixRendererContext = function (context) {
          return self._FixRendererContext(context);
        };
        this.navlist._WrapCustomElementRenderer = function (renderer) {
          return self._WrapCustomElementRenderer(renderer);
        };
        this.navlist._GetCustomElement = function () {
          return self._GetCustomElement();
        };
        this.navlist.afterCreate();
      },

      /**
       * When the <a href="#contextMenu">contextMenu</a> option is set, this method is called when the user invokes the context menu via
       * the default gestures: right-click, pressHold, and <kbd>Shift-F10</kbd>.  Components should not call this method directly.
       *
       * @param {!Object} menu The JET Menu to open as a context menu.  Always non-<code class="prettyprint">null</code>.
       * @param {!Event} event What triggered the menu launch.  Always non-<code class="prettyprint">null</code>.
       * @param {string} eventType "mouse", "touch", or "keyboard".  Never <code class="prettyprint">null</code>.
       * @private
       */
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        this.navlist.notifyContextMenuGesture(menu, event, eventType);
      },

      /**
       * Initialize DOM structure for navigation list.
       * @private
       * @memberof! oj.ojNavigationList
       */
      _setup: function () {
        this.navlist = new _ojNavigationListView();

        var keys = Object.keys(this.options);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          this._validateOptionValues(key, this.options[key]);
        }

        this._validateOptionsForIconsOnlyAndHorizontalList(
          this.options[this.navlist.OPTION_DRILL_MODE],
          this.options[this.navlist.OPTION_DISPLAY],
          this.options[this.navlist.OPTION_EDGE]
        );

        var opts = { ojContext: this };
        opts = $.extend(this.options, opts);
        this.navlist.init(opts);
      },

      getNodeBySubId: function (locator) {
        return this.navlist.getNodeBySubId(locator);
      },
      getSubIdByNode: function (node) {
        return this.navlist.getSubIdByNode(node);
      },

      /**
       * @typedef {Object} oj.ojNavigationList.NodeContext
       * @property {string} subId Sub-id string to identify a particular dom node.
       * @property {number} index The index of the item, where 0 is the index of the first item.
       * @property {K} key The Key of the item.
       * @property {boolean} group whether the item is a group.
       * @property {Element} [parent] the parent group item. Only available if item has a parent.
       * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"}]
       */

      /**
       * {@ojinclude "name":"nodeContextDoc"}
       * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
       * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
       * @ojsignature { target: "Type", for:"returns",
       *                value: "oj.ojNavigationList.NodeContext<K>|null",
       *                jsdocOverride: true}
       * @example {@ojinclude "name":"nodeContextExample"}
       *
       * @expose
       * @instance
       * @memberof oj.ojNavigationList
       * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
       */
      getContextByNode: function (node) {
        return this.navlist.getContextByNode(node);
      },

      /**
       * Expand an item.<p>
       * Note when vetoable is set to false, beforeExpand event will still be fired but the event cannot be veto.<p>
       *
       * @ignore
       * @expose
       * @memberof oj.ojNavigationList
       * @instance
       * @param {Object|string} key the <a href="#key-section">Key</a> of the item to expand
       * @param {boolean} vetoable if event is vetoable
       * @param {boolean} animate true if animate the expand operation, false otherwise
       * @export
       */
      expand: function (key, vetoable, animate) {
        this.navlist.expandKey(key, vetoable, true, true, animate);
      },

      /**
       * Collapse an item.<p>
       * Note when vetoable is set to false, beforeCollapse event will still be fired but the event cannot be veto.<p>
       *
       * @ignore
       * @expose
       * @memberof oj.ojNavigationList
       * @instance
       * @param {Object|string} key the <a href="#key-section">Key</a> of the item to collapse
       * @param {boolean} vetoable if event is vetoable
       * @param {boolean} animate true if animate the collapse operation, false otherwise
       * @export
       */
      collapse: function (key, vetoable, animate) {
        this.navlist.collapseKey(key, vetoable, true, animate);
      },

      /**
       * Gets the key of currently expanded items.
       *
       * @ignore
       * @expose
       * @memberof oj.ojNavigationList
       * @instance
       * @return {Array} array of keys of currently expanded items
       * @export
       */
      getExpanded: function () {
        return this.navlist.getExpanded();
      },

      _validateOptionsForIconsOnlyAndHorizontalList: function (drillMode, display, edge) {
        if (drillMode !== this.navlist.OPTION_DRILL_MODE_NONE) {
          if (display === this.navlist.OPTION_DISPLAY_ICONS) {
            throw new Error("Icon only navigation list should have drillMode set to 'none'.");
          }
          if (display === this.navlist.OPTION_DISPLAY_STACKED) {
            throw new Error("Stack only navigation list should have drillMode set to 'none'.");
          }
          if (edge === this.navlist.OPTION_EDGE_TOP) {
            throw new Error("Horizontal navigation list should have drillMode set to 'none'.");
          }
        }
      },

      _validateOptionValues: function (key, value) {
        var valid = true;
        if (key === this.navlist.OPTION_DRILL_MODE) {
          valid =
            value === this.navlist.OPTION_DRILL_MODE_NONE ||
            value === this.navlist.OPTION_DRILL_MODE_COLLAPSIBLE ||
            value === this.navlist.OPTION_DRILL_MODE_SLIDING;
        } else if (key === this.navlist.OPTION_DISPLAY) {
          valid =
            value === this.navlist.OPTION_DISPLAY_ALL ||
            value === this.navlist.OPTION_DISPLAY_ICONS ||
            value === this.navlist.OPTION_DISPLAY_STACKED;
        } else if (key === this.navlist.OPTION_EDGE) {
          if (this.element[0].tagName.toLowerCase() === this.navlist.TAG_NAME_TAB_BAR) {
            valid =
              value === this.navlist.OPTION_EDGE_TOP ||
              value === this.navlist.OPTION_EDGE_START ||
              value === this.navlist.OPTION_EDGE_END ||
              value === this.navlist.OPTION_EDGE_BOTTOM;
          } else {
            valid =
              value === this.navlist.OPTION_EDGE_TOP ||
              value === this.navlist.OPTION_EDGE_BOTTOM ||
              value === this.navlist.OPTION_EDGE_START;
          }
        }
        if (!valid) {
          throw new Error('Invalid value: ' + value + ' for key: ' + key);
        }
      },

      /**
       * Set single option
       * @param {string} key the option key
       * @param {Object} value value for option
       * @override
       * @memberof oj.ojNavigationList
       * @instance
       * @private
       */
      _setOption: function (key, value) {
        var flags;
        var extraData;
        this._validateOptionValues(key, value);
        switch (key) {
          case this.navlist.OPTION_DRILL_MODE:
            this._validateOptionsForIconsOnlyAndHorizontalList(
              value,
              this.options[this.navlist.OPTION_DISPLAY],
              this.options[this.navlist.OPTION_EDGE]
            );
            break;
          case this.navlist.OPTION_DISPLAY:
            this._validateOptionsForIconsOnlyAndHorizontalList(
              this.options[this.navlist.OPTION_DRILL_MODE],
              value,
              this.options[this.navlist.OPTION_EDGE]
            );
            break;
          case this.navlist.OPTION_EDGE:
            this._validateOptionsForIconsOnlyAndHorizontalList(
              this.options[this.navlist.OPTION_DRILL_MODE],
              this.options[this.navlist.OPTION_DISPLAY],
              value
            );
            break;
          case this.navlist.OPTION_SELECTION:
          case this.navlist.OPTION_CURRENT_ITEM:
            if (this.navlist.isAvailable()) {
              extraData = this.navlist.getItems([value])[0];
              flags = {
                _context: {
                  extraData: {
                    item: this._IsCustomElement() ? extraData : $(extraData)
                  }
                }
              };
            }
            break;
          default:
            break;
        }
        this.navlist.updateListViewOption(key, value);
        if (flags) {
          return this._super(key, value, flags);
        }
        return this._super(key, value);
      },

      /**
       * Sets multiple options
       * @param {Object} options the options object
       * @param {Object} flags additional flags for option
       * @override
       * @private
       */
      _setOptions: function (options, flags) {
        if (!this.navlist.isAvailable()) {
          // NavList might have been detached, just update the options.  When NavList becomes available again, the update options will take effect.
          this._super(options, flags);
          return this;
        }

        var result = this.navlist.setOptions(options, flags);

        var nonSkippedOptions = {};
        var keys = Object.keys(options);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (result.skipOptions.indexOf(key) < 0) {
            nonSkippedOptions[key] = options[key];
          }
        }
        // Should call _super as that's where the old and new option value checking
        // logic lives. _setOption should not be called directly.
        this._super(nonSkippedOptions, flags);

        if (result.needRefresh) {
          this.navlist.refresh();
        }
        return this;
      },

      /**
       * Invoked when application calls oj.Components.subtreeAttached.
       * @override
       * @private
       */
      _NotifyAttached: function () {
        this.navlist.notifyAttached();
      },

      /**
       * In browsers [Chrome v35, Firefox v24.5, IE9, Safari v6.1.4], blur and mouseleave events are generated for hidden content but not detached content,
       * so for detached content only, we must use this hook to remove the focus and hover classes.
       * @override
       * @private
       */
      _NotifyDetached: function () {
        this.navlist.notifyDetached();
      },

      /**
       * Invoked when application calls oj.Components.subtreeShown.
       * @override
       * @private
       */
      _NotifyShown: function () {
        this.navlist.notifyShown();
      },

      /**
       * Override to do the delay connect/disconnect
       * @memberof oj.ojNavigationList
       * @override
       * @protected
       */
      _VerifyConnectedForSetup: function () {
        return true;
      },

      /**
       * Refreshes the visual state of the Navigation List. JET components require a <code class="prettyprint">refresh()</code> after the DOM is
       * programmatically changed underneath the component.
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @ojshortdesc Refreshes the visual state of the Navigation List.
       * @memberof! oj.ojNavigationList
       * @instance
       * @return {void}
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       *  myNavList.refresh();
       */
      refresh: function () {
        this._super();
        this.navlist.refresh();
      },

      /**
       * Returns a Promise that resolves when the component is ready, i.e. after data fetching, rendering, and animations complete.
       * Note that in the highwatermark scrolling case, component is ready after data fetching, rendering, and associated animations of items fetched so far are complete.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @ignore
       * @memberof oj.ojNavigationList
       * @instance
       * @return {Promise} A Promise that resolves when the component is ready.
       */
      whenReady: function () {
        return this.navlist.whenReady();
      },

      /**
       * Sets up resources needed by navlist
       * @memberof! oj.ojNavigationList
       * @instance
       * @override
       * @protected
       */
      _SetupResources: function () {
        this._super();
        this.navlist.setupResources();
      },

      /**
       * Release resources held by navlist
       * @memberof! oj.ojNavigationList
       * @instance
       * @override
       * @protected
       */
      _ReleaseResources: function () {
        this._super();
        this.navlist.releaseResources();
      },

      /**
       * Destroy the Navigation List
       * @memberof! oj.ojNavigationList
       * @private
       */
      _destroy: function () {
        this.navlist.destroy();
        this._super();
      },

      _CompareOptionValues: function (option, value1, value2) {
        switch (option) {
          case 'currentItem':
          case 'selection':
            return oj.Object.compareValues(value1, value2);
          default:
            return this._super(option, value1, value2);
        }
      }
    });

    // Add custom getters for properties from theming file
    Components.setDefaultOptions({
      ojNavigationList: {
        hierarchyMenuDisplayThresholdLevel: Components.createDynamicPropertyGetter(function () {
          const cssVarsObject = _ojNavigationListView._CSS_Vars.navlist;
          const cssVarH = cssVarsObject.hierarchyMenuDisplayThresholdLevel;
          return +ThemeUtils.getCachedCSSVarValues([cssVarH])[0];
        })
      }
    });
  })();

  // DOCLETS
  /**
   * @ojcomponent oj.ojTabBar
   * @augments oj.baseComponent
   * @ojimportmembers oj.ojSharedContextMenu
   * @since 4.0.0
   * @ojrole tablist
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojTabBar<K, D> extends baseComponent<ojTabBarSettableProperties<K,D>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojTabBarSettableProperties<K,D> extends baseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }
   *              ]
   * @ojshortdesc A tab bar allows navigation between different content sections.
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["selection", "edge", "display", "truncation", "overflow"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-tab-bar'
   * @ojuxspecs ['tab-bar']
   *
   * @classdesc
   * <h3 id="navlistOverview-section">
   *   JET Tab Bar
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#navlistOverview-section"></a>
   * </h3>
   *
   * <p>Description: JET Tab Bar enhances a HTML list element into a themable, WAI-ARIA compliant, mobile friendly component with advance interactive features.
   *
   * <h3 id="data-section">
   *   Data
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
   * </h3>
   * <p>The JET Tab Bar gets its data in two different ways.  The first way is from a DataProvider/TableDataSource.  There are several types of DataProvider/TableDataSource
   * that are available out of the box:</p>
   * <ul>
   * <li>oj.ArrayDataProvider</li>
   * <li>oj.CollectionTableDataSource</li>
   * </ul>
   *
   * <p><b>oj.ArrayDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, Tab Bar will automatically react
   * when items are added or removed from the array.  See the documentation for oj.ArrayDataProvider for more details on the available options.</p>
   *
   * <p><b>oj.CollectionTableDataSource</b> - Use this when oj.Collection is the model for the underlying data.  Note that the Tab Bar will automatically react to model event from
   * the underlying oj.Collection.  See the documentation for oj.CollectionTableDataSource for more details on the available options.</p>
   *
   * <p> NOTE: PagingTableDataSource is not supported by Tab Bar.
   * <p>Second way is using static HTML content as data.</p>
   * <p>Note that any manipulation of static HTML content, including manipulating content generated through Knockout (for example, updating observableArray in a foreach binding), is not supported.<p>
   *
   * <p>Example of static content</p>
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-tab-bar>
   *  &lt;ul>
   *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
   *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
   *   &lt;li>&lt;a href="#">Item 3&lt;/a>&lt;/li>
   *  &lt;/ul>
   * &lt;/oj-tab-bar>
   * </code></pre>
   *
   * <h3 id="key-section">
   *   Key
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#key-section"></a>
   * </h3>
   * <p>Key is an identifier which uniquely identifies an item in tabbar.
   *  <ul>
   *  <li>When static html is used, it will be the <code class="prettyprint">id</code> attribute of <code class="prettyprint">&lt;li></code>. If no <code class="prettyprint">id</code> is specified then component will generate an id and will use it as key.</li>
   *  <li>When data source is used, it will be the <code class="prettyprint">id</code> attribute of item's data object.
   *  </ul>
   * <h3 id="icons-section">
   *   Icons
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#icons-section"></a>
   * </h3>
   *
   * <p>Sublist icons are inserted automatically.  To add other icons to list items, include them in the markup and include the <code class="prettyprint">oj-tabbar-item-icon</code> class, as follows:
   *
   * <pre class="prettyprint">
   * <code>&lt;oj-tab-bar>
   *   &lt;ul>
   *     &lt;li id="foo">&lt;a href="#">&lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">&lt;/span>Foo&lt;/a>&lt;/li>
   *   &lt;/ul>
   *  &lt;/oj-tab-bar>
   * </code></pre>
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   * {@ojinclude "name":"keyboardDoc"}
   *
   *<h3 id="context-section">
   *   Item Context
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
   * </h3>
   *
   * <p>For all item options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular item.  This gives developers the flexibility to return different value depending on the context.</p>
   *
   * <p>The context paramter contains the following keys:</p>
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>componentElement</kbd></td>
   *       <td>oj-tab-bar element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>datasource</kbd></td>
   *       <td>A reference to the data source object. (Not available for static content)</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>index</kbd></td>
   *       <td>The index of the item, where 0 is the index of the first item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>key</kbd></td>
   *       <td>The <a href="#key-section">Key</a> of the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>data</kbd></td>
   *       <td>The data object for the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>parentElement</kbd></td>
   *       <td>The list item element.  The renderer can use this to directly append content.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>oj-c-tab-bar will replace oj-tab-bar in core pack.
   *
   * <h5>Migration to oj-c-tab-bar</h5>
   *
   * <p>To migrate from oj-tab-bar to oj-c-tab-bar, you need to revise the import statement and references to oj-c-tab-bar in your app. Please note the changes between the two components below.</p>
   *
   * <p>These features are not yet available in oj-c-tab-bar, they will be available in a forthcoming version.</p>
   * <ul>
   *    <li>Progressive Truncation</li>
   *    <li>Context Menu Support</li>
   * </ul>
   *
   * <p>The first step is to determine if your tab bar requires any of the not yet released features (see above list).</p>
   *
   * <p>The next step is to determine compatibility with your DataSource.  Here are some changes.</p>
   * <ul>
   *  <li>DataProvider and array of type TabData<K> are the only currently supported data source</li>
   *  <li>itemTemplate is no longer supported</li>
   * </ul>
   * <p>
   *
   * <p>Finally review the list below for specific API changes.</p>
   *
   * <h5>Reorder Behavior Change</h5>
   * <p>Use Command + Shift + Arrow Keys to reorder.
   * </p>
   *
   * <h5>itemTemplate slot</h5>
   * <p>Support for itemTemplate has not been brought forward as oj-c-tab-bar does not support arbitary content.</p>
   *
   * <h5>current-item attribute</h5>
   * <p>This property is not available as it is internal to the component./p>
   *
   * <h5>item.renderer attribute</h5>
   * <p>This is not supported, everything this attribute did can be accomplished using items that will be rendered by the component</p>
   *
   * <h5>item.selectable attribute</h5>
   * <p>This is not supported, everything this attribute did can be accomplished using selectiom attribute</p>
   *
   * <h5>ojBeforeCurrentItem event</h5>
   * <p> this cancellable event is slated for deprecation.</p>
   *
   * <h5>ojBeforeDeselect event</h5>
   * <p> this cancellable event is slated for deprecation.</p>
   *
   * <h5>ojBeforeRemove event</h5>
   * <p> this cancellable event is slated for deprecation.</p>
   *
   * <h5>ojDeselect event</h5>
   * <p> this cancellable event is slated for deprecation.</p>
   *
   * <h5>The following features are not yet supported</h5>
   * <ul>
   *   <li>Progressive Truncation</li>
   *   <li>Custom contextMenu support</li>
   * </ul>
   *
   * <p></p>
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Data Set Size</h4>
   * <p>As a rule of thumb, it's recommended that applications limit the amount of data to display.  Displaying large
   * number of items in Tab Bar makes it hard for user to find what they are looking for, but affects the load time.
   *
   * <h4>Item Content</h4>
   * <p>Tab Bar allows developers to specify arbitrary content inside its item. In order to minimize any negative effect on
   * performance, you should avoid putting a large number of heavy-weight components inside because as you add more complexity
   * to the structure, the effect will be multiplied because there can be many items in the Tab Bar.</p>
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>The only supported way to set the reading direction (LTR or RTL) is to set the <code class="prettyprint">"dir"</code> attribute on the
   * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET custom element, in the unusual case that the reading direction
   * is changed post-init, the tab bar must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
   *
   *
   * <h3 id="animation-section">
   *   Animation
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#animation-section"></a>
   * </h3>
   *
   * <p>Applications can customize animations triggered by actions in Tab Bar by overriding action specific style classes on the animated item.  See the documentation of <a href="AnimationUtils.html">AnimationUtils</a>
   *    class for details.</p>
   *
   * <p>The following are actions in which applications can use to customize animation effects.
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Action</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>horizontal add</kbd></td>
   *       <td>When a new item is added to the TableDataSource associated with Horizontal Tab Bar.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>add</kbd></td>
   *       <td>When a new item is added to the TableDataSource associated with Vertical Tab Bar.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>horizontal remove</kbd></td>
   *       <td>When an existing item is removed from the TableDataSource associated with Horizontal Tab Bar.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>remove</kbd></td>
   *       <td>When an existing item is removed from the TableDataSource associated with Vertical Tab Bar.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>update</kbd></td>
   *       <td>When an existing item is updated in the TableDataSource associated with TabBar.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>pointerUp</kbd></td>
   *       <td>When user finish pressing an item (on touch).</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   */
  // --------------------------------------------------- oj.ojTabBar Styling Start -----------------------------------------------------------
  // ---------------- oj-tabbar-stack-icon-label --------------
  /**
   * Use this class to display a horizontal Tab Bar with icons and labels stacked. Applicable only when edge is top.
   * @ojstyleclass oj-tabbar-stack-icon-label
   * @ojdisplayname Stack Icon
   * @memberof oj.ojTabBar
   * @ojdeprecated {since: '9.0.0', description: 'Use display attribute instead.'}
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-stack-icon-label" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-category-divider --------------
  /**
   * Use this class to add a horizontal divider line between two categories of items.
   * @ojstyleclass oj-tabbar-category-divider
   * @ojdisplayname CategoryDivider
   * @ojstyleselector "oj-tab-bar li"
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar>
   *   &lt;ul>
   *     &lt;li ...>&lt;/li>
   *     &lt;li class="oj-tabbar-category-divider">&lt;/li>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-item-icon --------------
  /**
   * Use this class to add an icon to a list item.
   * @ojstyleclass oj-tabbar-item-icon
   * @ojdisplayname Icons
   * @ojstyleselector "oj-tab-bar span"
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-stack-icon-label" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-item-title --------------
  /**
   * When arbitrary content is placed inside an item's content area, its title text can be marked using this style class. This helps the component in identifying the Item's label.
   * @ojstyleclass oj-tabbar-item-title
   * @ojdisplayname Title
   * @memberof oj.ojTabBar
   * @ojstyleselector "oj-tab-bar span"
   * @ojtsexample
   * &lt;li id="foo">
   *   &lt;div>
   *     &lt;span class="oj-tabbar-item-title">Play&lt;/span>
   *       &lt;button>Button&lt;/button>
   *   &lt;/div>
   * &lt;/li>
   */
  // ---------------- oj-tabbar-item-text-wrap --------------
  /**
   * Use this class to wrap item label text. Note: On IE11, this is not supported when overflow attribute is set to 'popup'. This style class is not supported when edge is 'top' or 'bottom'.
   * @ojstyleclass oj-tabbar-item-text-wrap
   * @ojdisplayname Text Wrap
   * @memberof oj.ojTabBar
   * @ojdeprecated {since: '15.0.0', description: 'Since vertical layout of TabBar is deprecated, this should not be used anymore. Use NavigationList instead.'}
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-item-text-wrap" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-item-dividers --------------
  /**
   * Use this class  to render a divider between tab items. Note: On IE11, this is not supported when overflow attribute is set to 'popup'.
   * @ojstyleclass oj-tabbar-item-dividers
   * @ojdisplayname ItemDividers
   * @memberof oj.ojTabBar
   * @ojunsupportedthemes ["Redwood"]
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-item-dividers">
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-[size]-condense --------------
  /**
   * Use this class to wrap item label text. Note: On IE11, this is not supported when overflow attribute is set to 'popup'.
   * @ojstyletemplate oj-[size]-condense
   * @ojstyletemplatetokens ["StylingTemplateTokens.[size]"]
   * @ojdisplayname Condense
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-sm-condense" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-nofollow-link --------------
  /**
   * Use this class to prevent automatic navigation to the url specified on an &lt;a> tag's href attribute. <br/>
   * In this case, navigation can be handled programmatically by using selectionChanged event. <br/>
   * This is useful to execute some custom logic before browser triggers navigation.
   * @ojstyleclass oj-tabbar-nofollow-link
   * @ojdisplayname No Follow Link
   * @ojshortdesc Use this class to prevent automatic navigation to a URL within a tab item. See the Help documentation for more information.
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-nofollow-link" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-item-label --------------
  /**
   * Use this class to specify the element with the label.  This will eliminate the need for Tabbar to automatically
   * wrap any child element that is not an icon or a badge with this class.  Note the content must have the correct
   * order (icon element first, then the label element, then the badge element) as Tabbar in this case will not attempt
   * to reorder the content.
   * @ojstyleclass oj-tabbar-item-label
   * @ojdisplayname Label
   * @ojstyleselector "oj-tabbar span"
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-stack-icon-label" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         &lt;span class="oj-tabbar-item-label">
   *         Foo
   *         &lt;/span>
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-removable --------------
  /**
   * Use this class to make an item removable.
   * @ojstyleclass oj-removable
   * @ojdisplayname Item Removable
   * @ojstyleselector "oj-tab-bar li"
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar>
   *   &lt;ul>
   *     &lt;li id="foo" class="oj-removable" >
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-hide-remove-icon --------------
  /**
   * Use this class to hide the remove icon. In this case, Item can be removed using context menu.
   * @ojstyleclass oj-tabbar-hide-remove-icon
   * @ojdisplayname Hide Remove Icon
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-hide-remove-icon" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-tabbar-item-end --------------
  /**
   * Use this class to add an badge/metadata/icon to a list item.
   * @ojstyleclass oj-tabbar-item-end
   * @ojdisplayname Icon
   * @memberof oj.ojTabBar
   * @ojunsupportedthemes ['Alta']
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-tabbar-item-end" >
   *   &lt;ul>
   *     &lt;li id="foo">
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-end>
   *            &lt;span class="oj-badge oj-badge-subtle">3
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-disabled --------------
  /**
   * Any list item can be disabled by adding the oj-disabled class to that element
   * @ojdeprecated {since: "16.0.0", description: "Disabled Tab Bar items are not recommended in the Redwood design system, tabs should be removed, not disabled."}
   * @ojstyleclass oj-disabled
   * @ojdisplayname Disabled Item
   * @ojstyleselector "oj-tab-bar li"
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar>
   *   &lt;ul>
   *     &lt;li id="foo" class="oj-disabled" >
   *       &lt;a href="#">
   *         &lt;span class="oj-tabbar-item-icon demo-icon-font-24 demo-palette-icon-24">
   *         &lt;/span>
   *         Foo
   *       &lt;/a>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tab-bar>
   */
  // ---------------- oj-focus-highlight --------------
  /**
   * Under normal circumstances this class is applied automatically.
   * It is documented here for the rare cases that an app developer needs per-instance control.<br/><br/>
   * The oj-focus-highlight class applies focus styling that may not be desirable when the focus results from pointer interaction (touch or mouse), but which is needed for accessibility when the focus occurs by a non-pointer mechanism, for example keyboard or initial page load.<br/><br/>
   * The application-level behavior for this component is controlled in the theme by the <code class="prettyprint"><span class="pln">$focusHighlightPolicy </span></code>SASS variable; however, note that this same variable controls the focus highlight policy of many components and patterns. The values for the variable are:<br/><br/>
   * <code class="prettyprint"><span class="pln">nonPointer: </span></code>oj-focus-highlight is applied only when focus is not the result of pointer interaction. Most themes default to this value.<br/>
   * <code class="prettyprint"><span class="pln">all: </span></code> oj-focus-highlight is applied regardless of the focus mechanism.<br/>
   * <code class="prettyprint"><span class="pln">none: </span></code> oj-focus-highlight is never applied. This behavior is not accessible, and is intended for use when the application wishes to use its own event listener to precisely control when the class is applied (see below). The application must ensure the accessibility of the result.<br/><br/>
   * To change the behavior on a per-instance basis, the application can set the SASS variable as desired and then use event listeners to toggle this class as needed.<br/>
   * @ojstyleclass oj-focus-highlight
   * @ojdisplayname Focus Styling
   * @ojshortdesc Allows per-instance control of the focus highlight policy (not typically required). See the Help documentation for more information.
   * @memberof oj.ojTabBar
   * @ojtsexample
   * &lt;oj-tab-bar class="oj-focus-highlight">
   *   &lt;!-- Content -->
   * &lt;/oj-tab-bar>
   */
  /**
   * @ojstylevariableset oj-tab-bar-css-set1
   * @ojstylevariable oj-tab-bar-icon-to-text-padding {description: "Padding between icon and text", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-icon-margin {description: "Tab bar icon margin", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-icon-size {description: "Tab bar icon size", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-item-margin {description: "Tab bar item margin", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-item-padding {description: "Tab bar item padding", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-item-min-height {description: "Tab bar item minimum height", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-item-line-height {description: "Tab bar item line height", formats: ["number"], help: "#css-variables"}
   * @ojstylevariable oj-tab-bar-item-font-size {description: "Tab bar item font size", formats: ["length"], help: "#css-variables"}
   * @memberof oj.ojTabBar
   */
  /**
   * @ojstylevariableset oj-tab-bar-css-set2
   * @ojdisplayname Default
   * @ojstylevariable oj-tab-bar-item-font-weight {description: "Default tab bar item font weight", formats: ["font_weight"], help: "#oj-tab-bar-css-set2"}
   * @ojstylevariable oj-tab-bar-item-label-color {description: "Default tab bar item label color", formats: ["color"], help: "#oj-tab-bar-css-set2"}
   * @memberof oj.ojTabBar
   */
  /**
   * @ojstylevariableset oj-tab-bar-css-set3
   * @ojdisplayname Hovered
   * @ojstylevariable oj-tab-bar-item-label-color-hover {description: "Tab bar item label color when hovered", formats: ["color"], help: "#oj-tab-bar-css-set3"}
   * @ojstylevariable oj-tab-bar-item-bg-color-hover {description: "Tab bar item background color when hovered",formats: ["color"], help: "#oj-tab-bar-css-set3"}
   * @memberof oj.ojTabBar
   */
  /**
   * @ojstylevariableset oj-tab-bar-css-set4
   * @ojdisplayname Active
   * @ojstylevariable oj-tab-bar-item-bg-color-active {description: "Tab bar item background color when active", formats: ["color"], help: "#oj-tab-bar-css-set4"}
   * @ojstylevariable oj-tab-bar-item-border-color-active {description: "Tab bar item border color when active", formats: ["color"], help: "#oj-tab-bar-css-set4"}
   * @memberof oj.ojTabBar
   */
  /**
   * @ojstylevariableset oj-tab-bar-css-set5
   * @ojdisplayname Selected
   * @ojstylevariable oj-tab-bar-item-font-weight-selected {description: "Tab bar item font weight when selected", formats: ["font_weight"], help: "#oj-tab-bar-css-set5"}
   * @ojstylevariable oj-tab-bar-item-label-color-selected {description: "Tab bar item label color when selected", formats: ["color"], help: "#oj-tab-bar-css-set5"}
   * @ojstylevariable oj-tab-bar-item-bg-color-selected {description: "Tab bar item background color when selected", formats: ["color"], help: "#oj-tab-bar-css-set5"}
   * @ojstylevariable oj-tab-bar-item-border-color-selected {description: "Tab bar item border color when selected", formats: ["color"], help: "#oj-tab-bar-css-set5"}
   * @memberof oj.ojTabBar
   */
  // --------------------------------------------------- oj.ojTabBar Styling End -----------------------------------------------------------
  /**
   * An alias for the current item when referenced inside the item template. This can be especially useful
   * if oj-bind-for-each element is used inside the item template since it has its own scope of data access.
   *
   * @ojshortdesc Specifies the alias for the current item when referenced inside the item template.
   *
   * @name as
   * @expose
   * @public
   * @instance
   * @memberof! oj.ojTabBar
   * @type {string}
   * @default ''
   * @ojdeprecated {since: '6.2.0', description: 'Set the alias directly on the template element using the data-oj-as attribute instead.'}
   *
   * @example <caption>Initialize the Tabbar with the <code class="prettyprint">as</code> attribute specified:</caption>
   * &lt;oj-tab-bar as='item'>
   *   &lt;template slot='itemTemplate'>
   *     &lt;li>
   *     &lt;a href='#'>&lt;oj-bind-text value='[[item.data.name]]'>&lt;/oj-bind-text>&lt;/a>
   *     &lt;/li>
   *   &lt;/template>
   * &lt;/oj-tab-bar>
   */
  /**
   * <a href="#key-section">Key</a> of the current item.  Current item is the list item which is having active focus.  Note that if currentItem
   * is set to an item that is currently not available (not fetched or
   * inside a collapsed parent node), then the value is ignored.
   * <p>
   * When the current item is changed, the <code class="prettyprint">event.detail</code> of the <code class="prettyprint">currentItemChanged</code> event will contain the following additional properties:<br><br>
   * <table class="props">
   *   <thead>
   *     <tr>
   *       <th>Name</th>
   *       <th>Type</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>item</code></td>
   *       <td class="type">Element</td>
   *       <td class="description">Current Item element</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @expose
   * @public
   * @instance
   * @name currentItem
   * @memberof oj.ojTabBar
   * @type {any}
   * @default null
   * @ojshortdesc Specifies the key of the item that should have keyboard focus. See the Help documentation for more information.
   * @ojwriteback
   *
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">current-item</code> attribute specified:</caption>
   *  &lt;oj-tab-bar current-item='settings'> ... &lt;/oj-tab-bar>
   * @example <caption>Get the current item:</caption>
   * var currentItem = myTabBar.currentItem;
   *
   * @example <caption>Set the current item on the tabbar:</caption>
   * myTabBar.currentItem = "newItem";
   */

  /**
   *
   *  The position of the Tab Bar. Valid Values: top and bottom.
   * @expose
   * @name edge
   * @memberof oj.ojTabBar
   * @instance
   * @type {string}
   * @ojvalue {string} "top" This renders list items horizontally. Generally used when tab bar placed on top of content section.
   * @ojvalue {string} "bottom" This renders list items horizontally. Generally used when tab bar placed on bottom of content section.
   * @ojvalue {string} "start" This renders list items vertically. Generally used when tab bar placed on left/start of content section.
   * @ojvalue {string} "end" This renders list items vertically. Generally used when tab bar placed on right/end of content section.
   * @default start
   * @ojshortdesc Specifies the edge position of the Tab Bar.
   * @ojdeprecated [{target:'propertyValue', for:"end", since: "15.0.0", description: "Use NavigationList instead."}]
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">edge</code> attribute specified:</caption>
   *  &lt;oj-tab-bar edge='top'> ... &lt;/oj-tab-bar>
   * @example <caption>Get the edge:</caption>
   * var edge = myTabBar.edge;
   *
   * @example <caption>Set the edge on the tabbar:</caption>
   * myTabBar.edge = "top";
   */
  /**
   * Specifies if the tabs can be reordered within the tab bar by drag-and-drop.
   * @expose
   * @name reorderable
   * @memberof oj.ojTabBar
   * @instance
   * @ojshortdesc Specifies whether tabs can be reordered.
   *
   * @since 4.1.0
   * @type {string}
   * @ojvalue {string} "enabled" Enables reordering of items in tabbar.
   * @ojvalue {string} "disabled" Disables reordering of items in tabbar.
   * @default disabled
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">reorderable</code> attribute specified:</caption>
   *  &lt;oj-tab-bar reorderable='enabled'> ... &lt;/oj-tab-bar>
   * @example <caption>Get the reorderable:</caption>
   * var reorderable = myTabBar.reorderable;
   *
   * @example <caption>Set the edge on the tabbar:</caption>
   * myTabBar.reorderable = "enabled";
   */
  /**
   * Truncation applies to the tab titles when there is not enough room to display all tabs.
   * @expose
   * @name truncation
   * @memberof oj.ojTabBar
   * @instance
   *
   * @ojshortdesc Specifies whether truncation needs to be applied.
   * @since 4.1.0
   * @type {string}
   * @ojvalue {string} "none" tabs always take up the space needed by the title texts.
   * @ojvalue {string} "progressive"  If not enough space is available to display all of the tabs, then the width of each tab title is restricted just enough to allow all tabs to fit. All tab titles that are truncated are displayed with ellipses. However the width of each tab title will not be truncated below a specific threshold defined by the theme.
   * @default none
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">truncation</code> attribute specified:</caption>
   *  &lt;oj-tab-bar truncation='progressive'> ... &lt;/oj-tab-bar>
   * @example <caption>Get the truncation property:</caption>
   * var truncation = myTabBar.truncation;
   *
   * @example <caption>Set the truncation on the tabbar:</caption>
   * myTabBar.truncation = "progressive";
   */

  /**
   * Item <a href="#key-section">Key</a> of currently selected list item. If the value is modified
   * by an application, tab bar UI is modified to match the new value and the <code class="prettyprint">event.detail</code> of the <code class="prettyprint">selectionChanged</code> event will contain the following additional properties:<br><br>
   * <table class="props">
   *   <thead>
   *     <tr>
   *       <th>Name</th>
   *       <th>Type</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td class="name"><code>item</code></td>
   *       <td class="type">Element</td>
   *       <td class="description">Selected Item element</td>
   *     </tr>
   *   </tbody>
   * </table>
   * @type {any}
   * @name selection
   * @ojshortdesc Specifies the key of the selected item. See the Help documentation for more information.
   * @default null
   * @ojwriteback
   * @expose
   * @instance
   * @ojeventgroup common
   * @memberof oj.ojTabBar
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">selection</code> attribute specified:</caption>
   *  &lt;oj-tab-bar selection='settings'> ... &lt;/oj-tab-bar>
   *
   * @example <caption>Get the selection:</caption>
   * var selection = myTabBar.selection;
   *
   * @example <caption>Set the selection on the tabbar:</caption>
   * myTabBar.selection = "settings";
   */

  /**
   * The data source for the Tab Bar accepts either a TableDataSource or DataProvider.
   * See the data source section in the introduction for out of the box data source types.
   * If the data attribute is not specified, the child elements are used as content.  If there's no
   * content specified, then an empty list is rendered.
   *
   * @expose
   * @name data
   * @memberof oj.ojTabBar
   * @instance
   * @ojshortdesc Specifies the data provider for the Tab Bar. See the Help documentation for more information.
   * @type {Object|null}
   * @ojsignature [{target: "Type", value: "DataProvider<K, D>|null"},
   *               {target: "Type", value: "TableDataSource|DataProvider|null", consumedBy:"js"}]
   * @default null
   * @ojwebelementstatus {type: "deprecated", since: "14.0.0",
   *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">data</code> attribute specified:</caption>
   *  &lt;oj-tab-bar data='[[tableDataSource]]'> ... &lt;/oj-tab-bar>
   * @example <caption>Get the data:</caption>
   * var dataSource = myTabBar.data;
   *
   * @example <caption>Set the data attribute using one-dimensional array:</caption>
   * myTabBar.data = new oj.ArrayTableDataSource([1,2,3]);
   *
   * @example <caption>Set the data attribute using oj.Collection:</caption>
   * myTabBar.data = new oj.CollectionTableDataSource(collection);
   */

  /**
   * Whether to display both the label and icons (<code class="prettyprint">"all"</code>) or just the icons (<code class="prettyprint">"icons"</code>).
   * In the latter case, the label is displayed in a tooltip instead, unless a tooltip was already supplied at create time.
   * Note: If <code class="prettyprint"> display="icons" </code> is used with oj-tabbar-item-end then it is supoorted only for badge and not for icon or metadata.
   * If <code class="prettyprint"> display="stacked" </code> is used with oj-tabbar-item-end then it is supoorted only for badge and not for icon or metadata.
   * It is also mandatory to provide icons for each item as stated in <a href="#icons-section">icons section</a>.
   *
   * @expose
   * @memberof oj.ojTabBar
   * @instance
   * @name display
   * @type {string}
   * @ojvalue {string} "all" Display both the label and icons.
   * @ojvalue {string} "icons" Display only the icons.
   * @ojvalue {string} "stacked" Display icons with stacked label.
   * @default all
   * @ojshortdesc Specifies what needs to be displayed. See the Help documentation for more information.
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">display</code> attribute specified:</caption>
   *  &lt;oj-tab-bar display='icons'> ... &lt;/oj-tab-bar>
   *
   * @example <caption>Get or set the <code class="prettyprint">display</code> property:</caption>
   * // getter
   * var display = myTabBar.display;
   *
   * // setter
   * myTabBar.display = "icons";
   */

  /**
   * Whether to stretch the tab bar items to occupy available space or to condense items
   *
   * @expose
   * @memberof oj.ojTabBar
   * @instance
   * @name layout
   * @type {string}
   * @ojvalue {string} "stretch" all items are stretched
   * @ojvalue {string} "condense" all items are condense
   * @default stretch
   * @ojshortdesc Specifies whether to stretch the tab bar items to occupy available space or to condense items.
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">layout</code> attribute specified:</caption>
   *  &lt;oj-tab-bar layout='condense'> ... &lt;/oj-tab-bar>
   *
   * @example <caption>Get or set the <code class="prettyprint">layout</code> property:</caption>
   * // getter
   * var layout = myTabBar.layout;
   *
   * // setter
   * myTabBar.layout = "stretch";
   */

  /**
   * Specifies the overflow behaviour.
   * NOTE: This is only applicable when <code class="prettyprint">edge</code> attribute set to <code class="prettyprint">top</code>
   * @expose
   * @memberof oj.ojTabBar
   * @name overflow
   * @instance
   * @type {string}
   * @ojvalue {string} "popup" Popup menu will be shown with overflowed items. <p> Note that setting <code class="prettyprint">overflow</code> to <code class="prettyprint">popup</code> can trigger browser reflow, so only set it when it is actually required.
   * @ojvalue {string} "hidden" Overflow is clipped, and the rest of the content will be invisible.
   * @default hidden
   * @ojshortdesc Specifies overflow behaviour for the Tab Bar.
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">overflow</code> attribute specified:</caption>
   *  &lt;oj-tab-bar overflow='popup'> ... &lt;/oj-tab-bar>
   * @example <caption>Get or set the <code class="prettyprint">overflow</code> property:</caption>
   * // getter
   * var overflow = myTabBar.overflow;
   *
   * // setter
   * myTabBar.overflow = "popup";
   */

  /**
   * @typedef {Object} oj.ojTabBar.ItemContext
   * @property {Element} componentElement oj-tab-bar element
   * @property {DataProvider<K, D>} [datasource] A reference to the data source object. (Not available for static content)
   * @property {number} index The index of the item, where 0 is the index of the first item.
   * @property {K} key The Key of the item.
   * @property {D} data The data object for the item.
   * @property {Element} parentElement The list item element. The renderer can use this to directly append content.
   * @ojsignature [{target:"Type", value:"<K, D>", for:"genericTypeParameters"}]
   */

  /**
   * The item property contains a subset of properties for items.
   * @ojshortdesc Customize the functionality of each tab on Tab Bar.
   * @expose
   * @memberof oj.ojTabBar
   * @instance
   * @name item
   * @type {Object}
   */
  /**
   * The renderer function that renders the content of the item. See <a href="#context-section">itemContext</a>
   * in the introduction to see the object passed into the renderer function.
   * The function should return one of the following:
   * <ul>
   *   <li>An Object with the following property:
   *     <ul><li>insert: HTMLElement | string - A string or a DOM element of the content inside the item.</li></ul>
   *   </li>
   *   <li>undefined: If the developer chooses to manipulate the item element directly, the function should return undefined.</li>
   * </ul>
   * If no renderer is specified, Tab Bar will treat the data as a String.
   *
   * @expose
   * @ojshortdesc Specifies the renderer for the tab item. See the Help documentation for more information.
   * @name item.renderer
   * @memberof! oj.ojTabBar
   * @instance
   * @ojsignature { target: "Type",
   *                value: "?(((context: oj.ojTabBar.ItemContext<K, D>) => void)|null)",
   *                jsdocOverride: true}
   * @type {function(Object)|null}
   * @default null
   * @example <caption>Initialize the Tab Bar with the <code class="prettyprint">item.renderer</code> attribute specified:</caption>
   *  &lt;oj-tab-bar item.renderer="{{oj.KnockoutTemplateUtils.getRenderer('template', true)}}"> ... &lt;/oj-tab-bar>
   *
   * @example <caption>Get or set the <code class="prettyprint">renderer</code> property:</caption>
   * // set the renderer function
   * myTabBar.item.renderer = rendererFn;
   *
   * // get the renderer function
   * var rendererFn = myTabBar.item.renderer;
   */
  /**
   * Whether the item is selectable.
   * See <a href="#context-section">itemContext</a> in the introduction to see the object passed into the selectable function.
   *
   * @expose
   * @ojshortdesc Specifies whether the tab can be selected. See the Help documentation for more information.
   * @name item.selectable
   * @memberof! oj.ojTabBar
   * @instance
   * @ojsignature { target: "Type",
   *                value: "?(((context: oj.ojTabBar.ItemContext<K, D>) => boolean)|boolean)",
   *                jsdocOverride: true}
   * @type {function(Object)|boolean}
   * @default true
   *
   * @example <caption>Initialize the Tab Bar such that the first 3 items are not selectable:</caption>
   *  &lt;oj-tab-bar item.selectable="[[skipFirstThreeElementsFn]]">&lt;/oj-tab-bar>
   *
   *  var skipFirstThreeElementsFn = function(itemContext) {
   *                                      return itemContext['index'] > 3;
   *                                 }
   */
  // Events
  /**
   * Triggered when the default animation of a particular action is about to start.  The default animation can be cancelled by calling event.preventDefault.
   * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
   *
   * @expose
   * @ojshortdesc Event handler for when the default animation of a particular action is about to start.
   * @event
   * @name animateStart
   * @memberof oj.ojTabBar
   * @instance
   * @property {string} action the action that triggers the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
   * @property {Element} element the target of animation.
   * @property {function():void} endCallback if the event listener calls event.preventDefault to cancel the default animation, it must call the endCallback function when it finishes its own animation handling and when any custom animation ends.
   */
  /**
   * Triggered when the default animation of a particular action has ended.  Note this event will not be triggered if application cancelled the default animation on animateStart.
   * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
   *
   * @expose
   * @ojshortdesc Event handler for when the default animation of a particular action has ended.
   * @event
   * @name animateEnd
   * @memberof oj.ojTabBar
   * @instance
   * @property {string} action the action that triggered the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
   * @property {Element} element the target of animation.
   */

  /**
   * <p>Triggered before this list item is selected.
   * To prevent the item selection, invoke <code class="prettyprint">event.preventDefault()</code>.
   * @ojshortdesc Event handler for when before the selection is changed.
   * @expose
   * @event
   * @ojcancelable
   * @name beforeSelect
   * @memberof oj.ojTabBar
   * @instance
   * @property {any} key Selected list item <a href="#key-section">Key</a>.
   * @property {Element} item Selected list item.
   */

  /**
   * Triggered before the current item is changed via the <code class="prettyprint">currentItem</code> property or via the UI.
   * To prevent the item being focused, invoke <code class="prettyprint">event.preventDefault()</code>.
   * @ojshortdesc Event handler for when before the current item is changed.
   * @expose
   * @event
   * @memberof oj.ojTabBar
   * @ojcancelable
   * @name beforeCurrentItem
   * @instance
   * @property {any} previousKey the <a href="#key-section">Key</a> of the previous item
   * @property {Element} previousItem the previous item
   * @property {any} key the <a href="#key-section">Key</a> of the new current item
   * @property {Element} item the new current item
   */
  /**
   * Triggered immediately before a tab is deselected.
   * To prevent the item being deselected, invoke <code class="prettyprint">event.preventDefault()</code>.
   * @ojshortdesc Event handler for when before tab is deselected.
   * @expose
   * @event
   * @ojcancelable
   * @memberof oj.ojTabBar
   * @name beforeDeselect
   *
   * @since 4.1.0
   * @instance
   * @property {any} fromKey the <a href="#key-section">Key</a> of the tab item being navigated from
   * @property {Element} fromItem the tab item being navigated from
   * @property {any} toKey the <a href="#key-section">Key</a> of the tab item being navigated to
   * @property {Element} toItem the tab item being navigated to
   */
  /**
   * Triggered after a tab has been deselected.
   * @ojshortdesc Event handler for when a tab is deselected.
   * @expose
   * @event
   * @memberof oj.ojTabBar
   * @name deselect
   *
   * @since 4.1.0
   * @instance
   * @property {any} fromKey the <a href="#key-section">Key</a> of the tab item being navigated from
   * @property {Element} fromItem the tab item being navigated from
   * @property {any} toKey the <a href="#key-section">Key</a> of the tab item being navigated to
   * @property {Element} toItem the tab item being navigated to
   */
  /**
   * Triggered before the item is removed via the UI.
   * To prevent the item being removed, invoke <code class="prettyprint">event.preventDefault()</code>.
   * @ojshortdesc Event handler for when a tab is about to be removed.
   * @expose
   * @event
   * @ojcancelable
   * @memberof oj.ojTabBar
   * @name beforeRemove
   *
   * @since 4.1.0
   * @instance
   * @property {Element} item Item being removed
   * @property {any} key <a href="#key-section">Key</a> of the item being removed
   */
  /**
   * Triggered immediately after a tab is removed. This should be used to remove item from dom or from data source.
   * @ojshortdesc Event handler for when a tab is removed.
   * @expose
   * @event
   * @memberof oj.ojTabBar
   * @name remove
   *
   * @since 4.1.0
   * @instance
   * @property {Element} item Item removed
   * @property {any} key <a href="#key-section">Key</a> of the item removed
   */
  /**
   * Triggered after reordering items within tabbar via drag and drop or cut and paste. This should be used to reorder item in dom or data source.
   * @ojshortdesc Event handler for when a tab is reordered.
   * @expose
   * @event
   * @memberof oj.ojTabBar
   * @name reorder
   *
   * @since 4.1.0
   * @instance
   * @property {Element} item Item to be moved
   * @property {('before'|'after')} position the drop position relative to the reference item. Possible values are "before" and "after".
   * @property {Element} reference the item where the moved items are drop on.
   */
  /**
   * @typedef {Object} oj.ojTabBar.NodeContext
   * @property {string} subId Sub-id string to identify a particular dom node.
   * @property {number} index The index of the item, where 0 is the index of the first item.
   * @property {K} key The Key of the item.
   * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"}]
   */
  /**
   * {@ojinclude "name":"nodeContextDoc"}
   * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
   * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
   * @ojsignature { target: "Type", for: "returns",
   *                value: "oj.ojTabBar.NodeContext<K>|null",
   *                jsdocOverride: true}
   * @example {@ojinclude "name":"nodeContextExample"}
   * @method
   * @expose
   * @name getContextByNode
   * @instance
   * @memberof oj.ojTabBar
   * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
   */

  /**
   * Refreshes the visual state of the Tab Bar. JET components require a <code class="prettyprint">refresh()</code> after the DOM is
   * programmatically changed underneath the component.
   * <p>This method does not accept any arguments.
   *
   * @ojshortdesc Refreshes the visual state of the Tab Bar.
   * @expose
   * @memberof oj.ojTabBar
   * @instance
   * @name refresh
   * @return {void}
   * @method
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   *  myTabBar.refresh();
   */

  // Slots
  /**
   * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the list. The slot content must be a &lt;template> element.
   * The content of the template could either include the &lt;li> element, in which case that will be used as
   * the root of the item.  Or it can be just the content which excludes the &lt;li> element.</p>
   * <p>When the template is executed for each item, it will have access to the binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojTabBar.ItemTemplateContext]{@link oj.ojTabBar.ItemTemplateContext} or the table below for a list of properties available on $current)</li>
   *  <li>alias - if as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   * @ojslot itemTemplate
   * @ojmaxitems 1
   * @memberof oj.ojTabBar
   * @ojshortdesc The itemTemplate slot is used to specify the template for rendering each item in the list. See the Help documentation for more information.
   * @ojtemplateslotprops oj.ojTabBar.ItemTemplateContext
   * @example <caption>Initialize the ListView with an inline item template specified:</caption>
   * &lt;oj-tab-bar>
   *   &lt;template slot='itemTemplate' data-oj-as='item'>
   *     &lt;li>&lt;a href="#">&lt;oj-bind-text value='[[item.data.name]]'>&lt;/oj-bind-text>&lt;/a>&lt;/li>
   *   &lt;/template>
   * &lt;/oj-tab-bar>
   */
  /**
   * @typedef {Object} oj.ojTabBar.ItemTemplateContext
   * @property {Element} componentElement The &lt;oj-tab-bar> custom element
   * @property {Object} data The data for the current item being rendered
   * @property {number} index The zero-based index of the current item
   * @property {any} key The key of the current item being rendered
   */
  // Fragments:

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="2">List Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Selects the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display context menu</td>
   *     </tr>
   *     <tr>
   *       <td>Overflow Menu button</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Open menu. Refer <a href="oj.ojButton.html#touch-section">menu button</a> touch documentation. Note: This is applicable only for Horizontal Tab Bar when <code class="prettyprint">overflow</code> is set to <code class="prettyprint">popup</code>. </td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojTabBar
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="12">List Item</td>
   *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
   *       <td>Selects list item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Moves focus to the previous visible list item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Moves focus to the next  visible list item</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
   *       <td>For horizontal tab bar,focus will be moved to next visible item.
   *       </td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
   *       <td>For horizontal tab bar,focus will be moved to previous visible item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Home</kbd></td>
   *       <td>Moves focus to the first visible list item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>End</kbd></td>
   *       <td>Moves focus to the last visible list item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>F2</kbd></td>
   *       <td>If focus is on a list item, pressing F2 will make its contents accessible using TAB. It can also be used to exit actionable mode if already in actionable mode.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>When F2 mode is enabled, press Esc to exit F2 mode.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+X</kbd></td>
   *       <td>Marks the current item to move if reorderable is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+V</kbd></td>
   *       <td>Paste the item that are marked to directly before the current item</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DELETE</kbd></td>
   *       <td>Delete the current item. </td>
   *     </tr>
   *     <tr>
   *       <td>Overflow Menu button</td>
   *       <td><kbd>Enter or Space</kbd></td>
   *       <td>Open menu. Refer <a href="oj.ojButton.html#touch-section">menu button</a> touch documentation. Note: This is applicable only for Horizontal Tab Bar when <code class="prettyprint">overflow</code> is set to <code class="prettyprint">popup</code>. </td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojTabBar
   */

  // SubId Locators *****************************************************

  /**
   * <p>Sub-ID for the oj-tab-bar component's list item element.</p>
   *
   * <p>
   * To lookup the list items the locator object should have the following:
   * <ul>
   * <li><b>subId</b>: 'oj-tabbar-item'</li>
   * <li><b>key</b>: the <a href="#key-section">Key</a> of the item</li>
   * </ul>
   *
   * @ojsubid oj-tabbar-item
   * @memberof oj.ojTabBar
   *
   * @example <caption>Get the list item element with key 'foo':</caption>
   * var node = myTabBar.getNodeBySubId({'subId': 'oj-tabbar-item', 'key': 'foo'} );
   */
  /**
   * <p>Sub-ID for the oj-tab-bar items's removable icon.</p>
   *
   * <p>
   * To lookup the list items the locator object should have the following:
   * <ul>
   * <li><b>subId</b>: 'oj-tabbar-removable-icon'</li>
   * <li><b>key</b>: the key of the item</li>
   * </ul>
   *
   * @ojsubid oj-tabbar-item
   * @memberof oj.ojTabBar
   *
   * @example <caption>Get the remove icon of item with key 'foo':</caption>
   * var node = myTabBar.getNodeBySubId({'subId': 'oj-tabbar-removable-icon', 'key': 'foo'} );
   */

  // Node Context Objects *********************************************
  /**
   * <p>Context for the oj-tab-bar component's items.</p>
   *
   * @property {number} index the zero based item index
   * @property {Object|string} key the <a href="#key-section">Key</a> of the item
   *
   * @ojnodecontext oj-tabbar-item
   * @memberof oj.ojTabBar
   */

  /**
   * Handler for Expanded Navigation List
   * @constructor
   * @ignore
   */
  const DefaultNavListHandler = function (widget, root, component) {
    this.m_widget = widget;
    this.m_root = root;
    this.m_component = component;
    if (this.m_widget.GetOption(this.m_widget.OPTION_EDGE) === this.m_widget.OPTION_EDGE_END) {
      this.m_root.addClass(this.m_widget.getNavListEndEdgeStyleClass());
    }
  };
  oj._registerLegacyNamespaceProp('DefaultNavListHandler', DefaultNavListHandler);

  /**
   * Restore Listview element
   * @private
   */
  DefaultNavListHandler.prototype.Destroy = function () {
    this.m_root
      .removeClass(this.m_widget.getNavListExpandedStyleClass())
      .removeClass(this.m_widget.getNavListVerticalStyleClass())
      .removeClass(this.m_widget.getNavListEndEdgeStyleClass());
  };

  /**
   * Expand group Item
   * @param {jQuery} groupItem  Group Item
   * @param {boolean} animate true if animate the expand operation, false otherwise
   * @param {Event} event the event that triggers expand.  Note that event could be null in the case where this is programmatically done by the widget
   * @return {Promise} A Promise that resolves when expand animation completes
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.Expand = function (groupItem, animate, event) {
    return Promise.resolve(null);
  };

  /**
   * Collapse group Item
   * @param {jQuery} item  Group Item
   * @param {Object} key key of Group item
   * @param {boolean} animate true if animate the collapse operation, false otherwise
   * @param {Event} event the event that triggers collapse.  Note that event could be null in the case where this is programmatically done by the widget
   * @return {Promise} A Promise that resolves when collapse animation completes
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.Collapse = function (item, key, animate, event) {
    return Promise.resolve(null);
  };

  /**
   * Handle keyboard events for expand and collapse
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleExpandAndCollapseKeys =
    // eslint-disable-next-line no-unused-vars
    function (event, keyCode, current, currentItemKey) {
      return false;
    };

  /**
   * Mofify List item
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.ModifyListItem = function ($item, itemContent) {
    var isHierarchical = this.m_widget.m_contentHandler.IsHierarchical();
    // Except for collapsible/sliding/ group navlist items everything else should have role tab
    if (!isHierarchical || this.m_widget.isTabBar()) {
      var focusableElement = this.m_widget.getSingleFocusableElement($item);
      focusableElement.attr('role', 'tab');
    }
  };

  /**
   * Update aria properties when an item is selected.
   * @private
   */
  DefaultNavListHandler.prototype.UpdateAriaPropertiesOnSelectedItem = function (elem, highlight) {
    elem.attr('aria-selected', highlight ? 'true' : 'false');
  };

  /**
   * Placeholder to override or update generated dom after completing rendering
   * @private
   */
  DefaultNavListHandler.prototype.BeforeRenderComplete = function () {
    var role = this.m_widget.element.attr('role');
    if (role && role !== 'presentation') {
      this.m_widget.element.attr('role', 'presentation');
      var isHierarchical = this.m_widget.m_contentHandler.IsHierarchical();
      // If it is a collapsible/sliding/ group navlist role should be inherited from data provider.
      if (!this.m_widget.isTabBar() && isHierarchical) {
        this.m_root.attr('role', role);
      } else {
        // If it is a vertical navlist it should have aria-orientation
        if (this.m_root.hasClass(this.m_widget.getNavListVerticalStyleClass())) {
          this.m_root.attr('aria-orientation', 'vertical');
        }
        this.m_root.attr('role', 'tablist');
      }
    }
  };

  /**
   * Called by content handler once the content of an item is rendered triggered by an insert event
   * @param {Element} elem the item element
   * @param {Object} context the context object used for the item
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.ItemInsertComplete = function (elem, context) {};

  /**
   * Called by content handler once the content of an item is removed triggered by an remove event
   * @param {Element} elem the item element
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.ItemRemoveComplete = function (elem) {};

  /**
   * Handles arrow keys navigation on item
   * @param {number} keyCode description
   * @param {boolean} isExtend
   * @param {Event} event the DOM event causing the arrow keys
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleArrowKeys = function (keyCode, isExtend, event) {
    return _ojNavigationListView.superclass.HandleArrowKeys.apply(this.m_widget, arguments);
  };

  /**
   * Determine whether the key code is an arrow key
   * @param {number} keyCode
   * @return {boolean} true if it's an arrow key, false otherwise
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.IsArrowKey = function (keyCode) {
    return _ojNavigationListView.superclass.IsArrowKey.apply(this.m_widget, arguments);
  };

  /**
   * Determines whether the specified item is expanded
   * @param {jQuery} item the item element
   * @return {number} 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.GetState = function (item) {
    return _ojNavigationListView.superclass.GetState.apply(this.m_widget, arguments);
  };

  /**
   * Sets the disclosed state of the item
   * @param {jQuery} item the item element
   * @param {number} state 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.SetState = function (item, state) {
    _ojNavigationListView.superclass.SetState.apply(this.m_widget, arguments);
  };

  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.Init = function (opts) {
    this.m_root
      .addClass(this.m_widget.getNavListExpandedStyleClass())
      .addClass(this.m_widget.getNavListVerticalStyleClass());
  };

  /**
   * Check whether the item is selectable
   * @param {Element} item the item element
   * @return {boolean} true if item is selectable
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.IsSelectable = function (item) {
    return _ojNavigationListView.superclass.IsSelectable.apply(this.m_widget, arguments);
  };

  /**
   * Restore Item
   * @param {jQuery} item, List item
   * @param {jQuery} itemContent, Item contentelement
   * @param {jQuery} sublist, sub list when item is a group item.
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.RestoreItem = function (item, itemContent, sublist) {};

  /**
   * Invoked when an option was updated after component initialization.
   * Note: This will be invoked only for specifc options. see setOptions method in NavigationList.js.
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.SetOptions = function (options) {
    // DO Nothing
  };

  /**
   * Handler for blur event
   * @param {Event} event the blur event
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleBlur = function (event) {
    return _ojNavigationListView.superclass.HandleBlur.apply(this.m_widget, arguments);
  };

  /**
   * Handler for focus event
   * @param {Event} event the focus event
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleFocus = function (event) {
    return _ojNavigationListView.superclass.HandleFocus.apply(this.m_widget, arguments);
  };

  /**
   * Return node for the given subid
   * @param {Object} locator
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.GetNodeBySubId = function (locator) {
    return null;
  };

  /**
   * Return subid for the given node
   * @param {Element} node
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.GetSubIdByNode = function (node) {
    return null;
  };

  /**
   * Handle resize event
   * @param {number} width
   * @param {number} height
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleResize = function (width, height) {};

  /**
   * Invoked when root node is attached
   * @protected
   */
  DefaultNavListHandler.prototype.NotifyAttached = function () {};

  /**
   * Return subid for the given node
   * @param {string} action
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.GetAnimationEffect = function (action) {
    return _ojNavigationListView.superclass.getAnimationEffect.apply(this.m_widget, arguments);
  };

  /**
   * Return true if option update allowed.
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.IsOptionUpdateAllowed = function (key, value, flags) {
    return true;
  };

  /**
   * Triggered when an option is updated
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.OptionUpdated = function (key, value, flags) {};
  /**
   * Invoked before inserting an item in to nav list
   * @protected
   */
  DefaultNavListHandler.prototype.BeforeInsertItem = function () {};

  /**
   * Invoked when click event fired
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleClick = function (event) {};

  /**
   * Invoked when click event fired
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleKeydown = function (event) {};
  /**
   * Invoked when item selection changed.
   * @protected
   */
  // eslint-disable-next-line no-unused-vars
  DefaultNavListHandler.prototype.HandleSelectionChange = function (item) {};

  /**
   * Handler for Collapsible Navigation List
   * @constructor
   * @extends DefaultNavListHandler
   * @ignore
   */
  const CollapsibleNavListHandler = function (widget, root, component) {
    CollapsibleNavListHandler.superclass.constructor.call(this, widget, root, component);
  };
  // Subclass from oj.Object
  oj.Object.createSubclass(
    CollapsibleNavListHandler,
    DefaultNavListHandler,
    'oj.CollapsibleNavListHandler'
  );

  oj._registerLegacyNamespaceProp('CollapsibleNavListHandler', CollapsibleNavListHandler);

  CollapsibleNavListHandler.prototype.Destroy = function () {
    this.m_root
      .removeClass(this.m_widget.getNavListCollapsibleStyleClass())
      .removeClass(this.m_widget.getNavListVerticalStyleClass());
  };

  // eslint-disable-next-line no-unused-vars
  CollapsibleNavListHandler.prototype.Init = function (opts) {
    this.m_root
      .addClass(this.m_widget.getNavListCollapsibleStyleClass())
      .addClass(this.m_widget.getNavListVerticalStyleClass());
  };

  // eslint-disable-next-line no-unused-vars
  CollapsibleNavListHandler.prototype.Expand = function (groupItem, animate, event) {
    return _ojNavigationListView.superclass.AnimateExpand.apply(this.m_widget, arguments);
  };

  // eslint-disable-next-line no-unused-vars
  CollapsibleNavListHandler.prototype.Collapse = function (item, key, animate, event) {
    return _ojNavigationListView.superclass.AnimateCollapse.apply(this.m_widget, arguments);
  };

  CollapsibleNavListHandler.prototype.HandleExpandAndCollapseKeys = function (
    event,
    keyCode,
    current,
    currentItemKey
  ) {
    var isGroupItem = current.children('.' + this.m_widget.getGroupStyleClass()).length > 0;
    if (keyCode === this.m_widget.LEFT_KEY || keyCode === this.m_widget.RIGHT_KEY) {
      // Need to reverse left/right functionality  in rtl case
      if (
        (keyCode === this.m_widget.LEFT_KEY && !this.m_widget.isRtl()) ||
        (keyCode === this.m_widget.RIGHT_KEY && this.m_widget.isRtl())
      ) {
        if (this.m_widget.GetState(current) === this.m_widget.STATE_EXPANDED) {
          this.m_widget.CollapseItem(current, event, true, currentItemKey, true, true);
        }
      } else if (this.m_widget.GetState(current) === this.m_widget.STATE_COLLAPSED) {
        this.m_widget.ExpandItem(current, event, true, currentItemKey, true, true, true);
      }
      return true;
    }

    if (isGroupItem && (keyCode === $.ui.keyCode.ENTER || keyCode === $.ui.keyCode.SPACE)) {
      if (current.length <= 0) {
        return false;
      }
      if (this.m_widget.GetState(current) === this.m_widget.STATE_COLLAPSED) {
        this.m_widget.ExpandItem(current, null, true, currentItemKey, true, true, true);
      } else if (this.m_widget.GetState(current) === this.m_widget.STATE_EXPANDED) {
        this.m_widget.CollapseItem(current, null, true, currentItemKey, true, true);
      }
      return true;
    }
    return false;
  };

  const _ARIA_SELECTED = 'aria-selected';
  const _OJ_DEFAULT$1 = 'oj-default';

  /**
   * Handler for Horizontal Navigation List
   * @constructor
   * @extends DefaultNavListHandler
   * @ignore
   */

  const HorizontalNavListHandler = function (widget, root, component) {
    this.m_duringInit = true;
    HorizontalNavListHandler.superclass.constructor.call(this, widget, root, component);
    if (this.m_widget.GetOption(this.m_widget.OPTION_EDGE) === this.m_widget.OPTION_EDGE_BOTTOM) {
      this.m_root.addClass(this.m_widget.getNavListBottomEdgeStyleClass());
    }
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(
    HorizontalNavListHandler,
    DefaultNavListHandler,
    'oj.HorizontalNavListHandler'
  );

  oj._registerLegacyNamespaceProp('HorizontalNavListHandler', HorizontalNavListHandler);

  HorizontalNavListHandler.prototype.Destroy = function () {
    this.m_root
      .removeClass(this.m_widget.getNavListExpandedStyleClass())
      .removeClass(this.m_widget.getHorizontalNavListStyleClass())
      .removeClass(this.m_widget.getNavListBottomEdgeStyleClass());
    this.m_root.find('.' + this.m_widget.getDividerStyleClass()).remove();

    this._destroyOverflowMenu();

    if (this.m_overflowMenuItem != null) {
      this.m_overflowMenuItem.remove();
      this.m_overflowMenuItem = null;
    }
    this.m_overflowMenuItems = [];
    this.m_duringInit = true;
  };

  HorizontalNavListHandler.prototype.UpdateAriaPropertiesOnSelectedItem = function (elem, highlight) {
    // prettier-ignore
    elem.attr( // @HTMLUpdateOK
      _ARIA_SELECTED,
      highlight ? 'true' : 'false'
    );
  };

  HorizontalNavListHandler.prototype._isTabBar = function () {
    return this.m_widget.isTabBar();
  };

  HorizontalNavListHandler.prototype._getScrollableParent = function (node, includeHidden) {
    var nodePosition = window.getComputedStyle(node).position;
    var excludeStaticParent = nodePosition === 'absolute';
    var overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
    var found = false;
    var scrollParent;
    var parent = node.parentElement;
    while (parent && !found) {
      const { overflow, overflowY, overflowX, position } = window.getComputedStyle(parent);
      if (
        !(excludeStaticParent && position === 'static') &&
        overflowRegex.test(overflow + overflowY + overflowX)
      ) {
        scrollParent = parent;
        found = true;
      }
      parent = parent.parentElement;
    }

    return nodePosition === 'fixed' || !scrollParent
      ? node.ownerDocument.documentElement || document.documentElement
      : scrollParent;
  };

  HorizontalNavListHandler.prototype._isElementInsideHorizontalScrollerBounds = function (
    elem,
    scroller
  ) {
    var left;
    var right;
    if (scroller === document.documentElement) {
      left = 0;
      right = document.documentElement.clientWidth;
    } else {
      var scrollerBounds = scroller.getBoundingClientRect();
      left = scrollerBounds.left;
      right = scrollerBounds.right;
    }
    var bounds = elem.getBoundingClientRect();
    return (
      bounds.left <= right && bounds.right <= right && bounds.left >= left && bounds.right >= left
    );
  };

  /**
   * Handles arrow keys navigation on item
   * @param {number} keyCode description
   * @param {boolean} isExtend
   * @param {Event} event the DOM event causing the arrow keys
   * @private
   */
  HorizontalNavListHandler.prototype.HandleArrowKeys = function (keyCode, isExtend, event) {
    // Change keyCode to reverse left/right arrow keys for rtl case.
    if (keyCode === 'ArrowLeft' || keyCode === 'Left' || keyCode === $.ui.keyCode.LEFT) {
      // eslint-disable-next-line no-param-reassign
      keyCode = this.m_widget.isRtl() ? $.ui.keyCode.DOWN : $.ui.keyCode.UP;
    } else if (keyCode === 'ArrowRight' || keyCode === 'Right' || keyCode === $.ui.keyCode.RIGHT) {
      // eslint-disable-next-line no-param-reassign
      keyCode = this.m_widget.isRtl() ? $.ui.keyCode.UP : $.ui.keyCode.DOWN;
    }

    var processed = _ojNavigationListView.superclass.HandleArrowKeys.call(
      this.m_widget,
      keyCode,
      isExtend,
      event
    );
    var current = this.m_widget.m_active.elem;

    if (!this._scrollableParent) {
      // caching
      this._scrollableParent = this._getScrollableParent(this.m_root[0], true);
    }
    if (!this._isElementInsideHorizontalScrollerBounds(current[0], this._scrollableParent)) {
      current[0].scrollIntoView({ block: 'nearest', inline: 'nearest' });
    }
    return processed;
  };

  /**
   *
   * @param {number} keyCode
   * @return {boolean}
   * @private
   */
  HorizontalNavListHandler.prototype.IsArrowKey = function (keyCode) {
    return (
      keyCode === 'ArrowUp' ||
      keyCode === 'Up' ||
      keyCode === this.m_widget.UP_KEY ||
      keyCode === 'ArrowDown' ||
      keyCode === 'Down' ||
      keyCode === this.m_widget.DOWN_KEY ||
      keyCode === 'ArrowLeft' ||
      keyCode === 'Left' ||
      keyCode === this.m_widget.LEFT_KEY ||
      keyCode === 'ArrowRight' ||
      keyCode === 'Right' ||
      keyCode === this.m_widget.RIGHT_KEY
    );
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.ModifyListItem = function ($item, itemContent) {
    var focusableElement = this.m_widget.getSingleFocusableElement($item);
    focusableElement.attr('role', 'tab');
  };

  HorizontalNavListHandler.prototype.BeforeRenderComplete = function () {
    var self = this;
    this.m_root.attr('role', 'tablist');
    this.m_widget.element.attr('role', 'presentation');

    if (this.m_widget.GetOption('layout') === 'condense') {
      if (!this.m_root.hasClass(this.m_widget.getCondenseStyleClass())) {
        this.m_root.addClass(this.m_widget.getCondenseStyleClass());
      }
    }
    var visibleItems = this.m_widget.element.find(
      '.' + this.m_widget.getItemElementStyleClass() + ':visible'
    );
    visibleItems.each(function (index) {
      var ele = $(this);
      if (index > 0) {
        self._addSeparator(this, index);
      }

      if (index === visibleItems.length - 1) {
        ele.addClass(self.m_widget.getLastItemStyleClass());
      } else {
        ele.removeClass(self.m_widget.getLastItemStyleClass());
      }
    });
    if (this.m_duringInit) {
      this.m_duringInit = false;
      this._handleOverflow();
    }
  };

  HorizontalNavListHandler.prototype._addSeparator = function (elem, index) {
    var $elem = $(elem);
    var previousElement = $elem.prev();
    if (
      index > 0 &&
      previousElement.length &&
      !previousElement.is('li.' + this.m_widget.getDividerStyleClass())
    ) {
      // prettier-ignore
      $elem.before( // @HTMLUpdateOK
        '<li role="presentation" class="' + this.m_widget.getDividerStyleClass() + '"></li>'
      );
    }
  };

  HorizontalNavListHandler.prototype.ItemInsertComplete = function (elem, context) {
    this._addSeparator(elem, context.index);
    this._handleOverflow();
  };

  HorizontalNavListHandler.prototype.ItemRemoveComplete = function (elem) {
    var $elem = $(elem);
    var previousElement = $elem.prev();

    if (previousElement.length && previousElement.is('li.' + this.m_widget.getDividerStyleClass())) {
      previousElement.remove();
    } else {
      // Means,this could be the first element,
      // so ensure that divider is not present on next element which is going to be the first one.
      // This is needed because when complete observable array is updated with new set of records, first new records will be added before removing old ones.
      var nextElement = $elem.next();
      if (nextElement.is('li.' + this.m_widget.getDividerStyleClass())) {
        nextElement.remove();
      }
    }
    this._handleOverflow();
  };

  HorizontalNavListHandler.prototype.IsSelectable = function (item) {
    var itemSelectionMarkerAttr = _ARIA_SELECTED;
    return (
      !(this.m_overflowMenuItem && this.m_overflowMenuItem[0] === $(item)[0]) &&
      this.m_widget.getFocusItem($(item))[0].hasAttribute(itemSelectionMarkerAttr)
    );
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.Init = function (opts) {
    this.m_root
      .addClass(this.m_widget.getNavListExpandedStyleClass())
      .addClass(this.m_widget.getHorizontalNavListStyleClass());
    this.m_overflowMenuItems = [];
  };

  HorizontalNavListHandler.prototype.HandleClick = function (event) {
    if (
      $(event.target).closest(
        '.' +
          this.m_widget.getOverflowItemStyleClass() +
          ' a.' +
          this.m_widget.getItemContentStyleClass()
      ).length > 0
    ) {
      this._launchOverflowMenu(event);
    }
  };

  HorizontalNavListHandler.prototype.HandleKeydown = function (event) {
    if (
      $(event.target).closest(
        '.' +
          this.m_widget.getOverflowItemStyleClass() +
          ' a.' +
          this.m_widget.getItemContentStyleClass()
      ).length > 0
    ) {
      if (event.keyCode === $.ui.keyCode.SPACE) {
        this._launchOverflowMenu(event);
      }
    }
  };

  HorizontalNavListHandler.prototype.NotifyAttached = function () {
    this._handleOverflow();
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.HandleResize = function (width, height) {
    if (this.m_ignoreNextResize) {
      this.m_ignoreNextResize = false;
      return;
    }
    this._handleOverflow();
  };

  HorizontalNavListHandler.prototype.SetOptions = function (options) {
    var overflow;
    var truncation;
    var currentOverflow = this.m_widget.GetOption('overflow');
    var currentTruncation = this.m_widget.GetOption('truncation');

    if (options.overflow && currentOverflow !== options.overflow) {
      overflow = options.overflow;
    }
    if (options.truncation && currentTruncation !== options.truncation) {
      truncation = options.truncation;
    }
    if (overflow || truncation) {
      this._handleOverflow(overflow, truncation);
    }
  };

  HorizontalNavListHandler.prototype.HandleSelectionChange = function (item) {
    if (this.m_overflowMenuItem) {
      if (item != null && item.style.display === 'none') {
        this._highlightUnhighlightMoreItem(true);
      } else {
        this._highlightUnhighlightMoreItem(false);
      }
    }
  };

  HorizontalNavListHandler.prototype.GetAnimationEffect = function (action) {
    if (action === 'add' || action === 'remove') {
      return _ojNavigationListView.superclass.getAnimationEffect.call(
        this.m_widget,
        action + 'HorizontalItem'
      );
    }
    return _ojNavigationListView.superclass.getAnimationEffect.apply(this.m_widget, arguments);
  };

  HorizontalNavListHandler.prototype.GetNodeBySubId = function (locator) {
    var item = null;
    var subId = locator.subId;

    if (subId === this.m_widget.getItemSubIdKey() && this.m_overflowMenuItems.length > 0) {
      var overflowMenu = this._getOverflowMenu();
      var key = locator.key;
      var menuItems = overflowMenu.find('.oj-menu-item');

      for (var index = 0; index < menuItems.length; index++) {
        if (this.m_widget.compareValues($(menuItems[index]).data('key'), key)) {
          item = menuItems[index];
          this._launchOverflowMenu(null);
          break;
        }
      }
    }
    return item;
  };

  HorizontalNavListHandler.prototype.GetSubIdByNode = function (node) {
    var subId = null;
    var item = $(node).closest('.oj-menu-item');

    if (
      this._getOverflowMenu() !== null &&
      item.closest('.' + this.m_widget.getOverflowMenuStyleClass())[0] !== this._getOverflowMenu()[0]
    ) {
      return null;
    }

    if (item != null && item.length > 0) {
      var key = item.data('key');
      if (key != null) {
        subId = {
          subId: this.m_widget.getItemSubIdKey(),
          key: key
        };
      }
    }
    return subId;
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.OptionUpdated = function (key, value, flags) {
    if (key === 'selection') {
      this._toggleOverflowBtnSelection(value);
    }
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.IsOptionUpdateAllowed = function (key, value, flags) {
    if (key === 'currentItem') {
      if (this.m_overflowMenuItem && this.m_overflowMenuItem.attr('id') === value) {
        // ignore as this happens only for navigationlist more item and
        // we should not change currentItem
        return false;
      }
    }
    return true;
  };

  /**
   * Overflow handler for horizontal navigation list
   * @constructor
   * @ignore
   * @private
   */
  var _HorizontalNavListOverflowHandler = function (
    items,
    overflow,
    truncation,
    display,
    navlistHandler
  ) {
    this._overflow = overflow;
    this._truncation = truncation;
    this._items = items;
    this._display = display;
    this._navlistHandler = navlistHandler;
  };

  /**
   * Handle overflow.
   * @param {string=} overflow optional overflow behaviour, if not specified component overflow option will be used.
   * @param {string=} truncation optional truncation behaviour, if not specified component truncation option will be used.
   */
  HorizontalNavListHandler.prototype._handleOverflow = function (overflow, truncation) {
    var threshold = -1;
    var items = this._getItems();

    // return if there are no items
    if (items.length === 0) {
      return;
    }

    var display = this.m_widget.GetOption('display');

    if (!overflow) {
      // eslint-disable-next-line no-param-reassign
      overflow = this.m_widget.GetOption('overflow');
    }
    if (!truncation) {
      // eslint-disable-next-line no-param-reassign
      truncation = this.m_widget.GetOption('truncation');
    }

    var overflowHandler = new _HorizontalNavListOverflowHandler(
      items,
      overflow,
      truncation,
      display,
      this
    );

    // Return if there is no truncation or overflow handling needed
    if (!overflowHandler.shouldHandleOverflow()) {
      overflowHandler.unApplyTruncation();
      this._releaseContainerWidth();
      return;
    }

    this.showAllItems(items, overflow);
    overflowHandler.unApplyTruncation(); // unpply truncation if anything applied previously
    if (overflowHandler.checkForOverflow() && overflowHandler.applyTruncation()) {
      threshold = overflowHandler.getOverflowThreshold(); // caclulate threhsold only when it still overflow after truncation.
    }
    this._applyThreshold(threshold);
    this._releaseContainerWidth();
  };

  HorizontalNavListHandler.prototype.BeforeInsertItem = function () {
    this._fixContainerWidth();
  };

  HorizontalNavListHandler.prototype._fixContainerWidth = function () {
    var root = this.m_widget.getListContainer();
    var width = root[0].getBoundingClientRect().width;
    if (width !== 0) {
      // it will be 0 when there are no elements in the list.
      this.m_freezedContainerWidth = width;
      root.css('maxWidth', width);
    }
  };

  HorizontalNavListHandler.prototype._releaseContainerWidth = function () {
    var root = this.m_widget.getListContainer();
    root.css('maxWidth', 'none');

    if (this.m_freezedContainerWidth) {
      // Already applied truncation logic but still overflows
      // then no need to run overflow logic again, in case of conveyor belt this helps to show left/right buttons
      this.m_ignoreNextResize = true;
      this.m_freezedContainerWidth = null;
    }
  };

  HorizontalNavListHandler.prototype.showAllItems = function (items, overflow) {
    var self = this;
    // show all the items including overflow button
    if (overflow === 'popup') {
      this._showOrHideItem(this._getOverflowMenuButton(), true);
    }

    items.each(function (index, item) {
      self._showOrHideItem($(item), true);
    });
  };

  HorizontalNavListHandler.prototype._getItems = function () {
    return this.m_root.find(
      '.' +
        this.m_widget.getItemElementStyleClass() +
        ':not(.' +
        this.m_widget.getOverflowItemStyleClass() +
        ')'
    );
  };

  HorizontalNavListHandler.prototype._hasSeparators = function () {
    return this.m_root.hasClass(this.m_widget.getNavListItemsDividerStyleClass());
  };

  HorizontalNavListHandler.prototype._showOrHideItem = function (item, show) {
    var separator;
    if (this._hasSeparators()) {
      separator = item.prev('.' + this.m_widget.getDividerStyleClass());
    }
    if (show) {
      item.show();
      if (separator) {
        separator.show(); // show separator when hiding overflow item
      }
    } else {
      item.hide();
      if (separator) {
        separator.hide(); // hide separator when hiding item
      }
    }
  };

  HorizontalNavListHandler.prototype._applyThreshold = function (threshold) {
    var self = this;
    var items = this._getItems();
    var overflowMenuDataArray = [];
    var lastVisibleChild;
    var isOverflowItemVisible;

    if (items.length === 0) {
      return;
    }

    this.m_root
      .find('.' + this.m_widget.getLastItemStyleClass())
      .removeClass(this.m_widget.getLastItemStyleClass());

    if (threshold === -1 || threshold >= items.length) {
      if (this.m_overflowMenuItem) {
        // if overflow item is already added need to hide it
        this._showOrHideItem(this.m_overflowMenuItem, false);
      }
    } else {
      // As listview always inserts item using index means it will insert new item before index+1 item
      // some time it is possible that new item is inserted between overflow item  and it's separator,
      // so ensuring that separator is added if it's not already there.
      this._addSeparator(this._getOverflowMenuButton(), items.length);

      this._showOrHideItem(this._getOverflowMenuButton(), true);
      isOverflowItemVisible = true;
    }

    items.each(function (index, item) {
      var $item = $(item);
      if (threshold !== -1 && threshold <= index) {
        if ($item.hasClass('oj-focus')) {
          self.m_widget.ActiveAndFocus(self._getOverflowMenuButton(), null);
        }

        if ($item.hasClass('oj-selected')) {
          self._highlightUnhighlightMoreItem(true);
        }

        self._showOrHideItem($item, false);
        var overflowMenuData = {};
        overflowMenuDataArray.push(overflowMenuData);
        overflowMenuData.key = self.m_widget.GetKey(item);
        overflowMenuData.label = self._getItemLabel($item);
        if ($item.hasClass('oj-disabled')) {
          overflowMenuData.disabled = true;
        }
      } else {
        lastVisibleChild = $item;
        self._showOrHideItem($item, true);
        if ($item.hasClass('oj-selected') && self.m_overflowMenuItem) {
          self._highlightUnhighlightMoreItem(false);
        }
        if (
          self.m_overflowMenuItem &&
          self.m_overflowMenuItem.hasClass('oj-focus') &&
          self.m_widget.compareValues(
            self.m_widget.GetKey(item),
            self.m_widget.GetOption('currentItem')
          )
        ) {
          self.m_widget.ActiveAndFocus(lastVisibleChild, null);
        }
      }
    });

    if (isOverflowItemVisible) {
      this._getOverflowMenuButton().addClass(this.m_widget.getLastItemStyleClass());
    } else {
      lastVisibleChild.addClass(this.m_widget.getLastItemStyleClass());
    }

    this.m_overflowMenuItems = overflowMenuDataArray;
    this.m_widget.ClearCache();

    var isOverflowMenuVisible = this.m_overflowMenu && this.m_overflowMenu.is(':visible');
    this._destroyOverflowMenu();

    // launching sheetmenu some times make scrollbars visible which is triggering resize event.
    // So relaunching menu if it is already launched.
    if (isOverflowMenuVisible) {
      this._launchOverflowMenu(null);
    }
  };

  HorizontalNavListHandler.prototype._highlightUnhighlightMoreItem = function (highlight) {
    var overflowBtn = this._getOverflowMenuButton();
    if (highlight) {
      overflowBtn.addClass('oj-selected').removeClass(_OJ_DEFAULT$1);
    } else {
      overflowBtn.removeClass('oj-selected').addClass(_OJ_DEFAULT$1);
    }
  };

  HorizontalNavListHandler.prototype._destroyOverflowMenu = function () {
    if (this.m_overflowMenu) {
      this.m_overflowMenu.ojMenu('destroy');
      this.m_overflowMenu.remove();
      this.m_overflowMenu = null;
    }
  };

  HorizontalNavListHandler.prototype._getOverflowMenuButton = function () {
    if (!this.m_overflowMenuItem) {
      var overflowMenuItem = $(document.createElement('li'));
      var anchorElement = $(document.createElement('a'));
      var iconElement = $(document.createElement('span'));
      var items = this._getItems();
      overflowMenuItem
        .uniqueId()
        .attr('role', 'presentation')
        .addClass(this.m_widget.getItemElementStyleClass())
        .addClass(this.m_widget.getItemStyleClass())
        .addClass(this.m_widget.getOverflowItemStyleClass())
        .addClass(_OJ_DEFAULT$1)
        .append(anchorElement); // @HTMLUpdateOK constructed by component and not using string passed through any API
      anchorElement
        .addClass(this.m_widget.getFocusedElementStyleClass())
        .addClass(this.m_widget.getItemContentStyleClass());
      anchorElement
        .attr('role', 'tab')
        .attr('aria-haspopup', 'true')
        .attr(_ARIA_SELECTED, 'false') // @HTMLUpdateOK
        .attr('tabindex', '-1')
        .attr('href', '#')
        .append(iconElement); // @HTMLUpdateOK constructed by component and not using string passed through any API
      DataCollectionUtils.disableElement(anchorElement[0]);

      iconElement
        .addClass(this.m_widget.getItemIconStyleClass())
        .addClass('oj-fwk-icon')
        .addClass(this.m_widget.getOverflowItemIconStyleClass());
      var iconLabel = this.m_widget.ojContext.getTranslatedString('overflowItemLabel');
      iconElement.attr('aria-label', iconLabel);

      overflowMenuItem[0].key = overflowMenuItem.attr('id');
      this.m_root.find('.' + this.m_widget.GetStyleClass()).append(overflowMenuItem); // @HTMLUpdateOK constructed by component and not using string passed through any API
      this._addSeparator(overflowMenuItem, items.length);
      this.m_overflowMenuItem = overflowMenuItem;
    }
    return this.m_overflowMenuItem;
  };

  HorizontalNavListHandler.prototype._getOverflowMenu = function () {
    var self = this;
    var data = this.m_overflowMenuItems;

    if (data.length === 0) {
      return null;
    }

    if (!this.m_overflowMenu) {
      var overflowMenu = $(document.createElement('ul'));
      overflowMenu.addClass(this.m_widget.getOverflowMenuStyleClass()).hide();
      this.m_root.append(overflowMenu); // @HTMLUpdateOK constructed by component and not using string passed through any API

      // create menu markup
      for (var i = 0; i < data.length; i++) {
        var menuListItem = $(document.createElement('li'));
        var menuItem = $(document.createElement('a'));

        menuItem.attr('href', '#').text(data[i].label);

        menuListItem.data('key', data[i].key);

        if (data[i].disabled) {
          menuListItem.addClass('oj-disabled');
        }

        menuListItem.append(menuItem); // @HTMLUpdateOK menuItem's label text is read from dataSource and it was properly escaped
        overflowMenu.append(menuListItem); // @HTMLUpdateOK constructed by component and not using string passed through any API
      }

      // initialize ojmenu
      overflowMenu.ojMenu({
        openOptions: {
          display: 'auto'
        },
        open: self.__handleOverflowMenuOpen.bind(self),
        close: self.__handleOverflowMenuClose.bind(self),
        select: self.__handleOverflowMenuSelection.bind(self)
      });
      this.m_overflowMenu = overflowMenu;
    }

    return this.m_overflowMenu;
  };

  HorizontalNavListHandler.prototype._launchOverflowMenu = function (event) {
    var self = this;

    if (this._getOverflowMenu().is(':visible')) {
      return; // ignore if overflow menu already launched
    }

    this._getOverflowMenu().ojMenu('open', event, {
      launcher: self._getOverflowMenuButton(),
      initialFocus: 'firstItem',
      position: {
        my: 'end bottom',
        at: 'end top',
        collision: 'flipfit'
      }
    });
  };

  HorizontalNavListHandler.prototype._toggleOverflowBtnSelection = function (selectedItem) {
    var overflowItemSelected;
    if (this.m_overflowMenuItem && this.m_overflowMenuItems.length > 0) {
      if (selectedItem) {
        for (var i = 0; i < this.m_overflowMenuItems.length; i++) {
          if (this.m_widget.compareValues(this.m_overflowMenuItems[i].key, selectedItem)) {
            overflowItemSelected = true;
            break;
          }
        }
      }

      if (!overflowItemSelected) {
        this._highlightUnhighlightMoreItem(false);
      } else {
        // other items should not be visually selected since an overflow item is already selected
        const visibleItems = this.m_widget.element[0].querySelectorAll(
          '.' + this.m_widget.getItemElementStyleClass() + '.oj-selected'
        );
        for (let j = 0; j < visibleItems.length - 1; j++) {
          if (!this.m_widget.compareValues(visibleItems[j].key, selectedItem)) {
            visibleItems[j].classList.remove('oj-selected');
          }
        }
      }
    }
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.__handleOverflowMenuOpen = function (event) {
    this._getOverflowMenuButton()
      .find('.' + this.m_widget.getItemContentStyleClass())
      .attr('tabindex', '0');
  };

  // eslint-disable-next-line no-unused-vars
  HorizontalNavListHandler.prototype.__handleOverflowMenuClose = function (event) {
    var selectedItem = this.m_widget.ojContext.option('selection');
    this._toggleOverflowBtnSelection(selectedItem);
    this._getOverflowMenuButton()
      .find('.' + this.m_widget.getItemContentStyleClass())
      .focus();
  };

  HorizontalNavListHandler.prototype.__handleOverflowMenuSelection = function (event, ui) {
    var key = ui.item.data('key');
    var options = {
      selection: key
    };
    var item = this.m_widget.FindElementByKey(key);

    if (!this.m_widget.isTabBar()) {
      var previousKey = this.m_widget.GetOption('selection')[0];
      this.m_widget.FireSelectionAction(event, item, previousKey);
    }

    this.m_widget.HandleSelectionOption(options);
    var selectedItemKey = options.selection;
    if (selectedItemKey) {
      // trigger the optionChange event
      this.m_widget.SetOption('selection', selectedItemKey, {
        _context: {
          originalEvent: event,
          internalSet: true,
          extraData: {
            items: $(item)
          }
        },
        changed: true
      });
    }
  };

  HorizontalNavListHandler.prototype._getItemLabel = function (item) {
    var titleElement = item.find('.' + this.m_widget.getItemTitleStyleClass() + ':first');
    if (titleElement.length > 0) {
      return titleElement.text();
    }
    return item.find('.' + this.m_widget.getItemLabelStyleClass() + ':first').text();
  };

  _HorizontalNavListOverflowHandler.prototype._TEXT_WIDTH_KEY = 'textWidth';
  _HorizontalNavListOverflowHandler.prototype._ITEM_WIDTH_KEY = 'itemWidth';

  _HorizontalNavListOverflowHandler.prototype._getOverflowMenuButton = function () {
    return this._navlistHandler._getOverflowMenuButton();
  };

  _HorizontalNavListOverflowHandler.prototype._getWidget = function () {
    return this._navlistHandler.m_widget;
  };

  _HorizontalNavListOverflowHandler.prototype.shouldHandleOverflow = function () {
    return this._overflow === 'popup' || this._truncation === 'progressive';
  };

  _HorizontalNavListOverflowHandler.prototype.unApplyTruncation = function () {
    var self = this;
    this._items.each(function (index, item) {
      $(item)
        .find('.' + self._getWidget().getItemLabelStyleClass())
        .css('max-width', '');
    });
  };

  _HorizontalNavListOverflowHandler.prototype.checkForOverflow = function () {
    if (!this.shouldHandleOverflow()) {
      return false;
    }

    // Get overflow data together for performance
    if (!this._overflowData) {
      this._overflowData = this._collectOverflowData();
    }
    return this._isOverflowed(this._overflowData.containerEdgePos, this._overflowData.itemEdgePos, 0);
  };

  _HorizontalNavListOverflowHandler.prototype.applyTruncation = function () {
    // apply truncation
    if (this._truncation === 'progressive') {
      this._applyLabelMaxWidth(this._overflowData);
    }
    var item = this._items.last();
    var itemEdge =
      item[0].getBoundingClientRect()[DomUtils.getReadingDirection() === 'ltr' ? 'right' : 'left'];
    return this._isOverflowed(this._overflowData.containerEdgePos, itemEdge, 0);
  };

  _HorizontalNavListOverflowHandler.prototype.getOverflowThreshold = function () {
    var threshold = -1;
    if (this._overflow === 'popup') {
      threshold = this._calculateThreshold(this._overflowData);
    }
    return threshold;
  };

  _HorizontalNavListOverflowHandler.prototype._collectOverflowData = function () {
    var itemNonTextWidth;
    var overflowItemWidth;
    var readingDirection = DomUtils.getReadingDirection();
    var edge = readingDirection === 'ltr' ? 'right' : 'left';
    var container = this._getWidget().ojContext.element;

    var item = this._items.last();
    if (this._truncation === 'progressive') {
      this._calculateItemWidths();
      itemNonTextWidth = this._calculateItemNonTextWidth();
    }

    var edgePosition = container[0].getBoundingClientRect()[edge];
    var containerWidth = container[0].getBoundingClientRect().width;

    if (this._overflow === 'popup') {
      var overFlowMenuButton = this._getOverflowMenuButton()[0];
      var rect = overFlowMenuButton.getBoundingClientRect();
      const overFlowMenuButtonComputedStyle = window.getComputedStyle(overFlowMenuButton);
      let margin = 0;
      // NavigationList overflow icon has a left margin in ltr and right margin in rtl
      // NavigationList overflow "more" item has no margin in any case so this calculated margin= 0px.
      if (!this._navlistHandler._isTabBar() && this._display === 'icons') {
        margin =
          readingDirection === 'ltr'
            ? overFlowMenuButtonComputedStyle.marginLeft
            : overFlowMenuButtonComputedStyle.marginRight;
      }
      // TabBar overflow menu cases (icon and "more" item) has a right margin only in rtl
      if (this._navlistHandler._isTabBar() && readingDirection === 'rtl') {
        margin = overFlowMenuButtonComputedStyle.marginRight;
      }
      overflowItemWidth = rect.width + parseInt(margin, 10);
    }
    // Since this is last item it does not have a margin added to item edge
    var itemEdge = item[0].getBoundingClientRect()[edge];

    return {
      containerEdgePos: edgePosition,
      containerWidth: containerWidth,
      overflowItemWidth: overflowItemWidth,
      itemEdgePos: itemEdge,
      itemNonTextWidth: itemNonTextWidth
    };
  };

  _HorizontalNavListOverflowHandler.prototype._calculateItemWidths = function () {
    var self = this;
    var items = this._items;

    items.each(function (index, item) {
      var $item = $(item);
      var textWidth = $item
        .find('.' + self._getWidget().getItemLabelStyleClass())[0]
        .getBoundingClientRect().width;
      $item.data(self._TEXT_WIDTH_KEY, textWidth);
      $item.data(self._ITEM_WIDTH_KEY, item.getBoundingClientRect().width);
    });
  };

  _HorizontalNavListOverflowHandler.prototype._calculateItemNonTextWidth = function () {
    var items = this._items;
    var self = this;
    if (
      this._getWidget()
        .GetRootElement()
        .find('.' + this._getWidget().getHasIconsStyleClass()).lenght > 0
    ) {
      items = items.filter(function (index, item) {
        return $(item).find('.' + self._getWidget().getItemIconStyleClass()).length > 0;
      });
    }
    var itemsWithRemovable = items.filter(function (index, item) {
      return $(item).find('.' + self._getWidget().getRemovableStyleClass()).length > 0;
    });
    var pickItem =
      itemsWithRemovable && itemsWithRemovable.length > 0 ? itemsWithRemovable.last() : items.last();
    var textWidth = pickItem.data(self._TEXT_WIDTH_KEY);
    return pickItem.data(self._ITEM_WIDTH_KEY) - textWidth;
  };

  _HorizontalNavListOverflowHandler.prototype._isOverflowed = function (
    containerEdge,
    itemEdge,
    overflowItemWidth
  ) {
    var isLtr = DomUtils.getReadingDirection() === 'ltr';
    var _overflowItemWidth = overflowItemWidth || 0;
    if (isLtr) {
      // Even after using edge position, some times there is a fraction of pixel
      // difference which is being considered as overflow, so having 0.1 as buffer.
      return itemEdge - containerEdge + _overflowItemWidth > 0.1;
    }
    return containerEdge - itemEdge + _overflowItemWidth > 0.1;
  };

  _HorizontalNavListOverflowHandler.prototype._calculateThreshold = function (overflowData) {
    var items = this._items;
    var readingDirection = DomUtils.getReadingDirection();
    var edge = readingDirection === 'ltr' ? 'right' : 'left';
    var index = items.length - 1;
    var itemEdge = items[index].getBoundingClientRect()[edge];

    // Need to check for overflow including overflow item to avoid overflow item truncation.
    while (
      this._isOverflowed(overflowData.containerEdgePos, itemEdge, overflowData.overflowItemWidth) &&
      index > 0
    ) {
      index -= 1;
      // NavigationList item icons have a left margin hence for icon-only cases item edge is sufficient
      if (!this._navlistHandler._isTabBar() && this._display === 'icons') {
        itemEdge = items[index].getBoundingClientRect()[edge];
      } else {
        const itemComputedStyle = window.getComputedStyle(items[index]);
        let itemMargin = 0;
        // TabBar has right margin for all items in ltr and rtl mode.
        if (this._navlistHandler._isTabBar() || readingDirection === 'ltr') {
          itemMargin = itemComputedStyle.marginRight;
        } else {
          // Navigationlist non icon-only case items have a right margin (covered by if above) in
          // ltr and left margin in rtl
          itemMargin = itemComputedStyle.marginLeft;
        }
        itemEdge = items[index].getBoundingClientRect()[edge] + parseInt(itemMargin, 10);
      }
    }

    return index + 1;
  };

  _HorizontalNavListOverflowHandler.prototype._applyLabelMaxWidth = function (overflowData) {
    var items = this._items;
    var self = this;
    var minLabelWidth = this._getMinLabelWidth(this._items);
    var labelMaxWidth = overflowData.containerWidth / items.length - overflowData.itemNonTextWidth;

    if (labelMaxWidth < minLabelWidth) {
      labelMaxWidth = minLabelWidth; // use min width when it reaches threshold minimum
      // return; //Restore to original width when maxwidth reaches threshold minimum.
    }
    var surplusWidth = 0;
    var sumOfLongItemsWidth = 0;
    items.each(function (index, item) {
      var $item = $(item);
      var textWidth = $item.data(self._TEXT_WIDTH_KEY);
      if (textWidth < labelMaxWidth) {
        surplusWidth += labelMaxWidth - textWidth;
      } else {
        sumOfLongItemsWidth += textWidth;
      }
    });

    items.each(function (index, item) {
      var $item = $(item);
      var textWidth = $item.data(self._TEXT_WIDTH_KEY);
      var calcWidth = textWidth;
      if (textWidth > labelMaxWidth) {
        calcWidth = labelMaxWidth + (surplusWidth * textWidth) / sumOfLongItemsWidth;
      }
      $(item)
        .find('.' + self._getWidget().getItemLabelStyleClass())
        .css({ 'max-width': calcWidth + 'px' });
    });
  };

  _HorizontalNavListOverflowHandler.prototype._getMinLabelWidth = function (items) {
    var computedMinWidth = window
      .getComputedStyle(items.first().find('.' + this._getWidget().getItemLabelStyleClass())[0], null)
      .getPropertyValue('min-width');
    if (computedMinWidth.indexOf('px') > 0) {
      return parseInt(computedMinWidth.substring(0, computedMinWidth.length - 2), 10);
    }
    // This should never happen unless it was overriden intentionally
    return 0;
  };

  const _OJ_FOCUS_ANCESTOR = 'oj-focus-ancestor';
  const _ARIA_HIDDEN$1 = 'aria-hidden';
  const _ARIA_DESCRIBEDBY = 'aria-describedby';
  const _ARIA_LABELLEDBY = 'aria-labelledby';
  const _ARIA_EXPANDED = 'aria-expanded';
  const _OJ_NAV_HIER_BUTTON = 'oj-navigationlist-hierarchical-button';
  const _OJ_NAV_HIER_MENU = 'oj-navigationlist-hierarchical-menu';
  const _OJ_NAV_PREV_LINK = 'oj-navigationlist-previous-link';

  /**
   * Handler for Sliding Navigation List
   * @constructor
   * @extends CollapsibleNavListHandler
   * @ignore
   */
  const SlidingNavListHandler = function (widget, root, component) {
    SlidingNavListHandler.superclass.constructor.call(this, widget, root, component);
    // this keeps a stack of expanded items in top to bottom order
    this.m_expanded = [];
  };

  // Subclass from oj.Object
  oj.Object.createSubclass(
    SlidingNavListHandler,
    CollapsibleNavListHandler,
    'oj.SlidingNavListHandler'
  );

  oj._registerLegacyNamespaceProp('SlidingNavListHandler', SlidingNavListHandler);

  SlidingNavListHandler.prototype.Destroy = function () {
    this.m_root
      .removeClass('oj-navigationlist-slider')
      .removeClass(this.m_widget.getNavListVerticalStyleClass());
    this._toolbar.remove();
  };
  /**
   * Intiate Expand/collapse animation.
   *
   * @param {Object} item, item which is going to be expanded.
   * @param {boolean} isMovingNext true for expand animation and false for collapse animation.
   * @param {Object} focusableElement, focusable element after animation.
   * @param {Event} event the event that triggers sliding.  Note that event could be null in the case where this is programmatically done by the widget
   * @param {Function} animationResolve the resolve function that resolves the animation Promise
   */
  SlidingNavListHandler.prototype._slideAnimation = function (
    item,
    isMovingNext,
    focusableElement,
    event,
    animationResolve
  ) {
    var self = this;
    var listRoot = this.m_widget.getListContainer();
    var hasFocusAncestor = listRoot.hasClass(_OJ_FOCUS_ANCESTOR);

    // After loading child items, listview tries to move focus to first visible
    // element, if there is no active element set. So, temporarily removing focus ancestor and
    // setting focus to first element after animation. This will avoid jittering in animation.
    if (hasFocusAncestor && isMovingNext) {
      listRoot.removeClass(_OJ_FOCUS_ANCESTOR);
    }

    var action = isMovingNext ? 'sliderExpand' : 'sliderCollapse';
    var promise = this.m_widget.StartAnimation(
      /** @type {Element} */ (listRoot.get(0)),
      action,
      this.m_widget.getAnimationEffect(action)
    );
    promise.then(function () {
      self._slideAnimationComplete(item, isMovingNext, focusableElement, event, hasFocusAncestor);
      animationResolve(null);
    });
  };

  /**
   * Update ui after animation.
   *
   * @param {Object} item, item which is going to be expanded.
   * @param {boolean} isMovingNext true for expand animation and false for collapse animation
   * @param {Object|null} focusableElement, focusable element after animation.
   * @param {Event} event the event that triggers sliding.  Note that event could be null in the case where this is programmatically done by the widget
   * @param {boolean} needFocusAncestor, true if oj-focus-ancestor needs to be added after slide animation.
   * @private
   */
  SlidingNavListHandler.prototype._slideAnimationComplete = function (
    item,
    isMovingNext,
    focusableElement,
    event,
    needFocusAncestor
  ) {
    if (this.m_widget.m_contentHandler === null) {
      return;
    }

    if (focusableElement) {
      if (needFocusAncestor) {
        this.m_widget.getListContainer().addClass(_OJ_FOCUS_ANCESTOR); // during animation oj-focus-ancestor is being removed due triggering of focusout event. probably this is due to hiding of element user clicked on.
      }
      if (event && event.button === 0) {
        this.m_widget.AvoidFocusHighLight(true);
      }
      if (focusableElement.length > 0) {
        this.m_widget.SetCurrentItem(focusableElement, event);
      }
      this.m_widget.AvoidFocusHighLight(false);
    }
    if (!isMovingNext) {
      this.m_widget.AnimateCollapseComplete(item.children('.' + this.m_widget.getGroupStyleClass()));
    } else {
      this.m_widget.AnimateExpandComplete(item.children('.' + this.m_widget.getGroupStyleClass()));
    }
  };

  /**
   * Expand item in sliding navigation list
   * @param {Object} groupItem group item to be expanded
   * @param {boolean} animate flag to trigger animation or not
   * @param {Event} event the event that triggers expand.  Note that event could be null in the case where this is programmatically done by the widget
   * @return {Promise} A Promise that resolves when expand animation completes
   * @private
   */
  SlidingNavListHandler.prototype.Expand = function (groupItem, animate, event) {
    var animationResolve;
    var animationPromise = new Promise(function (resolve) {
      animationResolve = resolve;
    });

    var target = $(groupItem).parents('.oj-navigationlist-item-element:first');
    var sublist = target.children('.' + this.m_widget.getGroupStyleClass());
    var nextFocusableItem = null;

    var currentListRoot = target.closest('.' + this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS);
    if (currentListRoot.length > 0) {
      // Move marker style class to expanded node only when it is child of an already expanded node.
      // It is possible that child is expanded before parent, in which we need should not remove marker class from child.
      // Ref , During initialization, listview expands child before parent which is causing the issue.
      currentListRoot.removeClass(this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS);
      target.addClass(this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS);
      nextFocusableItem = sublist.find('.' + this.m_widget.getItemElementStyleClass() + ':eq(0)');
      this._updateHMenuOnExpand(target);
    }

    if (animate) {
      this._slideAnimation(target, true, nextFocusableItem, event, animationResolve);
    } else {
      this._slideAnimationComplete(target, true, nextFocusableItem, event, false);
      animationResolve(null);
    }

    // For ios, it is needed to set aria-hidden.
    target.siblings().attr(_ARIA_HIDDEN$1, 'true'); // @HTMLUpdateOK
    target
      .children('.' + this.m_widget.getGroupItemStyleClass())
      .children('.' + this.m_widget.getItemContentStyleClass())
      .attr(_ARIA_HIDDEN$1, 'true'); // @HTMLUpdateOK
    sublist.removeAttr(_ARIA_HIDDEN$1);

    // undo any display set by ListView
    groupItem.css('display', '');
    // Skip focus for group element
    target.addClass('oj-skipfocus');

    return animationPromise;
  };

  SlidingNavListHandler.prototype._updateHMenuOnExpand = function (target) {
    var listOfParents = target.parentsUntil(
      this.m_widget.element,
      '.' + this.m_widget.getItemElementStyleClass()
    );
    listOfParents = listOfParents.get().reverse(); // get list of parent nodes from top to bottom order
    listOfParents = $(listOfParents.concat(target));

    // clear the hierarchical menu items
    this.m_expanded = [];
    this._emptyHviewMenu();

    listOfParents.each(
      function (i, parentItem) {
        var parentLabel;
        if (i === 0) {
          // Use root label for the first item
          parentLabel = this.m_widget.getRootLabel();
        } else {
          parentLabel = this.m_widget.getItemLabel(this.m_expanded[i - 1]);
        }
        var itemNode = $(parentItem);
        this._addItemToHviewMenu(
          this.m_widget.GetKey(itemNode[0]),
          this.m_widget.getItemLabel(itemNode),
          parentLabel
        );
        this.m_expanded.push(itemNode);
      }.bind(this)
    );
  };

  /**
   * Collapse item in sliding navigation list
   * @param {Object} target target list root
   * @param {Object} key the key of the group item
   * @param {boolean} animate flag to trigger animation or not
   * @param {Event} event the event that triggers collapse.  Note that event could be null in the case where this is programmatically done by the widget
   * @return {Promise} A Promise that resolves when collapse animation completes
   * @private
   */
  SlidingNavListHandler.prototype.Collapse = function (target, key, animate, event) {
    var animationResolve;
    var animationPromise = new Promise(function (resolve) {
      animationResolve = resolve;
    });

    var currentList = target.children('.' + this.m_widget.getGroupStyleClass());
    var parentlist = target.parent();

    target
      .children('.' + this.m_widget.getGroupItemStyleClass())
      .children('.' + this.m_widget.getItemContentStyleClass())
      .removeAttr(_ARIA_HIDDEN$1);
    currentList.attr(_ARIA_HIDDEN$1, 'true'); // @HTMLUpdateOK
    target.siblings().removeAttr(_ARIA_HIDDEN$1);

    // Enable focus for group element
    target.removeClass('oj-skipfocus');

    target.removeClass(this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS);
    // While collapsing node, if any of parent is already having current style class then don't add again
    if (target.closest('.' + this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS).length === 0) {
      parentlist
        .closest('.' + this.m_widget.getItemElementStyleClass())
        .addClass(this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS);
      if (this.m_widget.element.is(parentlist)) {
        this.m_widget.element.addClass(this.m_widget.SLIDING_NAVLIST_CURRENT_STYLE_CLASS);
      }
    }

    if (animate) {
      this._slideAnimation(target, false, currentList.parent(), event, animationResolve);
    } else {
      this._slideAnimationComplete(target, false, currentList.parent(), event, false);
      animationResolve(null);
    }

    this._updateHMenuOnCollapse(key);

    return animationPromise;
  };

  SlidingNavListHandler.prototype._updateHMenuOnCollapse = function (key) {
    var collapsingItemIndex = -1;
    this.m_expanded.forEach(
      function (item, index) {
        var itemKey = this.m_widget.GetKey(item[0]);
        if (key === itemKey) {
          collapsingItemIndex = index;
        }
      }.bind(this)
    );
    // Remove all items under/after the collapsing item
    if (collapsingItemIndex > -1) {
      this.m_expanded.splice(collapsingItemIndex);
    }

    this._removeItemFromHviewMenu(key);
  };

  SlidingNavListHandler.prototype.UpdateAriaPropertiesOnSelectedItem = function (elem, highlight) {
    if (highlight) {
      elem.attr(_ARIA_DESCRIBEDBY, this._selectedLabelId); // @HTMLUpdateOK
    } else {
      elem.removeAttr(_ARIA_DESCRIBEDBY);
    }
  };
  /**
   * Determines whether the specified item is expanded
   * @param {jQuery} item the item element
   * @return {number} 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
   * @private
   */
  SlidingNavListHandler.prototype.GetState = function (item) {
    var expanded = this.m_widget.getFocusItem(item).attr(_ARIA_EXPANDED);
    if (expanded === 'true') {
      return this.m_widget.STATE_EXPANDED;
    }

    if (expanded === 'false') {
      return this.m_widget.STATE_COLLAPSED;
    }
    return this.m_widget.STATE_NONE;
  };
  /**
   * Sets the disclosed state of the item
   * @param {jQuery} item the item element
   * @param {number} state 0 if item is expanded, 1 if item is collapsed, 2 if item cannot be expand or collapse.
   * @private
   */
  SlidingNavListHandler.prototype.SetState = function (item, state) {
    if (state === this.m_widget.STATE_EXPANDED) {
      this.m_widget.getFocusItem(item).attr(_ARIA_EXPANDED, 'true'); // @HTMLUpdateOK
      item
        .removeClass(this.m_widget.COLLAPSED_STYLE_CLASS)
        .addClass(this.m_widget.EXPANDED_STYLE_CLASS);
    } else if (state === this.m_widget.STATE_COLLAPSED) {
      this.m_widget.getFocusItem(item).attr(_ARIA_EXPANDED, 'false'); // @HTMLUpdateOK
      item
        .removeClass(this.m_widget.EXPANDED_STYLE_CLASS)
        .addClass(this.m_widget.COLLAPSED_STYLE_CLASS);
    }
  };

  SlidingNavListHandler.prototype.ModifyListItem = function ($item, itemContent) {
    var focusableElement = this.m_widget.getFocusItem($item);
    $item.attr('role', 'presentation');
    focusableElement.attr('role', 'menuitem');
    if (!itemContent.attr('id')) {
      itemContent.uniqueId();
    }
    // JET:34729 remove aria-selected from menuitem elements, invalid tag for role menu
    focusableElement.removeAttr('aria-selected');

    // Ensure that it collapses all nodes.
    var groupItems = $item.children('.' + this.m_widget.getGroupStyleClass());
    if (groupItems.length > 0) {
      focusableElement.attr('aria-haspopup', 'true');
      groupItems.attr('role', 'menu');
      groupItems.css('display', '');
      $item.removeAttr(_ARIA_EXPANDED);
      focusableElement.attr(_ARIA_EXPANDED, 'false'); // @HTMLUpdateOK
    }
  };

  SlidingNavListHandler.prototype.BeforeRenderComplete = function () {
    this.m_root.attr('role', 'group');
    this.m_widget.element.attr('role', 'menu');
    this.m_widget.element.attr(_ARIA_LABELLEDBY, this._headerLabel.attr('id')); // @HTMLUpdateOK
  };

  SlidingNavListHandler.prototype.Init = function (opts) {
    this.m_root
      .addClass('oj-navigationlist-slider')
      .addClass(this.m_widget.getNavListVerticalStyleClass());
    opts.element.addClass('oj-navigationlist-current');
    this._buildSlidingNavListHeader(opts);
    this._initializeHierarchicalView();
  };

  SlidingNavListHandler.prototype.HandleClick = function (event) {
    if (
      $(event.target).closest('.oj-navigationlist-previous-link, .oj-navigationlist-previous-button')
        .length > 0
    ) {
      this.CollapseCurrentList(event);
    }
  };

  SlidingNavListHandler.prototype.IsSelectable = function (item) {
    // Slider items don't have Aria-selected tag, overrding selction for slider navlist

    var itemSelectionMarkerAttr = 'aria-selected';
    return (
      this.m_widget.getFocusItem($(item))[0].getAttribute('role') === 'menuitem' &&
      !this.m_widget.getFocusItem($(item))[0].hasAttribute(itemSelectionMarkerAttr)
    );
  };

  SlidingNavListHandler.prototype.HandleKeydown = function (event) {
    if (
      $(event.target).closest('.oj-navigationlist-previous-link, .oj-navigationlist-previous-button')
        .length > 0
    ) {
      if (event.keyCode === $.ui.keyCode.ENTER) {
        this.CollapseCurrentList(event);
      }
    }

    if ($(event.target).closest('.' + this.m_widget.GetStyleClass()).length > 0) {
      // check for default prevented as it might have already processed for quiting f2 mode
      if (event.keyCode === $.ui.keyCode.ESCAPE && !event.isDefaultPrevented()) {
        this.CollapseCurrentList(event);
      }
    }
  };
  /**
   * Initialize sliding navigation list header .
   * @private
   * @memberof! ojNavigationList
   */
  SlidingNavListHandler.prototype._buildSlidingNavListHeader = function (opts) {
    this._toolbar = $(document.createElement('div'));
    this._toolbar.addClass('oj-navigationlist-toolbar');
    this._previousLink = $(document.createElement('a'));
    this._prevButton = $(document.createElement('a'));
    this._prevButton.addClass('oj-navigationlist-previous-button');
    this._prevButton.css('visibility', 'hidden').attr('tabindex', '-1'); // @HTMLUpdateOK
    this._previousLink.addClass(_OJ_NAV_PREV_LINK).attr('tabindex', '-1'); // @HTMLUpdateOK
    this._headerLabel = $(document.createElement('label'));
    this._headerLabel.uniqueId();
    this._headerLabel.addClass('oj-navigationlist-current-header').text(this.m_widget.getRootLabel());
    this._vSeparator = $(document.createElement('span'));
    this._vSeparator
      .attr('role', 'separator') // @HTMLUpdateOK
      .attr('aria-orientation', 'vertical') // @HTMLUpdateOK
      .addClass('oj-navigationlist-toolbar-separator');
    this._hviewBtn = $(document.createElement('button'));
    this._hviewBtn.addClass(_OJ_NAV_HIER_BUTTON).attr('tabindex', '-1'); // @HTMLUpdateOK
    this._hviewMenu = $(document.createElement('ul'));
    this._hviewMenu.addClass(_OJ_NAV_HIER_MENU).hide();
    var selectedLabel = $(document.createElement('label'));
    selectedLabel.uniqueId().addClass('oj-helper-hidden-accessible').attr(_ARIA_HIDDEN$1, 'true'); // @HTMLUpdateOK
    this._selectedLabelId = selectedLabel.attr('id');
    selectedLabel.text(this.m_component.getTranslatedString('selectedLabel'));
    this._previousLink.append(this._headerLabel); // @HTMLUpdateOK
    this._toolbar.append(this._prevButton); // @HTMLUpdateOK
    this._toolbar
      .append(this._previousLink) // @HTMLUpdateOK
      .append(this._vSeparator) // @HTMLUpdateOK
      .append(this._hviewBtn) // @HTMLUpdateOK
      .append(this._hviewMenu) // @HTMLUpdateOK
      .append(selectedLabel); // @HTMLUpdateOK
    this.m_root.prepend(this._toolbar); // @HTMLUpdateOK
    this._showOrHideHierarchyMenu(opts.hierarchyMenuDisplayThresholdLevel);
  };

  /**
   * Collapses the current visible list if it is not the top level list
   * @private
   */
  SlidingNavListHandler.prototype.CollapseCurrentList = function (event) {
    // pop the expanded item stack
    var current = this.m_expanded[this.m_expanded.length - 1];
    if (current) {
      this.m_widget.CollapseItem(current, event, true, null, true, true);
    }
  };

  /**
   * Initialize hierarchical view for sliding navlist.
   * @private
   * @memberof! ojNavigationList
   */
  SlidingNavListHandler.prototype._initializeHierarchicalView = function () {
    var self = this;
    var menuid = this._hviewMenu.uniqueId().attr('id');
    this._hviewMenu.ojMenu({
      openOptions: {
        position: {
          my: 'end top',
          at: 'end bottom'
        }
      },
      select: function (event, ui) {
        var itemsToRemove = ui.item.nextAll();
        var expandedItems = self.m_expanded;
        var targetItemKey = ui.item.data('key');

        self.m_widget.signalTaskStart(); // signal method task start
        // collapse all child lists untill target list is visible
        while (expandedItems.length > 0) {
          var item = expandedItems[expandedItems.length - 1]; // remove item from list
          var currentKey = self.m_widget.GetKey(item[0]);
          self.m_widget.CollapseItem($(item), event, true, currentKey, true, true);
          if (self.m_widget.compareValues(targetItemKey, currentKey)) {
            break;
          }
        }
        itemsToRemove.remove();
        ui.item.remove();
        self._hviewMenu.ojMenu('refresh');
        self.m_widget.signalTaskEnd(); // signal method task end
      }
    });
    this._hviewBtn.ojButton({
      label: this.m_component.getTranslatedString('hierMenuBtnLabel'),
      display: 'icons',
      icons: {
        start: 'oj-fwk-icon oj-hier-icon'
      },
      menu: '#' + menuid,
      disabled: true,
      chroming: 'half'
    });
    this._prevButton.ojButton({
      label: this.m_component.getTranslatedString('previousIcon'),
      display: 'icons',
      icons: {
        start: 'oj-navigationlist-previous-icon oj-component-icon oj-clickable-icon-nocontext'
      },
      chroming: 'half'
    });
  };

  /**
   * Empty hierarchical menu items.
   * @private
   */
  SlidingNavListHandler.prototype._emptyHviewMenu = function () {
    if (this._hviewMenu) {
      var menuItems = this._hviewMenu.find('li');
      menuItems.remove();
    }
  };

  /**
   * Add current visible group item to hierarchical menu and update header text with new list's label.
   * @param {string} itemKey key of the group item whose list will be displayed
   * @param {string} label current list's label
   * @param {string} parentLabel parent list's label
   * @private
   */
  SlidingNavListHandler.prototype._addItemToHviewMenu = function (itemKey, label, parentLabel) {
    var i;
    if (this._hviewBtn) {
      var itemsinTree = this._hviewMenu.find('li').length;
      var menuListItem = $(document.createElement('li'));
      var menuItem = $(document.createElement('a'));
      menuItem.attr('href', '#'); // @HTMLUpdateOK
      menuListItem.append(menuItem); // @HTMLUpdateOK
      if (itemsinTree > 0) {
        for (i = 0; i < itemsinTree; i++) {
          if (i > 0) {
            // prettier-ignore
            menuItem.append( // @HTMLUpdateOK
              $(document.createElement('span')).addClass('oj-navigationlist-hvitem-space')
            );
          }
        }
        // prettier-ignore
        menuItem.append( // @HTMLUpdateOK
          $(document.createElement('span')).addClass(
            'oj-menu-item-icon oj-icon oj-navigationlist-level-indicator'
          )
        );
      }
      var menuItemLabel = $(document.createElement('span')).addClass(
        'oj-navigationlist-hierarchical-menu-label'
      );
      menuItemLabel.text(parentLabel);
      menuItem.append(menuItemLabel); // @HTMLUpdateOK

      // Store item key reference to refresh the list when user clicks on  hiearchical menu item.
      menuListItem.data('key', itemKey);
      this._hviewMenu.append(menuListItem); // @HTMLUpdateOK

      this._hviewMenu.ojMenu('refresh');
      this._showOrHideHierarchyMenu(this.m_widget.GetOption('hierarchyMenuDisplayThresholdLevel'));
      this._hviewBtn.ojButton('option', 'disabled', false);
      this._prevButton.css('visibility', 'visible');
      if (this.m_widget.getListContainer().hasClass(_OJ_FOCUS_ANCESTOR)) {
        this._prevButton.attr('tabindex', '0'); // @HTMLUpdateOK
      }
      this._headerLabel.text(label);
    }
  };

  SlidingNavListHandler.prototype.SetOptions = function (options) {
    if (options.hierarchyMenuDisplayThresholdLevel === undefined) {
      return;
    }

    var currentHMenuDisplayThreshold = this.m_widget.GetOption('hierarchyMenuDisplayThresholdLevel');
    if (currentHMenuDisplayThreshold !== options.hierarchyMenuDisplayThresholdLevel) {
      this._showOrHideHierarchyMenu(options.hierarchyMenuDisplayThresholdLevel);
    }
  };

  SlidingNavListHandler.prototype._showOrHideHierarchyMenu = function (
    hierarchyMenuDisplayThresholdLevel
  ) {
    var itemsinTree = this._hviewMenu.find('li').length;
    if (
      hierarchyMenuDisplayThresholdLevel === -1 ||
      itemsinTree < hierarchyMenuDisplayThresholdLevel
    ) {
      this._vSeparator.css('visibility', 'hidden');
      if (this._hviewBtn[0] === document.activeElement) {
        // is(:focus) failing during test cases so using document.activeElement.
        // tried by moving focus to <ul> using  this.m_widget.focus() but listview listen for focusin event.
        this.m_root.focusin();
      }
      this._hviewBtn.css('visibility', 'hidden');
    } else if (itemsinTree >= hierarchyMenuDisplayThresholdLevel) {
      this._vSeparator.css('visibility', 'visible');
      this._hviewBtn.css('visibility', 'visible');
    }
  };

  /**
   * Removes parent item of current list from hierarchical menu
   * otherwise return the emptyText set in the options
   * @private
   */
  SlidingNavListHandler.prototype._removeItemFromHviewMenu = function (key) {
    if (this._hviewBtn) {
      var menuItems = this._hviewMenu.find('li');
      var removeAfter;
      var restoreLabel;
      menuItems.each(function (index, item) {
        var $item = $(item);
        if ($item.data('key') === key) {
          $item.remove();
          restoreLabel = $item.children('a').text();
          removeAfter = true;
        } else if (removeAfter) {
          $item.remove();
        }
      });
      this._hviewMenu.ojMenu('refresh');
      this._showOrHideHierarchyMenu(this.m_widget.GetOption('hierarchyMenuDisplayThresholdLevel'));
      if (this._hviewMenu.children('li').length === 0) {
        this._hviewBtn.ojButton('option', 'disabled', true);
        this._prevButton.css('visibility', 'hidden');
        this._prevButton.attr('tabindex', '-1'); // @HTMLUpdateOK
        this._headerLabel.text(this.m_widget.getRootLabel());
      } else {
        this._headerLabel.text(restoreLabel);
      }
    }
  };

  // eslint-disable-next-line no-unused-vars
  SlidingNavListHandler.prototype.RestoreItem = function (item, itemContent, sublist) {
    itemContent
      .removeAttr('role')
      .removeAttr(_ARIA_EXPANDED)
      .removeAttr(_ARIA_DESCRIBEDBY)
      .removeAttr(_ARIA_HIDDEN$1);
  };

  SlidingNavListHandler.prototype._makeToolbarItemsFocusable = function (enable) {
    if (enable) {
      var itemsinTree = this._hviewMenu.find('li').length;
      if (itemsinTree) {
        this._prevButton.attr('tabindex', '0');
      }
      this._hviewBtn.attr('tabindex', '0');
    } else {
      this._prevButton.attr('tabindex', '-1');
      this._hviewBtn.attr('tabindex', '-1');
    }
  };

  /**
   * Handler for focus event
   * @param {Event} event the focus event
   * @protected
   * @override
   */
  SlidingNavListHandler.prototype.HandleFocus = function (event) {
    // If focus is on navlist or items but not on toolbar
    if (
      !(
        $.contains(this._toolbar.get(0), /** @type {Element} */ (event.target)) ||
        this._hviewMenu.get(0) === /** @type {Element} */ (event.relatedTarget)
      )
    ) {
      // make toolbar items focusable
      this._makeToolbarItemsFocusable(true);
      _ojNavigationListView.superclass.HandleFocus.apply(this.m_widget, arguments);
    }
  };

  /**
   * Handler for blur event
   * @param {Event} event the blur event
   * @protected
   * @override
   */
  SlidingNavListHandler.prototype.HandleBlur = function (event) {
    // If focus going to toolbar remove focus ancestor and unhighlight the active one
    if (
      $.contains(this._toolbar.get(0), /** @type {Element} */ (event.relatedTarget)) ||
      this._hviewMenu.get(0) === /** @type {Element} */ (event.relatedTarget)
    ) {
      this.m_widget.UnhighlightActive();
    } else {
      // if focus moves out side navlist make toolbar items not focusable
      if (
        event.relatedTarget == null ||
        !$.contains(this.m_root.get(0), /** @type {Element} */ (event.relatedTarget))
      ) {
        this._makeToolbarItemsFocusable(false);
      }
      _ojNavigationListView.superclass.HandleBlur.apply(this.m_widget, arguments);
    }
  };

  SlidingNavListHandler.prototype.GetNodeBySubId = function (locator) {
    if (locator.subId === _OJ_NAV_PREV_LINK) {
      return this._prevButton ? this._prevButton[0] : null;
    }

    if (locator.subId === _OJ_NAV_HIER_BUTTON) {
      return this._hviewBtn ? this._hviewBtn[0] : null;
    }

    if (locator.subId === _OJ_NAV_HIER_MENU) {
      return this._hviewMenu ? this._hviewMenu[0] : null;
    }

    return null;
  };

  SlidingNavListHandler.prototype.GetSubIdByNode = function (node) {
    if ($(node).closest(this._prevButton).length > 0) {
      return {
        subId: _OJ_NAV_PREV_LINK
      };
    }

    if ($(node).closest(this._hviewBtn).length > 0) {
      return {
        subId: _OJ_NAV_HIER_BUTTON
      };
    }

    if ($(node).closest(this._hviewMenu).length > 0) {
      return {
        subId: _OJ_NAV_HIER_MENU
      };
    }

    return null;
  };

});


define('ojs/ojavatar',['exports', 'preact/jsx-runtime', 'ojs/ojvcomponent', 'ojs/ojthemeutils', 'preact'], function (exports, jsxRuntime, ojvcomponent, ThemeUtils, preact) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.Avatar = class Avatar extends preact.Component {
        render(props) {
            return (jsxRuntime.jsxs("div", { class: this._getClasses(props), "aria-hidden": "true", children: [this._getInnerContent(props), this._getSecondaryInnerContent(props)] }));
        }
        _getClasses(props) {
            const shape = props.shape ??
                ThemeUtils.getCachedCSSVarValues(['--oj-private-avatar-global-shape-default'])[0];
            let classes = `oj-avatar oj-avatar-bg-${props.background} oj-avatar-${props.size} ${shape === 'circle' ? 'oj-avatar-circle' : 'oj-avatar-square'}`;
            if (props.iconClass || !props.src) {
                classes += ' oj-avatar-no-image';
                if (props.initials) {
                    classes += ' oj-avatar-has-initials';
                }
            }
            else {
                classes += ' oj-avatar-image';
            }
            return classes;
        }
        _getInnerContent(props) {
            if (props.src && !props.iconClass) {
                return (jsxRuntime.jsx("div", { class: "oj-avatar-background-image", style: { backgroundImage: `url("${props.src}")` } }));
            }
            else {
                return jsxRuntime.jsx("div", { class: "oj-avatar-background oj-avatar-background-image" });
            }
        }
        _getSecondaryInnerContent(props) {
            if (props.iconClass) {
                return jsxRuntime.jsx("div", { class: `oj-avatar-icon ${props.iconClass}` });
            }
            else if (props.src) {
                return;
            }
            else if (props.initials) {
                return jsxRuntime.jsx("div", { class: "oj-avatar-initials oj-avatar-background-image", children: props.initials });
            }
            else {
                return jsxRuntime.jsx("div", { class: "oj-avatar-background-image oj-avatar-placeholder-icon" });
            }
        }
    };
    exports.Avatar.defaultProps = {
        background: 'neutral',
        initials: null,
        size: 'md',
        src: null,
        iconClass: ''
    };
    exports.Avatar._metadata = { "properties": { "background": { "type": "string", "enumValues": ["blue", "gray", "green", "orange", "pink", "purple", "red", "teal", "neutral", "slate", "mauve", "lilac", "forest"] }, "initials": { "type": "string" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg", "2xs", "xxs", "xs", "xl", "2xl", "xxl"] }, "src": { "type": "string" }, "iconClass": { "type": "string" }, "shape": { "type": "string", "enumValues": ["square", "circle"] } } };
    exports.Avatar = __decorate([
        ojvcomponent.customElement('oj-avatar')
    ], exports.Avatar);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojswitcher',['ojs/ojcomponentcore', 'ojs/ojcustomelement', 'ojs/ojcustomelement-utils', 'ojs/ojcore-base'], function (Components, ojcustomelement, ojcustomelementUtils, oj) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  /**
   * @ojcomponent oj.ojSwitcher
   * @ojsignature {
   *                target: "Type",
   *                value: "class ojSwitcher extends JetElement<ojSwitcherSettableProperties>"
   *               }
   * @since 4.0.0
   *
   * @ojshortdesc A switcher dynamically decides which child element should be made visible.
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["value"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-switcher'
   *
   * @classdesc The switcher element dynamically decides which child element should be made visible. It will make a child element visible only if its <code class="prettyprint">slot</code> attribute's value matches with switcher's <code class="prettyprint">value</code> property.
   * <p> If child content is expensive to render, use <a href="oj.ojDefer.html">oj-defer</a> to defer rendering until child element is made visible.
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-switcher value="[[selectedValue]]">
   *  &lt;div slot="home">...&lt;div>
   *  &lt;div slot="about">...&lt;div>
   *  &lt;div slot="settings">...&lt;div>
   *  ...
   * &lt;/oj-switcher>
   * </code></pre>
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   * @expose
   * @memberof oj.ojSwitcher
   * @instance
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */
  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   *
   * @expose
   * @memberof oj.ojSwitcher
   * @instance
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */
  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof oj.ojSwitcher
   * @instance
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */
  /**
   * Refreshes the visual state of the component.
   *
   * @function refresh
   * @return {void}
   * @expose
   * @memberof oj.ojSwitcher
   * @instance
   */

  /**
   * @member
   * @name value
   * @memberof oj.ojSwitcher
   * @instance
   * @type {string}
   * @default ""
   * @ojshortdesc Specifies the value for this switcher.
   * @ojeventgroup common
   * @ojdynamicslot
   *
   * @desc <code class="prettyprint">value</code> of the switcher. Setting <code class="prettyprint">value</code> will make all child elements with matching <code class="prettyprint">slot</code> attribute as visible and hides elements which are not matching.
   * @example <caption>Initialize the Switcher with the <code class="prettyprint">value</code> attribute specified:</caption>
   *  &lt;oj-switcher value='settings'> ... &lt;/oj-switcher>
   * @example <caption>Read value property:</caption>
   * var selectedValue = mySwitcher.value;
   * @example <caption>Change value property:</caption>
   * mySwitcher.value = 'settings';
   */

  /**
   * @constructor
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  const ojSwitcher = function (context) {
    var ATTR_SWITCHER_SLOT = 'slot';
    var SWITCHER_VALUE_ATTR = 'value';
    var SWITCHER_ORIG_DISPLAY_STYLE = '_ojSwitcher_orig_display_style';
    var self = this;
    var element = context.element;
    var isInitialRender = true;
    var _slotMap = null;

    // Our version of GCC has a bug where the second param of MutationObserver.observe must be of
    // type MutationObserverInit which isn't a real class that we can instantiate. Work around is to
    // create the MutationObserver on an alias of 'this' and call observe in a different function.
    // TODO Cleanup when we replace GCC with uglify in 5.0.0.
    self._caseElementMutationObserver = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.type === 'childList') {
          if (mutation.addedNodes) {
            // For each newly added child node, apply the switcher value
            Array.prototype.forEach.call(mutation.addedNodes, function (item) {
              if (item.nodeType === 1) {
                var itemSlotAttributeValue = item.getAttribute(ATTR_SWITCHER_SLOT);
                _applyValueToItem(item, itemSlotAttributeValue);
                // force to re calculate slot map nex time
                _resetSlotMap();
              }
            });
          }
          if (mutation.removedNodes) {
            // For each removed child node restore original display style property
            Array.prototype.forEach.call(mutation.removedNodes, function (item) {
              if (item.nodeType === 1) {
                if (item[SWITCHER_ORIG_DISPLAY_STYLE] !== undefined) {
                  // eslint-disable-next-line no-param-reassign
                  item.style.display = item[SWITCHER_ORIG_DISPLAY_STYLE];
                }
                // force to re calculate slot map nex time
                _resetSlotMap();
              }
            });
          }
        }
      });
    });

    function _resetSlotMap() {
      _slotMap = null;
    }

    function _getSlotMap() {
      if (!_slotMap) {
        _slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(element);
      }
      return _slotMap;
    }

    function _hide(item) {
      var isCurrentlyVisible = !(item.style.display === 'none');
      if (isCurrentlyVisible) {
        // eslint-disable-next-line no-param-reassign
        item.style.display = 'none';
        Components.subtreeHidden(item);
      }
    }

    function _show(item) {
      var isCurrentlyVisible = !(item.style.display === 'none');
      if (!isCurrentlyVisible) {
        // eslint-disable-next-line no-param-reassign
        item.style.display = '';
        Components.subtreeShown(item, isInitialRender ? { initialRender: true } : undefined);
      } else if (isInitialRender) {
        Components.subtreeShown(item, { initialRender: true });
      }
    }

    this.createDOM = function () {
      self._caseElementMutationObserver.observe(element, { childList: true });
    };

    this.updateDOM = function () {
      var slots = _getSlotMap();
      var keys = Object.keys(slots);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var slot = slots[key];
        for (var j = 0; j < slot.length; j++) {
          var item = slot[j];
          _applyValueToItem(item, key);
        }
      }
      if (isInitialRender) {
        isInitialRender = false;
      }
    };

    function _applyValueToItem(item, itemSlotAttributeValue) {
      var switcherValue = element[SWITCHER_VALUE_ATTR];
      if (item[SWITCHER_ORIG_DISPLAY_STYLE] === undefined) {
        Object.defineProperty(item, SWITCHER_ORIG_DISPLAY_STYLE, { value: item.style.display });
      }
      if (itemSlotAttributeValue === switcherValue) {
        _show(item);
      } else {
        _hide(item);
      }
    }
  };

  (function () {
var __oj_switcher_metadata = 
{
  "properties": {
    "value": {
      "type": "string",
      "value": ""
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_switcher_metadata.extension._CONSTRUCTOR = ojSwitcher;
    __oj_switcher_metadata.extension._CONTROLS_SUBTREE_HIDDEN = true;
    oj.CustomElementBridge.register('oj-switcher', { metadata: __oj_switcher_metadata });
  })();

});


define('ojs/ojmessage',['require', 'exports', 'ojs/ojcore', 'ojs/ojknockout', 'ojs/ojbutton', 'ojs/ojjquery-hammer', 'ojs/ojcore-base', 'jquery', 'knockout', 'ojs/ojanimation', 'ojs/ojdomutils', 'ojs/ojcomponentcore', 'ojs/ojcomposite', 'ojs/ojcontext', 'hammerjs', 'ojs/ojlogger', 'ojs/ojthemeutils', 'ojs/ojtranslation'], function (require, exports, ojcore, ojknockout, ojbutton, ojjqueryHammer, oj, $, ko, AnimationUtils, DomUtils, Components, Composite, Context, Hammer, Logger, ThemeUtils, Translations) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = {};
      if (e) {
        Object.keys(e).forEach(function (k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        });
      }
      n['default'] = e;
      return n;
    }
  }

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  const ojMessage = {};

  /**
   * @ojcomponent oj.ojMessage
   * @since 5.0.0
   * @ojdeprecated [
   *   {
   *     type: "maintenance",
   *     since: "17.0.0"
   *   }
   * ]
   * @ojdisplayname Message
   * @ojshortdesc A message conveys categorized information to the user, often regarding errors.
   *
   * @ojsignature {target: "Type", value:"class ojMessage extends JetElement<ojMessageSettableProperties>"}
   *
   * @ojoracleicon 'oj-ux-ico-message'
   * @ojuxspecs ['messages']
   *
   * @classdesc
   * <h3 id="messageOverview-section">
   *   JET Message
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#messageOverview-section"></a>
   * </h3>
   * <p>Description:</p>
   * <p>Displays a message. All <code class="prettyprint">oj-message</code> elements in a page must
   * have an <code class="prettyprint">oj-messages</code> element as its parent.</p>
   *
   * <pre class="prettyprint">
   * <code>&lt;oj-message id="simpleMessage" message="[[messageData]]">
   * &lt;/oj-message>
   * </code></pre>
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>The {@link oj.ojMessage#message.sound} property is an accessibility feature for playing a
   * sound when a message is opened. This property defaults to "none", and can be enabled by setting
   * it to "defaults" or by providing URL to an audio file of a format that the browser supports. An
   * accessible application must provide a way for users to enable sound on a settings or preferences
   * page. Some browsers will have auto-play disabled by default, enabling it may require adjusting
   * the browser settings.</p>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Message</td>
   *       <td><kbd>Swipe Right, Swipe Up</kbd></td>
   *       <td>Close the message</td>
   *     </tr>
   *     <tr>
   *       <td>Message Close Icon</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Close the message</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc.
   * @memberof oj.ojMessage
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Message</td>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Close the message</td>
   *     </tr>
   *     <tr>
   *       <td>Message Close Icon</td>
   *       <td><kbd>Enter or Space</kbd></td>
   *       <td>Close the message</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc.
   * @memberof oj.ojMessage
   */

  // Attributes
  // ///////////

  /**
   * <p>Structured data specifying essential information to display a message on the UI.
   * @member
   * @name message
   * @memberof! oj.ojMessage
   * @instance
   * @since 5.0.0
   * @type {Object}
   * @ojsignature { target: "Type",
   *                value: "oj.ojMessage.Message",
   *                jsdocOverride: true}
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message</code> attribute:</caption>
   * &lt;!-- Binding message attribute to a structured object -->
   * &lt;oj-message message="[[myMessageData]]">&lt;/oj-message>
   *
   * &lt;!-- Setting message using JSON notation -->
   * &lt;oj-message message='{"severity": "error", "summary": "Some summary", "detail": "Some detail"}'>&lt;/oj-message>
   *
   * &lt;!-- Setting the message sub-attributes -->
   * &lt;oj-message message.severity="error" message.summary="Some summary" message.detail="Some detail">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message</code> property after initialization:</caption>
   * // getter
   * var message = myMessage.message;
   *
   * // setter - sets all sub-properties (missing sub-properties are defaulted)
   * myMessage.message = {
   *     severity: "error",
   *     summary: "Some summary",
   *     detail: "Some detail"
   * };
   */

  /**
   *<p>Specifies the URL for the custom image to be used as an icon representing the message.</p>
   * <p>The icon will be rendered as background image inside a container that is set to size of 16px*16px
   * in alta-web theme and 10px*20px for all other themes, therefore, the icon chosen must fit this
   * dimensions.</p>
   * <p>If this attribute is not specified, a suitable icon corresponding to value of
   * <code class="prettyprint">message.severity</code> will be rendered.</p>
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message.icon</code> attribute:</caption>
   * &lt;oj-message message.icon="images/emailIcon.png" message.summary="Some summary">&lt;/oj-messages>
   *
   * @example <caption>Get or set the <code class="prettyprint">icon</code> property after initialization:</caption>
   * // getter
   * var icon = myMessage.getPropoerty("message.icon");
   *
   * // setter
   * myMessage.setProperty("message.icon", "images/emailIcon.png");
   *
   * @expose
   * @type {string}
   * @name message.icon
   * @ojshortdesc Specifies the URL for the custom image to be used as an icon representing the message. See the Help documentation for more information.
   * @default ""
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   *<p>Specifies text representing the message category which is shown next to the message icon</p>
   * <p>If this attribute is not specified, a translated text corresponding to value of
   * <code class="prettyprint">message.severity</code> attribute will be rendered.</p>
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message.category</code> attribute:</caption>
   * &lt;oj-message message.category="Service Request" message.summary="New SR - Escalated">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message.category</code> property after initialization:</caption>
   * // getter
   * var category = myMessage.getProperty("message.category");
   *
   * // setter
   * myMessage.setProperty("message.category", "Service Request");
   *
   * @expose
   * @type {string}
   * @name message.category
   * @ojshortdesc Specifies message category text which is shown next to the message icon. See the Help documentation for more information.
   * @default ""
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   *<p>Specifies the severity of message.</p>
   *
   *@example <caption>Initialize the element with <code class="prettyprint">message.severity</code> attribute:</caption>
   * &lt;oj-message message.severity="error" message.summary="Some summary">&lt;/oj-message>
   *
   *@example <caption>Get or set the <code class="prettyprint">message.severity</code> property after initialization:</caption>
   * // getter
   * var severity = myMessage.getProperty("message.severity");
   *
   * // setter
   * myMessage.setProperty("message.severity", "error");
   *
   * @expose
   * @type {string}
   * @name message.severity
   * @ojvalue {string} "error" Error level message.
   * @ojvalue {string} "warning" Warning level message.
   * @ojvalue {string} "confirmation" Confirmation message.
   * @ojvalue {string} "info" Informational message.
   * @ojvalue {string} "none" Message status level not applicable.
   * @default "none"
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   *<p>Specifies timestamp for the message to be displayed in the message header. </p>
   *<p> timestamp could represent the date and time at which the message was created, or otherwise
   *could pertain to the event for which the message was created. For example, a timestamp for an
   *upcoming meeting could be set in the future, whereas a timestamp for a missed message could be set
   *in the past.</p>
   *<p> This specified value must be an ISOString. A default converter is used to convert and format
   *the value suitable for displaying in the message. This default convertor used such will be an
   *implementation detail and could change in future.</p>
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message.timestamp</code>
   * attribute:</caption>
   * &lt;oj-message message.summary="Some summary" message.timestamp="2018-03-09T13:10:47+14:00">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message.timestamp</code> property
   * after initialization:</caption>
   * // getter
   * var timestamp = myMessage.getProperty("message.timestamp");
   *
   * // setter
   * myMessage.setProperty("message.timestamp", "2018-03-09T13:10:47+14:00");
   *
   * @expose
   * @type {string}
   * @name message.timestamp
   * @ojshortdesc Specifies a timestamp for the message to be displayed in the message header. See the Help documentation for more information.
   * @default ""
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   *<p>Specifies summary text for the message.
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message.summary</code> attribute:</caption>
   * &lt;oj-message message.summary="Some summary">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message.summary</code> property after initialization:</caption>
   * // getter
   * var summary = myMessage.getProperty("message.summary");
   *
   * // setter
   * myMessage.setProperty("message.summary", "Some summary");
   *
   * @expose
   * @type {string}
   * @name message.summary
   * @default ""
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   *<p>Specifies detail text for the message.</p>
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message.detail</code> attribute:</caption>
   * &lt;oj-message message.detail="Some detail" message.summary="Some summary">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message.detail</code> property after initialization:</caption>
   * // getter
   * var detail = myMessage.getProperty("message.detail");
   *
   * // setter
   * myMessage.setProperty("message.detail", "Some detail");
   *
   * @expose
   * @type {string}
   * @name message.detail
   * @default ""
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   * <p>Specifies the number of milliseconds for which duration the message will be shown before it is
   * closed automatically.</p>
   * <p>This attribute can take the number of millisecond or special number values -1 and 0. If the
   * value is set to "-1", auto-close will be turned off. If the value is set to "0", application wide
   * value for autoTimeout as specified in a theming variable will be used.
   *
   * @example <caption>Initialize the element with
   * <code class="prettyprint">message.auto-timeout</code> attribute:</caption>
   * &lt;oj-message message.auto-timeout="3000" message.summary="Some summary">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message.autoTimeout</code>
   * property after initialization:</caption>
   * // getter
   * var autoTimeout = myMessage.getProperty("message.autoTimeout");
   *
   * // setter
   * myMessage.message.autoTimeout = 3000;
   *
   * @expose
   * @type {number}
   * @name message.autoTimeout
   * @ojshortdesc Specifies the duration in milliseconds that the message will be shown before it closes automatically. See the Help documentation for more information.
   * @default -1
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   *
   * @example <caption>The default auto-timeout value can be set at application level using this
   *          theme variable (SCSS) :</caption>
   * $messageAutoTimeoutOptionDefault: 5000 !default;
   */

  /**
   *<p>Specifies the UI affordance provided to end users to be able to close the message.</p>
   * @example <caption>Initialize the element with
   * <code class="prettyprint">message.close-affordance</code> attribute:</caption>
   * &lt;oj-message message.close-affordance="none" message.summary="Some summary">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">message.closeAffordance</code>
   * property after initialization:</caption>
   * // getter
   * var closeAffordance = myMessage.getProperty("message.closeAffordance");
   *
   * // setter
   * myMessage.setProperty("message.closeAffordance", "none");
   *
   * @example <caption>Close icon is displayed when close-affordance is set to 'defaults'. This can
   *          be changed at application level using this theme variable (SCSS) :</caption>
   * $messageCloseIconDisplay: none !default;
   *
   * @example <caption>Close icon is not displayed when close-affordance is set to 'defaults', if
   *          the message is set to auto timeout when using mobile themes. This can be changed at
   *          application level using this theme variable (SCSS) :</caption>
   * $messageAutoTimeoutCloseIconDisplay: block !default;
   *
   * @ojshortdesc Specifies the UI affordance provided to end users to be able to close the message. See the Help documentation for more information.
   *
   * @expose
   * @type {string}
   * @name message.closeAffordance
   * @ojvalue {string} "none" No UI affordance is provided to close the message. Application has to
   * call the close() method to dismiss the message.
   * @ojvalue {string} "defaults" Use implicit affordance to best suit the native theme, efficient use
   * of available space, and screen touch capabilities.<br><br>A close 'X' icon is displayed in all cases
   * except in the case when the message is set to auto-timeout when using mobile themes. The display
   * of the close icon can be further controlled by using the theme variables as noted below. See
   * keyboard and touch end user information sections in this document for interaction options.
   * @default "defaults"
   * @instance
   * @access public
   * @memberof! oj.ojMessage
   * @since 5.0.0
   */

  /**
   * <p>Specifies the sound to be played when a message is opened. Sound is an accessibility feature
   * required for low vision users who view a zoomed section of the UI. Because messages may be shown
   * outside of the zoomed section, such users require sound to be played to notify of new messages.</p>
   *
   * <p>This attribute can take a URL of the audio file for the custom sound to be played. The
   * supported formats are mp3, wav and ogg. Browser support should also be considered while choosing
   * the format of the audio file. Literal string values
   * <code class="prettyprint">"defaults"</code> and <code class="prettyprint">"none"</code> can also
   * be used for this attribute. If the value is set to "none", then the sound will be disabled. If
   * the value is set to "defaults", then a default sound is played.<p>
   *
   * <p>The default sound uses Web Audio APIs, which is not yet supported by some browsers, default
   * sound will not be played in such browsers. Sound will not be played in browsers where auto play
   * is not enabled. Some of the browsers do not allow auto play, while other browsers may provide a
   * user preference to enable it.</p>
   *
   *
   * @example <caption>Initialize the element with <code class="prettyprint">message.sound</code> attribute:</caption>
   * &lt;!-- Use an URL -->
   * &lt;oj-message message.sound="resources/audio/newEmail.wav" message.summary="Some summary">&lt;/oj-message>
   *
   * &lt;!-- Use defaults -->
   * &lt;oj-message message.sound="defaults" message.summary="Some summary">&lt;/oj-message>
   *
   * &lt;!-- Turn off sound -->
   * &lt;oj-message message.sound="none" message.summary="Some summary">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">sound</code> property after initialization:</caption>
   * // getter
   * var sound = myMessage.getProperty("message.sound");
   *
   * // setter
   * myMessage.setProperty("message.sound", "resources/audio/newEmail.wav");
   *
   * @expose
   * @type {string}
   * @name message.sound
   * @ojshortdesc Specifies the sound to be played when a message is opened. This is needed for accessibility. See the Help documentation for more information.
   * @default "none"
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   * <p>Specifies the display options for contents of the message.
   *
   * @expose
   * @member
   * @name displayOptions
   * @memberof! oj.ojMessage
   * @instance
   * @since 6.1.0
   * @type {Object}
   * @ojsignature { target: "Type",
   *                value: "oj.ojMessage.DisplayOptions",
   *                jsdocOverride: true}
   *
   * @example <caption>Initialize the element with <code class="prettyprint">display-options</code>
   * attribute:</caption>
   * &lt;!-- Binding display-options attribute to a structured object -->
   * &lt;oj-message display-options="[[myMessageDisplayOptions]]">&lt;/oj-message>
   *
   * &lt;!-- Setting display-options using JSON notation -->
   * &lt;oj-message display-options='{"category": "none"}' message.summary="Some summary" message.detail="Some detail">&lt;/oj-message>
   *
   * &lt;!-- Setting the display-options sub-attributes -->
   * &lt;oj-message display-options.category="none" message.summary="Some summary" message.detail="Some detail">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">displayOptions</code> property after initialization:</caption>
   * // getter
   * var displayOptions = myMessage.displayOptions;
   *
   * // setter
   * myMessage.displayOptions = {
   *     category: "none"
   * };
   */

  /**
   *<p>Specifies display option for {@link oj.ojMessage#message.category} text in this message.</p>
   * <p>In Redwood theme, showing the category text is an anti-pattern. Set this attribute to "none".</p>
   *
   * @example <caption>Initialize the element with <code class="prettyprint">display-options.category</code> attribute:</caption>
   * &lt;oj-message display-options.category="none" message.summary="Some summary" message.detail="Some detail">&lt;/oj-message>
   *
   * @example <caption>Get or set the <code class="prettyprint">displayOptions.category</code> property after initialization:</caption>
   * // getter
   * var categoryOption = myMessage.getProperty("displayOptions.category");
   *
   * // setter
   * myMessage.setProperty("displayOptions.category", "none");
   *
   * @expose
   * @type {string}
   * @name displayOptions.category
   * @ojshortdesc Specifies the display option for message category text in this message.
   *
   * @ojvalue {string} "header" If the {@link oj.ojMessage#message.category} property is specified,
   *  its value will be displayed in the header region of the message next to message icon. If
   *  {@link oj.ojMessage#message.category} property is not specified, a translated text corresponding
   *  to the value of the {@link oj.ojMessage#message.severity} property will be displayed.
   * @ojvalue {string} "auto" The component decides whether and where the
   *  {@link oj.ojMessage#message.category} text is displayed. The behavior is same as 'header'
   *  option, but may change in future releases.
   * @ojvalue {string} "none" The {@link oj.ojMessage#message.category} text will not be displayed.
   * @default "auto"
   * @instance
   * @access public
   * @memberof! oj.ojMessage
   */

  /**
   * <p>A collection of translated resources from the translation bundle, or
   * <code class="prettyprint">null</code> if this component has no resources. Resources may be
   * accessed and overridden individually or collectively, as seen in the examples.
   *
   * <p>If this component has translations, their documentation immediately follows this doc entry.
   *
   * @member
   * @name translations
   * @ojshortdesc A collection of translated resources from the translation bundle, or null if this component has no resources.
   * @memberof! oj.ojMessage
   * @instance
   * @ojtranslatable
   * @since 5.0.0
   * @type {Object}
   *
   * @example <caption>Initialize the element, overriding some translated resources and leaving the
   * others intact:</caption>
   * &lt;!-- Using dot notation -->
   * &lt;oj-some-element translations.some-key='Some value' translations.some-other-key='Some other value'>&lt;/oj-some-element>
   *
   * &lt;!-- Using JSON notation -->
   * &lt;oj-some-element translations='{"someKey":"Some value", "someOtherKey":"Some other value"}'>&lt;/oj-some-element>
   *
   * @example <caption>Get or set the <code class="prettyprint">translations</code> property after
   * initialization:</caption>
   * // Get one
   * var value = myComponent.getProperty("translations.someKey");
   *
   * // Set one, leaving the others intact. Always use the setProperty API for
   * // subproperties rather than setting a subproperty directly.
   * myComponent.setProperty('translations.someKey', 'some value');
   *
   * // Get all
   * var values = myComponent.translations;
   *
   * // Set all.  Must list every resource key, as those not listed are lost.
   * myComponent.translations = {
   *     someKey: 'some value',
   *     someOtherKey: 'some other value'
   * };
   *
   */

  // Slots
  // //////

  /**
   * <p>The <code class="prettyprint">detail</code> slot is for the message's detail area.
   * The <code class="prettyprint">&lt;oj-message></code> element accepts DOM nodes as children
   * with the detail slot. This slot is useful to add links or buttons to the detail area. The
   * default template will just display the text value of 'message.detail' property for any message.
   *
   *
   * @ojslot detail
   * @ojshortdesc The detail slot accepts DOM nodes as children. It is useful for adding links or buttons to the message's detail area.
   * @ojmaxitems 1
   * @memberof oj.ojMessage
   * @since 6.2.0
   *
   * @example <caption>Initialize the message with detail content:</caption>
   * &lt;oj-message>
   *   &lt;div slot="detail">Message detail.
   *     &lt;a href="#">Click here for more info...&lt;/a>
   *   &lt;/div>
   * &lt;/oj-message>
   */

  // Events
  // ///////

  /**
   * Triggered after the message is closed through user interaction or due to calling
   * <code class="prettyprint">close()</code> method.
   *
   * @expose
   * @event
   * @name close
   * @memberof oj.ojMessage
   * @instance
   * @since 5.0.0
   * @ojcancelable
   * @ojbubbles
   * @property {Object} message The message that was closed.
   * @ojsignature {target:"Type", value:"oj.ojMessage.Message", for:"message", jsdocOverride: true}
   */

  // Currently animate events is public API, however we do NOT want applications to use this API.
  // It is being removed in near future. Excluding it from JSDoc since v7.0.0 using @ignore hence.
  /**
   * Triggered when the default animation is about to start for the open or close actions of the message.
   * The default animation can be cancelled by calling
   * <code class="prettyprint">event.preventDefault</code>.
   * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
   *
   * @ignore
   * @event
   * @memberof oj.ojMessage
   * @name animateStart
   * @ojshortdesc Triggered when the default animation is about to start for the open or close actions of the message. See the Help documentation for more information.
   * @instance
   * @since 5.0.0
   * @ojcancelable
   * @ojbubbles
   * @property {!Element} element Target of animation.
   * @property {"open"|"close"} action The action that triggers the animation.<br><br>
   *            Suggested values are:
   *                    <ul>
   *                      <li>"open" - when a message is opened.</li>
   *                      <li>"close" - when a message is closed.</li>
   *                    </ul>
   * @property {!function():void} endCallback If the event listener calls
   *            event.preventDefault to cancel the default animation, it must call the
   *            endCallback function when it finishes its own animation handling and any
   *            custom animation has ended.
   *
   * @example <caption>Add a listener for the
   *          <code class="prettyprint">ojAnimateStart</code> event to override the default
   *          "close" animation:</caption>
   * myMessage.addEventListener("ojAnimateStart", function(event) {
   *   // verify that the component firing the event is a component of interest and action is close
   *   if (event.detail.action == "close") {
   *     event.preventDefault();
   *     oj.AnimationUtils.slideOut(event.detail.element, {"persist":  "all"}).then(event.detail.endCallback);
   *   }
   * });
   *
   * @example <caption>The default open and close animations are controlled via the theme
   *          (SCSS) :</caption>
   * // Applies for both 'inline' and 'overlay' messages
   * $messageGeneralOverlayOpenAnimation: ((effect: "zoomIn"), "fadeIn")  !default;
   * $messageGeneralOverlayCloseAnimation: ((effect: "zoomOut", persist: "all"), "fadeOut")  !default;
   * // Applies for 'notification' messages
   * $messageNotificationOverlayOpenAnimation: ((effect: "zoomIn"), "fadeIn")  !default;
   * $messageNotificationOverlayCloseAnimation: ((effect: "zoomOut", persist: "all"), "fadeOut")  !default;
   */

  // Currently animate events is public API, however we do NOT want applications to use this API.
  // It is being removed in near future. Excluding it from JSDoc since v7.0.0 using @ignore hence.
  /**
   * Triggered when the default animation is about to end for the open or close actions of the message.
   * The default animation can be cancelled by calling
   * <code class="prettyprint">event.preventDefault</code>.
   * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
   *
   * @ignore
   * @event
   * @memberof oj.ojMessage
   * @name animateEnd
   * @ojshortdesc Triggered when the default animation is about to end for the open or close actions of the message.
   * @instance
   * @since 5.0.0
   * @ojcancelable
   * @ojbubbles
   *
   * @property {!Element} element Target of animation.
   * @property {"open"|"close"} action The action that triggered the animation.<br><br>
   *            The number of actions can vary from component to component.
   *            Suggested values are:
   *                    <ul>
   *                      <li>"open" - when a message is opened.</li>
   *                      <li>"close" - when a message is closed.</li>
   *                    </ul>
   *
   * @example <caption>Add a listener for the
   *          <code class="prettyprint">ojAnimateEnd</code> event to listen for the "close"
   *          ending animation:</caption>
   * myMessage.addEventListener("ojAnimateEnd", function(event) {
   *   // verify that the component firing the event is a component of interest and action is close
   *   if (event.detail.action == "close") {}
   * });
   *
   * @example <caption>The default open and close animations are controlled via the theme
   *          (SCSS) :</caption>
   * // Applies for both 'inline' and 'overlay' messages
   * $messageGeneralOverlayOpenAnimation: (effect: "zoomIn", fade: true)  !default;
   * $messageGeneralOverlayCloseAnimation: (effect: "zoomOut", fade: true)  !default;
   * // Applies for 'notification' messages
   * $messageNotificationOverlayOpenAnimation: (effect: "zoomIn", fade: true)  !default;
   * $messageNotificationOverlayCloseAnimation: (effect: "zoomOut", fade: true)  !default;
   */

  // Methods
  // ////////

  /**
   * Closes the message.
   *
   * @expose
   * @function close
   * @memberof! oj.ojMessage
   * @instance
   * @since 5.0.0
   * @return {void}
   * @fires oj.ojMessage#ojClose
   *
   *
   * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
   * myMessage.close();
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @expose
   * @return {void}
   * @memberof! oj.ojMessage
   * @instance
   * @since 5.0.0
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */

  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   * @expose
   * @memberof! oj.ojMessage
   * @instance
   * @since 5.0.0
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */

  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof! oj.ojMessage
   * @instance
   * @since 5.0.0
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   */

  // Type Defs
  // //////////

  /**
   * @typedef {Object} oj.ojMessage.Message
   * @property {string} [icon] Defines the icon representing the message.
   * @property {string} [category] Defines category text of the message.
   * @property {"error"|"warning"|"confirmation"|"info"|"none"} [severity] Defines severity of the message.
   * @property {string} [timestamp] Defines timestamp of the message.
   * @property {string} [summary] Defines summary text of the message.
   * @property {string} [detail] Defines detail text of the message.
   * @property {number} [autoTimeout] Defines the time after which the message is to be closed automatically.
   * @property {"none"|"defaults"} [closeAffordance] Defines UI affordance provided to close the message.
   * @property {string} [sound] Defines the sound to be played when message is open.
   */

  /**
   * @typedef {Object} oj.ojMessage.DisplayOptions
   * @property {"header"|"none"|"auto"} [category] Defines display option for the category text in the
   *  message.
   */

  var _MESSAGE_VIEW =
    '<div :id="[[containerId]]" :class="[[computedMessageContainerSelectors]]" on-keydown="[[handleKeydown]]">' +
    '  <div class="oj-message-header">' +
    '    <div class="oj-message-leading-header" :title="[[computedCategory]]">' +
    '      <oj-bind-if test="[[computedIconStyle]]">' +
    '        <div class="oj-component-icon oj-message-status-icon oj-message-custom-icon" ' +
    '         role="presentation" :title="[[computedCategory]]" ' +
    '         :style.background="[[computedIconStyle]]">' +
    '        </div>' +
    '      </oj-bind-if>' +
    '      <oj-bind-if test="[[computedIconClass]]">' +
    '        <div role="presentation" :title="[[computedCategory]]" :class="[[computedIconClass]]">' +
    '        </div>' +
    '      </oj-bind-if>' +
    '      <oj-bind-if test="[[computedCategory]]">' +
    '        <div class="oj-message-category oj-message-title" tabindex="-1">' +
    '          <h1 :title="[[computedCategory]]">' +
    '            <oj-bind-text value="[[computedCategory]]"></oj-bind-text> ' +
    '          </h1>' +
    '        </div>' +
    '      </oj-bind-if>' +
    '      <oj-bind-if test="[[!computedCategory() && computedSummary()]]">' +
    '        <div class="oj-message-summary oj-message-title" tabindex="-1">' +
    '          <oj-bind-text value="[[computedSummary]]"></oj-bind-text>' +
    '        </div>' +
    '      </oj-bind-if>' +
    '    </div>' +
    '    <div class="oj-message-trailing-header">' +
    '      <oj-bind-if test="[[formattedTimestamp]]">' +
    '        <div class="oj-message-timestamp">' +
    '          <oj-bind-text value="[[formattedTimestamp]]"></oj-bind-text> ' +
    '        </div>' +
    '      </oj-bind-if>' +
    '      <oj-bind-if test="[[hasCloseAffordance]]">' +
    '        <div :class="[[computedMessageCloseSelectors]]">' +
    '          <oj-button class="oj-button-sm" display="icons" chroming="borderless" on-click="[[handleCloseIcon]]">' +
    '            <span slot="startIcon" class="oj-fwk-icon oj-fwk-icon-cross"></span>' +
    '            <span>' +
    '              <oj-bind-text value="[[computedLabelCloseIcon]]"></oj-bind-text>' +
    '            </span>' +
    '          </oj-button>' +
    '        </div>' +
    '      </oj-bind-if>' +
    '    </div>  ' +
    '  </div>' +
    '  <div class="oj-message-body">' +
    '    <oj-bind-if test="[[computedCategory]]">' +
    '      <div class="oj-message-summary">' +
    '        <oj-bind-text value="[[computedSummary]]"></oj-bind-text>' +
    '      </div>' +
    '    </oj-bind-if>' +
    '    <div class="oj-message-detail">' +
    '      <oj-bind-slot name="detail">' +
    '        <oj-bind-text value="[[computedDetail]]"></oj-bind-text>' +
    '      </oj-bind-slot>' +
    '    </div>' +
    '  <div>' +
    '</div>';

  function MessageViewModel(context) {
    this._composite = context.element;

    // anything used by the view bindings can't be obfuscated and is why it's defined in quotes.
    this.containerId = [context.unique, 'mc'].join('_');
    this._messagesContainerId = this.containerId;
    this.handleCloseIcon = this._handleCloseIcon.bind(this);
    this.close = this._closeMessage.bind(this);
    this.bindingsApplied = this._bindingsApplied.bind(this);
    this.disconnected = this._disconnected.bind(this);
    this.connected = this._connected.bind(this);
    this.propertyChanged = this._propertyChanged.bind(this);
    this.messageCreatedTime = new Date().toLocaleTimeString([], {
      hour: '2-digit',
      minute: '2-digit'
    });
    this.handleKeydown = this._handleKeydown.bind(this);

    // Store a reference to the slotCounts which will be later used to determine if message detail is present
    this._slotCounts = context.slotCounts;

    // Store a reference to the properties for any later use
    this._properties = context.properties;
    this._createObservables();

    // Update the severity class on the root element. Since this is the initial
    // render no need to check/remove any severity style classes as they would not
    // exist.
    // This method relies on the observables, so call this method after the observables
    // are updated and represent the current severity.
    this._updateSeverityStyleClass(null);
  }

  // eslint-disable-next-line no-unused-vars
  MessageViewModel.prototype._connected = function (element) {
    // reattached when open (not pending open or close animation), check to see if we need to
    // reschedule the auto close timeout
    var mediator = this._operationMediator;
    if (mediator && mediator.getPendingOperation() === 'none' && this._isMessageOpen()) {
      this._scheduleAutoClose();
    }
  };

  // eslint-disable-next-line no-unused-vars
  MessageViewModel.prototype._disconnected = function (element) {
    // Node disconnected and open (not pending open or close operations), clear the auto close timeout
    // since it might not be reattached.
    var mediator = this._operationMediator;
    if (mediator && mediator.getPendingOperation() === 'none') {
      this._clearAutoClose();
    }
  };

  // eslint-disable-next-line no-unused-vars
  MessageViewModel.prototype._bindingsApplied = function (context) {
    this._openMessage();
  };

  MessageViewModel.prototype._propertyChanged = function (detail) {
    function subPropertyChanged(_detail, topPropName, subPropName) {
      if (_detail.updatedFrom === 'external' && _detail.property === topPropName) {
        var subproperty = _detail.subproperty;
        if (subproperty) {
          // set a subproperty via attribute or setProperty("message.xxxx", value)
          var path = [topPropName, subPropName].join('.');
          return path === subproperty.path;
        }

        // set the entire message object
        var previousValue = _detail.previousValue[subPropName];
        var value = _detail.value[subPropName];
        return value !== previousValue;
      }

      return false;
    }

    // workaround for 

    if (subPropertyChanged(detail, 'message', 'autoTimeout')) {
      this.computedMessageCloseSelectors(this._computeMessageCloseSelectors());
      this._clearAutoClose();
      this._scheduleAutoClose();
    }

    if (subPropertyChanged(detail, 'message', 'closeAffordance')) {
      this.hasCloseAffordance(this._computeCloseAffordance() === 'defaults');
      this._unregisterSwipeHandler();
      this._registerSwipeHandler();
    }

    if (subPropertyChanged(detail, 'message', 'icon')) {
      this.computedIconStyle(this._computeIconStyle());
      this.computedIconClass(this._computeIconClass());
      this.computedMessageContainerSelectors(this._computeMessageContainerSelectors());
    }

    if (
      subPropertyChanged(detail, 'message', 'category') ||
      subPropertyChanged(detail, 'displayOptions', 'category')
    ) {
      this.computedCategory(this._computeCategory());
      this.computedMessageContainerSelectors(this._computeMessageContainerSelectors());
    }

    // category if unspecified and iconclass are derived from severity, recompute those
    if (subPropertyChanged(detail, 'message', 'severity')) {
      // get the previous severity from the observable before updating it
      const previousSeverity = this.computedSeverity();

      this.computedSeverity(this._computeSeverity());
      this.computedCategory(this._computeCategory());
      this.computedIconClass(this._computeIconClass());
      this.computedMessageContainerSelectors(this._computeMessageContainerSelectors());

      // Update the severity style classes on the root element.
      // This method relies on the observables, so call this method after the observables
      // are updated and represent the current severity.
      this._updateSeverityStyleClass(previousSeverity);
    }

    if (subPropertyChanged(detail, 'message', 'timestamp')) {
      this.formattedTimestamp(this._formatTimestamp());
    }

    if (subPropertyChanged(detail, 'message', 'summary')) {
      this.computedSummary(this._computeSummary());
    }

    if (subPropertyChanged(detail, 'message', 'detail')) {
      this.computedDetail(this._computeDetail());
      this.computedMessageContainerSelectors(this._computeMessageContainerSelectors());
    }

    if (subPropertyChanged(detail, 'translations', 'labelCloseIcon')) {
      this.computedLabelCloseIcon(this._computeLabelCloseIcon());
    }

    if (subPropertyChanged(detail, 'translations', 'categories')) {
      this.computedCategory(this._computeCategory());
    }
  };

  MessageViewModel.prototype._registerSwipeHandler = function () {
    if (DomUtils.isTouchSupported() && this._computeCloseAffordance() === 'defaults') {
      var messageContainerElement = $(document.getElementById(this._messagesContainerId));
      var options = {
        recognizers: [[Hammer.Swipe, { direction: Hammer.DIRECTION_ALL }]],
        cssProps: {
          // By default Hammer disables user selection when registering swipe events
          // this is for improving the user interaction in touch based desktops. But, we
          // need to override this behavior, as users should be able to copy the message
          // text.
          userSelect: 'auto'
        }
      };

      var swipeDirections =
        DomUtils.getReadingDirection() === 'rtl' ? 'swipeleft swipeup' : 'swiperight swipeup';
      this._hammerSwipe = messageContainerElement.ojHammer(options).on(
        swipeDirections,
        function (event) {
          event.preventDefault();
          // JET-33259 - research the ability to select text in message component while on a touch enabled desktop
          // In touch enabled desktops, close the message only if the gesture is made using touch action. Do nothing
          // if the gesture is made using mouse action. This would allow users to select text without dismissing the
          // message.
          if (event.gesture && event.gesture.pointerType !== 'mouse') {
            this._closeMessage();
          }
        }.bind(this)
      );
    }
  };

  MessageViewModel.prototype._unregisterSwipeHandler = function () {
    if (DomUtils.isTouchSupported() && this._hammerSwipe) {
      var swipeDirections =
        DomUtils.getReadingDirection() === 'rtl' ? 'swipeleft swipeup' : 'swiperight swipeup';
      this._hammerSwipe.off(swipeDirections);
      delete this._hammerSwipe;
    }
  };

  MessageViewModel.prototype._scheduleAutoClose = function () {
    // Schedule auto-close if applicable
    if (this._computeAutoTimeout() > -1) {
      // prettier-ignore
      this._autoCloseTimer = window.setTimeout( // @HTMLUpdateOK
        this._closeMessage.bind(this),
        this._computeAutoTimeout()
      );
    }
  };

  MessageViewModel.prototype._clearAutoClose = function () {
    if (!isNaN(this._autoCloseTimer)) {
      window.clearTimeout(this._autoCloseTimer);
      delete this._autoCloseTimer;
    }
  };

  MessageViewModel.prototype._isMessageOpen = function () {
    var messageContainerElement = document.getElementById(this._messagesContainerId);
    return !!(messageContainerElement && $(messageContainerElement).is(':visible'));
  };

  MessageViewModel.prototype._closeMessage = function (event) {
    var messageContainerElement = document.getElementById(this._messagesContainerId);

    // Possible that the oj-message element may be disconnected/removed while close is in progress,
    //  guard against this case where messageContainerElement is removed
    if (messageContainerElement) {
      // unregister the swipe handler
      this._unregisterSwipeHandler();
      this._clearAutoClose();
      var mediator = this._operationMediator;

      // When messages are inlined, the parent oj-messages takes care of open animation, but close
      //  animation is taken care here by the component. Since we did not do the open animation no
      //  mediator was used
      if (mediator) {
        // if we are pending the open operation, the close will be invoked after the open is done
        if (mediator.isOperationPending('close', this._closeMessage.bind(this, event))) {
          return;
        }
        mediator.destroy();
      }

      this._operationMediator = new OperationMediator(this._composite, 'close');

      var action = 'close';
      var options = this._getAnimateOptionDefaults(action);
      // eslint-disable-next-line no-undef
      AnimationUtils.startAnimation(messageContainerElement, action, options, this._composite).then(
        function () {
          // We will just hide the message container, but not discard it, the ojClose listener
          // could discard it if needed.
          $(messageContainerElement).hide();
          Components.subtreeHidden(messageContainerElement);

          var eventParams = {
            bubbles: true,
            cancelable: false,
            detail: {
              message: this._properties.message
            }
          };

          var closeEvent = new CustomEvent('ojClose', eventParams);
          if (event) {
            Object.defineProperty(closeEvent, '_originalEvent', { value: event, writable: false });
          }

          this._composite.dispatchEvent(closeEvent);
        }.bind(this)
      );
    }
  };

  MessageViewModel.prototype._computeSeverity = function () {
    var message = this._properties.message;

    if (oj.StringUtils.isEmptyOrUndefined(message.severity)) {
      return MessageViewModel._getMessageDefault('severity');
    }

    // oj.Message has 'fatal' severity which is no different from 'error', oj-message does not support
    //  'fatal' for this reason. Map 'fatal' to 'error' just to be compatible with cases where the
    //  message stream could come from existing oj.Message sources.
    return message.severity === 'fatal' ? 'error' : message.severity;
  };

  MessageViewModel.prototype._formatTimestamp = function () {
    var message = this._properties.message;

    if (!oj.StringUtils.isEmptyOrUndefined(message.timestamp)) {
      // loading library could be long running op. Set a busy state.
      var busyContext = Context.getContext(this._composite).getBusyContext();
      var options = {
        description: 'oj-message is busy loading required libraries and processing timestamp'
      };
      var resolve = busyContext.addBusyState(options);

      // Our NLS rules restrict that the numerals in the date string should be in latin digits
      //  regardless of the locale/language. The standard JS Date/DateTimeFormat global objects in
      //  its toLocaleString/toLocaleTimeString/format methods always translates the numerals also
      //  into respective languages (eg. ar-EG), without providing an option. Hence we need to use our
      //  default converter that deals with our NLS requirements already. However, the validation
      //  module is significantly huge, having static dependency on them increases our core module
      //  size, so optimizing performance by loading it dynamically and asynchronously only when
      //  timestamp is defined.
      var converterPromise = this._getConverterPromise(message.timestamp);

      converterPromise.then(
        function (converter) {
          try {
            var formattedTimestamp = converter.format(message.timestamp);

            // fine to update the observable directly with resolved value, it will also be updated
            //  in propertyChanged() if timestamp was to change
            this.formattedTimestamp(formattedTimestamp);
          } catch (e) {
            // expect oj.ConverterError if supplied value is not valid
            Logger.info(`JET oj-message: Invalid value for message.timestamp: ${message.timestamp}`);
          } finally {
            resolve();
          }
        }.bind(this)
      );
    }

    return undefined;
  };

  MessageViewModel.prototype._getConverterPromise = function (timestamp) {
    const dateTimeConverterLoadPromise = new Promise(function (resolve, reject) { require(['ojs/ojconverter-datetime'], function (m) { resolve(_interopNamespace(m)); }, reject) });
    return dateTimeConverterLoadPromise.then(
      function (__DateTimeConverter) {
        // use default format as in UX specs
        var pattern = this._isDateToday(timestamp) ? 'hh:mm a' : 'MM/dd/yy, hh:mm a';
        return new __DateTimeConverter.IntlDateTimeConverter({ pattern: pattern });
      }.bind(this)
    );
  };

  MessageViewModel.prototype._isDateToday = function (isoDate) {
    var todayDate = new Date();
    var suppliedDate = new Date(isoDate);

    return (
      todayDate.getUTCFullYear() === suppliedDate.getUTCFullYear() &&
      todayDate.getUTCMonth() === suppliedDate.getUTCMonth() &&
      todayDate.getUTCDate() === suppliedDate.getUTCDate()
    );
  };

  // Computes the category value for the bound variable. If category property is not specified, a
  //  default value based on the severity property is used. The display of category text is further
  //  dependent on what the display-options.category property value is.
  MessageViewModel.prototype._computeCategory = function () {
    var displayOptions = this._properties.displayOptions;

    if (displayOptions && displayOptions.category && displayOptions.category === 'none') {
      return undefined;
    }

    var message = this._properties.message;

    if (!oj.StringUtils.isEmptyOrUndefined(message.category)) {
      return message.category;
    }

    var severity = this._computeSeverity();

    // If severity is none, return undefined as we do not want to show the category
    if (severity === 'none') {
      return undefined;
    }

    var translations = this._properties.translations;

    var translatedCategory =
      translations && translations.categories ? translations.categories[severity] : undefined;

    if (oj.StringUtils.isEmptyOrUndefined(translatedCategory)) {
      // Ideally the custom element bridge should have set the translations sub-properties in this
      //  precedence (which is what the baseComponent in JQUI world did):
      //  1. Instance level override provided by app dev
      //  2. Localized value obtained from the bundle
      // However custom element bridge is not doing #2 (discussing with architects), fine to fetch
      //  from bundle in lieu of #2.
      translatedCategory = Translations.getComponentTranslations('oj-ojMessage').categories[severity];
    }

    return translatedCategory;
  };

  MessageViewModel.prototype._computeAutoTimeout = function () {
    var message = this._properties.message;

    if (isNaN(message.autoTimeout)) {
      return MessageViewModel._getMessageDefault('autoTimeout');
    }

    if (message.autoTimeout === 0) {
      return this._getThemedAutoTimeoutDefault();
    }

    return message.autoTimeout;
  };

  MessageViewModel.prototype._computeIconStyle = function () {
    var message = this._properties.message;

    if (oj.StringUtils.isEmptyOrUndefined(message.icon)) {
      return undefined;
    }

    return ["url('", message.icon, "') no-repeat"].join('');
  };

  MessageViewModel.prototype._computeIconClass = function () {
    var message = this._properties.message;

    if (!oj.StringUtils.isEmptyOrUndefined(message.icon)) {
      return undefined;
    }

    var computedSeverity = this._computeSeverity();

    if (computedSeverity === 'none') {
      return undefined;
    }

    var selectors = ['oj-component-icon', 'oj-message-status-icon'];
    selectors.push(['oj', 'message', computedSeverity, 'icon'].join('-'));
    return selectors.join(' ');
  };

  MessageViewModel.prototype._computeCloseAffordance = function () {
    var message = this._properties.message;

    if (oj.StringUtils.isEmptyOrUndefined(message.closeAffordance)) {
      return MessageViewModel._getMessageDefault('closeAffordance');
    }

    return message.closeAffordance;
  };

  MessageViewModel.prototype._computeMessageCloseSelectors = function () {
    if (this._computeAutoTimeout() > -1) {
      return 'oj-message-close oj-message-auto-timeout-close';
    }

    return 'oj-message-close';
  };

  MessageViewModel.prototype._computeMessageContainerSelectors = function () {
    let messageContainerSelectors = ['oj-message-container'];

    // Add no icon selector if no icons are specified, add relevent selectors
    // Simple logical not is sufficient for checking the existance. Since oj-bind-if
    // is testing for the same condition, we need this to be consistent.
    if (!this._computeIconStyle() && !this._computeIconClass()) {
      // No icon will be shown, add oj-message-no-icon selector to the container
      messageContainerSelectors.push('oj-message-no-icon');
    }

    // Add no detail selector if neither a detail slot nor a valid detail text is present
    if (!this._isDetailShown()) {
      messageContainerSelectors.push('oj-message-no-detail');
    }

    return messageContainerSelectors.join(' ');
  };

  MessageViewModel.prototype._computeSound = function () {
    var message = this._properties.message;

    if (message.sound === undefined) {
      return MessageViewModel._getMessageDefault('sound');
    }

    return message.sound;
  };

  MessageViewModel.prototype._computeLabelCloseIcon = function () {
    var translations = this._properties.translations;

    if (oj.StringUtils.isEmptyOrUndefined(translations.labelCloseIcon)) {
      // see comments in _computeCategory() that applies here as well
      return Translations.getTranslatedString('oj-ojMessage.labelCloseIcon');
    }

    return translations.labelCloseIcon;
  };

  MessageViewModel.prototype._computeSummary = function () {
    var message = this._properties.message;

    if (oj.StringUtils.isEmptyOrUndefined(message.summary)) {
      return undefined;
    }

    return message.summary;
  };

  MessageViewModel.prototype._computeDetail = function () {
    var message = this._properties.message;

    if (oj.StringUtils.isEmptyOrUndefined(message.detail)) {
      return undefined;
    }

    return message.detail;
  };

  MessageViewModel.prototype._handleCloseIcon = function (event) {
    this._closeMessage(event);
  };

  MessageViewModel.prototype._openMessage = function () {
    var messageContainerElement = document.getElementById(this._messagesContainerId);

    // Possible that the oj-message element may be disconnected/removed while open is in progress,
    //  guard against this case where messageContainerElement is removed
    if (messageContainerElement) {
      // Open animation for inlined message is taken care by the parent oj-messages. More comments
      //  on this below.
      if (this._isInlinedChildOfOjMessages()) {
        this._prepareMessageAtOpen();
      } else {
        this._operationMediator = new OperationMediator(this._composite, 'open');

        // notify the oj-messages to show the messages container so initial animation
        // will be seen.
        var eventParams = {
          bubbles: true,
          cancelable: false,
          detail: {
            message: this._properties.message
          }
        };

        // When the parent is an oj-messages, it will subscribe to message events ojBeforeOpen, ojOpen
        //  and ojAnimateStart for dealing with live region updates and to override animation based on
        //  its layout. For the case of inlined oj-message children though (in default slot), these
        //  events do not get delivered, since the parent oj-messages is not created yet. For this
        //  case, oj-messages will animate the inlined children as soon as it is created, and not in
        //  the ojAnimateStart listener.
        this._composite.dispatchEvent(new CustomEvent('ojBeforeOpen', eventParams));

        var action = 'open';
        var options = this._getAnimateOptionDefaults(action);

        // eslint-disable-next-line no-undef
        AnimationUtils.startAnimation(messageContainerElement, action, options, this._composite).then(
          function () {
            eventParams = {
              bubbles: true,
              cancelable: false,
              detail: {
                message: this._properties.message
              }
            };

            this._prepareMessageAtOpen();
            this._composite.dispatchEvent(new CustomEvent('ojOpen', eventParams));
          }.bind(this)
        );
      }
    }
  };

  MessageViewModel.prototype._isInlinedChildOfOjMessages = function () {
    var messagesAncestor = this._findMessagesAncestor();
    // If messages property is specified on oj-messages, the inlined oj-message children in its
    //  default slot are excluded.
    return messagesAncestor && !messagesAncestor.getProperty('messages');
  };

  MessageViewModel.prototype._findMessagesAncestor = function () {
    var ancestor = this._composite.parentElement;

    for (; ancestor; ancestor = ancestor.parentElement) {
      if (ancestor.nodeName.startsWith('OJ-')) {
        // stop at first ancestor with JET custom tag.
        return ancestor.nodeName === 'OJ-MESSAGES' ? ancestor : null;
      }
    }

    return null;
  };

  MessageViewModel.prototype._isDetailShown = function () {
    // Check if a detail slot is provided
    if (MessageViewModel._SLOT.DETAIL in this._slotCounts) {
      // We cannot determine if the provided slot renders content or not. So for our case,
      // we are assuming that if a slot is provided, message detail exists.
      return true;
    }

    // The _computeDetail method does all sanity checks and returns undefined it any of those checks fails,
    // so checking for undefined is sufficient to determine of the text is provided or not.
    if (this._computeDetail() !== undefined) {
      return true;
    }

    // When both the category and summary is specified, then the summary will be shown in the detail area.
    // So, this case should be treated as a message with detail, otherwise we do not have anything in the
    // message detail area.
    return this._computeCategory() !== undefined && this._computeSummary() !== undefined;
  };

  // Takes care of few additional stuff on the already opened (stamped case)/to-be-opened
  //  (inlined case) message. For inlined case, we have 2 limitations as noted below, but we are okay
  //  with it since we dont care to provide accurate functionality for inlined usecases (unusual).
  MessageViewModel.prototype._prepareMessageAtOpen = function () {
    var computedSound = this._computeSound();

    if (computedSound !== 'none') {
      // Initialize the AudioContext if the user agent supports Web Audio API
      this._initAudioContext();
      // 1. for inlined children case, we'd play sound a bit before the message actually is opened by
      //  the parent oj-messages.
      this._playSound(computedSound);
    }
    // register the swipe handler for touch devices
    this._registerSwipeHandler();

    // 2. for inlined children case, we'd be short of few seconds since we dont know when the parent
    //  oj-messages opens the message.
    this._scheduleAutoClose();
  };

  MessageViewModel.prototype._handleKeydown = function (event) {
    // if the event has been prevented or closeAffordance property is not "defaults", no-opt.
    if (event.defaultPrevented || this._computeCloseAffordance() !== 'defaults') {
      return;
    }

    // keyCode is deprecated and it's not supported on some browsers.
    if (event.keyCode === $.ui.keyCode.ESCAPE || event.key === 'Escape') {
      event.preventDefault();
      this._closeMessage(event);
    }
  };

  MessageViewModel.prototype._playSound = function (sound) {
    // Custom URL was specified for the sound, using <audio> element is simple and best for this case.
    if (sound !== 'defaults') {
      var audio = document.createElement('AUDIO');
      audio.src = sound;

      // Handle any error due to possible invalid URL.
      audio.addEventListener('error', function () {
        Logger.info(`JET oj-message: Failed to load media from URL in message.sound='${sound}'.`);
      });

      var promise = audio.play();

      if (promise !== undefined) {
        promise
          .then(function () {
            // All is well with autoplay
          })
          .catch(function (error) {
            // Autoplay failed. Possible causes 1. Browser prevents auto-play unless certain rules are
            // met (which varies by browsers), 2. The audio file resource does not exist or cannot be
            // loaded.
            Logger.info(
              `JET oj-message: Failed to play specified sound: '${sound}'. Error: ${error}`
            );
          });
      }
    } else if (window.audioContext === undefined) {
      // User agent does not support web audio API
      Logger.info(
        'JET oj-message: Failed to play default sound as the browser does not support Web Audio API'
      );
    } else {
      // Default gain value will be 100% of speaker volume which is fine
      var gainNode = window.audioContext.createGain();

      // Default destination is system speakers
      gainNode.connect(window.audioContext.destination);

      // Use default oscillator node type 'sine' and frequency '440 Hz', suffices for simple beep
      var oscillatorNode = window.audioContext.createOscillator();
      oscillatorNode.connect(gainNode);
      oscillatorNode.start();

      // Play for 10 ms
      oscillatorNode.stop(window.audioContext.currentTime + 0.01);
    }
  };

  MessageViewModel.prototype._initAudioContext = function () {
    if (window.audioContext === undefined) {
      try {
        // Create a page level AudioContext that all messages would use in this page. Browsers have
        //  limit on number of instances (usually 6), and AudioContext is designed to be shared per
        //  page. Webkit has a different constructor.
        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        // no op
      }
    }
  };

  MessageViewModel.prototype._createObservables = function () {
    // Computed observables
    // anything used by the view bindings can't be obfuscated and is why it's defined in quotes.
    // this["computedSeverity"] = ko.pureComputed(this._computeSeverity.bind(this), this);
    // this["computedCategory"] = ko.pureComputed(this._computeCategory.bind(this), this);
    // this["computedLabelCloseIcon"] = ko.pureComputed(this._computeLabelCloseIcon.bind(this), this);
    // this["computedCloseAffordance"] = ko.pureComputed(this._computeCloseAffordance.bind(this), this);
    // workaround for 
    this.hasCloseAffordance = ko.observable(this._computeCloseAffordance() === 'defaults');
    this.computedIconStyle = ko.observable(this._computeIconStyle());
    this.computedIconClass = ko.observable(this._computeIconClass());
    this.computedSeverity = ko.observable(this._computeSeverity());
    this.computedCategory = ko.observable(this._computeCategory());
    this.formattedTimestamp = ko.observable(this._formatTimestamp());
    this.computedLabelCloseIcon = ko.observable(this._computeLabelCloseIcon());
    this.computedMessageCloseSelectors = ko.observable(this._computeMessageCloseSelectors());
    this.computedMessageContainerSelectors = ko.observable(this._computeMessageContainerSelectors());
    this.computedSummary = ko.observable(this._computeSummary());
    this.computedDetail = ko.observable(this._computeDetail());
  };

  /**
   * Updates the severity styles based on the current severity
   *
   * @param {string=} previousSeverity An optional parameter representing the previous severity.
   *                                   If provided, the corresponding class will be removed.
   *
   * @private
   * @instance
   * @ignore
   */
  MessageViewModel.prototype._updateSeverityStyleClass = function (previousSeverity) {
    if (previousSeverity != null) {
      // Remove the style class representing the previous severity
      const previousStyleClass = MessageViewModel._getStyleClassForSeverity(previousSeverity);
      this._composite.classList.remove(previousStyleClass);
    }

    // Add the class for current severity
    const styleClass = MessageViewModel._getStyleClassForSeverity(this.computedSeverity());
    if (styleClass) {
      // add the style class only if it is available
      this._composite.classList.add(styleClass);
    }
  };

  MessageViewModel._getMessageDefault = function (propName) {
    return MessageViewModel._DEFAULTS.message[propName];
  };

  MessageViewModel._DEFAULTS = {
    autoTimeout: 4000,
    animation: {
      open: { effect: 'fadeIn', duration: '300ms' },
      close: { effect: 'fadeOut', duration: '300ms' }
    },
    message: {
      severity: 'none',
      autoTimeout: -1,
      closeAffordance: 'defaults',
      sound: 'none'
    }
  };

  /**
   * Computes the style class that has to be added in the root element based on
   * the severity of the message
   *
   * @param {string} severity The message severity whose style class is needed
   * @returns {string|undefined} The corresponding style class if one is available, undefined otherwise
   *
   * @private
   * @static
   * @ignore
   */
  MessageViewModel._getStyleClassForSeverity = function (severity) {
    return MessageViewModel._SEVERITY_STYLE_CLASS_MAP[severity];
  };

  /**
   * Maps the severity values to the corresponding element class that needs to
   * be added to the wrapper element
   *
   * @private
   * @static
   * @constant
   * @ignore
   */
  MessageViewModel._SEVERITY_STYLE_CLASS_MAP = {
    confirmation: 'oj-confirmation',
    error: 'oj-error',
    info: 'oj-info',
    warning: 'oj-warning'
  };

  /**
   * A map that contains supported slot names
   *
   * @private
   * @static
   * @constant
   * @ignore
   */
  MessageViewModel._SLOT = {
    DETAIL: 'detail'
  };

  MessageViewModel.prototype._getThemedAutoTimeoutDefault = function () {
    var themedDefaults = ThemeUtils.parseJSONFromFontFamily('oj-message-option-defaults');
    if (themedDefaults && themedDefaults.autoTimeout) {
      return themedDefaults.autoTimeout;
    }
    return MessageViewModel._DEFAULTS.autoTimeout;
  };

  MessageViewModel.prototype._getAnimateOptionDefaults = function (action) {
    return MessageViewModel._DEFAULTS.animation[action];
  };

  /**
   * Coordinate communications between an event being fulfilled and one or more promises
   * being resolved.  The window of time between the instance creation and the associated event
   * triggered is guarded by the {@link oj.BusyContext}.
   * @private
   * @constructor
   * @ignore
   * @param {Element} element to subscribe on the event type triggered on completion of the operation
   * @param {string} operation that completion will resolve one or more promises
   * @ojtsignore
   */
  function OperationMediator(element, operation) {
    this._element = element;
    this._operation = operation;

    this._init();
  }

  /**
   * Registers an event handler on the element associated with the target operation.
   * The event handler will resolve one or more pending promises.  The convention
   * is the operation will raise a "oj" + operation event upon completion. The
   * event hander is one and done - unregistered after first delivery.
   * @instance
   * @private
   */
  OperationMediator.prototype._init = function () {
    this._resolvedQueue = [];
    this._callback = this._eventHandler.bind(this);

    var operation = this._operation;
    var tokens = ['oj'];
    tokens.push(operation.charAt(0).toUpperCase());
    tokens.push(operation.slice(1));

    var eventType = tokens.join('');
    this._eventType = eventType;
    this._element.addEventListener(eventType, this._callback);

    // Add a busy state for the pending operation.  The busy state resolver will
    // be invoked when the resolved queue is delivered (operation completes).
    var busyContext = Context.getContext(this._element).getBusyContext();
    var options = {
      description: this._getBusyStateDescription.bind(this, this._element, this._operation)
    };
    var resolve = busyContext.addBusyState(options);
    this.addPromiseExecutor(
      function (callback) {
        // Resolve busyness next-tick.  The ojOpen/ojClose events bubble
        // up to oj-messages All event processing will be at the parent level.
        // Keep the busy state until the parent has had a chance to act on
        // the open/close event.
        window.setImmediate(function () {
          callback();
        });
      }.bind(this, resolve)
    );
  };

  /**
   * @private
   * @param {Element} element to subscribe on the event type triggered on completion of the operation
   * @param {string} operation that completion will resolve one or more promises
   * @returns {string} description of the busy state animation operation.
   */
  OperationMediator.prototype._getBusyStateDescription = function (element, operation) {
    return `${element.nodeName} is busy animating on the ${operation} operation`;
  };

  /**
   * Resolves the pending promises.
   *
   * @private
   * @param {string=} operation override sent to the resolverdQueue
   */
  OperationMediator.prototype._deliverResolved = function (operation) {
    // Critical section - the registered resolve queue is disconnect from the
    // instance state so that a race condition will not occur - resolve promoise
    // adding new operations to the same queue.

    var resolvedQueue = this._resolvedQueue;
    this._resolvedQueue = [];

    // eslint-disable-next-line no-param-reassign
    operation = !operation ? this._operation : operation;
    this._operation = null;

    for (var i = 0; i < resolvedQueue.length; i++) {
      resolvedQueue[i](operation);
    }
  };

  /**
   * Force delivery of unresolved promises.
   */
  OperationMediator.prototype.destroy = function () {
    // If the promise is swapped (component is destroyed)
    // before the event is fired, resolve with a "none" operation.
    this._deliverResolved('none');

    this._callback = null;
    this._element = null;
    this._operation = null;
    this._eventType = null;
  };

  /**
   * Event handler associated with completion of the target operation.
   * @private
   * @param {Event} event
   */
  OperationMediator.prototype._eventHandler = function (event) {
    if (event.target === this._element) {
      this._element.removeEventListener(event.type, this._callback);
      this._deliverResolved();
      this._callback = null;
    }
  };

  /**
   * @return {string} Returns the pending operation
   */
  OperationMediator.prototype.getPendingOperation = function () {
    return this._operation ? this._operation : 'none';
  };

  /**
   * A function that will be passed to other functions via the arguments resolve and reject.
   * The resolve function will be invoked when the event associated with completion of the
   * target operation is delivered to the target element.
   *
   * @public
   * @param {Function} resolve resultant function that will resovle a promise executor
   * @param {Function=} reject (not interested in the reject)
   */
  // eslint-disable-next-line no-unused-vars
  OperationMediator.prototype.addPromiseExecutor = function (resolve, reject) {
    this._resolvedQueue.push(resolve);
  };

  /**
   * Checks to see if there is a pending "open" or "close" operation.  If pending and it
   * is the same as the requested operation, the request silently fails.  If the current
   * operation is the inverse operation, we queue the current operation after the pending
   * operation is resolved.
   *
   * @param {string} operation currently requested
   * @param {Function} callback that should be invoked when the operation is the
   *                 inverse of the pending operation
   * @returns {boolean} <code>true</code> if a "close" or "open" operation is pending completion.
   */
  OperationMediator.prototype.isOperationPending = function (operation, callback) {
    // if destroyed return false
    if (!this._element) {
      return false;
    }

    var isPending = false;
    var pendingOperation = this.getPendingOperation();
    if (operation === pendingOperation) {
      // Same request is already pending. Silently fail.
      Logger.info(
        [
          "JET oj-message: invoked a '",
          operation,
          "' operation while pending animation of the same type of operation. ",
          'The second request will be ignored.'
        ].join('')
      );
      isPending = true;
    } else if (pendingOperation !== 'none') {
      Logger.info(
        [
          "JET oj-message: invoked a '",
          operation,
          "' operation while pending animation of a '",
          pendingOperation,
          "' operation. The second request will be invoked after the pending ",
          'operation completes.'
        ].join('')
      );

      // Queue the operation after the pending operation has completed.
      this.addPromiseExecutor(callback);

      isPending = true;
    }
    return isPending;
  };

var __oj_message_metadata = 
{
  "properties": {
    "displayOptions": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "enumValues": [
            "auto",
            "header",
            "none"
          ],
          "value": "auto"
        }
      }
    },
    "message": {
      "type": "object",
      "properties": {
        "autoTimeout": {
          "type": "number",
          "value": -1
        },
        "category": {
          "type": "string",
          "value": ""
        },
        "closeAffordance": {
          "type": "string",
          "enumValues": [
            "defaults",
            "none"
          ],
          "value": "defaults"
        },
        "detail": {
          "type": "string",
          "value": ""
        },
        "icon": {
          "type": "string",
          "value": ""
        },
        "severity": {
          "type": "string",
          "enumValues": [
            "confirmation",
            "error",
            "info",
            "none",
            "warning"
          ],
          "value": "none"
        },
        "sound": {
          "type": "string",
          "value": "none"
        },
        "summary": {
          "type": "string",
          "value": ""
        },
        "timestamp": {
          "type": "string",
          "value": ""
        }
      }
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "categories": {
          "type": "object",
          "properties": {
            "confirmation": {
              "type": "string"
            },
            "error": {
              "type": "string"
            },
            "info": {
              "type": "string"
            },
            "none": {
              "type": "string"
            },
            "warning": {
              "type": "string"
            }
          }
        },
        "labelCloseIcon": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "close": {},
    "getProperty": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojClose": {}
  },
  "extension": {}
};
  /* global __oj_message_metadata */
  // eslint-disable-next-line no-undef
  Composite.register('oj-message', {
    view: _MESSAGE_VIEW,
    viewModel: MessageViewModel,
    metadata: __oj_message_metadata
  });

  exports.ojMessage = ojMessage;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojmessages',['ojs/ojcore-base', 'jquery', 'knockout', 'ojs/ojanimation', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojtranslation', 'ojs/ojcomposite', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojdomutils', 'ojs/ojknockout', 'ojs/ojpopupcore', 'ojs/ojmessage', 'ojs/ojdataprovider', 'ojs/ojcustomelement-utils'], function (oj, $, ko, AnimationUtils, Context, ThemeUtils, Translations, Composite, Components, Logger, DomUtils, ojknockout, ojpopupcore, ojmessage, ojdataprovider, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /* jslint browser: true*/

  /**
   * @ojcomponent oj.ojMessages
   * @since 5.0.0
   * @ojdeprecated [
   *   {
   *     type: "maintenance",
   *     since: "16.0.0",
   *     value: ["oj-c-message-banner", "oj-c-message-toast"]
   *   }
   * ]
   * @ojdisplayname Messages
   * @ojshortdesc Messages manages the layout and display of child messages.
   *
   * @ojsignature {target: "Type", value:"class ojMessages extends JetElement<ojMessagesSettableProperties>"}
   * @ojtsimport {module: "ojmessage", type: "AMD", imported: ["ojMessage"]}
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["display", "position.at.horizontal", "position.at.vertical", "position.collision",
   *                                                     "position.my.horizontal", "position.my.vertical", "position.of",
   *                                                     "position.offset.x", "position.offset.y"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["messages"]}
   * @ojvbdefaultcolumns 2
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-messages'
   * @ojuxspecs ['messages']
   *
   * @classdesc
   * <h3 id="messageOverview-section">
   *   JET Messages
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#messageOverview-section"></a>
   * </h3>
   * <p>Description:
   * <p>Manages the layout and display of one or more messages.
   *
   * <h4 id="messages-syntax-section">Syntax
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#messages-syntax-section"></a></h4>
   * <p>Messages can be defined using a simple syntax to directly bind a DataProvider to the 'messages'
   *    attribute of oj-messages as shown below.
   * <p><b>Note that the use of inlined oj-message children inside of oj-messages is deprecated.</b>
   *    Applications should directly databind 'messages' attribute of oj-messages instead. Using
   *    oj-message inside of the 'messageTemplate' slot to define the template is still valid.
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-messages id="pageMessages" messages="[[messagesDataProvider]]">
   * &lt;/oj-messages>
   * </code>
   * </pre>
   *
   * <h4 id="messages-layout-section">Layouts
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#messages-layout-section"></a></h4>
   * <p>Messages can be shown in these layouts
   * <ul>
   * <li>Inlined to the page content.</li>
   * <li>Overlayed on the page content, positioned to the top of the page by default.</li>
   * <li>As notifications, positioned to the top-end corner of the page by default.</li>
   * </ul>
   * Inlined messages will push the page contents when a new message is shown and could scroll out of
   * the view when user scrolls the page. Overlayed or notification style messages are usually
   * positioned relative to the window, will assume a fixed position and will remain
   * visible when the user scrolls the page. Overlayed or notification messages can be positioned
   * relative to another element in the page, in which case the messages follow that element upon
   * page scroll. Inline and overlay layouts are suitable for messages pertaining to the page or
   * region of the page, or relating to the task the user performed on the page. Notification layout is
   * suitable for messages that arrive asynchronously to the application or to communicate alerts to
   * users. Examples below shows the three layouts.
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;!-- Inline: Do not specify the 'position', set 'display' to 'general' -->
   * &lt;oj-messages id="inlineMessages" messages="[[serviceRequestMessages]]" display="general">
   * &lt;/oj-messages>
   *
   * &lt;!-- Overlay: Set 'position' to an empty or a structured object, set 'display' to 'general' -->
   * &lt;oj-messages id="overlayMessages" messages="[[serviceRequestMessages]]" position="{}" display="general">
   * &lt;/oj-messages>
   *
   * &lt;!-- Notification: Set 'position' to an empty or a structured object, set 'display' to 'notification' -->
   * &lt;oj-messages id="notificationMessages" messages="[[emailMessages]]" position="{}" display="notification">
   * &lt;/oj-messages>
   * </code>
   * </pre>
   *
   * <h3 id="reparenting-section">
   *   Reparenting
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
   * </h3>
   *
   *  <p id="reparenting-strategy">
   *     When the messages region is disclosed as a popup (position property defined), it will be
   *     reparented in the document and reparented back when all contained messages are closed.
   *     The location of the messages within the document will be in context of where it is defined.
   *     This is different than other types of popups where their reparenting location depends on
   *     the context they are used.  The stacking context of the messages region will be defined
   *     by the "oj-messages-layer" style class. The messages region that has active focus will be
   *     assigned a greater z-index value. This is applied to the messages's layer by way of
   *     the "oj-focus-within" pseudo selector applied with "oj-messages-layer" selector.
   *     The page author has control over z-index weights by way of the "oj-messages-layer" selector.
   *  </p>
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * {@ojinclude "name":"migrationDoc"}
   */
  // --------------------------------------------------- oj.ojMessages Styling Start -----------------------------------------------------------
  // ---------------- oj-messages-inline-remove-bottom-border --------------
  /**
   * Inline messages will include a bottom border so that the messages section is demarcated from the contents below it. If this border is not desirable for certain page layouts, it can be removed by setting this marker class on oj-messages.
   * @ojstyleclass oj-messages-inline-remove-bottom-border
   * @ojdisplayname No Border
   * @memberof oj.ojMessages
   * @ojtsexample
   * &lt;oj-messages class="oj-messages-inline-remove-bottom-border">
   *   &lt;!-- Content -->
   * &lt;/oj-messages>
   */

  // ---------------- oj-messages-outlined --------------
  /**
   * Inline messages (Banners) can be either Edge-to-Edge or Outlined. By default, the inline messages are rendered as Edge-to-Edge Banner messages.
   * If Outlined Banner messages are preferred instead, add oj-messages-outlined class on the oj-messages element.
   * @ojstyleclass oj-messages-outlined
   * @since 10.0.0
   * @ojdisplayname Outlined Banner Messages
   * @memberof oj.ojMessages
   * @ojtsexample
   * &lt;oj-messages class="oj-messages-outlined"&gt;
   *   &lt;!-- Content --&gt;
   * &lt;/oj-messages&gt;
   */
  // --------------------------------------------------- oj.ojMessages Styling Start -----------------------------------------------------------

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan = "3">Focus within Messages</td>
   *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
   *       <td>Navigate the content of the messages region.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>F6</kbd></td>
   *       <td>Moves focus back to the last focused element outside the messages region.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Moves focus back to the last focused element outside the messages region.</td>
   *     </tr>
   *     <tr>
   *       <td rowspan = "1">Focus outside Messages</td>
   *       <td><kbd>F6</kbd></td>
   *       <td>Move focus to the first message within the more recently disclosed messages region.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc.
   * @memberof oj.ojMessages
   */

  /**
   * <h3 id="migration-section">
   *   Migration (Message Toast)
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   *
   * <p>
   * To migrate from oj-messages to oj-c-message-toast, you need to revise the import statement
   * and references to oj-c-message-toast in your app. Please note the changes between the two
   * components below.
   * </p>
   *
   * <h5>Display attribute</h5>
   * <p>
   * In <code class="prettyprint">oj-messages</code>, the messages are rendered as toasts if the <code class="prettyprint">display</code>
   * attribute is set to "notification". But, the <code class="prettyprint">oj-c-message-toast</code> is a dedicated component for rendering
   * messages as toasts. So, this attribute is not needed.
   * </p>
   *
   * <h5>Display Options attribute</h5>
   * <p>
   * This attribute allows one to configure whether or not to show the category text in the <code class="prettyprint">oj-messages</code> component.
   * But, in the <code class="prettyprint">oj-c-message-toast</code> component, the category texts are not supported and thus no need for this attribute.
   * </p>
   *
   * <h5>Messages attribute</h5>
   * <p>
   * The <code class="prettyprint">oj-c-message-toast</code> component uses <code class="prettyprint">data</code> attribute instead of the <code class="prettyprint">messages</code>
   * attribute. The new <code class="prettyprint">data</code> attribute only supports having a DataProvider as its value. If you were using an array for the <code class="prettyprint">messages</code>
   * attribute, you need to wrap it in a DataProvider when migrating to the new component. Also, the new attribute is a required attribute. So, if you were not setting the <code class="prettyprint">messages</code>
   * attribute, you will still need to set the <code class="prettyprint">data</code> attribute in the new component to a DataProvider but it can be initialized with an empty array.
   * </p>
   *
   * <h5>Position attribute</h5>
   * <p>
   * In the <code class="prettyprint">oj-c-message-toast</code> component this attribute will take a string instead of an object. In the new component, the messages
   * are always positioned with respect to the widow and thus it only takes the following string values for this property:
   * <ul>
   * <li><code class="prettyprint">"top"</code></li>
   * <li><code class="prettyprint">"top-left"</code></li>
   * <li><code class="prettyprint">"top-start"</code></li>
   * <li><code class="prettyprint">"top-right"</code></li>
   * <li><code class="prettyprint">"top-end"</code></li>
   * <li><code class="prettyprint">"bottom"</code></li>
   * <li><code class="prettyprint">"bottom-left"</code></li>
   * <li><code class="prettyprint">"bottom-start"</code></li>
   * <li><code class="prettyprint">"bottom-right"</code></li>
   * <li><code class="prettyprint">"bottom-end"</code></li>
   * </ul>
   * The <code class="prettyprint">offset</code> property of the position object is moved as a separate attribute.
   * </p>
   *
   * <h5>Position.offset property</h5>
   * <p>
   * If one were setting offset using the <code class="prettyprint">position.offset</code> property of the <code class="prettyprint">oj-messages</code> component,
   * the same can be done using the <code class="prettyprint">offset</code> attribute of the <code class="prettyprint">oj-c-message-toast</code> component. One can
   * either set it to a number, which will then be used for both horizontal and vertical offset, or set it to an object with horizontal and vertical properties set.
   * </p>
   *
   * <h5>Translations attribute</h5>
   * <p>
   * Per instance translations object is not supported in the new <code class="prettyprint">oj-c-message-toast</code> component. Use the translations bundle instead.
   * </p>
   *
   * <h5>ojClose event</h5>
   * <p>
   * In <code class="prettyprint">oj-c-message-toast</code> component, <code class="prettyprint">ojClose</code> event is triggered when one tries to close a message
   * in the page. But, this will not automatically close the message on the UI. The application needs to listen to this event and remove the corresponding item from
   * DataProvider. This will in turn remove the messages from the UI.
   * </p>
   *
   * <h5>Close methods</h5>
   * <p>
   * The <code class="prettyprint">oj-c-message-toast</code> component does not support <code class="prettyprint">close</code> and <code class="prettyprint">closeAll</code>
   * methods. To close a single message or all messages, simply remove the corresponding items from the DataProvider.
   * </p>
   *
   * <h5>messageTemplate</h5>
   * <p>
   * The <code class="prettyprint">messageTemplate</code> or the usage of <code class="prettyprint">oj-message</code> component is not supported in the
   * <code class="prettyprint">oj-c-message-toast</code> component. Instead, one can have any number of arbitrarily named template slots. In these templates,
   * one can directly provide the content without having to wrap them in an <code class="prettyprint">oj-message</code> component. Then using the
   * <code class="prettyprint">detail-template-value</code> attribute, one can specify which template will be used for which message. In the similar way,
   * one can also configure the start-icon of the component using the <code class="prettyprint">icon-template-value</code> attribute.
   * </p>
   *
   * <h5>Message type</h5>
   * <p>
   * The <code class="prettyprint">oj-c-message-toast</code> component uses the <code class="prettyprint">MessageToastItem</code> type for the items in the DataProvider.
   * Please note the changes in properties below:
   * <ul>
   * <li>autoTimeout - changed to <code class="prettyprint">"on" | "off" | number</code>. Use 'on' instead of 0 and 'off' instead of -1.</li>
   * <li>category - not supported as it is not an approved redwood-pattern</li>
   * <li>closeAffordance - changed to <code class="prettyprint">"on" | "off"</code>. Use 'off' instead of 'none' and leave the attribute unset instead of 'defaults'.</li>
   * <li>icon - not supported as it is not an approved redwood-pattern</li>
   * <li>timestamp - not supported as it is not an approved redwood-pattern</li>
   * </ul>
   * </p>
   *
   * @ojfragment migrationDoc
   * @memberof oj.ojMessages
   * @instance
   */

  // Attributes
  // ///////////

  /**
   *<p> Specifies the collection of structured message data used to display the individual messages.
   * This property can be used to conveniently specify the required data as a single collection.
   * Individual message will be automatically created based on this data. See
   * {@link oj.ojMessage.Message} for message values.</p>
   * <p> More information about the structured 'Message' data can be found in documentation for
   * 'message' attribute of <code class="prettyprint">oj-message</code> element.</p>
   *
   * The collection can be two types:
   * <li>an array of oj.ojMessage.Message objects.</li>
   * <li>oj.ArrayDataProvider of oj.ojMessage.Message objects. Look at {@link ArrayDataProvider} for more available options.</li>
   * @example <caption>Initialize component with <code class="prettyprint">messages</code> attribute:</caption>
   * //example with 'messages' attribute is  an array of oj.ojMessage.Message objects.
   * &lt;!-- emailNotifications is an array of messages, with each entry being of 'Message' type -->
   * &lt;oj-messages messages="[[emailNotifications]]">&lt;/oj-messages>
   * //example with 'messages' attribute of type dataprovider. See the documentation for {@link ArrayDataProvider} for more details on the available options.
   * &lt;oj-messages messages="[[dataProvider]]">&lt;/oj-messages>
   * &lt;!-- dataProvider is an oj.ArrayDataProvider, with each entry being of 'Message' type -->
   * @example <caption>Get or set the <code class="prettyprint">messages</code> property after initialization:</caption>
   *
   * // getter
   * var messages = myMessages.messages;
   *
   * // setter example using a messages array
   * myMessages.messages = [{"severity": "error", "summary": "Some summary 1", "detail": "Some detail 1"},
   *                        {"severity": "warning", "summary": "Some summary 2", "detail": "Some detail 2"}];
   * // setter example using DataProvider
   * var messages = [{"severity": "error", "summary": "Some summary 1", "detail": "Some detail 1"},
   *                {"severity": "warning", "summary": "Some summary 2", "detail": "Some detail 2"}];
   * myMessages.messages = new oj.ArrayDataProvider(messages);
   * @expose
   * @type {null | Array.<Object> | Object}
   * @name messages
   * @ojshortdesc Specifies the collection of structured message data used to display the individual messages. See the Help documentation for more information.
   * @default null
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessages
   * @ojsignature { target: "Type",
   *                value: "Array<oj.ojMessage.Message> | null | DataProvider<any, oj.ojMessage.Message>",
   *                jsdocOverride: true}
   **/

  /**
   * <p>Specifies the display purpose of messages. The valid values for display are
   * <code class="prettyprint">general</code> and <code class="prettyprint">notification</code>.
   * General messages are commonly rendered at the page level or section level, relating to the task
   * the user performed. Notification messages are typically used for reporting asynchronous events,
   * or to communicate some background activity.</p>
   *
   * The presentation of the message is inline by default.  However, when a
   * {@link oj.ojMessages#position}property is provided, the presentation will be an overlay.
   * The alignment of the overlay will default based on the <code>display</code> property.  The
   * defaults are defined by the theme.
   *
   * @example <caption>Initialize component with <code class="prettyprint">display</code> attribute:</caption>
   * &lt;oj-messages display="notification" position="{}">&lt;/oj-messages>
   *
   * @example <caption>Get or set the <code class="prettyprint">display</code> property after initialization:</caption>
   * // getter
   * var display = myMessages.display;
   *
   * // setter
   * myMessages.display = "notification";
   *
   * @expose
   * @type {string}
   * @name display
   * @ojshortdesc Specifies the display purpose of the messages. See the Help documentation for more information.
   * @default "general"
   * @ojvalue {string} "general" Messages pertaining to the page or region of the application.
   * @ojvalue {string} "notification" Often used for communicating alerts arriving asynchronously.
   * @instance
   * @since 5.0.0
   * @access public
   * @memberof! oj.ojMessages
   **/

  /**
   * <p>The position property defines the presentation style.  The default presentation is inline,
   * defined by a <code>null</code> position property value.  When a value is provide for the
   * property, the presentation style will be an overaly "popup".  The alignment of the overaly
   * is defined by the position sub-properties.</p>
   *
   * Default position sub-properites are extended by the provided value.  Defaults vary
   * based on the <code>display</code> property and provided by theme. The position
   * property is used to establish the location where the messages popup overlay will appear
   * relative to another element.</p>
   *
   * <p>The "my" and "at" properties defines alignment points relative to the popup and other
   * element.  The "my" property represents the popups alignment where the "at" property
   * represents the other element that can be identified by "of" or defauts to the launcher
   * when the popup opens.  The values of these properties describe horizontal and
   * vertical alignments.</p>
   *
   * @example <caption>Initialize the popup with <code class="prettyprint">position</code>
   *           attribute specified:</caption>
   * &lt;oj-messages position.my.horizontal="left"
   *              position.my.vertical="top"
   *              position.at.horizontal="right"
   *              position.at.vertical="top">
   * &lt;/oj-messages>;
   *
   * @example <caption>Get or set the <code class="prettyprint">position</code> property,
   *          after initialization:</caption>
   * // getter
   * var position = myMessages.position;
   *
   * // setter
   * myMessages.position =
   *    {"my": {"horizontal": "start", "vertical": "bottom"},
   *     "at": {"horizontal": "end", "vertical": "top" },
   *     "offset": {"x": 0, "y":5}};
   *
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @type {Object|null}
   * @name position
   * @ojshortdesc Specifies the position and presentation style of the messages. See the Help documentation for more information.
   * @ojsignature { target: "Type",
   *                value: "oj.ojMessages.Position|null",
   *                jsdocOverride: true}
   */

  /**
   * Defines which edge on the messages overlay to align with the target ("of") element.
   *
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.my
   * @type {Object}
   */

  /**
   * Defines the horizontal alignment of the messages overlay.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.my.horizontal
   * @type {string}
   * @ojvalue {string} "start" Evaluates to "left" in LTR mode and "right" in RTL mode.
   * @ojvalue {string} "end" Evaluates to "right" in LTR mode and "left" in RTL mode.
   * @ojvalue {string} "left"
   * @ojvalue {string} "center"
   * @ojvalue {string} "right"
   */

  /**
   * Defines the vertical alignment of the messages overlay.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.my.vertical
   * @type {string}
   * @ojvalue {string} "top"
   * @ojvalue {string} "center"
   * @ojvalue {string} "bottom"
   */

  /**
   * Defines a point offset in pixels from the ("my") alignment.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.offset
   * @type {Object}
   */

  /**
   * Horizontal alignment offset.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.offset.x
   * @type {number}
   */

  /**
   * Vertical alignment offset.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.offset.y
   * @type {number}
   */

  /**
   * Defines which position on the target element ("of") to align the positioned element
   * against.
   *
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.at
   * @type {Object}
   */

  /**
   * Defines the horizontal alignment of what the messages overlay is aligned to.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.at.horizontal
   * @type {string}
   * @ojvalue {string} "start" Evaluates to "left" in LTR mode and "right" in RTL mode.
   * @ojvalue {string} "end" Evaluates to "right" in LTR mode and "left" in RTL mode.
   * @ojvalue {string} "left"
   * @ojvalue {string} "center"
   * @ojvalue {string} "right"
   */

  /**
   * Defines the vertical alignment of what the messages overlay is aligned to.
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.at.vertical
   * @type {string}
   * @ojvalue {string} "top"
   * @ojvalue {string} "center"
   * @ojvalue {string} "bottom"
   */

  /**
   * Which element to position the messages overlay against.
   *
   * If the value is a string, it should be a selector or the literal string value
   * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
   * is used, the values are relative to the whole document.  Page horizontal and vertical
   * scroll offsets need to be factored into this point - see UIEvent
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
   *
   * @example <caption>Finding the point for an svg element:</caption>
   * var rect = svgDom.getBoundingClientRect();
   * var position = {of:{x:rect.left + window.pageXOffset, y:rect.top + window.pageYOffset}};
   *
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.of
   * @ojshortdesc Specifies which element to position the messages overlay against. See the Help documentation for more information.
   * @type {string}
   */

  /**
   * Rule for alternate alignment.
   *
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @name position.collision
   * @type {string}
   * @ojvalue {string} "flip" The element to the opposite side of the target and the
   *  collision detection is run again to see if it will fit. Whichever side
   *  allows more of the element to be visible will be used.
   * @ojvalue {string} "fit" Shift the element away from the edge of the window.
   * @ojvalue {string} "flipfit" First applies the flip logic, placing the element
   *  on whichever side allows more of the element to be visible. Then the fit logic
   *  is applied to ensure as much of the element is visible as possible.
   * @ojvalue {string} "none" No collision detection.
   */

  /**
   * <p>Specifies the display options for contents of all the messages specified for the
   * {@link oj.ojMessages#messages} attribute.
   *
   * @expose
   * @member
   * @name displayOptions
   * @ojshortdesc Specifies the display options for contents of all the messages.
   * @memberof! oj.ojMessages
   * @instance
   * @since 6.1.0
   * @type {Object}
   * @ojsignature { target: "Type",
   *                value: "oj.ojMessage.DisplayOptions",
   *                jsdocOverride: true}
   *
   * @example <caption>Initialize the element with <code class="prettyprint">display-options</code>
   * attribute:</caption>
   * &lt;!-- Binding display-options attribute to a structured object -->
   * &lt;oj-messages display-options="[[myMessageDisplayOptions]]">&lt;/oj-message>
   *
   * &lt;!-- Setting display-options using JSON notation -->
   * &lt;oj-messages display-options='{"category": "none"}' message.summary="Some summary" message.detail="Some detail">&lt;/oj-messages>
   *
   * &lt;!-- Setting the display-options sub-attributes -->
   * &lt;oj-messages display-options.category="none" message.summary="Some summary" message.detail="Some detail">&lt;/oj-messages>
   *
   * @example <caption>Get or set the <code class="prettyprint">displayOptions</code> property after initialization:</caption>
   * // getter
   * var displayOptions = myMessages.displayOptions;
   *
   * // setter
   * myMessages.displayOptions = {
   *     category: "none"
   * };
   */

  /**
   * <p>Specifies display option for {@link oj.ojMessage#message.category} text in all the messages
   * specified for the {@link oj.ojMessages#messages} attribute.</p>
   * <p>In Redwood theme, showing the category text is an anti-pattern. Set this attribute to "none".</p>
   *
   * @example <caption>Initialize the element with <code class="prettyprint">display-options.category</code> attribute:</caption>
   * &lt;oj-messages display-options.category="none" message.summary="Some summary" message.detail="Some detail">&lt;/oj-messages>
   *
   * @example <caption>Get or set the <code class="prettyprint">displayOptions.category</code> property after initialization:</caption>
   * // getter
   * var categoryOption = myMessages.getProperty("displayOptions.category");
   *
   * // setter
   * myMessages.setProperty("displayOptions.category", "none");
   *
   * @expose
   * @type {string}
   * @name displayOptions.category
   * @ojvalue {string} "header" If the {@link oj.ojMessage#message.category} property is specified,
   *  its value will be displayed in the header region of the message next to message icon. If
   *  {@link oj.ojMessage#message.category} property is not specified, a translated text corresponding
   *  to the value of the {@link oj.ojMessage#message.severity} property will be displayed.
   * @ojvalue {string} "auto" The component decides whether and where the
   *  {@link oj.ojMessage#message.category} text is displayed. The behavior is same as 'header'
   *  option, but may change in future releases.
   * @ojvalue {string} "none" The {@link oj.ojMessage#message.category} text will not be displayed.
   * @default "auto"
   * @instance
   * @access public
   * @memberof! oj.ojMessages
   */

  /**
   * <p>A collection of translated resources from the translation bundle, or <code class="prettyprint">null</code> if this
   * component has no resources.  Resources may be accessed and overridden individually or collectively, as seen in the examples.
   *
   * <p>If this component has translations, their documentation immediately follows this doc entry.
   *
   *
   * @example <caption>Initialize the component, overriding some translated resources and leaving the others intact:</caption>
   * &lt;!-- Using dot notation -->
   * &lt;oj-some-element translations.some-key='some value' translations.some-other-key='some other value'>&lt;/oj-some-element>
   *
   * &lt;!-- Using JSON notation -->
   * &lt;oj-some-element translations='{"someKey":"some value", "someOtherKey":"some other value"}'>&lt;/oj-some-element>
   *
   * @example <caption>Get or set the <code class="prettyprint">translations</code> property after initialization:</caption>
   * // Get one
   * var value = myComponent.translations.someKey;
   *
   * // Set one, leaving the others intact. Always use the setProperty API for
   * // subproperties rather than setting a subproperty directly.
   * myComponent.setProperty('translations.someKey', 'some value');
   *
   * // Get all
   * var values = myComponent.translations;
   *
   * // Set all.  Must list every resource key, as those not listed are lost.
   * myComponent.setProperty("translations.someKey" 'some value');
   *
   * @expose
   * @type {Object}
   * @name translations
   * @ojshortdesc A collection of translated resources from the translation bundle, or null if this component has no resources.
   * @memberof! oj.ojMessages
   * @ojtranslatable
   * @member
   * @instance
   * @since 5.0.0
   **/

  // Slots
  // //////

  /**
   * <p>The <code class="prettyprint">&lt;oj-messages></code> element accepts only
   * <code class="prettyprint">&lt;oj-message></code> element as children for the default slot. The
   * default slot contents are rendered only if the 'messages' attribute on
   * <code class="prettyprint">&lt;oj-messages></code> is not set. If the 'messages' attribute is set
   * <code class="prettyprint">&lt;oj-message></code> children are automatically stamped for each
   * message data in the collection.
   *
   * <p><b>Note that the use of inlined oj-message children inside of oj-messages is deprecated.</b>
   *    Applications should directly databind 'messages' attribute of oj-messages instead. Using
   *    oj-message inside of the 'messageTemplate' slot to define the template is still valid.
   *
   * @ojchild Default
   * @ojshortdesc The oj-messages element accepts only oj-message elements as children for the default slot. See the Help documentation for more information.
   * @memberof oj.ojMessages
   * @since 5.0.0
   *
   * @example <caption>Initialize <code class="prettyprint">&lt;oj-messages></code> with explicitly
   * defined <code class="prettyprint">&lt;oj-message></code> children:</caption>
   * &lt;oj-messages id="inlineMessages">
   *   &lt;oj-message message='{"summary": "Some summary", "detail": "Some detail", "autoTimeout": 5000}'>&lt;/oj-message>
   *   &lt;oj-message message="[[surveyInstructions]]">&lt;/oj-message>
   *   &lt;oj-message message="[[surveySubmitConfirmation]]">&lt;/oj-message>
   * &lt;/oj-messages>
   */

  /**
   * <p>The <code class="prettyprint">messageTemplate</code> slot is used to specify the template
   * for rendering each message in the <code class="prettyprint">oj-messages</code>. The slot
   * <b>must</b> be a &lt;template> element. The default template will display the
   * <code class="prettyprint">oj-message</code> children to best suit the display type of the
   * <code class="prettyprint">oj-messages</code>. This template slot will be applied only if the
   * 'messages' attribute on <code class="prettyprint">oj-messages</code>> is set.
   * The content of the template <b>must</b> be an <code class="prettyprint">oj-message</code>
   * element.</p>
   * <p>When the template is executed for each message, it will have access to the binding context
   * containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current message. (See [oj.ojMessages.MessageTemplateContext]{@link oj.ojMessages.MessageTemplateContext} or the table
   *       below for a list of properties available on $current)</li>
   *  <li>alias - if 'data-oj-as' attribute was specified on the &lt;template> element, the value
   *      will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   *
   * @ojslot messageTemplate
   * @ojshortdesc The messageTemplate slot is used to specify the template for rendering each message. See the Help documentation for more information.
   * @ojmaxitems 1
   * @memberof oj.ojMessages
   * @since 6.2.0
   * @ojtemplateslotprops oj.ojMessages.MessageTemplateContext
   * @ojpreferredcontent ["MessageElement"]
   *
   * @example <caption>Initialize oj-messages with an inline message template specified:</caption>
   * &lt;oj-messages messages="[[dataProvider]]">
   *   &lt;template slot="messageTemplate">
   *     &lt;oj-message message="[[$current.data]]">&lt;/oj-message>
   *   &lt;template>
   * &lt;/oj-messages>
   */

  // Methods
  // ////////

  /**
   * Closes the specified message regardless of the {@link oj.ojMessage#message.autoTimeout} or
   * {@link oj.ojMessage#message.closeAffordance} properties. The <code>message</code> argument
   * is a required argument, must be of type {@link oj.ojMessage#message}, and must be the same object
   * instance that was used to create and show the oj-message.
   *
   * <p>Closing a message changes the visibility to hidden. If the message is defined by an instance
   * in the {@link oj.ojMessages#messages} collection, the close operation will not remove the item
   * from the backing model. Application logic needs to listen for the
   * {@link oj.ojMessage#event:close} event bubbling up from the underlying oj-message child to remove
   * from the backing collection.</p>
   *
   * @expose
   * @function close
   * @ojshortdesc Unconditionally closes the specified message. See the Help documentation for more information.
   * @memberof! oj.ojMessages
   * @instance
   * @since 5.0.0
   * @param {Object} message The message to be closed.
   * @return {void}
   * @ojsignature {target:"Type", value:"oj.ojMessage.Message", for:"message", jsdocOverride: true}
   *
   * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
   * myMessages.close(myMessage.message);
   */

  /**
   * Closes child messages matching the <code>closeFilter</code> callback criteria.
   * The <code>closeFilter</code> callback is an optional argument. If not specified, all child
   * messages will be closed. If filter is specified, object of type {@link oj.ojMessage#message}
   * corresponding to each child will be passed to the <code>closeFilter</code> function. A return
   * value of <code>true</code> will result in calling {@link oj.ojMessage#close} for the message.
   * Otherwise, the message will remain in its current state.
   *
   * <p>Closing a message changes the visibility to hidden. If the message is defined by an instance
   * in the {@link oj.ojMessages#messages} collection, the close operation will not remove the item
   * from the backing model. Application logic needs to listen for the
   * {@link oj.ojMessage#event:close} event bubbling up from the underlying oj-message child to remove
   * from the backing collection.</p>
   *
   * @expose
   * @function closeAll
   * @ojshortdesc Closes all child messages matching an optional filter criteria. See the Help documentation for more information.
   * @memberof! oj.ojMessages
   * @instance
   * @since 5.0.0
   * @param {function} [closeFilter] An optional callback function that will be passed an instance
   *                   of type {@link oj.ojMessage#message} for each child
   *                   oj-message.  If <code>closeFilter</code> returns <code>true</code>, the
   *                   associated oj-message will be closed.  Returning <code>false</code> will
   *                   exclude the child message from closure.  If a <code>closeFilter</code> is not
   *                   passed, all child messages will be closed.
   * @return {void}
   * @ojsignature {target: "Type",
   *               value: "(message: oj.ojMessage.Message) => boolean",
   *               for: "closeFilter",
   *               jsdocOverride: true}
   *
   * @example <caption>Invoke the <code class="prettyprint">closeAll</code> method:</caption>
   * myMessages.closeAll(function (message)
   * {
   *   // close all messages of error severity
   *   return "error" === message.severity;
   * });
   */

  /**
   * Sets a property or a single subproperty for complex properties and notifies the component
   * of the change, triggering a [property]Changed event.
   *
   * @function setProperty
   * @ojshortdesc Sets a property or a single subproperty for complex properties and notifies the component of the change, triggering a corresponding event.
   * @param {string} property - The property name to set. Supports dot notation for subproperty access.
   * @param {any} value - The new value to set the property to.
   * @return {void}
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @since 5.0.0
   *
   * @example <caption>Set a single subproperty of a complex property:</caption>
   * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
   */

  /**
   * Retrieves a value for a property or a single subproperty for complex properties.
   * @function getProperty
   * @param {string} property - The property name to get. Supports dot notation for subproperty access.
   * @return {any}
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @since 5.0.0
   *
   * @example <caption>Get a single subproperty of a complex property:</caption>
   * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
   */

  /**
   * Performs a batch set of properties.
   * @function setProperties
   * @param {Object} properties - An object containing the property and value pairs to set.
   * @return {void}
   * @expose
   * @memberof! oj.ojMessages
   * @instance
   * @since 5.0.0
   *
   * @example <caption>Set a batch of properties:</caption>
   * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
   **/

  // Type Defs
  // //////////

  /**
   * @typedef {Object} oj.ojMessages.PositionAlign
   * @property {"top"|"bottom"|"center"} [vertical] Vertical alignment.
   * @property {"start"|"end"|"left"|"center"|"right"} [horizontal] Horizontal alignment. <p>
   * <ul>
   *  <li><b>"start"</b> evaluates to "left" in LTR mode and "right" in RTL mode.</li>
   *  <li><b>"end"</b> evaluates to "right" in LTR mode and "left" in RTL mode.</li>
   * </ul>
   *
   */

  /**
   * @typedef {Object} oj.ojMessages.PositionPoint
   * @property {number} [x] Horizontal alignment offset.
   * @property {number} [y] Vertical alignment offset.
   */
  /**
   * @typedef {Object} oj.ojMessages.MessageTemplateContext
   * @property {Element} componentElement The &lt;oj-messages> custom element.
   * @property {Object} data The data for the current message being rendered.
   * @ojsignature {target:"Type", value:"oj.ojMessage.Message", for:"data", jsdocOverride: true}
   */

  /**
   * @typedef {Object} oj.ojMessages.Position
   * @property {Object} [my] Defines which edge on the popup to align with the target ("of") element.
   * @property {Object} [at] Defines which position on the target element ("of") to align the positioned element
   *                                  against.
   * @property {Object} [offset] Defines a point offset in pixels from the ("my") alignment.
   * @property {string|Object} [of] Which element to position the popup against.
   *
   * If the value is a string, it should be a selector or the literal string value
   * of <code class="prettyprint">window</code>.  Otherwise, a point of x,y.  When a point
   * is used, the values are relative to the whole document.  Page horizontal and vertical
   * scroll offsets need to be factored into this point - see UIEvent
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageX">pageX</a>,
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/pageY">pageY</a>.
   *
   * @property {"flip"|"fit"|"flipfit"|"none"} [collision] Rule for alternate alignment. <p>
   * <ul>
   *  <li><b>"flip"</b> the element to the opposite side of the target and the
   *             collision detection is run again to see if it will fit. Whichever side
   *             allows more of the element to be visible will be used. </li>
   * <li><b>"fit"</b> shift the element away from the edge of the window. </li>
   * <li><b>"flipfit"</b> first applies the flip logic, placing the element
   *  on whichever side allows more of the element to be visible. Then the fit logic
   *  is applied to ensure as much of the element is visible as possible.</li>
   * <li><b>"none"</b> no collision detection.</li>
   * </ul>
   * @ojsignature [{target:"Type", value:"oj.ojMessages.PositionAlign", for:"my", jsdocOverride:true},
   *               {target:"Type", value:"oj.ojMessages.PositionAlign", for:"at", jsdocOverride:true},
   *               {target:"Type", value:"oj.ojMessages.PositionPoint", for:"offset", jsdocOverride:true},
   *               {target:"Type", value:"string|oj.ojMessages.PositionPoint", for:"of", jsdocOverride:true}]
   */

  var _MESSAGES_VIEW =
    '<div role="presentation" :id="[[containerId]]" :class="[[containerSelectors]]" ' +
    '     on-oj-open="[[handleOpen]]" on-oj-close="[[handleClose]]" ' +
    '     on-oj-animate-start="[[handleAnimateStart]]">' +
    '  <oj-bind-if test="[[!$properties.messages]]">' +
    '    <oj-bind-slot>' +
    '    </oj-bind-slot>' +
    '  </oj-bind-if>' +
    '  <oj-bind-if test="[[$properties.messages]]">' +
    '    <oj-bind-for-each data="[[$properties.messages]]" >' +
    '      <template>' +
    '        <oj-bind-template-slot name="messageTemplate" ' +
    '          data="[[{data:$current.data, componentElement:_composite}]]">' +
    '          <template>' +
    '            <oj-message message="[[$current.data]]" display-options="[[$properties.displayOptions]]">' +
    '            </oj-message>' +
    '          </template>' +
    '        </oj-bind-template-slot>' +
    '      </template>' +
    '    </oj-bind-for-each>' +
    '  </oj-bind-if>' +
    '</div>';

  function MessagesViewModel(context) {
    this._composite = context.element;

    // Anything used by the view bindings or component methods can't be obfuscated
    // and is why it's defined in quotes.
    this.containerId = [context.unique, 'mc'].join('_');
    this._messagesContainerId = this.containerId;
    this.handleOpen = this._handleOpen.bind(this);
    this.handleClose = this._handleClose.bind(this);
    this.handleAnimateStart = this._handleAnimateStart.bind(this);
    this.bindingsApplied = this._bindingsApplied.bind(this);
    this.disconnected = this._disconnected.bind(this);
    this.connected = this._connected.bind(this);
    this.close = this._close.bind(this);
    this.closeAll = this._closeAll.bind(this);
    this.propertyChanged = this._propertyChanged.bind(this);

    this._properties = context.properties;
    this._createObservables();
    this._updateLandmark();

    //  When slideIn/out animation is used, like the defaults in notification messages, the
    //  the transformation starts from off viewport. For applications that use oj-messages inside of
    //  iFrame with 100% width/height *(eg. our cookbook demos), this works find in all cases except
    //  WebKit. WebKit has a bug that 100% is not respected, and iFrame is resized to accomodate its
    //  contents. In this case the transformation starting from outside the iFrame bounds triggers a
    //  resize, the resize event then results in popupservice calling in the refresh hook (the
    //  _refresh() method here), which will again position to top-end for notification message, which
    //  will be further off view-port further trigger resize and goes into blind look.
    // Workaround is to set overflow hidden on the containing oj-messages so that transformation due
    //  to animation is confined to its boundary, this will workaround iFrame resize bug in Webkit.
    if (oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS) {
      this._composite.style.overflow = 'hidden';
    }
  }

  MessagesViewModel.prototype._bindingsApplied = function () {
    // detects F6 navigation to the body content
    var messagesContainerDiv = this._composite.querySelector(`#${this._messagesContainerId}`);
    messagesContainerDiv.addEventListener('ojFocus', this._navigationEventListener.bind(this), false);

    // If 'messages' property is specified, we will not have inlined oj-message children.
    if (this._properties.messages) {
      // Defer showing messages until the first stamped oj-message child is created and ready to show.
      //  This is dealt with in beforeOpen handler. Animation override is dealt with in the
      //  animateStart listener.
      messagesContainerDiv.addEventListener('ojBeforeOpen', this._handleBeforeOpen.bind(this), false);
      return;
    }

    // If we had inlined oj-message children in the default slot, they are all created before the
    //  parent oj-messages is created, so oj-messages does not receive events from the inlined
    //  children. Deal with animate overriding open action for those messages here.
    var inlinedMessageChildren = this._getDefaultSlotMessageElements();
    if (inlinedMessageChildren.length !== 0) {
      // Add a busy state before we start animating open action for all inlined oj-message children
      var busyContext = Context.getContext(this._composite).getBusyContext();
      this._inlinedMessagesOpenBusyStateResolve = busyContext.addBusyState({
        description: 'oj-messages is busy opening inlined messages'
      });

      this._showMessagesContainer();
      for (var i = 0; i < inlinedMessageChildren.length; i++) {
        this._animateMessageAction(
          inlinedMessageChildren[i].firstChild,
          'open',
          this._resolveInlinedMessagesOpenBusyState(
            inlinedMessageChildren[i].getProperty('message'),
            inlinedMessageChildren.length
          )
        );
      }
    }
  };

  MessagesViewModel.prototype._resolveInlinedMessagesOpenBusyState = function (
    message,
    numInlinedChildren
  ) {
    this._updateLiveRegionAndContainer(message);

    this._numInlinedChildrenAnimated = this._numInlinedChildrenAnimated
      ? this._numInlinedChildrenAnimated + 1
      : 1;

    if (this._numInlinedChildrenAnimated === numInlinedChildren) {
      this._numInlinedChildrenAnimated = 0;
      // Now that we are done open animating all inlined children, resolve the busy context
      this._inlinedMessagesOpenBusyStateResolve();
    }
  };

  MessagesViewModel.prototype._disconnected = function () {
    MessagesViewModel.NAVIGATION_TRACKER.remove(this._messagesContainerId);

    // detaching an open message overlay results in implicit dismissal
    if (oj.ZOrderUtils.getStatus(this._composite) === oj.ZOrderUtils.STATUS.OPEN) {
      this._closeOverlay();
    }
  };

  MessagesViewModel.prototype._connected = function () {
    MessagesViewModel.NAVIGATION_TRACKER.add(this._messagesContainerId);
  };

  MessagesViewModel.prototype._closeAll = function (closeFilter) {
    if (this._isMessagesShown()) {
      var messageChildren = this._getDefaultSlotMessageElements();
      for (var i = 0; i < messageChildren.length; i++) {
        var message = messageChildren[i].message;
        var closeable = true;
        if (closeFilter) {
          closeable = closeFilter(message);
        }
        if (closeable) {
          messageChildren[i].close();
        }
      }
    }
  };

  MessagesViewModel.prototype._propertyChanged = function (detail) {
    if (detail.updatedFrom === 'external' && detail.property === 'position') {
      if (detail.previousValue && detail.value) {
        // re-evaluate overlay position
        this._refresh();
      } else if (!detail.previousValue && detail.value) {
        // inline to overlay
        if (this._getDefaultSlotMessageElements().length > 0) {
          if (this._isMessagesShown()) {
            this._hideMessages();
          }

          this._openOverlay();
        }
      } else if (detail.previousValue && !detail.value) {
        // overlay to inline
        if (this._getDefaultSlotMessageElements().length > 0) {
          if (this._isOverlayOpen()) {
            this._closeOverlay();
          }

          this._showMessages();
        }
      }
    } else if (detail.updatedFrom === 'external' && detail.property === 'display') {
      if (this._getDefaultSlotMessageElements().length > 0) {
        if (this._isOverlayOpen()) {
          this._closeOverlay();
          this._openOverlay();
          this._refresh();
        } else if (this._isMessagesShown()) {
          this._hideMessages();
          this._showMessages();
        }
      }
    } else if (detail.updatedFrom === 'external' && detail.property === 'translations') {
      this._updateLandmark();
    }
  };

  MessagesViewModel.prototype._close = function (message) {
    if (message && this._isMessagesShown()) {
      var messageChildren = this._getDefaultSlotMessageElements();
      for (var i = 0; i < messageChildren.length; i++) {
        /** @type {?} */
        var childMessage = $(messageChildren[i]).prop('message');
        if (childMessage === message) {
          messageChildren[i].close();
        }
      }
    }
  };

  MessagesViewModel.prototype._isEventPertaining = function (event) {
    // verify the event is from a child message
    var target = event.target;
    var messagesContainerDiv = document.getElementById(this._messagesContainerId);
    if (target.nodeName !== 'OJ-MESSAGE' || !DomUtils.isAncestor(messagesContainerDiv, target)) {
      return false;
    }
    return true;
  };

  MessagesViewModel.prototype._handleBeforeOpen = function (event) {
    if (!event.defaultPrevented && this._isEventPertaining(event) && !this._isMessagesShown()) {
      this._showMessagesContainer();
    }
  };

  MessagesViewModel.prototype._showMessagesContainer = function () {
    if (!this._isPresentationInline()) {
      this._openOverlay();
    } else {
      this._showMessages();
    }
  };

  MessagesViewModel.prototype._handleOpen = function (event) {
    // verify the event is from a child message
    if (event.defaultPrevented || !this._isEventPertaining(event)) {
      return;
    }

    this._updateLiveRegionAndContainer(event.detail.message);
  };

  MessagesViewModel.prototype._updateLiveRegionAndContainer = function (message) {
    const translations = Translations.getComponentTranslations('oj-ojMessage').categories;

    // oj.Message has 'fatal' severity which is no different from 'error', oj-message does not support
    //  'fatal' for this reason. Map 'fatal' to 'error' just to be compatible with cases where the
    //  message stream could come from existing oj.Message sources.
    const severity = (message.severity === 'fatal' ? 'error' : message.severity) || 'none';
    const category = !message.category ? translations[severity] : message.category;
    // check if the message has detail text or not (as it is an optional property)
    // and determine which translation resource needs to be used.
    const options = {
      category: category,
      summary: message.summary,
      detail: message.detail || this._getTranslationsDefault('ariaLiveRegion.noDetail')
    };

    const liveRegion = this._getLiveRegion();
    const text = this._getTranslationsDefault('ariaLiveRegion.newMessage', options);
    liveRegion.announce(text);

    this._refresh(); // re-evaluate the position as the overlay size can change.
  };

  MessagesViewModel.prototype._getTranslationsDefault = function (key, options) {
    var val = this._properties.translations;
    var keySegments = key.split('.');

    // key is a dot separated qualifier, break it so we can use in [] notation to access sub-props
    for (var i = 0; i < keySegments.length && val; i++) {
      val = val[keySegments[i]];
    }

    if (oj.StringUtils.isEmptyOrUndefined(val)) {
      val = Translations.getTranslatedString(['oj-ojMessages', key].join('.'), options);
    } else if (options) {
      // if app dev specified and we have params, insert those for tokens possible in the val
      val = Translations.applyParameters(val, options);
    }

    return val;
  };

  MessagesViewModel.prototype._handleClose = function (event) {
    // verify the event is from a child message
    if (event.defaultPrevented || !this._isEventPertaining(event)) {
      return;
    }

    // look for next focus
    var closeMessageElement = event.target;
    var nextFocusElement;

    // If the event was triggered from the close icon, the originalEvent will be populated
    // Next focus is only needed when closure was from the close icon.  autoTimeout closure
    // shouldn't insist on focus handling.
    if (event._originalEvent) {
      nextFocusElement = this._getNextFocus(closeMessageElement);
    }

    if (nextFocusElement) {
      nextFocusElement.focus();
    }

    // remove the oj-message from DOM. Note that we are not calling 'oj.Components.subtreeHidden'
    //  because it is not required if we use jquery remove() as per the doc there
    $(closeMessageElement).remove();

    // if we do not have any "default" slot children, then the message being closed is the last one,
    //  close/hide the containers hence
    if (this._getDefaultSlotMessageElements().length === 0) {
      MessagesViewModel.NAVIGATION_TRACKER.togglePreviousFocus(this._messagesContainerId);

      if (this._isOverlayOpen()) {
        this._closeOverlay();
      } else {
        this._hideMessages();
      }
    } else {
      // If there are remaining messages, we need to reposition them if they are being shown in
      // an overlay
      // Call _refresh to do this, and no need to check for overlay to be open as the _refresh
      // method does the check reposition only if the overlay is open.
      this._refresh();
    }
  };

  MessagesViewModel.prototype._getNextFocus = function (target) {
    var messageElements = this._getDefaultSlotMessageElements();
    var n = messageElements.indexOf(target);
    var nextFocusMessage;
    if (n - 1 > -1) {
      nextFocusMessage = messageElements[n - 1];
    } else if (n + 1 <= messageElements.length - 1) {
      nextFocusMessage = messageElements[n + 1];
    }

    var nextFocusElement;
    if (nextFocusMessage) {
      nextFocusElement = nextFocusMessage.querySelector('.oj-message-category[tabindex="-1"]');
    }

    return nextFocusElement;
  };

  MessagesViewModel.prototype._handleAnimateStart = function (event) {
    if (event.defaultPrevented || !this._isEventPertaining(event)) {
      return; // animateStart already overridden on the individual oj-message.
    }

    // eat the event bubbling up from a child oj-message component
    event.preventDefault();

    // override animation
    this._animateMessageAction(event.detail.element, event.detail.action, event.detail.endCallback);
  };

  MessagesViewModel.prototype._animateMessageAction = function (messageElement, action, endCallback) {
    var display = this._isPresentationInline() ? 'general' : this._computeDisplay();
    var options = this._getThemedAnimateOptions(display, action);

    // oj-messages doesn't publish animateStart/animateEnd so use the simpler syntax for now and allow
    // the event to bubble.
    // oj.AnimationUtils.startAnimation(messageElement, action, options, component).then(endCallback);
    // eslint-disable-next-line no-undef
    AnimationUtils[options.effect](messageElement, options).then(endCallback);
  };

  MessagesViewModel._DEFAULTS = {
    general: {
      animation: {
        open: { effect: 'expand', duration: '300ms' },
        close: { effect: 'collapse', duration: '300ms' }
      },
      position: {
        my: { horizontal: 'center', vertical: 'top' },
        at: { horizontal: 'center', vertical: 'top' },
        of: 'window',
        collision: 'none'
      }
    },
    notification: {
      animation: {
        open: { effect: 'slideIn', duration: '300ms' },
        close: { effect: 'slideOut', duration: '300ms', direction: 'end' }
      },
      position: {
        my: { horizontal: 'end', vertical: 'top' },
        at: { horizontal: 'end', vertical: 'top' },
        of: 'window',
        collision: 'none'
      }
    }
  };

  MessagesViewModel.prototype._getThemedAnimateOptions = function (display, action) {
    var themedDefaults = ThemeUtils.parseJSONFromFontFamily('oj-messages-option-defaults');
    if (
      themedDefaults &&
      themedDefaults[display] &&
      themedDefaults[display].animation &&
      themedDefaults[display].animation[action]
    ) {
      return themedDefaults[display].animation[action];
    }
    return MessagesViewModel._DEFAULTS[display].animation[action];
  };

  MessagesViewModel.prototype._computeDisplay = function () {
    return this._properties.display;
  };

  MessagesViewModel.prototype._isPresentationInline = function () {
    return !this._properties.position;
  };

  MessagesViewModel.prototype._computeContainerSelectors = function () {
    var display = this._computeDisplay();
    var composite = $(this._composite);

    // something about the layout changed, take this opp. to update classes on the root element
    composite.removeClass('oj-messages-general oj-messages-notification oj-messages-inline');

    if (this._isPresentationInline()) {
      composite.addClass('oj-messages-inline');
    } else {
      composite.addClass(['oj-messages', display].join('-'));
    }

    // a bogus binding on the view, and we return a literal here, but provides a convenient way to be
    //  able to set classes on the root element when the underlying observables change
    return 'oj-messages-container';
  };

  MessagesViewModel.prototype._getThemedPosition = function () {
    var display = this._computeDisplay();
    var themedDefaults = ThemeUtils.parseJSONFromFontFamily('oj-messages-option-defaults');
    if (themedDefaults[display] && themedDefaults[display].position) {
      return themedDefaults[display].position;
    }
    return MessagesViewModel._DEFAULTS[display].position;
  };

  MessagesViewModel.prototype._getPositionAsJqUi = function () {
    var position = oj.PositionUtils.coerceToJqUi(this._computePosition());
    var isRtl = DomUtils.getReadingDirection() === 'rtl';
    position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);
    return position;
  };

  MessagesViewModel.prototype._computePosition = function () {
    var position = this._properties.position;
    return oj.PositionUtils.coerceToJet(position, this._getThemedPosition());
  };

  MessagesViewModel.prototype._getDefaultSlotMessageElements = function () {
    var element = this._composite.querySelector(`#${this._messagesContainerId}`);

    var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(element);
    var messageElements = [];

    // we just need to deal with "default" slot
    var body = slotMap['']; // default slot
    for (var i = 0; body && i < body.length; i++) {
      // any element child node of oj-messages must be a oj-message, do this validation at times.
      if (body[i].nodeName !== 'OJ-MESSAGE') {
        // we included oj-bind-if in our view def, so make an exception
        if (body[i].nodeName !== 'OJ-BIND-IF') {
          Logger.error(
            'JET oj-messages: can contain only oj-message children in its default slot. ' +
              `Found <${body[i].nodeName}> instead.`
          );
        }
      } else {
        messageElements.push(body[i]);
      }
    }

    return messageElements;
  };

  MessagesViewModel.prototype._isMessagesShown = function () {
    return $(this._composite).is(':visible');
  };

  MessagesViewModel.prototype._showMessages = function () {
    if (!this._isMessagesShown()) {
      // unhide the oj-messages root and notify
      $(this._composite).show();
      Components.subtreeShown($(this._composite));
    }

    // When messages are shown in popup, popup.open() will call popup_elem.show(), which is a deep
    //  show() call in its subtree, so behind the scenes, our composite will have 'display:block'
    //  inline style set quietly. For this case _isMessagesShown() check is not reliable. Hence
    //  the accessibility enabling code below is outside of this check, when showing the messages.
    // This is not an issue when hiding the messages though, because the popup effect kicks in later.
    MessagesViewModel.NAVIGATION_TRACKER.add(this._messagesContainerId);
    this._announceNavigation();
  };

  MessagesViewModel.prototype._hideMessages = function () {
    if (this._isMessagesShown()) {
      // hide the oj-messages node root and notify
      $(this._composite).hide();
      Components.subtreeHidden(this._composite);

      MessagesViewModel.NAVIGATION_TRACKER.remove(this._messagesContainerId);
      if (this._liveRegion) {
        this._liveRegion.destroy();
        delete this._liveRegion;
      }
    }
  };

  MessagesViewModel.prototype._openOverlay = function () {
    var composite = $(this._composite);
    var psOptions = {};
    psOptions[oj.PopupService.OPTION.POPUP] = composite;
    psOptions[oj.PopupService.OPTION.LAUNCHER] = this._getLauncher();
    psOptions[oj.PopupService.OPTION.POSITION] = this._getPositionAsJqUi();
    psOptions[oj.PopupService.OPTION.EVENTS] = this._getPopupServiceEvents();

    psOptions[oj.PopupService.OPTION.LAYER_SELECTORS] = ['oj', 'messages', 'layer'].join('-');
    psOptions[oj.PopupService.OPTION.MODALITY] = oj.PopupService.MODALITY.MODELESS;
    psOptions[oj.PopupService.OPTION.CUSTOM_ELEMENT] = true;
    oj.PopupService.getInstance().open(psOptions);

    this._showMessages();

    this._overlayEventsCallback = MessagesViewModel._overlayEventsListener.bind(this, composite);

    // snap on tab key handler
    composite[0].addEventListener('keydown', this._overlayEventsCallback, false);
  };

  MessagesViewModel.prototype._getLauncher = function () {
    var launcher = this._composite.parentElement;

    if (this._composite.previousElementSibling) {
      launcher = this._composite.previousElementSibling;
    } else if (this._composite.nextElementSibling) {
      launcher = this._composite.nextElementSibling;
    }

    return $(launcher);
  };

  MessagesViewModel.prototype._closeOverlay = function () {
    this._hideMessages();

    var composite = $(this._composite);

    /** @type {!Object.<oj.PopupService.OPTION, ?>} */
    var psOptions = {};
    psOptions[oj.PopupService.OPTION.POPUP] = composite;
    oj.PopupService.getInstance().close(psOptions);

    // remove tab key handler
    var overlayEventsCallback = this._overlayEventsCallback;
    delete this._overlayEventsCallback;
    composite[0].removeEventListener('keydown', overlayEventsCallback, false);
  };

  MessagesViewModel.prototype._isOverlayOpen = function () {
    var composite = this._composite;
    var status = oj.ZOrderUtils.getStatus(composite);
    return (
      status === oj.ZOrderUtils.STATUS.OPENING ||
      status === oj.ZOrderUtils.STATUS.OPEN ||
      status === oj.ZOrderUtils.STATUS.CLOSING
    );
  };

  MessagesViewModel._overlayEventsListener = function (element, event) {
    if (event.defaultPrevented) {
      return;
    }

    // keyCode is deprecated and it's not supported on some browsers.
    if (event.keyCode === $.ui.keyCode.TAB || event.key === 'Tab') {
      var target = event.target;
      var nodes = element.find(':tabbable');
      if (nodes.length > 0) {
        var firstNode = nodes[0];
        var lastNode = nodes[nodes.length - 1];
        if (firstNode === lastNode && target === firstNode) {
          // only one tabstop and key event is on the last/first, eat the event
          event.preventDefault();
        } else if (firstNode === target && event.shiftKey) {
          // tabbing backwards, cycle focus to last node
          event.preventDefault();
          lastNode.focus(); // tabbing backwards, cycle focus to last node
        } else if (lastNode === target && !event.shiftKey) {
          event.preventDefault();
          firstNode.focus(); // tabbing forwards, cycle to the first node
        }
      } else {
        // no tab stops, eat tab event
        event.preventDefault();
      }
    }
  };

  /**
   * Listens for the ojFocus event fired on the messages container by the navigation
   * tracker. Signals the navigation tracker has forced focus to the messages container
   * in response to F6 keypress from outside the messages container.
   *
   * @private
   * @instance
   * @param {Event|CustomEvent} event
   */
  MessagesViewModel.prototype._navigationEventListener = function (event) {
    // The extra id check to to make sure the event is not from ojDialog or ojPopup
    // The dialog and popup raise ojFocus events but the ojFocus raised from the
    // messages navigation tracker is dispatched on the container and doesn't bubble.
    if (event.target.id === this._messagesContainerId) {
      event.preventDefault();
      this._announceNavigation(true);
    }
  };

  /**
   * Announces F6 navigation commands depending on if focus is within the message region
   * and the platform (mobile, desktop).
   *
   * @private
   * @instance
   * @param {boolean=} isFocusWithin true if focus navigation is to the messages container
   */
  MessagesViewModel.prototype._announceNavigation = function (isFocusWithin) {
    var isVOSupported =
      oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.IOS ||
      oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;
    var key;
    if (isFocusWithin) {
      key = isVOSupported ? undefined : 'ariaLiveRegion.navigationFromKeyboard';
    } else {
      key = isVOSupported
        ? 'ariaLiveRegion.navigationToTouch'
        : 'ariaLiveRegion.navigationToKeyboard';
    }

    if (key) {
      var liveRegion = this._getLiveRegion();
      var message = this._getTranslationsDefault(key);
      liveRegion.announce(message);
    }
  };

  MessagesViewModel.prototype._getLiveRegion = function () {
    var id = this._messagesContainerId;
    if (!this._liveRegion) {
      this._liveRegion = new LiveRegion(id);
    }

    return this._liveRegion;
  };

  MessagesViewModel.prototype._getPopupServiceEvents = function () {
    var events = {};
    events[oj.PopupService.EVENT.POPUP_CLOSE] = this._closeOverlay.bind(this);
    events[oj.PopupService.EVENT.POPUP_REMOVE] = this._surrogateRemoveHandler.bind(this);
    events[oj.PopupService.EVENT.POPUP_REFRESH] = this._refresh.bind(this);

    return events;
  };

  MessagesViewModel.prototype._refresh = function () {
    if (this._isOverlayOpen()) {
      var messagesBoundingRect = this._composite.getBoundingClientRect();

      // We will reposition only if messages are fully in viewport. Otherwise overflowing messages
      //  cannot be scrolled with page scroll since our popup repositions for scroll events.
      if (
        messagesBoundingRect.height < document.documentElement.clientHeight &&
        messagesBoundingRect.width < document.documentElement.clientWidth
      ) {
        var position = this._getPositionAsJqUi();
        $(this._composite).position(position);
      }
    }
  };

  MessagesViewModel.prototype._surrogateRemoveHandler = function () {
    var composite = $(this._composite);
    if (oj.ZOrderUtils.getStatus(composite) === oj.ZOrderUtils.STATUS.OPEN) {
      ojcustomelementUtils.CustomElementUtils.cleanComponentBindings(composite[0]);
      this._closeOverlay();
    }
  };

  MessagesViewModel.prototype._createObservables = function () {
    // this can't be obfuscated by the closure compiler
    this.containerSelectors = ko.pureComputed(this._computeContainerSelectors.bind(this), this);
  };

  MessagesViewModel.prototype._computeLabelLandmark = function () {
    var properties = this._properties;

    if (oj.StringUtils.isEmptyOrUndefined(properties.translations.labelLandmark)) {
      return this._getTranslationsDefault('labelLandmark');
    }

    return properties.translations.labelLandmark;
  };

  MessagesViewModel.prototype._updateLandmark = function () {
    var labelLandmark = this._computeLabelLandmark();
    this._composite.setAttribute('aria-label', labelLandmark);
    this._composite.setAttribute('role', 'complementary');
  };

  /**
   * Tracks all visible instances of oj-messages and handles F6 navigation to the the most
   * recently disclosed instance.  In addtion, F6 navigation from the messages back to the
   * last focus element.
   *
   * @const
   * @type {Object}
   */
  MessagesViewModel.NAVIGATION_TRACKER = {
    /**
     * @type {Array.<string>}
     */
    _messagesContainerIds: [],
    /**
     * @type {Object}
     */
    _priorFocusCache: {},
    /**
     * @param {string} id
     */
    add: function (id) {
      // adds tracking of the messages container when it becomes disclosed.

      this.remove(id);
      this._messagesContainerIds.push(id);
      this._start(id);
    },
    /**
     * @param {string} id
     */
    remove: function (id) {
      // disabled tracking the message container when it's not disclosed

      var messagesContainerIds = this._messagesContainerIds;
      var i = messagesContainerIds.indexOf(id);
      if (i > -1) {
        messagesContainerIds.splice(i, 1);
      }

      this._stop(id);
    },
    /**
     * @param {string} id
     */
    togglePreviousFocus: function (id) {
      // Restore focus from the messages container to what had focus prior to establishing
      // focus within the messages container. Invoked from press F6 within the messages
      // container.

      var priorFocusCache = this._priorFocusCache;

      /** @type {Element} */
      var target = priorFocusCache[id];

      if (target && $(target).is(':visible') && oj.ZOrderUtils.isAboveTopModalLayer(target)) {
        target.focus();
        delete priorFocusCache[id];
        return true;
      }
      return false;
    },
    /**
     * @param {string} id
     * @param {Element|undefined} target
     */
    _addPriorFocusCache: function (id, target) {
      // Captures the element that had focus prior to navigation to a messages container.
      // navigation can be via F6 or mouse.

      this._priorFocusCache[id] = target;
    },
    /**
     * @param {string} id
     */
    _start: function (id) {
      // Establishes listeners on the message container.  Adds the document listeners if
      // it's the first messages container shown.

      var messagesContainerDiv = document.getElementById(id);
      if (!messagesContainerDiv) {
        return;
      }

      // establish capture focus and keydown bubble listener on the container
      var messageContainerCallback = this._messageContainerListener.bind(this, id);
      messagesContainerDiv.addEventListener('focus', messageContainerCallback, true);
      messagesContainerDiv.addEventListener('keydown', messageContainerCallback, false);
      messagesContainerDiv.addEventListener('click', messageContainerCallback, false);
      $(messagesContainerDiv).data('oj_messages_nmtl', messageContainerCallback);

      // return if already listening
      if (this._documentCallback) {
        return;
      }

      this._documentCallback = this._documentListener.bind(this);
      var docElement = document.documentElement;
      docElement.addEventListener('keydown', this._documentCallback, false);
      docElement.addEventListener('blur', this._documentCallback, true);
    },
    /**
     * @param {string} id
     */
    _stop: function (id) {
      // Removes message container listeners when the messages container is hidden.
      // Hidding the last message container will remove the listeners on the document.

      var messagesContainerDiv = document.getElementById(id);
      if (messagesContainerDiv) {
        /** @type {?} */
        var messageContainerCallback = $(messagesContainerDiv).data('oj_messages_nmtl');
        if (messageContainerCallback) {
          messagesContainerDiv.removeEventListener('focus', messageContainerCallback, true);
          messagesContainerDiv.removeEventListener('keydown', messageContainerCallback, false);
          messagesContainerDiv.removeEventListener('click', messageContainerCallback, false);
        }
      }

      if (!this._documentCallback || this._messagesContainerIds.length > 0) {
        return;
      }

      var docElement = document.documentElement;
      docElement.removeEventListener('keydown', this._documentCallback, false);
      docElement.removeEventListener('blur', this._documentCallback, true);
      delete this._documentCallback;
    },
    /**
     * @param {!Element} target
     * @return {number}
     */
    _indexOfFocusWithin: function (target) {
      // checks if the target of the F6 keydown is within a messages container.
      var messagesContainerIds = this._messagesContainerIds;
      for (var i = 0; i < messagesContainerIds.length; i++) {
        var messagesContainerDiv = document.getElementById(messagesContainerIds[i]);
        if (messagesContainerDiv && DomUtils.isAncestorOrSelf(messagesContainerDiv, target)) {
          return i;
        }
      }

      return -1;
    },
    /**
     * @param {Event} event
     */
    _documentListener: function (event) {
      if (event.defaultPrevented) {
        return;
      }

      // Listeners for F6 navigation to the messages region from any element in the document.  The
      // listener is a bubble keydown.  If the event has been prevented, it's ignored.  If
      // there are multiple oj-messages components in the page, the selection is based on the
      // most recently disclosed order.

      var messagesContainerIds = this._messagesContainerIds;
      // F6 keypress
      // keyCode is deprecated and it's not supported on some browsers.
      if (
        event.type === 'keydown' &&
        (event.keyCode === 117 || event.key === 'F6') &&
        messagesContainerIds.length > 0
      ) {
        // Look to see if the event target is already within a message area.  If focus is within
        // do nothing as the F6 listener on the mesage area will handle.
        var s = this._indexOfFocusWithin(event.target);
        if (s > -1) {
          return; // @see #_messageContainerListener
        }
        s = messagesContainerIds.length - 1;

        // target the most recently disclosed
        for (var i = s; i > -1; i--) {
          var messagesContainerDiv = document.getElementById(messagesContainerIds[i]);

          // if the container doesn't exist or is not visible continue to the next most recently used
          if (
            messagesContainerDiv &&
            $(messagesContainerDiv).is(':visible') &&
            oj.ZOrderUtils.isAboveTopModalLayer(messagesContainerDiv)
          ) {
            // At this point we need to focus the title of the current message element.
            // A message by default has a category text, and that should be the one that
            // receives the initial focus. But, when the category text is hidden, the summary
            // text will be used in its place.
            // Both of these cases can be selected by using the common selector oj-message-title
            var element = messagesContainerDiv.querySelector('.oj-message-title[tabindex="-1"]');

            event.preventDefault();

            // captrue what had focus prior to pressing F6
            this._addPriorFocusCache(messagesContainerIds[i], event.target);

            element.focus();

            // Use a custom message to signal navigation to the messages container. The event doesn't
            // bubble. The event is used to announce navigation instructions.
            var customEvent = new CustomEvent('ojFocus', { bubbles: false, cancelable: true });
            messagesContainerDiv.dispatchEvent(customEvent);
            break;
          }
        }
      } else if (event.type === 'blur') {
        // capture blur listener used to keep track of what last had focus
        this._prevActiveElement = event.target;
      }
    },
    /**
     * @param {string} id
     * @param {Event} event
     */
    _messageContainerListener: function (id, event) {
      // capture focus and bubble keydown event listener attached to visible message containers

      if (event.defaultPrevented) {
        return;
      }

      if (event.type === 'focus' || event.type === 'click') {
        // if prior focus was outside the messgaes container and new focus is within, capture
        // what had prior focus. This is the best attempt to capture F2 navigation when using
        // mouse or touch to navigate to the message container versus F2 keyboard.

        /** @type {?} */
        var messagesContainerDiv = document.getElementById(id);
        var prevActiveElement = this._prevActiveElement;
        if (
          prevActiveElement &&
          messagesContainerDiv &&
          !DomUtils.isAncestorOrSelf(messagesContainerDiv, prevActiveElement)
        ) {
          // attached to visible message components.  Tracks previous focus.
          this._addPriorFocusCache(id, prevActiveElement);
        }
      } else if (
        event.type === 'keydown' &&
        (event.keyCode === 117 ||
          event.keyCode === $.ui.keyCode.ESCAPE ||
          event.key === 'F6' ||
          event.key === 'Escape')
      ) {
        // F6 or ESC keypress from within the content of the messages container will toggle focus back
        // to to what had prior focus. An attempt is made to fixup the navigate even if arriving
        // using the mouse or touch.
        // keyCode is deprecated and it's not supported on some browsers.
        if (this.togglePreviousFocus(id)) {
          event.preventDefault();
        }
      }
    }
  };

  /**
   * Utility for handling voice over messages sent to a aria live region.  Messages
   * announced will not be deleted until the live region utility instance is destroyed.
   * They are not cleared due to the chattiness and quick timming messages can be added
   * as it could be too quick to read.
   * @private
   * @constructor
   * @class LiveRegion
   * @ignore
   * @ojtsignore
   * @param {string} id of the messages container
   */
  function LiveRegion(id) {
    this.Init(id);
  }

  /**
   * Adds one to the reference counter instance.
   * @instance
   * @protected
   */
  LiveRegion.prototype.Init = function (id) {
    this._id = id;
  };

  /**
   * Decrements the reference counter destroying the assocaited shared DOM aria
   * live region element when there are no longer any messages using it.
   * @instance
   * @public
   */
  LiveRegion.prototype.destroy = function () {
    var liveRegion = $(document.getElementById(LiveRegion._LIVE_REGION_ID));

    // remove all the messages per messages container
    var id = this._id;
    delete this._id;

    liveRegion.find('div[data-container-id="' + id + '"]').remove();

    if (liveRegion.children('div').length < 1) {
      liveRegion.remove();
    }
  };

  /**
   * Sends a message to the aria live region for voice over mode.
   * @instance
   * @public
   * @param {string} message to be announce in the live region
   */
  LiveRegion.prototype.announce = function (message) {
    var liveRegion = LiveRegion._getLiveRegion();
    var id = this._id;
    $('<div>').attr('data-container-id', id).text(message).appendTo(liveRegion); // @HTMLUpdateOK
  };

  /**
   * Creates or returns an existing aria live region used by messages.
   * @returns {jQuery} aria live region
   * @private
   */
  LiveRegion._getLiveRegion = function () {
    var liveRegion = $(document.getElementById(LiveRegion._LIVE_REGION_ID));
    if (liveRegion.length === 0) {
      // only tracks additions
      liveRegion = $('<div>');
      liveRegion.attr({
        id: LiveRegion._LIVE_REGION_ID,
        role: 'log',
        'aria-live': 'polite',
        'aria-relevant': 'additions'
      });
      liveRegion.addClass('oj-helper-hidden-accessible');
      liveRegion.appendTo(document.body); // @HTMLUpdateOK
    }
    return liveRegion;
  };

  LiveRegion._LIVE_REGION_ID = '__oj_messages_arialiveregion';

var __oj_messages_metadata = 
{
  "properties": {
    "display": {
      "type": "string",
      "enumValues": [
        "general",
        "notification"
      ],
      "value": "general"
    },
    "displayOptions": {
      "type": "object",
      "properties": {
        "category": {
          "type": "string",
          "enumValues": [
            "auto",
            "header",
            "none"
          ],
          "value": "auto"
        }
      }
    },
    "messages": {
      "type": "Array<Object>|object"
    },
    "position": {
      "type": "object",
      "properties": {
        "at": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ]
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ]
            }
          }
        },
        "collision": {
          "type": "string",
          "enumValues": [
            "fit",
            "flip",
            "flipfit",
            "none"
          ]
        },
        "my": {
          "type": "object",
          "properties": {
            "horizontal": {
              "type": "string",
              "enumValues": [
                "center",
                "end",
                "left",
                "right",
                "start"
              ]
            },
            "vertical": {
              "type": "string",
              "enumValues": [
                "bottom",
                "center",
                "top"
              ]
            }
          }
        },
        "of": {
          "type": "string"
        },
        "offset": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number"
            },
            "y": {
              "type": "number"
            }
          }
        }
      }
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaLiveRegion": {
          "type": "object",
          "properties": {
            "navigationFromKeyboard": {
              "type": "string"
            },
            "navigationToKeyboard": {
              "type": "string"
            },
            "navigationToTouch": {
              "type": "string"
            },
            "newMessage": {
              "type": "string"
            },
            "noDetail": {
              "type": "string"
            }
          }
        },
        "labelLandmark": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "close": {},
    "closeAll": {},
    "getProperty": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_messages_metadata */
  // eslint-disable-next-line no-undef
  Composite.register('oj-messages', {
    view: _MESSAGES_VIEW,
    viewModel: MessagesViewModel,
    metadata: __oj_messages_metadata
  });

});


define('ojs/ojconveyorbelt',['ojs/ojcore-base', 'jquery', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojdomutils', 'touchr'], function (oj, $, ThemeUtils, Components, Logger, Context, Config, DomUtils, touchr) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

var __oj_conveyor_belt_metadata = 
{
  "properties": {
    "arrowVisibility": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "auto",
        "hidden",
        "visible"
      ]
    },
    "contentParent": {
      "type": "string",
      "writeback": true
    },
    "orientation": {
      "type": "string",
      "writeback": true,
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "horizontal"
    },
    "scrollPosition": {
      "type": "number",
      "writeback": true,
      "value": 0
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "tipArrowNext": {
          "type": "string"
        },
        "tipArrowPrevious": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "scrollElementIntoView": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_conveyor_belt_metadata:false */
  (function () {
    __oj_conveyor_belt_metadata.extension._WIDGET_NAME = 'ojConveyorBelt';
    oj.CustomElementBridge.register('oj-conveyor-belt', { metadata: __oj_conveyor_belt_metadata });
  })();

  /*
   ** Important:
   ** - This file is designed to be shared verbatim among the ADFui products.
   ** - Do not add framework-specific dependencies in this file (it must be self-contained).
   ** - Do not change this file without testing it in other ADFui products (ADF Faces, JET, etc.).
   */

  /**
   * Constructor.
   * @param {Object} elem DOM element associated with the conveyor
   * @param {string} orientation Direction of scrolling, either horizontal or vertical
   * @param {Object} contentParent DOM element whose children are the items to scroll
   * @param {boolean} bRtl True if the reading direction is right-to-left, otherwise false
   * @param {Object} buttonInfo Map of properties for the following button information:
   *  - arrowVisibility: 'visible'/'hidden' if arrow buttons should be visible/hidden
   *  - prevButtonStyleClass: Style class name to use for the scroll previous button,
   *  - nextButtonStyleClass: Style class name to use for the scroll next button,
   *  - prevButtonIcon: Icon element to use for the scroll previous button,
   *  - nextButtonIcon: Icon element to use for the scroll next button,
   * @param {Object} callbackInfo Map of properties for the following callback information:
   *  - scrollFunc: Callback function to animate scrolling a DOM element,
   *  - addResizeListener: Callback function to add a resize listener for a DOM element
   *  - removeResizeListener: Callback function to remove a resize listener for a DOM element
   *  - addStyleClassName: Callback function to add a style class name to a DOM element
   *  - removeStyleClassName: Callback functin to remove a style class name from a DOM element
   *  - hasStyleClassName: Callback function to check whether a style class name is applied
   *    to a DOM element,
   *  - filterContentElements: Callback function to filter the array of conveyor content elements,
   *  - subtreeAttached: Callback function to notify when a DOM subtree is attached,
   *  - subtreeDetached: Callback function to notify when a DOM subtree is detached,
   *  - addBusyState: Callback function to add a busy state to the busy context,
   *    has changed
   * @param {Object} styleInfo Map of properties for the following style information:
   *  - overflowContainerStyleClass: Style class name for the overflow container DOM element,
   *  - contentContainerStyleClass: Style class name for the content container DOM element,
   *  - itemStyleClass: Style class name for the DOM element of an item in the conveyor,
   *  - hiddenStyleClass: Style class name used to hide a DOM element
   * @param {Object} agentInfo Browser user agent information.
   * @class ConveyorBeltCommon
   * @memberof ConveyorBeltCommon
   * @protected
   * @constructor
   * @ignore
   * @ojtsignore
   */
  function ConveyorBeltCommon(elem, options, buttonInfo, callbackInfo, styleInfo) {
    //  orientation, contentParent, bRtl, buttonInfo, callbackInfo, styleInfo) {
    this._elem = elem;
    this._orientation = options.orientation;
    this._contentParent = options.contentParent;
    this._scrollPosition = options.scrollPosition;
    this._bRtl = options.bRtl;
    this._arrowVisibility = buttonInfo.arrowVisibility;
    this._prevButtonStyleClass = buttonInfo.prevButtonStyleClass;
    this._nextButtonStyleClass = buttonInfo.nextButtonStyleClass;
    this._prevButtonIcon = buttonInfo.prevButtonIcon;
    this._nextButtonIcon = buttonInfo.nextButtonIcon;

    this._scrollFunc = callbackInfo.scrollFunc;
    this._addResizeListenerFunc = callbackInfo.addResizeListener;
    this._removeResizeListenerFunc = callbackInfo.removeResizeListener;
    this._addStyleClassNameFunc = callbackInfo.addStyleClassName;
    this._removeStyleClassNameFunc = callbackInfo.removeStyleClassName;
    this._hasStyleClassNameFunc = callbackInfo.hasStyleClassName;
    this._filterContentElementsFunc = callbackInfo.filterContentElements;
    this._subtreeDetachedFunc = callbackInfo.subtreeDetached;
    this._subtreeAttachedFunc = callbackInfo.subtreeAttached;
    this._addBusyStateFunc = callbackInfo.addBusyState;
    this._handleFocus = callbackInfo.handleFocus;
    this._setScrollPositionProperty = callbackInfo.setScrollPositionProperty;

    this._overflowContainerStyleClass = styleInfo.overflowContainerStyleClass;
    this._contentContainerStyleClass = styleInfo.contentContainerStyleClass;
    this._itemStyleClass = styleInfo.itemStyleClass;
    this._hiddenStyleClass = styleInfo.hiddenStyleClass;

    this._bExternalScroll = true;
    this._firstVisibleItemIndex = 0;
    this._atStart = true;
    this._atEnd = false;

    this._hasResources = false;
  }

  /**
   * Setup the conveyor belt.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.setup = function () {
    // create the content and overflow containers
    this._createInnerContainers();

    // create the next/prev buttons
    if (this._arrowVisibility === 'visible') {
      this._createPrevButton(this._prevButtonStyleClass, this._prevButtonIcon);
      this._createNextButton(this._nextButtonStyleClass, this._nextButtonIcon);

      var nextButton = this._nextButton;
      this._buttonWidth = Math.round($(nextButton).outerWidth(true));
      this._buttonHeight = Math.round($(nextButton).outerHeight(true));
    } else {
      this._buttonWidth = 0;
      this._buttonHeight = 0;
    }

    // hide the buttons until we know we need them
    this._hidePrevButton();
    this._hideNextButton();

    // set up listeners
    this.setupResources();

    // initial value from the scrollPosition option
    this._origScroll = this._scrollPosition;

    // clear any old sizes so that new sizes will be calculated
    this._clearCachedSizes();
    // adjust overflow size
    this._adjustOverflowSize(true);
    // handle an initial resize
    this._handleResize(true);

    // notify the child that it's being re-attached to the DOM AFTER attaching it
    // (the detached notification happened in _reparentChildrenToContentContainer())
    this._subtreeAttachedFunc(this._contentContainer);
  };

  /**
   * Setup the conveyor belt resources (mostly listeners).
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.setupResources = function () {
    if (this._hasResources) {
      return;
    }
    var self = this;
    var cbcClass = ConveyorBeltCommon;

    // handle the mouse wheel on the whole conveyor
    this._mouseWheelListener = function (event) {
      self._handleMouseWheel(event);
    };
    cbcClass._addBubbleEventListener(this._elem, 'mousewheel', this._mouseWheelListener, false);
    cbcClass._addBubbleEventListener(this._elem, 'wheel', this._mouseWheelListener, false);

    // handle swipe gestures on the overflow container, which excludes the next/prev buttons
    this._touchStartListener = function (event) {
      self._handleTouchStart(event);
    };
    cbcClass._addBubbleEventListener(
      this._overflowContainer,
      'touchstart',
      this._touchStartListener,
      true
    );
    this._touchMoveListener = function (event) {
      self._handleTouchMove(event);
    };
    cbcClass._addBubbleEventListener(
      this._overflowContainer,
      'touchmove',
      this._touchMoveListener,
      false
    );
    this._touchEndListener = function (event) {
      self._handleTouchEnd(event);
    };
    cbcClass._addBubbleEventListener(this._overflowContainer, 'touchend', this._touchEndListener);
    cbcClass._addBubbleEventListener(this._overflowContainer, 'touchcancel', this._touchEndListener);

    this._handleKeyDownFunc = function (event) {
      self._handleKeyDown(event);
    };

    cbcClass._addBubbleEventListener(this._elem, 'keydown', this._handleKeyDownFunc);

    this._handleFocusListener = function (event) {
      self._handleFocus(event);
    };
    this._elem.addEventListener('focus', this._handleFocusListener, {
      passive: false,
      capture: true
    });

    // eslint-disable-next-line no-unused-vars
    this._handleResizeFunc = function (width, height) {
      self._handleResize(false);
    };
    // listen for resizes on both the conveyor itself and on its content
    this._addResizeListenerFunc(this._elem, this._handleResizeFunc);
    this._addResizeListenerFunc(this._contentContainer, this._handleResizeFunc);

    this._hasResources = true;
  };

  /**
   * Release the conveyor belt resouces (listeners).
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.releaseResources = function () {
    if (!this._hasResources) {
      return;
    }
    var elem = this._elem;
    var cbcClass = ConveyorBeltCommon;

    cbcClass._removeBubbleEventListener(elem, 'mousewheel', this._mouseWheelListener, false);
    cbcClass._removeBubbleEventListener(elem, 'wheel', this._mouseWheelListener, false);
    cbcClass._removeBubbleEventListener(
      this._overflowContainer,
      'touchstart',
      this._touchStartListener,
      true
    );
    cbcClass._removeBubbleEventListener(
      this._overflowContainer,
      'touchmove',
      this._touchMoveListener,
      false
    );
    cbcClass._removeBubbleEventListener(this._overflowContainer, 'touchend', this._touchEndListener);
    cbcClass._removeBubbleEventListener(
      this._overflowContainer,
      'touchcancel',
      this._touchEndListener
    );
    cbcClass._removeBubbleEventListener(this._overflowContainer, 'scroll', this._scrollListener);
    cbcClass._removeBubbleEventListener(this._elem, 'keydown', this._handleKeyDownFunc);
    this._elem.removeEventListener('focus', this._handleFocusListener, {
      passive: false,
      capture: true
    });
    this._mouseWheelListener = null;
    this._touchStartListener = null;
    this._touchMoveListener = null;
    this._touchEndListener = null;
    this._scrollListener = null;
    this._handleFocusListener = null;

    // remove listeners before reparenting original children and clearing member
    // variables
    this._removeResizeListenerFunc(elem, this._handleResizeFunc);
    this._removeResizeListenerFunc(this._contentContainer, this._handleResizeFunc);
    this._handleResizeFunc = null;

    this._hasResources = false;
  };

  /**
   * Handle a keydown event.
   * @param {Event} event <code class="prettyprint">jQuery</code> event object.
   * @return {void}
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._handleKeyDown = function (event) {
    if (event.defaultPrevented) {
      return; // Should do nothing if the default action has been cancelled
    }
    var tabindexAttr = this._elem.getAttribute('tabindex');
    if (tabindexAttr == null || tabindexAttr < 0) {
      return;
    }
    var key = event.key || event.keyCode;
    if (this._orientation === 'horizontal') {
      switch (key) {
        case ConveyorBeltCommon._KEYBOARD_KEYS._RIGHT:
        case ConveyorBeltCommon._KEYBOARD_KEYS._RIGHT_IE:
        case ConveyorBeltCommon._KEYBOARD_KEYS._RIGHT_CODE:
          if (this._bRtl) {
            this._scrollPrevOnKeyDown(event);
          } else {
            this._scrollNextOnKeyDown(event);
          }
          break;
        case ConveyorBeltCommon._KEYBOARD_KEYS._LEFT:
        case ConveyorBeltCommon._KEYBOARD_KEYS._LEFT_IE:
        case ConveyorBeltCommon._KEYBOARD_KEYS._LEFT_CODE:
          if (this._bRtl) {
            this._scrollNextOnKeyDown(event);
          } else {
            this._scrollPrevOnKeyDown(event);
          }
          break;
        default:
          return;
      }
    }

    if (this._orientation === 'vertical') {
      switch (key) {
        case ConveyorBeltCommon._KEYBOARD_KEYS._DOWN:
        case ConveyorBeltCommon._KEYBOARD_KEYS._DOWN_IE:
        case ConveyorBeltCommon._KEYBOARD_KEYS._DOWN_CODE:
          this._scrollNextOnKeyDown(event);
          break;
        case ConveyorBeltCommon._KEYBOARD_KEYS._UP:
        case ConveyorBeltCommon._KEYBOARD_KEYS._UP_IE:
        case ConveyorBeltCommon._KEYBOARD_KEYS._UP_CODE:
          this._scrollPrevOnKeyDown(event);
          break;
        default:
      }
    }
  };

  ConveyorBeltCommon.prototype._scrollNextOnKeyDown = function (event) {
    if (this._constrainScroll(this._calcNextScroll()) !== this._getCurrScroll()) {
      this._scrollNext();
      event.preventDefault();
    }
  };

  ConveyorBeltCommon.prototype._scrollPrevOnKeyDown = function (event) {
    if (this._constrainScroll(this._calcPrevScroll()) !== this._getCurrScroll()) {
      this._scrollPrev();
      event.preventDefault();
    }
  };

  /**
   * Destroy the conveyor belt.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.destroy = function () {
    // FIX : resolve busy state when destroying
    this._resolveBusyState();

    var elem = this._elem;

    this.releaseResources();

    // move the original content children from the _contentContainer back to the
    // original DOM element
    this._reparentChildrenFromContentContainer(this._contentContainer, elem);

    // the content container is a child of the overflow container
    elem.removeChild(this._overflowContainer);
    this._overflowContainer = null;

    if (this._nextButton != null && this._prevButton != null) {
      elem.removeChild(this._nextButton);
      elem.removeChild(this._prevButton);
      this._nextButton = null;
      this._prevButton = null;
    }
    this._contentContainer = null;
    this._clearCachedSizes();

    this._elem = null;
    this._scrollFunc = null;
    this._addResizeListenerFunc = null;
    this._removeResizeListenerFunc = null;
    this._addStyleClassNameFunc = null;
    this._removeStyleClassNameFunc = null;
    this._hasStyleClassNameFunc = null;
    this._filterContentElementsFunc = null;
    this._subtreeDetachedFunc = null;
    this._subtreeAttachedFunc = null;
    this._addBusyStateFunc = null;

    this._contentParent = null;
  };

  /**
   * Handle a component resize.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.handleResize = function () {
    this._handleResize(false);
  };

  /**
   * Set the scroll position.
   * @param {number} scroll Desired logical scroll position
   * @param {boolean} bImmediate True to make the change immediately, false to animate it
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.setScroll = function (scroll, bImmediate) {
    this._setCurrScroll(scroll, bImmediate);
  };

  /**
   * Get the current scroll position.
   * @return {number} Logical scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   */
  ConveyorBeltCommon.prototype.getScroll = function () {
    return this._getCurrScroll();
  };

  /**
   * Reparent the DOM child nodes from their old parent node to a new parent
   * content container node.
   * @param {Object} fromNode Old parent DOM node
   * @param {Object} toNode New parent DOM node
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._reparentChildrenToContentContainer = function (fromNode, toNode) {
    var fromNodeChildren = fromNode.childNodes;
    while (fromNodeChildren.length > 0) {
      var child = fromNodeChildren[0];

      // notify the child that it's being detached from the DOM BEFORE detaching it
      // (the re-attached notification will happen in setup())
      this._subtreeDetachedFunc(child);

      toNode.appendChild(child); // @HTMLUpdateOK

      if (child.nodeType === 1 && this._itemStyleClass) {
        this._addStyleClassNameFunc(child, this._itemStyleClass);
      }
    }
  };

  /**
   * Reparent the DOM child nodes from the content container to a new
   * parent node.
   * @param {Object} fromNode Old parent DOM node
   * @param {Object} toNode New parent DOM node
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._reparentChildrenFromContentContainer = function (fromNode, toNode) {
    var children = fromNode.childNodes;
    while (children.length > 0) {
      var child = children[0];
      toNode.appendChild(child); // @HTMLUpdateOK

      if (child.nodeType === 1 && this._itemStyleClass) {
        this._removeStyleClassNameFunc(child, this._itemStyleClass);
      }
    }
  };

  /**
   * Get the computed style of the given DOM element.
   * @param {Object} elem DOM element
   * @return {Object} Computed style for the element
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._getComputedStyle = function (elem) {
    var elemOwnerDoc = elem.ownerDocument;
    var defView = elemOwnerDoc.defaultView;
    return defView.getComputedStyle(elem, null);
  };

  /**
   * Get the inner width of the given DOM element (inside borders and padding).
   * @param {Object} elem DOM element
   * @return {number} Width of element
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._getElemInnerWidth = function (elem) {
    var cbcClass = ConveyorBeltCommon;
    var computedStyle = cbcClass._getComputedStyle(elem);
    // the computedStyle width is the inner width of the elem
    return cbcClass._getCSSLengthAsInt(computedStyle.width);
  };

  /**
   * Get the inner height of the given DOM element (inside borders and padding).
   * @param {Object} elem DOM element
   * @return {number} Height of element
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._getElemInnerHeight = function (elem) {
    var cbcClass = ConveyorBeltCommon;
    var computedStyle = cbcClass._getComputedStyle(elem);
    // the computedStyle height is the inner height of the elem
    return cbcClass._getCSSLengthAsInt(computedStyle.height);
  };

  /**
   * Get the int value of a CSS length.
   * @param {string} cssLength cssLength as a string
   * @return {number} cssLength as an int
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._getCSSLengthAsInt = function (cssLength) {
    // this function copied from AdfAgent.getCSSLengthAsInt
    if (cssLength.length > 0 && cssLength !== 'auto') {
      // Fix  - CONVEYOR BELT TAB SCROLLING DOESN'T SCROLL THE LAST ITEM ENTIRELY INTO VIEW
      // offsetWidth/offsetHeight property will round the value to an integer
      // similarly, round the cssLength to the nearest integer
      var intLength = Math.round(parseFloat(cssLength));

      if (isNaN(intLength)) {
        intLength = 0;
      }

      return intLength;
    }
    return 0;
  };

  /**
   * Add a bubble event listener to the given DOM node.
   * @param {Object} node DOM node
   * @param {string} type Event type
   * @param {function(Event):void} listener Listener function
   * @param {boolean} passive passive option for listener
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._addBubbleEventListener = function (node, type, listener, passive) {
    node.addEventListener(type, listener, { passive, capture: false });
  };

  /**
   * Remove a bubble event listener from the given DOM node.
   * @param {Object} node DOM node
   * @param {string} type Event type
   * @param {function(Event):void} listener Listener function
   * @param {boolean} passive passive option for listener
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._removeBubbleEventListener = function (node, type, listener, passive) {
    node.removeEventListener(type, listener, { passive, capture: false });
  };

  /**
   * Get the wheel delta from a mousewheel event.
   * @param {Event} event Event object
   * @return {number} Wheel delta
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._getWheelDelta = function (event) {
    var wheelDelta = 0;
    if (event.deltaY != null || event.deltaX != null) {
      var deltaX = Math.abs(event.deltaX);
      var deltaY = Math.abs(event.deltaY);
      if (deltaX > deltaY) {
        wheelDelta = -event.deltaX;
      } else {
        wheelDelta = -event.deltaY;
      }
    } else if (event.wheelDelta != null) {
      var wheelDeltaX = Math.abs(event.wheelDeltaX);
      var wheelDeltaY = Math.abs(event.wheelDeltaY);
      if (wheelDeltaX > wheelDeltaY) {
        wheelDelta = event.wheelDeltaX;
      } else {
        wheelDelta = event.wheelDeltaY;
      }
    } else {
      wheelDelta = -event.detail;
    }
    if (event.deltaMode === 1) {
      wheelDelta *= 5;
    }
    return wheelDelta;
  };

  /**
   * Determine if this conveyor belt is horizontal or vertical.
   * @return {boolean} True if the conveyor belt is horizontal, false if vertical
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._isHorizontal = function () {
    return this._orientation === 'horizontal';
  };

  /**
   * Determine if this conveyor belt is empty.
   * @return {boolean} True if the conveyor belt is empty, false if not
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._isEmpty = function () {
    var contentParent = this._getContentParent();
    return !contentParent.hasChildNodes();
  };

  /**
   * Restore inner DOM to its initial state before sizes were calculated.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._reinitializeInnerDom = function () {
    // restore inner DOM to initial state in order to accurately calculate new sizes

    // save original scroll value for use in _adjustOverflowSize()
    this._origScroll = this._getCurrScroll();
    this._setOverflowScroll(0);

    // hide the buttons until we know we need them
    this._hidePrevButton();
    this._hideNextButton();
    this._bExternalScroll = true;
  };

  /**
   * Clear cached sizes.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._clearCachedSizes = function () {
    this._totalSize = null;
    this._sizes = null;
  };

  /**
   * Handle a component resize.
   * @param {boolean} bSetup True when called from setup, false otherwise
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._handleResize = function (bSetup) {
    // if this is not the first call, need to reinitialize the inner DOM before
    // we can accurately calculate new sizes (if this is the first call, DOM
    // is already in initial state)
    if (!bSetup) {
      this._reinitializeInnerDom();
    }
    this._clearCachedSizes();
    // measure content size
    this._totalSize = this._measureContents();
    // if this is not the first call, need to adjust the overflow size (if this
    // is the first call, the overflow size was already adjusted in setup)
    if (!bSetup) {
      this._adjustOverflowSize(false);
    }
    // center buttons orthogonal to conveyor orientation
    if (this._arrowVisibility === 'visible') {
      this._alignButtons();
    }
  };

  /**
   * Center the overflow buttons orthogonal to the conveyor orientation.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._alignButtons = function () {
    var nextButton = this._nextButton;
    var prevButton = this._prevButton;
    var nextButtonStyle = nextButton.style;
    var prevButtonStyle = prevButton.style;
    var totalSize = this._totalSize;

    if (this._isHorizontal()) {
      nextButtonStyle.height = totalSize.h + 'px';
      prevButtonStyle.height = totalSize.h + 'px';
    } else {
      nextButtonStyle.width = totalSize.w + 'px';
      prevButtonStyle.width = totalSize.w + 'px';
    }
  };

  /**
   * Adjust the overflow size.
   * @param {boolean} bInit True for initialization, false for refresh
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._adjustOverflowSize = function (bInit) {
    var contentContainer = this._contentContainer;
    var bHoriz = this._isHorizontal();

    var cbcClass = ConveyorBeltCommon;
    var elemInnerSize = bHoriz
      ? cbcClass._getElemInnerWidth(this._elem)
      : cbcClass._getElemInnerHeight(this._elem);

    this._minScroll = 0;
    // take the button size into account for max scroll position
    this._maxScroll = bHoriz
      ? contentContainer.offsetWidth - elemInnerSize + this._buttonWidth
      : contentContainer.offsetHeight - elemInnerSize + this._buttonHeight;
    // constrain max scroll
    if (this._maxScroll < 0) {
      this._maxScroll = 0;
    }

    // hide buttons AFTER calculating sizes above, but BEFORE updating scroll position below
    this._hidePrevButton();
    this._hideNextButton();

    // refresh current scroll position AFTER calculating sizes above
    this._setCurrScroll(bInit ? this._scrollPosition : this._origScroll, true);
    this._bExternalScroll = true;
    this._origScroll = this._scrollPosition;
  };

  /**
   * Create the inner overflow and content containers.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._createInnerContainers = function () {
    // the original children of the conveyor elem will be reparented to the contentContainer;
    // the conveyor elem will contain the overflowContainer, which will contain the contentContainer,
    // which will contain the original children

    var self = this;

    var elem = this._elem;
    var cbcClass = ConveyorBeltCommon;
    var overflowContainer = document.createElement('div');
    this._overflowContainer = overflowContainer;
    this._addStyleClassNameFunc(overflowContainer, this._overflowContainerStyleClass);
    var contentContainer = document.createElement('div');
    this._contentContainer = contentContainer;
    this._addStyleClassNameFunc(contentContainer, this._contentContainerStyleClass);

    // reparent children from elem to contentContainer before adding
    // content container to elem
    this._reparentChildrenToContentContainer(elem, contentContainer);

    elem.appendChild(overflowContainer); // @HTMLUpdateOK
    overflowContainer.appendChild(contentContainer); // @HTMLUpdateOK

    // the overflow container listens to DOM scroll events in case the scroll was triggered externally,
    // for example when the user tabs through the child content
    this._scrollListener = function (event) {
      self._handleScroll(event);
    };
    cbcClass._addBubbleEventListener(overflowContainer, 'scroll', this._scrollListener);
  };

  /**
   * Get the content elements of the conveyor.
   * @return {Array} array of content elements
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._getContentElements = function () {
    var arContentElements = [];

    // if there is a nested contentParent, then we need to put its children into
    // arContentElements instead of the children of the contentContainer
    var parent = this._contentParent ? this._contentParent : this._contentContainer;

    var contentChildren = parent.children;
    var numContentChildren = contentChildren.length;
    var i;
    for (i = 0; i < numContentChildren; i++) {
      var child = contentChildren[i];
      if (child.nodeType === 1 && child.tagName !== 'TEMPLATE' && child.offsetWidth !== 0) {
        arContentElements.push(child);
      }
    }

    var filterFunc = this._filterContentElementsFunc;
    arContentElements = filterFunc(arContentElements);

    // if the content elements are direct children of the contentContainer, meaning there's no nested
    // contentParent, then make sure they have the itemStyleClass applied to them in case they were
    // added dynamically
    if (parent === this._contentContainer && this._itemStyleClass) {
      for (i = 0; i < arContentElements.length; i++) {
        var contentElem = arContentElements[i];
        if (!this._hasStyleClassNameFunc(contentElem, this._itemStyleClass)) {
          this._addStyleClassNameFunc(contentElem, this._itemStyleClass);
        }
      }
    }

    return arContentElements;
  };

  /**
   * Create the prev button.
   * @param {string} buttonStyleClass Style class to use for the button
   * @param {Node} icon Button icon element
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._createPrevButton = function (buttonStyleClass, icon) {
    var self = this;
    var prevButton = document.createElement('div');
    this._prevButton = prevButton;
    prevButton.setAttribute('class', buttonStyleClass);
    // hide the button from screen readers because it is not keyboard accessible
    prevButton.setAttribute('aria-hidden', 'true');
    var cbcClass = ConveyorBeltCommon;
    cbcClass._addBubbleEventListener(prevButton, 'click', function () {
      self._scrollPrev();
    });

    prevButton.appendChild(icon); // @HTMLUpdateOK

    var elem = this._elem;
    elem.insertBefore(prevButton, this._overflowContainer); // @HTMLUpdateOK
  };

  /**
   * Create the next button.
   * @param {string} buttonStyleClass Style class to use for the button
   * @param {Node} icon Button icon element
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._createNextButton = function (buttonStyleClass, icon) {
    var self = this;
    var nextButton = document.createElement('div');
    this._nextButton = nextButton;
    nextButton.setAttribute('class', buttonStyleClass);
    // hide the button from screen readers because it is not keyboard accessible
    nextButton.setAttribute('aria-hidden', 'true');
    var cbcClass = ConveyorBeltCommon;
    cbcClass._addBubbleEventListener(nextButton, 'click', function () {
      self._scrollNext();
    });

    nextButton.appendChild(icon); // @HTMLUpdateOK

    var elem = this._elem;
    elem.appendChild(nextButton); // @HTMLUpdateOK
  };

  /**
   * Get the content parent.
   * @return {Object} parent DOM element of the content
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._getContentParent = function () {
    // if an explicit content parent was not specified, it will be the _contentContainer
    var contentParent = this._contentParent;
    if (!contentParent) {
      contentParent = this._contentContainer;
    }
    return contentParent;
  };

  /**
   * Measure the contents of the conveyor.
   * @return {Object} Total size of the contents
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._measureContents = function () {
    var arContentElements = this._getContentElements();
    var totalSize = { w: 0, h: 0 };
    var sizes = [];
    if (arContentElements.length > 0) {
      var children = arContentElements;
      var bHoriz = this._isHorizontal();
      var contentWidth = 0;

      // get the width of the contentContainer, not the contentParent, because
      // in JET, if the children are in a buttonset, for example, the offsetLeft
      // of the children is relative to the contentContainer, not the
      // contentParent
      var contentContainer = this._contentContainer;
      contentWidth = contentContainer.offsetWidth;

      var startOffset = 0;
      var prevSizeObj = null;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.nodeType === 1) {
          var ww = child.offsetWidth;
          var hh = child.offsetHeight;
          var childId = child.id;
          var sizeObj = { w: ww, h: hh, id: childId };
          var childParent;
          // calculating the start assumes that the browser has done the appropriate layout;
          // subtract 1 from the end so it's the last pixel of this child, not the start of the next child
          if (bHoriz) {
            // FIX : in IE, the conveyor items all report offsetLeft=0,
            // so we need to get the offset from the parent wrapping table cell div
            // instead
            var offLeft = child.offsetLeft;
            if (!this._contentParent && offLeft === 0) {
              childParent = child.parentNode;
              offLeft = childParent.offsetLeft;
            }

            // if RTL, still want to save the start coords in logical, ascending order beginning with 0
            if (this._bRtl) {
              sizeObj.start = contentWidth - (offLeft + ww);
            } else {
              sizeObj.start = offLeft;
            }

            // Offset each item's start coord by the first item's offset to handle cases like text-align:right,
            // where the items may be right-aligned within the content container.  We still want our logical
            // coords to start at 0.
            if (i === 0) {
              startOffset = sizeObj.start;
            }
            sizeObj.start -= startOffset;

            totalSize.w = sizeObj.start + ww;
            totalSize.h = Math.max(totalSize.h, hh);
            sizeObj.end = totalSize.w - 1;
          } else {
            // FIX : in IE, the conveyor items all report offsetTop=0,
            // so we need to get the offset from the parent wrapping table cell div
            // instead
            var offTop = child.offsetTop;
            if (!this._contentParent && offTop === 0) {
              childParent = child.parentNode;
              offTop = childParent.offsetTop;
            }

            sizeObj.start = offTop;
            totalSize.w = Math.max(totalSize.w, ww);
            totalSize.h = sizeObj.start + hh;
            sizeObj.end = totalSize.h - 1;
          }

          // if this item overlaps the previous item, adjust the previous item to
          // end just before this item (can happen, for example, with horizontal
          // JET buttonsets)
          if (prevSizeObj) {
            if (prevSizeObj.end >= sizeObj.start) {
              var overlap = prevSizeObj.end - (sizeObj.start - 1);
              prevSizeObj.end -= overlap;
              if (bHoriz) {
                prevSizeObj.w -= overlap;
              } else {
                prevSizeObj.h -= overlap;
              }
            }
          }

          sizes.push(sizeObj);
          prevSizeObj = sizeObj;
        }
      }
    }
    this._sizes = sizes;
    return totalSize;
  };

  /**
   * Get the array of content sizes.
   * @return {Array} Array of content sizes
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._getSizes = function () {
    return this._sizes;
  };

  /**
   * Show the next button.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._showNextButton = function () {
    this._removeStyleClassNameFunc(this._nextButton, this._hiddenStyleClass);
    this._atEnd = false;
  };

  /**
   * Show the prev button.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._showPrevButton = function () {
    this._removeStyleClassNameFunc(this._prevButton, this._hiddenStyleClass);
    this._atStart = false;
  };

  /**
   * Hide the next button.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._hideNextButton = function () {
    this._addStyleClassNameFunc(this._nextButton, this._hiddenStyleClass);
    this._atEnd = true;
  };

  /**
   * Hide the prev button.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._hidePrevButton = function () {
    this._addStyleClassNameFunc(this._prevButton, this._hiddenStyleClass);
    this._atStart = true;
  };

  /**
   * Get the size of a next/prev button along the direction of conveyor orientation.
   * @return {number} Size of a button
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._getButtonSize = function () {
    var result = 0;
    if (this._arrowVisibility === 'visible') {
      result = this._isHorizontal() ? this._buttonWidth : this._buttonHeight;
    }
    return result;
  };

  /**
   * Update visibility of the next/prev buttons and adjust scroll position accordingly.
   * @param {number} scroll Desired scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._updateButtonVisibility = function (scroll) {
    var buttonSize = this._getButtonSize();
    var ovScroll = this._getCurrScroll();
    var bNeedsScroll = this._needsScroll();
    // if scrolling to the start, hide the prev button and reclaim its space
    if (scroll <= this._minScroll) {
      if (!this._atStart) {
        ovScroll -= buttonSize;
      }
      this._hidePrevButton();
    } else if (bNeedsScroll) {
      // if not at the start, show the prev button and allocate space for it
      if (this._atStart) {
        ovScroll += buttonSize;
      }
      this._showPrevButton();
    }

    // if scrolling to the end, hide the next button and reclaim its space
    if (scroll >= this._maxScroll) {
      this._hideNextButton();
    } else if (bNeedsScroll) {
      this._showNextButton();
    }
    // update the overflow container
    this._setOverflowScroll(ovScroll);
  };

  /**
   * Set the overflow scroll position.
   * @param {number} scroll Overflow logical scroll position
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._setOverflowScroll = function (scroll) {
    var container = this._overflowContainer;
    if (this._isHorizontal()) {
      DomUtils.setScrollLeft(container, scroll);
    } else {
      container.scrollTop = scroll;
    }
  };

  /**
   * Get the current overflow viewport size.
   * @return {number} Overflow viewport size
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._getCurrViewportSize = function () {
    var container = this._overflowContainer;
    return this._isHorizontal() ? container.offsetWidth : container.offsetHeight;
  };

  /**
   * Set the scroll position.
   * @param {number} scroll Desired logical scroll position
   * @param {boolean} bImmediate True to make the change immediately, false to animate it
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._setCurrScroll = function (scroll, bImmediate) {
    // don't do anything if we're already in the middle of scrolling
    if (!this._bScrolling) {
      // if this function is called, the conveyor internally initiated the scroll, so turn off the
      // flag for an externally triggered scroll
      this._bExternalScroll = false;
      this._setCurrScrollHelper(scroll, bImmediate);
    }
  };

  /**
   * Helper function to set scroll position.
   * @param {number} scroll Desired scroll position
   * @param {boolean} bImmediate True to make the change immediately, false to animate it
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._setCurrScrollHelper = function (scroll, bImmediate) {
    if (this._isEmpty()) {
      return;
    }

    this._bScrolling = true;
    // eslint-disable-next-line no-param-reassign
    scroll = this._constrainScroll(scroll);
    // update button visibility before scrolling
    this._updateButtonVisibility(scroll);
    var scrollFunc = this._scrollFunc;
    // if making the change immediately, simply call the anim end function
    if (bImmediate || !scrollFunc || scroll === this._getCurrScroll()) {
      // FIX : if this is an external scroll, set the current scroll
      // value again because it may be different from the passed in scroll value
      // due to showing/hiding scroll buttons (Note that for an external scroll,
      // the scroll has already happened before this function was called)
      this._onScrollAnimEnd(this._bExternalScroll ? this._getCurrScroll() : scroll);
    } else {
      // if animating the change, call out to the provided callback
      // FIX : add busy state before animating a scroll
      this._busyStateResolveFunc = this._addBusyStateFunc('scrolling');

      var cbcClass = ConveyorBeltCommon;
      // 1.1 px/ms is the desired animation speed, so calculate the duration based on the distance to scroll
      var duration = Math.abs(this._getCurrScroll() - scroll) / cbcClass._SCROLL_SPEED;
      var self = this;
      var onEndFunc = function () {
        self._onScrollAnimEnd(scroll);

        // FIX : resolve busy state after animating a scroll
        self._resolveBusyState();
      };
      // scrollFunc delegates to jQuery.animate() to animate scrollLeft.
      // Most browsers use negative scroll value in RTL, except for old ie/edge that still use positive values
      // DomUtils.calculateScrollLeft converts the logical scroll to the correct browser value.
      scrollFunc(this._overflowContainer, DomUtils.calculateScrollLeft(scroll), duration, onEndFunc);
    }
  };

  /**
   * Resolve an outstanding busy state.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._resolveBusyState = function () {
    if (this._busyStateResolveFunc) {
      this._busyStateResolveFunc();
      this._busyStateResolveFunc = null;
    }
  };

  /**
   * Get the current scroll position.
   * @return {number} Logical scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._getCurrScroll = function () {
    var container = this._overflowContainer;
    return this._isHorizontal()
      ? Math.round(Math.abs(container.scrollLeft))
      : Math.round(container.scrollTop);
  };

  /**
   * Determine if the conveyor needs to show scroll buttons.
   * @return {boolean} True if scrolling is needed, false if not
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._needsScroll = function () {
    var contentContainer = this._contentContainer;
    var overflowContainer = this._overflowContainer;
    return this._isHorizontal()
      ? contentContainer.offsetWidth > overflowContainer.offsetWidth
      : contentContainer.offsetHeight > overflowContainer.offsetHeight;
  };

  /**
   * Constrain the scroll position.
   * @param {number} scroll Desired scroll position
   * @return {number} Constrained scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._constrainScroll = function (scroll) {
    if (!this._needsScroll() || scroll < this._minScroll) {
      return this._minScroll;
    } else if (scroll > this._maxScroll) {
      return this._maxScroll;
    }
    return scroll;
  };

  /**
   * Handle a mousewheel event.
   * @param {Event} event Event object
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._handleMouseWheel = function (event) {
    // if we're already scrolling, just consume the event
    var bConsumeEvent = this._bScrolling;
    if (this._needsScroll() && !this._bScrolling) {
      var cbcClass = ConveyorBeltCommon;
      var wheelDelta = cbcClass._getWheelDelta(event);
      var scroll;
      if (wheelDelta < 0 && !this._atEnd) {
        scroll = this._getCurrScroll() + Math.abs(wheelDelta);
      } else if (wheelDelta > 0 && !this._atStart) {
        scroll = this._getCurrScroll() - wheelDelta;
      }
      if (scroll != null) {
        bConsumeEvent = true;
        this._setCurrScroll(scroll, true);
      }
    }
    if (bConsumeEvent) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  /**
   * Handle a touchstart event.
   * @param {Event} event Event object
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._handleTouchStart = function (event) {
    var eventTouches = event.touches;
    if (this._needsScroll() && !this._bScrolling && eventTouches.length === 1) {
      this._bTouch = true;
      // save off some initial information at the start of a swipe
      this._firstTouch = eventTouches[0];
      this._touchLastCoord = this._isHorizontal() ? this._firstTouch.pageX : this._firstTouch.pageY;

      this._touchStartScroll = this._getCurrScroll();
      this._touchStartNextScroll = this._calcNextScroll();
      this._touchStartPrevScroll = this._calcPrevScroll();
      // FIX : save the initial at start or at end state
      this._touchInitialNotAtEnd = !this._atEnd;
      this._touchInitialNotAtStart = !this._atStart;
      this._trackingPoints = [];
      this._addTrackingPoint(this._touchLastCoord);
      this._targetCoord = 0;
    }
  };

  /**
   * Handle a touchmove event.
   * @param {Event} event Event object
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._handleTouchMove = function (event) {
    var bHoriz = this._isHorizontal();
    var eventTouches = event.touches;
    var currentTouch = eventTouches[0];
    this._touchCurrentCoord = bHoriz ? currentTouch.pageX : currentTouch.pageY;
    var diff = this._touchCurrentCoord - this._touchLastCoord;
    // in non-RTL, if swiping left or up, scroll next; otherwise scroll prev
    // in RTL, if swiping right or up, scroll next; otherwise scroll prev
    var bNext = bHoriz && this._bRtl ? diff > 0 : diff < 0;
    // determine whether the conveyor can be scrolled in the direction of the swipe
    var canScrollInSwipeDirection =
      (bNext && this._touchInitialNotAtEnd) || (!bNext && this._touchInitialNotAtStart);
    // only need to do something if we also received the touchstart and if we can
    // scroll in the swipe direction
    if (this._bTouch && this._firstTouch.id === currentTouch.id && canScrollInSwipeDirection) {
      this._addTrackingPoint(this._touchLastCoord);
      if (bHoriz && this._bRtl) {
        this._setCurrScroll(this._getCurrScroll() + diff, true);
      } else {
        this._setCurrScroll(this._getCurrScroll() - diff, true);
      }
      this._touchLastCoord = this._touchCurrentCoord;
      // if we're under the threshold, but we've already scrolled to the end,
      // then we don't need to continue trying to scroll and we don't need to
      // reset the scroll position at the end of the touch
      if (
        (this._touchInitialNotAtEnd && this._atEnd) ||
        (this._touchInitialNotAtStart && this._atStart)
      ) {
        this._bTouch = false;
      }
      // FIX : set a flag indicating we've scrolled for this touch event
      this._scrolledForThisTouch = true;
    }
    if (this._scrolledForThisTouch) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  /**
   * Handle a touchend event.
   * @param {Event} event Event object
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  ConveyorBeltCommon.prototype._handleTouchEnd = function (event) {
    this._bTouch = false;
    // FIX : reset the flag indicating if we've scrolled for this touch
    // event
    this._scrolledForThisTouch = false;
    if (this._trackingPoints != null) {
      this._addTrackingPoint(this._touchLastCoord);
      this._startDecelAnim();
    }
  };

  /**
   * Records movement for the last 100ms
   * @param {number} coord - x or y coordinate depending on the conveyorbelt orientation
   */
  ConveyorBeltCommon.prototype._addTrackingPoint = function (coord) {
    if (this._trackingPoints == null) {
      return;
    }
    var time = Date.now();
    while (this._trackingPoints.length > 0) {
      if (time - this._trackingPoints[0].time <= 100) {
        break;
      }
      this._trackingPoints.shift();
    }
    this._trackingPoints.push({ coord, time });
  };

  /*
   * Initialize animation of values coming to a stop
   */
  ConveyorBeltCommon.prototype._startDecelAnim = function () {
    var firstPoint = this._trackingPoints[0];
    var lastPoint = this._trackingPoints[this._trackingPoints.length - 1];

    var offset = lastPoint.coord - firstPoint.coord;
    var timeOffset = lastPoint.time - firstPoint.time;

    var D = timeOffset / 15;

    this._decVel = offset / D || 0; // prevent NaN

    if (Math.abs(this._decVel) > 1) {
      this._decelerating = true;
      requestAnimationFrame(this._stepDecelAnim.bind(this));
    }
  };

  /**
   * Animates values slowing down
   */
  ConveyorBeltCommon.prototype._stepDecelAnim = function () {
    if (!this._decelerating) {
      return;
    }
    var friction = ConveyorBeltCommon._TOUCH_SCROLL_FRICTION;
    var stopThreshold = ConveyorBeltCommon._TOUCH_SCROLL_STOP_THRESHOLD;
    this._decVel *= friction;

    this._targetCoord += this._decVel;

    if (Math.abs(this._decVel) > stopThreshold) {
      if (this._isHorizontal() && this._bRtl) {
        this._setCurrScroll(this._getCurrScroll() + this._targetCoord, true);
      } else {
        this._setCurrScroll(this._getCurrScroll() - this._targetCoord, true);
      }
      requestAnimationFrame(this._stepDecelAnim.bind(this));
    } else {
      this._decelerating = false;
    }
  };

  /**
   * Handle a DOM scroll event.
   * @param {Event} event Event object
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  // eslint-disable-next-line no-unused-vars
  ConveyorBeltCommon.prototype._handleScroll = function (event) {
    // if the scroll was triggered externally, for example by tabbing through
    // child items, then update the visual state of the conveyor to match the
    // new scroll state
    if (this._bExternalScroll && !this._bScrolling) {
      this._setCurrScrollHelper(this._getCurrScroll(), true);
    }
    this._bExternalScroll = true;
  };

  /**
   * Function called after a scroll finishes.
   * @param {number} scroll Scroll position
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._onScrollAnimEnd = function (scroll) {
    // set the desired value after the animation to make sure that the final value is exactly what was intended,
    // in case the animation introduced interpolation errors
    this._setOverflowScroll(scroll);
    this._setScrollPositionProperty(scroll);
    this._bScrolling = false;
  };

  /**
   * Scroll to the next set of items.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._scrollNext = function () {
    if (!this._bScrolling) {
      this._setCurrScroll(this._calcNextScroll(), false);
    }
  };

  /**
   * Scroll to the previous set of items.
   * @return {void}
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._scrollPrev = function () {
    if (!this._bScrolling) {
      this._setCurrScroll(this._calcPrevScroll(), false);
    }
  };

  /**
   * Calculate the scroll position for the next set of items.
   * @return {number} Next scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcNextScroll = function () {
    var nextIndex = this._calcNextVisibleItemIndex();
    var scroll = 0;
    // if single item is bigger than viewport, then scroll by viewport size
    if (nextIndex === this._calcFirstVisibleItemIndex()) {
      scroll = this._getCurrScroll() + this._getCurrViewportSize();
    } else {
      scroll = this._calcStartScroll(nextIndex);
    }
    return scroll;
  };

  /**
   * Calculate the scroll position for the previous set of items.
   * @return {number} Previous scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcPrevScroll = function () {
    var prevIndex = this._calcPrevVisibleItemIndex();
    var scroll = 0;
    // if single item is bigger than viewport, then scroll by viewport size
    if (prevIndex === this._calcLastVisibleItemIndex()) {
      scroll = this._getCurrScroll() - this._getCurrViewportSize();
    } else {
      scroll = this._calcEndScroll(prevIndex);
    }
    // if at the end and scrolling prev, anticipate the next button becoming
    // visible and adjust the scroll position
    if (this._atEnd) {
      scroll += this._getButtonSize();
    }
    // if scrolling prev and the scroll position is less than or equal to the size of the prev button,
    // just scroll to the very beginning because the prev button should get hidden
    if (scroll <= this._getButtonSize()) {
      scroll = this._minScroll;
    }
    return scroll;
  };

  /**
   * Calculate the scroll position for the start of the specified item.
   * @param {number} index Index of the item to scroll to
   * @return {number} Scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcStartScroll = function (index) {
    var sizes = this._getSizes();
    var sizeObj = sizes[index];
    return sizeObj.start;
  };

  /**
   * Calculate the scroll position for the end of the specified item.
   * @param {number} index Index of the item to scroll to
   * @return {number} Scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcEndScroll = function (index) {
    var sizes = this._getSizes();
    var sizeObj = sizes[index];
    return sizeObj.end - this._getCurrViewportSize() + 1;
  };

  /**
   * Calculate the index of the first visible item.
   * @return {number} Index of first visible item
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcFirstVisibleItemIndex = function () {
    var currScroll = this._getCurrScroll();
    var i = this._calcItemIndex(currScroll);
    return i < 0 ? 0 : i;
  };

  /**
   * Calculate the index of the last visible item.
   * @return {number} Index of last visible item
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcLastVisibleItemIndex = function () {
    var elemSize = this._getCurrViewportSize();
    var currScroll = this._getCurrScroll() + elemSize - 1;
    var i = this._calcItemIndex(currScroll);
    var sizes = this._getSizes();
    return i < 0 ? sizes.length - 1 : i;
  };

  /**
   * Calculate the index of the previous visible item.
   * @return {number} Index of previous visible item
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcPrevVisibleItemIndex = function () {
    var currScroll = this._getCurrScroll() - 1;
    var i = this._calcItemIndex(currScroll);
    return i < 0 ? 0 : i;
  };

  /**
   * Calculate the index of the next visible item.
   * @return {number} Index of next visible item
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcNextVisibleItemIndex = function () {
    var elemSize = this._getCurrViewportSize();
    var currScroll = this._getCurrScroll() + elemSize;
    var i = this._calcItemIndex(currScroll);
    var sizes = this._getSizes();
    return i < 0 ? sizes.length - 1 : i;
  };

  /**
   * Calculate the index of the item at the given scroll position.
   * @param {number} scroll Scroll position
   * @return {number} Index of item at given scroll position
   * @memberof ConveyorBeltCommon
   * @instance
   * @private
   */
  ConveyorBeltCommon.prototype._calcItemIndex = function (scroll) {
    var sizes = this._getSizes();
    for (var i = 0; i < sizes.length; i++) {
      var sizeObj = sizes[i];
      if (scroll <= sizeObj.end) {
        return i;
      }
    }
    return -1;
  };

  /**
   * Scroll animation speed (px/ms).
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._SCROLL_SPEED = 1.1;
  /**
   * Touch scroll friction.
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._TOUCH_SCROLL_FRICTION = 0.7;
  /**
   * Touch scroll stop threshold.
   * @memberof ConveyorBeltCommon
   * @private
   */
  ConveyorBeltCommon._TOUCH_SCROLL_STOP_THRESHOLD = 0.1;

  ConveyorBeltCommon._KEYBOARD_KEYS = {
    _UP: 'ArrowUp',
    _UP_IE: 'Up',
    _UP_CODE: 38,
    _DOWN: 'ArrowDown',
    _DOWN_IE: 'Down',
    _DOWN_CODE: 40,
    _LEFT: 'ArrowLeft',
    _LEFT_IE: 'Left',
    _LEFT_CODE: 37,
    _RIGHT: 'ArrowRight',
    _RIGHT_IE: 'Right',
    _RIGHT_CODE: 39
  };

  /**
   * @ojcomponent oj.ojConveyorBelt
   * @augments oj.baseComponent
   * @since 0.6.0
   * @ojdeprecated [
   *  {
   *    type: "maintenance",
   *    since: "17.0.0",
   *    value: ["oj-c-conveyor-belt"]
   *  }
   * ]
   *
   * @ojshortdesc A conveyor belt manages overflow for its child elements and allows scrolling among them.
   * @class oj.ojConveyorBelt
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["orientation"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-conveyor-belt'
   * @ojuxspecs ['conveyor-belt']
   *
   * @classdesc
   * <h3 id="conveyorBeltOverview-section">
   *   JET ConveyorBelt
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#conveyorBeltOverview-section"></a>
   * </h3>
   *
   * <p>Description: Container element that manages overflow for its child
   * elements and allows scrolling among them.
   *
   * <p>Child elements of the ConveyorBelt must all be siblings at the same level.
   * The size of the ConveyorBelt must somehow be constrained in order for
   * there to be overflow to manage, for example by specifying CSS
   * <code class="prettyprint">max-width</code> or
   * <code class="prettyprint">max-height</code>.
   * <p>If the elements to be scrolled among are direct children of the
   * ConveyorBelt, then ConveyorBelt will ensure that they are laid out
   * appropriately for its orientation.  However, if the elements to be scrolled
   * among are contained by a single nested descendant element, the
   * <code class="prettyprint">content-parent</code>, then it is up to calling code
   * to ensure that the elements are laid out appropriately.  For example,
   * elements can be forced horizontal by using CSS
   * <code class="prettyprint">white-space:nowrap</code>, or vertical by using
   * <code class="prettyprint">display:block</code>.
   *
   * <pre class="prettyprint"><code>
   * &lt;oj-conveyor-belt>
   *   &lt;oj-button>Alpha&lt;/oj-button>
   *   &lt;oj-button>Beta&lt;/oj-button>
   *   &lt;oj-button>Gamma&lt;/oj-button>
   *   &lt;oj-button>Delta&lt;/oj-button>
   *   &lt;oj-button>Epsilon&lt;/oj-button>
   *   &lt;oj-button>Zeta&lt;/oj-button>
   * &lt;/oj-conveyor-belt>
   * </code></pre>
   *
   * <p id="conveyorBelt-filmStrip-section">JET FilmStrip and ConveyorBelt look similar, but are intended to be used
   * for different purposes.
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#conveyorBelt-filmStrip-section"></a>
   * <p>Use ConveyorBelt when you want to:
   * <ul>
   * <li>handle overflow without showing a scrollbar</li>
   * <li>keep all items accessible via tabbing and readable by a screen reader</li>
   * </ul>
   * <p>Use FilmStrip when you want to:
   * <ul>
   * <li>layout a set of items across discrete logical pages</li>
   * <li>control which and how many items are shown</li>
   * <li>hide items outside the current viewport from tab order and screen reader</li>
   * </ul>
   *
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   *
   * <h3 id="keyboard-appdev-section">
   *   Keyboard Application Developer Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
   * </h3>
   *
   * <p>Providing keyboard support for the items in the conveyor belt is the
   * responsibility of the application developer, if the items do not already
   * support keyboard interaction.  This could be done, for example, by specifying
   * <code class="prettyprint">tabindex</code> on each item to enable tab
   * navigation.  Alternatively, this could be done by adding a keyboard listener
   * and responding to key events, like pressing the arrow keys.
   *
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>ConveyorBelt provides opt-in keyboard accessibility. To be able to scroll using keyboard,
   * it is required to set attribute <code class="prettyprint">tabindex=0</code>.
   * If Sighted keyboard-only users also need to be able to
   * access the items in the conveyor just by using the keyboard.
   * It is up to the child items of the ConveyorBelt to support keyboard
   * navigation.  If child items support tab navigation, the browser may scroll
   * them into view when they receive focus.  If child items support other forms
   * of keyboard navigation, for example by using the arrow keys, it is up to the
   * child items to scroll themselves into view.  This may be done, for example,
   * by calling the DOM function <code class="prettyprint">focus()</code> or
   * <code class="prettyprint">scrollIntoView()</code> on the item.
   * ConveyorBelt will be aware of tab based or programmatic scrolling and will
   * honor it, updating itself to toggle visibility of the overflow indicators as
   * needed.
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   * </h3>
   * To migrate from oj-conveyor-belt to oj-c-conveyor-belt, you need to revise the import statement and references to oj-c-conveyor-belt in your app.
   * Please note the changes between the two components below.
   * <ul> The new oj-c-conveyor-belt component could be in two modes:
   * <li>
   * A ConveyorBelt component with completely opaque content.
   * The navigation by arrows always scroll by fixed size, i.e. width of the scroll view port.
   * The snapping position is not applied and the scrolling could be stopped so that child element is visible partially.
   * </li>
   * <li>
   * Items aware ConveyorBelt component. A ConveyorBelt component that contains information about its children/items.
   * The navigation by keyboard right/left arrows scrolls and snaps the child elements to the best fit.
   * To make conveyor belt aware of its content please use <code class="prettyprint">items</code> attribute and <code class="prettyprint">template</code> element with <code class="prettyprint">itemTemplate</code> slot.
   * </li>
   * </ul>
   * <h5>content-parent attribute</h5>
   * <p>
   *  The content-parent attribute is no longer supported.
   * </p>
   * <h5>items attribute</h5>
   * <p>
   *  The <code class="prettyprint">items</code> attribute is the new way to provide data to make the new oj-c-conveyor-belt component to be aware of its items.
   *  Besides maintaining its support for DataProvider, the <code class="prettyprint">items</code> attribute also accepts an Array of data items.
   *  The <code class="prettyprint">items</code> attribute only works in connection with <code class="prettyprint">itemTemplate</code> slot.
   *  The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the Conveyor Belt.
   *  The slot content must be a &lt;template&gt; element.
   * </p>
   * <h5>itemTemplate slot</h5>
   * <p>
   * The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the Conveyor Belt.
   * The slot content must be a &lt;template&gt; element. Please specify items attribute if conveyor belt items need data.
   * The itemTemplate and items makes conveyor belt component to be aware of its items and respect individual items borders during pagination.
   * </p>
   * <h5>refresh method</h5>
   * <p>
   * The <code class="prettyprint">refresh()</code> method is no longer supported. The application should no longer need to use this method.
   * </p>
   * <h5>oj-bind-for-each operator</h5>
   * <p>
   *  It is recommended that the <code class="prettyprint">items</code> attribute is used instead of <code class="prettyprint">oj-bind-for-each</code> operator
   * </p>
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET element, in the unusual case that the directionality
   * (LTR or RTL) changes post-init, the conveyorBelt must be
   * <code class="prettyprint">refresh()</code>ed.
   */
  /**
   * <p>The &lt;oj-conveyor-belt> element manages overflow for its child elements and allows scrolling among them.
   * Child elements of the &lt;oj-conveyor-belt> must all be siblings at the same level.</p>
   * <p>If the elements to be scrolled among are nested descendants and not direct
   * children of the conveyor belt, the <code class="prettyprint">content-parent</code>
   * attribute should specify the nested elements direct parent.</p>
   *
   * @ojchild Default
   * @ojshortdesc The oj-conveyor-belt element manages overflow for its child elements and allows scrolling among them. See the Help documentation for more information.
   * @memberof oj.ojConveyorBelt
   *
   * @example <caption>Initialize the conveyor belt with child content specified:</caption>
   * &lt;oj-conveyor-belt>
   *   &lt;oj-button>Alpha&lt;/oj-button>
   *   &lt;oj-button>Beta&lt;/oj-button>
   *   &lt;oj-button>Gamma&lt;/oj-button>
   *   &lt;oj-button>Delta&lt;/oj-button>
   *   &lt;oj-button>Epsilon&lt;/oj-button>
   *   &lt;oj-button>Zeta&lt;/oj-button>
   * &lt;/oj-conveyor-belt>
   *
   * @example <caption>Initialize the conveyor belt with nested child content
   * specified:</caption>
   * &lt;oj-conveyor-belt content-parent='#myContentElem'>
   *   &lt;div id='myContentElem'>
   *     &lt;oj-button>Item 1&lt;/oj-button>
   *     &lt;oj-button>Item 2&lt;/oj-button>
   *     &lt;oj-button>Item 3&lt;/oj-button>
   *     &lt;oj-button>Item 4&lt;/oj-button>
   *     &lt;oj-button>Item 5&lt;/oj-button>
   *   &lt;/div>
   * &lt;/oj-conveyor-belt>
   */

  //----------------------------------------------
  //             SUB-IDS
  //----------------------------------------------
  /**
   * <p>Sub-ID for the start overflow indicator of a horizontal ConveyorBelt.</p>
   *
   * @ojsubid oj-conveyorbelt-start-overflow-indicator
   * @memberof oj.ojConveyorBelt
   *
   * @example <caption>Get the start overflow indicator:</caption>
   * var node = myConveyorBelt.getNodeBySubId({'subId': 'oj-conveyorbelt-start-overflow-indicator'} );
   */

  /**
   * <p>Sub-ID for the end overflow indicator of a horizontal ConveyorBelt.</p>
   *
   * @ojsubid oj-conveyorbelt-end-overflow-indicator
   * @memberof oj.ojConveyorBelt
   *
   * @example <caption>Get the end overflow indicator:</caption>
   * var node = myConveyorBelt.getNodeBySubId({'subId': 'oj-conveyorbelt-end-overflow-indicator'} );
   */

  /**
   * <p>Sub-ID for the top overflow indicator of a vertical ConveyorBelt.</p>
   *
   * @ojsubid oj-conveyorbelt-top-overflow-indicator
   * @memberof oj.ojConveyorBelt
   *
   * @example <caption>Get the top overflow indicator:</caption>
   * var node = myConveyorBelt.getNodeBySubId({'subId': 'oj-conveyorbelt-top-overflow-indicator'} );
   */

  /**
   * <p>Sub-ID for the bottom overflow indicator of a vertical ConveyorBelt.</p>
   *
   * @ojsubid oj-conveyorbelt-bottom-overflow-indicator
   * @memberof oj.ojConveyorBelt
   *
   * @example <caption>Get the bottom overflow indicator:</caption>
   * var node = myConveyorBelt.getNodeBySubId({'subId': 'oj-conveyorbelt-bottom-overflow-indicator'} );
   */

  //-----------------------------------------------------
  //                   Fragments
  //-----------------------------------------------------
  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>ConveyorBelt</td>
   *       <td><kbd>Swipe</kbd></td>
   *       <td>Transition to an adjacent logical page of child items.</td>
   *     </tr>
   *     <tr>
   *       <td>Navigation Arrow</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Transition to an adjacent logical page of child items.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojConveyorBelt
   */

  /**
   * <p>If <code class="prettyprint">tabindex=0</code> ConveyorBelt supports the following keyboard interactions:
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>ConveyorBelt</td>
   *       <td><kbd>RightArrow or DownArrow</kbd></td>
   *       <td>Scrolls the content Right/Down.</td>
   *     </tr>
   *     <tr>
   *       <td>ConveyorBelt</td>
   *       <td><kbd>LeftArrow or UpArrow</kbd></td>
   *       <td>Scrolls the content Left/Up</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojConveyorBelt
   */

  //-----------------------------------------------------
  //                   Styling
  //-----------------------------------------------------
  /**
   * @ojstylevariableset oj-conveyor-belt-css-set1
   * @ojstylevariable oj-conveyor-belt-box-shadow-width {description: "Conveyor belt box-shadow width", formats: ["length"]}
   * @memberof oj.ojConveyorBelt
   */

  (function () {
    // start static members and functions //////////////////////////////////////////

    // FIX : log warning message when "disabled" property set
    /**
     * Warning message when "disabled" property is set.
     * @const
     * @private
     * @type {string}
     */
    var _WARNING_DISABLED_OPTION = "JET ConveyorBelt: 'disabled' property not supported";

    // make sure the collapseEventTimeout param is less than the one used in the unit tests
    // in order to ensure that the filmStrip listener gets the resize event before the unit test
    /**
     * Timeout in milliseconds for collapse event.
     * @const
     * @private
     * @type {number}
     */
    var _RESIZE_LISTENER_COLLAPSE_EVENT_TIMEOUT = 25;

    /**
     * Escape an html fragment/text.
     * @param {string} text Text to escape.
     * @returns {string} Escaped text.
     * @memberof oj.ojFilmStrip
     * @private
     */
    function _escapeHtml(text) {
      // let jQuery escape the text
      var jqDiv = $('<div></div>');
      jqDiv.text(text);
      return jqDiv[0].innerHTML; // @HTMLUpdateOK
    }

    // end static members and functions ////////////////////////////////////////////

    oj.__registerWidget('oj.ojConveyorBelt', $.oj.baseComponent, {
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',

      options: {
        /**
         * Specify the orientation of the conveyorBelt.
         *
         * @expose
         * @memberof oj.ojConveyorBelt
         * @instance
         * @ojwriteback
         * @type {string}
         * @ojvalue {string} "horizontal" Orient the conveyorBelt horizontally.
         * @ojvalue {string} "vertical" Orient the conveyorBelt vertically.
         * @default "horizontal"
         * @ojshortdesc Specifies the orientation of the conveyorBelt.
         *
         * @example <caption>Initialize the conveyorBelt with the
         * <code class="prettyprint">orientation</code> attribute specified:</caption>
         * &lt;oj-conveyor-belt orientation='vertical'>
         * &lt;/oj-conveyor-belt>
         *
         * @example <caption>Get or set the <code class="prettyprint">orientation</code>
         * property after initialization:</caption>
         * // getter
         * var orientation = myConveyorBelt.orientation;
         *
         * // setter
         * myConveyorBelt.orientation = 'vertical';
         */
        orientation: 'horizontal',
        /**
         * <p>Indicates whether overflow content arrows are visible or hidden.
         *
         * <p>The default value of this property varies by theme. If the default value is 'auto', then the behavior varies by device.
         *
         * @expose
         * @memberof oj.ojConveyorBelt
         * @instance
         * @since 9.0.0
         * @ojwriteback
         * @type {string}
         * @ojvalue {string} "auto" show overflow arrows on desktop, hide on mobile.
         * @ojvalue {string} "visible" always show overflow arrows.
         * @ojvalue {string} "hidden" never show overflow arrows.
         * @ojshortdesc Specifies visibility of overflow arrow buttons.
         *
         * @example <caption>Initialize the conveyorBelt with the
         * <code class="prettyprint">arrow-visibility</code> attribute specified:</caption>
         * &lt;oj-conveyor-belt arrow-visibility='auto'>
         * &lt;/oj-conveyor-belt>
         *
         * @example <caption>Get or set the <code class="prettyprint">arrow-visibility</code> property after initialization:</caption>
         * // getter
         * var arrowVisibilityValue = myConveyor.arrowVisibility;
         *
         * // setter
         * myConveyor.arrowVisibility = 'hidden';
         *
         * @example <caption>Set the default in the theme (SCSS) :</caption>
         * $conveyorBeltArrowVisibilityOptionDefault: visible !default;
         *
         */
        arrowVisibility: 'auto',
        /**
         * Specify the selector of the descendant DOM element in the conveyorBelt
         * that directly contains the items to scroll among.
         *
         * <p>This attribute value is <code class="prettyprint">null</code> by default,
         * meaning that the items to scroll among are direct children of the
         * oj-conveyor-belt.  In some cases, the items to scroll among
         * are not direct children of the oj-conveyor-belt, but are instead
         * nested in a descendant DOM element.  In such cases, this attribute should be
         * specified to point to the descendant DOM element whose direct children
         * are the items to scroll among.  For example, if the items to scroll
         * among are buttons in a buttonset, the buttons are direct children of
         * the DOM element representing the buttonset.  The buttonset would be
         * the direct child of the conveyorBelt.  If the
         * <code class="prettyprint">id</code> of the buttonset DOM element were
         * <code class="prettyprint">'myContentElem'</code>, then content-parent
         * would be specified as <code class="prettyprint">'#myContentElem'</code>.
         *
         * <p><b>WARNING:</b> The selector specified for this attribute should match
         * only a single descendant DOM element.  If multiple elements are matched,
         * then only the first one will be used.  Applications should not depend on
         * this behavior because we reserve the right to change it in the future in
         * order to allow and use multiple matching elements.
         *
         * @expose
         * @memberof oj.ojConveyorBelt
         * @instance
         * @ojwriteback
         * @type {?string}
         * @default null
         * @ojshortdesc Specify the selector of the descendant DOM element in the conveyorBelt that directly contains the items to scroll among.
         *
         * @example <caption>Initialize the conveyorBelt with the
         * <code class="prettyprint">content-parent</code> attribute specified:</caption>
         * &lt;oj-conveyor-belt content-parent='#myContentElem'>
         *   &lt;div id='myContentElem'>
         *     &lt;oj-button>Item 1&lt;/oj-button>
         *     &lt;oj-button>Item 2&lt;/oj-button>
         *     &lt;oj-button>Item 3&lt;/oj-button>
         *     &lt;oj-button>Item 4&lt;/oj-button>
         *     &lt;oj-button>Item 5&lt;/oj-button>
         *   &lt;/div>
         * &lt;/oj-conveyor-belt>
         *
         * @example <caption>Get or set the <code class="prettyprint">contentParent</code>
         * property after initialization:</caption>
         * // getter
         * var contentParent = myConveyorBelt.contentParent;
         *
         * // setter
         * myConveyorBelt.contentParent = '#myContentElem';
         */
        contentParent: null,
        /**
         * <p>Gets or sets the number of pixels that an element's content is scrolled from its initial position.
         *
         * <p>The default value of this property is 0.
         *
         * <p> There is no difference between LTR/RTL value assignment.
         * In both LTR and RTL values changes from 0 and max scroll position >=0  if we scroll to the end.
         * If we scroll to the beginning then the values changes from max scroll position >=0 to min scroll position = 0
         * When the value exceeds max/min the value is constrained to the max/min scroll position accordingly.
         *
         * @ojshortdesc Gets or sets the number of pixels that an element's content is scrolled from its initial position.
         * @expose
         * @public
         * @type {number}
         * @instance
         * @memberof oj.ojConveyorBelt
         * @default 0
         * @since 12.0.0
         * @ojwriteback
         *
         *
         * @example <caption>Get or set the <code class="prettyprint">scroll-position</code> property after initialization:</caption>
         * // getter
         * var scrollPosition = myConveyor.scrollPosition;
         *
         * // setter
         * myConveyor.scrollPosition = 10;
         *
         *
         */
        scrollPosition: 0

        /**
         * To avoid tight coupling between a ConveyorBelt and its contents, JET
         * ConveyorBelt does not support the <code class="prettyprint">disabled</code>
         * attribute.
         *
         * <p><b>WARNING:</b> Applications should not depend on this behavior
         * because we reserve the right to change it in the future in order to
         * support <code class="prettyprint">disabled</code> and propagate it to
         * child elements of ConveyorBelt.
         *
         * @member
         * @name disabled
         * @memberof oj.ojConveyorBelt
         * @instance
         * @type {boolean}
         * @default false
         * @ignore
         */
        // disabled attribute declared in superclass, but we still want the above API doc

        // Events

        /**
         * Triggered when the conveyorBelt is created.
         *
         * @event
         * @name create
         * @memberof oj.ojConveyorBelt
         * @instance
         * @ignore
         */
        // create event declared in superclass, but we still want the above API doc
      },

      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @return {void}
       * @override
       * @protected
       * @instance
       * @memberof oj.ojConveyorBelt
       */
      _ComponentCreate: function () {
        // Override of protected base class method.
        // call superclass first
        this._super();

        var elem = this.element;
        elem.addClass('oj-conveyorbelt oj-component');

        var options = this.options;
        // FIX : log warning message when "disabled" attribute set
        if (options.disabled) {
          Logger.warn(_WARNING_DISABLED_OPTION);
        }

        // FIX : remove override of _init() and call _setup() from here
        this._setup();
      },

      // This method currently runs at create, init, and refresh time (since refresh() is called by _init()).
      /**
       * Refreshes the visual state of the conveyorBelt. JET elements require a
       * <code class="prettyprint">refresh()</code> after the DOM is
       * programmatically changed underneath the element.
       *
       * <p>This method does not accept any arguments.
       *
       * @return {void}
       * @expose
       * @memberof oj.ojConveyorBelt
       * @instance
       * @ojshortdesc Refreshes the visual state of the conveyorBelt.
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myConveyorBelt.refresh();
       */
      refresh: function () {
        // Override of public base class method.
        this._super();

        // Check if the reading direction have changed
        var bRTL = this._GetReadingDirection() === 'rtl';
        var bDirectionChanged = this._bRTL !== bRTL;

        // save and restore scroll position only if the reading direction is not changed
        var scroll;
        // save the current scroll position
        if (!bDirectionChanged) {
          scroll = this._cbCommon.getScroll();
        }

        // destroy the cbCommon and setup from scratch in case items were added/removed
        this._destroyCBCommon();
        this._setup();

        // restore the saved scroll position
        if (!bDirectionChanged) {
          this._cbCommon.setScroll(scroll, true);
        }
      },

      /**
       * Notifies the component that its subtree has been made visible
       * programmatically after the component has been created.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @protected
       * @override
       */
      _NotifyShown: function () {
        this._super();
        // FIX : perform a deferred layout
        if (this._needsSetup) {
          this._setup();
        } else if (this._cbCommon) {
          // with internal flexbox layout, conveyor doesn't get notified when
          // content resizes while hidden, so explicitly handle a resize when
          // shown again
          var cbCommon = this._cbCommon;
          cbCommon.handleResize();
        }
      },

      /**
       * Notifies the component that its subtree has been connected to the document
       * programmatically after the component has been created.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @protected
       * @override
       */
      _NotifyAttached: function () {
        this._super();
        // FIX : perform a deferred layout
        if (this._needsSetup) {
          this._setup();
        } else if (this._cbCommon) {
          // with internal flexbox layout, conveyor doesn't get notified when
          // content resizes while detached, so explicitly handle a resize when
          // attached again
          var cbCommon = this._cbCommon;
          cbCommon.handleResize();
        }
      },

      /**
       * Setup the conveyorBelt.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _setup: function () {
        // Private, not an override (not in base class).
        var self = this;
        var elem = this.element;
        var options = this.options;
        var orientation = options.orientation;

        if (orientation === 'vertical') {
          elem.addClass('oj-conveyorbelt-vertical');
        } else {
          elem.removeClass('oj-conveyorbelt-vertical');
        }

        // FIX : if conveyor is detached or hidden, we can't layout
        // correctly, so defer layout until conveyor is attached or shown
        if (!this._canCalculateSizes()) {
          this._needsSetup = true;
          return;
        }
        this._needsSetup = null;

        this._bRTL = this._GetReadingDirection() === 'rtl';
        if (!this._cbCommon) {
          var prevStyleClass = null;
          var nextStyleClass = null;
          var prevIcon = null;
          var nextIcon = null;

          var animateScrollFunc = null;
          var tooltipNext = _escapeHtml(this.getTranslatedString('tipArrowNext'));
          var tooltipPrevious = _escapeHtml(this.getTranslatedString('tipArrowPrevious'));
          if (orientation !== 'vertical') {
            prevStyleClass = 'oj-enabled oj-conveyorbelt-overflow-indicator oj-start oj-default';
            nextStyleClass = 'oj-enabled oj-conveyorbelt-overflow-indicator oj-end oj-default';
            prevIcon = this._createIcon('oj-conveyorbelt-overflow-icon oj-start', tooltipPrevious);
            nextIcon = this._createIcon('oj-conveyorbelt-overflow-icon oj-end', tooltipNext);
            animateScrollFunc = this._animateScrollLeft.bind(this);
          } else {
            prevStyleClass = 'oj-enabled oj-conveyorbelt-overflow-indicator oj-top oj-default';
            nextStyleClass = 'oj-enabled oj-conveyorbelt-overflow-indicator oj-bottom oj-default';
            prevIcon = this._createIcon('oj-conveyorbelt-overflow-icon oj-top', tooltipPrevious);
            nextIcon = this._createIcon('oj-conveyorbelt-overflow-icon oj-bottom', tooltipNext);
            animateScrollFunc = this._animateScrollTop.bind(this);
          }

          var buttonInfo = {};

          if (options.arrowVisibility === 'auto') {
            buttonInfo.arrowVisibility =
              Config.getDeviceRenderMode() === 'phone' ? 'hidden' : 'visible';
          } else {
            buttonInfo.arrowVisibility = options.arrowVisibility;
          }

          buttonInfo.prevButtonStyleClass = prevStyleClass;
          buttonInfo.nextButtonStyleClass = nextStyleClass;
          buttonInfo.prevButtonIcon = prevIcon;
          buttonInfo.nextButtonIcon = nextIcon;
          var styleInfo = {};
          styleInfo.overflowContainerStyleClass = 'oj-conveyorbelt-overflow-container';

          styleInfo.contentContainerStyleClass = 'oj-conveyorbelt-content-container';
          styleInfo.itemStyleClass = 'oj-conveyorbelt-item';
          styleInfo.hiddenStyleClass = 'oj-helper-hidden';
          var callbackInfo = {};
          callbackInfo.addResizeListener = function (_elem, listener) {
            DomUtils.addResizeListener(_elem, listener, _RESIZE_LISTENER_COLLAPSE_EVENT_TIMEOUT);
          };
          callbackInfo.removeResizeListener = DomUtils.removeResizeListener;
          callbackInfo.addStyleClassName = this._addStyleClassName;
          callbackInfo.removeStyleClassName = this._removeStyleClassName;
          callbackInfo.hasStyleClassName = this._hasStyleClassName;
          callbackInfo.filterContentElements = function (arContentElements) {
            return self._filterContentElements(arContentElements);
          };
          callbackInfo.subtreeDetached = Components.subtreeDetached;
          callbackInfo.subtreeAttached = Components.subtreeAttached;
          callbackInfo.addBusyState = function (description) {
            return self._addBusyState(description);
          };
          callbackInfo.setScrollPositionProperty = function (value) {
            self.option('scrollPosition', value, {
              _context: { internalSet: true, writeback: true }
            });
          };
          // disable scroll animation during testing
          if (Config.getAutomationMode() !== 'enabled') {
            callbackInfo.scrollFunc = animateScrollFunc;
          }
          var contentParentElem = null;
          if (options.contentParent) {
            // only use the first result returned from the contentParent selector
            contentParentElem = $(options.contentParent)[0];
          }
          callbackInfo.handleFocus = function (event) {
            // if focus is on the conveyorbelt itself do nothing
            if (self.element[0].isEqualNode(event.target)) {
              return;
            }
            var conveyorBeltItems;
            if (contentParentElem != null) {
              conveyorBeltItems = contentParentElem.children;
            } else {
              conveyorBeltItems = self.element[0].getElementsByClassName('oj-conveyorbelt-item');
            }
            for (var j = 0; j < conveyorBeltItems.length; j++) {
              if (conveyorBeltItems[j].isEqualNode(event.target)) {
                self.scrollElementIntoView(conveyorBeltItems[j]);
                break;
              }
            }
          };
          this._cbCommon = new ConveyorBeltCommon(
            elem[0],
            {
              orientation: orientation,
              contentParent: contentParentElem,
              bRtl: this._bRTL,
              scrollPosition: options.scrollPosition
            },
            buttonInfo,
            callbackInfo,
            styleInfo
          );
        }

        var cbCommon = this._cbCommon;
        cbCommon.setup();
        var children = elem.find('.oj-conveyorbelt-overflow-indicator');
        // need to setup listeners for styles on each button individually so that callbacks for that
        // listener are specific to each button and don't affect both buttons at the same time
        for (var i = 0; i < children.length; i++) {
          this._setupButtonMouseStyles($(children[i]));
        }
      },

      /**
       * Setup conveyor resources
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @override
       * @protected
       */
      _SetupResources: function () {
        if (this._cbCommon) {
          this._cbCommon.setupResources();
        }
        this._super();
      },

      /**
       * Release conveyor resources
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @override
       * @protected
       */
      _ReleaseResources: function () {
        if (this._cbCommon) {
          this._cbCommon.releaseResources();
        }
        this._super();
      },

      /**
       * Destroy the conveyorBelt.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @override
       * @protected
       */
      _destroy: function () {
        // Override of protected base class method.
        this._destroyCBCommon();
        var elem = this.element;
        elem.removeClass('oj-conveyorbelt oj-component oj-conveyorbelt-vertical');

        // call superclass last
        this._super();
      },

      /**
       * Set an option on the conveyorBelt.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @override
       * @protected
       */
      _setOption: function (key, value, flags) {
        // Override of protected base class method.
        // Method name needn't be quoted since is in externs.js.
        var bRecreate = false;
        var options = this.options;
        switch (key) {
          // when changing containerParent or orientation, just destroy and recreate
          // the ConveyorBeltCommon
          case 'containerParent':
          case 'arrowVisibility':
            bRecreate = true;
            break;
          case 'orientation':
            bRecreate = options.orientation !== value;
            break;
          case 'scrollPosition':
            if (options.scrollPosition !== value) {
              this._cbCommon.setScroll(value, true);
            }
            break;
          case 'disabled':
            // FIX : log warning message when "disabled" attribute set
            Logger.warn(_WARNING_DISABLED_OPTION);
            break;
          default:
            break;
        }
        // if recreating, destroy the ConveyorBeltCommon before calling superclass
        // _setOption
        if (bRecreate) {
          this._destroyCBCommon();
        }
        if (key !== 'scrollPosition') {
          // For 'scrollPosition' the option value assignment and option change event
          // are done later in this.option(..) in the scroll callback
          this._super(key, value, flags);
        }
        // if recreating, setup the new ConveyorBeltCommon after calling superclass
        // _setOption
        if (bRecreate) {
          this._setup();
        }
      },

      /**
       * Destroy the ConveyorBeltCommon.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _destroyCBCommon: function () {
        var cbCommon = this._cbCommon;
        if (cbCommon) {
          // FIX : detach mouse listeners from overflow indicators
          // before destroying cbCommon in order to avoid memory leaks
          var elem = this.element;
          var children = elem.find('.oj-conveyorbelt-overflow-indicator');
          children.off(this.eventNamespace);

          cbCommon.destroy();
        }
        this._cbCommon = null;
      },

      /**
       * Determine whether the conveyorBelt can calculate sizes (when it is
       * attached to the page DOM and not hidden).
       * @returns {boolean} true if sizes can be calculated, false if not
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _canCalculateSizes: function () {
        var div = document.createElement('div');
        var style = div.style;
        style.width = '10px';
        style.height = '10px';

        // make sure flexbox layout doesn't grow/shrink the item
        style['-webkit-flex'] = '0 0 auto';
        style.flex = '0 0 auto';

        var elem = this.element[0];
        elem.appendChild(div); // @HTMLUpdateOK
        var bCanCalcSizes = false;
        try {
          bCanCalcSizes = div.offsetWidth > 0 && div.offsetHeight > 0;
        } catch (e) {
          // do nothing
        }
        elem.removeChild(div);
        return bCanCalcSizes;
      },

      /**
       * Setup mouse listeners to change button styles.
       * @param {Object} element jQuery element to affect
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _setupButtonMouseStyles: function (element) {
        //  - conveyorbelt next/previous oj-hover color don't go away
        this._AddHoverable({
          element: element,
          afterToggle: function (eventtype) {
            if (eventtype === 'mouseenter') {
              element.removeClass('oj-default');
            } else if (eventtype === 'mouseleave') {
              element.addClass('oj-default');
            }
          }
        });

        this._AddActiveable({
          element: element,
          afterToggle: function (eventtype) {
            if (
              eventtype === 'mousedown' ||
              eventtype === 'touchstart' ||
              eventtype === 'mouseenter'
            ) {
              element.removeClass('oj-default');
            } else if (
              eventtype === 'mouseup' ||
              eventtype === 'touchend' ||
              eventtype === 'touchcancel' ||
              eventtype === 'mouseleave'
            ) {
              element.addClass('oj-default');
            }
          }
        });
      },

      /**
       * Create a DOM element for a button with an icon.
       * @param {string} iconStyleClass Style class for the icon
       * @returns {Element} Button with Icon DOM element
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _createIcon: function (iconStyleClass, tooltip) {
        var span = document.createElement('span');
        span.setAttribute('class', 'oj-component-icon ' + iconStyleClass);
        var innerButton = document.createElement('div');
        innerButton.setAttribute('class', 'oj-conveyorbelt-overflow-button');
        innerButton.setAttribute('role', 'button');
        innerButton.appendChild(span);
        innerButton.setAttribute('title', tooltip);

        return innerButton;
      },

      /**
       * Animate setting the scrollLeft DOM property.
       * @param {Element} elem DOM element to scroll
       * @param {number} value Scroll value
       * @param {number} duration Duration of animation, in ms
       * @param {function():void} onEndFunc Function to call when the animation ends
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _animateScrollLeft: function (elem, value, duration, onEndFunc) {
        var props = {};
        props.scrollLeft = value;
        // use swing instead of easeInOutCubic because easeInOutCubic isn't found
        // when running in the cookbook
        $(elem).animate(props, duration, 'swing', onEndFunc);
      },

      /**
       * Animate setting the scrollTop DOM property.
       * @param {Element} elem DOM element to scroll
       * @param {number} value Scroll value
       * @param {number} duration Duration of animation, in ms
       * @param {function():void} onEndFunc Function to call when the animation ends
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _animateScrollTop: function (elem, value, duration, onEndFunc) {
        var props = {};
        props.scrollTop = value;
        // use swing instead of easeInOutCubic because easeInOutCubic isn't found
        // when running in the cookbook
        $(elem).animate(props, duration, 'swing', onEndFunc);
      },

      /**
       * Add a style class name to an element.
       * @param {Object} elem Element to which to add style class.
       * @param {string} styleClass Style class name to add.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _addStyleClassName: function (elem, styleClass) {
        $(elem).addClass(styleClass);
      },

      /**
       * Remove a style class name from an element.
       * @param {Object} elem Element from which to remove style class.
       * @param {string} styleClass Style class name to remove.
       * @return {void}
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _removeStyleClassName: function (elem, styleClass) {
        $(elem).removeClass(styleClass);
      },

      /**
       * Determine whether the given style class name is applied to the given
       * element.
       * @param {Object} elem Element to check for style class name.
       * @param {string} styleClass Style class name for which to look.
       * @returns {boolean} true if style class name is applied, false if not
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _hasStyleClassName: function (elem, styleClass) {
        return $(elem).hasClass(styleClass);
      },

      /**
       * Filter the given array of conveyor content elements to remove extraneous elements, like the
       * divs added by the resize listener.
       * @param {Array} arContentElements Array of conveyor content elements.
       * @returns {Array} filtered array of conveyor content elements
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _filterContentElements: function (arContentElements) {
        var ret = [];
        for (var i = 0; i < arContentElements.length; i++) {
          var contentElem = arContentElements[i];
          if (
            !this._hasStyleClassName(contentElem, 'oj-helper-detect-expansion') &&
            !this._hasStyleClassName(contentElem, 'oj-helper-detect-contraction')
          ) {
            ret.push(contentElem);
          }
        }
        return ret;
      },

      /**
       * Add a busy state to the busy context.
       *
       * @param {string} description Additional information about busy state.
       * @returns {Function} Resolve function called by the registrant when the busy state completes.
       *          The resultant function will throw an error if the busy state is no longer registered.
       * @memberof oj.ojConveyorBelt
       * @instance
       * @private
       */
      _addBusyState: function (description) {
        var element = this.element;
        var context = Context.getContext(element[0]);
        var busyContext = context.getBusyContext();

        var desc = 'ConveyorBelt';
        var id = element.attr('id');
        desc += " (id='" + id + "')";
        desc += ': ' + description;

        var busyStateOptions = { description: desc };
        return busyContext.addBusyState(busyStateOptions);
      },

      // @inheritdoc
      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element[0];
        }

        var subId = locator.subId;
        if (subId === 'oj-conveyorbelt-start-overflow-indicator') {
          return this.widget().find('.oj-conveyorbelt-overflow-indicator.oj-start')[0];
        }
        if (subId === 'oj-conveyorbelt-end-overflow-indicator') {
          return this.widget().find('.oj-conveyorbelt-overflow-indicator.oj-end')[0];
        }
        if (subId === 'oj-conveyorbelt-top-overflow-indicator') {
          return this.widget().find('.oj-conveyorbelt-overflow-indicator.oj-top')[0];
        }
        if (subId === 'oj-conveyorbelt-bottom-overflow-indicator') {
          return this.widget().find('.oj-conveyorbelt-overflow-indicator.oj-bottom')[0];
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      // @inheritdoc
      getSubIdByNode: function (node) {
        var startIndicator = this.getNodeBySubId({
          subId: 'oj-conveyorbelt-start-overflow-indicator'
        });
        var endIndicator = this.getNodeBySubId({ subId: 'oj-conveyorbelt-end-overflow-indicator' });
        var topIndicator = this.getNodeBySubId({ subId: 'oj-conveyorbelt-top-overflow-indicator' });
        var bottomIndicator = this.getNodeBySubId({
          subId: 'oj-conveyorbelt-bottom-overflow-indicator'
        });
        var currentNode = node;
        var elem = this.element[0];
        while (currentNode && currentNode !== elem) {
          if (currentNode === startIndicator) {
            return { subId: 'oj-conveyorbelt-start-overflow-indicator' };
          } else if (currentNode === endIndicator) {
            return { subId: 'oj-conveyorbelt-end-overflow-indicator' };
          } else if (currentNode === topIndicator) {
            return { subId: 'oj-conveyorbelt-top-overflow-indicator' };
          } else if (currentNode === bottomIndicator) {
            return { subId: 'oj-conveyorbelt-bottom-overflow-indicator' };
          }

          currentNode = currentNode.parentElement;
        }
        return null;
      },

      /**
       * Scrolls child item of conveyor belt into the view.
       *
       *
       * @param {Element} elem DOM element to scroll
       * @return {void}
       * @expose
       * @memberof oj.ojConveyorBelt
       * @instance
       * @since 9.0.0
       * @ojshortdesc Scrolls child item of conveyor belt into the view.
       *
       * @example <caption>Invoke the <code class="prettyprint">scrollElementIntoView</code> method:</caption>
       * myConveyorBelt.scrollElementIntoView(element);
       */
      scrollElementIntoView: function (element) {
        if (!this._cbCommon) {
          // JET-56499 - ignore this method call until conveyor has been initialized
          return;
        }
        var currentScroll = this._cbCommon.getScroll();
        var currentViewportSize = this._cbCommon._getCurrViewportSize();

        var contentWidth = this._cbCommon._contentContainer.offsetWidth;

        var elementOffLeft = element.offsetLeft;
        // FIX : in IE, the conveyor items all report offsetLeft=0,
        // so we need to get the offset from the parent wrapping table cell div
        // instead
        if (!this._cbCommon._contentParent && elementOffLeft === 0) {
          elementOffLeft = element.parentNode.offsetLeft;
        }

        // if RTL, still want to save the start coords in logical, ascending order beginning with 0
        if (this._cbCommon._bRtl) {
          elementOffLeft = contentWidth - (elementOffLeft + element.offsetWidth);
        }
        // FIX : in IE, the conveyor items all report offsetTop=0,
        // so we need to get the offset from the parent wrapping table cell div
        // instead
        var elementOffTop = element.offsetTop;
        if (!this._cbCommon._contentParent && elementOffTop === 0) {
          elementOffTop = element.parentNode.offsetTop;
        }
        if (this._cbCommon._isHorizontal()) {
          // horizontal conveyor belt
          // if the element is in the current horizontal view port, then we don't need to scroll
          if (
            elementOffLeft + element.offsetWidth <= currentScroll + currentViewportSize &&
            elementOffLeft >= currentScroll &&
            elementOffLeft > this._cbCommon._getButtonSize()
          ) {
            return;
          }

          // if vertical conveyor belt and the element is in the current vertical view port, then we don't need to scroll
        } else if (
          elementOffTop + element.offsetHeight <= currentScroll + currentViewportSize &&
          elementOffTop >= currentScroll &&
          elementOffTop > this._cbCommon._getButtonSize()
        ) {
          return;
        }

        var contentContainer = this._cbCommon._contentContainer;
        var cbcClass = ConveyorBeltCommon;
        var elemInnerSize = this._cbCommon._isHorizontal()
          ? cbcClass._getElemInnerWidth(this.element[0])
          : cbcClass._getElemInnerHeight(this.element[0]);
        this._cbCommon._minScroll = 0;
        // take the button size into account for max scroll position
        this._cbCommon._maxScroll = this._cbCommon._isHorizontal()
          ? contentContainer.offsetWidth - elemInnerSize + this._cbCommon._buttonWidth
          : contentContainer.offsetHeight - elemInnerSize + this._cbCommon._buttonHeight;
        // constrain max scroll
        if (this._cbCommon._maxScroll < 0) {
          this._cbCommon._maxScroll = 0;
        }
        var scroll = 0;
        if (this._cbCommon._isHorizontal()) {
          // scroll conveyor belt in case of a horizontal conveyorbelt
          scroll = elementOffLeft;
        } else {
          // scroll conveyor belt in case of a vertical conveyorbelt
          scroll = elementOffTop;
        }
        if (scroll <= this._cbCommon._getButtonSize()) {
          scroll = this._cbCommon._minScroll;
        }
        this._cbCommon._setCurrScroll(scroll, true);
      }
    }); // end of oj.__registerWidget

    // Set theme-based defaults
    Components.setDefaultOptions({
      ojConveyorBelt: {
        arrowVisibility: Components.createDynamicPropertyGetter(function () {
          return ThemeUtils.getCachedCSSVarValues([
            '--oj-private-conveyor-belt-global-arrow-visibility-default'
          ])[0];
        })
      }
    });
  })(); // end of ConveyorBelt wrapper function

});


define('ojs/ojcollapsible',['ojs/ojcore-base', 'jquery', 'ojs/ojcomponentcore', 'ojs/ojcontext', 'ojs/ojdomutils', 'ojs/ojcustomelement', 'ojs/ojanimation', 'ojs/ojcustomelement-utils'], function (oj, $, Components, Context, DomUtils, ojcustomelement, ojanimation, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

var __oj_collapsible_metadata = 
{
  "properties": {
    "disabled": {
      "type": "boolean",
      "value": false
    },
    "expandArea": {
      "type": "string",
      "enumValues": [
        "disclosureIcon",
        "header"
      ],
      "value": "header"
    },
    "expanded": {
      "type": "boolean",
      "writeback": true,
      "value": false,
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "getterOnly"
            }
          ]
        }
      }
    },
    "translations": {
      "type": "object",
      "value": {}
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojBeforeCollapse": {},
    "ojBeforeExpand": {},
    "ojCollapse": {},
    "ojExpand": {}
  },
  "extension": {}
};
  /* global __oj_collapsible_metadata */
  (function () {
    __oj_collapsible_metadata.extension._WIDGET_NAME = 'ojCollapsible';
    __oj_collapsible_metadata.extension._CONTROLS_SUBTREE_HIDDEN = true;
    oj.CustomElementBridge.register('oj-collapsible', { metadata: __oj_collapsible_metadata });
  })();

  /**
   * @ojcomponent oj.ojCollapsible
   * @augments oj.baseComponent
   * @since 0.6.0
   *
   * @class oj.ojCollapsible
   * @ojshortdesc A collapsible displays a header that can be expanded to show its content.
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["expandArea", "expanded", "disabled"]}
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-collapsible'
   * @ojuxspecs ['collapsible-header']
   *
   * @classdesc
   * <h3 id="collapsibleOverview-section">
   *   JET Collapsible
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#collapsibleOverview-section"></a>
   * </h3>
   *
   * <p>Description: A JET Collapsible displays a header that can be expanded to show additional content beneath it.
   * The child element of the oj-collapsible in the named <a href="#header">header</a> slot is displayed in the header, while the child element in the <a href="#Default">default</a> slot is displayed as the content.
   *
   * <p>Note for performance reasons, if the collapsible content is expensive to render, you should wrap it in an <code class="prettyprint">oj-defer</code> element (API doc {@link oj.ojDefer}) to defer the rendering of that content.<br/>
   * See the Collapsible - Deferred Rendering demo for an example.</p>
   *
   * <pre class="prettyprint"><code>
   * &lt;oj-collapsible>
   *   &lt;h3 slot='header'>Header 1&lt;/h3>
   *   &lt;p>Content 1&lt;/p>
   * &lt;/oj-collapsible>
   * </code></pre>
   *
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   *  </h3>
   *  To migrate from oj-collapsible to oj-c-collapsible, you need to revise the import statement and references to oj-c-collapsible in your app.
   *  In addition, please note the changes between the two components below.
   *  <h5>oj-header-border style class</h5>
   *  <p>The <code class="prettyprint">oj-header-border</code> style class should no longer be used with oj-c-collapsible.
   *     To display a divider between the collapsible header and content, set the <code class="prettyprint">variant</code> property value
   *     to <code class="prettyprint">horizontal-rule</code>
   *  </p>
   *  <h5>Child margins</h5>
   *   <p>By default, <code class="prettyprint">oj-c-collapsible</code> removes margins from children passed
   *      in the <code class="prettyprint">header</code> and default (content) slots. To preserve the margins,
   *      wrap the header or content elements in an extra <code class="prettyprint">div</code>.
   *   </p>
   *  <h5>expand-area attribute</h5>
   *   <p>The <code class="prettyprint">expand-area</code> attribute will not be supported in oj-c-collapsible.
   *      A click anywhere in the header area will toggle disclosure which has always been  the default behavior for oj-collapsible too.
   *   </p>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>In the unusual case that the directionality (LTR or RTL) changes post-init, the collapsible must be <code class="prettyprint">refresh()</code>ed.
   *
   * <h3 id="data-attributes-section">
   *   Custom Data Attributes
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
   * </h3>
   *
   * <p>Collapsible supports the following custom data attributes.
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Name</th>
   *       <th>Description</th>
   *       <th>Example</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>data-oj-clickthrough</kbd></td>
   *       <td><p>Specify on any element inside the header where you want to control whether Collapsible should toggle disclosure by
   *           an event originating from the element or one of its descendants.</p>
   *           <p>For example, if you specify this attribute with a value of "disabled" on a button inside the header, then Collapsible
   *           will not trigger disclosure when user clicks on the button.</p>
   *       </td>
   *       <td>
   *         <pre class="prettyprint"><code>&lt;oj-collapsible>
   *   &lt;div slot="header">
   *     &lt;h3>Header 3&lt;/h3>
   *     &lt;oj-button data-oj-clickthrough="disabled">&lt;/oj-button
   *   &lt;/div>
   *   &lt;p>Content&lt;/p>
   * &lt;/oj-collapsible></code></pre>
   *       </td>
   *     </tr>
   *   </tbody>
   * </table>
   */
  //-----------------------------------------------------
  //                   Slots
  //-----------------------------------------------------

  /**
   * <p>The default slot is the collapsible's content.
   *
   * @ojchild Default
   * @memberof oj.ojCollapsible
   *
   * @example <caption>Initialize the Collapsible with child content specified:</caption>
   * &lt;oj-collapsible>
   *   &lt;h3 slot='header'>Header 1&lt;/h3>
   *   &lt;p>Content 1&lt;/p>
   * &lt;/oj-collapsible>
   */

  /**
   * <p>The <code class="prettyprint">header</code> slot is the collapsible's header. If not specified, the header contains only an open/close icon. Note that the header text is required for JET collapsible for accessibility purposes.</p>
   *
   * @ojslot header
   * @memberof oj.ojCollapsible
   *
   * @example <caption>Initialize the Collapsible with the header slot specified:</caption>
   * &lt;oj-collapsible>
   *   &lt;h3 slot='header'>Header 1&lt;/h3>
   *   &lt;p>Content 1&lt;/p>
   * &lt;/oj-collapsible>
   */

  /**
   * <p>Sub-ID for the disclosure icon of a Collapsible.</p>
   *
   * @ojsubid oj-collapsible-disclosure
   * @memberof oj.ojCollapsible
   * @example <caption>Get the Collapsible disclosure icon:</caption>
   * var node = myCollapsible.getNodeBySubId({"subId": "oj-collapsible-disclosure"});
   */
  //-----------------------------------------------------
  //                   Fragments
  //-----------------------------------------------------
  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Header</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Toggle disclosure state</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojCollapsible
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Header</td>
   *       <td><kbd>Space or Enter</kbd></td>
   *       <td>Toggle disclosure state.</tr>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojCollapsible
   */

  //------------------------------------------------------
  //                  Styling Start
  //------------------------------------------------------
  /**
   * Use on any element inside the header where you do not want Collapsible to process the click event.
   * @ojstyleclass oj-clickthrough-disabled
   * @ojdisplayname Prevent Clickthrough
   * @ojstyleselector oj-collapsible *
   * @ojdeprecated {since: '12.0.0', description: 'Specify data-oj-clickthrough attribute with value disabled instead.'}
   * @memberof oj.ojCollapsible
   * @ojtsexample
   * &lt;oj-collapsible id="collapsibleId">
   *   &lt;span slot='header'>
   *      &lt;h3>Header&lt;/h3>
   *      &lt;oj-button class="oj-clickthrough-disabled">Click&lt;/oj-button>
   *   &lt;/span>
   *   &lt;!-- Content -->
   * &lt;/oj-collapsible>
   */

  (function () {
    var uid = 0;
    var OPEN_ICON = 'oj-collapsible-open-icon';
    var CLOSE_ICON = 'oj-collapsible-close-icon';

    const OJC_HEADER = 'oj-collapsible-header';
    const OJC_TRANSITION = 'oj-collapsible-transition';
    const OJC_DISCLOSURE = 'oj-collapsible-disclosure';

    const OJ_ARIA_EXPANDED = 'aria-expanded';
    const OJ_ARIA_HIDDEN = 'aria-hidden';

    oj.__registerWidget('oj.ojCollapsible', $.oj.baseComponent, {
      widgetEventPrefix: 'oj',
      options: {
        /**
         * Specifies if the content is expanded.
         *
         * @expose
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Specifies if the content is expanded.
         * @type {boolean}
         * @default false
         * @ojwriteback
         * @ojeventgroup common
         * @ojwebelementstatus {
         *   type: "getterOnly"
         * }
         * @example <caption>Initialize the collapsible with the <code class="prettyprint">expanded</code> attribute specified:</caption>
         * &lt;oj-collapsible expanded='true'>&lt;/oj-collapsible>
         *
         * @example <caption>Get or set the <code class="prettyprint">expanded</code> property after initialization:</caption>
         * // getter
         * var expandedValue = myCollapsible.expanded;
         *
         * // setter
         * myCollapsible.expanded = false;
         */
        expanded: false,

        /**
         * Disables the collapsible if set to <code class="prettyprint">true</code>.
         * @name disabled
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Disables the collapsible if set to true.
         * @type {boolean}
         * @default false
         * @example <caption>Initialize the collapsible with the <code class="prettyprint">disabled</code> attribute specified:</caption>
         * &lt;oj-collapsible disabled='true'>&lt;/oj-collapsible>
         *
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization:</caption>
         * // getter
         * var disabledValue = myCollapsible.disabled;
         *
         * // setter
         * myCollapsible.disabled = false;
         */
        disabled: false,

        /**
         * The type of event to expand/collapse the collapsible.
         * To expand the collapsible on hover, use "mouseover".
         *
         * @ignore
         * @ojtsignore
         * @expose
         * @memberof oj.ojCollapsible
         * @instance
         * @type {string}
         * @default "click"
         */
        expandOn: 'click',

        /**
         * Where in the header to click to toggle disclosure.
         *
         * @expose
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Where in the header to click to toggle disclosure.
         * @type {string}
         * @ojvalue {string} "header" click any where in the header to toggle disclosure
         * @ojvalue {string} "disclosureIcon" click the disclosureIcon to toggle disclosure
         * @default "header"
         * @ojdeprecated {since: '14.0.0', description: 'The expand-area attribute should no longer be used and will be removed in the future.
         *                A click anywhere in the header area will toggle the disclosure (current default setting).'}
         *
         * @example <caption>Initialize the collapsible with the <code class="prettyprint">expand-area</code> attribute specified:</caption>
         * &lt;oj-collapsible expand-area='disclosureIcon'>&lt;/oj-collapsible>
         *
         * @example <caption>Get or set the <code class="prettyprint">expand-area</code> property after initialization:</caption>
         * // getter
         * var expandAreaValue = myCollapsible.expandArea;
         *
         * // setter
         * myCollapsible.expandArea = 'disclosureIcon';
         */
        expandArea: 'header',

        // callbacks
        /**
         * Triggered immediately before the collapsible is expanded.
         * Call <code class="prettyprint">event.preventDefault()</code> in the event listener to veto the event, which prevents the content from expanding.
         *
         * @expose
         * @event
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Triggered immediately before the collapsible is expanded.
         * @ojcancelable
         * @property {Element} header The header that is about to be expanded.
         * @property {Element} content The content that is about to be expanded.
         */
        beforeExpand: null,

        /**
         * Triggered after the collapsible has been expanded (after animation completes).
         *
         * @expose
         * @event
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Triggered immediately after the collapsible is expanded.
         * @property {Element} header The header that was just expanded.
         * @property {Element} content The content that was just expanded.
         */
        expand: null,

        /**
         * Triggered immediately before the collapsible is collapsed.
         * Call <code class="prettyprint">event.preventDefault()</code> in the event listener to veto the event, which prevents the content from collapsing.
         *
         * @expose
         * @event
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Triggered immediately before the collapsible is collapsed.
         * @ojcancelable
         * @property {Element} header The header that is about to be collapsed.
         * @property {Element} content The content that is about to be collapsed.
         */
        beforeCollapse: null,

        /**
         * Triggered after the collapsible has been collapsed.
         *
         * @expose
         * @event
         * @memberof oj.ojCollapsible
         * @instance
         * @ojshortdesc Triggered immediately after the collapsible is collapsed.
         * @property {Element} header The header that was just collapsed.
         * @property {Element} content The content that was just collapsed.
         */
        collapse: null
      },

      /**
       * @memberof oj.ojCollapsible
       * @instance
       * @protected
       * @override
       */
      _ComponentCreate: function () {
        this._super();

        //  - Stop using ui-helper-reset in the layout widgets.
        this.element.addClass('oj-collapsible oj-component');

        this._processPanels();
        this._refresh();

        //  - collapsible shouldn't implement _init()
        this._initialRender = true;

        // don't fire event on initial render
        var elem = this.element[0];
        this._expandCollapseHandler(
          this._createEventObject(elem, this.options.expanded ? 'ojexpand' : 'ojcollapse')
        );

        this._initialRender = undefined;
      },

      /**
       * Returns the focus element.
       * @return {Element} the focus element inside ojCollapsible or the root element
       * @protected
       * @ignore
       */

      GetFocusElement: function () {
        if (!this._isDisabled()) {
          return this._getCollapsibleIcon()[0];
        }

        return this.element[0];
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _createEventObject: function (element, type) {
        return {
          type: type,
          target: element,
          currentTarget: element,
          preventDefault: $.noop
        };
      },

      /**
       * @memberof oj.ojCollapsible
       * @param {Object} menu The JET Menu to open as a context menu
       * @param {Event} event What triggered the menu launch
       * @param {string} eventType "mouse", "touch", "keyboard"
       * @private
       */
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        // Setting the launcher to the "twisty" icon, since that seems to be the only tabbable thing in the collapsible,
        // and it seems to remain tabbable even if the collapsible is disabled.  See the superclass JSDoc for _OpenContextMenu
        // for tips on choosing a launcher.
        this._OpenContextMenu(event, eventType, { launcher: this._getCollapsibleIcon().first() });
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _createIcons: function () {
        var options = this.options;
        var icon = options.expanded ? OPEN_ICON : CLOSE_ICON;
        var iconTag = this._isDisabled() ? $('<span>') : $('<a tabindex="0">');

        iconTag
          .addClass(
            'oj-component-icon oj-clickable-icon-nocontext oj-collapsible-header-icon ' + icon
          )
          .attr('aria-labelledby', this.header.attr('id'))
          .prependTo(this.headerWrapper); // @HTMLUpdateOK
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _destroyIcons: function () {
        this.headerWrapper.children('.oj-collapsible-header-icon').remove();
      },

      /**
       * @memberof oj.ojCollapsible
       * @override
       * @private
       */
      _destroy: function () {
        //  - ojcollapsible should resolve busy state when it's destroyed
        this._resolveBusyContext();
        this._cleanup();

        // clean up main element
        this.element.removeClass('oj-collapsible oj-component oj-expanded oj-collapsed oj-disabled');

        // clean up headers
        if (this._isDisabled()) {
          this._findFocusables(this.headerWrapper).removeAttr('tabIndex');
        }

        this.header.removeClass(OJC_HEADER).each(this._removeIdAttr.bind(this));

        // aria
        var focusable = this._findFirstFocusableInHeader();
        focusable
          .removeAttr('role')
          .removeAttr('aria-controls')
          .removeAttr(OJ_ARIA_EXPANDED)
          .removeAttr('aria-disabled');

        this._destroyIcons();

        // clean up content panels
        this.content
          .css('display', '')
          .removeAttr(OJ_ARIA_HIDDEN)
          .removeAttr('tabIndex')
          .removeClass('oj-component-content oj-collapsible-content')
          .each(this._removeIdAttr.bind(this));
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _cleanup: function () {
        // remove listeners
        this._tearDownEvents();

        // remove header wrapper
        if (this.header && this.headerWrapper) {
          DomUtils.unwrap(this.header);
          this.headerWrapper = null;
        }

        // remove wrapper
        if (this.content) {
          //  - DomUtils.unwrap() will avoid unwrapping if the node is being destroyed by Knockout
          DomUtils.unwrap(this.content);
          this.wrapper = null;
        }
        // TODO: remove oj-disabled
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _isDisabled: function () {
        return this.element.hasClass('oj-disabled');
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _getExpandAreaSelector: function () {
        if (this.options.expandArea === 'header') {
          return '> .oj-collapsible-header-wrapper';
        }
        return '> .oj-collapsible-header-wrapper > .oj-collapsible-header-icon';
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _getCollapsibleIcon: function () {
        return this.headerWrapper.find('.oj-collapsible-header-icon');
      },

      /**
       * @memberof oj.ojCollapsible
       * @override
       * @private
       */
      _setOption: function (key, value, flags) {
        if (key === 'expanded') {
          if (value === this.options.expanded) {
            return;
          }

          if (value) {
            this.expand(true);
          } else {
            this.collapse(true);
          }
          return;
        }

        // #5332 - opacity doesn't cascade to positioned elements in IE
        // so we need to add the disabled class to the headers and panels
        if (key === 'disabled') {
          this._super(key, value, flags);
          this.refresh();
          return;
        }

        if (key === 'expandOn' || key === 'expandArea') {
          this._tearDownEvents();
          this._super(key, value, flags);
          this._setupEvents();
        } else {
          this._super(key, value, flags);
        }
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _keydown: function (event) {
        if (event.altKey || event.ctrlKey) {
          return;
        }
        // JET-58821: ignore the key event if it does not come from the icon or header wrapper itself
        var target = event.target;
        if (target !== this._getCollapsibleIcon()[0] && target !== this.headerWrapper[0]) {
          return;
        }

        var keyCode = $.ui.keyCode;

        switch (event.keyCode) {
          case keyCode.SPACE:
          case keyCode.ENTER:
            this._toggleHandler(event);
            break;
          default:
        }
      },

      /**
       * Refreshes the visual state of the collapsible.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @memberof oj.ojCollapsible
       * @instance
       * @return {void}
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myCollapsible.refresh();
       */
      refresh: function () {
        this._super();
        this._destroyIcons();
        this._cleanup();
        this._processPanels();
        this._refresh();
      },

      /**
       * Make sure the header slot is the first child of the root element
       * If the slot header is not specified, it will create one with empty text
       * @memberof oj.ojCollapsible
       * @private
       */
      _processHeaderSlots: function () {
        var elem = this.element[0];
        var newHeader = false;

        // add the header node if not specified
        var headers = ojcustomelementUtils.CustomElementUtils.getSlotMap(elem).header;
        var header;

        if (headers && headers.length) {
          // exactly one child element has the "header" named slot
          if (headers.length === 1) {
            header = headers[0];
          } else {
            // multiple child elements have the "header" named slots, combine them
            var $header = $("<span slot='header'></span>");
            header = $header[0];

            for (var i = 0; i < headers.length; i++) {
              header.appendChild(headers[i]); // @HTMLUpdateOK
            }
            $header.children().attr('slot', '');
            newHeader = true;
          }
        } else {
          header = $("<span slot='header'></span>")[0];
          newHeader = true;
        }

        // make the header slot be the first child
        // Note prepend doesn't work in IE11 and Edge, use insertBefore instead
        if (newHeader || this.element.children().index(header) !== 0) {
          elem.insertBefore(header, elem.firstChild); // @HTMLUpdateOK
        }

        return $(header);
      },

      /**
       * Make sure the default slots are the last child of the root element
       * If there are multiple default slots, combine them
       * @memberof oj.ojCollapsible
       * @private
       */
      _processDefaultSlots: function () {
        var elem = this.element[0];

        var contents = ojcustomelementUtils.CustomElementUtils.getSlotMap(elem)[''];
        var content;

        if (contents && contents.length === 1) {
          content = contents[0];
        } else {
          var $content = $('<div></div>');
          content = $content[0];
          if (contents && contents.length) {
            for (var i = 0; i < contents.length; i++) {
              content.appendChild(contents[i]); // @HTMLUpdateOK
            }
          }
          // add the content slot
          // Note: append doesn't work in IE11 and Edge, use appendChild instead
          elem.appendChild(content); // @HTMLUpdateOK
        }

        return $(content);
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _processPanels: function () {
        // process header
        if (this._IsCustomElement()) {
          this.header = this._processHeaderSlots();
        } else {
          //  - Stop using ui-helper-reset in the layout widgets.
          this.header = this.element.children(':first-child');
        }
        this.header.addClass(OJC_HEADER);

        // process content
        if (this._IsCustomElement()) {
          this.content = this._processDefaultSlots();
        } else {
          this.content = this.header.next();
        }
        this.content.addClass('oj-collapsible-content oj-component-content');

        this.content.wrap('<div></div>'); // @HTMLUpdateOK
        this.wrapper = this.content.parent().addClass('oj-collapsible-wrapper');

        if (this.options.disabled) {
          this.element.addClass('oj-disabled');
        }

        // wrap header in another div for A11Y
        this.header.wrap('<div></div>'); // @HTMLUpdateOK
        this.headerWrapper = this.header.parent().addClass('oj-collapsible-header-wrapper');

        if (this.header.hasClass('oj-header-border')) {
          this.headerWrapper.addClass('oj-header-border');
        }

        // Note: must set tabIndex=-1 to focusable elements
        // to avoid tabbing in a disabled header
        if (this._isDisabled()) {
          this._findFocusables(this.headerWrapper).attr('tabIndex', -1);
        }
      },

      /**
       * Used for explicit cases where the component needs to be refreshed
       * (e.g., when the value option changes or other UI gestures).
       * @memberof oj.ojCollapsible
       * @private
       */
      _refresh: function () {
        var header = this.header;
        var content = this.content;
        var options = this.options;

        var id = this.element.attr('id');
        if (!id) {
          uid += 1;
          id = uid;
        }

        var collapsibleId = 'oj-collapsible-' + id;
        this.collapsibleId = collapsibleId;

        var headerId = header.attr('id');
        var contentId = content.attr('id');

        if (!headerId) {
          headerId = collapsibleId + '-header';
          header.attr('id', headerId);
        }
        if (!contentId) {
          contentId = collapsibleId + '-content';
          content.attr('id', contentId);
        }

        // aria
        this._createIcons();
        var focusable = this._findFirstFocusableInHeader();
        focusable
          .attr('role', 'button')
          .attr('aria-controls', contentId)
          .attr(OJ_ARIA_EXPANDED, options.expanded); // @HTMLUpdateOK
        // .attr('aria-expanded', options.expanded);

        if (this._isDisabled()) {
          focusable.attr('aria-disabled', 'true');
        }

        //  - when collapsible is refreshed, it's content displays & disclosure icon collapsed
        if (options.expanded) {
          content.removeAttr(OJ_ARIA_HIDDEN);
        } else {
          this.wrapper.css({
            'max-height': 0,
            'overflow-y': 'hidden',
            display: 'none'
          });
          // content.attr('aria-hidden', 'true');
          content.attr(OJ_ARIA_HIDDEN, 'true'); // @HTMLUpdateOK
        }

        this._setupEvents();
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _setupEvents: function () {
        var events = {
          keydown: this._keydown
        };

        var event = this.options.expandOn;
        if (event) {
          var self = this;
          $.each(event.split(' '), function (index, eventName) {
            // security test
            if (DomUtils.isValidIdentifier(eventName)) {
              events[eventName] = self._toggleHandler;
            }
          });
        }

        var expandArea = this.element.find(this._getExpandAreaSelector());

        // add listeners on expandArea (event expandArea)
        this._on(expandArea, events);

        this._on(this.wrapper, {
          transitionend: this._transitionEndHandler,
          webkitTransitionEnd: this._transitionEndHandler
        });

        if (!this._isDisabled()) {
          this._on(this.element, {
            ojfocus: this._focusHandler,
            ojfocusout: this._focusHandler
          });

          this._focusable({
            element: this._getCollapsibleIcon(),
            applyHighlight: true
          });

          this._AddHoverable(expandArea);
          this._AddActiveable(expandArea);
        }
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _tearDownEvents: function () {
        var expandArea = this.element.find(this._getExpandAreaSelector());

        this._RemoveHoverable(expandArea);
        this._RemoveActiveable(expandArea);
        this._off(expandArea);

        // remove wrapper listeners
        if (this.wrapper) {
          this._off(this.wrapper);
        }
        this._off(this.element.add(this.content));
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _toggleHandler: function (event) {
        if (this._isDisabled() || event.isDefaultPrevented()) {
          return;
        }

        //  - click on button in header slot propagates to collapse/expand action
        var target = $(event.target);
        for (; target.length && target[0] !== this.header[0]; target = target.parent()) {
          if (target.attr('data-oj-clickthrough') === 'disabled') {
            return;
          }
          /**
           * @deprecated since 12.0.0, use data-oj-clickthrough="disabled" attribute instead
           */
          if (target.hasClass('oj-clickthrough-disabled')) {
            return;
          }
        }

        if (this.options.expanded) {
          this.collapse(true, event);
        } else {
          this.expand(true, event);
        }

        event.preventDefault();
        event.stopPropagation();

        // set focus on the disclosure icon
        this._getCollapsibleIcon().focus();
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _calcEffectTime: function (jelem) {
        var propertyStr = jelem.css('transitionProperty');
        var delayStr = jelem.css('transitionDelay');
        var durationStr = jelem.css('transitionDuration');
        var propertyArray = propertyStr.split(',');
        var delayArray = delayStr.split(',');
        var durationArray = durationStr.split(',');
        var propertyLen = propertyArray.length;
        var delayLen = delayArray.length;
        var durationLen = durationArray.length;
        var maxTime = 0;

        for (var i = 0; i < propertyLen; i++) {
          var duration = durationArray[i % durationLen];
          var durationMs =
            duration.indexOf('ms') > -1 ? parseFloat(duration) : parseFloat(duration) * 1000;
          if (durationMs > 0) {
            var delay = delayArray[i % delayLen];
            var delayMs = delay.indexOf('ms') > -1 ? parseFloat(delay) : parseFloat(delay) * 1000;

            maxTime = Math.max(maxTime, delayMs + durationMs);
          }
        }

        return maxTime + 100;
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _resolveTransition: function (wrapper) {
        var self = this;

        this._transitionTimer = setTimeout(function () {
          self._transitionEndHandler();
        }, self._calcEffectTime(wrapper));
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _expandCollapseHandler: function (event) {
        // only process expand/collapse for a disabled collapsible on initial render
        if (this._isDisabled() && !this._initialRender) {
          return;
        }

        if (event.target !== this.element[0]) {
          return;
        }

        if (this._initialRender || !event.isDefaultPrevented || !event.isDefaultPrevented()) {
          var element = this.element;
          var content = this.content;
          var wrapper = this.wrapper;
          var isExpanded = event.type === 'ojexpand';

          var self = this;
          event.preventDefault();

          // fire option change event
          if (!this._initialRender) {
            this._changeExpandedOption(isExpanded);
          }

          //  - ojcollapsible should update disclosure icon before animation not after
          this._getCollapsibleIcon()
            .toggleClass(OPEN_ICON, isExpanded)
            // logic or cause same icon for expanded/collapsed state would remove the oj-icon-class
            .toggleClass(CLOSE_ICON, !isExpanded || OPEN_ICON === CLOSE_ICON)
            .end();

          //  - expansion animation on initial render.
          if (
            this._initialRender ||
            document.hidden ||
            this.element.hasClass('oj-collapsible-skip-animation')
          ) {
            if (!isExpanded) {
              wrapper.css('max-height', 0);
              wrapper.hide();
            }
            self._afterExpandCollapse(isExpanded, event);
          } else {
            // do animation
            wrapper.contentHeight = wrapper.outerHeight();

            // Add a busy state for the animation.  The busy state resolver will be invoked
            // when the animation is completed
            if (!this._animationResolve) {
              var busyContext = Context.getContext(element[0]).getBusyContext();
              this._animationResolve = busyContext.addBusyState({
                description: "The collapsible id='" + this.element.attr('id') + "' is animating."
              });
            }
            this._transitionEnded = false;

            // expanding
            if (isExpanded) {
              // James: set display:none on the wrapper when it is hidden and then
              // remove display:none when its is shown.
              // This should trigger JAWS into refreshing the buffer.
              wrapper.show();

              setTimeout(function () {
                // if closed, add inner height to content height
                wrapper.contentHeight += content.outerHeight();

                wrapper.addClass(OJC_TRANSITION).css({
                  'max-height': wrapper.contentHeight
                });
                self._resolveTransition(wrapper);
              }, 0);
            } else {
              // collapsing
              // disable transitions & set max-height to content height
              wrapper.removeClass(OJC_TRANSITION);
              wrapper.css({
                'max-height': wrapper.contentHeight,
                'overflow-y': 'hidden'
              });

              // no transition when end state is the same
              if (wrapper.contentHeight === 0) {
                self._transitionEndHandler();
              } else {
                setTimeout(function () {
                  // enable & start transition
                  wrapper.addClass(OJC_TRANSITION).css({
                    'max-height': 0 //! important
                  });
                  self._resolveTransition(wrapper);
                }, 20);
              }
            }
          }
        }
      },

      _focusHandler: function (event) {
        if (this._isDisabled()) {
          return;
        }

        if (event.type === 'ojfocusout') {
          this._findFirstFocusableInHeader().attr('tabIndex', -1);

          event.preventDefault();
          event.stopPropagation();
        } else if (event.type === 'ojfocus') {
          this._findFirstFocusableInHeader().attr('tabIndex', 0).focus();
          event.preventDefault();
          event.stopPropagation();
        }
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _findFirstFocusableInHeader: function () {
        return this._findFocusables(this.headerWrapper).first();
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _findFocusables: function (start) {
        // create <span> or <a> depending on if this.isDisabled
        if (this._isDisabled()) {
          return start.find('span');
        }
        return start.find('a,:input');
      },

      /**
       * Expand a collapsible.<p>
       * Note the beforeExpand event will only be fired when vetoable is true.<p>
       * Please use the <code class="prettyprint">expanded</code> option
       * for expanding a collapsible so that it triggers the beforeExpand event:
       * $( ".selector" ).ojCollapsible( "option", "expanded", true );
       *
       * @expose
       * @ignore
       * @ojtsignore
       * @memberof oj.ojCollapsible
       * @instance
       * @param {boolean} vetoable if event is vetoable
       */
      expand: function (vetoable, event) {
        if (this._isDisabled()) {
          return;
        }

        var eventData = {
          /** @expose */
          header: this.header,
          /** @expose */
          content: this.content
        };

        if (!vetoable || this._trigger('beforeExpand', event, eventData) !== false) {
          this._expandCollapseHandler(this._createEventObject(this.element[0], 'ojexpand'));
        }
      },

      /**
       * Collapse a collapsible.<p>
       * Note the beforeCollapse event will only be fired when vetoable is true.<p>
       * Please use the <code class="prettyprint">expanded</code> option
       * for collapsing a collapsible so that it triggers the beforeCollapse event:
       * $( ".selector" ).ojCollapsible( "option", "expanded", false );
       *
       * @expose
       * @ignore
       * @ojtsignore
       * @memberof oj.ojCollapsible
       * @instance
       * @param {boolean} vetoable if event is vetoable
       */
      collapse: function (vetoable, event) {
        if (this._isDisabled()) {
          return;
        }

        var eventData = {
          /** @expose */
          header: this.header,
          /** @expose */
          content: this.content
        };

        if (!vetoable || this._trigger('beforeCollapse', event, eventData) !== false) {
          this._expandCollapseHandler(this._createEventObject(this.element[0], 'ojcollapse'));
        }
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _transitionEndHandler: function (event) {
        // ignore event if not for this collapsible
        if (this._isDisabled() || (event && event.target !== this.element[0])) {
          return;
        }

        var isMaxHeight = false;
        if (event && event.originalEvent) {
          isMaxHeight = event.originalEvent.propertyName === 'max-height';
        }

        // if transition property is MaxHeight, clear timer if exists
        if (isMaxHeight && this._transitionTimer) {
          clearTimeout(this._transitionTimer);
          this._transitionTimer = undefined;
        }

        if (event) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }

        // transition end already handled
        if (this._transitionEnded) {
          return;
        }

        // always set flag either timer expired or transition end
        if (isMaxHeight || !event) {
          this._transitionEnded = true;
        }

        if (!this.wrapper) {
          return;
        }

        // just completed a collapse transition
        if (this.options.expanded) {
          this.wrapper.css({
            'max-height': 9999,
            'overflow-y': ''
          });
        } else {
          // James: set display:none on the wrapper when it is hidden and then remove display:none when its is shown.
          // This should trigger JAWS into refreshing the buffer.
          this.wrapper.hide();
        }

        this.wrapper.removeClass(OJC_TRANSITION);
        this._afterExpandCollapse(this.options.expanded, event);
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _resolveBusyContext: function () {
        // resolve/remove the component busy state
        if (this._animationResolve) {
          this._animationResolve();
          this._animationResolve = null;
        }
      },

      /**
       * @memberof oj.ojCollapsible
       * @private
       */
      _afterExpandCollapse: function (isExpanded, event) {
        var element = this.element;
        var wrapper = this.wrapper;

        if (isExpanded) {
          element.removeClass('oj-collapsed');
          element.addClass('oj-expanded');

          //  - ojcollapsible needs to call oj.components.subtreeshown()/subtreehidden()
          Components.subtreeShown(wrapper[0]);
        } else {
          element.removeClass('oj-expanded');
          element.addClass('oj-collapsed');

          //  - ojcollapsible needs to call oj.components.subtreeshown()/subtreehidden()
          Components.subtreeHidden(wrapper[0]);
        }

        // aria
        if (isExpanded) {
          this.content.removeAttr(OJ_ARIA_HIDDEN);
        } else {
          this.content.attr(OJ_ARIA_HIDDEN, 'true'); // @HTMLUpdateOK
        }

        this._findFirstFocusableInHeader().attr(OJ_ARIA_EXPANDED, isExpanded); // @HTMLUpdateOK

        this._resolveBusyContext();

        var eventData = {
          /** @expose */
          header: this.header,
          /** @expose */
          content: this.content
        };

        if (!this._initialRender) {
          if (isExpanded) {
            this._trigger('expand', event, eventData);
          } else {
            this._trigger('collapse', event, eventData);
          }
        }
      },

      /**
       * @param {boolean} value
       * @memberof oj.ojCollapsible
       * @private
       */
      _changeExpandedOption: function (value) {
        this.option('expanded', value, { _context: { writeback: true, internalSet: true } });
      },

      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element ? this.element[0] : null;
        }

        var subId = locator.subId;

        switch (subId) {
          case 'oj-collapsible-content':
            return this.content[0];

          case OJC_HEADER:
            return this.header[0];

          case OJC_DISCLOSURE:
          case 'oj-collapsible-header-icon':
            return this._getCollapsibleIcon()[0];
          default:
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      getSubIdByNode: function (node) {
        var headerIcon = this.getNodeBySubId({ subId: OJC_DISCLOSURE });
        var currentNode = node;
        while (currentNode) {
          if (currentNode === this.content[0]) {
            return { subId: 'oj-collapsible-content' };
          } else if (currentNode === this.header[0]) {
            return { subId: OJC_HEADER };
          } else if (currentNode === headerIcon) {
            return { subId: OJC_DISCLOSURE };
          }

          currentNode = currentNode.parentElement;
        }
        return null;
      },

      /**
       * @param {string} id
       * @memberof oj.ojCollapsible
       * @private
       */
      _removeIdAttr: function (_, element) {
        if (/^oj-collapsible/.test(element.id)) {
          this.removeAttribute('id');
        }
      }
    });
  })();

});


define('ojs/ojaccordion',['ojs/ojcore-base', 'jquery', 'ojs/ojlogger', 'ojs/ojcomponentcore', 'ojs/ojcollapsible'], function (oj, $, Logger, ojcomponentcore, ojcollapsible) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

var __oj_accordion_metadata = 
{
  "properties": {
    "expanded": {
      "type": "Array<string>|Array<number>|Array<Object>",
      "writeback": true
    },
    "multiple": {
      "type": "boolean",
      "value": false
    },
    "translations": {
      "type": "object",
      "value": {}
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojBeforeCollapse": {},
    "ojBeforeExpand": {},
    "ojCollapse": {},
    "ojExpand": {}
  },
  "extension": {}
};
  /* global __oj_accordion_metadata:false */
  (function () {
    __oj_accordion_metadata.extension._WIDGET_NAME = 'ojAccordion';
    __oj_accordion_metadata.extension._TRACK_CHILDREN = 'nearestCustomElement';
    oj.CustomElementBridge.register('oj-accordion', { metadata: __oj_accordion_metadata });
  })();

  /**
   * @preserve Copyright 2013 jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */

  /**
   * @ojcomponent oj.ojAccordion
   * @augments oj.baseComponent
   * @since 0.6.0
   *
   * @ojshortdesc An accordion displays a set of collapsible child elements.
   * @ojrole group
   * @class oj.ojAccordion
   * @ojpropertylayout [ {propertyGroup: "common", items: ["multiple"]},
   *                     {propertyGroup: "data", items: ["expanded"]} ]
   * @ojvbdefaultcolumns 3
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-accordion'
   * @ojuxspecs ['accordion']
   *
   * @classdesc
   * <h3 id="accordionOverview-section">
   *   JET Accordion
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accordionOverview-section"></a>
   * </h3>
   *
   * <p>Description: A JET Accordion contains one or more {@link oj.ojCollapsible} child elements.
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-accordion>
   *   &lt;oj-collapsible>
   *     &lt;h3 slot="header">
   *       &lt;img src="images/default.png"/>
   *       &lt;span>Header 1&lt;/span>
   *     &lt;/h3>
   *     &lt;p>Content 1.&lt;/p>
   *   &lt;/oj-collapsible>
   *   &lt;oj-collapsible expanded="true">
   *     &lt;h3 slot="header">Header 3&lt;/h3>
   *     &lt;p>Content 3&lt;/p>
   *   &lt;/oj-collapsible>
   * &lt;/oj-accordion>
   * </code></pre>
   *  <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   *  </h3>
   *
   * <p>If a collapsible header contains non-textual content, the application must set the aria-label on the header slot."
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>In the unusual case that the directionality (LTR or RTL) changes post-init, the accordion must be <code class="prettyprint">refresh()</code>ed.
   *
   */
  //---------------------------------------------------------------
  //                    Fragments
  //---------------------------------------------------------------

  /**
   * <p>The <code class="prettyprint">&lt;oj-accordion></code> element accepts one or more <code class="prettyprint">&lt;oj-collapsible></code> elements as children.
   *
   * @ojchild Default
   * @memberof oj.ojAccordion
   * @ojpreferredcontent ["CollapsibleElement"]
   *
   * @example <caption>Initialize the Accordion with two Collapsible children specified:</caption>
   * &lt;oj-accordion>
   *   &lt;oj-collapsible>
   *     &lt;h3 slot="header">Header 1&lt;/h3>
   *     &lt;p>Content 1&lt;/p>
   *   &lt;/oj-collapsible>
   *   &lt;oj-collapsible expanded="true">
   *     &lt;h3 slot="header">Header 2&lt;/h3>
   *     &lt;p>Content 2&lt;/p>
   *   &lt;/oj-collapsible>
   * &lt;/oj-accordion>
   */

  /**
   * <p>Sub-ID for the specified disclosure icon within an Accordion.</p>
   *
   * @property {number} index The zero-based index of the disclosure icon.
   *
   * @ojsubid oj-accordion-disclosure
   * @memberof oj.ojAccordion
   *
   * @example <caption>Get the second disclosure icon:</caption>
   * var node = myAccordion.getNodeBySubId({"subId": "oj-accordion-disclosure", 'index': 1});
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Toggle disclosure state.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojAccordion
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>Space or Enter</kbd></td>
   *       <td>Toggle disclosure state.</td>
   *     </tr>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Navigate to next collapsible header and if none then the next element on page.</td>
   *     </tr>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>Shift+Tab</kbd></td>
   *       <td>Navigate to previous collapsible header and if none then the previous element on page.</td>
   *     </tr>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>UpArrow or LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
   *       <td>Move focus to the previous collapsible header with wrap around.</td>
   *     </tr>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>DownArrow or RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
   *       <td>Move focus to the next collapsible header with wrap around.</td>
   *     </tr>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>Home</kbd></td>
   *       <td>Move focus to the first collapsible header.</td>
   *     </tr>
   *     <tr>
   *       <td>Collapsible header</td>
   *       <td><kbd>End</kbd></td>
   *       <td>Move focus to the last collapsible header.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojAccordion
   */

  //-----------------------------------------------------------------
  //                        Widget Code
  //-----------------------------------------------------------------

  (function () {
    const OJA_COLLAPSIBLE = 'oj-accordion-collapsible';
    const OJA_CREATED = 'oj-accordion-created';

    const OJ_COLLAPSIBLE = 'oj-collapsible';
    const OJ_COLLAPSIBLE_HEADER = 'oj-collapsible-header';

    const OJ_COLLAPSIBLE_CLASS = '.oj-collapsible';

    oj.__registerWidget('oj.ojAccordion', $.oj.baseComponent, {
      widgetEventPrefix: 'oj',
      options: {
        /**
         * Allow multiple collapsibles to be open at the same time.
         * Note: if multiple is true, the beforeCollapse/beforeExpand/collapse/expand events will not be fired by the accordion. They are however fired by the collapsibles.
         *
         * @expose
         * @memberof oj.ojAccordion
         * @instance
         * @ojshortdesc Specifies whether multiple collapsible items can be open at the same time.
         * @type {boolean}
         * @default false
         * @example <caption>Initialize the accordion with the <code class="prettyprint">multiple</code> attribute specified:</caption>
         * &lt;oj-accordion multiple='true'>&lt;/oj-accordion>
         *
         * @example <caption>Get or set the <code class="prettyprint">multiple</code> property after initialization:</caption>
         * // getter
         * var multipleValue = myAccordion.multiple;
         *
         * // setter
         * myAccordion.multiple=true;
         */
        multiple: false,

        /**
         * Array contains either string ids or numeric zero-based indices or objects containing string id and/or numeric index of the collapsibles that should be expanded.<p>
         * Setter value: array of either string ids or numeric indices or objects containing either string id or numeric index or both.  If the object contains both id and index, numeric index takes precedence.<p>
         * Getter value: array of objects containing numeric index and string id, if available. If an expanded collapsible has a page author provided id, that id is returned.<p>
         *
         * Note: The default value of null means that accordion doesn't modify the expanded state of its child collapsibles.
         * When the value is specified, it overrides the expanded state of its child collapsibles.<p>
         *
         * @expose
         * @memberof oj.ojAccordion
         * @instance
         * @ojshortdesc A list of expanded child collapsible items.
         * @type {Array.<string>|Array.<number>|Array.<Object>|null}
         * @ojsignature {target: "Accessor", value: {GetterType: "Array<{id?: string, index?: number}>|null", SetterType: "Array<string>|Array<number>|Array<{id?: string, index?: number}>|null"}, jsdocOverride: true}
         * @ojwriteback
         * @default null
         *
         * @example <caption>Initialize the accordion with the
         * <code class="prettyprint">expanded</code> attribute specified:</caption>
         * &lt;oj-accordion expanded="['collapsible2']">&lt;/oj-accordion>
         *
         * @example <caption>Get or set the <code class="prettyprint">expanded</code> property
         * after initialization:</caption>
         * // getter
         * var expanded = myAccordion.expanded;
         *
         * // setter
         * myAccordion.expanded=['collapsible1'];
         *
         * @ojtsexample <caption>set Or get
         * <code class="prettyprint">expanded</code> property:</caption>
         * let elem = document.getElementById('accordion') as ojAccordion;
         * //set expanded to an array of objects
         * elem.expanded = [{id: "c2"},{id: "c3"}];
         * //or
         * elem.set('expanded', [{id: "c2"},{id: "c3"}]);
         *
         * //set expanded to an array of string
         * //elem.expanded = ["c1", "c2"]. Please note this wont compile. Use the format below
         * elem.set('expanded', ["c1", "c2"]);
         *
         * //set expanded to an array of number
         * //elem.expanded = [2,3]. Please note this wont compile. Use the format below
         * elem.set('expanded', [2, 3]);
         *
         * //get expanded property value
         * let expanded = elem.expanded; //This is guaranteed to be of the type Array<{id?: string, index?: number}>|null
         *
         * //reset the value of expanded to its default,
         * elem.unset('expanded');
         *
         */
        expanded: null,

        // callbacks
        /**
         * Triggered immediately before any collapsible in the accordion is expanded.
         * Call <code class="prettyprint">event.preventDefault()</code> in the event listener to veto the event, which prevents the content from expanding.
         * If multiple is true, the beforeExpand event will not be fired by the accordion.
         *
         * @expose
         * @event
         * @memberof oj.ojAccordion
         * @instance
         * @ojshortdesc Triggered immediately before any collapsible in the accordion is expanded.
         * @ojcancelable
         * @property {Element} toCollapsible The collapsible being expanded.
         * @property {Element} fromCollapsible The collapsible being collapsed.
         */
        beforeExpand: null,

        /**
         * Triggered after the accordion has been expanded (after animation completes).
         * The expand can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         * If multiple is true, the expand event will not be fired by the accordion.
         *
         * @expose
         * @event
         * @memberof oj.ojAccordion
         * @instance
         * @ojshortdesc Triggered after any collapsible in the accordion is expanded.
         * @property {Element} toCollapsible The collapsible being expanded.
         * @property {Element} fromCollapsible The collapsible being collapsed.
         */
        expand: null,

        /**
         * Triggered immediately before any collapsible in the accordion is collapsed.
         * Call <code class="prettyprint">event.preventDefault()</code> in the event listener to veto the event, which prevents the content from collapsing.
         * If multiple is true, the beforeCollapse event will not be fired by the accordion.
         *
         * @expose
         * @event
         * @memberof oj.ojAccordion
         * @instance
         * @ojshortdesc Triggered immediately before any collapsible in the accordion is collapsed.
         * @ojcancelable
         * @property {Element} toCollapsible The collapsible being expanded.
         * @property {Element} fromCollapsible The collapsible being collapsed.
         */
        beforeCollapse: null,

        /**
         * Triggered after any collapsible in the accordion has been collapsed (after animation completes).
         * The collapse can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         * If multiple is true, the collapse event will not be fired by the accordion.
         *
         * @expose
         * @event
         * @memberof oj.ojAccordion
         * @instance
         * @ojshortdesc Triggered after any collapsible in the accordion has been collapsed.
         * @property {Element} toCollapsible The collapsible being expanded.
         * @property {Element} fromCollapsible The collapsible being collapsed.
         */
        collapse: null
      },

      /**
       * @memberof oj.ojAccordion
       * @instance
       * @protected
       * @override
       */
      _ComponentCreate: function () {
        this._super();
        //  - Stop using ui-helper-reset in the layout widgets.
        this.element
          .addClass('oj-accordion oj-component')
          // aria
          .attr('role', 'group');
        //  - accordion expanded opt. val doesn't overrides its collaspsible expanded opt.
        this.options.expanded = this._expandedIndexToId(this.options.expanded);
        this._refresh();
      },

      /**
       * @memberof oj.ojAccordion
       * @param {Object} menu The JET Menu to open as a context menu
       * @param {Event} event What triggered the menu launch
       * @param {string} eventType "mouse", "touch", "keyboard"
       * @private
       */
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        // Setting the launcher to the "twisty" icon of the first collapsible in the accordion, since those twisties seem to be
        // the only tabbable things in the accordion, and they seem to remain tabbable even if the collapsible is disabled.
        // Component owner should feel free to specify a different launcher if appropriate, e.g. could specify the "current"
        // twisty rather than the first if desired.  See the superclass JSDoc for _OpenContextMenu for tips on choosing a launcher.
        this._OpenContextMenu(event, eventType, {
          launcher: this.element.find('.oj-collapsible-header-icon').first()
        });
      },

      /**
       * @memberof oj.ojAccordion
       * @override
       * @private
       */
      _destroy: function () {
        // clean up main element
        this.element.removeClass('oj-accordion oj-component').removeAttr('role');

        this.element.children().removeClass(OJA_COLLAPSIBLE);

        // remove collapsibles created by accordion
        this.element
          .children('.oj-accordion-created')
          .removeClass(OJA_CREATED)
          .ojCollapsible('destroy');
      },

      /**
       * @memberof oj.ojAccordion
       * @override
       * @private
       */
      _setOption: function (key, value, flags) {
        if (key === 'multiple') {
          // Transition multiple to single.
          // Keep the first expanded one expanded and collapse the rest.
          if (!value && this.options.multiple) {
            //  - when "multiple" option value is changed to false, exception is displayed
            this.element
              .children('.oj-expanded')
              .first()
              .siblings(OJ_COLLAPSIBLE_CLASS)
              .ojCollapsible('collapse', false);
          }
        } else if (key === 'expanded') {
          this._setExpandedOption(value);
          return;
        }

        this._super(key, value, flags);
      },

      /**
       * Refreshes the visual state of the accordion.
       *
       * <p>This method does not accept any arguments.
       *
       * @expose
       * @ojshortdesc Refreshes the visual state of the accordion.
       * @memberof oj.ojAccordion
       * @instance
       * @return {void}
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myAccordion.refresh();
       */
      refresh: function () {
        this._super();
        this._refresh();
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _refresh: function () {
        this._makeCollapsible();

        // TODO: ignore disabled until disabled propagation is supported
        // need to propagate the option to the collapsible children
        // this.option("disabled", this.options.disabled);

        this._internalSetExpanded = true;
        this._setExpandedOption(this.options.expanded);
        this._internalSetExpanded = false;

        this._setupEvents();
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _makeCollapsible: function () {
        this.collapsibles = this.element.children().not('oj-menu');

        if (this._IsCustomElement()) {
          this.collapsibles
            .not(OJ_COLLAPSIBLE)
            .ojCollapsible({
              expandArea: 'header'
            })
            .addClass(OJA_CREATED)
            .attr('data-oj-internal', ''); // mark internal component, used in oj.Components.getComponentElementByNode
        } else {
          this.element.children(':oj-collapsible').each(function () {
            $(this).ojCollapsible('option', 'expandArea', 'header');
          });

          this.collapsibles
            .not(':oj-ojCollapsible')
            .ojCollapsible({
              expandArea: 'header'
            })
            .addClass(OJA_CREATED)
            .attr('data-oj-internal', ''); // mark internal component, used in oj.Components.getComponentElementByNode
        }

        this.collapsibles.addClass(OJA_COLLAPSIBLE);
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _setupEvents: function () {
        var events;
        if (this._IsCustomElement()) {
          events = {
            keydown: this._keydown,
            ojBeforeExpand: this._beforeExpandHandler,
            ojExpand: this._expandHandler,
            ojBeforeCollapse: this._beforeCollapseHandler,
            ojCollapse: this._collapseHandler
          };
        } else {
          events = {
            keydown: this._keydown,
            ojbeforeexpand: this._beforeExpandHandler,
            ojexpand: this._expandHandler,
            ojbeforecollapse: this._beforeCollapseHandler,
            ojcollapse: this._collapseHandler
          };
        }

        this._off(this.collapsibles);
        this._on(this.collapsibles, events);
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _keydown: function (event) {
        // ignore event if target is not a header
        if (
          !event.altKey &&
          !event.ctrlKey &&
          ($(event.target).hasClass('oj-collapsible-header-wrapper') ||
            $(event.target).hasClass('oj-collapsible-header-icon'))
        ) {
          var keyCode = $.ui.keyCode;
          var enabledCollapsibles = this.collapsibles.not('.oj-disabled');
          var length = enabledCollapsibles.length;
          var target = $(event.target).closest(OJ_COLLAPSIBLE_CLASS);
          var currentIndex = enabledCollapsibles.index(target);
          var toFocus = false;

          if (currentIndex >= 0) {
            switch (event.keyCode) {
              case keyCode.RIGHT:
              case keyCode.DOWN:
                toFocus = enabledCollapsibles[(currentIndex + 1) % length];
                break;
              case keyCode.LEFT:
              case keyCode.UP:
                toFocus = enabledCollapsibles[(currentIndex - 1 + length) % length];
                break;
              case keyCode.HOME:
                toFocus = enabledCollapsibles[0];
                break;
              case keyCode.END:
                toFocus = enabledCollapsibles[length - 1];
                break;
              default:
            }
          }

          if (toFocus) {
            if (target) {
              $(target).trigger('ojfocusout');
            }
            $(toFocus).trigger('ojfocus');

            event.preventDefault();
          }
        }
      },

      /**
       * For single expansion
       *   returns a list of expanded collapsible widgets that are sibling
       *   of the current event target
       * For multiple expansion
       *   returns an empty set.
       * @memberof oj.ojAccordion
       * @private
       */
      _findTargetSiblings: function (event) {
        if (!this.options.multiple) {
          var closestCollapsible = $(event.target).closest(OJ_COLLAPSIBLE_CLASS);
          if (closestCollapsible.parent().is(':oj-ojAccordion')) {
            return closestCollapsible.siblings('.oj-collapsible.oj-expanded').map(function () {
              return $(this).data('oj-ojCollapsible');
            });
          }
        }
        return $();
      },

      /**
       * Trigger "beforeCollapse" on all expanded siblings in
       * the before expand handler
       * @memberof oj.ojAccordion
       * @private
       */
      _beforeExpandHandler: function (event, eventData) {
        if (!this._isTargetMyCollapsible(event)) {
          return true;
        }

        this._expandTarget = $(event.target);
        var result;
        var collapsible = null;

        this._findTargetSiblings(event).each(function () {
          collapsible = this.element;

          var beforeCollapsedData = {
            /** @expose */
            header: collapsible.find('.oj-collapsible-header'),

            /** @expose */
            content: collapsible.find('.oj-collapsible-content')
          };

          result = this._trigger('beforeCollapse', event, beforeCollapsedData);

          if (!result) {
            this._expandTarget = null;
          }

          return result;
        });

        if (!this.options.multiple) {
          var newData = this._initEventData(collapsible, this._expandTarget);
          result = this._trigger('beforeExpand', event, newData);
        }

        // make sure collapse all expanded collapsibles before expand others
        var self = this;
        if (result) {
          this._findTargetSiblings(event).each(function () {
            this.collapse(false, event, eventData);
            self._collapsedCollapsible = this.widget();
          });
        }

        return result;
      },

      /**
       * Collapse all expanded siblings and don't allow cancel
       * @memberof oj.ojAccordion
       * @private
       */
      _expandHandler: function (event, eventData) {
        // clear the collapsedCollapsible
        var fromCollapsible = null;
        if (this._collapsedCollapsible) {
          fromCollapsible = this._collapsedCollapsible;
          this._collapsedCollapsible = null;
        }

        //  - accordion expanded opt. val doesn't overrides its collaspsible expanded opt.
        // don't handle event during setExpandedOption
        if (!this._isTargetMyCollapsible(event) || this._duringSetExpandedOption) {
          return;
        }

        var newData;
        var self = this;

        this._findTargetSiblings(event).each(function () {
          this.collapse(false, event, eventData);
          newData = self._initEventData(this.element, $(event.target));
        });

        if (!newData) {
          newData = self._initEventData(fromCollapsible, $(event.target));
        }

        if (!this.options.multiple) {
          this._trigger('expand', event, newData);
        }

        this._updateExpanded();

        this._expandTarget = null;
      },

      /**
       * Trigger "beforecollapse" on all collapsed siblings in
       * the before collapse handler
       * @memberof oj.ojAccordion
       * @private
       */
      _beforeCollapseHandler: function (event, _eventData) {
        var eventData = _eventData;
        if (this._isTargetMyCollapsible(event) && !this.options.multiple) {
          if (!eventData && event.originalEvent instanceof CustomEvent) {
            eventData = event.originalEvent.detail;
          }

          return this._trigger(
            'beforeCollapse',
            event,
            this._initCollapseEventData(event, eventData)
          );
        }
        return true;
      },

      /**
       * Collapse all collapsed siblings and don't allow cancel
       * @memberof oj.ojAccordion
       * @private
       */
      _collapseHandler: function (event, _eventData) {
        //  - accordion expanded opt. val doesn't overrides its collaspsible expanded opt.
        // don't handle event during setExpandedOption
        var eventData = _eventData;
        if (!this._duringSetExpandedOption && this._isTargetMyCollapsible(event)) {
          if (!eventData && event.originalEvent instanceof CustomEvent) {
            eventData = event.originalEvent.detail;
          }

          var newData = this._initCollapseEventData(event, eventData);

          if (!this.options.multiple) {
            this._trigger('collapse', event, newData);
          }

          this._updateExpanded();
        }
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _initEventData: function (fromC, toC) {
        return {
          /**
           * @expose
           * @ignore
           */
          fromCollapsible: fromC, // the collapsible being collapsed.
          /**
           * @expose
           * @ignore
           */
          toCollapsible: toC // the collapsible being expanded.
        };
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _initCollapseEventData: function (event, eventData) {
        var newData;
        if (eventData.toCollapsible) {
          newData = eventData;
        } else if (event.originalEvent && event.originalEvent.target) {
          newData = this._initEventData($(event.target), this._expandTarget);
        }

        if (!newData && this._expandTarget) {
          newData = this._initEventData($(event.target), this._expandTarget);
        }

        return newData;
      },

      /**
       * To filter out events from the nested accordion
       * @memberof oj.ojAccordion
       * @private
       */
      _isTargetMyCollapsible: function (event) {
        return $(event.target).is(this.collapsibles);
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _updateExpanded: function () {
        var cid;
        var result = [];
        var newexp;

        this.collapsibles.each(function (index) {
          var bExpanded = false;
          if (this.tagName.toLowerCase() === OJ_COLLAPSIBLE) {
            bExpanded = this.expanded;
          } else {
            bExpanded = $(this).ojCollapsible('option', 'expanded');
          }
          if (bExpanded) {
            newexp = {};
            cid = $(this).attr('id');
            // add id property if provided
            if (cid) {
              newexp.id = cid;
            }
            // always add index property
            newexp.index = index;

            result.push(newexp);
          }
        });

        // this.options.expanded == null means retrieve the status from collapsibles
        if (
          !this.options.expanded ||
          !oj.Object._compareArrayIdIndexObject(result, this.options.expanded)
        ) {
          this.option('expanded', result, { _context: { internalSet: true, writeback: true } });
        }
      },

      /**
       * Return a new sorted expanded array contains IDs if they are available
       * @memberof oj.ojAccordion
       * @private
       */
      _expandedIndexToId: function (expanded) {
        //  - accordion expanded opt. val doesn't overrides its collaspsible expanded opt.
        if (Array.isArray(expanded)) {
          var id;
          var newExp = [];
          var expArr = [];

          // convert expanded from Array{Object} to Array{string or number}
          for (var i = 0; i < expanded.length; i++) {
            var exp = expanded[i];
            if (typeof exp === 'number' || typeof exp === 'string') {
              expArr.push(exp);
            } else if (typeof exp.index === 'number') {
              expArr.push(exp.index);
            } else if (typeof exp.id === 'string') {
              expArr.push(exp.id);
            }
          }

          this.element.children().each(function (index) {
            id = $(this).attr('id');
            if (id) {
              if (expArr.indexOf(id) !== -1 || expArr.indexOf(index) !== -1) {
                newExp.push({ id: id, index: index });
              }
            } else if (expArr.indexOf(index) !== -1) {
              // use index if ID not available
              newExp.push({ index: index });
            }
          });

          // if more than one expanded, keep the last collapsible
          if (!this.options.multiple && newExp.length > 1) {
            newExp = [newExp[newExp.length - 1]];
          }

          return newExp;
        }

        return null;
      },

      /**
       * @memberof oj.ojAccordion
       * @private
       */
      _setExpandedOption: function (_expanded) {
        // sort expanded array if it's from external setOption
        var expanded = _expanded;
        if (!this._internalSetExpanded) {
          expanded = this._expandedIndexToId(expanded); // eslint-disable-line no-param-reassign
        }

        // parent override children expanded setting
        if (expanded) {
          // loop thru collapsibles to collapse/expand based on expandedList
          var self = this;
          var child;
          var childId;
          var parentExp;
          var exp;
          var iexp = 0;

          this.collapsibles.each(function (index) {
            child = $(this);
            childId = child.attr('id');

            parentExp = false;
            exp = expanded[iexp];
            if (exp) {
              if (childId) {
                if (childId === exp.id) {
                  parentExp = true;
                }
              } else if (index === exp.index) {
                parentExp = true;
              }
              if (parentExp) {
                iexp += 1;
              }
            }

            //  - accordion expanded opt. val doesn't overrides its collaspsible expanded opt.
            // when the parent override the child setting:
            // 1) log a warning
            // 2) set child's expanded option with the writeback flag.
            var isCustomElement = this.tagName.toLowerCase() === OJ_COLLAPSIBLE;
            var childExp = isCustomElement
              ? this.expanded
              : child.ojCollapsible('option', 'expanded');

            if (childExp !== parentExp) {
              Logger.warn('JET Accordion: override collapsible ' + index + ' expanded setting');

              // don't fire accordion "exanded" optionChange event here
              self._duringSetExpandedOption = true;
              if (isCustomElement) {
                this.expanded = parentExp;
              } else {
                child.ojCollapsible('option', 'expanded', parentExp);
              }
              self._duringSetExpandedOption = false;
            }
          });
        }

        this._updateExpanded();
      },

      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element ? this.element[0] : null;
        }

        var subId = locator.subId;
        var index = locator.index;

        if (typeof index !== 'number' || index < 0 || index >= this.collapsibles.length) {
          return null;
        }

        var collapsible = this.collapsibles[index];

        switch (subId) {
          case 'oj-accordion-content':
            subId = 'oj-collapsible-content';
            break;

          case 'oj-accordion-header':
            subId = OJ_COLLAPSIBLE_HEADER;
            break;

          case 'oj-accordion-disclosure':
          case 'oj-accordion-header-icon':
            subId = 'oj-collapsible-disclosure';
            break;

          case OJA_COLLAPSIBLE:
            return collapsible;

          default:
            // Non-null locators have to be handled by the component subclasses
            return null;
        }
        return $(collapsible).ojCollapsible('getNodeBySubId', { subId: subId });
      },

      getSubIdByNode: function (node) {
        // First, find which collapsible the node is a descendant of
        var collapsibleIndex = -1;
        var currentNode = node;
        while (currentNode) {
          collapsibleIndex = Array.prototype.indexOf.call(this.collapsibles, currentNode);
          if (collapsibleIndex !== -1) {
            break;
          }
          currentNode = currentNode.parentElement;
        }
        var subId = null;
        // Then, find the subId from the collapsible
        if (collapsibleIndex !== -1) {
          var collapsibleSubId = $(this.collapsibles[collapsibleIndex]).ojCollapsible(
            'getSubIdByNode',
            node
          );
          collapsibleSubId = collapsibleSubId || {};
          switch (collapsibleSubId.subId) {
            case 'oj-collapsible-content':
              subId = 'oj-accordion-content';
              break;
            case OJ_COLLAPSIBLE_HEADER:
              subId = 'oj-accordion-header';
              break;
            case 'oj-collapsible-disclosure':
            case 'oj-collapsible-header-icon':
              subId = 'oj-accordion-disclosure';
              break;
            default:
              subId = OJA_COLLAPSIBLE;
          }
        }
        if (subId) {
          return { subId: subId, index: collapsibleIndex };
        }
        return null;
      },

      _CompareOptionValues: function (option, value1, value2) {
        if (option === 'expanded') {
          return oj.Object.compareValues(value1, value2);
        }
        return this._super(option, value1, value2);
      }
    });
  })();

});


define('ojs/ojprogress',['ojs/ojcore-base', 'ojs/ojcomponentcore', 'ojs/ojcore', 'jquery'], function (oj, ojcomponentcore, oj$1, $) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  oj$1 = oj$1 && Object.prototype.hasOwnProperty.call(oj$1, 'default') ? oj$1['default'] : oj$1;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;

  (function () {
var __oj_progress_metadata = 
{
  "properties": {
    "max": {
      "type": "number",
      "value": 100
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaIndeterminateProgressText": {
          "type": "string"
        }
      }
    },
    "type": {
      "type": "string",
      "enumValues": [
        "bar",
        "circle"
      ],
      "value": "bar"
    },
    "value": {
      "type": "number",
      "writeback": true,
      "value": 0
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
    __oj_progress_metadata.extension._WIDGET_NAME = 'ojProgressbar';
    oj.CustomElementBridge.register('oj-progress', { metadata: __oj_progress_metadata });
  })();

  /**
   * @ojcomponent oj.ojProgress
   * @ojdeprecated {since: '15.0.0', description: 'oj-progress has been deprecated, please use oj-progress-bar or oj-progress-circle instead.'}
   * @since 1.0.0
   * @augments oj.baseComponent
   * @ojshortdesc A progress allows the user to visualize the progression of an extended computer operation.
   * @ojpropertylayout {propertyGroup: "common", items: ["type", "max"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["value"]}
   * @ojvbdefaultcolumns 4
   * @ojvbmincolumns 1
   * @ojunsupportedthemes ["Redwood"]
   *
   * @classdesc
   * <h3 id="progressOverview-section">
   *   JET Progress
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#progressOverview-section"></a>
   * </h3>
   * The JET Progress element allows a user to display progress of an operation in a rectangular horizontal or circular meter.
   * If a developer does not wish to display the exact value, a value of '-1' can be passed in to display an indeterminate value.
   *
   * <pre class="prettyprint"><code>&lt;oj-progress value='{{progressValue}}'>&lt;/oj-progress></code></pre>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>If this element is being used to describe the loading process of a particular region of a page, then the <code class="prettyprint">aria-describedby</code>
   *    attribute must point to the id of the oj-progress and <code class="prettyprint">aria-busy = "true"</code> must be added to the region until the loading is complete.</p>
   *
   * <h3 id="migration-section">
   *   Migration
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#migration-section"></a>
   *  </h3>
   *  To migrate from oj-progress-bar to oj-c-progress-bar, you need to revise the import statement and references to oj-c-progress-bar in your app.  Please note the changes between the two components below.
   *  <h5>oj-progress-bar-embedded class</h5>
   *  <p>To render a progress bar that is attached to a container, set the edge attribute to 'top' instead of using the 'oj-progress-bar-embedded' class.</p>
   *
   *
   */

  //-----------------------------------------------------
  //                   Fragments
  //-----------------------------------------------------

  /**
   * <p>This element has no touch interaction.  </p>
   *
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojProgress
   */

  /**
   * <p>This element has no keyboard interaction.  </p>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojProgress
   */

  //-----------------------------------------------------
  //                   Styles
  //-----------------------------------------------------

  // ---------------- oj-progress-bar-embedded --------------
  /**
   * Optional class that can be set on a oj-progress bar element to style an embedded progress bar within a web application or dialog.
   * @ojstyleclass oj-progress-bar-embedded
   * @ojdisplayname Embedded
   * @memberof oj.ojProgress
   * @ojtsexample
   * &lt;div class='oj-web-applayout-page'>
   *   &lt;header class='oj-web-applayout-header'>
   *   &lt;</header>
   *   &lt;oj-progress class='oj-progress-bar-embedded' value='{{loadingValue}}'>
   *   &lt;/oj-progress>
   * &lt;/div>
   */
  // ---------------- oj-progress-bar-start-label --------------
  /**
   * Optional class that can be set on a div after the oj-progress element. This div contains the start text to display underneath the oj-progress bar.
   * @ojstyleclass oj-progress-bar-start-label
   * @ojdisplayname Start Label
   * @memberof oj.ojProgress
   * @ojtsexample
   * &lt;div class='oj-web-applayout-page'>
   *   &lt;header class='oj-web-applayout-header'>
   *   &lt;</header>
   *   &lt;oj-progress class='oj-progress-bar-embedded' value='{{loadingValue}}'>
   *     &lt;div class='oj-progress-bar-start-label'>0%
   *     &lt;/div>
   *     &lt;div class='oj-progress-bar-end-label'>100%
   *     &lt;/div>
   *   &lt;/oj-progress>
   * &lt;/div>
   */
  // ---------------- oj-progress-bar-end-label --------------
  /**
   * Optional class that can be set on a div after the oj-progress element. This div contains the end text to display underneath the oj-progress bar.
   * @ojstyleclass oj-progress-bar-end-label
   * @ojdisplayname End Label
   * @memberof oj.ojProgress
   * @ojtsexample
   * &lt;div class='oj-web-applayout-page'>
   *   &lt;header class='oj-web-applayout-header'>
   *   &lt;</header>
   *   &lt;oj-progress class='oj-progress-bar-embedded' value='{{loadingValue}}'>
   *     &lt;div class='oj-progress-bar-start-label'>0%
   *     &lt;/div>
   *     &lt;div class='oj-progress-bar-end-label'>100%
   *     &lt;/div>
   *   &lt;/oj-progress>
   * &lt;/div>
   */

  //-----------------------------------------------------
  //                   Slots
  //-----------------------------------------------------

  /**
   * @ojslot contextMenu
   * @memberof oj.ojProgress
   * @ojdeprecated {since: '10.0.0', description: '&lt;oj-progress> no longer supports context menu.'}
   */

  (function () {
    /*
     * <h3 id="markup-section">
     *   HTML Markup and Style Classes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#markup-section"></a>
     * </h3>
     *
     * <p>To create the start label for the progress bar wrap the start label text in a div with the  <code class="prettyprint"> oj-progress-bar-start-label </code> class. </p>
     *
     * <p>To create the end label for the progress bar wrap the end label text in a div with the  <code class="prettyprint"> oj-progress-bar-end-label </code> class. </p>
     *
     */
    oj$1.__registerWidget('oj.ojProgressbar', $.oj.baseComponent, {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',
      options: {
        /**
         * The maximum allowed value. The element's max attribute is used if it
         * is provided, otherwise the default value of 100 is used.
         * @ojshortdesc The maximum allowed value.
         * @expose
         * @public
         * @type {number}
         * @instance
         * @memberof oj.ojProgress
         * @default 100
         * @ojmin 0
         * @example <caption>Initialize the Progress with the <code class="prettyprint">max</code> attribute specified</caption>
         * &lt;oj-progress max='220'>&lt;/oj-progress>
         * @example <caption>Get or set the <code class="prettyprint">max</code> property after initialization</caption>
         * //Get progress max
         * var max = myProgress.max;
         *
         * //Set progress max
         * myProgress.max = 200;
         */
        max: 100,
        /**
         * The value of the Progress. The element's value attribute is used if it
         * is provided, otherwise the default value of 0 is used. For indeterminate Progress, set value to -1.
         * @ojshortdesc The value of the Progress.
         * @expose
         * @public
         * @type {number}
         * @instance
         * @memberof oj.ojProgress
         * @default 0
         * @ojmin -1
         * @ojwriteback
         * @ojeventgroup common
         * @example <caption>Initialize the Progress with the <code class="prettyprint">value</code> attribute specified</caption>
         * &lt;oj-progress value='{{progressVal}}'>&lt;/oj-progress>
         * @example <caption>Get or set the <code class="prettyprint">value</code> property after initialization</caption>
         * //Get progress value
         * var value = myProgress.value;
         *
         * //Set progress value
         * myProgress.value = 10;
         */
        value: 0,
        /**
         * The shape of the Progress.
         * @ojshortdesc The shape of the Progress.
         * @expose
         * @instance
         * @type {string}
         * @memberof oj.ojProgress
         * @since 3.0
         * @ojvalue {string} "bar" displays progress in a rectangular horizontal meter
         * @ojvalue {string} "circle" displays progress in a circular meter
         * @default "bar"
         * @example <caption>Initialize the Progress with the <code class="prettyprint">type</code> attribute specified</caption>
         * &lt;oj-progress type='circle'>&lt;/oj-progress>
         * @example <caption>Get or set the <code class="prettyprint">type</code> property after initialization</caption>
         * //Get progress type
         * var type = myProgress.type;
         *
         * //Set progress type
         * myProgress.type= 'bar';
         */
        type: 'bar',
        /**
         * If disabled is set to true, then the Progress will not change if a new value is passed in.
         * By default this parameter is set to false.
         * @ojshortdesc If disabled is set to true, then the Progress will not change if a new value is passed in.
         * @expose
         * @public
         * @type {boolean}
         * @ignore
         * @instance
         * @memberof oj.ojProgress
         * @default false
         * @example <caption>Initialize the Progress with the <code class="prettyprint">disabled</code> attribute specified</caption>
         * &lt;oj-progress disabled='true'>&lt;/oj-progress>
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> property after initialization</caption>
         * //Get progress disabled
         * var disabled = myProgress.disabled;
         *
         * //Set progress disabled
         * myProgress.disabled= true;
         */
        disabled: false
      },
      // The min value is a constant and 0 is the value set for it.
      min: 0,

      /**
       * Variable used to indicate that the value is indeterminate
       *
       * @override
       * @memberof oj.ojProgress
       * @private
       */
      _indeterminate: false,
      /**
       * Create the Progress
       * @override
       * @memberof oj.ojProgress
       * @return {void}
       * @protected
       */
      _ComponentCreate: function () {
        this._super();

        // Constrain initial value
        this.options.value = this._constrainedValue();
        this.oldValue = this.options.value;

        this.element.attr({
          // Only set static values, aria-valuenow and aria-valuemax are
          // set inside _refreshValue()
          role: 'progressbar',
          'aria-valuemin': this.min
        });
        this.element.addClass('oj-component');
        this._setUpProgressType();
      },
      /**
       * Sets up train based on type
       * @memberof oj.ojProgress
       * @return {void}
       * @private
       */
      _setUpProgressType: function () {
        if (this.options.type === 'circle') {
          this.element.addClass('oj-progress-circle');
          this._setupCircleSVG();
        } else {
          this.element.addClass('oj-progress-bar');
          this.valueDiv = $("<div class='oj-progress-bar-value'></div>").appendTo(this.element); // @HTMLUpdateOK
        }

        this._refreshValue();
      },

      /**
       * <p>Initialize the options</p>
       * @protected
       * @param {Object} originalDefaults
       * @param {Object} constructorOptions
       * @override
       * @memberof oj.ojProgress
       * @return {void}
       */
      _InitOptions: function (originalDefaults, constructorOptions) {
        var element = this.element;

        this._super(originalDefaults, constructorOptions);

        if (constructorOptions.max === undefined) {
          // get from dom. if still undefined, get from originalDefaults.
          var dom = element.attr('max') || undefined;
          if (dom != null) {
            this.options.max = dom;
          }
        }
      },

      /**
       * Check that value is valid and within the correct bounds. A value of -1 indicates an indeterminate value.
       * @param {number} newValue The new value of the progress being passed in.
       * @override
       * @private
       * @memberof oj.ojProgress
       * @return {number}
       */
      _constrainedValue: function (newValue) {
        if (newValue === undefined) {
          // eslint-disable-next-line no-param-reassign
          newValue = this.options.value;
        }

        // Indicates that the value is indeterminate.
        this._indeterminate = newValue === -1;

        // sanitize value
        if (typeof newValue !== 'number') {
          // eslint-disable-next-line no-param-reassign
          newValue = isNaN(newValue) ? 0 : Number(newValue);
        }

        return this._indeterminate ? -1 : Math.min(this.options.max, Math.max(this.min, newValue));
      },
      /**
       * Set the value
       * @param {Object} options The options being set
       * @override
       * @private
       * @memberof oj.ojProgress
       * @return {void}
       */
      _setOptions: function (options, flags) {
        // Ensure "value" option is set after other values (like max)
        var value = options.value;
        // eslint-disable-next-line no-param-reassign
        delete options.value;

        this._super(options, flags);
        if (!this.options.disabled) {
          this.options.value = this._constrainedValue(value);
          this._refreshValue();
        }
      },

      /**
       * Setup the svg for the determinate progress circle. The determinate progress circle is composed of
       * two circles, one for the value and one for the track. The strokes of the circles are used for the visual rendering.
       * @private
       * @memberof oj.ojProgress
       * @return {void}
       */
      _setupCircleSVG: function () {
        // Clear existing SVG
        if (this.svg) {
          this.svg.remove();
        }

        if (!this._indeterminate) {
          var namespace = 'http://www.w3.org/2000/svg';
          var svg = document.createElementNS(namespace, 'svg');
          var bgCircle = document.createElementNS(namespace, 'circle');
          var circle = document.createElementNS(namespace, 'circle');
          var radius = Math.min(this.element.outerWidth(), this.element.outerHeight()) * 0.5;

          svg.setAttribute('width', radius * 2);
          svg.setAttribute('height', radius * 2);
          svg.setAttribute('class', 'oj-progress-circle-transform');

          // Track Circle
          bgCircle.setAttribute('r', radius * 0.9);
          bgCircle.setAttribute('cx', radius);
          bgCircle.setAttribute('cy', radius);
          bgCircle.setAttribute('class', 'oj-progress-circle-base');

          // Value Circle
          circle.setAttribute('r', radius * 0.9);
          circle.setAttribute('cx', radius);
          circle.setAttribute('cy', radius);
          circle.setAttribute('class', 'oj-progress-circle-base oj-progress-circle-value');
          var circumference = 2 * radius * 0.9 * Math.PI;
          var offset = circumference - (this._percentage() / 100) * circumference;
          circle.style.strokeDasharray = circumference.toString();
          circle.style.strokeDashoffset = offset;

          svg.appendChild(bgCircle);
          svg.appendChild(circle);

          this.svg = $(svg);

          this.element[0].appendChild(svg);
        }
      },

      /**
       * Check that the max value is not less than the min
       * @param {string} key The key for the option being set
       * @param {string|number} value The value being set
       * @override
       * @private
       * @memberof oj.ojProgress
       * @return {void}
       */
      _setOption: function (key, value, flags) {
        if (key === 'max') {
          // Don't allow a max less than min
          // eslint-disable-next-line no-param-reassign
          value = Math.max(this.min, value);
        }
        // If changing the type of progress, want to remove the old progress
        // and rerender a new one
        if (key === 'type') {
          if (this.options.type === 'circle') {
            this.element.removeClass('oj-progress-circle');
            if (this.svg) {
              this.svg.remove();
            }
          } else {
            this.element.removeClass('oj-progress-bar');
            this.valueDiv.remove();
          }

          if (this.overlayDiv) {
            this.overlayDiv.remove();
            this.overlayDiv = null;
          }
        }
        this._super(key, value, flags);
        // If changing the type of progress, want to remove the old progress
        // and rerender a new one
        if (key === 'type') {
          this._setUpProgressType();
        }
      },

      /**
       * Calculates the percentage of the progress that has been loaded based on min, max, and value.
       *
       * @override
       * @private
       * @memberof oj.ojProgress
       * @return {number}
       */
      _percentage: function () {
        return Math.min(
          this._indeterminate
            ? 100
            : (100 * (this.options.value - this.min)) / (this.options.max - this.min),
          100
        );
      },

      /**
       * This function is used to update the value when the value has changed.
       *
       * @override
       * @private
       * @memberof oj.ojProgress
       * @return {void}
       */
      _refreshValue: function () {
        var value = this.options.value;
        var percentage = this._percentage();
        var isCircle = this.options.type === 'circle';
        if (isCircle) {
          this._setupCircleSVG();
        } else {
          this.valueDiv
            .toggle(this._indeterminate || value > this.min)
            .width(percentage.toFixed(0) + '%');

          this.element.toggleClass('oj-progress-bar-indeterminate', this._indeterminate);
        }

        if (this._indeterminate) {
          this.element.attr({
            'aria-valuetext': this.getTranslatedString('ariaIndeterminateProgressText')
          });
          this.element.removeAttr('aria-valuenow');
          this.element.removeAttr('aria-valuemin');
          this.element.removeAttr('aria-valuemax');
          if (!this.overlayDiv) {
            if (isCircle) {
              // prettier-ignore
              this.overlayDiv = $("<div class='oj-progress-circle-overlay'></div>").appendTo( // @HTMLUpdateOK
                this.element
              );
              var diameter = Math.min(this.element.outerWidth(), this.element.outerHeight());
              this.overlayDiv.css('width', diameter);
              this.overlayDiv.css('height', diameter);
            } else {
              // prettier-ignore
              this.overlayDiv = $("<div class='oj-progress-bar-overlay'></div>").appendTo( // @HTMLUpdateOK
                this.valueDiv
              );
            }
            this.overlayDiv.addClass('oj-indeterminate');
          }
        } else {
          this.element.attr({ 'aria-valuemax': this.options.max, 'aria-valuenow': value });
          if (this.overlayDiv) {
            this.overlayDiv.remove();
            this.overlayDiv = null;
          }
        }
      },

      /**
       * Overide the destory function to remove appropriate class and attributes.
       *
       * @override
       * @private
       * @memberof oj.ojProgress
       * @return {void}
       */
      _destroy: function () {
        if (this.options.type === 'circle') {
          this.element.removeClass('oj-progress-circle oj-component');
          if (this.svg) {
            this.svg.remove();
          }
        } else {
          this.element.removeClass('oj-progress-bar oj-component');

          this.valueDiv.remove();
          if (this._indeterminate) {
            this.element.removeClass('oj-progress-bar-indeterminate');
          }
        }
        this.element
          .removeAttr('role')
          .removeAttr('aria-valuemin')
          .removeAttr('aria-valuemax')
          .removeAttr('aria-valuenow');
        if (this.overlayDiv) {
          this.overlayDiv.remove();
        }
        this._super();
      }
    });
  })();

});


define('ojs/ojprogressbar',['ojs/ojprogress'], function (ojprogress) { 'use strict';



});


define('ojs/ojprogress-bar',['exports', 'preact/jsx-runtime', 'ojs/ojvcomponent', 'preact', 'ojs/ojtranslation'], function (exports, jsxRuntime, ojvcomponent, preact, Translations) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.ProgressBar = class ProgressBar extends preact.Component {
        render(props) {
            return props.value === -1
                ? this._renderIndeterminateBar(props)
                : this._renderDeterminateBar(props);
        }
        _renderDeterminateBar(props) {
            let max = props.max;
            let value = props.value;
            if (max < 0) {
                max = 0;
            }
            if (value < 0) {
                value = 0;
            }
            const percentage = max === 0 ? 0 : value > max ? 1 : value / max;
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: "oj-progress-bar", role: "progressbar", "aria-valuemin": 0, "aria-valuemax": max, "aria-valuenow": value, children: jsxRuntime.jsx("div", { class: "oj-progress-bar-track", children: jsxRuntime.jsx("div", { class: "oj-progress-bar-value", style: { width: percentage * 100 + '%' } }) }) }));
        }
        _renderIndeterminateBar(props) {
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: "oj-progress-bar", role: "progressbar", "aria-valuetext": Translations.getTranslatedString('oj-ojProgressbar.ariaIndeterminateProgressText'), children: jsxRuntime.jsx("div", { class: "oj-progress-bar-track", children: jsxRuntime.jsx("div", { class: "oj-progress-bar-value oj-progress-bar-indeterminate" }) }) }));
        }
    };
    exports.ProgressBar.defaultProps = {
        max: 100,
        value: 0
    };
    exports.ProgressBar._metadata = { "properties": { "max": { "type": "number" }, "value": { "type": "number" } } };
    exports.ProgressBar = __decorate([
        ojvcomponent.customElement('oj-progress-bar')
    ], exports.ProgressBar);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojprogress-circle',['exports', 'preact/jsx-runtime', 'ojs/ojvcomponent', 'preact', 'ojs/ojtranslation'], function (exports, jsxRuntime, ojvcomponent, preact, Translations) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.ProgressCircle = class ProgressCircle extends preact.Component {
        render(props) {
            return props.value === -1
                ? this._renderIndeterminateCircle(props)
                : this._renderDeterminateCircle(props);
        }
        _renderIndeterminateCircle(props) {
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: 'oj-progress-circle oj-progress-circle-' + props.size, role: "progressbar", "aria-valuetext": Translations.getTranslatedString('oj-ojProgressbar.ariaIndeterminateProgressText'), children: jsxRuntime.jsx("div", { class: "oj-progress-circle-indeterminate", children: jsxRuntime.jsx("div", { class: "oj-progress-circle-indeterminate-inner" }) }) }));
        }
        _renderDeterminateCircle(props) {
            let max = props.max;
            let value = props.value;
            if (max < 0) {
                max = 0;
            }
            if (value < 0 && value !== -1) {
                value = 0;
            }
            const percentage = max === 0 ? 0 : value > max ? 1 : value / max;
            const clipPath = this._getClipPath(percentage);
            return (jsxRuntime.jsxs(ojvcomponent.Root, { class: 'oj-progress-circle oj-progress-circle-' + props.size, role: "progressbar", "aria-valuemin": 0, "aria-valuemax": max, "aria-valuenow": value, children: [jsxRuntime.jsx("div", { class: "oj-progress-circle-tracker" }), jsxRuntime.jsx("div", { class: "oj-progress-circle-value", style: { clipPath } })] }));
        }
        _getClipPath(percentage) {
            let tangent;
            if (percentage < 0.125) {
                tangent = this._calculateTangent(percentage) + 50;
                return `polygon(50% 0, ${tangent}% 0, 50% 50%)`;
            }
            else if (percentage < 0.375) {
                if (percentage < 0.25) {
                    tangent = 50 - this._calculateTangent(0.25 - percentage);
                }
                else {
                    tangent = this._calculateTangent(percentage - 0.25) + 50;
                }
                return `polygon(50% 0, 100% 0, 100% ${tangent}%, 50% 50%)`;
            }
            else if (percentage < 0.625) {
                if (percentage < 0.5) {
                    tangent = 50 + this._calculateTangent(0.5 - percentage);
                }
                else {
                    tangent = 50 - this._calculateTangent(percentage - 0.5);
                }
                return `polygon(50% 0, 100% 0, 100% 100%, ${tangent}% 100%, 50% 50%)`;
            }
            else if (percentage < 0.875) {
                if (percentage < 0.75) {
                    tangent = 50 + this._calculateTangent(0.75 - percentage);
                }
                else {
                    tangent = 50 - this._calculateTangent(percentage - 0.75);
                }
                return `polygon(50% 0, 100% 0, 100% 100%, 0% 100%, 0% ${tangent}%, 50% 50%)`;
            }
            tangent = 50 - this._calculateTangent(1 - percentage);
            return `polygon(50% 0, 100% 0, 100% 100%, 0% 100%, 0% 0%, ${tangent}% 0%, 50% 50%)`;
        }
        _calculateTangent(percentage) {
            return 50 * Math.tan(percentage * 2 * Math.PI);
        }
    };
    exports.ProgressCircle.defaultProps = {
        max: 100,
        value: 0,
        size: 'md'
    };
    exports.ProgressCircle._metadata = { "properties": { "max": { "type": "number" }, "value": { "type": "number" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] } } };
    exports.ProgressCircle = __decorate([
        ojvcomponent.customElement('oj-progress-circle')
    ], exports.ProgressCircle);

    Object.defineProperty(exports, '__esModule', { value: true });

});




define('ojs/ojprogresslist',['ojs/ojcore', 'jquery', 'knockout', 'ojs/ojcomposite', 'ojs/ojknockouttemplateutils', 'ojs/ojcomponentcore', 'ojs/ojlistview', 'ojs/ojprogress'], 
function(oj, $, ko, Composite, KnockoutTemplateUtils)
{
  "use strict";

var __oj_progress_list_metadata = 
{
  "properties": {
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "deprecated",
              "since": "14.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    }
  },
  "methods": {
    "getProperty": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};


/* jslint browser: true,devel:true*/
/**
 * This interface defines the API for oj.ProgressItem.
 * It can be implemented in order to the track progress and status of an arbitrary task
 * (e.g. a file being uploaded)
 *
 * @export
 * @interface ProgressItem
 * @memberof oj
 * @since 4.0.0
 * @ojdeprecated {since: '8.0.0', description: '&lt;oj-progress-list> has been deprecated, please use &lt;oj-list-view> instead.'}
 *
 */
oj.ProgressItem = function () {};

/**
 * Attach an event handler
 *
 * @method
 * @name addEventListener
 * @memberof oj.ProgressItem
 * @instance
 * @param {oj.ProgressItem.EventType} eventType eventType
 * @param {EventListener} listener The event listener to add.
 * @returns {void}
 *
 * @export
 */

/**
 * Detach an event handler
 *
 * @method
 * @name removeEventListener
 * @memberof oj.ProgressItem
 * @instance
 * @param {oj.ProgressItem.EventType} eventType eventType
 * @param {EventListener} listener The event listener to remove.
 * @returns {void}
 *
 * @export
 */

/**
 * ProgressItem status
 *
 * @export
 * @enum {string}
 * @memberof oj.ProgressItem
 */
oj.ProgressItem.Status = {
  /**
   * initial state before any progress events
   */
  QUEUED: 'queued',
  /**
   * upload is in progress
   */
  LOADSTARTED: 'loadstarted',
  /**
   * upload aborted
   */
  ABORTED: 'aborted',
  /**
   * upload failed
   */
  ERRORED: 'errored',
  /**
   * upload timeout
   */
  TIMEDOUT: 'timedout',
  /**
   * upload is completed
   */
  LOADED: 'loaded'
};

/**
 * ProgressItem event types
 *
 * @export
 * @enum {string}
 * @memberof oj.ProgressItem
 */
oj.ProgressItem.EventType = {
  /**
   * Triggered when the progress start
   */
  LOADSTART: 'loadstart',
  /**
   * Triggered for upload progress events.
   */
  PROGRESS: 'progress',
  /**
   * Triggered when an upload has been aborted.
   */
  ABORT: 'abort',
  /**
   * Triggered when an upload failed.
   */
  ERROR: 'error',
  /**
   * Triggered when an upload succeeded.
   */
  LOAD: 'load',
  /**
   * Triggered when timeout has passed before upload completed
   */
  TIMEOUT: 'timeout',
  /**
   * Triggered when an upload completed (success or failure).
   */
  LOADEND: 'loadend'
};



/* global ko */

/**
 * @ignore
 * @ojtsignore
 * @ojcomponent oj.ojProgressItem
 * @since 4.0.0
 * @classdesc Display a progress and status icon when ended. The property data is a <code class="prettyprint">ProgressItem</code>.
 */

/**
 * @member
 * @name data
 * @memberof oj.ojProgressItem
 * @instance
 * @type {null|oj.ProgressItem}
 * @default null
 * @ojshortdesc Data used by the oj.ojProgressList
 */

/**
 * @ignore
 * @ojtsignore
 */
var progressItemMetadata = {
  properties: {
    data: {
      type: 'object'
    }
  }
};

var progressItemView =
  "    <div class='oj-flex oj-sm-justify-content-space-between'>" +
  "      <div class='oj-flex-item oj-flex oj-sm-flex-direction-column'>" +
  "        <span data-bind='text: $properties.data.name' class='oj-progresslist-name'></span>" +
  "        <div data-bind='text: message' class='oj-progresslist-error-message'></div>" +
  '      </div>' +
  "      <div class='oj-flex oj-sm-align-items-center'>" +
  "        <oj-bind-slot name='itemInfo'>" +
  "          <div class='oj-flex-item oj-flex oj-progresslist-info'>" +
  "            <span data-bind='text: $data.getSizeInBKMGT($properties.data.size)'></span>" +
  '          </div>' +
  '        </oj-bind-slot>' +
  "        <div class='oj-flex-item oj-flex'>" +
  "          <oj-progress-status status='{{status}}'" +
  "                              progress='{{progress}}'>" +
  '          </oj-progress-status>' +
  '        </div>' +
  '      </div>' +
  '    </div>';

function progressItemViewModel(context) {
  var self = this;
  var handleUploadProgress;
  var handleUploadFail;
  var handleUploadDone;

  // Triggered for upload progress events. The event payload contains:
  // total: {integer} total number of bytes for the upload
  // loaded: {integer} number of bytes are loaded
  handleUploadProgress = function (event) {
    var item = event.target;
    if (item && event.lengthComputable) {
      self.status(oj.ProgressItem.Status.LOADSTARTED);
      self.progress(parseInt((event.loaded / event.total) * 100, 10));
    }
  };

  // Triggered when the upload fails (error, timeout or aborted).
  handleUploadFail = function (event) {
    var item = event.target;
    if (item) {
      self.message(event.error.message);
      self.status(oj.ProgressItem.Status.ERRORED);
      removeListeners(item);
    }
  };

  // Triggered when the upload is successfully completed.
  handleUploadDone = function (event) {
    var item = event.target;
    if (item) {
      self.status(oj.ProgressItem.Status.LOADED);
      removeListeners(item);
    }
  };

  self.status = ko.observable(oj.ProgressItem.Status.QUEUED);
  self.progress = ko.observable(-1);
  self.message = ko.observable('');

  // return size in B, KB, MB or GB
  var units = ['B', 'KB', 'MB', 'GB', 'TB'];
  self.getSizeInBKMGT = function (_bytes) {
    var bytes = _bytes;
    if (isNaN(bytes)) {
      return null;
    }

    var i;
    for (i = 0; bytes >= 1024 && i < 4; i++) {
      bytes /= 1024;
    }
    return bytes.toFixed(2) + units[i];
  };

  function addListeners(item) {
    item.addEventListener(oj.ProgressItem.EventType.PROGRESS, handleUploadProgress);
    item.addEventListener(oj.ProgressItem.EventType.ERROR, handleUploadFail);
    item.addEventListener(oj.ProgressItem.EventType.TIMEOUT, handleUploadFail);
    item.addEventListener(oj.ProgressItem.EventType.ABORT, handleUploadFail);
    item.addEventListener(oj.ProgressItem.EventType.LOAD, handleUploadDone);
  }

  function removeListeners(item) {
    item.removeEventListener(oj.ProgressItem.EventType.PROGRESS, handleUploadProgress, false);
    item.removeEventListener(oj.ProgressItem.EventType.ERROR, handleUploadFail, false);
    item.removeEventListener(oj.ProgressItem.EventType.TIMEOUT, handleUploadFail, false);
    item.removeEventListener(oj.ProgressItem.EventType.ABORT, handleUploadFail, false);
    item.removeEventListener(oj.ProgressItem.EventType.LOAD, handleUploadDone, false);
  }

  // Add listeners after the listeners have been defined
  addListeners(context.properties.data);
}

// eslint-disable-next-line no-undef
Composite.register('oj-progress-item', {
  view: progressItemView,
  viewModel: progressItemViewModel,
  metadata: progressItemMetadata
});


/* global KnockoutTemplateUtils:false */
/**
 * @ojcomponent oj.ojProgressList
 * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["DataProvider"]}
 * @since 4.0.0
 * @ojdisplayname Progress List
 * @ojshortdesc A progress list displays a list of items and their progress, it is most commonly used in conjunction with a file picker to display file upload progress.
 * @ojdeprecated {since: '8.0.0', value: ['oj-list-view']}
 * @ojunsupportedthemes ["Redwood"]
 *
 * @class oj.ojProgressList
 * @ojsignature {target: "Type", value:"class ojProgressList extends JetElement<ojProgressListSettableProperties>"}
 *
 * @ojpropertylayout {propertyGroup: "data", items: ["data"]}
 * @ojvbdefaultcolumns 4
 * @ojvbmincolumns 1
 *
 * @ojoracleicon 'oj-ux-ico-progress-list'
 *
 * @classdesc
 * <h3 id="progressListOverview-section">
 *   JET ProgressList
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#progressListOverview-section"></a>
 * </h3>
 * <p>Description:</p>
 * <p>Display a <code class="prettyprint">ListView</code> where the data is a <code class="prettyprint">DataProvider</code> or
 * <code class="prettyprint">TableDataSource</code> and data rows are <code class="prettyprint">ProgressItem</code>s.
 * <p>Please see the <code class="prettyprint">ListView</code> for Touch and Keyboard End User Information</p>
 *
 * <p>See {@link oj.ojListView}</p>
 * <p>See {@link DataProvider}</p>
 * <p>See {@link TableDataSource}</p>
 * <p>See {@link oj.ProgressItem}</p>
 *
 * <pre class="prettyprint">
 * <code>
 * &lt;oj-progress-list data='{{dataProvider}}'>
 * &lt;/oj-progress-list>
 * </code>
 * </pre>
 */

/**
 * Data used by the ProgressList.
 * @member
 * @name data
 * @memberof oj.ojProgressList
 * @instance
 * @ojshortdesc Data used by the ProgressList.
 * @type {Object|null}
 * @ojsignature [{target: "Type", value: "DataProvider<any, any>|null"},
 *               {target: "Type", value: "DataProvider|TableDataSource|null", consumedBy:"js"}]
 *
 * @default null
 * @ojwebelementstatus {type: "deprecated", since: "14.0.0",
 *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
 *
 * @example <caption>Initialize the progress list with the <code class="prettyprint">data</code> attribute specified:</caption>
 * &lt;oj-progress-list data='{{dataProvider}}'>&lt;/oj-progress-list>
 *
 * @example <caption>Get or set the <code class="prettyprint">data</code> property after initialization:</caption>
 * // getter
 * var dataValue = myProgressList.data;
 *
 * // setter
 * myProgressList.data = dataProvider;
 */

var progressListView =
  '<oj-list-view data-bind="attr: {id: $unique + \'_list\'}"' +
  "              aria-label='list using array'" +
  "              data='{{$properties.data}}'" +
  "              item.renderer='{{renderer()}}'" +
  "              selection-mode='single'>" +
  '</oj-list-view>' +
  '' +
  '<script type=\'text/html\' data-bind="attr: {id: tempId}">' +
  "  <li class='oj-progresslist-item' tabindex='0'>" +
  "    <oj-progress-item data='{{$data}}'>" +
  '    </oj-progress-item>' +
  '  </li>' +
  '</script>';

function progressListViewModel(context) {
  var self = this;
  self.tempId = context.unique + '_templ';

  self.renderer = function () {
    return KnockoutTemplateUtils.getRenderer(self.tempId, true);
  };
}

/* global __oj_progress_list_metadata */
// eslint-disable-next-line no-undef
Composite.register('oj-progress-list', {
  view: progressListView,
  viewModel: progressListViewModel,
  metadata: __oj_progress_list_metadata
});

/**
 * Sets a property or a single subproperty for complex properties and notifies the component
 * of the change, triggering a [property]Changed event.
 *
 * @function setProperty
 * @param {string} property - The property name to set. Supports dot notation for subproperty access.
 * @param {any} value - The new value to set the property to.
 * @return {void}
 *
 * @expose
 * @memberof oj.ojProgressList
 * @instance
 *
 * @example <caption>Set a single subproperty of a complex property:</caption>
 * myComponent.setProperty('complexProperty.subProperty1.subProperty2', "someValue");
 */
/**
 * Retrieves a value for a property or a single subproperty for complex properties.
 * @function getProperty
 * @param {string} property - The property name to get. Supports dot notation for subproperty access.
 * @return {any}
 *
 * @expose
 * @memberof oj.ojProgressList
 * @instance
 *
 * @example <caption>Get a single subproperty of a complex property:</caption>
 * var subpropValue = myComponent.getProperty('complexProperty.subProperty1.subProperty2');
 */
/**
 * Performs a batch set of properties.
 * @function setProperties
 * @param {Object} properties - An object containing the property and value pairs to set.
 * @return {void}
 *
 * @expose
 * @memberof oj.ojProgressList
 * @instance
 *
 * @example <caption>Set a batch of properties:</caption>
 * myComponent.setProperties({"prop1": "value1", "prop2.subprop": "value2", "prop3": "value3"});
 */



/**
 * @ignore
 * @ojtsignore
 * @ojcomponent oj.ojProgressStatus
 * @since 4.0.0
 * @classdesc Display a progress and status icon when ended. The property data is a <code class="prettyprint">ProgressItem</code>.
 */

/**
 * @member
 * @name data
 * @memberof oj.ojProgressStatus
 * @instance
 * @type {null|oj.ProgressItem}
 * @default null
 * @ojshortdesc Data used by the file upload progress status.
 */

/**
 * @ignore
 * @ojtsignore
 */
var progressStatusMetadata = {
  properties: {
    status: {
      type: 'string'
    },
    progress: {
      type: 'number'
    }
  }
};

var progressStatusView =
  '  <div data-bind=\'visible: ($properties.status == "queued")\'' +
  "       class='oj-progressstatus-cell'>" +
  "    <div class='oj-component-icon oj-progressstatus-cancel-icon'" +
  "         role='img' title='cancel'></div>" +
  '  </div>' +
  '  <div data-bind=\'visible: ($properties.status == "loadstarted")\'' +
  "       class='oj-progressstatus-cell'>" +
  "    <oj-progress type='circle' value='{{$properties.progress}}'>" +
  '    </oj-progress>' +
  '  </div>' +
  '  <div data-bind=\'visible: ($properties.status == "loaded")\'' +
  "       class='oj-progressstatus-cell'>" +
  "    <div class='oj-component-icon oj-progressstatus-done-icon' role='img' title='done'></div>" +
  '  </div>' +
  '  <div data-bind=\'visible: ($properties.status == "errored" || $properties.status == "timedout" || $properties.status == "aborted")\'' +
  "       class='oj-progressstatus-cell'>" +
  "    <div class='oj-component-icon oj-progressstatus-error-icon' role='img' title='error'></div>" +
  '  </div>';

// eslint-disable-next-line no-undef
Composite.register('oj-progress-status', {
  view: progressStatusView,
  metadata: progressStatusMetadata
});

});

define('ojs/ojfilmstrip',['exports', 'ojs/ojcore-base', 'jquery', 'ojs/ojcontext', 'ojs/ojcomponentcore', 'ojs/ojlogger', 'ojs/ojdomutils', 'ojs/ojfocusutils', 'touchr'], function (exports, oj, $, Context, Components, Logger, DomUtils, FocusUtils, touchr) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;
  FocusUtils = FocusUtils && Object.prototype.hasOwnProperty.call(FocusUtils, 'default') ? FocusUtils['default'] : FocusUtils;

var __oj_film_strip_metadata = 
{
  "properties": {
    "arrowPlacement": {
      "type": "string",
      "enumValues": [
        "adjacent",
        "overlay"
      ],
      "value": "adjacent"
    },
    "arrowVisibility": {
      "type": "string",
      "enumValues": [
        "auto",
        "hidden",
        "hover",
        "visible"
      ],
      "value": "auto"
    },
    "currentItem": {
      "type": "object",
      "writeback": true,
      "value": {
        "index": 0
      },
      "properties": {
        "id": {
          "type": "string"
        },
        "index": {
          "type": "number"
        }
      }
    },
    "looping": {
      "type": "string",
      "enumValues": [
        "off",
        "page"
      ],
      "value": "off"
    },
    "maxItemsPerPage": {
      "type": "number",
      "value": 0
    },
    "orientation": {
      "type": "string",
      "enumValues": [
        "horizontal",
        "vertical"
      ],
      "value": "horizontal"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "labelAccArrowNextPage": {
          "type": "string"
        },
        "labelAccArrowPreviousPage": {
          "type": "string"
        },
        "labelAccFilmStrip": {
          "type": "string"
        },
        "tipArrowNextPage": {
          "type": "string"
        },
        "tipArrowPreviousPage": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getItemsPerPage": {},
    "getPagingModel": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "extension": {}
};
  /* global __oj_film_strip_metadata:false */
  (function () {
    __oj_film_strip_metadata.extension._WIDGET_NAME = 'ojFilmStrip';
    __oj_film_strip_metadata.extension._TRACK_CHILDREN = 'immediate';
    oj.CustomElementBridge.register('oj-film-strip', { metadata: __oj_film_strip_metadata });
  })();

  /* jslint browser: true*/
  /**
   * Implementation of PagingModel used by FilmStrip.
   * @class oj.FilmStripPagingModel
   * @classdesc Implementation of PagingModel used by FilmStrip.
   * @extends EventSource
   * @implements PagingModel
   * @constructor
   * @ignore
   */

  const FilmStripPagingModel = function () {
    this.Init();
  };

  oj._registerLegacyNamespaceProp('FilmStripPagingModel', FilmStripPagingModel);
  // Subclass from oj.EventSource
  oj.Object.createSubclass(FilmStripPagingModel, oj.EventSource, 'oj.FilmStripPagingModel');

  /**
   * Initialize the instance.
   * @return {void}
   * @memberof FilmStripPagingModel
   * @instance
   * @export
   */
  FilmStripPagingModel.prototype.Init = function () {
    FilmStripPagingModel.superclass.Init.call(this);

    this._page = -1;
    this._totalSize = 0;
    this._pageSize = -1;
  };

  /**
   * Set the total size.
   * @param {number} totalSize The total size.
   * @return {void}
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.setTotalSize = function (totalSize) {
    this._totalSize = totalSize;
  };

  /**
   * Get the page size.
   * @returns {number} The page size.
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.getPageSize = function () {
    return this._pageSize;
  };

  // start PagingModel interface methods //////////////////////////////////////

  /**
   * Get the current page
   * @returns {number} The current page
   * @export
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.getPage = function () {
    return this._page;
  };

  /**
   * Set the current page
   * @param {number} page The current page
   * @param {Object=} options Options<p>
   *                  pageSize: The page size.<p>
   * @returns {Promise} promise object triggering done when complete
   * @export
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.setPage = function (page, options) {
    // ensure that the page index is an actual number, because the paging control
    // seems to set a string when you click on one of the page dots
    // eslint-disable-next-line no-param-reassign
    page = parseInt(page, 10);

    try {
      var prevPageCount = this.getPageCount();
      var prevPage = this._page;
      var prevPageSize = this._pageSize;
      var pageSize = prevPageSize;
      if (options && options.pageSize) {
        pageSize = options.pageSize;
      }

      // FIX : if the paging model hasn't been initialized yet,
      // just return a resolved promise instead of throwing the invalid page
      // error below
      if (this._totalSize === 0 && pageSize === -1) {
        return Promise.resolve();
      }

      var newPageCount = Math.ceil(this._totalSize / pageSize);
      if (page < 0 || page > newPageCount - 1) {
        throw new Error("JET FilmStrip: Invalid 'page' set: " + page);
      }

      var bFiredBeforePageEvent = false;
      if (page !== prevPage || pageSize !== prevPageSize) {
        var bSuccess = this.handleEvent('beforePage', {
          page: page,
          previousPage: prevPage
        });
        if (bSuccess === false) {
          return Promise.reject();
        }
        bFiredBeforePageEvent = true;
      }

      this._page = page;
      this._pageSize = pageSize;
      var pageCount = this.getPageCount();
      var self = this;

      return new Promise(function (resolve) {
        if (prevPageCount !== pageCount) {
          self.handleEvent('pageCount', { pageCount: pageCount, previousPageCount: prevPageCount });
        }
        if (bFiredBeforePageEvent) {
          var optionsObj = { page: page, previousPage: prevPage };
          if (options && options.loopDirection) {
            optionsObj.loopDirection = options.loopDirection;
          }
          self.handleEvent('page', optionsObj);
        }
        resolve(null);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  /**
   * Get the current page start index
   * @returns {number} The current page start index
   * @export
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.getStartItemIndex = function () {
    // FIX : if there is no data yet, explicitly return -1 for
    // start index, because otherwise the calculated value would incorrectly
    // be 1
    if (this._page === -1 && this._pageSize === -1) {
      return -1;
    }

    return this._page * this._pageSize;
  };

  /**
   * Get the current page end index
   * @returns {number} The current page end index
   * @export
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.getEndItemIndex = function () {
    return Math.min(this.getStartItemIndex() + this._pageSize, this._totalSize) - 1;
  };

  /**
   * Get the page count
   * @returns {number} The total number of pages
   * @export
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.getPageCount = function () {
    return Math.ceil(this._totalSize / this._pageSize);
  };

  /**
   * Return the total number of items. Returns -1 if unknown.
   * @returns {number} total number of items
   * @export
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.totalSize = function () {
    return this._totalSize;
  };

  /**
   * Returns the confidence for the totalSize value.
   * @return {string} "actual" if the totalSize is the time of the fetch is an exact number
   *                  "estimate" if the totalSize is an estimate
   *                  "atLeast" if the totalSize is at least a certain number
   *                  "unknown" if the totalSize is unknown
   * @export
   * @expose
   * @memberof FilmStripPagingModel
   * @instance
   */
  FilmStripPagingModel.prototype.totalSizeConfidence = function () {
    return 'actual';
  };

  // end PagingModel interface methods ////////////////////////////////////////

  /**
   * @ojcomponent oj.ojFilmStrip
   * @augments oj.baseComponent
   * @since 1.1.0
   *
   * @ojshortdesc A filmstrip lays out its children in a single row or column across logical pages and allows navigating through them.
   * @ojrole application
   * @class oj.ojFilmStrip
   *
   * @ojtsimport {module: "ojpagingmodel", type: "AMD", imported: ["PagingModel"]}
   * @ojpropertylayout [ {propertyGroup: "common", items: ["orientation", "maxItemsPerPage", "arrowPlacement", "arrowVisibility", "looping"]},
   *                     {propertyGroup: "data", items: ["currentItem"]} ]
   * @ojvbdefaultcolumns 12
   * @ojvbmincolumns 1
   *
   * @ojoracleicon 'oj-ux-ico-film-strip'
   *
   * @classdesc
   * <h3 id="filmStripOverview-section">
   *   JET FilmStrip
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#filmStripOverview-section"></a>
   * </h3>
   *
   * <p>Description: Container element that lays out its children in a single
   * row or column across logical pages and allows navigating through them.
   *
   * <p>A JET FilmStrip can contain multiple direct child elements and
   * all child elements are expected to be the same size.
   * <p>FilmStrip will layout the child items across multiple logical pages and
   * allow for changing between logical pages.  When the element is resized,
   * relayout will occur and the number of pages and number of items shown per
   * page may change.
   *
   * <p>Note for performance reasons, if the FilmStrip content is expensive to render, you should wrap it in an <code class="prettyprint">oj-defer</code> element (API doc {@link oj.ojDefer}) to defer the rendering of that content until it is shown by the filmstrip.<br/>
   * See the Film Strip - Deferred Rendering demo for an example.</p>
   *
   * <pre class="prettyprint"><code>
   * &lt;oj-film-strip>
   *   &lt;div class='my-filmstrip-item'>Alpha&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Beta&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Gamma&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Delta&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Epsilon&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Zeta&lt;/div>
   * &lt;/oj-film-strip>
   * </code></pre>
   *
   * <p id="filmStrip-conveyorBelt-section">JET FilmStrip and ConveyorBelt look similar, but are intended to be used
   * for different purposes.
   * <a class="bookmarkable-link" title="Bookmarkable Link" href="#filmStrip-conveyorBelt-section"></a>
   * <p>Use FilmStrip when you want to:
   * <ul>
   * <li>layout a set of items across discrete logical pages</li>
   * <li>control which and how many items are shown</li>
   * <li>hide items outside the current viewport from tab order and screen reader</li>
   * </ul>
   * <p>Use ConveyorBelt when you want to:
   * <ul>
   * <li>handle overflow without showing a scrollbar</li>
   * <li>keep all items accessible via tabbing and readable by a screen reader</li>
   * </ul>
   *
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   *
   * <h3 id="keyboard-appdev-section">
   *   Keyboard Application Developer Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-appdev-section"></a>
   * </h3>
   *
   * <p>FilmStrip is for layout only.  Providing keyboard support for the child
   * items in the filmstrip is the responsibility of the application developer, if
   * the items do not already support keyboard interaction.  This could be done,
   * for example, by specifying <code class="prettyprint">tabindex</code> on each
   * item to enable tab navigation among them.
   *
   * <p>Only the child items of the FilmStrip that are visible in the current
   * logical page can be tabbed to.  Items outside the current logical page are
   * hidden from the tab order.
   *
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>FilmStrip is for layout only.  It is the responsibility of the
   * application developer to make the items in the filmstrip accessible.  Sighted
   * keyboard-only users need to be able to access the items in the layout just by
   * using the keyboard.  It is up to the child items of the FilmStrip to
   * support keyboard navigation.
   *
   * <p>Only the child items of the FilmStrip that are visible in the current
   * logical page can be read by a screen reader.  Items outside the current
   * logical page are hidden from a screen reader.
   *
   * <p>FilmStrip assigns itself the WAI-ARIA
   * <code class="prettyprint">role</code> of
   * <code class="prettyprint">"application"</code>.  The application <b>must</b>
   * specify a WAI-ARIA label for the FilmStrip element so that screen reader
   * users will understand the purpose of the FilmStrip.
   *
   * <p>The application <b>must</b> provide accessible controls for navigating
   * through the logical pages of the FilmStrip for use by screen reader users,
   * because the arrow keys may be intercepted by the screen reader itself.  The
   * navigation arrows built into FilmStrip can be used, or if they are hidden,
   * then alternative means, such as a paging control, must be provided.
   *
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Lazy Rendering</h4>
   * <p>If there are many items in the FilmStrip or complex content in each item,
   * it is recommended to implement lazy rendering of item content.  The application
   * should keep track of which items have rendered their content.  Items that are
   * initially visible in the FilmStrip should render their content from the start.
   * The application should then listen to events from the FilmStrip's
   * <code class="prettyprint">PagingModel</code> in order to render content for
   * items that are paged into view later.
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET element, in the unusual case that the directionality
   * (LTR or RTL) changes post-init, the FilmStrip must be
   * <code class="prettyprint">refresh()</code>ed.
   */

  //-----------------------------------------------------
  //                   Slots
  //-----------------------------------------------------
  /**
   * <p>The &lt;oj-film-strip> element lays out its children in a single row or column across logical pages and allows navigating through them.<p>
   *
   * @ojchild Default
   * @memberof oj.ojFilmStrip
   *
   * @example <caption>Initialize the film strip with child content specified:</caption>
   * &lt;oj-film-strip>
   *   &lt;div class='my-filmstrip-item'>Alpha&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Beta&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Gamma&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Delta&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Epsilon&lt;/div>
   *   &lt;div class='my-filmstrip-item'>Zeta&lt;/div>
   * &lt;/oj-film-strip>
   */

  //-----------------------------------------------------
  //                   Sub-ids
  //-----------------------------------------------------
  /**
   * <p>Sub-ID for the start navigation arrow of a horizontal FilmStrip.</p>
   *
   * @ojsubid oj-filmstrip-start-arrow
   * @memberof oj.ojFilmStrip
   *
   * @example <caption>Get the start navigation arrow:</caption>
   * var node = myFilmStrip.getNodeBySubId({'subId': 'oj-filmstrip-start-arrow'} );
   */

  /**
   * <p>Sub-ID for the end navigation arrow of a horizontal FilmStrip.</p>
   *
   * @ojsubid oj-filmstrip-end-arrow
   * @memberof oj.ojFilmStrip
   *
   * @example <caption>Get the end navigation arrow:</caption>
   * var node = myFilmStrip.getNodeBySubId({'subId': 'oj-filmstrip-end-arrow'} );
   */

  /**
   * <p>Sub-ID for the top navigation arrow of a vertical FilmStrip.</p>
   *
   * @ojsubid oj-filmstrip-top-arrow
   * @memberof oj.ojFilmStrip
   *
   * @example <caption>Get the top navigation arrow:</caption>
   * var node = myFilmStrip.getNodeBySubId({'subId': 'oj-filmstrip-top-arrow'} );
   */

  /**
   * <p>Sub-ID for the bottom navigation arrow of a vertical FilmStrip.</p>
   *
   * @ojsubid oj-filmstrip-bottom-arrow
   * @memberof oj.ojFilmStrip
   *
   * @example <caption>Get the bottom navigation arrow:</caption>
   * var node = myFilmStrip.getNodeBySubId({'subId': 'oj-filmstrip-bottom-arrow'} );
   */

  //-----------------------------------------------------
  //                   Fragments
  //-----------------------------------------------------
  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>FilmStrip</td>
   *       <td><kbd>Swipe</kbd></td>
   *       <td>Transition to an adjacent logical page of child items.</td>
   *     </tr>
   *     <tr>
   *       <td>Navigation Arrow</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Transition to an adjacent logical page of child items.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojFilmStrip
   */

  /**
   * <p>FilmStrip itself is a tabstop and supports the following keyboard interactions:
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>FilmStrip</td>
   *       <td><kbd>UpArrow or LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
   *       <td>Transition to the previous logical page of child items.</td>
   *     </tr>
   *     <tr>
   *       <td>FilmStrip</td>
   *       <td><kbd>DownArrow or RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
   *       <td>Transition to the next logical page of child items.</td>
   *     </tr>
   *     <tr>
   *       <td>FilmStrip</td>
   *       <td><kbd>Home</kbd></td>
   *       <td>Transition to the first logical page of child items.</td>
   *     </tr>
   *     <tr>
   *       <td>FilmStrip</td>
   *       <td><kbd>End</kbd></td>
   *       <td>Transition to the last logical page of child items.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojFilmStrip
   */
  (function () {
    // start static members and functions //////////////////////////////////////////

    const _ADJACENT = 'adjacent';
    // aria-hidden DOM attribute
    const _ARIA_HIDDEN = 'aria-hidden';
    const _AUTO = 'auto';
    // display CSS attribute
    const _DISPLAY = 'display';

    // threshold to initialize a drag scroll (pixels)
    const _DRAG_SCROLL_INIT_THRESHOLD = 3;
    // drag scroll threshold (percentage of filmStrip size)
    const _DRAG_SCROLL_THRESHOLD = 0.33;
    // drag scroll threshold (max distance, pixels)
    const _DRAG_SCROLL_MAX_THRESHOLD = 100;

    const _EMPTY_STRING = '';
    // throw an error when invalid "currentItem" property set
    const _ERROR_CURRENT_ITEM_NOT_FOUND =
      "JET FilmStrip: Value of 'currentItem' property is invalid. No such item exists: ";
    // throw an error when "orientation" property set to invalid value
    const _ERROR_INVALID_ORIENTATION =
      "JET FilmStrip: Unsupported value set as 'orientation' property: ";
    // throw an error when "arrowPlacement" property set to invalid value
    const _ERROR_INVALID_NAV_ARROW_PLACEMENT =
      "JET FilmStrip: Unsupported value set as 'arrowPlacement' property: ";
    // throw an error when "arrowVisibility" property set to invalid value
    const _ERROR_INVALID_NAV_ARROW_VISIBILITY =
      "JET FilmStrip: Unsupported value set as 'arrowVisibility' property: ";
    // throw an error when "looping" property set to invalid value
    const _ERROR_INVALID_LOOPING = "JET FilmStrip: Unsupported value set as 'looping' property: ";
    const _FLEX_BASIS = 'flex-basis';
    const _HIDDEN = 'hidden';
    // jQuery hidden selector
    const _HIDDEN_SELECTOR = ':hidden';
    const _HORIZONTAL = 'horizontal';
    const _HOVER = 'hover';
    const _CURRENT_ITEM = 'currentItem';
    const _MS_TRANSFORM = '-ms-transform';
    const _NONE = 'none';

    const _OJ_BOTTOM = 'oj-bottom';
    const _OJ_END = 'oj-end';
    const _OJ_FILMSTRIP_ARROW = 'oj-filmstrip-arrow';
    const _OJ_FILMSTRIP_ARROW_CONTAINER = 'oj-filmstrip-arrow-container';
    const _OJ_FILMSTRIP_ARROW_TRANSITION = 'oj-filmstrip-arrow-transition';
    const _OJ_FILMSTRIP_CONTAINER = 'oj-filmstrip-container';
    const _OJ_FILMSTRIP_HOVER = 'oj-filmstrip-hover';
    const _OJ_FILMSTRIP_ITEM = 'oj-filmstrip-item';
    const _OJ_FILMSTRIP_ITEM_CONTAINER = 'oj-filmstrip-item-container';
    const _OJ_FILMSTRIP_PAGE = 'oj-filmstrip-page';
    const _OJ_FILMSTRIP_PAGES_CONTAINER = 'oj-filmstrip-pages-container';
    const _OJ_FILMSTRIP_TRANSITION = 'oj-filmstrip-transition';
    const _OJ_FILMSTRIP_TRANSITION_NEXT_NEWPAGE_FROM = 'oj-filmstrip-transition-next-newpage-from';
    const _OJ_FILMSTRIP_TRANSITION_NEXT_OLDPAGE_FROM = 'oj-filmstrip-transition-next-oldpage-from';
    const _OJ_FILMSTRIP_TRANSITION_PREV_NEWPAGE_FROM = 'oj-filmstrip-transition-prev-newpage-from';
    const _OJ_FILMSTRIP_TRANSITION_PREV_OLDPAGE_FROM = 'oj-filmstrip-transition-prev-oldpage-from';
    const _OJ_FILMSTRIP_TRANSITION_NEXT_NEWPAGE_TO = 'oj-filmstrip-transition-next-newpage-to';
    const _OJ_FILMSTRIP_TRANSITION_NEXT_OLDPAGE_TO = 'oj-filmstrip-transition-next-oldpage-to';
    const _OJ_FILMSTRIP_TRANSITION_PREV_NEWPAGE_TO = 'oj-filmstrip-transition-prev-newpage-to';
    const _OJ_FILMSTRIP_TRANSITION_PREV_OLDPAGE_TO = 'oj-filmstrip-transition-prev-oldpage-to';
    const _OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_FIRSTPAGE =
      'oj-filmstrip-transition-display-as-firstpage';
    const _OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_LASTPAGE =
      'oj-filmstrip-transition-display-as-lastpage';
    const _OJ_FILMSTRIP_LABELLEDBY = 'aria-labelledby';
    const _OJ_FILMSTRIP_START_ARROW = 'oj-filmstrip-start-arrow';
    const _OJ_FILMSTRIP_END_ARROW = 'oj-filmstrip-end-arrow';
    const _OJ_FILMSTRIP_TOP_ARROW = 'oj-filmstrip-top-arrow';
    const _OJ_FILMSTRIP_BOTTOM_ARROW = 'oj-filmstrip-bottom-arrow';
    const _OJ_FILMSTRIP_VERTICAL = 'oj-filmstrip-vertical';
    const _OJ_START = 'oj-start';
    const _OJ_TOP = 'oj-top';
    const _LOOPING_OFF = 'off';
    const _LOOPING_PAGE = 'page';
    const _LOOPING_DIRECTION_NEXT = 'next';
    const _LOOPING_DIRECTION_PREV = 'prev';

    const _OVERLAY = 'overlay';
    const _PERIOD = '.';
    const _PX = 'px';
    // make sure the collapseEventTimeout param is less than the one used in the unit tests
    // in order to ensure that the filmStrip listener gets the resize event before the unit test
    const _RESIZE_LISTENER_COLLAPSE_EVENT_TIMEOUT = 25;
    const _TRANSFORM = 'transform';
    const _VERTICAL = 'vertical';
    const _VISIBLE = 'visible';
    // jQuery visible selector
    const _VISIBLE_SELECTOR = ':visible';
    const _WEBKIT_FLEX_BASIS = '-webkit-flex-basis';
    const _WEBKIT_TRANSFORM = '-webkit-transform';

    // log warning message when "disabled" property set
    const _WARNING_DISABLED_OPTION = "JET FilmStrip: 'disabled' property not supported";
    // log a warning when filmstrip has no children present
    const _WARNING_FILMSTRIP_EMPTY = 'JET FilmStrip: There are no nested children!';

    /**
     * Apply a CSS transform to the given object.
     * @param {jQuery} jqObj Object to apply transform to.
     * @param {string} transform The transform to apply.
     * @memberof oj.ojFilmStrip
     * @private
     */
    function _applyTransform(jqObj, transform) {
      jqObj
        .css(_WEBKIT_TRANSFORM, transform)
        .css(_MS_TRANSFORM, transform)
        .css(_TRANSFORM, transform);
    }

    /**
     * Remove a CSS transform from the given object.
     * @param {jQuery} jqObj Object to apply transform to.
     * @memberof oj.ojFilmStrip
     * @private
     */
    function _removeTransform(jqObj) {
      jqObj
        .css(_WEBKIT_TRANSFORM, _EMPTY_STRING)
        .css(_MS_TRANSFORM, _EMPTY_STRING)
        .css(_TRANSFORM, _EMPTY_STRING);
    }

    /**
     * Escape an html fragment/text.
     * @param {string} text Text to escape.
     * @returns {string} Escaped text.
     * @memberof oj.ojFilmStrip
     * @private
     */
    function _escapeHtml(text) {
      // let jQuery escape the text
      const jqDiv = $('<div></div>');
      jqDiv.text(text);
      return jqDiv[0].innerHTML; // @HTMLUpdateOK
    }

    // end static members and functions ////////////////////////////////////////////

    function _isInvalidCurrentItemId(id, elem) {
      return id && DomUtils.isValidIdentifier(id) && !elem.find(`#${id}`).length;
    }

    function _isInvalidCurrentItemIndex(index, elem) {
      return index != null && (index < 0 || index >= elem.children().length);
    }

    oj.__registerWidget('oj.ojFilmStrip', $.oj.baseComponent, {
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',

      options: {
        /**
         * Specify the maximum number of child items to show in a logical page.
         * A value of 0 (the default) means that FilmStrip will show as many items
         * per logical page as will fit based on the element and item sizes.
         *
         * <p>FilmStrip may show fewer than the specified number of items when
         * <code class="prettyprint">max-items-per-page</code> is set to a value other
         * than 0 if the element size is smaller than what would be required to
         * show that many items.
         *
         * @expose
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {number}
         * @default 0
         * @see #getItemsPerPage
         * @ojshortdesc Specifies the maximum number of child items shown in a logical page.
         * @ojmin 0
         *
         * @example <caption>Initialize the FilmStrip with the
         * <code class="prettyprint">max-items-per-page</code> attribute specified:</caption>
         * &lt;oj-film-strip max-items-per-page='3'>
         * &lt;/oj-film-strip>
         *
         * @example <caption>Get or set the <code class="prettyprint">maxItemsPerPage</code>
         * property after initialization:</caption>
         * // getter
         * var maxItemsPerPage = myFilmStrip.maxItemsPerPage;
         *
         * // setter
         * myFilmStrip.maxItemsPerPage = 3;
         */
        maxItemsPerPage: 0,

        /**
         * Specify the orientation of the FilmStrip.
         *
         * @expose
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {string}
         * @ojvalue {string} "horizontal" Orient the FilmStrip horizontally.
         * @ojvalue {string} "vertical" Orient the FilmStrip vertically.
         * @default "horizontal"
         * @ojshortdesc Specifies the orientation of the FilmStrip.
         *
         * @example <caption>Initialize the FilmStrip with the
         * <code class="prettyprint">orientation</code> attribute specified:</caption>
         * &lt;oj-film-strip orientation='vertical'>
         * &lt;/oj-film-strip>
         *
         * @example <caption>Get or set the <code class="prettyprint">orientation</code>
         * property after initialization:</caption>
         * // getter
         * var orientation = myFilmStrip.orientation;
         *
         * // setter
         * myFilmStrip.orientation = 'vertical';
         */
        orientation: 'horizontal',

        /**
         * Specify the child item whose logical page should be displayed.  The
         * position of the item on the logical page is not guaranteed.
         *
         * <p>This attribute can be set to an object containing either string id of the item
         * or numeric 0-based index of the item or both.  If the object contains both
         * string id and numeric index, string id takes precedence.
         *
         * <p>FilmStrip will automatically update the value of this attribute when the
         * logical page is changed to be the first item on the new logical page.
         * When the value is updated automatically, it will be an object containing
         * numeric index and string id, if available.
         *
         * <p>When the element is resized, FilmStrip will preserve the value of
         * this attribute to show the new logical page on which the item is located.
         *
         * @property {string} [id] string id of the item
         * @property {number} [index] numeric 0-based index of the item
         *
         * @expose
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {Object}
         * @ojsignature {target: "Type", value: "{id?: string, index?: number}", jsdocOverride: true}
         * @default {"index" : 0}
         * @ojwriteback
         * @ojshortdesc Specifies the child item whose logical page should be displayed.
         *
         * @example <caption>Initialize the FilmStrip with the
         * <code class="prettyprint">current-item</code> attribute specified:</caption>
         * &lt;!-- Using dot notation -->
         * &lt;oj-film-strip current-item.index='3' current-item.id='thirdItemId'>
         * &lt;/oj-film-strip>
         *
         * &lt;!-- Using JSON notation -->
         * &lt;oj-film-strip current-item='{"index" : 3, "id" : "thirdItemId"}'>
         * &lt;/oj-film-strip>
         *
         * @example <caption>Get or set the <code class="prettyprint">currentItem</code>
         * property after initialization:</caption>
         *
         * // Get one
         * var index = myFilmStrip.currentItem.index;
         *
         * // Set one, leaving the others intact. Use the setProperty API for
         * // subproperties so that a property change event is fired.
         * myFilmStrip.setProperty('currentItem.index', 1);
         *
         * // Get all
         * var currentItem = myFilmStrip.currentItem;
         *
         * // Set all
         * myFilmStrip.currentItem = {'index' : 3, 'id' : 'thirdItemId'};
         */
        currentItem: { index: 0 },

        /**
         * Specify the placement of the navigation arrows.
         *
         * @expose
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {string}
         * @ojvalue {string} "adjacent" Arrows are outside, adjacent to the filmStrip
         *          content.  The arrows are still inside the bounds of the filmStrip
         *          element itself.
         * @ojvalue {string} "overlay" Arrows are inside, overlaying the filmStrip content.
         * @default "adjacent"
         * @ojshortdesc Specifies the placement of the navigation arrows.
         *
         * @example <caption>Initialize the FilmStrip with the
         * <code class="prettyprint">arrow-placement</code> attribute specified:</caption>
         * &lt;oj-film-strip arrow-placement='overlay'>
         * &lt;/oj-film-strip>
         *
         * @example <caption>Get or set the <code class="prettyprint">arrowPlacement</code>
         * property after initialization:</caption>
         * // getter
         * var arrowPlacement = myFilmStrip.arrowPlacement;
         *
         * // setter
         * myFilmStrip.arrowPlacement = 'overlay';
         */
        arrowPlacement: 'adjacent',

        /**
         * Specify the visibility of the navigation arrows.
         *
         * @expose
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {string}
         * @ojvalue {string} "visible" Arrows are visible.
         * @ojvalue {string} "hidden" Arrows are hidden.
         * @ojvalue {string} "hover" Arrows are visible when the mouse is over the
         *          filmStrip, and hidden otherwise.
         * @ojvalue {string} "auto" Behaves as if the value were
         *          <code class="prettyprint">visible</code> when the
         *          <code class="prettyprint">arrow-placement</code>
         *          attribute is set to <code class="prettyprint">adjacent</code>, and
         *          <code class="prettyprint">hover</code> when the
         *          <code class="prettyprint">arrow-placement</code>
         *          attribute is set to <code class="prettyprint">overlay</code>.
         * @default "auto"
         * @ojshortdesc Specifies the visibility of the navigation arrows.
         *
         * @example <caption>Initialize the FilmStrip with the
         * <code class="prettyprint">arrow-visibility</code> attribute specified:</caption>
         * &lt;oj-film-strip arrow-visibility='visible'>
         * &lt;/oj-film-strip>
         *
         * @example <caption>Get or set the <code class="prettyprint">arrowVisibility</code>
         * property after initialization:</caption>
         * // getter
         * var arrowVisibility = myFilmStrip.arrowVisibility;
         *
         * // setter
         * myFilmStrip.arrowVisibility = 'visible';
         */
        arrowVisibility: 'auto',

        /**
         * Specify the navigation looping behavior.
         *
         *
         * @expose
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {string}
         * @ojvalue {string} "off"  Navigation is bounded between first and last page and
         *                          can't go any further in the direction of navigation.
         * @ojvalue {string} "page" Navigation is not bounded between first and last page
         *                          and can go further in the direction of navigation.
         *                          This lets the user loop around from first page to last page, or
         *                          from last page to first page.
         * @default "off"
         * @ojshortdesc Specifies the navigation looping behavior
         *
         * @example <caption>Initialize the FilmStrip with the
         * <code class="prettyprint">looping</code> attribute specified:</caption>
         * &lt;oj-film-strip looping='page'>
         * &lt;/oj-film-strip>
         *
         * @example <caption>Get or set the <code class="prettyprint">looping</code>
         * property after initialization:</caption>
         * // getter
         * var looping = myFilmStrip.looping;
         *
         * // setter
         * myFilmStrip.looping = 'page';
         */
        looping: 'off'

        /**
         * FilmStrip inherits the <code class="prettyprint">disabled</code>
         * attribute from its superclass, but does not support it in order to avoid
         * tight coupling between a FilmStrip and its contents.  Setting this
         * attribute on FilmStrip has no effect.
         *
         * <p><b>WARNING:</b> Applications should not depend on this behavior
         * because we reserve the right to change it in the future in order to
         * support <code class="prettyprint">disabled</code> and propagate it to
         * child elements of FilmStrip.
         *
         * @member
         * @name disabled
         * @memberof oj.ojFilmStrip
         * @instance
         * @type {boolean}
         * @default false
         * @ignore
         */
        // disabled attribute declared in superclass, but we still want the above API doc

        // Events

        /**
         * Triggered when the filmStrip is created.
         *
         * @event
         * @name create
         * @memberof oj.ojFilmStrip
         * @instance
         * @ignore
         */
        // create event declared in superclass, but we still want the above API doc
      },

      /**
       * After _ComponentCreate and _AfterCreate,
       * the widget should be 100% set up. this._super should be called first.
       * @return {void}
       * @override
       * @protected
       * @instance
       * @memberof oj.ojFilmStrip
       */
      _ComponentCreate: function () {
        // Override of protected base class method.
        // call superclass first
        this._super();

        const elem = this.element;
        elem.addClass('oj-filmstrip oj-component').attr('tabindex', 0).attr('role', 'application');

        // ensure a unique id for use with aria-labelledby on navigation arrows
        elem.uniqueId();

        this._focusable({ element: elem, applyHighlight: true });

        // log warning message when "disabled" property set
        const options = this.options;
        if (options.disabled) {
          Logger.warn(_WARNING_DISABLED_OPTION);
        }

        // throw error if "orientation" property set to invalid value
        if (options.orientation !== _HORIZONTAL && options.orientation !== _VERTICAL) {
          throw new Error(_ERROR_INVALID_ORIENTATION + options.orientation);
        }

        // throw error if "arrowPlacement" property set to invalid value
        if (options.arrowPlacement !== _ADJACENT && options.arrowPlacement !== _OVERLAY) {
          throw new Error(_ERROR_INVALID_NAV_ARROW_PLACEMENT + options.arrowPlacement);
        }

        // throw error if "arrowVisibility" property set to invalid value
        if (
          options.arrowVisibility !== _VISIBLE &&
          options.arrowVisibility !== _HIDDEN &&
          options.arrowVisibility !== _HOVER &&
          options.arrowVisibility !== _AUTO
        ) {
          throw new Error(_ERROR_INVALID_NAV_ARROW_VISIBILITY + options.arrowVisibility);
        }

        // throw error if "looping" property set to invalid value
        if (options.looping !== _LOOPING_OFF && options.looping !== _LOOPING_PAGE) {
          throw new Error(_ERROR_INVALID_LOOPING + options.looping);
        }

        this.touchEventNamespace = this.eventNamespace + 'Touch';
        this.mouseEventNamespace = this.eventNamespace + 'Mouse';
        this.keyEventNamespace = this.eventNamespace + 'Key';
        this.navArrowHoverableEventNamespace = this.eventNamespace + 'NavArrowHoverable';

        // Make sure currentItem is an object of (id, index)
        options.currentItem = this._convertCurrentItemToObj(options.currentItem);

        if (elem.children().length && options.currentItem) {
          if (
            _isInvalidCurrentItemId(options.currentItem.id, elem) ||
            _isInvalidCurrentItemIndex(options.currentItem.index, elem)
          ) {
            throw new Error(_ERROR_CURRENT_ITEM_NOT_FOUND + JSON.stringify(options.currentItem));
          }
        }

        this._setup(true);

        // update the currentItem object in options.
        this._populateCurrentItemObj(options.currentItem);
        this.option(_CURRENT_ITEM, options.currentItem, {
          _context: { internalSet: true, writeback: true }
        });
      },

      // This method currently runs at create, init, and refresh time (since refresh() is called by _init()).
      /**
       * Refreshes the visual state of the FilmStrip. JET elements require a
       * <code class="prettyprint">refresh()</code> after the DOM is
       * programmatically changed underneath the element.
       *
       * <p>This method does not accept any arguments.
       * @return {void}
       *
       * @expose
       * @memberof oj.ojFilmStrip
       * @instance
       * @ojshortdesc Refreshes the visual state of the FilmStrip.
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * myFilmStrip.refresh();
       */
      refresh: function () {
        // Override of public base class method.
        this._super();

        this._setup(false);
      },

      /**
       * Get the actual number of items shown per logical page.
       * <p>The value returned by this method may be different from the value of the
       * <code class="prettyprint">maxItemsPerPage</code> property.
       * @returns {number} The actual number of items shown per logical page.
       *
       * @expose
       * @memberof oj.ojFilmStrip
       * @instance
       * @see #maxItemsPerPage
       * @ojshortdesc Get the actual number of items shown per logical page.
       *
       * @example <caption>Invoke the <code class="prettyprint">getItemsPerPage</code> method:</caption>
       * var itemsPerPage = myFilmStrip.getItemsPerPage();
       */
      getItemsPerPage: function () {
        return this._itemsPerPage;
      },

      /**
       * Get the PagingModel created and used by the FilmStrip.  The PagingModel
       * provides information about the FilmStrip's logical pages and a way to
       * programmatically change pages.
       * @returns {Object} The instance of the PagingModel created and used by the FilmStrip.
       * @ojsignature {target: "Type",
       *               value: "PagingModel",
       *               for: "returns"}
       *
       * @expose
       * @memberof oj.ojFilmStrip
       * @instance
       * @ojshortdesc Get the PagingModel created and used by the FilmStrip.
       *
       * @example <caption>Invoke the <code class="prettyprint">getPagingModel</code> method:</caption>
       * var pagingModel = myFilmStrip.getPagingModel();
       */
      getPagingModel: function () {
        return this._pagingModel;
      },

      /**
       * Notifies the component that its subtree has been made visible
       * programmatically after the component has been created.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @protected
       * @override
       */
      _notifyCommon: function () {
        // perform a deferred layout
        if (this._needsSetup) {
          this._setup(this._needsSetup[0]);
        } else {
          // explicitly handle a resize in case we don't get a notification when shown
          this._handleResize();
        }
      },
      _NotifyShown: function () {
        this._super();
        this._notifyCommon();
      },

      /**
       * Notifies the component that its subtree has been connected to the document
       * programmatically after the component has been created.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @protected
       * @override
       */
      _NotifyAttached: function () {
        this._super();
        this._notifyCommon();
      },

      // isInit is true for init (create and re-init), false for refresh
      /**
       * Setup the filmStrip.
       * @param {boolean} isInit True if _setup is called from _init(), false
       *        if called from refresh().
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _setup: function (isInit) {
        // Private, not an override (not in base class).
        const self = this;

        // FIX : always create paging model, even if filmstrip is
        // detached or hidden, so that it's available for an assocated paging
        // control
        // (Note: Check whether paging model is null, because if the filmstrip
        // was created while detached or hidden, then when it's attached or
        // shown, _setup will be called again with isInit=true, and we don't
        // want to create a different instance of the paging model.)
        if (isInit && !this._pagingModel) {
          this._pagingModel = new FilmStripPagingModel();
        }

        // FIX : when using jquery find() in the filmStrip, filter out any results from
        // nested filmStrips
        if (isInit && !this._filterNestedFilmStripsFunc) {
          this._filterNestedFilmStripsFunc = function (index, elem) {
            return $(elem).closest('.oj-filmstrip')[0] === self.element[0];
          };
        }

        // if filmStrip is detached or hidden, we can't layout correctly, so
        // defer layout until filmStrip is attached or shown
        if (!this._canCalculateSizes()) {
          // want a true value of isInit to take precedence over a false value
          let oldIsInit = false;
          if (this._needsSetup) {
            oldIsInit = this._needsSetup[0];
          }
          this._needsSetup = [isInit || oldIsInit];
          return;
        }

        // JET-56619: occasionally, initialization may still be needed when refreshing a previously hidden
        // filmstrip
        var needsSetup = false;
        if (this._needsSetup) {
          needsSetup = this._needsSetup[0];
        }
        this._needsSetup = null;

        this._bRTL = this._GetReadingDirection() === 'rtl';
        this._bTouchSupported = DomUtils.isTouchSupported();
        const elem = this.element;
        if (isInit || needsSetup) {
          this._itemsPerPage = 0;
          this._handlePageFunc = function (event) {
            self._handlePage(event);
          };
          this._componentSize = 0;
          this._itemSize = -1;
          // eslint-disable-next-line no-unused-vars
          this._handleTransitionEndFunc = function () {
            self._handleTransitionEnd();
          };
          // eslint-disable-next-line no-unused-vars
          this._handleResizeFunc = function () {
            self._handleResize();
          };

          if (this._bTouchSupported) {
            this._handleTouchStartFunc = function (event) {
              self._handleTouchStart(event);
            };
            this._handleTouchMoveFunc = function (event) {
              self._handleTouchMove(event);
            };
            this._handleTouchEndFunc = function () {
              self._handleTouchEnd();
            };
            this._addTouchListeners();
          }
          this._handleMouseDownFunc = function (event) {
            self._handleMouseDown(event);
          };
          this._handleMouseMoveFunc = function (event) {
            self._handleMouseMove(event);
          };
          this._handleMouseUpFunc = function () {
            self._handleMouseUp();
          };
          this._addMouseListeners();
          this._handleKeyDownFunc = function (event) {
            self._handleKeyDown(event);
          };
          this._addKeyListeners();
        } else {
          this._destroyInternal();
        }

        // notify the original children of the filmStrip that they were detached from
        // the DOM BEFORE actually detaching so that components can save state
        const originalItems = elem.children();

        for (let i = 0; i < originalItems.length; i++) {
          Components.subtreeDetached(originalItems[i]);
        }

        const pagingModel = this._pagingModel;
        if (isInit || needsSetup) {
          // register the page change listener
          pagingModel.on('page', this._handlePageFunc);
        }
        // initialize the paging model with the total number of items
        // FIX : always set total size on paging model in case
        // items have been appended and filmstrip has been refreshed
        pagingModel.setTotalSize(originalItems.length);

        // wrap the original child DOM BEFORE adding the resize listener
        this._wrapChildren();

        this._adjustSizes();

        // notify the original children of the filmStrip that they were attached
        // again after wrapping them
        for (let i = 0; i < originalItems.length; i++) {
          Components.subtreeAttached(originalItems[i]);
        }

        if (originalItems.length === 0) {
          Logger.warn(_WARNING_FILMSTRIP_EMPTY);
        }

        // register resize handler, note it has been previously unregistered
        // in _destroyInternal() if isInit==false (JET-49032)
        DomUtils.addResizeListener(
          elem[0],
          this._handleResizeFunc,
          _RESIZE_LISTENER_COLLAPSE_EVENT_TIMEOUT
        );
      },

      /**
       * Destroy the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @override
       * @protected
       */
      _destroy: function () {
        // Override of protected base class method.
        if (this._bTouchSupported) {
          this._removeTouchListeners();
          this._handleTouchStartFunc = null;
          this._handleTouchMoveFunc = null;
          this._handleTouchEndFunc = null;
        }
        this._removeMouseListeners();
        this._handleMouseDownFunc = null;
        this._handleMouseMoveFunc = null;
        this._handleMouseUpFunc = null;
        this._removeKeyListeners();
        this._handleKeyDownFunc = null;

        this._destroyInternal();
        this._pagingModel.off('page', this._handlePageFunc);
        this._handlePageFunc = null;
        this._pagingModel = null;
        this._handleResizeFunc = null;
        this._handleTransitionEndFunc = null;
        this._filterNestedFilmStripsFunc = null;

        const elem = this.element;
        elem
          .removeClass('oj-filmstrip oj-component ' + _OJ_FILMSTRIP_HOVER)
          .removeAttr('tabindex role')
          .removeAttr(_OJ_FILMSTRIP_LABELLEDBY);

        // remove a generated unique id
        elem.removeUniqueId();

        // remove passive listeners if added
        if (this._IsCustomElement()) {
          elem[0].removeEventListener('touchstart', this._delegatedHandleTouchStartFunc, {
            passive: true
          });
          elem[0].removeEventListener('touchmove', this._delegatedHandleTouchMoveFunc, {
            passive: false
          });
          delete this._delegatedHandleTouchStartFunc;
          delete this._delegatedHandleTouchMoveFunc;
        }

        this._super();
      },

      /**
       * Destroy the internal structure of the filmStrip that will be recreated
       * during a refresh.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _destroyInternal: function () {
        // FIX : clear the flag to handle a deferred resize
        this._deferredHandleResize = false;

        // FIX : resolve busy state when destroying
        this._resolveBusyState();

        const elem = this.element;
        DomUtils.removeResizeListener(elem[0], this._handleResizeFunc);
        // reset item size so it will be recalculated at the next layout
        this._itemSize = -1;
        if (this._queuedHandleResize) {
          clearTimeout(this._queuedHandleResize);
          this._queuedHandleResize = null;
        }

        const originalItems = this._getItems();
        let i;
        // notify the original children of the filmStrip that they were detached from
        // the DOM BEFORE actually detaching so that components can save state
        for (i = 0; i < originalItems.length; i++) {
          Components.subtreeDetached(originalItems[i]);
        }

        this._clearCalculatedSizes();
        const itemContainers = this._getItemContainers();
        // remove logical page containers here instead of in _unwrapChildren because
        // they're added in _adjustSizes, not in _wrapChildren
        itemContainers.unwrap();
        this._unwrapChildren();

        // notify the original children of the filmStrip that they were attached
        // again after unwrapping them
        for (i = 0; i < originalItems.length; i++) {
          Components.subtreeAttached(originalItems[i]);
        }
      },

      /**
       * Set an option on the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @override
       * @protected
       */
      _setOption: function (key, value, flags) {
        // Override of protected base class method.
        // Method name needn't be quoted since is in externs.js.
        const options = this.options;
        let bRefresh = false;
        let newPageIndex = -1;
        const pagingModel = this._pagingModel;
        const oldPageIndex = pagingModel.getPage();

        switch (key) {
          case 'disabled':
            // log warning message when "disabled" property set
            Logger.warn(_WARNING_DISABLED_OPTION);
            break;
          case 'orientation':
            // throw error if "orientation" property set to invalid value
            if (value !== _HORIZONTAL && value !== _VERTICAL) {
              throw new Error(_ERROR_INVALID_ORIENTATION + value);
            }
            bRefresh = options.orientation !== value;
            break;
          case 'maxItemsPerPage':
            bRefresh = options.maxItemsPerPage !== value;
            break;
          case 'arrowPlacement':
            // throw error if "arrowPlacement" property set to invalid value
            if (value !== _ADJACENT && value !== _OVERLAY) {
              throw new Error(_ERROR_INVALID_NAV_ARROW_PLACEMENT + value);
            }
            bRefresh = options.arrowPlacement !== value;
            break;
          case 'arrowVisibility':
            // throw error if "arrowVisibility" property set to invalid value
            if (value !== _VISIBLE && value !== _HIDDEN && value !== _HOVER && value !== _AUTO) {
              throw new Error(_ERROR_INVALID_NAV_ARROW_VISIBILITY + value);
            }
            bRefresh = options.arrowVisibility !== value;
            break;
          case 'looping':
            // throw error if "looping" property set to invalid value
            if (value !== _LOOPING_OFF && value !== _LOOPING_PAGE) {
              throw new Error(_ERROR_INVALID_LOOPING + value);
            }
            bRefresh = options.looping !== value;
            break;
          case _CURRENT_ITEM:
            // Make sure currentItem value is an object of (id, index)
            // eslint-disable-next-line no-param-reassign
            value = this._convertCurrentItemToObj(value);
            this._populateCurrentItemObj(value);
            var currentItem = options.currentItem;
            if (
              currentItem &&
              value &&
              (currentItem.id !== value.id || currentItem.index !== value.index)
            ) {
              newPageIndex = this._findPage(value);
              // throw error if item not found
              if (newPageIndex < 0 || newPageIndex >= pagingModel.getPageCount()) {
                throw new Error(_ERROR_CURRENT_ITEM_NOT_FOUND + JSON.stringify(value));
              }
            }
            break;
          default:
            break;
        }

        this._super(key, value, flags);

        if (key === _CURRENT_ITEM && newPageIndex > -1 && newPageIndex !== oldPageIndex) {
          pagingModel.setPage(newPageIndex);
        }

        if (bRefresh) {
          this._setup(false);
        }
      },

      /**
       * Handle a component resize.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleResize: function () {
        // FIX : if we're handling a page change, defer handling the resize
        if (this._busyStateResolveFunc) {
          this._deferredHandleResize = true;
        } else if (!this._bHandlingResize) {
          // handle the resize if not already handling one
          this._bHandlingResize = true;
          this._adjustSizes(true);
          this._bHandlingResize = false;
        } else if (!this._queuedHandleResize) {
          // if already handling a resize, queue another one
          const self = this;
          this._queuedHandleResize = setTimeout(function () {
            self._queuedHandleResize = null;
            self._handleResize();
          }, 0);
        }
      },

      /**
       * Determine whether the filmStrip is oriented horizontally or vertically.
       * @returns {boolean} True if horizontal, false if vertical.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _isHorizontal: function () {
        const options = this.options;
        return options.orientation !== _VERTICAL;
      },

      /**
       * Determine whether the looping behavior is set to page
       * @returns {boolean} True if looping is set to page, false otherwise.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _isLoopingPage: function () {
        const options = this.options;
        return options.looping === _LOOPING_PAGE;
      },

      /**
       * Get the CSS position attribute to use.
       * @returns {string} CSS position attribute name.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getCssPositionAttr: function () {
        const bHorizontal = this._isHorizontal();
        if (bHorizontal) {
          if (this._bRTL) {
            return 'right';
          }
          return 'left';
        }
        return 'top';
      },

      /**
       * Get the CSS size attribute to use.
       * @returns {string} CSS size attribute name.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getCssSizeAttr: function () {
        const bHorizontal = this._isHorizontal();
        return bHorizontal ? 'width' : 'height';
      },

      /**
       * Determine whether the filmStrip can calculate sizes (when it is
       * attached to the page DOM and not hidden).
       * @returns {boolean} True if sizes can be calculated, false if not.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _canCalculateSizes: function () {
        const div = document.createElement('div');
        const style = div.style;
        // need to set absolute position in order to get correct offsetwidth when
        // flexbox layout is applied; otherwise the offsetwidth becomes 0
        style.position = 'absolute';
        style.width = '10px';
        style.height = '10px';
        const elem = this.element[0];
        elem.appendChild(div); // @HTMLUpdateOK div is created locally at the beginning of this function
        let bCanCalcSizes = false;
        try {
          bCanCalcSizes = div.offsetWidth > 0 && div.offsetHeight > 0;
        } catch (e) {
          // do nothing
        }
        elem.removeChild(div);
        return bCanCalcSizes;
      },

      /**
       * Wrap the original child items of the filmStrip in internal layout structure.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _wrapChildren: function () {
        const elem = this.element;
        const bHorizontal = this._isHorizontal();
        const originalItems = elem.children();

        // prettier-ignore
        originalItems.addClass(_OJ_FILMSTRIP_ITEM).wrap( // @HTMLUpdateOK
          `<div class="${_OJ_FILMSTRIP_CONTAINER} ${_OJ_FILMSTRIP_ITEM_CONTAINER}"></div>`
        );

        // need to initially specify the position on the pagesWrapper so that we can
        // always get the value later
        const cssAttr = this._getCssPositionAttr();
        // prettier-ignore
        const pagesWrapper = elem
          .children()
          .wrapAll( // @HTMLUpdateOK
            `<div class="${_OJ_FILMSTRIP_CONTAINER} ${_OJ_FILMSTRIP_PAGES_CONTAINER}"></div>`
          )
          .parent()
          .css(cssAttr, '0px');
        this._pagesWrapper = pagesWrapper;

        const options = this.options;
        if (options.arrowVisibility !== _HIDDEN && options.arrowPlacement === _ADJACENT) {
          // FIX : add the oj-filmstrip-container class to the content
          // container so that it is a flexbox layout
          // prettier-ignore
          this._contentWrapper = pagesWrapper
            .wrap( // @HTMLUpdateOK
              `<div class="${_OJ_FILMSTRIP_CONTAINER} oj-filmstrip-content-container"></div>`
            )
            .parent();
        }

        elem.addClass(_OJ_FILMSTRIP_CONTAINER);
        if (!bHorizontal) {
          elem.addClass(_OJ_FILMSTRIP_VERTICAL);
        }

        // Fix  - ACC: FIF TOUR PAGE DOESN'T DESCRIBE WHAT'S WITHIN THE FILMSTRIP
        // Create a page info element that will contain the current page information for accessibility
        const pageInfoElem = this._createPageInfoElem();
        const elementId = elem.attr('id');
        const pageInfoId = pageInfoElem.attr('id');
        elem.append(pageInfoElem); // @HTMLUpdateOK
        elem.attr(_OJ_FILMSTRIP_LABELLEDBY, `${elementId} ${pageInfoId}`); // @HTMLUpdateOK
        this._pageInfoElem = pageInfoElem;

        // FIX : only need to create nav buttons if the filmstrip
        // is not empty
        if (options.arrowVisibility !== _HIDDEN && originalItems.length > 0) {
          this._prevButton = this._createPrevNavArrow();
          this._nextButton = this._createNextNavArrow();

          if (this._navArrowsShownOnHover()) {
            this._setupNavArrowsHoverable();
          }
        }
      },

      /**
       * Unwrap the internal layout structure around the original child items of the
       * filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _unwrapChildren: function () {
        const elem = this.element;
        const originalItems = this._getItems();

        // unregister elem as hoverable
        this._tearDownNavArrowsHoverable();

        // remove navigation arrow containers
        if (this._prevButton) {
          this._UnregisterChildNode(this._prevButton);
          this._prevButton = null;
        }
        if (this._nextButton) {
          this._UnregisterChildNode(this._nextButton);
          this._nextButton = null;
        }
        const navArrowContainers = elem.children(_PERIOD + _OJ_FILMSTRIP_ARROW_CONTAINER);
        if (navArrowContainers) {
          navArrowContainers.remove();
        }

        if (this._pageInfoElem) {
          this._UnregisterChildNode(this._pageInfoElem);
          this._pageInfoElem.remove();
          this._pageInfoElem = null;
        }

        // the individual page containers that were added in _adjustSizes are not
        // removed here; they are expected to have been removed before calling
        // _unwrapChildren
        originalItems
          .removeClass(_OJ_FILMSTRIP_ITEM) // original children
          .unwrap() // remove item containers
          .unwrap(); // remove pages container
        this._pagesWrapper = null;
        if (this._contentWrapper) {
          originalItems.unwrap(); // remove content container
          this._contentWrapper = null;
        }

        elem.removeClass(`${_OJ_FILMSTRIP_CONTAINER} ${_OJ_FILMSTRIP_VERTICAL}`);
      },

      /**
       * Create the page info element to contain the current page information
       * @returns {jQuery} Page Info jQuery object.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _createPageInfoElem: function () {
        const pageInfoElem = $(document.createElement('div'));
        pageInfoElem.uniqueId();
        pageInfoElem.addClass('oj-helper-hidden-accessible oj-filmstrip-liveregion');
        pageInfoElem.attr({ 'aria-live': 'polite', 'aria-atomic': 'true' });
        return pageInfoElem;
      },

      /**
       * Update the page info element that contains the current page information
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _updatePageInfoElem: function () {
        const pagingModel = this._pagingModel;
        const pageIndex = pagingModel.getPage();
        const pageCount = pagingModel.getPageCount();
        const pageInfo = _escapeHtml(
          this.getTranslatedString('labelAccFilmStrip', {
            pageIndex: pageIndex + 1,
            pageCount: pageCount
          })
        );
        const pageInfoElem = this._pageInfoElem;
        if (pageInfoElem) {
          pageInfoElem.text(pageInfo);
        }
      },

      /**
       * Setup events to only show the navigation arrows when the mouse hovers over
       * the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _setupNavArrowsHoverable: function () {
        // Note: Use oj-filmstrip-hover marker instead of standard oj-hover marker
        // because if we use the standard one, then when it's added to the filmStrip
        // root node, all hoverables inside the filmStrip appear as if the mouse
        // were hovering over them.
        // Note: keep this logic updated if superclass _hoverable method changes.
        const elem = this.element;
        elem
          .on('mouseenter' + this.navArrowHoverableEventNamespace, function (event) {
            if (!$(event.currentTarget).hasClass('oj-disabled')) {
              $(event.currentTarget).addClass(_OJ_FILMSTRIP_HOVER);
            }
          })
          .on('mouseleave' + this.navArrowHoverableEventNamespace, function (event) {
            $(event.currentTarget).removeClass(_OJ_FILMSTRIP_HOVER);
          });
      },

      /**
       * Tear down events to only show the navigation arrows when the mouse hovers
       * over the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _tearDownNavArrowsHoverable: function () {
        const elem = this.element;
        elem.off(this.navArrowHoverableEventNamespace);
      },

      /**
       * Determine whether navigation arrows should only be shown on hover.
       * @returns {boolean} True if nav arrows should only be shown on hover, false
       *          otherwise.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _navArrowsShownOnHover: function () {
        const options = this.options;
        const arrowVisibility = options.arrowVisibility;
        return (
          arrowVisibility === _HOVER ||
          (arrowVisibility === _AUTO && options.arrowPlacement === _OVERLAY)
        );
      },

      /**
       * Determine whether there is a previous logical page.
       * @returns {boolean} True if there is a previous logical page, false otherwise.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _hasPrevPage: function () {
        const pagingModel = this._pagingModel;
        return pagingModel.getPage() > 0;
      },

      /**
       * Determine whether there is a next logical page.
       * @returns {boolean} True if there is a next logical page, false otherwise.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _hasNextPage: function () {
        const pagingModel = this._pagingModel;
        return pagingModel.getPage() < pagingModel.getPageCount() - 1;
      },

      /**
       * Go to the previous logical page.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _prevPage: function () {
        const pagingModel = this._pagingModel;
        if (this._hasPrevPage()) {
          pagingModel.setPage(pagingModel.getPage() - 1);
        } else {
          const pageCount = pagingModel.getPageCount();
          // navigate from first page to last page
          if (this._isLoopingPage() && pageCount > 1) {
            pagingModel.setPage(pageCount - 1, { loopDirection: _LOOPING_DIRECTION_PREV });
          }
        }
      },

      /**
       * Go to the next logical page.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _nextPage: function () {
        const pagingModel = this._pagingModel;
        if (this._hasNextPage()) {
          pagingModel.setPage(pagingModel.getPage() + 1);
        } else {
          const pageCount = pagingModel.getPageCount();
          // navigate from last page to first page
          if (this._isLoopingPage() && pageCount > 1) {
            pagingModel.setPage(0, { loopDirection: _LOOPING_DIRECTION_NEXT });
          }
        }
      },

      /**
       * Determine whether there is a next logical page.
       * @param {boolean} bShow True to show the navigation arrow, false to hide it.
       * @param {jQuery} jqNavArrow Navigation arrow jQuery object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _displayNavigationArrow: function (bShow, jqNavArrow) {
        const options = this.options;
        const navArrowPlacement = options.arrowPlacement;
        if (navArrowPlacement === _ADJACENT) {
          jqNavArrow.css('visibility', bShow ? '' : _HIDDEN);
        } else {
          jqNavArrow.parent().css('display', bShow ? '' : _NONE);
        }
      },

      /**
       * Update whether the navigation arrows are shown.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _updateNavigationArrowsDisplay: function () {
        const options = this.options;
        const navArrowVisibility = options.arrowVisibility;
        if (navArrowVisibility !== _HIDDEN) {
          const pagingModel = this._pagingModel;
          const pageIndex = pagingModel.getPage();
          const pageCount = pagingModel.getPageCount();
          const bLooping = this._isLoopingPage() && pageCount > 1;
          this._displayNavigationArrow(bLooping || pageIndex !== 0, this._prevButton);
          this._displayNavigationArrow(bLooping || pageIndex !== pageCount - 1, this._nextButton);
        }
      },

      /**
       * Create the previous navigation arrow.
       * @returns {jQuery} Navigation arrow jQuery object.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _createPrevNavArrow: function () {
        const elem = this.element;
        const bHorizontal = this._isHorizontal();
        const locationMarker = bHorizontal ? _OJ_START : _OJ_TOP;
        const container = this._createNavigationArrowContainer(locationMarker);

        const options = this.options;
        const navArrowPlacement = options.arrowPlacement;

        // need to append prev button when overlay so that it is in front of the
        // filmstrip items in z-order
        if (navArrowPlacement === _OVERLAY) {
          elem.append(container); // @HTMLUpdateOK
        } else {
          elem.prepend(container); // @HTMLUpdateOK
        }

        const label = _escapeHtml(this.getTranslatedString('labelAccArrowPreviousPage'));
        const tooltip = _escapeHtml(this.getTranslatedString('tipArrowPreviousPage'));
        const navArrow = this._createNavigationArrow(container, locationMarker, label, tooltip);
        const self = this;
        navArrow.on('click', function () {
          self._prevPage();
        });

        return navArrow;
      },

      /**
       * Create the next navigation arrow.
       * @returns {jQuery} Navigation arrow jQuery object.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _createNextNavArrow: function () {
        const elem = this.element;
        const bHorizontal = this._isHorizontal();
        const locationMarker = bHorizontal ? _OJ_END : _OJ_BOTTOM;
        const container = this._createNavigationArrowContainer(locationMarker);
        elem.append(container); // @HTMLUpdateOK

        const label = _escapeHtml(this.getTranslatedString('labelAccArrowNextPage'));
        const tooltip = _escapeHtml(this.getTranslatedString('tipArrowNextPage'));
        const navArrow = this._createNavigationArrow(container, locationMarker, label, tooltip);
        const self = this;
        navArrow.on('click', function () {
          self._nextPage();
        });

        return navArrow;
      },

      /**
       * Create the container around a navigation arrow.
       * @param {string} locationMarker Marker class for the location of the
       *        navigation arrow: oj-top, oj-bottom, oj-start, or oj-end.
       * @returns {jQuery} jQuery object for the container around a navigation arrow.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _createNavigationArrowContainer: function (locationMarker) {
        const container = $(document.createElement('div'));
        container.addClass(_OJ_FILMSTRIP_ARROW_CONTAINER + ' ' + locationMarker);
        const options = this.options;
        const navArrowPlacement = options.arrowPlacement;
        if (navArrowPlacement === _OVERLAY) {
          container.addClass('oj-filmstrip-arrow-container-overlay');

          if (this._navArrowsShownOnHover()) {
            container.addClass(_OJ_FILMSTRIP_ARROW_TRANSITION);
          }
        }
        return container;
      },

      /**
       * Create a navigation arrow.
       * @param {jQuery} parentElem Parent DOM element of the navigation arrow.
       * @param {string} locationMarker Marker class for the location of the
       *        navigation arrow: oj-top, oj-bottom, oj-start, or oj-end.
       * @param {string} label Accessible label for the navigation arrow.
       * @param {string} tooltip Tooltip for the navigation arrow.
       * @returns {jQuery} Navigation arrow jQuery object.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _createNavigationArrow: function (parentElem, locationMarker, label, tooltip) {
        const str = `<div class='${_OJ_FILMSTRIP_ARROW} oj-default oj-enabled ${locationMarker}' role='button' tabindex='-1'><span class='oj-filmstrip-arrow-icon ${locationMarker} oj-component-icon'></span></div>`;

        parentElem.append(str); // @HTMLUpdateOK
        const arrowElem = parentElem.children(_PERIOD + _OJ_FILMSTRIP_ARROW).eq(0);
        arrowElem.uniqueId();
        const arrowId = arrowElem.attr('id');
        if (label) {
          arrowElem.attr('aria-label', label);
        }
        if (tooltip) {
          arrowElem.attr('title', tooltip);
        }
        // Fix  - ACC: FIF TOUR PAGE DOESN'T DESCRIBE WHAT'S WITHIN THE FILMSTRIP
        const pageInfoElem = this._pageInfoElem;
        const pageInfoId = pageInfoElem.attr('id');
        arrowElem.attr(_OJ_FILMSTRIP_LABELLEDBY, `${pageInfoId} ${arrowId}`); // @HTMLUpdateOK

        //  - filmstrip: next/previous oj-hover colors doesn't go away in touch device
        this._AddHoverable(arrowElem);
        this._AddActiveable(arrowElem);

        const options = this.options;
        const navArrowPlacement = options.arrowPlacement;
        if (navArrowPlacement === _ADJACENT) {
          if (this._navArrowsShownOnHover()) {
            arrowElem.addClass(_OJ_FILMSTRIP_ARROW_TRANSITION);
          }
        }

        return arrowElem;
      },

      /**
       * Get the containers around the original child items.
       * @returns {jQuery} The containers around the original child items.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getItemContainers: function () {
        const pagesWrapper = this._pagesWrapper;
        return pagesWrapper
          .find(_PERIOD + _OJ_FILMSTRIP_ITEM_CONTAINER)
          .filter(this._filterNestedFilmStripsFunc);
      },

      /**
       * Get the original child items.
       * @returns {jQuery} The original child items.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getItems: function () {
        const pagesWrapper = this._pagesWrapper;
        return pagesWrapper
          .find(_PERIOD + _OJ_FILMSTRIP_ITEM)
          .filter(this._filterNestedFilmStripsFunc);
      },

      /**
       * Get the logical page containers.
       * @returns {jQuery} The logical page containers.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getPages: function () {
        const pagesWrapper = this._pagesWrapper;
        return pagesWrapper.children(_PERIOD + _OJ_FILMSTRIP_PAGE);
      },

      /**
       * Clear the calculated sizes set on the internal layout DOM structure.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _clearCalculatedSizes: function () {
        const pagesWrapper = this._pagesWrapper;
        const pages = this._getPages();
        pages.css(_FLEX_BASIS, _EMPTY_STRING).css(_WEBKIT_FLEX_BASIS, _EMPTY_STRING);
        const items = this._getItemContainers();
        items.css(_FLEX_BASIS, _EMPTY_STRING).css(_WEBKIT_FLEX_BASIS, _EMPTY_STRING);
        pagesWrapper.css(this._getCssSizeAttr(), _EMPTY_STRING);
      },

      /**
       * Calculate sizes and set them on the internal layout DOM structure.
       * @param {boolean} bNotifyAttach True to notify children when they're
       *        attached to/detached from the DOM, false to not notify them (when
       *        the notification will happen outside of this method).
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _adjustSizes: function (bNotifyAttach) {
        // clear previously calculated values before recalculating
        this._clearCalculatedSizes();

        const options = this.options;
        const bHorizontal = this._isHorizontal();
        let itemsPerPage = options.maxItemsPerPage;
        const bCalcItemsPerPage = itemsPerPage < 1;
        const elem = this.element;

        const itemContainers = this._getItemContainers();
        // if we haven't saved the item size yet, do it now
        if (this._itemSize < 0) {
          const items = this._getItems();
          if (items.length) {
            // use the size of the item specified in the options
            const optionItemIndex = this._getItemIndex(options.currentItem);

            let optionItemContainer;
            if (optionItemIndex > -1 && itemContainers[optionItemIndex]) {
              optionItemContainer = $(itemContainers[optionItemIndex]);
            } else {
              // if size can't be determined from the selected try to use the first one
              optionItemContainer = $(itemContainers[0]);
            }

            // unhide the item, in case the app has initially hidden it
            const optionItem = optionItemContainer.children(_PERIOD + _OJ_FILMSTRIP_ITEM);
            optionItem.css(_DISPLAY, _EMPTY_STRING);
            // notify the item that it's being shown
            Components.subtreeShown(optionItem[0]);

            this._itemSize = bHorizontal ? optionItemContainer.width() : optionItemContainer.height();
          }
        }

        // get component size after itemSize, in case item needed to be unhidden
        let componentSize = bHorizontal ? elem.width() : elem.height();
        if (options.arrowVisibility !== _HIDDEN && options.arrowPlacement === _ADJACENT) {
          const arrowContainers = elem.children(_PERIOD + _OJ_FILMSTRIP_ARROW_CONTAINER);
          const firstArrowContainer = arrowContainers.eq(0);
          const arrowSize = bHorizontal ? firstArrowContainer.width() : firstArrowContainer.height();
          componentSize -= 2 * arrowSize;
        }
        this._componentSize = componentSize;

        // if there are a fixed number of items per page, but the number specified
        // won't fit, then reduce the number to what will fit
        if (!bCalcItemsPerPage) {
          // use min of 1 to prevent browser crash
          const calcFitCount = Math.max(Math.floor(componentSize / this._itemSize), 1);
          if (calcFitCount < itemsPerPage) {
            itemsPerPage = calcFitCount;
          }
        }

        // if calculating fitCount, use min of 1 to prevent browser crash
        const fitCount = bCalcItemsPerPage
          ? Math.max(Math.floor(componentSize / this._itemSize), 1)
          : itemsPerPage;
        const fitItemSize = componentSize / fitCount;
        itemContainers.css(_FLEX_BASIS, fitItemSize + _PX).css(_WEBKIT_FLEX_BASIS, fitItemSize + _PX);

        const newPageCount = Math.ceil(itemContainers.length / fitCount);
        // wrap items in logical page containers
        let pages = this._getPages();
        let bCreatePages = false;
        // need to create logical pages if page layout changed, or if we haven't
        // yet created logical pages
        const pagingModel = this._pagingModel;
        if (
          pagingModel.getPageCount() !== newPageCount ||
          this._itemsPerPage !== fitCount ||
          !pages ||
          pages.length < 1
        ) {
          bCreatePages = true;
          let i;
          if (bNotifyAttach) {
            // notify the original children of the filmStrip that they were detached from
            // the DOM BEFORE actually detaching so that components can save state
            for (i = 0; i < itemContainers.length; i++) {
              Components.subtreeDetached(itemContainers[i]);
            }
          }

          if (pages && pages.length > 0) {
            // remove old logical page containers
            itemContainers.unwrap();
          }

          // create new logical page containers
          for (i = 0; i < itemContainers.length; i += fitCount) {
            const itemsOnPage = itemContainers.slice(i, i + fitCount);
            // initially hide the page container
            // prettier-ignore
            itemsOnPage
              .wrapAll( // @HTMLUpdateOK
                `<div class="${_OJ_FILMSTRIP_CONTAINER} ${_OJ_FILMSTRIP_PAGE}" ${_ARIA_HIDDEN}="true"></div>`
              )
              .parent()
              .css('display', _NONE);
          }

          if (bNotifyAttach) {
            // notify the original children of the filmStrip that they were attached
            // again after wrapping them
            for (i = 0; i < itemContainers.length; i++) {
              Components.subtreeAttached(itemContainers[i]);
            }
          }
        }
        // always need to update size of each page, even if page count doesn't change
        pages = this._getPages();
        pages.css(_FLEX_BASIS, componentSize + _PX).css(_WEBKIT_FLEX_BASIS, componentSize + _PX);

        // always need to update the pages container size
        const pagesWrapper = this._pagesWrapper;
        const contentWrapper = this._contentWrapper;
        // only show a single page at a time
        pagesWrapper.css(this._getCssSizeAttr(), componentSize);
        if (contentWrapper) {
          contentWrapper.css(this._getCssSizeAttr(), componentSize);
        }

        if (itemContainers.length) {
          let newPageIndex = 0;
          if (options.currentItem) {
            newPageIndex = this._findTargetPage(options.currentItem, fitCount);
          }

          if (
            newPageIndex > -1 &&
            (pagingModel.getPageCount() !== newPageCount ||
              this._itemsPerPage !== fitCount ||
              pagingModel.getPage() !== newPageIndex)
          ) {
            pagingModel.setPage(newPageIndex, { pageSize: fitCount });
          } else if (bCreatePages) {
            // if the page layout didn't change, but we recreated the logical page
            // containers, then simply go to the current logical page to make sure that
            // pages and items are hidden or shown as appropriate
            const currPage = pagingModel.getPage();
            this._handlePage({ previousPage: currPage, page: currPage });
          }
        }
      },

      /**
       * Handle a 'page' event from the PagingModel.
       * @param {Object} event Event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handlePage: function (event) {
        const pageIndex = event.page;
        const loopDirection = event.loopDirection;
        const prevPageIndex = event.previousPage;
        const pagesWrapper = this._pagesWrapper;
        const pages = this._getPages();
        const pagingModel = this._pagingModel;
        const pageSize = pagingModel.getPageSize();
        const pageCount = pagingModel.getPageCount();
        const bImmediate =
          prevPageIndex < 0 || prevPageIndex === pageIndex || this._itemsPerPage !== pageSize;
        const bLooping = this._isLoopingPage();
        // update _itemsPerPage AFTER using it to initialize bImmediate above
        this._itemsPerPage = pageSize;

        // get the old page, if there is one
        let oldPage = null;
        if (!bImmediate) {
          oldPage = $(pages[prevPageIndex]);
        }

        const cssAttr = this._getCssPositionAttr();

        // unhide the new page
        const newPage = $(pages[pageIndex]);
        const bPageHidden = newPage.is(_HIDDEN_SELECTOR);
        if (bPageHidden) {
          this._unhidePage(newPage);
        }
        // defer the scroll if we're dragging so that we can animate it
        let bDeferScroll = this._bDragInit;
        let bNext;
        if (prevPageIndex > -1 && !bImmediate) {
          bNext = pageIndex > prevPageIndex;
          // if looping is enabled, continue in the direction of the navigation
          if (bLooping && loopDirection) {
            bNext = loopDirection === _LOOPING_DIRECTION_NEXT;
          }

          // check if navigating from first page to last page or from last page to first page
          const bFirstToLast = bLooping && !bNext && pageCount > 1 && prevPageIndex === 0;
          const bLastToFirst = bLooping && bNext && pageCount > 1 && prevPageIndex === pageCount - 1;

          bDeferScroll = true;
          // set size of pages wrapper to show two pages at a time because both of
          // them will temporarily be visible
          pagesWrapper.css(this._getCssSizeAttr(), 2 * this._componentSize);
          // if going to the previous page, initially scroll to show the current page
          // because the previous page will be at the current scroll position
          if (!bNext) {
            // only adjust scroll if the page was hidden (in the case of dragging,
            // the page will already be unhidden and scrolled correctly)
            if (bPageHidden) {
              pagesWrapper.css(cssAttr, -this._componentSize + _PX);
            }
          }

          // set initial transition states on the pages
          if (bNext) {
            if (oldPage) {
              oldPage.addClass(_OJ_FILMSTRIP_TRANSITION_NEXT_OLDPAGE_FROM);
            }
            newPage.addClass(_OJ_FILMSTRIP_TRANSITION_NEXT_NEWPAGE_FROM);
            if (bLastToFirst) {
              newPage.addClass(_OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_LASTPAGE);
            }
          } else {
            if (oldPage) {
              oldPage.addClass(_OJ_FILMSTRIP_TRANSITION_PREV_OLDPAGE_FROM);
            }
            newPage.addClass(_OJ_FILMSTRIP_TRANSITION_PREV_NEWPAGE_FROM);
            if (bFirstToLast) {
              newPage.addClass(_OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_FIRSTPAGE);
            }
          }
        }

        // FIX : add busy state before animating a scroll
        this._busyStateResolveFunc = this._addBusyState('scrolling');

        if (bDeferScroll) {
          const self = this;
          const bDragInit = this._bDragInit;
          // if bouncing back because a drag scroll didn't cross the threshold,
          // add the transition class before the timeout because the transforms
          // are removed and reapplied in the timeout
          if (bDragInit && prevPageIndex < 0) {
            const visiblePages = pages.filter(_VISIBLE_SELECTOR);
            visiblePages.addClass(_OJ_FILMSTRIP_TRANSITION);
          }
          // FIX : In Safari on Mac OS X, sometimes when changing pages
          // the new page appears hidden until after the transition.  It seems to be
          // a timing issue where the new page has been made visible in the DOM, but
          // Safari hasn't processed that change before the transition starts.
          // Changing the timeout delay from 0 to 25 seems to help.
          setTimeout(function () {
            self._finishHandlePage(pageIndex, prevPageIndex, bNext, bImmediate, bDragInit);
          }, 25);
        } else {
          this._finishHandlePage(pageIndex, prevPageIndex, bNext, bImmediate);
        }
      },

      /**
       * Finish handling a 'page' event from the PagingModel.
       * @param {number} pageIndex 0-based page index to go to.
       * @param {number} prevPageIndex 0-based old page index.
       * @param {boolean} bNext True if the navigation direction is next.
       * @param {boolean} bImmediate True to change pages immediately with no
       *        transition, false to transition them over time.
       * @param {boolean} bDragInit True if we're currently drag scrolling, false
       *        otherwise.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _finishHandlePage: function (pageIndex, prevPageIndex, bNext, bImmediate, bDragInit) {
        const pagesWrapper = this._pagesWrapper;
        if (!bImmediate) {
          this._bPageChangeTransition = true;
          pagesWrapper.on(
            `transitionend${this.eventNamespace} webkitTransitionEnd${this.eventNamespace}`,
            this._handleTransitionEndFunc
          );
        }

        if (bImmediate) {
          this._handleTransitionEnd();
        } else {
          const pages = this._getPages();
          // if we're currently drag scrolling, remove the transforms that we used
          // to scroll while we were under the drag threshold
          if (bDragInit) {
            _removeTransform(pages);
          }

          // changing pages
          if (prevPageIndex > -1) {
            // remove initial transition states and set destination states, and
            // transition between them
            const oldPage = $(pages[prevPageIndex]);
            const newPage = $(pages[pageIndex]);
            oldPage.addClass(_OJ_FILMSTRIP_TRANSITION);
            newPage.addClass(_OJ_FILMSTRIP_TRANSITION);
            if (bNext) {
              oldPage.removeClass(_OJ_FILMSTRIP_TRANSITION_NEXT_OLDPAGE_FROM);
              newPage.removeClass(_OJ_FILMSTRIP_TRANSITION_NEXT_NEWPAGE_FROM);
              oldPage.addClass(_OJ_FILMSTRIP_TRANSITION_NEXT_OLDPAGE_TO);
              newPage.addClass(_OJ_FILMSTRIP_TRANSITION_NEXT_NEWPAGE_TO);
            } else {
              oldPage.removeClass(_OJ_FILMSTRIP_TRANSITION_PREV_OLDPAGE_FROM);
              newPage.removeClass(_OJ_FILMSTRIP_TRANSITION_PREV_NEWPAGE_FROM);
              oldPage.addClass(_OJ_FILMSTRIP_TRANSITION_PREV_OLDPAGE_TO);
              newPage.addClass(_OJ_FILMSTRIP_TRANSITION_PREV_NEWPAGE_TO);
            }
          } else if (bDragInit) {
            // bouncing back to current page after drag scrolling under the threshold
            const visiblePages = pages.filter(_VISIBLE_SELECTOR);
            _applyTransform(visiblePages, 'translate3d(0, 0, 0)');
          }
        }
      },

      /**
       * Handle the end of a page change transition.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleTransitionEnd: function () {
        this._bPageChangeTransition = false;
        const pagesWrapper = this._pagesWrapper;
        const cssAttr = this._getCssPositionAttr();
        pagesWrapper
          .off(this.eventNamespace)
          .css(this._getCssSizeAttr(), this._componentSize)
          .css(cssAttr, '0px');

        // if the filmStrip contains the focus element, we may need to focus a new
        // element if the old one is on a page that's being hidden
        let focusElem = null;
        if (
          FocusUtils.containsFocus(pagesWrapper[0]) ||
          (this._nextButton && FocusUtils.containsFocus(this._nextButton[0])) ||
          (this._prevButton && FocusUtils.containsFocus(this._prevButton[0]))
        ) {
          focusElem = document.activeElement;
        }

        const pagingModel = this._pagingModel;
        const pageIndex = pagingModel.getPage();

        // hide all pages except for current one
        const pages = this._getPages();
        for (let i = 0; i < pages.length; i++) {
          if (i !== pageIndex) {
            this._hidePage($(pages[i]));
          }
        }
        // remove transition classes
        pages.removeClass(
          _OJ_FILMSTRIP_TRANSITION +
            ' ' +
            _OJ_FILMSTRIP_TRANSITION_NEXT_OLDPAGE_TO +
            ' ' +
            _OJ_FILMSTRIP_TRANSITION_NEXT_NEWPAGE_TO +
            ' ' +
            _OJ_FILMSTRIP_TRANSITION_PREV_OLDPAGE_TO +
            ' ' +
            _OJ_FILMSTRIP_TRANSITION_PREV_NEWPAGE_TO +
            ' ' +
            _OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_FIRSTPAGE +
            ' ' +
            _OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_LASTPAGE
        );
        // remove transforms left over from drag scrolling
        _removeTransform(pages);

        // update display of the navigation arrows
        this._updateNavigationArrowsDisplay();

        // if the old focus element is being hidden, transfer focus to something visible
        if (focusElem && $(focusElem).is(_HIDDEN_SELECTOR)) {
          const elem = this.element;
          // focus an element in the new logical page if possible, otherwise focus
          // the filmStrip itself
          const firstTabStop = FocusUtils.getFirstTabStop(pages[pageIndex]);
          if (firstTabStop) {
            FocusUtils.focusElement(firstTabStop);
          } else {
            FocusUtils.focusElement(elem[0]);
          }
        }

        // update currentItem property if it's not on the current page
        const options = this.options;
        const currItemPage = this._findPage(options.currentItem);
        if (currItemPage !== pageIndex) {
          const newFirstItem = this._getFirstItemOnPage(pageIndex);
          // FIX : only update currentItem property if the filmstrip is not empty
          if (newFirstItem) {
            this.option(_CURRENT_ITEM, newFirstItem, { _context: { writeback: true } });
          }
        }

        // FIX : if we've deferred handling a resize during a page change, handle it now
        if (this._deferredHandleResize) {
          this._deferredHandleResize = false;

          this._handleResize();
        }

        // Fix  - ACC: FIF TOUR PAGE DOESN'T DESCRIBE WHAT'S WITHIN THE FILMSTRIP
        this._updatePageInfoElem();
        // FIX : resolve busy state after animating a scroll
        this._resolveBusyState();
      },

      /**
       * Get the 0-based index of the specified item.
       * @param {Object} item The item object.
       * @returns {number} The 0-based index of the specified item, or -1 if not found.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getItemIndex: function (item) {
        let itemIndex = -1;
        if (item) {
          const items = this._getItems();
          // If the item contains both id and index, item id takes precedence.
          if (item.id && DomUtils.isValidIdentifier(item.id)) {
            for (let i = 0; i < items.length; i++) {
              const itemElem = items[i];
              const itemId = itemElem.id;
              if (itemId && itemId.length > 0 && itemId === item.id) {
                itemIndex = i;
                break;
              }
            }
          } else if (item.index != null && item.index >= 0 && item.index < items.length) {
            itemIndex = item.index;
          }
        }
        return itemIndex;
      },

      /**
       * Convert any 0-based numeric item index or string item id to an item object of (id, index).
       * @param {(string|number|Object)} item String item id or numeric item index or an item object of (id, index).
       * @returns {Object} The item object of (id, index).
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _convertCurrentItemToObj: function (item) {
        let itemObj = null;
        if (typeof item === 'object') {
          // copy it to prevent any pollution from other possible attributes
          itemObj = {
            index: item.index,
            id: item.id
          };
        } else if (typeof item === 'number') {
          itemObj = { index: item };
        } else if (typeof item === 'string') {
          itemObj = { id: item };
        }
        return itemObj;
      },

      /**
       * Populates the item object with valid id and index
       * @param {Object} item The item object to populate.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _populateCurrentItemObj: function (item) {
        if (item && this._pagingModel.getPage() >= 0) {
          const index = this._getItemIndex(item);
          // eslint-disable-next-line no-param-reassign
          item.index = index;
          if (item.id == null && index > -1) {
            const items = this._getItems();
            // eslint-disable-next-line no-param-reassign
            item.id = items[index].id;
          }
        }
      },

      /**
       * Find the logical page containing the specified item.
       * @param {Object} item The item object.
       * @param {?number} itemsPerPage The number of items on each logical page.
       * @returns {number} The 0-based index of the logical page containing the item,
       *          or -1 if not found.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _findPage: function (item, itemsPerPage) {
        const itemIndex = this._getItemIndex(item);
        let pageIndex = -1;
        if (itemIndex > -1) {
          if (itemsPerPage === undefined) {
            // eslint-disable-next-line no-param-reassign
            itemsPerPage = this._itemsPerPage;
          }
          pageIndex = Math.floor(itemIndex / itemsPerPage);
        }
        return pageIndex;
      },

      /**
       * Find the logical page containing the specified item.
       * If the item no longer exists, try to find the closest page.
       * @param {Object} item The item object.
       * @param {?number} itemsPerPage The number of items on each logical page.
       * @returns {number} The 0-based index of the logical page containing the item,
       *          or -1 if not found.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _findTargetPage: function (item, itemsPerPage) {
        let pageIndex = this._findPage(item, itemsPerPage);
        if (pageIndex < 0) {
          const items = this._getItems();
          if (items.length > 0 && item && item.index != null && item.index >= items.length) {
            if (itemsPerPage === undefined) {
              // eslint-disable-next-line no-param-reassign
              itemsPerPage = this._itemsPerPage;
            }
            pageIndex = Math.floor((items.length - 1) / itemsPerPage);
          }
        }
        return pageIndex;
      },

      /**
       * Get the first item on the specified logical page.
       * @param {number} pageIndex 0-based index of the logical page.
       * @param {?number} pageCount Number of logical pages.
       * @param {?number} itemsPerPage Number of items on each logical page.
       * @returns {Object} The first item object.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _getFirstItemOnPage: function (pageIndex, pageCount, itemsPerPage) {
        const pagingModel = this._pagingModel;
        if (pageCount === undefined) {
          // eslint-disable-next-line no-param-reassign
          pageCount = pagingModel.getPageCount();
        }
        if (pageIndex >= 0 && pageIndex < pageCount) {
          const items = this._getItems();
          if (itemsPerPage === undefined) {
            // eslint-disable-next-line no-param-reassign
            itemsPerPage = this._itemsPerPage;
          }
          const itemIndex = pageIndex * itemsPerPage;
          if (itemIndex < items.length) {
            const firstItemOnPage = items[itemIndex];
            const firstId = firstItemOnPage.id;
            return { id: firstId, index: itemIndex };
          }
        }
        return null;
      },

      /**
       * Hide the logical page.
       * @param {jQuery} page Page to hide.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _hidePage: function (page) {
        // notify the page that it's being hidden BEFORE actually hiding it so that
        // components can save state
        Components.subtreeHidden(page[0]);

        page.css(_DISPLAY, _NONE).attr(_ARIA_HIDDEN, 'true'); // @HTMLUpdateOK

        // hide the items explicitly; unhiding will unhide them explicitly
        const items = page
          .find(_PERIOD + _OJ_FILMSTRIP_ITEM)
          .filter(this._filterNestedFilmStripsFunc);
        items.css(_DISPLAY, _NONE);
      },

      /**
       * Unhide the logical page.
       * @param {jQuery} page Page to unhide.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _unhidePage: function (page) {
        page.css(_DISPLAY, _EMPTY_STRING).removeAttr(_ARIA_HIDDEN);

        // unhide the items explicitly because the app may have initially hidden them
        const items = page
          .find(_PERIOD + _OJ_FILMSTRIP_ITEM)
          .filter(this._filterNestedFilmStripsFunc);
        items.css(_DISPLAY, _EMPTY_STRING);

        // notify the page that it was shown
        Components.subtreeShown(page[0]);
      },

      /**
       * Add key listeners on the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _addKeyListeners: function () {
        const elem = this.element;
        elem.on(`keydown${this.keyEventNamespace}`, this._handleKeyDownFunc);
      },

      /**
       * Remove key listeners from the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _removeKeyListeners: function () {
        const elem = this.element;
        elem.off(this.keyEventNamespace);
      },

      /**
       * Add mouse listeners on the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _addMouseListeners: function () {
        const elem = this.element;
        elem
          .on(`mousedown${this.mouseEventNamespace}`, this._handleMouseDownFunc)
          .on(`mousemove${this.mouseEventNamespace}`, this._handleMouseMoveFunc)
          .on(`mouseup${this.mouseEventNamespace}`, this._handleMouseUpFunc);
      },

      /**
       * Remove mouse listeners from the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _removeMouseListeners: function () {
        const elem = this.element;
        elem.off(this.mouseEventNamespace);
      },

      /**
       * Add touch listeners on the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _addTouchListeners: function () {
        const elem = this.element;
        if (this._IsCustomElement()) {
          const createDelegatedListener = function (listener) {
            return function (event) {
              listener($.Event(event));
            };
          };
          this._delegatedHandleTouchStartFunc = createDelegatedListener(this._handleTouchStartFunc);
          this._delegatedHandleTouchMoveFunc = createDelegatedListener(this._handleTouchMoveFunc);
          elem[0].addEventListener('touchstart', this._delegatedHandleTouchStartFunc, {
            passive: true
          });
          elem[0].addEventListener('touchmove', this._delegatedHandleTouchMoveFunc, {
            passive: false
          });
          elem
            .on(`touchend${this.touchEventNamespace}`, this._handleTouchEndFunc)
            .on(`touchcancel${this.touchEventNamespace}`, this._handleTouchEndFunc);
        } else {
          elem
            .on(`touchstart${this.touchEventNamespace}`, this._handleTouchStartFunc)
            .on(`touchmove${this.touchEventNamespace}`, this._handleTouchMoveFunc)
            .on(`touchend${this.touchEventNamespace}`, this._handleTouchEndFunc)
            .on(`touchcancel${this.touchEventNamespace}`, this._handleTouchEndFunc);
        }
      },

      /**
       * Remove touch listeners from the filmStrip.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _removeTouchListeners: function () {
        const elem = this.element;
        elem.off(this.touchEventNamespace);
      },

      /**
       * Handle a keydown event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleKeyDown: function (event) {
        // ignore the event unless filmstrip is the target
        if (event.target !== this.element[0]) {
          return;
        }
        const pagingModel = this._pagingModel;
        const pageIndex = pagingModel.getPage();
        const pageCount = pagingModel.getPageCount();
        let newPageIndex;
        switch (event.keyCode) {
          case $.ui.keyCode.RIGHT:
            if (this._bRTL) {
              newPageIndex = pageIndex - 1;
            } else {
              newPageIndex = pageIndex + 1;
            }
            break;
          case $.ui.keyCode.LEFT:
            if (this._bRTL) {
              newPageIndex = pageIndex + 1;
            } else {
              newPageIndex = pageIndex - 1;
            }
            break;
          case $.ui.keyCode.DOWN:
            newPageIndex = pageIndex + 1;
            break;
          case $.ui.keyCode.UP:
            newPageIndex = pageIndex - 1;
            break;
          case $.ui.keyCode.HOME:
            newPageIndex = 0;
            break;
          case $.ui.keyCode.END:
            newPageIndex = pageCount - 1;
            break;
          default:
            return;
        }

        if (newPageIndex > -1 && newPageIndex < pageCount) {
          pagingModel.setPage(newPageIndex);
        } else if (this._isLoopingPage() && pageCount > 1) {
          const optionsObj = {};
          // navigate from last page to first page
          if (newPageIndex === pageCount) {
            newPageIndex = 0;
            optionsObj.loopDirection = _LOOPING_DIRECTION_NEXT;
          }
          // navigate from first page to last page
          if (newPageIndex === -1) {
            newPageIndex = pageCount - 1;
            optionsObj.loopDirection = _LOOPING_DIRECTION_PREV;
          }
          pagingModel.setPage(newPageIndex, optionsObj);
        }

        event.preventDefault();
      },

      /**
       * Handle a mousedown event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleMouseDown: function (event) {
        const originalEvent = event.originalEvent;
        this._dragScrollStart(originalEvent);
      },

      /**
       * Handle a mousemove event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleMouseMove: function (event) {
        const originalEvent = event.originalEvent;
        this._dragScrollMove(event, originalEvent);
      },

      /**
       * Handle a mouseup event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleMouseUp: function () {
        this._dragScrollEnd();
      },

      /**
       * Handle a touchstart event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleTouchStart: function (event) {
        const originalEvent = event.originalEvent;
        const eventTouches = originalEvent.touches;
        if (eventTouches.length === 1) {
          const firstTouch = eventTouches[0];
          this._dragScrollStart(firstTouch);
        }
      },

      /**
       * Handle a touchmove event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleTouchMove: function (event) {
        const originalEvent = event.originalEvent;
        const eventTouches = originalEvent.touches;
        const firstTouch = eventTouches[0];
        this._dragScrollMove(event, firstTouch);

        // FIX : if the drag scroll was started, prevent the page
        // from scrolling also
        // FIX : do this for touchMove events instead of touchStart so
        // that it doesn't prevent clicks/taps from being detected on nav arrows and
        // item content
        if (this._bTouch || this._scrolledForThisTouch) {
          event.preventDefault();
        }
      },

      /**
       * Handle a touchend event.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _handleTouchEnd: function () {
        this._dragScrollEnd();
      },

      /**
       * Start a drag scroll.
       * @param {Event} coordsObj Object that has pageX and pageY properties.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _dragScrollStart: function (coordsObj) {
        const pagingModel = this._pagingModel;
        if (pagingModel.getPageCount() > 1 && !this._bPageChangeTransition) {
          this._bTouch = true;
          this._bDragInit = false;
          this._bFirstToLast = false;
          this._bLastToFirst = false;

          const bHorizontal = this._isHorizontal();
          this._touchStartCoord = bHorizontal ? coordsObj.pageX : coordsObj.pageY;
          this._touchStartCoord2 = bHorizontal ? coordsObj.pageY : coordsObj.pageX;
        }
      },

      /**
       * Initialize a drag scroll.
       * Called after a drag scroll has started if the drag has passed an initial
       * threshold.
       * @param {Object} coordsObj Object that has pageX and pageY properties.
       * @param {boolean} bFirstToLast true if looping from first page to last page.
       * @param {boolean} bLastToFirst true if looping from last page to first page.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _initDragScroll: function (coordsObj, bFirstToLast, bLastToFirst) {
        // save off some initial information at the start of a swipe
        const bHorizontal = this._isHorizontal();
        this._touchStartCoord = bHorizontal ? coordsObj.pageX : coordsObj.pageY;
        this._touchStartCoord2 = bHorizontal ? coordsObj.pageY : coordsObj.pageX;

        const cssAttr = this._getCssPositionAttr();
        const pagesWrapper = this._pagesWrapper;
        const pagingModel = this._pagingModel;
        const pageIndex = pagingModel.getPage();
        const pageCount = pagingModel.getPageCount();

        // unhide adjacent pages (unhide both because we don't know which way user
        // will scroll)
        const pages = this._getPages();
        let pageCountToShow = 1;

        if (bFirstToLast || bLastToFirst) {
          if (bFirstToLast) {
            // unhide last page
            this._unhidePage($(pages[pageCount - 1]));

            // when unhiding previous page, need to adjust current scroll position
            // to continue showing current page
            pagesWrapper.css(cssAttr, -this._componentSize + _PX);

            // increment number of pages we need to show
            pageCountToShow += 1;

            // display last page as first page
            $(pages[pageCount - 1]).addClass(_OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_FIRSTPAGE);
          }
          if (bLastToFirst) {
            // unhide first page
            this._unhidePage($(pages[0]));

            // increment number of pages we need to show
            pageCountToShow += 1;

            // display first page as last page
            $(pages[0]).addClass(_OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_LASTPAGE);
          }
        } else {
          if (pageIndex > 0) {
            this._unhidePage($(pages[pageIndex - 1]));

            // when unhiding previous page, need to adjust current scroll position
            // to continue showing current page
            pagesWrapper.css(cssAttr, -this._componentSize + _PX);

            // increment number of pages we need to show
            pageCountToShow += 1;
          }
          if (pageIndex < pageCount - 1) {
            this._unhidePage($(pages[pageIndex + 1]));

            // increment number of pages we need to show
            pageCountToShow += 1;
          }
        }

        if (pageCountToShow > 1) {
          pagesWrapper.css(this._getCssSizeAttr(), pageCountToShow * this._componentSize);
        }

        this._touchStartScroll = parseInt(pagesWrapper.css(cssAttr), 10);
      },

      /**
       * Process a move during drag scrolling.
       * @param {Event} event <code class="prettyprint">jQuery</code> event object.
       * @param {Object} coordsObj Object that has pageX and pageY properties.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _dragScrollMove: function (event, coordsObj) {
        // do nothing if we haven't started the scroll
        if (!this._bTouch) {
          return;
        }

        const bHorizontal = this._isHorizontal();
        const touchCoord = bHorizontal ? coordsObj.pageX : coordsObj.pageY;
        const diff = touchCoord - this._touchStartCoord;

        //  - cannot scroll vertically in filmstrip component
        const touchCoord2 = bHorizontal ? coordsObj.pageY : coordsObj.pageX;
        const diff2 = touchCoord2 - this._touchStartCoord2;

        // in non-RTL, if swiping left or up, scroll next; otherwise scroll prev
        // in RTL, if swiping right or up, scroll next; otherwise scroll prev
        const bNext = bHorizontal && this._bRTL ? diff > 0 : diff < 0;
        // determine whether the filmStrip can be scrolled in the direction of the swipe
        const pagingModel = this._pagingModel;
        const pageIndex = pagingModel.getPage();
        const pageCount = pagingModel.getPageCount();
        const bLooping = this._isLoopingPage();

        const bFirstToLast = bLooping && !bNext && pageCount > 1 && pageIndex === 0;
        const bLastToFirst = bLooping && bNext && pageCount > 1 && pageIndex === pageCount - 1;

        if (!this._bDragInit) {
          //  - cannot scroll vertically in filmstrip component
          // If the direction of swipe doesn't align with orientation of filmstrip,
          // don't scroll again for this same swipe
          if (Math.abs(diff2) > Math.abs(diff)) {
            this._bTouch = false;

            // set a flag indicating we don't scroll for this touch event
            this._scrolledForThisTouch = false;
          }

          // only initialize the drag once we've passed the initial threshold
          if (Math.abs(diff) > _DRAG_SCROLL_INIT_THRESHOLD) {
            this._initDragScroll(coordsObj, bFirstToLast, bLastToFirst);
            this._bDragInit = true;
          }
          this._bFirstToLast = bFirstToLast;
          this._bLastToFirst = bLastToFirst;

          // return here even if we just initialized the drag so that we'll start
          // processing the drag move on the next event when we have different mouse
          // coords
          return;
        } else if (bFirstToLast !== this._bFirstToLast || bLastToFirst !== this._bLastToFirst) {
          // if the navigation has changed from first page to last page or from last page to first page,
          // reset the pages, because we need to reposition the pages again
          this._dragScrollResetPages();

          // re-initialize the drag scroll based on the current drag coordinates
          this._initDragScroll(coordsObj, bFirstToLast, bLastToFirst);
          this._bFirstToLast = bFirstToLast;
          this._bLastToFirst = bLastToFirst;
        }

        const canScrollInSwipeDirection =
          (bNext && pageIndex < pagingModel.getPageCount() - 1) || (!bNext && pageIndex > 0);
        // only need to do something if we can scroll in the swipe direction
        // if looping is enabled, continue in the direction of the swipe
        if (canScrollInSwipeDirection || bLooping) {
          // only scroll next/prev if the swipe is longer than the threshold; if it's
          // less, then just drag the items with the swipe
          const elem = this.element[0];
          const threshold = Math.min(
            _DRAG_SCROLL_THRESHOLD * (bHorizontal ? elem.offsetWidth : elem.offsetHeight),
            _DRAG_SCROLL_MAX_THRESHOLD
          );
          const cssAttr = this._getCssPositionAttr();
          const pagesWrapper = this._pagesWrapper;
          const pages = this._getPages();

          // if swiping beyond the threshold, scroll to the next/prev page
          if (Math.abs(diff) >= threshold) {
            let newPageIndex;
            let pageToHide;
            const optionsObj = {};

            if (bFirstToLast || bLastToFirst) {
              if (bFirstToLast) {
                newPageIndex = pageCount - 1;
                // Hide only if more than 2 pages are available
                pageToHide = pageCount > 2 ? 1 : -1;
              } else {
                newPageIndex = 0;
                // Hide only if more than 2 pages are available
                pageToHide = pageCount > 2 ? pageCount - 2 : -1;
              }
              optionsObj.loopDirection = bNext ? _LOOPING_DIRECTION_NEXT : _LOOPING_DIRECTION_PREV;
            } else {
              newPageIndex = bNext ? pageIndex + 1 : pageIndex - 1;
              pageToHide = bNext ? pageIndex - 1 : pageIndex + 1;
            }

            // hide the page that we're not scrolling to
            if (pageToHide > -1 && pageToHide < pagingModel.getPageCount()) {
              this._hidePage($(pages[pageToHide]));
            }

            // when hiding previous page, need to adjust current scroll position
            // to continue showing current page
            if (bNext && pageToHide > -1 && !bLastToFirst) {
              const currScroll = parseInt(pagesWrapper.css(cssAttr), 10);
              pagesWrapper.css(cssAttr, currScroll + this._componentSize + _PX);
            }

            // update size to show two pages instead of three
            pagesWrapper.css(this._getCssSizeAttr(), 2 * this._componentSize);

            // don't scroll again for this same swipe
            this._bTouch = false;

            pagingModel.setPage(newPageIndex, optionsObj);
          } else {
            // if swiping under the threshold, just move the conveyor with the swipe
            const scrollVal = diff;
            const transform = bHorizontal
              ? `translate3d(${scrollVal}px, 0, 0)`
              : `translate3d(0, ${scrollVal}px, 0)`;
            _applyTransform(pages.filter(_VISIBLE_SELECTOR), transform);
          }

          // set a flag indicating we've scrolled for this touch event
          this._scrolledForThisTouch = true;
        }

        // if we've scrolled for this touch event, consume the event
        // so that the page doesn't also scroll
        if (this._scrolledForThisTouch) {
          event.preventDefault();
          event.stopPropagation();
        }
      },

      /**
       * Process the end of a drag scroll.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _dragScrollEnd: function () {
        // if a full page swipe hasn't happened, scroll back to the original position
        if (this._bTouch && this._bDragInit) {
          const pagingModel = this._pagingModel;
          const pageIndex = pagingModel.getPage();
          this._handlePage({ previousPage: pageIndex, page: pageIndex });
        }
        this._bTouch = false;
        this._bDragInit = false;
        this._bFirstToLast = false;
        this._bLastToFirst = false;

        // reset the flag indicating if we've scrolled for this touch event
        this._scrolledForThisTouch = false;
      },

      /**
       * Reset the pages during drag scrolling.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _dragScrollResetPages: function () {
        const pagesWrapper = this._pagesWrapper;
        const cssAttr = this._getCssPositionAttr();
        const pagingModel = this._pagingModel;
        const pageIndex = pagingModel.getPage();
        const pageCount = pagingModel.getPageCount();
        // hide all pages except for current one
        const pages = this._getPages();
        for (let i = 0; i < pages.length; i++) {
          if (i !== pageIndex) {
            this._hidePage($(pages[i]));
          }
        }
        pagesWrapper.css(cssAttr, '0px');
        $(pages[0]).removeClass(_OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_LASTPAGE);
        $(pages[pageCount - 1]).removeClass(_OJ_FILMSTRIP_TRANSITION_DISPLAY_AS_FIRSTPAGE);
      },

      /**
       * Add a busy state to the busy context.
       *
       * @param {string} description Additional information about busy state.
       * @returns {Function} Resolve function called by the registrant when the busy state completes.
       *          The resultant function will throw an error if the busy state is no longer registered.
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _addBusyState: function (description) {
        const element = this.element;
        const context = Context.getContext(element[0]);
        const busyContext = context.getBusyContext();

        const id = element.attr('id');
        const desc = `FilmStrip (id='${id}'): ${description}`;

        const busyStateOptions = { description: desc };
        return busyContext.addBusyState(busyStateOptions);
      },

      /**
       * Resolve an outstanding busy state.
       * @return {void}
       * @memberof oj.ojFilmStrip
       * @instance
       * @private
       */
      _resolveBusyState: function () {
        if (this._busyStateResolveFunc) {
          this._busyStateResolveFunc();
          this._busyStateResolveFunc = null;
        }
      },

      // @inheritdoc
      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element ? this.element[0] : null;
        }

        const subId = locator.subId;
        if (subId === _OJ_FILMSTRIP_START_ARROW) {
          return this.widget()
            .find(_PERIOD + _OJ_FILMSTRIP_ARROW + _PERIOD + _OJ_START)
            .filter(this._filterNestedFilmStripsFunc)[0];
        }
        if (subId === _OJ_FILMSTRIP_END_ARROW) {
          return this.widget()
            .find(_PERIOD + _OJ_FILMSTRIP_ARROW + _PERIOD + _OJ_END)
            .filter(this._filterNestedFilmStripsFunc)[0];
        }
        if (subId === _OJ_FILMSTRIP_TOP_ARROW) {
          return this.widget()
            .find(_PERIOD + _OJ_FILMSTRIP_ARROW + _PERIOD + _OJ_TOP)
            .filter(this._filterNestedFilmStripsFunc)[0];
        }
        if (subId === _OJ_FILMSTRIP_BOTTOM_ARROW) {
          return this.widget()
            .find(_PERIOD + _OJ_FILMSTRIP_ARROW + _PERIOD + _OJ_BOTTOM)
            .filter(this._filterNestedFilmStripsFunc)[0];
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
      },

      // @inheritdoc
      getSubIdByNode: function (node) {
        const startArrow = this.getNodeBySubId({ subId: _OJ_FILMSTRIP_START_ARROW });
        const endArrow = this.getNodeBySubId({ subId: _OJ_FILMSTRIP_END_ARROW });
        const topArrow = this.getNodeBySubId({ subId: _OJ_FILMSTRIP_TOP_ARROW });
        const bottomArrow = this.getNodeBySubId({ subId: _OJ_FILMSTRIP_BOTTOM_ARROW });
        let currentNode = node;
        const elem = this.element[0];
        while (currentNode && currentNode !== elem) {
          if (currentNode === startArrow) {
            return { subId: _OJ_FILMSTRIP_START_ARROW };
          } else if (currentNode === endArrow) {
            return { subId: _OJ_FILMSTRIP_END_ARROW };
          } else if (currentNode === topArrow) {
            return { subId: _OJ_FILMSTRIP_TOP_ARROW };
          } else if (currentNode === bottomArrow) {
            return { subId: _OJ_FILMSTRIP_BOTTOM_ARROW };
          }

          currentNode = currentNode.parentElement;
        }
        return null;
      },

      // @inheritdoc
      _CompareOptionValues: function (option, value1, value2) {
        if (option === 'currentItem') {
          return oj.Object.compareValues(value1, value2);
        }
        return this._super(option, value1, value2);
      }
    }); // end of oj.__registerWidget
  })(); // end of FilmStrip wrapper function

  exports.FilmStripPagingModel = FilmStripPagingModel;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtouchproxy',['jquery', 'ojs/ojcore-base'], function ($, oj) { 'use strict';

  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;

  const _TouchProxy = function (elem) {
    this._init(elem);
  };

  oj._registerLegacyNamespaceProp('_TouchProxy', _TouchProxy);

  /**
   * Initializes the TouchProxy instance
   *
   * @param {Object} elem
   * @private
   */
  _TouchProxy.prototype._init = function (elem) {
    this._elem = elem;

    this._touchHandled = false;
    this._touchMoved = false;

    // add touchListeners
    this._touchStartHandler = $.proxy(this._touchStart, this);
    this._touchEndHandler = $.proxy(this._touchEnd, this);
    this._touchMoveHandler = $.proxy(this._touchMove, this);

    this._elem.on({
      touchend: this._touchEndHandler,
      touchcancel: this._touchEndHandler
    });

    // register touchstart & touchmove with passive option
    this._elem[0].addEventListener('touchstart', this._touchStartHandler, { passive: true });
    this._elem[0].addEventListener('touchmove', this._touchMoveHandler, { passive: false });
  };

  _TouchProxy.prototype._destroy = function () {
    if (this._elem && this._touchStartHandler) {
      this._elem.off({
        touchend: this._touchEndHandler,
        touchcancel: this._touchEndHandler
      });

      // remove touchstart & touchmove registered with passive option
      this._elem[0].removeEventListener('touchstart', this._touchStartHandler, { passive: true });
      this._elem[0].removeEventListener('touchmove', this._touchMoveHandler, { passive: false });

      this._touchStartHandler = undefined;
      this._touchEndHandler = undefined;
      this._touchMoveHandler = undefined;
    }
  };

  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {string} simulatedType The corresponding mouse event
   *
   * @private
   */
  _TouchProxy.prototype._touchHandler = function (event, simulatedType) {
    // Ignore multi-touch events
    if (event.originalEvent.touches.length > 1) {
      return;
    }

    //  - contextmenu issues: presshold should launch the contextmenu on touch devices
    if (event.type !== 'touchstart' && event.type !== 'touchend') {
      event.preventDefault();
    }

    var touch = event.originalEvent.changedTouches[0];
    var simulatedEvent = document.createEvent('MouseEvent');

    // Initialize the simulated mouse event using the touch event's coordinates
    // initMouseEvent(type, canBubble, cancelable, view, clickCount,
    //                screenX, screenY, clientX, clientY, ctrlKey,
    //                altKey, shiftKey, metaKey, button, relatedTarget);
    simulatedEvent.initMouseEvent(
      simulatedType,
      true,
      true,
      window,
      1,
      touch.screenX,
      touch.screenY,
      touch.clientX,
      touch.clientY,
      false,
      false,
      false,
      false,
      0 /* left*/,
      null
    );

    touch.target.dispatchEvent(simulatedEvent);
  };

  /**
   * Handle touchstart events
   * @param {Object} event The element's touchstart event
   *
   * @private
   */
  _TouchProxy.prototype._touchStart = function (event) {
    // Ignore the event if already being handled
    if (this._touchHandled) {
      return;
    }

    // set the touchHandled flag
    this._touchHandled = true;

    // Track movement to determine if interaction was a click
    this._touchMoved = false;

    // touchstart is registered with addEventListener but
    // downstream code expects jQuery event
    // eslint-disable-next-line no-param-reassign
    event = $.Event(event);

    // Simulate the mouseover, mousemove and mousedown events
    this._touchHandler(event, 'mouseover');
    this._touchHandler(event, 'mousemove');
    this._touchHandler(event, 'mousedown');
  };

  /**
   * Handle the touchmove events
   * @param {Object} event The element's touchmove event
   *
   * @private
   */
  _TouchProxy.prototype._touchMove = function (event) {
    // Ignore event if not handled
    if (!this._touchHandled) {
      return;
    }

    // Interaction was not a click
    this._touchMoved = true;

    // touchmove is registered with addEventListener but
    // downstream code expects jQuery event
    // eslint-disable-next-line no-param-reassign
    event = $.Event(event);

    // Simulate the mousemove event
    this._touchHandler(event, 'mousemove');
  };

  /**
   * Handle the touchend events
   * @param {Object} event The element's touchend event
   *
   * @private
   */
  _TouchProxy.prototype._touchEnd = function (event) {
    // Ignore event if not handled
    if (!this._touchHandled) {
      return;
    }

    // Simulate the mouseup and mouseout events
    this._touchHandler(event, 'mouseup');
    this._touchHandler(event, 'mouseout');

    // If the touch interaction did not move, it should trigger a click
    if (!this._touchMoved && event.type === 'touchend') {
      // Simulate the click event
      this._touchHandler(event, 'click');
    }

    // Unset the flag
    this._touchHandled = false;
  };

  _TouchProxy._TOUCH_PROXY_KEY = '_ojTouchProxy';

  _TouchProxy.prototype.touchMoved = function () {
    return this._touchMoved;
  };

  /**
   * Adds touch event listeners
   * @param {Object} elem
   * @ignore
   */
  _TouchProxy.addTouchListeners = function (elem) {
    var jelem = $(elem);
    var proxy = jelem.data(_TouchProxy._TOUCH_PROXY_KEY);
    if (!proxy) {
      proxy = new _TouchProxy(jelem);
      jelem.data(_TouchProxy._TOUCH_PROXY_KEY, proxy);
    }

    return proxy;
  };

  /**
   * Removes touch event listeners
   * @param {Object} elem
   * @ignore
   */
  _TouchProxy.removeTouchListeners = function (elem) {
    var jelem = $(elem);
    var proxy = jelem.data(_TouchProxy._TOUCH_PROXY_KEY);
    if (proxy) {
      proxy._destroy();
      jelem.removeData(_TouchProxy._TOUCH_PROXY_KEY);
    }
  };

});


define('ojs/ojselector',['exports', 'preact/jsx-runtime', 'ojs/ojvcomponent', 'preact', 'ojs/ojdomutils'], function (exports, jsxRuntime, ojvcomponent, preact, DomUtils) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.Selector = class Selector extends preact.Component {
        constructor(props) {
            super(props);
            this._handleFocusin = (event) => {
                this.setState({ focus: true });
            };
            this._handleFocusout = (event) => {
                this.setState({ focus: false });
            };
            this._checkboxListener = (event) => {
                const { selectedKeys, rowKey, selectionMode, indeterminate } = this.props;
                let newSelectedKeys;
                if (selectedKeys != null) {
                    if (event.target.checked) {
                        if (selectionMode === 'multiple') {
                            newSelectedKeys = selectedKeys.add([rowKey]);
                        }
                        else if (selectionMode === 'all') {
                            newSelectedKeys = selectedKeys.addAll();
                        }
                        else if (selectionMode === 'single' && !selectedKeys.has(rowKey)) {
                            newSelectedKeys = selectedKeys.clear().add([rowKey]);
                        }
                    }
                    else {
                        if (selectionMode === 'all') {
                            if (indeterminate) {
                                newSelectedKeys = selectedKeys.addAll();
                            }
                            else {
                                newSelectedKeys = selectedKeys.clear();
                            }
                        }
                        else {
                            newSelectedKeys = selectedKeys.delete([rowKey]);
                        }
                    }
                    this.props.onSelectedKeysChanged?.(newSelectedKeys);
                    this.props.onIndeterminateChanged?.(false);
                }
            };
            this.state = {
                focus: false
            };
        }
        render(props, state) {
            const { rowKey, indeterminate } = props;
            const isSelected = this._isSelected(rowKey);
            let spanClass = 'oj-selector-wrapper oj-component-icon';
            if (indeterminate) {
                spanClass += ' oj-indeterminate';
            }
            else if (isSelected) {
                spanClass += ' oj-selected';
            }
            if (state.focus && !DomUtils.recentPointer()) {
                spanClass += ' oj-focus-highlight';
            }
            const ariaLabelledby = props['aria-labelledby'] || null;
            const ariaLabel = props['aria-label'] || null;
            return (jsxRuntime.jsx(ojvcomponent.Root, { class: "oj-selector", children: jsxRuntime.jsx("span", { class: spanClass, children: jsxRuntime.jsx("input", { type: "checkbox", class: "oj-selectorbox", "data-oj-clickthrough": "disabled", "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, checked: isSelected, onfocusin: this._handleFocusin, onfocusout: this._handleFocusout, onClick: this._checkboxListener }) }) }));
        }
        _isSelected(rowKey) {
            const { selectedKeys, selectionMode } = this.props;
            if (!selectedKeys) {
                return false;
            }
            return selectionMode === 'all' ? selectedKeys.isAddAll() : selectedKeys.has(rowKey);
        }
    };
    exports.Selector.defaultProps = {
        rowKey: null,
        indeterminate: false,
        selectedKeys: null,
        selectionMode: 'multiple'
    };
    exports.Selector._metadata = { "properties": { "rowKey": { "type": "any" }, "indeterminate": { "type": "boolean", "writeback": true }, "selectedKeys": { "type": "object", "writeback": true }, "selectionMode": { "type": "string", "enumValues": ["all", "multiple", "single"] } }, "extension": { "_WRITEBACK_PROPS": ["selectedKeys", "indeterminate"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby"] } };
    exports.Selector = __decorate([
        ojvcomponent.customElement('oj-selector')
    ], exports.Selector);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojtreeview',['require', 'ojs/ojcore-base', 'jquery', 'ojs/ojcontext', 'ojs/ojthemeutils', 'ojs/ojcomponentcore', 'ojs/ojanimation', 'ojs/ojdomutils', 'ojs/ojlogger', 'ojs/ojconfig', 'ojs/ojkeyset', 'ojs/ojselector', 'ojdnd', 'ojs/ojcustomelement-utils', 'ojs/ojdatacollection-common', 'ojs/ojtranslation'], function (require, oj, $, Context, ThemeUtils, ojcomponentcore, ojanimation, DomUtils, Logger, ojconfig, ojkeyset, ojselector, ojdnd, ojcustomelementUtils, DataCollectionUtils, Translations) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = {};
      if (e) {
        Object.keys(e).forEach(function (k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        });
      }
      n['default'] = e;
      return n;
    }
  }

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  class TreeviewSelectionManager {
    constructor(
      rawData,
      attributesMap = { keyAttributes: 'id', childrenAttribute: 'children' },
      createOptimizedKeyMap = (m) => new Map(m),
      createOptimizedKeySet = (s) => new Set(s)
    ) {
      this.data = rawData;
      this.createOptimizedKeyMap = createOptimizedKeyMap;
      this.createOptimizedKeySet = createOptimizedKeySet;
      this.keyAttr = attributesMap.keyAttributes;
      this.childrenAttr = attributesMap.childrenAttribute;

      // Generates Map(parentKey: parentData) and set of all keys from raw data
      const populateParentKeyNodeMap = (data, parentKeyNodeMap, allKeys) => {
        data.forEach((child) => {
          allKeys.add(child[this.keyAttr]);
          if (child[this.childrenAttr] && child[this.childrenAttr].length > 0) {
            parentKeyNodeMap.set(child[this.keyAttr], child);
            populateParentKeyNodeMap(child[this.childrenAttr], parentKeyNodeMap, allKeys);
          }
        });
      };
      this.parentKeyNodeMap = this.createOptimizedKeyMap();
      this.allKeys = this.createOptimizedKeySet();
      populateParentKeyNodeMap(this.data, this.parentKeyNodeMap, this.allKeys);
    }

    // Computes actual selection from given set of keys. Previous keys optional for diffing.
    computeSelection(currentKeySet, previousKeySet = new ojkeyset.KeySetImpl()) {
      // Derive the set of leaves that becomes selected
      const currentKeys = this.normalizeKeySet(currentKeySet);
      const previousKeys = this.normalizeKeySet(previousKeySet);
      const newKeys = currentKeys.delete(previousKeys.values());
      const oldKeys = previousKeys.delete(currentKeys.values());
      const deselectedLeaves = this.reduceToLeaves(oldKeys.values());
      const selectedLeaves = this.createOptimizedKeySet(
        new Set(
          [
            ...[...currentKeys.values()].filter((key) => !this.parentKeyNodeMap.has(key)),
            ...this.reduceToLeaves(newKeys.values())
          ].filter((key) => !deselectedLeaves.has(key))
        )
      );

      // From selected leaves, derive parent selection states
      const actualSelection = {
        selectedLeaves: selectedLeaves,
        selectedParents: this.createOptimizedKeySet(),
        partialParents: this.createOptimizedKeySet()
      };
      this.assignParentSelection(
        { children: this.data },
        { selected: 0, partial: 0 },
        actualSelection
      );

      // Overall selection = selected leaves + selected parents
      actualSelection.selected = this.createOptimizedKeySet([
        ...actualSelection.selectedLeaves.values(),
        ...actualSelection.selectedParents.values()
      ]);

      return {
        selected: new ojkeyset.KeySetImpl(actualSelection.selected),
        selectedLeaves: new ojkeyset.KeySetImpl(actualSelection.selectedLeaves),
        selectedParents: new ojkeyset.KeySetImpl(actualSelection.selectedParents),
        partialParents: new ojkeyset.KeySetImpl(actualSelection.partialParents)
      };
    }

    // Reduces given keys (e.g. containing parent keys) to a set of associated leaf keys
    reduceToLeaves(keys) {
      const getLeafKeys = (node, leafKeys) => {
        const isLeaf = !this.parentKeyNodeMap.has(node[this.keyAttr]);
        if (isLeaf) {
          leafKeys.add(node[this.keyAttr]);
          return;
        }
        node[this.childrenAttr].forEach((child) => getLeafKeys(child, leafKeys));
      };

      const leafKeys = this.createOptimizedKeySet();
      keys.forEach(
        (key) =>
          this.parentKeyNodeMap.has(key)
            ? getLeafKeys(this.parentKeyNodeMap.get(key), leafKeys)
            : leafKeys.add(key),
        this
      );
      return leafKeys;
    }

    // Derives parent states (selected, partial) from selected leaves
    assignParentSelection(node, siblingsSelection, selected) {
      const isLeaf =
        node[this.keyAttr] !== undefined && !this.parentKeyNodeMap.has(node[this.keyAttr]);
      if (isLeaf) {
        if (selected.selectedLeaves.has(node[this.keyAttr])) {
          // eslint-disable-next-line no-param-reassign
          siblingsSelection.selected += 1;
        }
      } else {
        const childrenSelection = { selected: 0, partial: 0 };
        node[this.childrenAttr].forEach((child) =>
          this.assignParentSelection(child, childrenSelection, selected)
        );

        if (
          node[this.keyAttr] === undefined ||
          childrenSelection.selected + childrenSelection.partial === 0
        ) {
          return;
        }

        if (childrenSelection.selected === node[this.childrenAttr].length) {
          selected.selectedParents.add(node[this.keyAttr]);
          // eslint-disable-next-line no-param-reassign
          siblingsSelection.selected += 1;
        } else {
          selected.partialParents.add(node[this.keyAttr]);
          // eslint-disable-next-line no-param-reassign
          siblingsSelection.partial += 1;
        }
      }
    }

    // Normalizes given keyset (e.g. if it's an AllKeySetImpl) to a KeySetImpl
    normalizeKeySet(keySet) {
      return keySet.isAddAll() ? new ojkeyset.KeySetImpl(this.allKeys).delete(keySet.deletedValues()) : keySet;
    }
  }

  /**
   * @ojcomponent oj.ojTreeView
   * @augments oj.baseComponent
   * @since 4.0.0
   * @ojimportmembers oj.ojSharedContextMenu
   * @ojshortdesc A tree view displays hierarchical relationships between items.
   * @ojrole tree
   * @ojtsimport {module: "ojtreedataprovider", type: "AMD", importName: "TreeDataProvider"}
   * @ojtsimport {module: "ojkeyset", type: "AMD", imported: ["KeySet"]}
   * @ojtsimport {module: "ojdataprovider", type: "AMD", imported: ["ItemMetadata"]}
   * @ojsignature [{
   *                target: "Type",
   *                value: "class ojTreeView<K, D> extends baseComponent<ojTreeViewSettableProperties<K,D>>",
   *                genericParameters: [{"name": "K", "description": "Type of key of the dataprovider"}, {"name": "D", "description": "Type of data from the dataprovider"}]
   *               },
   *               {
   *                target: "Type",
   *                value: "ojTreeViewSettableProperties<K,D> extends baseComponentSettableProperties",
   *                for: "SettableProperties"
   *               }]
   *
   * @ojpropertylayout {propertyGroup: "common", items: ["selectionMode"]}
   * @ojpropertylayout {propertyGroup: "data", items: ["data", "expanded", "selection"]}
   * @ojvbdefaultcolumns 6
   * @ojvbmincolumns 2
   *
   * @ojoracleicon 'oj-ux-ico-tree-view'
   * @ojuxspecs ['tree-view']
   *
   * @classdesc
   * <h3 id="treeViewOverview-section">
   *   JET TreeView
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treeViewOverview-section"></a>
   * </h3>
   *
   * <p>The JET TreeView allows a user to display the hierarchical relationship between items.</p>
   *
   * <p>The child content can be configured via inline HTML content or a DataProvider.
   * It is recommended that inline HTML content should only be used for static data and the DataProvider should always be used for mutable data.
   * </p>
   *
   * <h3 id="data-section">
   *   Data
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
   * </h3>
   * <p>The JET TreeView gets its data in two different ways. The first way is from a TreeDataProvider or TreeDataSource.</p>
   * <ul>
   * <li><b>ArrayTreeDataProvider</b> - Use this when the underlying data is an array.
   *  See the documentation for <a href="ArrayTreeDataProvider.html">ArrayTreeDataProvider</a>
   * for more details on the available options.</li>
   * </ul>
   * <p>There are two types of TreeDataSource that are available out of the box:</p>
   * <ul>
   * <li><b>oj.JsonTreeDataSource</b> (deprecated) - Use this when the underlying data is a JSON object.
   * See the documentation for <a href="JsonTreeDataSource.html">JsonTreeDataSource</a>
   * for more details on the available options.</li>
   * <li><b>oj.CollectionTreeDataSource</b> (deprecated) - Use this when Collection is the model for each group of data.
   * See the documentation for <a href="CollectionTreeDataSource.html">CollectionTreeDataSource</a>
   * for more details on the available options.</li>
   * </ul>
   *
   * <p>Example of tree data provider content:</p>
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-tree-view data="[[dataprovider]]">
   * &lt;/oj-tree-view>
   * </code></pre>
   * <p>Check out the ArrayTreeDataProvider keys demo.</p>
   *
   * <p>The second way is using static HTML content as data.</p>
   * <p>Note that any manipulation of static HTML content, including manipulating content generated through Knockout (for example, updating observableArray in a foreach binding), is not supported.<p>
   *
   * <p>Example of static content:</p>
   * <pre class="prettyprint">
   * <code>
   * &lt;oj-tree-view id="treeview1">
   *   &lt;ul>
   *     &lt;li>
   *       &lt;a id="group1" href="#">Group 1&lt;/a>
   *       &lt;ul>
   *         &lt;li>&lt;a id="item1-1" href="#">Item 1-1&lt;/a>&lt;/li>
   *         &lt;li>&lt;a id="item1-2" href="#">Item 1-2&lt;/a>&lt;/li>
   *       &lt;/ul>
   *     &lt;/li>
   *     &lt;li>
   *       &lt;a id="group2" href="#">Group 2&lt;/a>
   *       &lt;ul>
   *         &lt;li>&lt;a id="item2-1" href="#">Item 2-1&lt;/a>&lt;/li>
   *         &lt;li>&lt;a id="item2-2" href="#">Item 2-2&lt;/a>&lt;/li>
   *       &lt;/ul>
   *     &lt;/li>
   *   &lt;/ul>
   * &lt;/oj-tree-view>
   * </code></pre>
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="keyboard-section">
   *   Keyboard End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"keyboardDoc"}
   *
   * <h3 id="context-section">
   *   Item Context
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
   * </h3>
   *
   * <p>For item attributes, developers can specify a function as the return value.
   * The function takes a single argument, which is an object that contains contextual
   * information about the particular item. This gives developers the flexibility
   * to return different value depending on the context.</p>
   *
   * <p>The context parameter contains the following keys:</p>
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>componentElement</kbd></td>
   *       <td>The TreeView element.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>data</kbd></td>
   *       <td>The data object for the item (not available for static content).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>datasource</kbd></td>
   *       <td>A reference to the data source object (not available for static content).</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>depth</kbd></td>
   *       <td>The depth of the item. The depth of the first level children under the invisible root is 1.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>index</kbd></td>
   *       <td>The index of the item relative to its parent, where 0 is the index of the first item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>key</kbd></td>
   *       <td>The key of the item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>leaf</kbd></td>
   *       <td>Whether the item is a leaf item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>parentElement</kbd></td>
   *       <td>The TreeView item element. The renderer can use this to directly append content.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>parentKey</kbd></td>
   *       <td>The key of the parent item. The parent key is null for root item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>metadata</kbd></td>
   *       <td>The metadata of the item (not available for static content).</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   * <p> <b>Important:</b> Treeview does not support actionable content (i.e. Buttons, Links, etc) inside it's templated content.</p>
   * <p>To facilitate drag and drop including item reordering using only keyboard, application must ensure that either to expose the functionality using context menu, and/or
   * allow users to perform the functionality with the appropriate keystroke.  You can find examples of how this can be done in the cookbook demos.</p>
   *
   * <p>Nesting collection components such as ListView, Table, TreeView, and TreeView inside of TreeView is not supported.</p>
   *
   * <h3 id="perf-section">
   *   Performance
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
   * </h3>
   *
   * <h4>Data Set Size</h4>
   * <p>As a rule of thumb, it is recommended that applications limit the amount of data to display. Displaying large
   * number of items in TreeView makes it hard for user to find what they are looking for, but also affects the load time and
   * scrolling performance as well.</p>
   *
   * <h4>Item Content</h4>
   * <p>TreeView allows developers to specify arbitrary content inside its item. In order to minimize any negative effect on
   * performance, please avoid putting a large number of heavy-weight components inside because as it adds more complexity
   * to the structure, and the effect will be multiplied because there can be many items in the TreeView.</p>
   *
   * <h4>Expand All</h4>
   * <p>While TreeView provides a convenient way to initially expand all parent items in the TreeView, it might have an impact
   * on the initial rendering performance since expanding each parent item might cause a fetch from the server depending on
   * the TreeDataProvider or TreeDataSource. Other factors that could impact performance includes the depth of the tree, and the number of children
   * in each level.</p>
   *
   * <h3 id="animation-section">
   *   Animation
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#animation-section"></a>
   * </h3>
   *
   * <p>Applications can customize animations triggered by actions in TreeView by overriding action specific style classes on the animated item.  See the documentation of <a href="AnimationUtils.html">AnimationUtils</a>
   *    class for details.</p>
   *
   * <p>The following are actions in which applications can use to customize animation effects.
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Action</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>expand</kbd></td>
   *       <td>When user expands an item.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>collapse</kbd></td>
   *       <td>When user collapses an item.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   */

  //-----------------------------------------------------
  //                   Fragments
  //-----------------------------------------------------
  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan="2">Item</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Focus on the item. If <code class="prettyprint">selectionMode</code> is enabled, selects the item as well.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Press & Hold</kbd></td>
   *       <td>Display context menu</td>
   *     </tr>
   *     <tr>
   *       <td>Disclosure Icon</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Expand or collapse the item.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojTreeView
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td rowspan = "13" nowrap>Item</td>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Navigates to next focusable element on page.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+Tab</kbd></td>
   *       <td>Navigates to previous focusable element on page.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>DownArrow</kbd></td>
   *       <td>Moves focus to the item below.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow</kbd></td>
   *       <td>Moves focus to the item above.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow</kbd></td>
   *       <td>On an expanded item, collapses the item. Otherwise, move focus to the item above. The action is swapped with <kbd>RightArrow</kbd> in RTL locales.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>RightArrow</kbd></td>
   *       <td>On a collapsed item, expands the item. Otherwise, move focus to the item below. The action is swapped with <kbd>LeftArrow</kbd> in RTL locales.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+DownArrow</kbd></td>
   *       <td>Extends the selection to the item below. Only applicable if the multiple or leafOnly selection is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+UpArrow</kbd></td>
   *       <td>Extends the selection to the item above. Only applicable if the multiple or leafOnly selection is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Space</kbd></td>
   *       <td>Toggles the selection of the current item and deselects the other items.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Selects the current item and deselects the other items. No op if the current item is already selected.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+Space/Enter / CMD+Space/Enter</kbd></td>
   *       <td>Toggles the selection of the current item while maintaining previously selected items. Only applicable if the multiple or leafOnly selection is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Shift+Space/Enter</kbd></td>
   *       <td>Selects contiguous items from the last selected item to the current item. Only applicable if the multiple or leafOnly selection is enabled.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Ctrl+A / CMD+A</kbd></td>
   *       <td>If selectionMode is multiple, will select all selectable nodes.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojTreeView
   */

  //-----------------------------------------------------
  //                   Sub-ids
  //-----------------------------------------------------
  /**
   * <p>Sub-ID for TreeView items. See the <a href="#getNodeBySubId">getNodeBySubId</a>
   * method for details.</p>
   *
   * @ojsubid oj-treeview-item
   * @memberof oj.ojTreeView
   *
   * @example <caption>Get the item with key 'foo':</caption>
   * var item = myTreeView.getNodeBySubId({'subId': 'oj-treeview-item', 'key': 'foo'});
   */

  /**
   * <p>Sub-ID for TreeView disclosure icons. See the <a href="#getNodeBySubId">getNodeBySubId</a>
   * method for details.</p>
   *
   * @ojsubid oj-treeview-disclosure
   * @memberof oj.ojTreeView
   *
   * @example <caption>Get the disclosure icon for the non-leaf item with key 'foo':</caption>
   * var item = myTreeView.getNodeBySubId({'subId': 'oj-treeview-disclosure', 'key': 'foo'});
   */

  /**
   * <p>Context for TreeView items.</p>
   *
   * @property {Element} componentElement The TreeView element.
   * @property {Object} data The data object for the item (not available for static content).
   * @property {oj.TreeDataProvider|oj.TreeDataSource} datasource A reference to the data source object (not available for static content).
   * @property {number} depth The depth of the item. The depth of the first level children under the invisible root is 1.
   * @property {number} index The index of the item relative to its parent, where 0 is the index of the first item.
   * @property {Object} key The key of the item.
   * @property {boolean} leaf Whether the item is a leaf item.
   * @property {Object} parentKey The key of the parent item. The parent key is null for root item.
   * @property {ItemMetadata<K>} metadata The metadata of the item (not available for static content).
   * @ojsignature [{target:"Type", value:"oj.TreeDataProvider|oj.TreeDataSource", for:"datasource", consumedBy:"js"},
   *               {target:"Type", value:"oj.TreeDataProvider", for:"datasource", consumedBy:"ts"}]
   *
   * @ojnodecontext oj-treeview-item
   * @memberof oj.ojTreeView
   */

  //-----------------------------------------------------
  //                   Slots
  //-----------------------------------------------------
  /**
   * <p>The <code class="prettyprint">itemTemplate</code> slot is used to specify the template for rendering each item in the list. The slot content must be a &lt;template> element.
   * The content of the template could either include the &lt;li> element, in which case that will be used as
   * the root of the item.  Or it can be just the content which excludes the &lt;li> element.</p>
   * <p>When the template is executed for each item, it will have access to the binding context containing the following properties:</p>
   * <ul>
   *   <li>$current - an object that contains information for the current item. (See [oj.ojTreeView.ItemTemplateContext]{@link oj.ojTreeView.ItemTemplateContext} or the table below for a list of properties available on $current)</li>
   *   <li>alias - if as attribute was specified, the value will be used to provide an application-named alias for $current.</li>
   * </ul>
   *
   * @ojslot itemTemplate
   * @ojshortdesc The itemTemplate slot is used to specify the template for rendering each item in the tree. See the Help documentation for more information.
   * @ojmaxitems 1
   * @memberof oj.ojTreeView
   * @ojtemplateslotprops oj.ojTreeView.ItemTemplateContext
   * @example <caption>Initialize the TreeView with an inline item template specified:</caption>
   * &lt;oj-tree-view>
   *   &lt;template slot='itemTemplate'>
   *     &lt;span>&lt;oj-bind-text value='[[$current.data.name]]'>&lt;/span>
   *   &lt;template>
   * &lt;/oj-tree-view>
   */
  /**
    @typedef {Object} oj.ojTreeView.ItemTemplateContext
    @property {Element} componentElement The &lt;oj-tree-view> custom element.
    @property {Object} data The data for the current item being rendered.
    @property {number} index The zero-based index of the current item.
    @property {any} key The key of the current item being rendered.
    @property {number} depth The depth of the current item being rendered. The depth of the first level children under the invisible root is 1.
    @property {boolean} leaf True if the current item is a leaf node.
    @property {any} parentkey The key of the parent item. The parent key is null for root nodes.
    @property {ItemMetadata<K>} metadata The metadata of the item.
    @ojsignature [{target:"Type", value:"<K = any,D = any>", for:"genericTypeParameters"},
    {target:"Type", value:"D", for:"data", jsdocOverride: true},
    {target:"Type", value:"K", for:"key", jsdocOverride: true},
    {target:"Type", value:"K", for:"parentkey", jsdocOverride: true}]
   */

  //-----------------------------------------------------
  //                   Styling
  //-----------------------------------------------------
  // ---------------- oj-treeview-item-text --------------
  /**
   * Use this class on the span providing the item text in the static markup or the item renderer or template slot.
   * @ojstyleclass oj-treeview-item-text
   * @ojdisplayname Treeview item text
   * @ojstyleselector "oj-tree-view span"
   * @memberof oj.ojTreeView
   */
  /**
   * Use this class on the span providing the item icon in the static markup or the item renderer or template slot.
   * @ojstyleclass oj-treeview-item-icon
   * @ojdisplayname Treeview item icon
   * @ojstyleselector "oj-tree-view span"
   * @memberof oj.ojTreeView
   */
  /**
   * Use this class on any additional icons included in treeview's items to assist with vertical alignment and size.
   * @ojstyleclass oj-treeview-item-content-icon
   * @ojdisplayname Treeview item content icon
   * @ojstyleselector "oj-tree-view *"
   * @memberof oj.ojTreeView
   */
  /**
   * @ojstylevariableset oj-tree-view-css-set1
   * @ojstylevariable oj-tree-view-row-height {description: "Tree view row height", formats: ["length"], help: "#css-variables"}
   * @ojstylevariable oj-tree-view-text-color {description: "Tree view text color", formats: ["color"], help: "#css-variables"}
   * @ojstylevariable oj-tree-view-indent-width {description: "Tree view indent width", formats: ["length"], help: "#css-variables"}
   * @memberof oj.ojTreeView
   */
  // --------------------------------------------------- oj.ojTreeView Styling End -----------------------------------------------------------

  (function () {
    oj.__registerWidget('oj.ojTreeView', $.oj.baseComponent, {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',
      options: {
        /**
         * The key of the item that has the browser focus.
         * This is a read-only attribute so page authors cannot set or change it directly.
         *
         * @expose
         * @public
         * @type {any}
         * @instance
         * @memberof! oj.ojTreeView
         * @ojshortdesc Read-only property used for retrieving the key of the item that currently has focus.
         * @readonly
         * @ojwriteback
         * @ojsignature {target:"Type", value:"K"}
         *
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">current-item</code> attribute specified:</caption>
         * &lt;oj-tree-view current-item='{{myCurrentItem}}'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">currentItem</code> property after initialization:</caption>
         * // getter
         * var currentItemValue = myTreeView.currentItem;
         *
         * // setter
         * myTreeView.currentItem = "item2";
         */
        currentItem: null,

        /**
         * The data source for the TreeView. Accepts an instance of TreeDataProvider or TreeDataSource.
         * See the data source section in the introduction for out of the box data source types.
         * If the data attribute is not specified, the child elements are used as content. If there's no
         * content specified, then an empty list is rendered.
         *
         * @expose
         * @public
         * @type {Object}
         * @instance
         * @memberof! oj.ojTreeView
         * @ojshortdesc Specifies the data for the tree. See the Help documentation for more information.
         * @default null
         * @ojsignature {target: "Type", value: "TreeDataProvider<K, D>"}
         * @ojwebelementstatus {type: "unsupported", since: "13.0.0",
         *   description: "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."}
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">data</code> attribute specified:</caption>
         * &lt;oj-tree-view data='{{myDataProvider}}'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">data</code> property after initialization:</caption>
         * // getter
         * var dataValue = myTreeView.data;
         *
         * // setter
         * myTreeView.data = new ArrayTreeDataProvider(myArray);
         */
        data: null,

        /**
         * Enable drag and drop functionality.<br><br>
         * JET provides support for HTML5 Drag and Drop events.  Please refer to {@link https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop third party documentation}
         * on HTML5 Drag and Drop to learn how to use it.
         *
         * @expose
         * @memberof! oj.ojTreeView
         * @ojshortdesc Customizes the drag and drop functionality. See the Help documentation for more information.
         * @type {Object}
         * @instance
         */
        dnd: {
          /**
           * @expose
           * @name dnd.drag
           * @memberof! oj.ojTreeView
           * @ojshortdesc Customizes the drag functionality.
           * @instance
           * @type {Object}
           * @ojsignature {target: "Type", value: "?"}
           * @default null
           * @property {Object} items If this object is specified, TreeView will initiate drag operation when the user drags on an item.
           * @property {string|Array.<string>} [items.dataTypes] The MIME types to use for the dragged data in the dataTransfer object. This can be a string if there is only one
           * type, or an array of strings if multiple types are needed.<br><br>
           * For example, if selected items of employee data are being dragged, dataTypes could be "application/employees+json". Drop targets can examine the data types and decide
           * whether to accept the data. A text input may only accept "text" data type, while a chart for displaying employee data may be configured to accept the "application/employees+json" type.<br><br>
           * For each type in the array, dataTransfer.setData will be called with the specified type and the JSON version of the selected item data as the value. The selected item data
           * is an array of objects, with each object representing a model object from the underlying data source. For example, if the underlying data is an Collection, then this
           * would be a Model object. Note that when static HTML is used, then the value would be the HTML string of the selected item.<br><br><br>
           * This property is required unless the application calls setData itself in a dragStart callback function.
           * @property {function(Event, {items: Array.<D>}):void} [items.dragStart] A callback function that receives the "dragstart" event and context information as its arguments.<br><br>
           * <code class="prettyprint">function(event, context)</code><br><br>
           * All of the event payloads listed below can be found under the <code class="prettyprint">context</code> argument.
           * <ul><li><code class="prettyprint">items</code>: An array of objects, with each object representing the data of one selected item.</li></ul><br>
           * This function can set its own data and drag image as needed. If dataTypes is specified, event.dataTransfer is already populated with the default data when this function is invoked.
           * If dataTypes is not specified, this function must call event.dataTransfer.setData to set the data or else the drag operation will be cancelled. In either case, the drag image is
           * set to an image of the dragged items on the TreeView.
           * @property {function(Event):void} [items.drag] A callback function that receives the "drag" event as its argument.<br><br>
           * @property {function(Event):void} [items.dragEnd] A callback function that receives the "dragend" event as its argument.<br><br>
           *
           * @ojsignature {target: "Type",
           *               value: "?((event: Event, context: {items: Array<D>}) => void)",
           *               for: "items.dragStart"}
           *
           * @example <caption>Initialize the TreeView such that only leaf items are focusable:</caption>
           * myTreeView.setProperty('dnd.drag.items', {
           *   'dataTypes': ['application/ojtreeviewitems+json'],
           *   'dragEnd': handleDragEnd
           * });
           */
          drag: null,

          /**
           * @typedef {Object} oj.ojTreeView.ItemsDropOnDropContext
           * @property {Element} item The item being dropped on.
           * @property {'inside'|'before'|'after'|'first'} position The drop position relative to the item being dropped on.
           */
          /**
           * @expose
           * @name dnd.drop
           * @memberof! oj.ojTreeView
           * @ojshortdesc Customizes the drop functionality.
           * @instance
           * @type {Object}
           * @ojsignature {target: "Type", value: "?"}
           * @default null
           * @property {Object} items  An object that specifies callback functions to handle dropping items<br><br>
           * @property {string|Array.<string>} [items.dataTypes] A data type or an array of data types this component can accept.<br><br>
           * This property is required unless dragEnter, dragOver, and drop callback functions are specified to handle the corresponding events.
           * @property {function(Event, {item: Element}):void} [items.dragEnter] A callback function that receives the "dragenter" event and context information as its arguments.<br><br>
           * <code class="prettyprint">function(event, context)</code><br><br>
           * All of the event payloads listed below can be found under the <code class="prettyprint">context</code> argument.
           * <ul><li><code class="prettyprint">item</code>: The item being entered.</li></ul><br>
           * This function should call <code class="prettyprint">event.preventDefault()</code> to indicate the dragged data can be accepted.
           * Otherwise, dataTypes will be matched against the drag dataTypes to determine if the data is acceptable. If there is a match, <code class="prettyprint">event.preventDefault()</code>
           * will be called to indicate that the data can be accepted.
           * @property {function(Event, {item: Element}):void} [items.dragOver] A callback function that receives the "dragover" event and context information as its arguments.<br><br>
           * <code class="prettyprint">function(event, context)</code><br><br>
           * All of the event payloads listed below can be found under the <code class="prettyprint">context</code> argument.
           * <ul><li><code class="prettyprint">item</code>: The item being dragged over.</li></ul><br>
           * This function should call <code class="prettyprint">event.preventDefault()</code> to indicate the dragged data can be accepted.
           * Otherwise, dataTypes will be matched against the drag dataTypes to determine if the data is acceptable. If there is a match, <code class="prettyprint">event.preventDefault()</code>
           * will be called to indicate that the data can be accepted.
           * @property {function(Event, {item: Element}):void} [items.dragLeave] A callback function that receives the "dragleave" event and context information as its arguments.<br><br>
           * <code class="prettyprint">function(event, context)</code><br><br>
           * All of the event payloads listed below can be found under the <code class="prettyprint">context</code> argument.
           * <ul><li><code class="prettyprint">item</code>: The item that was last entered.</li></ul><br>
           * @property {function(Event, oj.ojTreeView.ItemsDropOnDropContext):void} items.drop A required callback function that receives the "drop" event and context information as its arguments.<br><br>
           * <code class="prettyprint">function(event, context)</code><br><br>
           * All of the event payloads listed below can be found under the <code class="prettyprint">context</code> argument.
           * <ul><li><code class="prettyprint">item</code>: The item being dropped on.</li>
           * <li><code class="prettyprint">position</code>: The drop position relative to the item being dropped on.
           * Valid values are "inside", "before", "after", and "first" (the first child of the item being dropped on).</li></ul><br>
           * This function should call <code class="prettyprint">event.preventDefault()</code> to indicate the dragged data can be accepted.<br><br>
           * If the application needs to look at the data for the item being dropped on, it can use the <code class="prettyprint">Context.getContextByNode</code> method.
           *
           * @ojsignature [{target: "Type",
           *                value: "?((event: Event, context: {item: Element}) => void)",
           *                for: "items.dragEnter"},
           *               {target: "Type",
           *                value: "?((event: Event, context: {item: Element}) => void)",
           *                for: "items.dragOver"},
           *               {target: "Type",
           *                value: "?((event: Event, context: {item: Element}) => void)",
           *                for: "items.dragLeave"}]
           *
           *
           * @example <caption>Initialize the TreeView such that only leaf items are focusable:</caption>
           * myTreeView.setProperty('dnd.drop.items', {
           *   'dataTypes': ['application/ojtreeviewitems+json'],
           *   'drop': handleDrop
           * });
           */
          drop: null
        },

        /**
         * Specifies the key set containing the keys of the TreeView items that should be expanded.
         * Use the <a href="KeySetImpl.html">KeySetImpl</a> class to specify items to expand.
         * Use the <a href="AllKeySetImpl.html">AllKeySetImpl</a> class to expand all items.
         *
         * @expose
         * @memberof! oj.ojTreeView
         * @ojshortdesc Specifies the key set containing the keys of the items that should be expanded. See the Help documentation for more information.
         * @instance
         * @type {KeySet}
         * @default new KeySet()
         * @ojwriteback
         * @ojsignature {target:"Type", value:"KeySet<K>"}
         *
         * @example <caption>Initialize the TreeView with some expanded items:</caption>
         * myTreeView.expanded = new KeySetImpl(['item1', 'item2']);
         *
         * @example <caption>Initialize the TreeView with all items expanded:</caption>
         * myTreeView.expanded = new AllKeySetImpl();
         */
        expanded: new ojkeyset.KeySetImpl(),

        /**
         * The item attribute contains a subset of attributes for items.
         *
         * @expose
         * @memberof! oj.ojTreeView
         * @ojshortdesc Customizes the functionality of each item in the tree.
         * @type {Object}
         * @instance
         */
        item: {
          /**
           * @typedef {Object} oj.ojTreeView.ItemContext
           * @property {Element} componentElement The TreeView element.
           * @property {D} [data] The data object of the item (not available for static content).
           * @property {number} depth The depth of the item. The depth of the first level children under the invisible root is 1.
           * @property {number} index The index of the item relative to its parent, where 0 is the index of the first item.
           * @property {K} key The key of the item.
           * @property {boolean} leaf Whether the item is a leaf item.
           * @property {Element} parentElement The TreeView item element. The renderer can use this to directly append content.
           * @property {K} [parentKey] The key of the parent item (not available for root item).
           * @property {ItemMetadata<K>} metadata The metadata of the item (not available for static content).
           * @property {TreeDataProvider<K, D> | Object} datasource A reference to the data source object (not available for static content).
           * @ojsignature {target:"Type", value:"<K,D>", for:"genericTypeParameters"}
           */
          /**
           * A function that returns whether the item is focusable.
           * A item that is not focusable cannot be clicked on or navigated to.
           * See <a href="#context-section">itemContext</a> in the introduction
           * to see the object passed into the focusable function.
           * If no function is specified, then all the items will be focusable.
           *
           * @expose
           * @name item.focusable
           * @ojshortdesc Specifies whether the item can receive keyboard focus. See the Help documentation for more information.
           * @memberof! oj.ojTreeView
           * @instance
           * @type {function(Object):boolean|null}
           * @ojsignature {target: "Type",
           *               value: "?((itemContext: oj.ojTreeView.ItemContext<K,D>) => boolean)",
           *               jsdocOverride: true}
           * @ojdeprecated {since: '13.0.0', description: 'Not accessible by screen reader.'}
           * @default null
           *
           * @example <caption>Initialize the TreeView such that only leaf items are focusable:</caption>
           * myTreeView.setProperty('item.focusable', function(itemContext)
           * {
           *   return itemContext['leaf'];
           * });
           */
          focusable: null,

          /**
           * The renderer function that renders the contents of the item. See <a href="#context-section">itemContext</a>
           * in the introduction to see the object passed into the renderer function.
           * The function should return one of the following:
           * <ul>
           *   <li>An Object with the following property:
           *     <ul><li>insert: HTMLElement | string - A string or a DOM element of the content inside the item.</li></ul>
           *   </li>
           *   <li>Nothing: If the developer chooses to manipulate the item element directly, the function should return nothing.</li>
           * </ul>
           *
           * @expose
           * @name item.renderer
           * @ojshortdesc Specifies the renderer for the item. See the Help documentation for more information.
           * @memberof! oj.ojTreeView
           * @instance
           * @type {function(Object):Object|null}
           * @ojsignature {target: "Type",
           *               value: "?((itemContext: oj.ojTreeView.ItemContext<K,D>) => {insert: Element|string}|void)|null",
           *               jsdocOverride: true}
           * @default null
           *
           * @example <caption>Initialize the TreeView with a renderer:</caption>
           * &lt;oj-tree-view item.renderer='{{myRendererFunc}}'>&lt;/oj-tree-view>
           *
           * @example <caption>Get or set the <code class="prettyprint">renderer</code> property after initialization:</caption>
           * // getter
           * var renderer = myTreeView.item.renderer;
           *
           * // setter
           * myTreeView.item.renderer = myRendererFunc;
           */
          renderer: null,

          /**
           * A function that returns whether the item can be selected.
           * If selectionMode is set to "none" this attribute is ignored.
           * In addition, if focusable is set to false, then the selectable
           * option is automatically overridden and set to false also.
           * See <a href="#context-section">itemContext</a> in the introduction
           * to see the object passed into the selectable function.
           * If no function is specified, then all the items will be selectable.
           *
           * @expose
           * @name item.selectable
           * @ojshortdesc Specifies whether the item can be selected. See the Help documentation for more information.
           * @memberof! oj.ojTreeView
           * @instance
           * @type {function(Object):boolean|null}
           * @ojsignature {target: "Type",
           *               value: "?((itemContext: oj.ojTreeView.ItemContext<K,D>) => boolean)",
           *               jsdocOverride: true}
           * @default null
           *
           * @example <caption>Initialize the TreeView with the <code class="prettyprint">selectable</code> attribute specified:</caption>
           * &lt;oj-tree-view item.selectable='{{mySelectableFunc}}'>&lt;/oj-tree-view>
           *
           * @example <caption>Get or set the <code class="prettyprint">selectable</code> property after initialization:</caption>
           * // getter
           * var selectable = myTreeView.item.selectable;
           *
           * // setter
           * myTreeView.item.selectable = mySelectableFunc;
           */
          selectable: null
        },
        /**
         * scrollPolicy options.
         * <p>
         * The following options are supported:
         * <ul>
         *   <li>maxCount: Maximum rows which will be displayed before fetching more rows will be stopped.</li>
         * </ul>
         *
         * @ojshortdesc Specifies fetch options for scrolling behaviors that trigger data fetches. See the Help documentation for more information.
         * @expose
         * @instance
         * @memberof! oj.ojTreeView
         * @type {Object.<number>|null}
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">scroll-policy-options</code> attribute specified:</caption>
         * &lt;oj-tree-view scroll-policy-options.max-count='1000'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">scroll-policy-options</code> attribute after initialization:</caption>
         * // getter
         * var maxCountValue = myTreeView.scrollPolicyOptions.maxCount;
         *
         * // setter
         * myTreeView.scrollPolicyOptions.maxCount = 30;
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">scroll-policy-options</code> attribute specified:</caption>
         * &lt;!-- Using dot notation -->
         * &lt;oj-tree-view scroll-policy-options.max-count='1000'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">scrollPolicyOptions</code> property after initialization:</caption>
         * // Get maxCount value
         * var maxCountValue = myTreeView.scrollPolicyOptions.maxCount;
         *
         * // Get ScrollPolicy Object
         * var scrollPolicyOptionsValues = myTreeView.scrollPolicyOptions;
         *
         * // Set maxCount value
         * myTreeView.setProperty('scrollPolicyOptions.maxCount', 1000);
         *
         */
        scrollPolicyOptions: {
          /**
           * The maximum number of rows which will be displayed before fetching more rows will be stopped.
           * <p>See the <a href="#scrollPolicyOptions">scroll-policy-options</a> attribute for usage examples.</p>
           *
           * @expose
           * @name scrollPolicyOptions.maxCount
           * @ojshortdesc The maximum number of items to display before fetching more data items will be stopped.
           * @memberof! oj.ojTreeView
           * @instance
           * @type {number}
           * @default 500
           * @ojmin 0
           */
          maxCount: 500
        },
        /**
         * The KeySet of the current selected items in the TreeView. An empty KeySet indicates nothing is selected.
         * Note that property change event for the deprecated selection property will still be fired when
         * selected property has changed. In addition, <a href="AllKeySetImpl.html">AllKeySetImpl</a> set
         * can be used to represent an select all state. In this case, the value for selection would have an
         * 'inverted' property set to true, and would contain the keys of the items that are not selected.
         *
         * @ojshortdesc Specifies the keys of the current selected items. See the Help documentation for more information.
         * @expose
         * @memberof! oj.ojTreeView
         * @instance
         * @default new KeySetImpl();
         * @type {KeySet}
         * @ojsignature {target:"Type", value:"KeySet<K>"}
         * @ojwriteback
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">selected</code> attribute specified:</caption>
         * &lt;oj-tree-view selected='{{mySelectedItemsKeySet}}'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">selected</code> property after initialization:</caption>
         * // getter
         * var selectedValue = myTreeView.selected;
         *
         * // setter
         * myTreeView.selected = ['item1', 'item2', 'item3'];
         */
        selected: new ojkeyset.KeySetImpl(),
        /**
         * The current selections in the TreeView. An empty array indicates nothing is selected.
         *
         * @expose
         * @memberof! oj.ojTreeView
         * @ojshortdesc Specifies the current selections in the tree. An empty array indicates nothing is selected.
         * @instance
         * @type {Array.<any>}
         * @default []
         * @ojwriteback
         * @ojeventgroup common
         *
         * @ojsignature {target:"Type", value:"Array<K>"}
         * @ojdeprecated {since: '8.0.0', description: 'Use selected attribute instead.'}
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">selection</code> attribute specified:</caption>
         * &lt;oj-tree-view selection='{{mySelection}}'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">selection</code> property after initialization:</caption>
         * // getter
         * var selectionValue = myTreeView.selection;
         *
         * // setter
         * myTreeView.selection = ['item1', 'item2', 'item3'];
         */
        selection: [],

        /**
         * <p>The type of selection behavior that is enabled on the TreeView. This attribute controls the number of selections that can be made via selection gestures at any given time.
         *
         * <p>If <code class="prettyprint">single</code> or <code class="prettyprint">multiple</code> is specified, selection gestures will be enabled, and the TreeView's selection styling will be applied to all items specified by the <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes.
         * If <code class="prettyprint">multiple</code> is specified <a href="oj.ojSelector.html">oj-selectors</a> will also be rendered by default.
         * If <code class="prettyprint">none</code> is specified, selection gestures will be disabled, and the TreeView's selection styling will not be applied to any items specified by the <a href="#selection">selection</a> and <a href="#selected">selected</a> attributes.
         * If <code class="prettyprint">leafOnly</code> is specified, the selection consists only of leaves, from which parent selection states are derived.<a href="oj.ojSelector.html">oj-selectors</a> will be rendered by default and the selection states of the items will be cascaded, which means that:</p>
         * <ul>
         *   <li>If a parent item is selected, then all the descendants will be selected automatically.</li>
         *   <li>If a parent item is unselected, then all the descendants will be unselected automatically.</li>
         *   <li>If a parent item has a mixture of selected and unselected descendants, and redwood is enabled then it will display a partially selected state.</li>
         * </ul>
         * <p> Note: In order to compute the selection, in selectionMode <code>leafOnly</code> the treeview will trigger continuous fetches until it has the complete data set.
         * We do not recommend using this mode with large data sets and currently mutations are not supported in this mode.</p>
         * <p>Changing the value of this attribute will not affect the value of the <a href="#selection">selection</a> or <a href="#selected">selected</a> attributes.
         *
         * @expose
         * @memberof! oj.ojTreeView
         * @ojshortdesc Specifies the selection mode.
         * @instance
         * @type {string}
         * @default "none"
         * @ojvalue {string} "none" Selection is disabled.
         * @ojvalue {string} "single" Only a single item can be selected at a time.
         * @ojvalue {string} "multiple" Multiple items can be selected at the same time.
         * @ojvalue {string} "leafOnly" Multiple items can be selected but children items control the parent's selection state.
         *
         * @example <caption>Initialize the TreeView with the <code class="prettyprint">selection-mode</code> attribute specified:</caption>
         * &lt;oj-tree-view selection-mode='multiple'>&lt;/oj-tree-view>
         *
         * @example <caption>Get or set the <code class="prettyprint">selectionMode</code> property after initialization:</caption>
         * // getter
         * var selectionModeValue = myTreeView.selectionMode;
         *
         * // setter
         * myTreeView.selectionMode = 'multiple';
         */
        selectionMode: 'none',

        // Events

        /**
         * Triggered when the default animation of a particular action has ended.
         * Note this event will not be triggered if application cancelled the default animation on animateStart.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojTreeView
         * @ojshortdesc Triggered when the default animation of a particular action has ended.
         * @instance
         * @property {'expand'|'collapse'} action The action that triggers the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
         * @property {Element} element The target of animation.
         */
        animateEnd: null,

        /**
         * Triggered when the default animation of a particular action is about to start.
         * The default animation can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         * @ojdeprecated {since: "12.1.0", description: "This web component no longer supports this event."}
         *
         * @expose
         * @event
         * @memberof oj.ojTreeView
         * @ojshortdesc Triggered when the default animation of a particular action is about to start.
         * @instance
         * @property {'expand'|'collapse'} action The action that triggered the animation.<br><br>See <a href="#animation-section">animation</a> section for a list of actions.
         * @property {Element} element The target of animation.
         * @property {function():void} endCallback If the event listener calls <code class="prettyprint">event.preventDefault()</code> to cancel the default animation, it must call the endCallback function when it finishes its own animation handling and when any custom animation ends.
         */
        animateStart: null,

        /**
         * Triggered before an item is collapsed via the <code class="prettyprint">expanded</code> attribute or via the UI.
         * Call <code class="prettyprint">event.preventDefault()</code> to veto the event, which prevents collapsing the item.
         *
         * @expose
         * @event
         * @ojcancelable
         * @memberof oj.ojTreeView
         * @ojshortdesc Triggered before an item is collapsed.
         * @instance
         * @property {any} key The key of the item to be collapsed.
         * @property {Element} item The item to be collapsed.
         * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
         *               {target:"Type", value:"K", for:"key"}]
         */
        beforeCollapse: null,

        /**
         * Triggered before the current item is changed via the <code class="prettyprint">currentItem</code> attribute or via the UI.
         * Call <code class="prettyprint">event.preventDefault()</code> to veto the event, which prevents changing the current item.
         *
         * @expose
         * @event
         * @ojcancelable
         * @memberof oj.ojTreeView
         * @ojshortdesc Triggered before the current item is changed.
         * @instance
         * @property {any} previousKey The key of the previous item.
         * @property {Element} previousItem The previous item.
         * @property {any} key The key of the new current item.
         * @property {Element} item The new current item.
         * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
         *               {target:"Type", value:"K", for:"previousKey"},
         *               {target:"Type", value:"K", for:"key"}]
         */
        beforeCurrentItem: null,

        /**
         * Triggered before an item is expanded via the <code class="prettyprint">expanded</code> attribute or via the UI.
         * Call <code class="prettyprint">event.preventDefault()</code> to veto the event, which prevents expanding the item.
         *
         * @expose
         * @event
         * @ojcancelable
         * @memberof oj.ojTreeView
         * @ojshortdesc Triggered before an item is expanded.
         * @instance
         * @property {any} key The key of the item to be expanded.
         * @property {Element} item The item to be expanded.
         * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
         *               {target:"Type", value:"K", for:"key"}]
         */
        beforeExpand: null,

        /**
         * Triggered after an item has been collapsed.
         *
         * @expose
         * @event
         * @memberof oj.ojTreeView
         * @instance
         * @property {any} key The key of the item that was just collapsed.
         * @property {Element} item The item that was just collapsed.
         * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
         *               {target:"Type", value:"K", for:"key"}]
         */
        collapse: null,

        /**
         * Triggered after an item has been expanded.
         *
         * @expose
         * @event
         * @memberof oj.ojTreeView
         * @instance
         * @property {any} key The key of the item that was just expanded.
         * @property {Element} item The item that was just expanded.
         * @ojsignature [{target:"Type", value:"<K>", for:"genericTypeParameters"},
         *               {target:"Type", value:"K", for:"key"}]
         */
        expand: null
      },
      constants: {
        TREEVIEW_CONTENT_PADDING_REM: 0.5,
        PERIOD: '.',
        OJ_COMPLETE: 'oj-complete',
        OJ_TREEVIEW_LIST: 'oj-treeview-list',
        ERROR_FETCHING_DATA: 'Error fetching data: ',
        OJ_ITEM_DATA: 'oj-item-data',
        OJ_ITEM_METADATA: 'oj-item-metadata',
        OJ_TREEVIEW_ITEM_CONTENT: 'oj-treeview-item-content',
        OJ_TREEVIEW_SELECTOR: 'oj-treeview-selector',
        OJ_COMPONENT_ICON: 'oj-component-icon',
        OJ_DRAGGABLE: 'oj-draggable',
        OJ_TREEVIEW_SPACER: 'oj-treeview-spacer',
        OJ_TREEVIEW_LEAF: 'oj-treeview-leaf',
        OJ_TREEVIEW_DISCLOSURE_ICON: 'oj-treeview-disclosure-icon',
        OJ_DEFAULT: 'oj-default',
        OJ_EXPANDED: 'oj-expanded',
        OJ_TREEVIEW_SKELETON_CONTAINER: 'oj-treeview-skeleton-container',
        OJ_COLLAPSED: 'oj-collapsed',
        OJ_TREEVIEW_ANIMATED: 'oj-treeview-animated',
        OJ_SELECTED: 'oj-selected',
        OJ_TREEVIEW_DRAG_SOURCE: 'oj-treeview-drag-source',
        OJ_TREEVIEW_SKELETON_CONTENT: 'oj-treeview-skeleton-content',
        OJ_ANIMATION_SKELETON: 'oj-animation-skeleton',
        OJ_TREEVIEW_ITEM: 'oj-treeview-item',
        OJ_HOVER: 'oj-hover',
        OJ_CLICKABLE_ICON_NOCONTEXT: 'oj-clickable-icon-nocontext',
        OJ_TREEVIEW_DROPLINE: 'oj-treeview-drop-line',
        OJ_TREEVIEW_SELECT_SINGLE: 'oj-treeview-select-single',
        OJ_TREEVIEW_ICON: 'oj-treeview-icon',
        OJ_TREEVIEW_DRAG_IMAGE: 'oj-treeview-drag-image',
        OJ_TREEVIEW_DRAG_IMAGE_ITEM: 'oj-treeview-drag-image-item',
        OJ_FOCUS: 'oj-focus',
        OJ_TREEVIEW_DROP_ZONE: 'oj-treeview-drop-zone',
        OJ_FOCUS_HIGHLIGHT: 'oj-focus-highlight',
        OJ_ANIMATION_SKELETON_FADE_IN: 'oj-animation-skeleton-fade-in',
        OJ_TREEVIEW_SKELETON_CHILD: 'oj-treeview-skeleton-child',
        OJ_TREEVIEW_SKELETON_CARROT: 'oj-treeview-skeleton-carrot',
        OJ_TREEVIEW_SKELETON_ITEM: 'oj-treeview-skeleton-item',
        OJ_TREEVIEW_SKELETON_LEAF: 'oj-treeview-skeleton-leaf',
        OJ_TREEVIEW_ITEM_ICON: 'oj-treeview-item-icon',
        OJ_TREEVIEW_SELECTED_TOP_ITEM: 'oj-selected-item-content-top',
        OJ_TREEVIEW_SELECTED_BOTTOM_ITEM: 'oj-selected-item-content-bottom',
        OJ_TREEVIEW_CSS_VARS: {
          expandAnimation: '--oj-private-tree-view-global-expand-animation',
          collapseAnimation: '--oj-private-tree-view-global-collapse-animation',
          dataFadeInDuration: '--oj-private-tree-view-global-data-fadein-duration',
          multipleSelectionAffordance: '--oj-private-tree-view-global-selection-affordance-default',
          loadIndicator: '--oj-private-tree-view-global-load-indicator-default',
          showIndicatorDelay: '--oj-private-core-global-loading-indicator-delay-duration'
        }
      },
      // @inheritdoc
      _ComponentCreate: function () {
        this._super();
      },

      // @inheritdoc
      _AfterCreate: function () {
        this._super();
        this._initRender();
        this._render();
        this._isInitFetch = true;
      },
      // @inheritdoc
      _CompareOptionValues: function (option, value1, value2) {
        switch (option) {
          case 'selection':
            if (value1 && value1.inverted === undefined) {
              // eslint-disable-next-line no-param-reassign
              value1.inverted = false;
            }
            if (value2 && value2.inverted === undefined) {
              // eslint-disable-next-line no-param-reassign
              value2.inverted = false;
            }
            if (value1 && value2 && value1.inverted !== value2.inverted) {
              return false;
            }
            return oj.KeyUtils.equals(value1, value2);
          case 'selected':
            return DataCollectionUtils.areKeySetsEqual(value1, value2);
          default:
            return this._super(option, value1, value2);
        }
      },
      /**
       * Initializes the TreeView.
       * @private
       */
      _initRender: function () {
        var self = this;
        // Event listeners
        // Event listeners
        this._on(this.element, {
          click: function (event) {
            self._handleClick(event);
          },
          mouseover: function (event) {
            self._handleMouseOver(event);
          },
          mouseout: function (event) {
            self._handleMouseOut(event);
          },
          mousedown: function (event) {
            self._handleMouseDown(event);
          },
          mouseup: function (event) {
            self._handleMouseUp(event);
          },
          keydown: function (event) {
            self._handleKeyDown(event);
          },
          dragstart: function (event) {
            self._handleDragStart(event);
          },
          drag: function (event) {
            self._handleDragSourceEvent(event, 'drag');
          },
          dragend: function (event) {
            self._handleDragSourceEvent(event, 'dragEnd');
          },
          dragenter: function (event) {
            self._handleDropTargetEvent(event, 'dragEnter');
          },
          dragover: function (event) {
            self._handleDropTargetEvent(event, 'dragOver');
          },
          dragleave: function (event) {
            self._handleDropTargetEvent(event, 'dragLeave');
          },
          drop: function (event) {
            self._handleDropTargetEvent(event, 'drop');
          }
        });

        if (DomUtils.isTouchSupported()) {
          this.element[0].addEventListener(
            'touchstart',
            function (event) {
              self.isTouchDrag = false;
              self.contextMenuOpen = false;
              self.touchStartEvent = event;
            },
            { passive: true }
          );

          this.element[0].addEventListener(
            'touchmove',
            function (event) {
              if (self.isTouchDrag) {
                event.preventDefault();
              }
            },
            { passive: false }
          );

          this.element[0].addEventListener('touchcancel', function () {
            self.touchStartEvent = null;
            self.isTouchDrag = false;
          });

          this.element[0].addEventListener('touchend', function (event) {
            self.isTouchDrag = false;
            if (self.touchStartEvent && event.changedTouches.length) {
              var overElem = document.elementFromPoint(
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
              );
              if (overElem !== self.touchStartEvent.target) {
                self.touchStartEvent = null;
              }
            }
            self._handleMouseOut(event);
          });
        }

        this.element[0].addEventListener('focusin', (event) => {
          if (
            this._getParents(
              event.target,
              this.constants.PERIOD + this.constants.OJ_TREEVIEW_SELECTOR
            ).length > 0
          ) {
            this._getRoot().focus({ preventScroll: true });
          }
        });
        this._dropLine = document.createElement('div');
        this._dropLine.classList.add(this.constants.OJ_TREEVIEW_DROPLINE);
        this.element[0].appendChild(this._dropLine); // HTMLUpdateOk

        const status = document.createElement('div');
        status.classList.add('oj-helper-hidden-accessible');
        status.setAttribute('role', 'status');
        this.element[0].appendChild(status); // HTMLUpdateOk

        this._dropLine.style.display = 'none';

        this._refreshId = 0;
        this._uiExpanded = new ojkeyset.KeySetImpl();
        this.m_fetching = new Map();

        this._expandedChildrenMap = new Map();
        this._syncSelectionState();
      },
      /**
       * Syncs initial selection state with selected being source of truth
       * @private
       */
      _syncSelectionState: function () {
        var selectedArray = ojkeyset.KeySetUtils.toArray(this.options.selected);
        var selectionKeySet = ojkeyset.KeySetUtils.toKeySet(this.options.selection);

        if (selectedArray.length > 0 || selectedArray.inverted) {
          this._userOptionChange('selection', selectedArray, null);
        } else if (this.options.selection.length > 0 || this.options.selection.inverted) {
          this._userOptionChange('selected', selectionKeySet, null);
        }
      },
      /**
       * Renders the TreeView.
       * @private
       */
      _render: function () {
        var self = this;
        this.element[0].classList.remove(this.constants.OJ_COMPLETE);
        this._keyList = new Set(); // list of existing node keys
        var ulElementList = this.element[0].querySelectorAll('ul');
        var i;
        if (this.options.data) {
          for (i = 0; i < ulElementList.length; i++) {
            ulElementList[i].parentNode.removeChild(ulElementList[i]);
          }
          this._fetchChildren(null, function (response) {
            var fetchListResult = response.values[0];
            self._truncateIfOverMaxCount(fetchListResult.value);
            var params = { fetchListResult: fetchListResult.value, parentElem: self.element[0] };
            self._renderItems(params).then(function () {
              self._resetFocus();
              self.element[0].classList.add(self.constants.OJ_COMPLETE);
              self._decorateTree();
              self._lastSelectedItem = null;
            });
          });
        } else {
          for (i = 0; i < ulElementList.length; i++) {
            ulElementList[i].classList.add(this.constants.OJ_TREEVIEW_LIST);
            ulElementList[i].setAttribute('role', 'group');
          }
          var liElementList = this.element[0].querySelectorAll('li');
          for (i = 0; i < liElementList.length; i++) {
            var itemContent = this._getItemContent(liElementList[i]);
            if (itemContent) {
              var disclosureIcon = this._getItemDisclosureIcon(itemContent);
              if (disclosureIcon) {
                itemContent.removeChild(disclosureIcon);
              }
            }
            self._decorateItem(liElementList[i]);
          }
          this._resetFocus();
          this._decorateTree();
          if (this._isLeafOnlySelectionEnabled()) {
            this._rawData = this._buildStaticRawData([], this._getRoot());
            this._initLeafOnlySelectionMode();
          }
          this.element[0].classList.add(this.constants.OJ_COMPLETE);
        }
      },
      _buildStaticRawData: function (rawData, subtree) {
        for (let i = 0; i < subtree.children.length; i++) {
          const item = { key: this._getKey(subtree.children[i]) };
          if (!this._isLeaf(subtree.children[i])) {
            item.children = this._buildStaticRawData([], this._getSubtree(subtree.children[i]));
          }
          rawData.push(item);
        }
        return rawData;
      },
      _getDataProvider: function () {
        var self = this;
        var data;
        if (self.m_dataSource == null) {
          data = self.options.data;
          if (!oj.DataProviderFeatureChecker.isTreeDataProvider(data)) {
            var adapterPromise = new Promise(function (resolve, reject) { require(['ojs/ojtreedataprovideradapter'], function (m) { resolve(_interopNamespace(m)); }, reject) });
            if (!adapterPromise) {
              throw new Error('Error adapting a TreeDataSource');
            }
            return adapterPromise.then(
              // eslint-disable-next-line new-cap
              (TreeDataSourceAdapter) => new TreeDataSourceAdapter.default(data)
            );
          }
        } else {
          data = self.m_dataSource;
        }

        return Promise.resolve(data);
      },
      /**
       * Fetch the children of a parent item from the data source.
       * @param {string} parentKey The key of the parent item.
       * @param {Function} successFunc The function to be called if the fetch is successful.
       * @private
       */
      _fetchChildren: function (parentKey, successFunc) {
        var self = this;
        var dataProviderPromiseBusyResolve = self._addBusyState('getting data provider', parentKey);
        var dataProviderPromise = self._getDataProvider();
        var refreshing = this._refreshId;

        dataProviderPromise.then(
          function (dataProvider) {
            dataProviderPromiseBusyResolve();

            // bail out of the fetch if the component was refreshed
            if (self._refreshId !== refreshing) {
              return;
            }
            self.m_dataSource = dataProvider;

            var childDataProvider =
              parentKey === null ? dataProvider : dataProvider.getChildDataProvider(parentKey);
            if (childDataProvider != null) {
              var busyResolve = self._addBusyState('fetching data', parentKey);
              var delay = self._getShowStatusDelay();
              if (self._isSkeletonSupported()) {
                self._skeletonTimeout = setTimeout(function () {
                  var rootMap = self._expandedChildrenMap.get(null);
                  if (parentKey === null) {
                    self._changeStatusMessage(null, false);
                    self._renderInitialSkeletons();
                  } else if (
                    !rootMap &&
                    !self._isParentSkeletonRendered(parentKey) &&
                    !self._isLeafOnlySelectionEnabled()
                  ) {
                    var parentItem = self._getItemByKey(parentKey);
                    if (parentItem) {
                      var parentSubtree = self._getSubtree(parentItem);
                      if (!parentSubtree) {
                        self._renderChildSkeletons(parentKey);
                        self._changeStatusMessage(parentKey, false);
                      }
                    }
                  }
                }, delay);
              }
              var enginePromise = self._loadTemplateEngine();

              // Create a clientId symbol that uniquely identify this consumer so that
              // DataProvider which supports it can optimize resources
              self._clientId = self._clientId || Symbol();

              // size -1 to fetch all rows
              var options = { clientId: self._clientId, size: -1 };
              var dataProviderAsyncIterator = childDataProvider
                .fetchFirst(options)
                [Symbol.asyncIterator]();
              var promise = dataProviderAsyncIterator.next();

              // new helper function to be called in recursion to fetch all data.
              var helperFunction = function (values) {
                // skip additional fetching if done
                if (values[0].done) {
                  self._clearSkeletonTimeout();
                  if (self._isLeafOnlySelectionEnabled()) {
                    self._buildRawData(parentKey, values[0]);
                  }
                  if (self._isSkeletonSupported()) {
                    var expandedChildren = [];
                    var children = values[0].value.data;
                    for (var i = 0; i < children.length; i++) {
                      var childKey = values[0].value.metadata[i].key;
                      if (
                        self._isInitExpanded(childKey) &&
                        self.m_dataSource.getChildDataProvider(childKey)
                      ) {
                        expandedChildren.push(childKey);
                      }
                    }
                    self._expandedChildrenMap.set(parentKey, expandedChildren);
                    var currentExpandedChildren = self._expandedChildrenMap.get(parentKey);
                    if (currentExpandedChildren) {
                      var index = currentExpandedChildren.indexOf(parentKey);
                      if (index > -1) {
                        currentExpandedChildren.splice(index, 1);
                      }
                    }
                    if (!currentExpandedChildren || currentExpandedChildren.length === 0) {
                      return {
                        values: values,
                        shouldRemoveSkeleton: true
                      };
                    }
                  }
                  return {
                    values: values,
                    shouldRemoveSkeleton: false
                  };
                }
                var nextPromise = dataProviderAsyncIterator.next();
                return nextPromise.then(
                  function (value) {
                    // bail out of the fetch if the component was refreshed
                    if (self._refreshId !== refreshing) {
                      return null;
                    }
                    // eslint-disable-next-line no-param-reassign
                    values[0].done = value.done;
                    // eslint-disable-next-line no-param-reassign
                    values[0].value.data = values[0].value.data.concat(value.value.data);
                    // eslint-disable-next-line no-param-reassign
                    values[0].value.metadata = values[0].value.metadata.concat(value.value.metadata);
                    return helperFunction(values);
                  },
                  function (reason) {
                    Logger.error(self.constants.ERROR_FETCHING_DATA + reason);
                    busyResolve();
                  }
                );
              };

              Promise.all([promise, enginePromise])
                .then(
                  function (values) {
                    // bail out of the fetch if the component was refreshed
                    if (self._refreshId !== refreshing) {
                      return null;
                    }
                    return helperFunction(values);
                  },
                  function (reason) {
                    return Promise.reject(reason);
                  }
                )
                .then(
                  function (values) {
                    // bail out of the fetch if the component was refreshed
                    if (self._refreshId !== refreshing) {
                      busyResolve();
                      return;
                    }
                    successFunc(values);
                    busyResolve();
                  },
                  function (reason) {
                    Logger.error(self.constants.ERROR_FETCHING_DATA + reason);
                    var skeletonContainer = self._getSkeletonContainer(self.element[0]);
                    if (self._isSkeletonSupported() && skeletonContainer) {
                      self._removeSkeleton(null);
                    }
                    busyResolve();
                  }
                );
            }
          },
          function (reason) {
            Logger.error(self.constants.ERROR_FETCHING_DATA + reason);
            dataProviderPromiseBusyResolve();
            self._expandedChildrenMap = new Map();
            self.m_fetching = new Map();
          }
        );
      },
      _clearSkeletonTimeout: function () {
        if (this._skeletonTimeout) {
          clearTimeout(this._skeletonTimeout);
          this._skeletonTimeout = null;
        }
      },
      _buildRawData: function (parentKey, values) {
        if (parentKey === null) {
          this._rawData = values.value.metadata;
        } else {
          this._findParentAndAddChildren(this._rawData, values.value.metadata, parentKey);
        }
      },
      _findParentAndAddChildren: function (searchArray, children, parentKey) {
        for (var i = 0; i < searchArray.length; i++) {
          if (searchArray[i].key === parentKey) {
            // eslint-disable-next-line no-param-reassign
            searchArray[i].children = children;
            return;
          } else if (searchArray[i].children) {
            this._findParentAndAddChildren(searchArray[i].children, children, parentKey);
          }
        }
      },
      _isParentSkeletonRendered: function (key) {
        var item = this._getItemByKey(key);
        var parents = this._getParents(item, this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM);
        for (var i = 0; i < parents.length; i++) {
          var parentKey = this._getKey(parents[i]);
          var parentMapEntry = this._expandedChildrenMap.get(parentKey);
          if (parentMapEntry) {
            return true;
          }
        }
        return false;
      },
      _getShowStatusDelay: function () {
        const defaultOptions = this._getOptionDefaults();
        return DomUtils.getCSSTimeUnitAsMillis(defaultOptions.showIndicatorDelay);
      },
      /**
       * Render the TreeView items after the data is fetched.
       * @param {Object} params An object containing parameters relevant for rendering.
       * @private
       */
      _renderItems: function (params) {
        return new Promise(
          function (resolve) {
            var ulElem = document.createElement('ul');
            ulElem.classList.add(this.constants.OJ_TREEVIEW_LIST);
            ulElem.setAttribute('role', 'group');
            var skeletonContainer = this._getSkeletonContainer(this.element[0]);
            if (
              (skeletonContainer && this._isSkeletonSupported()) ||
              this._isLeafOnlySelectionEnabled()
            ) {
              ulElem.style.display = 'none';
            }
            params.parentElem.appendChild(ulElem); // @HTMLUpdateOK
            for (var i = 0; i < params.fetchListResult.data.length; i++) {
              this._renderItem(ulElem, params.fetchListResult, i);
            }
            if (
              skeletonContainer &&
              this._isSkeletonSupported() &&
              !this._isLeafOnlySelectionEnabled()
            ) {
              this._toggleParentDisplay(params.parentElem, resolve);
            } else {
              resolve();
            }
          }.bind(this)
        );
      },
      /**
       * Gets the value of getScrollPolicyOptions from the treeview.
       * @private
       */
      _getScrollPolicyOptions: function () {
        return this.options.scrollPolicyOptions;
      },
      /**
       * Checks if fetched data is greater then maxCount and returns amount over.
       * @private
       */
      _validateScrollPolicyOptions: function (fetchListResultLength) {
        var scrollPolicyOptions = this._getScrollPolicyOptions();
        var potentialTotalCount = this._getTreeViewItemCount() + fetchListResultLength;
        if (scrollPolicyOptions.maxCount < potentialTotalCount) {
          Logger.info(
            'ScrollPolicyOptions max count of [' +
              scrollPolicyOptions.maxCount +
              '] has been reached.'
          );
        }
        return potentialTotalCount - scrollPolicyOptions.maxCount;
      },
      /**
       * Truncates fetched data if over maxCount.
       * @private
       */
      _truncateIfOverMaxCount: function (fetchListResultValue) {
        const valueLength = fetchListResultValue.data.length;
        const offset = this._validateScrollPolicyOptions(valueLength);
        // over max count need to truncate
        if (offset === valueLength) {
          // entire fetchListLength is over maxCount, remove all
          // eslint-disable-next-line no-param-reassign
          fetchListResultValue.data = [];
          // eslint-disable-next-line no-param-reassign
          fetchListResultValue.metadata = [];
        } else if (offset > 0) {
          // part of fetchListLength is over maxCount, remove
          fetchListResultValue.data.splice(-offset, valueLength);
          fetchListResultValue.metadata.splice(-offset, valueLength);
        }
      },
      /**
       * Recursively walks _expandedChildrenMap to see if it needs to toggle the parents display style if all expanded children have been fetched.
       * @param {Element} item The item element.
       * @param {Function} resolve The function to resolve the rendering busy state.
       * @private
       */
      _toggleParentDisplay: function (item, resolve) {
        var itemKey = this._getKey(item);
        if (item === this.element[0]) {
          itemKey = null;
        }
        var childExpandedKeys = this._expandedChildrenMap.get(itemKey);
        if (childExpandedKeys && childExpandedKeys.length > 0) {
          resolve();
        } else {
          let key = null;
          // eslint-disable-next-line no-restricted-syntax
          for (key of this._expandedChildrenMap.keys()) {
            var parentExpandedChildren = this._expandedChildrenMap.get(key);
            var keyItem;
            var subtree;
            if (key === null) {
              keyItem = this.element[0];
              subtree = this._getRoot();
            } else {
              keyItem = this._getItemByKey(key);
              subtree = this._getSubtree(keyItem);
              this._setItemExpanded(keyItem);
            }
            if (subtree && parentExpandedChildren.length === 0) {
              this._resolveNoChildren(key, keyItem, subtree, resolve);
            }
            for (var i = parentExpandedChildren.length - 1; i >= 0; i--) {
              if (parentExpandedChildren[i] === itemKey) {
                if (subtree) {
                  parentExpandedChildren.splice(i, 1);
                  if (parentExpandedChildren.length === 0) {
                    this._resolveNoChildren(key, keyItem, subtree, resolve);
                  }
                }
              }
            }
          }
          resolve();
        }
      },
      /**
       * Removes skeleton after it has been found.
       * @param {Object} key The key of the item where the skeleton is.
       * @param {Element} keyItem The Element the key belongs to.
       * @param {Element} subtree The subtree ul element.
       * @param {Function} resolve The function to resolve the rendering busy state.
       * @private
       */
      _resolveNoChildren: function (key, keyItem, subtree, resolve) {
        this._expandedChildrenMap.delete(key);
        var skeletonContainer = this._getSkeletonContainer(keyItem);
        if (skeletonContainer && !this._isLeafOnlySelectionEnabled()) {
          this._foundSkeleton(key, subtree, resolve);
        } else if (!this._isLeafOnlySelectionEnabled()) {
          if (subtree) {
            // eslint-disable-next-line no-param-reassign
            subtree.style.display = 'block';
          }
          this._toggleParentDisplay(keyItem, resolve);
        }
      },
      /**
       * Removes skeleton after it has been found.
       * @param {Object} key The key of the item where the skeleton is.
       * @param {Element} subtree The subtree ul element.
       * @param {Function} resolve The function to resolve the rendering busy state.
       * @private
       */
      _foundSkeleton: function (key, subtree, resolve) {
        var skeletonRemovedPromise = this._removeSkeleton(key);
        skeletonRemovedPromise.then(
          function () {
            if (subtree) {
              // eslint-disable-next-line no-param-reassign
              subtree.style.display = 'block';
            }
            var defaults = this._getOptionDefaults();
            ojanimation.fadeIn(subtree, { duration: defaults.dataFadeInDuration });
            resolve();
          }.bind(this)
        );
      },
      /**
       * Render a TreeView item after the data is fetched.
       * @param {Element} ulElem The <ul> to attach the item to.
       * @param {oj.FetchListResult} fetchListResult The array of item data returned by the data source.
       * @param {number} index The index of the item.
       * @param {boolean} replace Coming from change mutation event.
       * @private
       */
      _renderItem: function (ulElem, fetchListResult, index, insertIndex, replace) {
        var self = this;
        var i;
        var textWrapper;

        // eslint-disable-next-line no-param-reassign
        // index += nodeSet.getStart();
        var data = fetchListResult.data[index];
        var metadata = fetchListResult.metadata[index];
        var key = metadata.key;

        // Prevent infinite recursion due to duplicated keys ()
        if (!replace) {
          if (this._keyList.has(key)) {
            throw new Error('JET TreeView nodes should not have duplicated keys: ' + key);
          }
          this._keyList.add(key);
        }

        var liElem = document.createElement('li');

        if (replace) {
          var oldElem = this._getItemByKey(key);
          if (oldElem) {
            // eslint-disable-next-line no-param-reassign
            ulElem = oldElem.parentNode;
            var oldSubtree = this._getSubtree(oldElem);
            oldElem.parentNode.replaceChild(liElem, oldElem);
          } else {
            return; // nothing to replace
          }
        } else if (insertIndex == null || insertIndex >= ulElem.children.length) {
          ulElem.appendChild(liElem); // @HTMLUpdateOK
        } else {
          ulElem.insertBefore(liElem, ulElem.children[insertIndex]); // @HTMLUpdateOK
        }
        var context = {
          parentElement: $(liElem),
          index: index,
          data: data,
          datasource: self.options.data,
          parentKey: self._getKey(self._getParentItem(liElem)),
          metadata: metadata,
          component: ojcomponentcore.__GetWidgetConstructor(self.element)
        };

        if (self._FixRendererContext) {
          context = self._FixRendererContext(context);
        }

        // dataSource always set by this point as it is post fetch
        var childDataProvider = self.m_dataSource.getChildDataProvider(key);
        metadata.leaf = childDataProvider === null;
        metadata.depth = this._getDepth(liElem);

        // Merge properties from metadata into item context
        var props = Object.keys(metadata);
        for (i = 0; i < props.length; i++) {
          var prop = props[i];
          context[prop] = metadata[prop];
        }

        var renderer = self.options.item.renderer;
        renderer = self._WrapCustomElementRenderer(renderer);
        var templateElement = this._getItemTemplate();
        var templateEngine = this._getTemplateEngine();

        if (renderer != null) {
          DataCollectionUtils.applyRendererContent(liElem, renderer.call(self, context), true);
        } else if (templateElement != null && templateEngine != null) {
          var componentElement = self.element[0];
          var nodes = templateEngine.execute(componentElement, templateElement, context, null);
          for (i = 0; i < nodes.length; i++) {
            if (nodes[i].tagName === 'LI') {
              liElem.parentNode.replaceChild(nodes[i], liElem);
              liElem = nodes[i];
              break;
            } else {
              liElem.appendChild(nodes[i]); // @HTMLUpdateOK
            }
          }
        } else {
          textWrapper = document.createElement('span');
          textWrapper.appendChild(document.createTextNode(data == null ? '' : data.toString())); // @HTMLUpdateOK
          liElem.appendChild(textWrapper); // @HTMLUpdateOK
        }
        // eslint-disable-next-line block-scoped-var
        if (replace && oldSubtree) {
          // eslint-disable-next-line block-scoped-var
          liElem.appendChild(oldSubtree);
        }

        // Get the item from root again as template replaces the item element
        liElem = ulElem.children[insertIndex != null ? insertIndex : index];

        context.parentElement = $(liElem);

        // Set id on the liElem if not set by the renderer
        if (!liElem.hasAttribute('id')) {
          liElem.setAttribute('id', this._getUniqueItemId());
        }

        liElem[this.constants.OJ_ITEM_DATA] = data;
        liElem[this.constants.OJ_ITEM_METADATA] = metadata;

        self._decorateItem(liElem);
      },
      /**
       * @param {Element} elem The li element to get depth of.
       * @return {number} depth from the li, 1 is top level
       * @private
       * @memberof oj.ojTreeView
       */
      _getDepth: function (elem) {
        var depth = 0;
        var curr = elem;
        while (curr && curr !== this.element[0]) {
          curr = curr.parentElement.parentElement;
          depth += 1;
        }
        return depth;
      },
      /**
       * Initiate loading of the template engine.  An error is thrown if the template engine failed to load.
       * @return {Promise} resolves to the template engine, or null if:
       *                   1) there's no need because no item template is specified
       *                   2) a renderer is present which takes precedence
       * @private
       * @memberof oj.ojTreeView
       */
      _loadTemplateEngine: function () {
        if (this._getItemTemplate() != null && this.options.item.renderer == null) {
          return new Promise((resolve) => {
            const templateOptions = {
              customElement: this._GetCustomElement()
            };
            ojconfig.__getTemplateEngine(templateOptions).then(
              (engine) => {
                this.m_engine = engine;
                resolve(engine);
              },
              (reason) => {
                throw new Error('Error loading template engine: ' + reason);
              }
            );
          });
        }

        return Promise.resolve(null);
      },
      /**
       * Retrieve the template engine, returns null if it has not been loaded yet
       * @private
       * @memberof oj.ojTreeView
       */
      _getTemplateEngine: function () {
        return this.m_engine;
      },
      /**
       * Returns the inline template element inside oj-tree-view
       * @return {Element|null} the inline template element
       * @private
       * @memberof oj.ojTreeView
       */
      _getItemTemplate: function () {
        if (this.m_template === undefined) {
          // cache the template, assuming replacing template will require refresh
          this.m_template = null;
          var slotMap = this._getSlotMap();
          var slot = slotMap.itemTemplate;
          if (slot && slot.length > 0 && slot[0].tagName.toLowerCase() === 'template') {
            this.m_template = slot[0];
          }
        }
        return this.m_template;
      },
      /**
       * Returns the slot map object.
       * @return {object} slot Map
       * @private
       * @memberof oj.ojTreeView
       */
      _getSlotMap: function () {
        return ojcustomelementUtils.CustomElementUtils.getSlotMap(this.element[0]);
      },
      /**
       * Adds the necessary attributes to a TreeView root element.
       * @private
       */
      _decorateTree: function () {
        var self = this;
        // Keyboard focus and ARIA attributes
        var root = this._getRoot();
        if (root) {
          this._focusable({
            element: $(root),
            applyHighlight: true,
            setupHandlers: function (focusInHandler, focusOutHandler) {
              self._focusInHandler = focusInHandler;
              self._focusOutHandler = focusOutHandler;
            }
          });
          root.setAttribute('tabIndex', 0);
          $(root)
            .on('focus', function () {
              self._focusInHandler($(self._getItemContent(self._currentItem)));
            })
            .on('blur', function () {
              self._focusOutHandler($(self._getItemContent(self._currentItem)));
            });
          root.setAttribute('role', 'tree');
          root.setAttribute('aria-labelledby', this.element[0].getAttribute('id'));

          var selectionMode = this.options.selectionMode;
          if (selectionMode !== 'none') {
            root.setAttribute(
              'aria-multiselectable',
              this._isMultiSelectionEnabled() || this._isLeafOnlySelectionEnabled() ? 'true' : 'false'
            );
          } else {
            root.removeAttribute('aria-multiselectable');
          }

          if (selectionMode === 'single') {
            this.element[0].classList.add(this.constants.OJ_TREEVIEW_SELECT_SINGLE);
          }

          // programmatically setting focus treeview should also handle focus
          this.element[0].setAttribute('tabIndex', -1);
          this.element[0].addEventListener('focus', () => {
            this._getRoot().focus();
          });
          this.element[0].addEventListener('blur', () => {
            this._getRoot().blur();
          });
          this._refreshTopAndBottomSelectionClasses();
        }
      },
      _isMultiSelectionEnabled: function () {
        return this.options.selectionMode === 'multiple';
      },
      _isLeafOnlySelectionEnabled: function () {
        return this.options.selectionMode === 'leafOnly';
      },
      _isDefaultCheckBoxesEnabled: function () {
        var defaults = this._getOptionDefaults();
        return (
          defaults.multipleSelectionAffordance === 'selector' &&
          (this._isMultiSelectionEnabled() || this._isLeafOnlySelectionEnabled())
        );
      },
      _refreshSelectionItems: function () {
        const selectionMode = this.options.selectionMode;
        if (selectionMode === 'none') {
          return;
        }
        const selected = this._getSelected();
        const newSelectedItems = this._getItemsInSelectedKeySet(selected);
        const currentSelectedItemContents = this._getSelectedItemContents();
        for (let i = currentSelectedItemContents.length - 1; i >= 0; i--) {
          const selectedItem = currentSelectedItemContents[i].parentElement;
          const indexOfSelectedItem = newSelectedItems.indexOf(selectedItem);
          if (indexOfSelectedItem !== -1) {
            newSelectedItems.splice(indexOfSelectedItem, 1);
          } else {
            this._setUnselected(selectedItem);
          }
        }

        for (let i = 0; i < newSelectedItems.length; i++) {
          this._setSelected(newSelectedItems[i]);
        }

        if (this._isLeafOnlySelectionEnabled()) {
          this._updateIndeterminateState(this._selectedKeysets.partialParents);
        }
        this._refreshTopAndBottomSelectionClasses();
      },
      _getItemsInSelectedKeySet: function (selected) {
        const selectedItems = [];
        if (selected.isAddAll()) {
          this._getItems().forEach((item) => {
            const key = this._getKey(item);
            if (!selected.deletedValues().has(key) && this._isActionable(item, 'select')) {
              selectedItems.push(item);
            }
          });
        } else {
          selected.values().forEach((key) => {
            const item = this._getItemByKey(key);
            if (item && this._isActionable(item, 'select')) {
              selectedItems.push(item);
            }
          });
        }
        return selectedItems;
      },
      /**
       * Adds the necessary attributes to a TreeView item element.
       * @param {Element} item The item element to decorate.
       * @private
       */
      _decorateItem: function (item) {
        item.classList.add(this.constants.OJ_TREEVIEW_ITEM);
        item.setAttribute('role', 'treeitem');
        var itemKey = this._getKey(item);

        // Create wrapper for item icon and text
        var itemContent = this._getItemContent(item);
        if (!itemContent) {
          // Wrap everything except the subtree
          // Use innerHTML to include text and comment nodes as well
          itemContent = document.createElement('div');
          itemContent.classList.add(this.constants.OJ_TREEVIEW_ITEM_CONTENT);

          if (
            this._isDefaultCheckBoxesEnabled() &&
            this._isActionable(item, 'focus') &&
            this._isActionable(item, 'select')
          ) {
            var selectorSpan = document.createElement('span');
            selectorSpan.classList.add(this.constants.OJ_TREEVIEW_SELECTOR);
            var selector = document.createElement('oj-selector');
            var selected = this._getSelected();
            if (selected.has(itemKey)) {
              selector.selectedKeys = new ojkeyset.KeySetImpl([itemKey]);
            } else {
              selector.selectedKeys = new ojkeyset.KeySetImpl();
            }
            selector.setAttribute('aria-hidden', 'true');
            selector.setAttribute('data-oj-binding-provider', 'none');
            selector.setAttribute('selection-mode', 'multiple');
            selector.addEventListener(
              'selectedKeysChanged',
              function (event) {
                if (event.detail.updatedFrom === 'internal') {
                  var selectedItem = this._getItemByKey(event.target.rowKey);
                  this._focus(selectedItem, event);
                  var currentSelected = this._getSelected();
                  if (currentSelected.has(event.target.rowKey)) {
                    currentSelected = currentSelected.delete([event.target.rowKey]);
                  } else {
                    currentSelected = currentSelected.add([event.target.rowKey]);
                    this._selectionAnchor = event.target.rowKey;
                  }
                  this._userSelectedOptionChange(currentSelected, event);
                }
              }.bind(this)
            );
            selector.rowKey = itemKey;
            selectorSpan.appendChild(selector); // @HTMLUpdateOK
            itemContent.appendChild(selectorSpan); // @HTMLUpdateOK
            var busyContext = Context.getContext(selector).getBusyContext();
            busyContext.whenReady().then(() => {
              DataCollectionUtils.disableAllFocusableElements(selector);
            });
          }

          if (item.firstChild) {
            do {
              itemContent.appendChild(item.firstChild); // @HTMLUpdateOK
            } while (item.childNodes.length > 0);
          }

          item.appendChild(itemContent); // @HTMLUpdateOK
          // Take the subtree out of the itemContent wrapper

          var innerTree = itemContent.getElementsByTagName('ul')[0];
          if (innerTree) {
            item.appendChild(innerTree); // @HTMLUpdateOK
          }
          var treeViewItems = itemContent.querySelectorAll(
            this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM_ICON
          );
          for (let i = 0; i < treeViewItems.length; i++) {
            treeViewItems[i].classList.add(this.constants.OJ_TREEVIEW_ICON);
            treeViewItems[i].classList.add(this.constants.OJ_COMPONENT_ICON);
          }
        }
        // Initial selection
        this._select(item);

        // DnD
        itemContent.setAttribute('draggable', this._isDnD() ? 'true' : 'false');

        // Create disclosure icon or spacer
        var disclosureIcon = this._getItemDisclosureIcon(itemContent);
        var indentElement = this._getItemSpacer(itemContent);

        if (!disclosureIcon) {
          disclosureIcon = document.createElement('ins');
          this._addTreeViewIconClass(disclosureIcon);
          if (indentElement) {
            itemContent.insertBefore(disclosureIcon, indentElement.nextElementSibling); // @HTMLUpdateOK
          } else {
            itemContent.insertBefore(disclosureIcon, itemContent.children[0]); // @HTMLUpdateOK
          }
        }

        if (!indentElement) {
          indentElement = document.createElement('span');
          this._addTreeviewSpacerClass(indentElement);
          itemContent.insertBefore(indentElement, disclosureIcon); // @HTMLUpdateOK
        }

        this._addIndentation(item, indentElement);
        if (this._isDnD()) {
          item.classList.add(this.constants.OJ_DRAGGABLE);
          itemContent.classList.add(this.constants.OJ_DRAGGABLE);
        }

        if (this._isLeaf(item)) {
          this._addTreeviewLeafClass(item);
        } else if (this._isInitExpanded(itemKey)) {
          this._expand(item, false);
          this._addDisclosureClasses(disclosureIcon);
        } else {
          this._collapse(item, false);
          this._addDisclosureClasses(disclosureIcon);
        }
      },
      /**
       * Add the indentation on a spacer
       * @private
       */
      _addIndentation: function (item, spacer) {
        // 0 index the depth for style purposes
        let depth = this._getDepth(item) - 1;
        const spacerStyle = spacer.style;
        const isRedwood = ThemeUtils.parseJSONFromFontFamily('oj-theme-json').behavior === 'redwood';
        let paddingOffset = 0;
        if (this._hasIcon(item) && isRedwood) {
          /* in redwood treeview icons have margin-inline-end: 0.5rem to add space between icon and text,
            if our items have icons we need to add 0.5 * depth to spacer to properly align them */
          paddingOffset = depth * this.constants.TREEVIEW_CONTENT_PADDING_REM;
        }
        if (this._isLeaf(item)) {
          depth += 1;
        }
        spacerStyle.width =
          'calc(calc(' + depth + ' * var(--oj-tree-view-indent-width)) + ' + paddingOffset + 'rem)';
      },
      _hasIcon: function (item) {
        return item.querySelectorAll('.oj-treeview-icon.oj-component-icon').length > 0;
      },
      /**
       * removes the indentation on the spacer
       * @private
       */
      _removeIndentation: function (spacer) {
        spacer.style.removeProperty('width');
        spacer.removeAttribute('class');
        spacer.classList.add(this.constants.OJ_TREEVIEW_SPACER);
      },
      _addTreeviewSpacerClass: function (item) {
        item.classList.add(this.constants.OJ_TREEVIEW_SPACER);
      },
      _addTreeViewIconClass: function (item) {
        item.classList.add(this.constants.OJ_TREEVIEW_ICON);
      },
      _addTreeviewLeafClass: function (item) {
        item.classList.add(this.constants.OJ_TREEVIEW_LEAF);
      },
      _removeTreeviewLeafClass: function (item) {
        item.classList.remove(this.constants.OJ_TREEVIEW_LEAF);
      },
      _addDisclosureClasses: function (item) {
        item.classList.add(this.constants.OJ_TREEVIEW_DISCLOSURE_ICON);
        item.classList.add(this.constants.OJ_COMPONENT_ICON);
        item.classList.add(this.constants.OJ_CLICKABLE_ICON_NOCONTEXT);
        item.classList.add(this.constants.OJ_DEFAULT);
      },
      _removeDisclosureClasses: function (item) {
        item.classList.remove(this.constants.OJ_TREEVIEW_DISCLOSURE_ICON);
        item.classList.remove(this.constants.OJ_COMPONENT_ICON);
        item.classList.remove(this.constants.OJ_CLICKABLE_ICON_NOCONTEXT);
        item.classList.remove(this.constants.OJ_DEFAULT);
      },
      /**
        /**
         * Returns all the item elements that belongs to the TreeView.
         * @return {Element} All the item elements that belongs to the TreeView.
         * @private
         */
      _getItems: function () {
        return this.element[0].querySelectorAll(
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM
        );
      },

      /**
       * Returns the key of the provided item.
       * @param {Element} item The TreeView item element.
       * @return {any} The key.
       * @private
       */
      _getKey: function (item) {
        if (!item) {
          return null;
        }
        // Rely on the key in the metadata first. The DOM id stringifies the key,
        // so it won't return the correct key if the key isn't string.
        var metadata = item[this.constants.OJ_ITEM_METADATA];
        if (metadata) {
          return metadata.key;
        }
        return item.getAttribute('id');
      },

      /**
       * Returns the item element that is identified by the provided key.
       * @param {string} key The key.
       * @return {Element} The item element.
       * @private
       */
      _getItemByKey: function (key) {
        // Rely on the key in the metadata first. The DOM id stringifies the key,
        // so it won't return the correct key if the key isn't string.
        var itemList = this.element[0].getElementsByTagName('li');
        var item;
        for (var i = 0; i < itemList.length; i++) {
          var metadata = itemList[i][this.constants.OJ_ITEM_METADATA];
          if (metadata) {
            if (oj.KeyUtils.equals(metadata.key, key)) {
              item = itemList[i];
              break;
            }
          }
        }
        if (item) {
          return item;
        }
        if (typeof key === 'string') {
          var keyElement = document.getElementById(key);
          var root = this._getRoot();
          if (root) {
            if (keyElement && root.contains(keyElement)) {
              return keyElement;
            }
          }
        }
        return undefined;
      },

      /**
       * Returns the content element of the provided item element.
       * @param {Element} item The TreeView item element.
       * @return {Element} The item content element.
       * @private
       */
      _getItemContent: function (item) {
        if (!item) {
          return null;
        }
        // : _getItemContent can give you non direct children's content
        var children = item.children;
        for (var i = 0; i < children.length; i++) {
          if (
            item.children[i].classList &&
            item.children[i].classList.contains(this.constants.OJ_TREEVIEW_ITEM_CONTENT)
          ) {
            return item.children[i];
          }
        }
        return null;
      },
      /**
       * Returns the child items of the provided item element.
       * @param {Element} item The TreeView item element.
       * @return {Element} The child item elements.
       * @private
       */
      _getChildItems: function (item) {
        var listElements = [];
        var firstSubList = item.getElementsByClassName(this.constants.OJ_TREEVIEW_LIST)[0];
        if (firstSubList) {
          var children = firstSubList.children;
          for (var i = 0; i < children.length; i++) {
            listElements.push(children[i]);
          }
        }
        return listElements;
      },
      /**
       * Returns the parent item of the provided item element.
       * @param {Element} item The TreeView item element.
       * @return {Element} The parent item element.
       * @private
       */
      _getParentItem: function (item) {
        var parentListElement = this._getParents(item, '.oj-treeview-list')[0];
        return this._getParents(
          parentListElement,
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM
        )[0];
      },

      /**
       * Returns the subtree element (ul) of the provided item element.
       * @param {Element} item The TreeView item element.
       * @return {Element} The subtree element (ul).
       * @private
       */
      _getSubtree: function (item) {
        return item.getElementsByClassName(this.constants.OJ_TREEVIEW_LIST)[0];
      },

      /**
       * Returns the root ul of the TreeView.
       * @return {Element}
       * @private
       */
      _getRoot: function () {
        return this.element[0].getElementsByClassName(this.constants.OJ_TREEVIEW_LIST)[0];
      },

      /**
       * Returns whether the item is a leaf item.
       * @param {Element} item The TreeView item element.
       * @return {boolean}
       * @private
       */
      _isLeaf: function (item) {
        if (!item) {
          return null;
        }
        var metadata = item[this.constants.OJ_ITEM_METADATA];
        var hasChildren = metadata ? !metadata.leaf : this._getSubtree(item) !== undefined;
        return !hasChildren;
      },

      /**
       * Returns whether item element is initially expanded in the TreeView option.
       * Note that the expanded option is not kept in sync with the actual expanded state of the TreeView.
       * @param {Object} key The TreeView items key.
       * @return {boolean}
       * @private
       */
      _isInitExpanded: function (key, uiExpanded) {
        var expanded = uiExpanded != null ? uiExpanded : this.options.expanded;
        return expanded && expanded.has ? expanded.has(key) : false;
      },

      /**
       * Returns whether item element is currently expanded.
       * Note that the expanded option is not kept in sync with the actual expanded state of the TreeView.
       * @param {Element} item The TreeView item element.
       * @return {boolean}
       * @private
       */
      _isExpanded: function (item) {
        return item.classList.contains(this.constants.OJ_EXPANDED);
      },

      /**
       * Whether the group item is currently in the middle of expanding/collapsing
       * @param {Object} key the key of the group item
       * @return {boolean} true if it's expanding/collapsing, false otherwise
       * @private
       */
      _isDisclosing: function (key) {
        if (key && this.m_disclosing) {
          return this.m_disclosing.indexOf(key) > -1;
        }

        return false;
      },

      /**
       * Marks a group item as currently in the middle of expanding/collapsing
       * @param {Object} key the key of the group item
       * @param {boolean} flag true or false
       * @private
       */
      _setDisclosing: function (key, flag) {
        if (key == null) {
          return;
        }

        if (this.m_disclosing == null) {
          this.m_disclosing = [];
        }

        if (flag) {
          this.m_disclosing.push(key);
        } else {
          // there should be at most one entry, but just in case remove all occurrences
          var index = this.m_disclosing.indexOf(key);
          while (index > -1) {
            this.m_disclosing.splice(index, 1);
            index = this.m_disclosing.indexOf(key);
          }
        }
      },
      /**
       * Expands an item.
       * @param {Element} item The TreeView item element.
       * @param {boolean} animate Whether the expand should be animated.
       * @param {Event} event The event that triggers the expand.
       * @param {boolean} vetoable Whether the expand can be vetoed by beforeExpand.
       * @private
       */
      _expand: function (item, animate, event, vetoable) {
        var self = this;
        if (
          this._isExpanded(item) ||
          this._isLeaf(item) ||
          (animate && this._isDisclosing(this._getKey(item)))
        ) {
          return;
        }

        if (animate) {
          var cancelled = !this._trigger('beforeExpand', event, this._getEventPayload(item));
          if (cancelled && vetoable !== false) {
            return;
          }
        }
        if (event && this._isActionable(item, 'focus')) {
          this._focus(item, event);
        }

        var subtree = this._getSubtree(item);
        var key = self._getKey(item);
        if (!subtree) {
          this._uiExpanded = this._uiExpanded.add([key]);
          this._fetchChildren(key, function (response) {
            // if the item is already expanded or is no longer in the expanded option bail early
            // no need to check refreshId because is handled at fetchChildren layer
            // uiExpanded is used because on ui gesture the expanded is not set until
            // fetch/animation completes, so we need an internal expanded option to track that
            if (
              (self._isExpanded(item) && !self._isSkeletonSupported()) ||
              (!self._isInitExpanded(key) && !self._isInitExpanded(key, self._uiExpanded))
            ) {
              return;
            }

            var fetchListResult = response.values[0];
            self._truncateIfOverMaxCount(fetchListResult.value);

            var skeletonContainerLength = item.getElementsByClassName(
              self.constants.OJ_TREEVIEW_SKELETON_CONTAINER
            ).length;
            var params = { fetchListResult: fetchListResult.value, parentElem: item };
            if (
              self._isSkeletonSupported() &&
              skeletonContainerLength > 0 &&
              response.shouldRemoveSkeleton &&
              !self._isLeafOnlySelectionEnabled()
            ) {
              self._renderItems(params).then(function () {
                var itemHeight = item.offsetHeight;
                var skeletonHeight = itemHeight * 3; // Three tiered skeleton
                var contentHeight = itemHeight * fetchListResult.value.data.length;
                subtree = self._getSubtree(item);
                var options = {
                  startMaxHeight: skeletonHeight + 'px',
                  endMaxHeight: contentHeight + 'px'
                };
                if (contentHeight > skeletonHeight) {
                  self._animateSkeletonRemoval('expand', item, subtree, options, event);
                } else if (contentHeight < skeletonHeight) {
                  self._animateSkeletonRemoval('collapse', item, subtree, options, event);
                } else {
                  self._animateSkeletonRemoval('fadeIn', item, subtree, options, event);
                }
              });
            } else if (self._isSkeletonSupported() && skeletonContainerLength > 0) {
              self._renderItems(params).then(function () {
                self._setExpandedState(self, item, event);
                if (self.isReady() && self._isLeafOnlySelectionEnabled()) {
                  self._initLeafOnlySelectionMode();
                }
              });
            } else {
              self._renderItems(params).then(function () {
                self._expandAfterFetch(item, animate, event);
                if (self.isReady() && self._isLeafOnlySelectionEnabled()) {
                  self._initLeafOnlySelectionMode();
                }
              });
            }
          });
          return;
        }
        this._expandAfterFetch(item, animate, event);
      },
      /**
       * Inits leafOnly selectionMode by computing initial selected state.
       * @private
       */
      _initLeafOnlySelectionMode: function () {
        const attributesMap = { keyAttributes: 'key', childrenAttribute: 'children' };
        let createKeyMap = (m) => new Map(m);
        if (this.options.data && this.options.data.createOptimizedKeyMap) {
          createKeyMap = (m) => this.options.data.createOptimizedKeyMap(m);
        }
        let createKeySet = (s) => new Set(s);
        if (this.options.data && this.options.data.createOptimizedKeySet) {
          createKeySet = (s) => this.options.data.createOptimizedKeySet(s);
        }
        this.treeviewSelectionManager = new TreeviewSelectionManager(
          this._rawData,
          attributesMap,
          createKeyMap,
          createKeySet
        );
        this._userSelectedOptionChange(this._filterOutParentKeys(this._getSelected()), null, true);
        var root = this._getRoot();
        var skeletonContainer = this._getSkeletonContainer(this.element[0]);
        if (skeletonContainer) {
          var skeletonRemovedPromise = this._removeSkeleton(null);
          skeletonRemovedPromise.then(
            function () {
              if (root) {
                // eslint-disable-next-line no-param-reassign
                root.style.display = 'block';
              }
              var defaults = this._getOptionDefaults();
              ojanimation.fadeIn(root, { duration: defaults.dataFadeInDuration });
            }.bind(this)
          );
        } else if (root) {
          // eslint-disable-next-line no-param-reassign
          root.style.display = 'block';
        }
      },
      /**
       * Adds necessary expand classes to an item .
       * @param {Element} item The TreeView item element.
       * @private
       */
      _setItemExpanded: function (item) {
        item.classList.remove(this.constants.OJ_COLLAPSED);
        item.classList.add(this.constants.OJ_EXPANDED);
        this._setAriaExpanded(item, 'true');
      },
      /**
       * Animates the collapse or expand after a skeleton has been removed.
       * @param {String} action The animation action.
       * @param {Element} item The TreeView item element.
       * @param {Element} subtree The item's subtree element.
       * @param {Object} option The options for the the animation.
       * @param {Event} event The event that has caused this action.
       * @private
       */
      _animateSkeletonRemoval: function (action, item, subtree, options, event) {
        var key = this._getKey(item);
        var skeletonRemovedPromise = this._removeSkeleton(key);
        skeletonRemovedPromise.then(
          function () {
            this._setItemExpanded(item);
            var self = this;
            var fadeinPromise;
            var defaults = this._getOptionDefaults();
            // eslint-disable-next-line no-param-reassign
            subtree.style.display = 'block';
            fadeinPromise = ojanimation.fadeIn(subtree, { duration: defaults.dataFadeInDuration });
            fadeinPromise.then(
              function () {
                var animationPromise;
                var busyResolve = this._addBusyState('animating skeleton removal', key);
                item.classList.add(this.constants.OJ_TREEVIEW_ANIMATED); // animation flag
                this._setDisclosing(this._getKey(item), true);
                if (action === 'expand') {
                  animationPromise = this._startAnimation(subtree, 'expand', options);
                  animationPromise.then(
                    this._resolveAnimationPromise(self, item, event, busyResolve)
                  );
                } else if (action === 'collapse') {
                  animationPromise = this._startAnimation(subtree, 'collapse', options);
                  animationPromise.then(
                    this._resolveAnimationPromise(self, item, event, busyResolve)
                  );
                } else {
                  var resolve = this._resolveAnimationPromise(self, item, event, busyResolve);
                  resolve();
                }
              }.bind(this)
            );
          }.bind(this)
        );
      },
      /**
       * Expands an item after its child items have been fetched.
       * @param {Element} item The TreeView item element.
       * @param {boolean} animate Whether the expand should be animated.
       * @param {Event} event The event that triggers the expand.
       * @private
       */
      _expandAfterFetch: function (item, animate, event) {
        this._setItemExpanded(item);
        var key = this._getKey(item);

        var subtree = this._getSubtree(item);
        if (subtree) {
          subtree.style.display = 'block';
        }

        if (animate) {
          var busyResolve = this._addBusyState('animating expand', key);
          item.classList.add(this.constants.OJ_TREEVIEW_ANIMATED); // animation flag
          this._setDisclosing(key, true);
          this._startAnimation(subtree, 'expand').then(
            this._resolveAnimationPromise(this, item, event, busyResolve)
          );
        }
      },
      _setExpandedState: function (self, item, event) {
        self._setDisclosing(self._getKey(item), false);
        item.classList.remove(self.constants.OJ_TREEVIEW_ANIMATED);
        self._trigger('expand', event, self._getEventPayload(item));
        // Update option and fire optionChange
        var expanded = self.options.expanded;
        var newExpanded = expanded.add([self._getKey(item)]);
        self._refreshTopAndBottomSelectionClasses();
        self._userOptionChange('expanded', newExpanded, event);
      },
      _resolveAnimationPromise: function (self, item, event, busyResolve) {
        return function () {
          this._setExpandedState(self, item, event);
          busyResolve();
        }.bind(this);
      },
      /**
       * Collapses an item.
       * @param {Element} item The TreeView item element.
       * @param {boolean} animate Whether the collapse should be animated.
       * @param {Event} event The event that triggers the collapse.
       * @param {boolean} vetoable Whether the collapse can be vetoed by beforeCollapse.
       * @private
       */
      _collapse: function (item, animate, event, vetoable) {
        var self = this;
        var key = this._getKey(item);

        if (
          item.classList.contains(this.constants.OJ_COLLAPSED) ||
          this._isLeaf(item) ||
          (animate && this._isDisclosing(key))
        ) {
          return;
        }

        if (event && this._isActionable(item, 'focus')) {
          this._focus(item, event);
        } else if (item.contains(this._currentItem)) {
          var tempItem = item;
          if (!this._isActionable(tempItem, 'focus')) {
            tempItem = this._getPreviousActionableItem(item, 'focus');
            if (!tempItem) {
              tempItem = this._getNextActionableItem(item, 'focus');
            }
          }
          if (tempItem) {
            this._focus(tempItem, event);
          } else {
            this.options.currentItem = null;
            this._resetFocus();
          }
        }

        if (animate) {
          var cancelled = !this._trigger('beforeCollapse', event, this._getEventPayload(item));
          if (cancelled && vetoable !== false) {
            return;
          }
          this._setDisclosing(key, true);
        }

        item.classList.remove(this.constants.OJ_EXPANDED);
        item.classList.add(this.constants.OJ_COLLAPSED);
        this._setAriaExpanded(item, 'false');

        var subtree = this._getSubtree(item);
        if (animate) {
          var busyResolve = this._addBusyState('animating collapse', key);
          item.classList.add(this.constants.OJ_TREEVIEW_ANIMATED); // animation flag

          this._uiExpanded = this._uiExpanded.delete([key]);
          this._startAnimation(subtree, 'collapse').then(function () {
            self._setDisclosing(key, false);
            subtree.style.display = 'none';
            item.classList.remove(self.constants.OJ_TREEVIEW_ANIMATED);
            self._trigger('collapse', event, self._getEventPayload(item));

            // Update option and fire optionChange
            var expanded = self.options.expanded;
            var newExpanded = expanded.delete([key]);
            self._refreshTopAndBottomSelectionClasses();
            self._userOptionChange('expanded', newExpanded, event);
            busyResolve();
          });
        } else if (subtree) {
          subtree.style.display = 'none';
          this._refreshTopAndBottomSelectionClasses();
        }
        if (this._isLeafOnlySelectionEnabled() && !subtree) {
          this._fetchChildren(key, function (response) {
            var fetchListResult = response.values[0];
            self._truncateIfOverMaxCount(fetchListResult.value);
            var params = { fetchListResult: fetchListResult.value, parentElem: item };
            self._renderItems(params).then(function () {
              if (self.isReady() && self._isLeafOnlySelectionEnabled()) {
                self._initLeafOnlySelectionMode();
              }
            });
          });
        }
      },

      /**
       * Starts the animation for the specific action.
       * @param {Element} elem The element to animate.
       * @param {string} action The name of the action to animate.
       * @return {Promise} A promise that will be resolved when the animation ends.
       * @private
       */
      _startAnimation: function (elem, action, options) {
        var defaultAnimations = {};
        if (defaultAnimations[action] == null) {
          defaultAnimations[action] = JSON.parse(this._getOptionDefaults()[`${action}Animation`]);
        }
        var effects = defaultAnimations[action];
        if (options) {
          if (effects.effect === 'expand' || effects.effect === 'collapse') {
            Object.assign(effects, options);
          }
        }
        return ojanimation.startAnimation(elem, action, effects, this);
      },

      /**
       * Returns the default event payload for the provided item element.
       * @param {Element} item The TreeView item element.
       * @return {Object}
       * @private
       */
      _getEventPayload: function (item) {
        return { key: this._getKey(item), item: item };
      },

      /**
       * Returns whether an action (select or focus) can be performed on the item.
       * @param {Element} item The TreeView item element.
       * @param {string} actionName The action name: 'select' or 'focus'.
       * @return {boolean}
       * @private
       */
      _isActionable: function (item, actionName) {
        var actionable = this.options.item[actionName + 'able'];
        if (actionable === false) {
          return false;
        } else if (typeof actionable === 'function') {
          var itemContext = this.getContextByNode(item);
          return actionable(itemContext);
        }
        return true;
      },

      /**
       * Returns whether item element is selected.
       * @param {Element} item The TreeView item element.
       * @return {boolean}
       * @private
       */
      _isSelected: function (item) {
        var selectionMode = this.options.selectionMode;
        var selected = this._getSelected();

        if (selectionMode === 'none') {
          return false;
        }

        var key = this._getKey(item);
        return selected.has(key);
      },
      /**
       * Returns the actual selected state. In leafOnly mode this contains leaves and parents.
       * @return {Object}
       * @private
       */
      _getSelected: function () {
        if (this._isLeafOnlySelectionEnabled() && this._selectedKeysets) {
          return this._selectedKeysets.selected;
        }
        return this.options.selected;
      },
      /**
       * Selects or unselects an item, depending on what triggers the selection.
       * @param {Element} item The TreeView item element.
       * @param {Event} event The event that triggers the select.
       * @private
       */
      _select: function (item, event) {
        var selectionMode = this.options.selectionMode;
        if (selectionMode === 'none') {
          return;
        }

        // Check whether the item is selectable
        if (!this._isActionable(item, 'focus') || !this._isActionable(item, 'select')) {
          return;
        }

        var isSelected = this._isSelected(item);

        if (event) {
          var eventKey = event.key || event.keyCode;
          var sourceCapabilityTouch =
            event.originalEvent.sourceCapabilities &&
            event.originalEvent.sourceCapabilities.firesTouchEvents;
          var isTouch =
            DomUtils.isTouchSupported() &&
            (sourceCapabilityTouch ||
              (this.touchStartEvent != null && this.touchStartEvent.target === event.target));
          var isMetaKey = DomUtils.isMetaKeyPressed(event);
          var isNavigation =
            DataCollectionUtils.isArrowUpKeyEvent(eventKey) ||
            DataCollectionUtils.isArrowDownKeyEvent(eventKey);
          var key = this._getKey(item);
          var selected = new ojkeyset.KeySetImpl();
          if (
            (this._isMultiSelectionEnabled() || this._isLeafOnlySelectionEnabled()) &&
            event.shiftKey &&
            !isNavigation &&
            this._selectionAnchor
          ) {
            let nextItem = this._getItemByKey(this._selectionAnchor);

            if (isMetaKey) {
              selected = this._getSelected();
            }
            // Select a range from the last selected item to the current item
            var getNextItem =
              nextItem && nextItem.offsetTop < item.offsetTop
                ? this._getNextActionableItem.bind(this)
                : this._getPreviousActionableItem.bind(this);

            while (nextItem && nextItem !== item) {
              var nextKey = this._getKey(nextItem);
              if (!selected.has(nextKey)) {
                selected = selected.add([nextKey]);
              }
              nextItem = getNextItem(nextItem, 'select');
            }
            isSelected = true;
            selected = selected.add([key]);
          } else if (
            (this._isMultiSelectionEnabled() || this._isLeafOnlySelectionEnabled()) &&
            (isMetaKey || isTouch || isNavigation)
          ) {
            // Toggle selection of current item while maintaining the selection of the other items
            isSelected = !isSelected;
            selected = this._getSelected();
            if (isSelected) {
              selected = selected.add([key]);
            } else {
              selected = selected.delete([key]);
            }
            this._selectionAnchor = key;
          } else if ((isTouch || DataCollectionUtils.isSpaceBarKeyEvent(eventKey)) && isSelected) {
            // On touch or spacebar, toggle the selection of the current item
            // Otherwise, select the current item even if it is already selected
            isSelected = false;
            selected = new ojkeyset.KeySetImpl();
          } else {
            isSelected = true;
            selected = new ojkeyset.KeySetImpl([key]);
            this._selectionAnchor = key;
          }
          // Since clicking on the item resets the selection, ignore the previous selection when computing the final selection for the leafOnly case.
          this._userSelectedOptionChange(selected, event, !isMetaKey && !isNavigation && !isTouch);
        }

        if (isSelected) {
          this._setSelected(item);
        } else {
          this._setUnselected(item);
        }
      },
      /**
       * Returns a oj-selector by Key.
       * @param {Object} key The key of the item.
       * @private
       */
      _getSelectorByItem: function (item) {
        return item.getElementsByTagName('oj-selector')[0];
      },
      /**
       * Clears old intermediate state and sets new state.
       * @param {Set} partialParents The keyset of the new partial state.
       * @private
       */
      _updateIndeterminateState: function (partialParents) {
        if (!this._isDefaultCheckBoxesEnabled()) {
          return;
        }
        var indeterminateSelectorSpans = Array.from(
          this.element[0].getElementsByClassName('oj-indeterminate')
        );
        var partialParentsArray = Array.from(partialParents.values());
        var selector;
        var i;
        for (i = indeterminateSelectorSpans.length - 1; i >= 0; i--) {
          selector = indeterminateSelectorSpans[i].parentElement;
          var rowKey = selector.rowKey;
          var indexOfPartialParent = partialParentsArray.indexOf(rowKey);
          if (indexOfPartialParent !== -1) {
            partialParentsArray.splice(indexOfPartialParent, 1);
          } else {
            selector.indeterminate = false;
          }
        }
        for (i = 0; i < partialParentsArray.length; i++) {
          var item = this._getItemByKey(partialParentsArray[i]);
          selector = this._getSelectorByItem(item);
          selector.indeterminate = true;
        }
      },
      /**
       * Style the provided item as selected.
       * @param {Element} item The TreeView item element.
       * @private
       */
      _setSelected: function (item) {
        var itemContent = this._getItemContent(item);
        itemContent.classList.add(this.constants.OJ_SELECTED);
        item.setAttribute('aria-selected', 'true');
        var key = this._getKey(item);
        this._setupSelector(key, item, true);
      },
      _isHiddenElement: function (item) {
        const parents = this._getParents(
          item,
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM
        );
        for (let i = 1; i < parents.length; i++) {
          const subtree = this._getSubtree(parents[i]);
          if (subtree && subtree.style.display === 'none' && item !== parents[i]) {
            return true;
          }
        }
        return false;
      },
      _refreshTopAndBottomSelectionClasses: function () {
        if (this._isLeafOnlySelectionEnabled() || this._isMultiSelectionEnabled()) {
          const flatList = this._getFlatList();
          let previousItem;
          flatList.forEach((element) => {
            const itemContent = this._getItemContent(element);
            itemContent.classList.remove(this.constants.OJ_TREEVIEW_SELECTED_TOP_ITEM);
            itemContent.classList.remove(this.constants.OJ_TREEVIEW_SELECTED_BOTTOM_ITEM);
            const isSelected = this._isSelected(element);
            if (!previousItem && isSelected) {
              itemContent.classList.add(this.constants.OJ_TREEVIEW_SELECTED_TOP_ITEM);
              previousItem = element;
            }
            if (previousItem && isSelected) {
              const nextItem = this._getNextItem(element);
              if (!nextItem || !this._isSelected(nextItem)) {
                itemContent.classList.add(this.constants.OJ_TREEVIEW_SELECTED_BOTTOM_ITEM);
                previousItem = null;
              }
            }
          });
        }
      },
      /**
       * Style the provided item as unselected.
       * @param {Element} item The TreeView item element.
       * @private
       */
      _setUnselected: function (item) {
        var itemContent = this._getItemContent(item);
        itemContent.classList.remove(this.constants.OJ_SELECTED);
        item.setAttribute('aria-selected', 'false');
        var key = this._getKey(item);
        this._setupSelector(key, item, false);
      },
      /**
       * Clears the selection of all items.
       * @private
       */
      _clearSelection: function () {
        var items = this._getSelectedItemContents();
        for (var i = items.length - 1; i >= 0; i--) {
          this._setUnselected(items[i].parentElement);
        }
        if (this._isLeafOnlySelectionEnabled() || this._isMultiSelectionEnabled()) {
          const topItemContents = this.element[0].querySelectorAll(
            this.constants.PERIOD + this.constants.OJ_TREEVIEW_SELECTED_TOP_ITEM
          );
          topItemContents.forEach((itemContent) => {
            itemContent.classList.remove(this.constants.OJ_TREEVIEW_SELECTED_TOP_ITEM);
          });
          const bottomItemContents = this.element[0].querySelectorAll(
            this.constants.PERIOD + this.constants.OJ_TREEVIEW_SELECTED_BOTTOM_ITEM
          );
          bottomItemContents.forEach((itemContent) => {
            itemContent.classList.remove(this.constants.OJ_TREEVIEW_SELECTED_BOTTOM_ITEM);
          });
        }
      },
      _setupSelector: function (key, item, isSelected) {
        if (this._isDefaultCheckBoxesEnabled()) {
          var selector = this._getSelectorByItem(item);
          if (selector) {
            const initialVal = isSelected ? [key] : [];
            const isSelectorSelected =
              selector.querySelector(this.constants.PERIOD + this.constants.OJ_SELECTED) !== null;
            if (isSelected !== isSelectorSelected) {
              selector.selectedKeys = new ojkeyset.KeySetImpl(initialVal);
            }
          }
        }
      },
      /**
       * Retrieves selected item content divs.
       * @private
       *
       */
      _getSelectedItemContents: function () {
        return this.element[0].querySelectorAll(
          this.constants.PERIOD +
            this.constants.OJ_TREEVIEW_ITEM_CONTENT +
            this.constants.PERIOD +
            this.constants.OJ_SELECTED
        );
      },
      /**
       * Sets the focus (current item) on the provided item element.
       * @param {Element} item The TreeView item element.
       * @param {Event} event The event that triggers the focus.
       * @private
       */
      _focus: function (item, event) {
        // Check whether the item is focusable
        if (!this._isActionable(item, 'focus')) {
          return;
        }

        if (event) {
          var payload = this._getEventPayload(item);
          if (this._currentItem) {
            payload.previousKey = this._getKey(this._currentItem);
            payload.previousItem = this._currentItem;
          }

          var cancelled = !this._trigger('beforeCurrentItem', event, payload);
          if (cancelled) {
            return;
          }

          // Update option and fire optionChange
          this._userOptionChange('currentItem', this._getKey(item), event);
        }

        this._focusOutHandler($(this._getItemContent(this._currentItem)));
        this._focusInHandler($(this._getItemContent(item)));
        this._setCurrentItem(item);
      },

      /**
       * Resets the focus (current item) of the TreeView.
       * @private
       */
      _resetFocus: function () {
        if (this.options.currentItem) {
          var currentItem = this._getItemByKey(this.options.currentItem);
          if (currentItem) {
            this._setCurrentItem(currentItem);
            return;
          }
        }

        // CurrentItem not specified, so default to the first item.
        // Update the option so the currentItem attribute is in sync.
        var firstItem = this._getItems()[0];
        if (!this._isActionable(firstItem, 'focus')) {
          firstItem = this._getNextActionableItem(firstItem, 'focus');
        }
        this._setCurrentItem(firstItem);
        this._userOptionChange('currentItem', this._getKey(this._currentItem), null);
      },

      /**
       * Set the provided item as the current item.
       * @param {Element} item The TreeView item element.
       * @private
       */
      _setCurrentItem: function (item) {
        this._currentItem = item;
        // Set the item content to be the activedescendant so that the screen reader
        // does not read the child items.
        var root = this._getRoot();
        if (root && item) {
          root.setAttribute('aria-activedescendant', this._getItemId(item));
        }
      },
      _getItemId: function (item) {
        return item.getAttribute('id');
      },
      _getUniqueItemId: function () {
        return ojcustomelementUtils.ElementUtils.getUniqueId() + '_' + this.element[0].getAttribute('id');
      },
      _getTreeViewItemCount: function () {
        return this._getItems().length;
      },
      /**
       * Adds a busy state.
       * @param {string} description The description of the busy state.
       * @param {Objet} key The key of the item that is busy.
       * @return {Function} The resolve function of the busy state.
       * @private
       */
      _addBusyState: function (description, key) {
        var busyContext = Context.getContext(this.element[0]).getBusyContext();
        var id = this.element.attr('id');
        var busyContextPromise = busyContext.addBusyState({
          description: "The component identified by '" + id + "', " + description
        });
        if (this.m_fetching.has(key)) {
          this.m_fetching.set(key, this.m_fetching.get(key) + 1);
        } else {
          this.m_fetching.set(key, 1);
        }
        return function () {
          if (this.m_fetching.get(key) === 1) {
            this.m_fetching.delete(key);
          } else {
            this.m_fetching.set(key, this.m_fetching.get(key) - 1);
          }
          busyContextPromise();
          Promise.resolve(this._processEventQueue());
        }.bind(this);
      },
      /**
       * Changes aria live-region to give user message node is being fetched.
       * @param {Objet} key The key of the item that is being fetched.
       * @param {string} completed If fetching was completed by node.
       * @private
       */
      _changeStatusMessage: function (key, completed) {
        const status = this.element[0].getElementsByClassName('oj-helper-hidden-accessible')[0];
        let statusText;
        const nodeText =
          key !== null ? this._getNodeTextByKey(key) : this.element[0].getAttribute('id');
        if (!completed) {
          statusText = Translations.getTranslatedString('oj-ojTreeView.retrievingDataAria', {
            nodeText: nodeText
          });
        } else {
          statusText = Translations.getTranslatedString('oj-ojTreeView.receivedDataAria', {
            nodeText: nodeText
          });
        }
        if (status.textContent !== statusText) {
          status.textContent = statusText;
        }
      },
      /**
       * Returns node text by key,
       * @param {Objet} key The key of the node..
       * @private
       */
      _getNodeTextByKey: function (key) {
        const item = this._getItemByKey(key);
        if (item) {
          const itemContent = this._getItemContent(item);
          const regularEx = /[\n\r]+|[\s]{2,}/g;
          // trim white space
          return itemContent.textContent.replace(regularEx, ' ').trim();
        }
        return null;
      },
      /**
       * Writes back a user-triggered change into the option.
       * @param {string} key The option name.
       * @param {Object} value The new value of the option.
       * @param {Event} event The event that triggers the change.
       * @private
       */
      _userOptionChange: function (key, value, event) {
        this.option(key, value, {
          _context: { originalEvent: event, writeback: true, internalSet: true }
        });
      },
      /**
       * Writes back a user-triggered selected change into the option.
       * @param {string} selected The selected key set thats user has triggered.
       * @param {Event} event The event that triggers the change.
       * @param {boolean} ignorePreviousSelection optional param to ignore previous selection.
       * @private
       */
      _userSelectedOptionChange: function (selected, event, ignorePreviousSelection) {
        let currentKeys = selected;
        if (this._isLeafOnlySelectionEnabled()) {
          let previousKeys = ignorePreviousSelection
            ? this._getEmptyKeySet(currentKeys)
            : this._getSelected();
          this._selectedKeysets = this.treeviewSelectionManager.computeSelection(
            currentKeys,
            previousKeys
          );
          currentKeys = this._selectedKeysets.selectedLeaves;
        }

        this._refreshTopAndBottomSelectionClasses();
        this._userOptionChange('selected', currentKeys, event);
        this._userOptionChange('selection', ojkeyset.KeySetUtils.toArray(currentKeys), event);
        this._refreshSelectionItems();
      },
      /**
       * Returns an empty version of the given currentKeys.
       * @param {string} currentKeys current key set impl we should base off.
       * @private
       */
      _getEmptyKeySet: function (currentKeys) {
        if (currentKeys.isAddAll()) {
          return new ojkeyset.AllKeySetImpl();
        }
        return new ojkeyset.KeySetImpl();
      },
      /**
       * Filters out keys that are parents.
       * @param {string} currentKeys keyset we should be filtering.
       * @private
       */
      _filterOutParentKeys: function (currentKeys) {
        if (currentKeys.isAddAll()) {
          let baseAllKeySet = new ojkeyset.AllKeySetImpl();
          let deletedLeafValues = [...currentKeys.deletedValues()].filter(
            (key) => !this.treeviewSelectionManager.parentKeyNodeMap.has(key)
          );
          baseAllKeySet = baseAllKeySet.delete(deletedLeafValues);
          return baseAllKeySet;
        }
        return new ojkeyset.KeySetImpl(
          [...currentKeys.values()].filter(
            (key) => !this.treeviewSelectionManager.parentKeyNodeMap.has(key)
          )
        );
      },
      /**
       * Returns the dnd.drag.items option.
       * @return {Object} The option object. Defaults to {}.
       * @private
       */
      _getDragOptions: function () {
        return ((this.options.dnd || {}).drag || {}).items || {};
      },

      /**
       * Returns the dnd.drop.items option.
       * @return {Object} The option object. Defaults to {}.
       * @private
       */
      _getDropOptions: function () {
        return ((this.options.dnd || {}).drop || {}).items || {};
      },

      /**
       * Returns the closest item to the element.
       * @param {Element} elem The element.
       * @return {Element} The item content element.
       * @private
       */
      _getClosestItem: function (elem) {
        return this._closest(elem, this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM);
      },

      /**
       * Returns the closest item content to the element.
       * @param {Element} elem The element.
       * @return {Element} The item content element.
       * @private
       */
      _getClosestItemContent: function (elem) {
        return this._closest(elem, '.oj-treeview-item-content');
      },

      /**
       * Returns the closest disclosure icon to the element.
       * @param {Element} elem The element.
       * @return {Element} The disclosure icon element.
       * @private
       */
      _getClosestDisclosureIcon: function (elem) {
        return this._closest(elem, '.oj-treeview-disclosure-icon');
      },

      /**
       * Handles click event.
       * @param {Event} event The event.
       * @private
       */
      _handleClick: function (event) {
        // disable click event if selector is target
        if (DataCollectionUtils.isFromDefaultSelector(event)) {
          return;
        }
        var item;
        // Clicking on disclosure icon
        var disclosureIcon = this._getClosestDisclosureIcon(event.target);
        if (disclosureIcon) {
          item = this._getClosestItem(disclosureIcon);
          var itemKey = this._getKey(item);
          if (this.m_fetching.has(itemKey)) {
            return;
          }
          if (this._isExpanded(item)) {
            this._collapse(item, true, event);
          } else {
            this._expand(item, true, event);
          }
          this.touchStartEvent = null;
          return;
        }

        // Clicking on item content
        var itemContent = this._getClosestItemContent(event.target);
        if (itemContent) {
          item = itemContent.parentNode;
          this._select(item, event);
          this._focus(item, event);
          this.touchStartEvent = null;
          return;
        }

        // Clear selection otherwise
        var selectionMode = this.options.selectionMode;
        if (selectionMode !== 'none') {
          this._clearSelection();
          this._userSelectedOptionChange(new ojkeyset.KeySetImpl(), event);
        }

        this.touchStartEvent = null;
      },
      _isDnD: function () {
        var dragOptions = this._getDragOptions();
        return Object.keys(dragOptions).length > 0;
      },
      /**
       * Handles mouse over event.
       * @param {Event} event The event.
       * @private
       */
      _handleMouseOver: function (event) {
        // Don't add hover effect for touch
        if (DomUtils.isTouchSupported() && this.touchStartEvent) {
          return;
        }

        var selectionMode = this.options.selectionMode;
        if (selectionMode === 'none' && !this._isDnD()) {
          return;
        }

        var target = this._getClosestDisclosureIcon(event.target);

        if (!target) {
          target = this._getClosestItemContent(event.target);
        }

        // Add hover effect
        if (target) {
          target.classList.remove(this.constants.OJ_DEFAULT);
          target.classList.add(this.constants.OJ_HOVER);
        }
      },

      /**
       * Handles mouse out event.
       * @param {Event} event The event.
       * @private
       */
      _handleMouseOut: function (event) {
        var target = this._getClosestDisclosureIcon(event.target);
        if (target) {
          target.classList.remove(this.constants.OJ_SELECTED);
        }

        if (!target) {
          target = this._getClosestItemContent(event.target);
        }

        // Remove hover effect
        if (target) {
          target.classList.add(this.constants.OJ_DEFAULT);
          target.classList.remove(this.constants.OJ_HOVER);
        }
      },

      /**
       * Handles mouse down event.
       * @param {Event} event The event.
       * @private
       */
      _handleMouseDown: function (event) {
        // disable click event if selector is target
        if (DataCollectionUtils.isFromDefaultSelector(event)) {
          return;
        }
        var disclosureIcon = this._getClosestDisclosureIcon(event.target);
        if (disclosureIcon) {
          disclosureIcon.classList.add(this.constants.OJ_SELECTED);
        }
      },

      /**
       * Handles mouse up event.
       * @param {Event} event The event.
       * @private
       */
      _handleMouseUp: function (event) {
        var disclosureIcon = this._getClosestDisclosureIcon(event.target);
        if (disclosureIcon) {
          disclosureIcon.classList.remove(this.constants.OJ_SELECTED);
        }
      },

      /**
       * Handles key down event.
       * @param {Event} event The event.
       * @private
       */
      _handleKeyDown: function (event) {
        var currentItem = this._currentItem;
        var nextItem;
        var eventKey = event.key || event.keyCode;
        if (
          DataCollectionUtils.isArrowUpKeyEvent(eventKey) ||
          DataCollectionUtils.isArrowDownKeyEvent(eventKey)
        ) {
          nextItem = DataCollectionUtils.isArrowDownKeyEvent(eventKey)
            ? this._getNextActionableItem(currentItem, 'focus')
            : this._getPreviousActionableItem(currentItem, 'focus');
          if (nextItem) {
            event.preventDefault(); // prevent scrolling the page
            if (this._isSelected(currentItem) && event.shiftKey) {
              // Shift+Up/Down either extends the selection to the next item or cancels previous Shift+Down/Up
              this._select(this._isSelected(nextItem) ? currentItem : nextItem, event);
            }
            this._scrollToVisible(nextItem);
            this._focus(nextItem, event);
          }
        } else if (
          DataCollectionUtils.isArrowLeftKeyEvent(eventKey) ||
          DataCollectionUtils.isArrowRightKeyEvent(eventKey)
        ) {
          var isRTL = this._GetReadingDirection() === 'rtl';
          var isEnd =
            (!isRTL && DataCollectionUtils.isArrowRightKeyEvent(eventKey)) ||
            (isRTL && DataCollectionUtils.isArrowLeftKeyEvent(eventKey));
          if (isEnd && !this._isLeaf(currentItem) && !this._isExpanded(currentItem)) {
            event.preventDefault(); // prevent scrolling the page
            this._expand(currentItem, true, event);
          } else if (!isEnd && !this._isLeaf(currentItem) && this._isExpanded(currentItem)) {
            event.preventDefault(); // prevent scrolling the page
            this._collapse(currentItem, true, event);
          } else {
            nextItem = isEnd
              ? this._getNextActionableItem(currentItem, 'focus')
              : this._getPreviousActionableItem(currentItem, 'focus');
            if (nextItem) {
              event.preventDefault(); // prevent scrolling the page
              this._focus(nextItem, event);
            }
          }
        } else if (
          DataCollectionUtils.isEnterKeyEvent(eventKey) ||
          DataCollectionUtils.isSpaceBarKeyEvent(eventKey)
        ) {
          // ENTER or SPACE
          event.preventDefault(); // prevent scrolling the page
          this._select(currentItem, event);
        } else if (
          DataCollectionUtils.isLetterAKeyEvent(eventKey) &&
          DomUtils.isMetaKeyPressed(event) &&
          (this._isLeafOnlySelectionEnabled() || this._isMultiSelectionEnabled())
        ) {
          // CTRL - A
          event.preventDefault(); // prevent default ctrl
          this._userSelectedOptionChange(new ojkeyset.AllKeySetImpl(), event);
        }
      },
      /**
       * Scroll as needed to make an element visible in the viewport
       * @param {Element} elem the element to make visible
       * @private
       */
      _scrollToVisible: function (elem) {
        const tree = this.element[0];
        const spacerHeight = this._getItemSpacer(elem).offsetHeight;

        const treeBoundingClientRect = tree.getBoundingClientRect();
        const viewportStart = treeBoundingClientRect.top;
        const viewportEnd = treeBoundingClientRect.bottom;

        const elemBoundingClientRect = elem.getBoundingClientRect();
        const elemTop = elemBoundingClientRect.top;
        const elemBottom = elemBoundingClientRect.top + spacerHeight;

        if (elemTop >= viewportStart && elemBottom <= viewportEnd) {
          return;
        }
        // +- 1 for the focus border
        if (elemTop < viewportStart) {
          tree.scrollTop += elemTop - viewportStart - 1;
        } else if (elemBottom > viewportEnd) {
          tree.scrollTop += elemBottom - viewportEnd + 1;
        }
      },
      /**
       * Returns the item below the provided item.
       * @param {Element} item The TreeView item element.
       * @return {Element} The next item element.
       * @private
       */
      _getNextItem: function (item) {
        // If the item is expanded, go to the first child
        if (!this._isLeaf(item) && this._isExpanded(item)) {
          var firstChild = this._getChildItems(item)[0];
          if (firstChild) {
            return firstChild;
          }
        }

        // Otherwise, go to the next sibling of the item or its ancestors
        var parent = item;
        while (parent) {
          var nextSibling = this._getNextSibling(
            parent,
            this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM
          );
          if (nextSibling) {
            return nextSibling;
          }

          parent = this._getParentItem(parent);
        }

        // Otherwise, don't go anywhere
        return null;
      },

      /**
       * Returns the closest item below the provided item that can accept the specified action.
       * @param {Element} item The TreeView item element.
       * @param {string} actionName The action name: 'select' or 'focus'.
       * @return {Element} The next item element.
       * @private
       */
      _getNextActionableItem: function (item, actionName) {
        while (item != null) {
          // eslint-disable-next-line no-param-reassign
          item = this._getNextItem(item);
          if (item != null && this._isActionable(item, actionName)) {
            return item;
          }
        }
        return null;
      },
      /**
       * Returns the item above the provided item.
       * @param {Element} item The TreeView item element.
       * @return {Element} The previous item element.
       * @private
       */
      _getPreviousItem: function (item) {
        // Go to the last expanded child of the previous sibling
        var prevSibling = this._getPreviousSibling(
          item,
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_ITEM
        );
        while (prevSibling) {
          if (!this._isLeaf(prevSibling) && this._isExpanded(prevSibling)) {
            var prevChildren = this._getChildItems(prevSibling);
            var lastChild = prevChildren[prevChildren.length - 1];
            if (lastChild) {
              prevSibling = lastChild;
            } else {
              return prevSibling;
            }
          } else {
            return prevSibling;
          }
        }

        // Otherwise, go to the parent
        var parent = this._getParentItem(item);
        if (parent) {
          return parent;
        }

        // Otherwise, don't go anywhere
        return null;
      },
      /**
       * Returns the closest item above the provided item that can accept the specified action.
       * @param {Element} item The TreeView item element.
       * @param {string} actionName The action name: 'select' or 'focus'.
       * @return {Element} The previous item element.
       * @private
       */
      _getPreviousActionableItem: function (item, actionName) {
        while (item != null) {
          // eslint-disable-next-line no-param-reassign
          item = this._getPreviousItem(item);
          if (item != null && this._isActionable(item, actionName)) {
            return item;
          }
        }
        return null;
      },
      /**
       * Handles DnD dragStart event.
       * @param {Event} event The event.
       * @private
       */
      _handleDragStart: function (event) {
        var self = this;
        var isRTL = this._GetReadingDirection() === 'rtl';

        var targetItem = this._getClosestItem(event.target);
        if (!targetItem) {
          return;
        }

        var i;
        var items = [];
        if (!this._isSelected(targetItem)) {
          this._select(targetItem, event);
          items.push(targetItem);
        } else {
          var selection = this.options.selection;
          for (i = 0; i < selection.length; i++) {
            var itemByKey = this._getItemByKey(selection[i]);
            if (itemByKey) {
              items.push(itemByKey);
            }
          }
        }

        this._refreshTopAndBottomSelectionClasses();

        var dragOptions = this._getDragOptions();
        var dataTransfer = event.originalEvent.dataTransfer;

        var dragImage = document.createElement('ul');
        dragImage.classList.add(this.constants.OJ_TREEVIEW_DRAG_IMAGE);
        dragImage.classList.add(this.constants.OJ_TREEVIEW_LIST);
        if (DataCollectionUtils.isSafari()) {
          // On Safari, the drag image is not rendered if the position is fixed.
          // If we set {position: absolute; top: -10000px}, it should theoretically
          // work for all browsers (as it does for table and listview), but it
          // causes the treeview to blink frantically if you drag an unselected
          // item on Chrome. When an unselected item is dragged, the treeview applies
          // selection effect to it, but Chrome somehow doesn't like modifying the
          // DOM and setting drag image at the same time if the drag image has absolute
          // position and negative top (I tested that positive top is fine, but positive
          // top adds a scrollbar on IE). This issue never happens on table and
          // listview because they don't allow dragging unselected items.
          dragImage.style.position = 'absolute';
        }

        var dragData = [];
        var topmost = Infinity;
        var leftmost = Infinity;

        items.forEach(function (item) {
          const data = item[self.constants.OJ_ITEM_DATA];
          if (data) {
            dragData.push(data);
          } else {
            dragData.push(item.parentElement.innerHTML);
          }

          const offset = item.getBoundingClientRect();

          // added in case window has scrolled the treeview down
          const windowScrollLeft = window.scrollX;
          const windowScrollTop = window.scrollY;

          const offsetTop = offset.top + windowScrollTop;
          let offsetLeft = offset.left + windowScrollLeft;

          const itemContentChildren = self._getItemContent(item).children;
          let childrenWidth = 0;

          for (var j = 0; j < itemContentChildren.length; j++) {
            childrenWidth += itemContentChildren[j].offsetWidth;
          }

          if (isRTL) {
            offsetLeft += self._getTreeviewWidth() - childrenWidth;
          } else {
            offsetLeft += childrenWidth;
          }

          const clonedItem = item.cloneNode(true);
          clonedItem.style.top = offsetTop + 'px';
          clonedItem.style.left = offsetLeft + 'px';

          item.classList.add(self.constants.OJ_TREEVIEW_DRAG_SOURCE);
          clonedItem.classList.add(self.constants.OJ_TREEVIEW_DRAG_IMAGE);
          clonedItem.classList.add(self.constants.OJ_TREEVIEW_DRAG_IMAGE_ITEM);

          // Don't include children in the drag image
          var children = self._getSubtree(clonedItem);
          if (children) {
            clonedItem.removeChild(children);
          }

          var clonedItemContent = self._getItemContent(clonedItem);
          self._setUnselected(clonedItem);
          clonedItemContent.classList.remove(self.constants.OJ_TREEVIEW_SELECTED_TOP_ITEM);
          clonedItemContent.classList.remove(self.constants.OJ_TREEVIEW_SELECTED_BOTTOM_ITEM);
          clonedItemContent.classList.remove(self.constants.OJ_FOCUS);
          clonedItemContent.classList.remove(self.constants.OJ_HOVER);
          clonedItemContent.classList.remove(self.constants.OJ_FOCUS_HIGHLIGHT);
          clonedItemContent.classList.remove(self.constants.OJ_DRAGGABLE);

          var clonedItemSpacer = clonedItem.getElementsByClassName(
            self.constants.OJ_TREEVIEW_SPACER
          )[0];
          if (clonedItemSpacer) {
            var spacer = document.createElement('span');
            self._addTreeviewSpacerClass(spacer);
            clonedItemContent.insertBefore(spacer, clonedItemSpacer); // @HTMLUpdateOK
            clonedItemContent.removeChild(clonedItemSpacer);
          }

          if (
            self._isDefaultCheckBoxesEnabled() &&
            self._isActionable(item, 'focus') &&
            self._isActionable(item, 'select')
          ) {
            var clonedSelector = clonedItem.getElementsByClassName(
              self.constants.OJ_TREEVIEW_SELECTOR
            )[0];
            clonedSelector.firstChild.selectedKeys = self.options.selected;
            clonedSelector.firstChild.rowKey = self._getKey(item);
          }
          // Drag image offset is based on the top left corner of the resulting drag image
          if (offsetTop < topmost) {
            topmost = offsetTop;
          }
          if (offsetLeft < leftmost) {
            leftmost = offsetLeft;
          }

          dragImage.appendChild(clonedItem); // @HTMLUpdateOK
        });
        // : There's inconsistency in how the drag image offset is computed
        // for the native DnD impl and the polyfill. In the native impl, the offset is
        // relative to the top-left corner of the rendered drag image element. In the
        // polyfill, the offset is relative to the {top: 0, left: 0} position. To
        // reconcile this, we must make sure that the top-left corner of the rendered
        // drag image element is at the {top: 0, left: 0} position.
        var child;
        for (i = 0; i < dragImage.children.length; i++) {
          child = dragImage.children[i];
          child.style.top = parseFloat(child.style.top) - topmost + 'px';
          child.style.left = parseFloat(child.style.left) - leftmost + 'px';
        }
        var optionTypes = dragOptions.dataTypes;
        var dragDataTypes = typeof optionTypes === 'string' ? [optionTypes] : optionTypes || [];
        for (i = 0; i < dragDataTypes.length; i++) {
          dataTransfer.setData(dragDataTypes[i], JSON.stringify(dragData));
        }

        // Drag image has to be attached to the DOM when being assigned to the dataTransfer.
        // It has to be removed afterwards to prevent leaks.
        document.body.appendChild(dragImage); // @HTMLUpdateOK
        dataTransfer.setDragImage(dragImage, event.pageX - leftmost, event.pageY - topmost);
        setTimeout(function () {
          dragImage.parentElement.removeChild(dragImage);
        }, 0);

        var callback = dragOptions.dragStart;
        if (callback) {
          callback(event.originalEvent, { items: dragData });
        }

        if (event.originalEvent.defaultPrevented) {
          items.forEach((element) => {
            element.classList.remove(this.constants.OJ_TREEVIEW_DRAG_SOURCE);
          });
        }
      },
      /**
       * Handles DnD drag and dragEnd events.
       * @param {Event} event The event.
       * @param {string} eventType The event type (drag or dragEnd).
       * @private
       */
      _handleDragSourceEvent: function (event, eventType) {
        if (this.touchStartEvent && this.contextMenuOpen && eventType === 'drag') {
          event.preventDefault();
          return;
        }
        if (eventType === 'dragEnd') {
          this._removeGhostElements();
          this._dropLine.style.display = 'none';
        }
        var callback = this._getDragOptions()[eventType];
        if (callback) {
          callback(event.originalEvent);
        }
      },
      _getTreeviewWidth: function () {
        return this.element[0].offsetWidth;
      },
      _getItemSpacer: function (item) {
        return item.getElementsByClassName(this.constants.OJ_TREEVIEW_SPACER)[0];
      },
      /**
       * Handles DnD dragEnter, dragOver, dragLeave, and drop events.
       * @param {Event} event The event.
       * @param {string} eventType The event type (dragEnter, dragOver, dragLeave, or drop).
       * @private
       */
      _handleDropTargetEvent: function (event, eventType) {
        var dropOptions = this._getDropOptions();
        var optionTypes = dropOptions.dataTypes;
        var dropDataTypes = typeof optionTypes === 'string' ? [optionTypes] : optionTypes || [];
        var callback = dropOptions[eventType];
        var targetItem = this._getClosestItem(event.target);
        if (!targetItem) {
          return;
        }

        if (this.touchStartEvent && this.contextMenuOpen) {
          event.preventDefault();
          return;
        }

        if (
          this.touchStartEvent &&
          (eventType === 'dragEnter' || eventType === 'dragOver' || eventType === 'dragLeave')
        ) {
          this.isTouchDrag = true;
        }

        // Position drop effects based on the spacer (disclosure icon) because it takes up the entire item height
        var spacer = this._getItemSpacer(targetItem);
        var spacerRect = spacer.getBoundingClientRect();

        var position = 'inside';
        var relativeY = event.originalEvent.clientY - spacerRect.top;
        if (relativeY < 0.25 * spacerRect.height) {
          position = 'before';
        } else if (relativeY > 0.75 * spacerRect.height) {
          position = this._isExpanded(targetItem) ? 'first' : 'after';
        }

        if (callback) {
          callback(event.originalEvent, { item: targetItem, position: position });
        }

        for (var i = 0; i < dropDataTypes.length; i++) {
          var dataTypes = event.originalEvent.dataTransfer.types;
          if (dataTypes && dataTypes.indexOf(dropDataTypes[i]) >= 0) {
            event.preventDefault();
            break;
          }
        }

        if (
          (eventType === 'dragEnter' || eventType === 'dragOver') &&
          event.originalEvent.defaultPrevented
        ) {
          this.dragLeftTreeview = false;
          var isRTL = this._GetReadingDirection() === 'rtl';
          // Draw the drop target effect on dragEnter and dragOver
          var dropLineTop = targetItem.offsetTop;
          if (position !== 'before') {
            dropLineTop += spacerRect.height;
          }

          if (position !== 'inside') {
            // calculate drop line size
            var dropLineOffset;
            var disclosureIcon;
            var parentItem = this._getParentItem(targetItem);
            if (parentItem && this._isLeaf(targetItem)) {
              dropLineOffset = spacerRect.width;
              disclosureIcon = this._getItemDisclosureIcon(parentItem);
              // using height here because we pad the width giving incorrect fontSize
              dropLineOffset -= disclosureIcon.offsetHeight;
            } else if (parentItem && !this._isLeaf(targetItem)) {
              dropLineOffset = spacerRect.width;
              if (position === 'first') {
                // first inside expanded parent align drop line with children
                disclosureIcon = this._getItemDisclosureIcon(targetItem);
                // using height here because we pad the width giving incorrect fontSize
                dropLineOffset += disclosureIcon.offsetHeight;
              }
            } else if (!parentItem) {
              dropLineOffset = 0;
              if (position === 'first') {
                // first inside expanded parent align drop line with children
                disclosureIcon = this._getItemDisclosureIcon(targetItem);
                // using height here because we pad the width giving incorrect fontSize
                dropLineOffset += disclosureIcon.offsetHeight;
              }
            }
            if (this._isExpanded(targetItem) && position !== 'before') {
              dropLineOffset += 8; // line up with children even though dropline is still on parent
            }
            this._removeDropClass(targetItem);
            var width = targetItem.offsetWidth - parseInt(dropLineOffset, 10) + 'px';
            var left = isRTL ? '0px' : dropLineOffset + 'px';
            this._dropLine.style.width = width;
            this._dropLine.style.left = left;
            this._dropLine.style.top = dropLineTop + 'px';
            this._dropLine.style.display = '';
          } else {
            this._dropLine.style.display = 'none';
            this._addDropClass(targetItem);
          }
        } else if (eventType === 'drop') {
          this._removeGhostElements();
          this._dropLine.style.display = 'none';
          this._removeDropClass(targetItem);
        } else if (eventType === 'dragLeave') {
          this.dragLeftTreeview = true;
          if (position !== 'inside') {
            this._removeDropClass(targetItem);
          }
          setTimeout(() => {
            if (this.dragLeftTreeview) {
              this._dropLine.style.display = 'none';
              this.dragLeftTreeview = false;
              this._removeAllDropZones();
            }
          }, 50);
        }
      },
      _addDropClass: function (item) {
        var itemContent = this._getItemContent(item);
        itemContent.classList.add(this.constants.OJ_TREEVIEW_DROP_ZONE);
      },
      _removeDropClass: function (item) {
        var itemContent = this._getItemContent(item);
        itemContent.classList.remove(this.constants.OJ_TREEVIEW_DROP_ZONE);
      },
      _removeGhostElements: function () {
        var ghostElements = this.element[0].querySelectorAll(
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_DRAG_SOURCE
        );
        for (var i = ghostElements.length - 1; i >= 0; i--) {
          ghostElements[i].classList.remove(this.constants.OJ_TREEVIEW_DRAG_SOURCE);
        }
      },
      _removeAllDropZones: function () {
        var dropZones = this.element[0].querySelectorAll(
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_DROP_ZONE
        );
        for (var i = dropZones.length - 1; i >= 0; i--) {
          dropZones[i].classList.remove(this.constants.OJ_TREEVIEW_DROP_ZONE);
        }
      },
      // @inheritdoc
      _NotifyContextMenuGesture: function (menu, event, eventType) {
        if (eventType === 'keyboard') {
          // If launched by Shift+F10, the context menu should be rendered next
          // to the currentItem.
          var launcher = this._currentItem ? this._getItemContent(this._currentItem) : this.element;
          var openOptions = {
            launcher: this._getRoot(),
            initialFocus: 'menu',
            position: { my: 'start top', at: 'start bottom', of: launcher }
          };
          this._OpenContextMenu(event, eventType, openOptions);
        } else if (!this.isTouchDrag) {
          if (this.touchStartEvent) {
            this.contextMenuOpen = true;
          }
          var item = this._getClosestItem(event.target);
          if (item) {
            this._setCurrentItem(item);
            this._userOptionChange('currentItem', this._getKey(this._currentItem), event);
            this._superApply(arguments);
          }
        }
      },
      // @inheritdoc
      refresh: function () {
        this._super();
        this._refreshId += 1;

        if (this._getItemTemplate() != null) {
          this._cleanTemplateNodes(this._getRoot());
        }

        delete this.m_template;
        delete this.m_engine;
        delete this.m_dataSource;

        this._expandedChildrenMap = new Map();
        this.m_fetching = new Map();

        this._render();
      },

      // @inheritdoc
      getNodeBySubId: function (locator) {
        if (locator == null) {
          return this.element ? this.element[0] : null;
        }

        var key = locator.key;
        var subId = locator.subId;
        var item = this._getItemByKey(key);
        var ret;

        if (subId === 'oj-treeview-disclosure' && item) {
          ret = item.getElementsByClassName(this.constants.OJ_TREEVIEW_DISCLOSURE_ICON)[0];
        } else if (subId === this.constants.OJ_TREEVIEW_ITEM && item) {
          ret = item.getElementsByClassName(this.constants.OJ_TREEVIEW_ITEM_CONTENT)[0];
        }

        // Non-null locators have to be handled by the component subclasses
        return ret || null;
      },

      // @inheritdoc
      getSubIdByNode: function (node) {
        if (!this.element[0].contains(node)) {
          return null;
        }

        var subId;
        var disclosureIcon = this._getClosestDisclosureIcon(node);
        var item = this._getClosestItem(node);

        if (disclosureIcon) {
          subId = 'oj-treeview-disclosure';
        } else if (item) {
          subId = this.constants.OJ_TREEVIEW_ITEM;
        } else {
          return null;
        }

        return { subId: subId, key: this._getKey(item) };
      },

      /**
       * {@ojinclude "name":"nodeContextDoc"}
       * @param {!Element} node - {@ojinclude "name":"nodeContextParam"}
       * @returns {Object|null} {@ojinclude "name":"nodeContextReturn"}
       *
       * @example {@ojinclude "name":"nodeContextExample"}
       *
       * @expose
       * @instance
       * @memberof oj.ojTreeView
       * @ojshortdesc Returns an object with context for the given child DOM node. See the Help documentation for more information.
       */
      getContextByNode: function (node) {
        if (!this.element[0].contains(node)) {
          return null;
        }
        var i;
        var item = this._getClosestItem(node);
        if (!item) {
          return null;
        }
        var itemParentChildren = item.parentNode.children;
        var treeViewItems = [];
        for (i = 0; i < itemParentChildren.length; i++) {
          if (itemParentChildren[i].classList.contains(this.constants.OJ_TREEVIEW_ITEM)) {
            treeViewItems.push(itemParentChildren[i]);
          }
        }

        var context = {
          subId: this.constants.OJ_TREEVIEW_ITEM,
          index: treeViewItems.indexOf(item),
          parentKey: this._getKey(this._getParentItem(item))
        };

        context.component = ojcomponentcore.__GetWidgetConstructor(this.element);
        if (this._FixRendererContext) {
          context = this._FixRendererContext(context);
        }

        var metadata = item[this.constants.OJ_ITEM_METADATA];
        if (metadata) {
          context.metadata = metadata;
          context.data = item[this.constants.OJ_ITEM_DATA];
          context.datasource = this.options.data;

          // Merge properties from metadata into item context
          // Contains key, leaf, and depth
          var props = Object.keys(metadata);
          for (i = 0; i < props.length; i++) {
            var prop = props[i];
            context[prop] = metadata[prop];
          }
        } else {
          // Static content
          context.key = this._getKey(item);
          context.leaf = this._isLeaf(item);
          context.depth = this._getParents(item, '.oj-treeview-list').length;
        }

        return context;
      },
      // @inheritdoc
      // eslint-disable-next-line no-unused-vars
      _setOption: function (key, value, flags) {
        var self = this;
        var i;
        var items;

        // Call the super to update the property values
        if (
          !this._isLeafOnlySelectionEnabled() ||
          (this._isLeafOnlySelectionEnabled() && (key !== 'selected' || key !== 'selection'))
        ) {
          this._superApply(arguments);
        }

        if (key === 'expanded') {
          this._uiExpanded = self._uiExpanded.clear();
          this._expandedChildrenMap = new Map();
          items = this._getItems();
          for (i = 0; i < items.length; i++) {
            var itemKey = this._getKey(items[i]);
            if (self._isInitExpanded(itemKey)) {
              self._expand(items[i], true);
            } else {
              self._collapse(items[i], true);
            }
          }
        } else if (key === 'selected') {
          if (this._isLeafOnlySelectionEnabled()) {
            let currentKeys = value;
            currentKeys = this._filterOutParentKeys(currentKeys);
            let previousKeys = this._getEmptyKeySet(currentKeys);
            this._selectedKeysets = this.treeviewSelectionManager.computeSelection(
              currentKeys,
              previousKeys
            );
            // eslint-disable-next-line no-param-reassign
            value = this._selectedKeysets.selectedLeaves;
            arguments[1] = value;
            this._superApply(arguments);
          }
          var selectedArray = ojkeyset.KeySetUtils.toArray(value);
          this._userOptionChange('selection', selectedArray, null);
          this._refreshSelectionItems();
        } else if (key === 'selection') {
          var selectionKeySet = ojkeyset.KeySetUtils.toKeySet(value);
          if (this._isLeafOnlySelectionEnabled()) {
            let currentKeys = selectionKeySet;
            currentKeys = this._filterOutParentKeys(currentKeys);
            let previousKeys = this._getEmptyKeySet(currentKeys);
            this._selectedKeysets = this.treeviewSelectionManager.computeSelection(
              currentKeys,
              previousKeys
            );
            // eslint-disable-next-line no-param-reassign
            selectionKeySet = this._selectedKeysets.selectedLeaves;
            arguments[1] = ojkeyset.KeySetUtils.toArray(selectionKeySet);
            this._superApply(arguments);
          }
          this._userOptionChange('selected', selectionKeySet, null);
          this._refreshSelectionItems();
        } else if (key === 'currentItem') {
          this._resetFocus();
        } else if (key === 'data') {
          this._removeDataProviderEventListeners();
          this.options.data = value;
          if (!this.options.data) {
            this._getRoot().remove();
          }
          this._addDataProviderEventListeners();
          this.refresh();
        } else {
          this.refresh();
        }
      },
      _SetupResources: function () {
        this._super();
        this._addDataProviderEventListeners();
        if (this._isInitFetch) {
          this._isInitFetch = false;
        } else {
          this.refresh();
        }
      },
      _ReleaseResources: function () {
        this._super();
        if (this._getItemTemplate() != null) {
          this._cleanTemplateNodes(this._getRoot());
        }
        this._removeDataProviderEventListeners();
      },
      /**
       * Override to do the delay connect/disconnect
       * @memberof oj.ojTreeView
       * @override
       * @protected
       */
      _VerifyConnectedForSetup: function () {
        return true;
      },
      // @inheritdoc
      _destroy: function () {
        if (this._getItemTemplate() != null) {
          this._cleanTemplateNodes(this._getRoot());
        }
        this._removeDataProviderEventListeners();
        this._super();
      },
      _cleanTemplateNodes: function (node) {
        const templateEngine = this._getTemplateEngine();
        if (node != null && templateEngine != null) {
          templateEngine.clean(node, this.element[0]);
        }
      },
      _addDataProviderEventListeners: function () {
        var dataProvider = this.options.data;
        if (dataProvider && oj.DataProviderFeatureChecker.isTreeDataProvider(dataProvider)) {
          this.m_handleModelMutateEventListener = this.handleModelMutateEvent.bind(this);
          this.m_handleModelRefreshEventListener = this.handleModelRefreshEvent.bind(this);

          dataProvider.addEventListener('mutate', this.m_handleModelMutateEventListener);
          dataProvider.addEventListener('refresh', this.m_handleModelRefreshEventListener);
        }
      },
      _removeDataProviderEventListeners: function () {
        var dataProvider = this.options.data;
        if (dataProvider && oj.DataProviderFeatureChecker.isTreeDataProvider(dataProvider)) {
          dataProvider.removeEventListener('mutate', this.m_handleModelMutateEventListener);
          dataProvider.removeEventListener('refresh', this.m_handleModelRefreshEventListener);
        }
      },
      handleModelMutateEvent: function (event) {
        if (this._isLeafOnlySelectionEnabled()) {
          Logger.error('Mutations are not supported in selectionMode: leafOnly  ');
          return;
        }
        if (!this.isReady()) {
          this._pushToEventQueue(event);
          return;
        }
        if (event.detail.remove != null) {
          this.handleModelRemoveEvent(event);
        }
        if (event.detail.add != null) {
          this.handleModelAddEvent(event);
        }
        if (event.detail.update != null) {
          this.handleModelChangeEvent(event);
        }
        this._processEventQueue();
      },
      _pushToEventQueue: function (event) {
        if (this.m_eventQueue == null) {
          this.m_eventQueue = [];
        }

        this.m_eventQueue.push(event);
      },
      _clearEventQueue: function () {
        if (this.m_eventQueue != null) {
          this.m_eventQueue.length = 0;
        }
      },
      _processEventQueue: function () {
        if (!this.isReady()) {
          return;
        }
        let event;

        if (this.m_eventQueue != null && this.m_eventQueue.length > 0) {
          // see if we can find a refresh event
          for (var i = 0; i < this.m_eventQueue.length; i++) {
            event = this.m_eventQueue[i];
            if (event.type === 'refresh' && (!event.detail || (event.detail && !event.detail.keys))) {
              this.handleModelRefreshEvent(event);
              // we are done
              return;
            }
          }

          // we'll just need to handle one event at a time since processEventQueue will be triggered whenever an event is done processing
          event = this.m_eventQueue.shift();
          if (event.type === 'mutate') {
            this.handleModelMutateEvent(event);
          }
          if (event.type === 'refresh' && event.detail && event.detail.keys) {
            this.handleModelRefreshEvent(event);
          }
        }
      },
      isReady: function () {
        return this.m_fetching.size === 0;
      },
      handleModelRemoveEvent: function (event) {
        var self = this;
        var keys = event.detail.remove.keys;
        var removedKeys = [];
        if (keys == null || keys.size === 0) {
          return;
        }

        const currentItemKey = this._getKey(this._currentItem);
        const oldFlatList = this._getFlatList();
        const oldCurrentItemIndex = oldFlatList.indexOf(this._currentItem);

        keys.forEach(function (key) {
          let savedParentKey;
          const addEvent = event.detail.add;

          const itemParentKey = self._getKey(self._getParentItem(self._getItemByKey(key)));
          if (addEvent && addEvent.parentKeys) {
            const foundParentKey = addEvent.parentKeys.find((parentKey) =>
              oj.KeyUtils.equals(parentKey, itemParentKey)
            );
            if (foundParentKey) {
              savedParentKey = foundParentKey;
            }
          }
          removedKeys = removedKeys.concat(
            self._removeAllChildrenOfParentKey(
              key,
              savedParentKey,
              addEvent && addEvent.keys.has(key)
            )
          );
        });

        if (removedKeys.length === 0) {
          return;
        }

        // checks whether the removed item is selected, and adjust the value as needed
        var selected = this._getSelected();
        if (selected != null) {
          var newSelected = selected.delete(removedKeys);
          // update selected/selection option if it did changed
          if (selected !== newSelected) {
            this._userSelectedOptionChange(newSelected, event);
          }
        }
        this._refreshTopAndBottomSelectionClasses();

        // checks whether the removed item is expanded, and adjust the value as needed
        var expanded = this.options.expanded;
        if (expanded != null) {
          var newExpanded = expanded.delete(removedKeys);
          this._uiExpanded.delete(removedKeys);
          // update selection option if it did changed
          if (expanded !== newExpanded) {
            this._userOptionChange('expanded', newExpanded, null);
          }
        }
        if (!this._getItemByKey(currentItemKey)) {
          const newFlatList = this._getFlatList();
          let newCurrentItem = null;
          if (newFlatList.length > 0) {
            for (let i = oldCurrentItemIndex - 1; i >= 0; --i) {
              if (
                newFlatList.includes(oldFlatList[i]) &&
                this._isActionable(oldFlatList[i], 'focus')
              ) {
                newCurrentItem = oldFlatList[i];
                break;
              }
            }
            if (!newCurrentItem) {
              for (let i = oldCurrentItemIndex; i < oldFlatList.length; i++) {
                if (
                  newFlatList.includes(oldFlatList[i]) &&
                  this._isActionable(oldFlatList[i], 'focus')
                ) {
                  newCurrentItem = oldFlatList[i];
                  break;
                }
              }
            }
            if (!newCurrentItem) {
              const items = this._getItems();
              if (items.length > 0) {
                newCurrentItem = items[0];
              }
            }
            if (newCurrentItem) {
              this._setCurrentItem(newCurrentItem);
              this._userOptionChange('currentItem', this._getKey(this._currentItem), event);
              return;
            }
          }
        }
        this._resetFocus();
      },
      _getFlatList: function () {
        const flatList = [];
        this._getItems().forEach((item) => {
          const isHiddenElement = this._isHiddenElement(item);
          if (!isHiddenElement) {
            flatList.push(item);
          }
        });
        return flatList;
      },
      _changeNodeToLeaf: function (item, subtree) {
        if (item === this.element[0]) {
          return;
        }

        item.removeChild(subtree);
        // eslint-disable-next-line no-param-reassign
        item[this.constants.OJ_ITEM_METADATA].leaf = true;
        item.classList.add(this.constants.OJ_TREEVIEW_LEAF);
        item.classList.remove(this.constants.OJ_EXPANDED);
        item.removeAttribute('aria-expanded');
        item.classList.remove(this.constants.OJ_COLLAPSED);
        var spacer = this._getItemSpacer(item);
        this._removeIndentation(spacer);
        this._addIndentation(item, spacer);

        var key = this._getKey(item);
        var keys = [];
        keys.push(key);
        var expanded = this.options.expanded;
        if (expanded != null) {
          var newExpanded = expanded.delete(keys);
          this._uiExpanded.delete(keys);
          // update selection option if it did changed
          if (expanded !== newExpanded) {
            this._userOptionChange('expanded', newExpanded, null);
          }
        }

        var disclosureIcon = this._getItemDisclosureIcon(item);
        this._removeDisclosureClasses(disclosureIcon);
      },
      _changeNodeToParent: function (item) {
        // eslint-disable-next-line no-param-reassign
        item[this.constants.OJ_ITEM_METADATA].leaf = false;
        item.classList.remove(this.constants.OJ_TREEVIEW_LEAF);
        item.classList.add(this.constants.OJ_COLLAPSED);
        this._setAriaExpanded(item, 'false');
        var spacer = this._getItemSpacer(item);
        this._removeIndentation(spacer);
        this._addIndentation(item, spacer);

        var disclosureIcon = this._getItemDisclosureIcon(item);
        this._addDisclosureClasses(disclosureIcon);
      },
      _setAriaExpanded: function (item, state) {
        item.setAttribute('aria-expanded', state);
      },
      _getItemDisclosureIcon: function (item) {
        return item.getElementsByTagName('ins')[0];
      },
      _removeAllChildrenOfParentKey: function (key, savedParentKey, reorder) {
        /* savedParentKey means remove all children but leave parent called when we have a smart refresh event from the dp*/
        var self = this;
        var removedKeys = [];
        var elem = this._getItemByKey(key);
        if (elem) {
          this._getChildItems(elem).forEach(function (child) {
            var childkey = self._getKey(child);
            var childKeys = self._removeAllChildrenOfParentKey(childkey, savedParentKey, reorder);
            removedKeys = removedKeys.concat(childKeys);
          });
          var subtree = elem.parentNode;
          if (!oj.KeyUtils.equals(key, savedParentKey)) {
            subtree.removeChild(elem);
            this._cleanTemplateNodes(elem);
            this._keyList.delete(key);
            if (!reorder) {
              removedKeys.push(key);
            }
          }
          if (subtree.getElementsByTagName('li').length === 0 && !savedParentKey && !reorder) {
            this._changeNodeToLeaf(subtree.parentNode, subtree);
          }
        }
        return removedKeys;
      },
      _isLeafIcon: function (item) {
        return item.classList.contains(this.constants.OJ_TREEVIEW_LEAF);
      },
      handleModelReorder: function (moveKey, locationKey, afterFlag) {
        var locationItem = this._getItemByKey(locationKey);
        var locationItemParent = locationItem.parentElement;
        var reorderItem = this._getItemByKey(moveKey);
        var reorderParent = reorderItem.parentElement;
        var subtree = reorderItem.parentNode;
        reorderParent.removeChild(reorderItem);
        if (reorderParent.getElementsByTagName('li').length === 0) {
          this._changeNodeToLeaf(subtree.parentNode, subtree);
        }
        if (afterFlag) {
          locationItemParent.insertBefore(reorderItem, locationItem.nextSibling); // @HTMLUpdateOK
        } else {
          locationItemParent.insertBefore(reorderItem, locationItem); // @HTMLUpdateOK
        }
      },
      getLastItemKey(list) {
        return this._getKey(list[list.length - 1]);
      },
      handleModelAddEvent: function (event) {
        var addEvent = event.detail.add;
        var parentKeys = addEvent.parentKeys;
        var indexes = addEvent.indexes;
        var i = 0;
        var self = this;
        var addKeys = event.detail.add.keys;
        const addEventBusyResolve = this._addBusyState(
          'validating mutation data for add event',
          null
        );
        this._fetchEventDataForKeys(addEvent).then((validatededEventData) => {
          if (validatededEventData === null) {
            addEventBusyResolve();
            return;
          }
          this._truncateIfOverMaxCount(validatededEventData);
          const data = validatededEventData.data;
          const metadata = validatededEventData.metadata;
          parentKeys.forEach(function (key) {
            var parentItem = self._getItemByKey(key);
            if (parentItem && self._isLeafIcon(parentItem)) {
              self._changeNodeToParent(parentItem);
            }
          });
          const initialKeys = this._getAllTreeviewKeys();
          const finalKeys = DataCollectionUtils.getAddEventKeysResult(initialKeys, addEvent, true);
          if (
            data &&
            addKeys.size > 0 &&
            data.length > 0 &&
            addKeys.size === data.length &&
            (indexes == null || indexes.length === data.length)
          ) {
            for (i = 0; i < data.length; i++) {
              var parentKey = parentKeys[i];
              var index = this._getInsertIndex(metadata[i].key, parentKey, finalKeys);
              if (index === null) {
                // cannot find index, skip this iteration
                // eslint-disable-next-line no-continue
                continue;
              }
              var parentItem = this._getItemByKey(parentKey);
              var subtree;
              if (parentKey == null) {
                subtree = this._getRoot();
              } else if (parentItem) {
                subtree = this._getSubtree(parentItem);
              }
              if (subtree) {
                this._renderItem(subtree, { data: [data[i]], metadata: [metadata[i]] }, 0, index);
              }
            }
            this._refreshTopAndBottomSelectionClasses();
          }
          addEventBusyResolve();
        });
      },
      _getInsertIndex: function (key, parentKey, finalKeys) {
        let parent;
        if (!parentKey) {
          parent = this.element[0];
        } else {
          parent = this._getItemByKey(parentKey);
        }
        // bad parent key or do not have parentKey yet
        // potentially parent added out of order real gross
        if (!parent) {
          return null;
        }
        let finalKeysIndex = finalKeys.indexOf(key);
        if (finalKeysIndex === -1) {
          return null;
        }
        let childItems = this._getChildItems(parent);
        // assume insert at end
        let index = childItems.length;
        for (let i = 0; i < childItems.length; i++) {
          let child = childItems[i];
          let childKey = this._getKey(child);
          if (finalKeys.indexOf(childKey) > finalKeysIndex) {
            index = i;
            break;
          }
        }
        return index;
      },
      _getAllTreeviewKeys: function () {
        const keys = [];
        const items = this._getItems();
        for (let i = 0; i < items.length; i++) {
          keys.push(this._getKey(items[i]));
        }
        return keys;
      },
      handleModelChangeEvent: function (event) {
        const changeEvent = event.detail.update;
        const changeEventBusyResolve = this._addBusyState(
          'validating mutation data for change event',
          null
        );
        this._fetchEventDataForKeys(changeEvent).then((validatededEventData) => {
          if (validatededEventData === null) {
            changeEventBusyResolve();
            return;
          }
          const keys = [...validatededEventData.keys];
          for (let i = 0; i < keys.length; i++) {
            const elem = this._getItemByKey(keys[i]);
            if (elem != null) {
              const insertIndex = this._indexToParent(elem);
              this._renderItem(
                null,
                {
                  data: [validatededEventData.data[i]],
                  metadata: [validatededEventData.metadata[i]]
                },
                0,
                insertIndex,
                true
              );
            }
          }
          this._resetFocus();
          this._refreshTopAndBottomSelectionClasses();
          changeEventBusyResolve();
        });
      },
      _fetchEventDataForKeys: function (eventData) {
        return new Promise((resolve) => {
          const dataProviderPromiseBusyResolve = this._addBusyState('getting data provider', null);
          const dataProviderPromise = this._getDataProvider();
          dataProviderPromise.then(
            (dataProvider) => {
              resolve(DataCollectionUtils.getEventDetail(dataProvider, eventData));
              dataProviderPromiseBusyResolve();
            },
            function (reason) {
              Logger.error(this.constants.ERROR_FETCHING_DATA + reason);
              dataProviderPromiseBusyResolve();
            }
          );
        });
      },
      _indexToParent: function (elem) {
        var index = 0;
        for (var i = 0; i < elem.parentNode.children.length; i++) {
          if (elem.parentNode.children[i] === elem) {
            index = i;
            break;
          }
        }
        return index;
      },
      handleModelRefreshEvent: function (event) {
        // if treeview is busy, queue it for processing later
        if (!this.isReady()) {
          this._pushToEventQueue(event);
          return;
        }
        if (event.detail && event.detail.keys) {
          const keys = event.detail.keys;
          // smart refresh
          keys.forEach((key) => {
            const item = this._getItemByKey(key);
            if (item && !this._isLeaf(item)) {
              // recrusive method needs to pass parent key down
              this._removeAllChildrenOfParentKey(key, key);
              const subtree = this._getSubtree(item);
              if (subtree) {
                item.removeChild(subtree);
              }
              if (this._isExpanded(item)) {
                item.classList.remove(this.constants.OJ_EXPANDED);
                this._expand(item, true);
              }
            }
          });
          this._refreshTopAndBottomSelectionClasses();
        } else {
          // full refresh
          this._clearEventQueue();
          this.refresh();
        }
      },
      _isSkeletonSupported: function () {
        var defaults = this._getOptionDefaults();
        return defaults.loadIndicator === 'skeleton';
      },
      _getOptionDefaults: function () {
        if (this.defaultOptions == null) {
          this.defaultOptions = {};
          const keys = Object.keys(this.constants.OJ_TREEVIEW_CSS_VARS);
          const vars = keys.map((key) => this.constants.OJ_TREEVIEW_CSS_VARS[key]);
          const values = ThemeUtils.getCachedCSSVarValues(vars);
          keys.forEach((key, i) => {
            this.defaultOptions[key] = values[i];
          });
        }
        return this.defaultOptions;
      },
      _renderChildSkeletons: function (parentKey) {
        var parentItem = this._getItemByKey(parentKey);
        this._removeExistingSkeletons(parentItem);
        var disclosureIconWidth = this._getItemDisclosureIcon(parentItem).offsetWidth;
        var isRTL = this._GetReadingDirection() === 'rtl';
        var threeItemedSkeleton = this._buildThreeItemedSkeleton();
        var skeletonContainer = this._buildSkeletonContainer();
        var skeletonMargin = disclosureIconWidth;
        var depth = this._getDepth(parentItem);
        if (isRTL) {
          skeletonContainer.style.marginRight = skeletonMargin + disclosureIconWidth / depth + 'px';
        } else {
          skeletonContainer.style.marginLeft = skeletonMargin + disclosureIconWidth / depth + 'px';
        }
        skeletonContainer.appendChild(threeItemedSkeleton); // @HTMLUpdateOK
        parentItem.appendChild(skeletonContainer); // @HTMLUpdateOK
      },
      _renderInitialSkeletons: function () {
        this._removeExistingSkeletons(this.element[0]);
        var threeItemedSkeleton = this._buildThreeItemedSkeleton();
        var twoItemedSkeleton = this._buildTwoItemedSkeleton();
        var skeletonContainer = this._buildSkeletonContainer();
        skeletonContainer.appendChild(threeItemedSkeleton); // @HTMLUpdateOK
        skeletonContainer.appendChild(twoItemedSkeleton); // @HTMLUpdateOK
        this.element[0].classList.add(this.constants.OJ_COMPLETE);
        this.element[0].appendChild(skeletonContainer); // @HTMLUpdateOK

        var skeletonHeight = skeletonContainer.offsetHeight;
        var treeviewHeight = this.element[0].offsetHeight;
        var treeviewItemHeight = skeletonHeight / 5; // number of skeleton items
        var i = 0;
        if (skeletonHeight < treeviewHeight) {
          do {
            if (i % 2 === 0) {
              skeletonHeight += treeviewItemHeight * 3; // number of skeleton items
              skeletonContainer.appendChild(this._buildThreeItemedSkeleton()); // @HTMLUpdateOK
            } else {
              skeletonHeight += treeviewItemHeight * 2; // number of skeleton items
              skeletonContainer.appendChild(this._buildTwoItemedSkeleton()); // @HTMLUpdateOK
            }
            i += 1;
          } while (skeletonHeight <= treeviewHeight);
        }
        if (skeletonHeight > treeviewHeight) {
          var skeletonContents = skeletonContainer.querySelectorAll(
            this.constants.PERIOD + this.constants.OJ_TREEVIEW_SKELETON_CONTENT
          );
          for (i = skeletonContents.length - 1; i >= 0; i--) {
            skeletonHeight -= treeviewItemHeight;
            skeletonContainer.removeChild(skeletonContents[i]);
            if (skeletonHeight <= treeviewHeight) {
              break;
            }
          }
        }
      },
      _removeExistingSkeletons: function (item) {
        var existingSkeletonContainers = item.querySelectorAll(
          this.constants.PERIOD + this.constants.OJ_TREEVIEW_SKELETON_CONTAINER
        );
        for (var i = 0; i < existingSkeletonContainers.length; i++) {
          item.removeChild(existingSkeletonContainers[i]);
        }
      },
      _getSkeletonContainer: function (item) {
        return item.getElementsByClassName(this.constants.OJ_TREEVIEW_SKELETON_CONTAINER)[0];
      },
      _removeSkeleton: function (parentKey) {
        return new Promise(
          function (resolve) {
            var self = this;
            var skeletonBusyResolve = self._addBusyState('removing skeleton', parentKey);
            self._changeStatusMessage(parentKey, true);
            var skeletonContainer;
            if (parentKey === null) {
              skeletonContainer = this._getSkeletonContainer(self.element[0]);
            } else {
              skeletonContainer = this._getSkeletonContainer(this._getItemByKey(parentKey));
            }
            if (!skeletonContainer) {
              skeletonBusyResolve();
              resolve();
            } else {
              ojanimation.fadeOut(skeletonContainer, { duration: '100ms' }).then(function () {
                if (skeletonContainer.parentElement) {
                  skeletonContainer.parentElement.removeChild(skeletonContainer);
                }
                skeletonBusyResolve();
                resolve();
              });
            }
          }.bind(this)
        );
      },
      _buildThreeItemedSkeleton: function () {
        var fragment = this._buildTwoItemedSkeleton();
        var leaf = this._buildSkeletonLeafContent();
        fragment.appendChild(leaf); // @HTMLUpdateOK
        return fragment;
      },
      _buildTwoItemedSkeleton: function () {
        var fragment = new DocumentFragment();
        var firstChild = this._buildSkeletonContent(false);
        fragment.appendChild(firstChild); // @HTMLUpdateOK
        var secondChild = this._buildSkeletonContent(true);
        fragment.appendChild(secondChild); // @HTMLUpdateOK
        return fragment;
      },
      _buildSkeletonContainer: function () {
        var skeletonContainer = document.createElement('div');
        skeletonContainer.classList.add(this.constants.OJ_TREEVIEW_SKELETON_CONTAINER);
        skeletonContainer.classList.add(this.constants.OJ_ANIMATION_SKELETON_FADE_IN);
        return skeletonContainer;
      },
      _buildSkeletonContent: function (child) {
        var contentDiv = document.createElement('div');
        contentDiv.classList.add(this.constants.OJ_TREEVIEW_SKELETON_CONTENT);
        var carrotDiv = this._buildSkeletonCarrot();
        if (child) {
          carrotDiv.classList.add(this.constants.OJ_TREEVIEW_SKELETON_CHILD);
        }
        contentDiv.appendChild(carrotDiv); // @HTMLUpdateOK
        contentDiv.appendChild(this._buildSkeletonItem()); // @HTMLUpdateOK
        return contentDiv;
      },
      _buildSkeletonCarrot: function () {
        var carrotDiv = document.createElement('div');
        carrotDiv.classList.add(this.constants.OJ_TREEVIEW_SKELETON_CARROT);
        carrotDiv.classList.add(this.constants.OJ_ANIMATION_SKELETON);
        return carrotDiv;
      },
      _buildSkeletonItem: function () {
        var itemDiv = document.createElement('div');
        itemDiv.classList.add(this.constants.OJ_TREEVIEW_SKELETON_ITEM);
        itemDiv.classList.add(this.constants.OJ_ANIMATION_SKELETON);
        return itemDiv;
      },
      _buildSkeletonLeafContent: function () {
        var contentDiv = document.createElement('div');
        contentDiv.classList.add(this.constants.OJ_TREEVIEW_SKELETON_CONTENT);
        contentDiv.appendChild(this._buildSkeletonLeafItem()); // @HTMLUpdateOK
        return contentDiv;
      },
      _buildSkeletonLeafItem: function () {
        var leafDiv = document.createElement('div');
        leafDiv.classList.add(this.constants.OJ_TREEVIEW_SKELETON_LEAF);
        leafDiv.classList.add(this.constants.OJ_ANIMATION_SKELETON);
        return leafDiv;
      },
      _closest: function (element, selector) {
        if (!element) {
          return null;
        }
        if (!element.closest) {
          do {
            if (this._matches(element, selector)) return element;
            // eslint-disable-next-line no-param-reassign
            element = element.parentElement || element.parentNode;
          } while (element !== null && element.nodeType === 1);
          return null;
        }
        return element.closest(selector);
      },
      _getParents: function (elem, parentSelector) {
        var parents = [];
        // eslint-disable-next-line no-param-reassign
        for (; elem && elem !== this.element[0]; elem = elem.parentNode) {
          if (this._matches(elem, parentSelector)) {
            parents.push(elem);
          }
        }
        return parents;
      },
      _getNextSibling: function (elem, selector) {
        var sibling = elem.nextElementSibling;
        if (!selector) return sibling;
        while (sibling) {
          if (this._matches(sibling, selector)) return sibling;
          sibling = sibling.nextElementSibling;
        }
        return null;
      },
      _getPreviousSibling: function (elem, selector) {
        var sibling = elem.previousElementSibling;
        if (!selector) return sibling;
        while (sibling) {
          if (this._matches(sibling, selector)) return sibling;
          sibling = sibling.previousElementSibling;
        }
        return null;
      },
      _matches: function (elem, selector) {
        if (!elem.matches) {
          // eslint-disable-next-line no-param-reassign
          elem.matches =
            Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        return elem.matches(selector);
      }
    });
  })();

var __oj_tree_view_metadata = 
{
  "properties": {
    "currentItem": {
      "type": "any",
      "writeback": true,
      "readOnly": true
    },
    "data": {
      "type": "object",
      "extension": {
        "webelement": {
          "exceptionStatus": [
            {
              "type": "unsupported",
              "since": "13.0.0",
              "description": "Data sets from a DataProvider cannot be sent to WebDriverJS; use ViewModels or page variables instead."
            }
          ]
        }
      }
    },
    "dnd": {
      "type": "object",
      "properties": {
        "drag": {
          "type": "object",
          "properties": {
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "drag": {
                  "type": "function"
                },
                "dragEnd": {
                  "type": "function"
                },
                "dragStart": {
                  "type": "function"
                }
              }
            }
          }
        },
        "drop": {
          "type": "object",
          "properties": {
            "items": {
              "type": "object",
              "properties": {
                "dataTypes": {
                  "type": "string|Array<string>"
                },
                "dragEnter": {
                  "type": "function"
                },
                "dragLeave": {
                  "type": "function"
                },
                "dragOver": {
                  "type": "function"
                },
                "drop": {
                  "type": "function"
                }
              }
            }
          }
        }
      }
    },
    "expanded": {
      "type": "KeySet",
      "writeback": true
    },
    "item": {
      "type": "object",
      "properties": {
        "focusable": {
          "type": "function"
        },
        "renderer": {
          "type": "function"
        },
        "selectable": {
          "type": "function"
        }
      }
    },
    "scrollPolicyOptions": {
      "type": "Object<number>",
      "properties": {
        "maxCount": {
          "type": "number",
          "value": 500
        }
      }
    },
    "selected": {
      "type": "KeySet",
      "writeback": true
    },
    "selection": {
      "type": "Array<any>",
      "writeback": true,
      "value": []
    },
    "selectionMode": {
      "type": "string",
      "enumValues": [
        "leafOnly",
        "multiple",
        "none",
        "single"
      ],
      "value": "none"
    },
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "receivedDataAria": {
          "type": "string"
        },
        "retrievingDataAria": {
          "type": "string"
        },
        "treeViewSelectorAria": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getContextByNode": {},
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAnimateEnd": {},
    "ojAnimateStart": {},
    "ojBeforeCollapse": {},
    "ojBeforeCurrentItem": {},
    "ojBeforeExpand": {},
    "ojCollapse": {},
    "ojExpand": {}
  },
  "extension": {}
};
  /* global __oj_tree_view_metadata:false */
  (function () {
    __oj_tree_view_metadata.extension._WIDGET_NAME = 'ojTreeView';
    oj.CustomElementBridge.register('oj-tree-view', { metadata: __oj_tree_view_metadata });
  })();

});


define('ojs/ojhighlighttext',['exports', 'preact/jsx-runtime', 'preact', 'ojs/ojvcomponent'], function (exports, jsxRuntime, preact, ojvcomponent) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.HighlightText = class HighlightText extends preact.Component {
        constructor() {
            super(...arguments);
            this._HIGHLIGHT_TOKEN = '__@@__';
        }
        render(props) {
            const content = this._highlighter(props.text, props.matchText);
            return jsxRuntime.jsx(ojvcomponent.Root, { class: "oj-highlighttext", children: content });
        }
        _highlighter(unhighlightedText, matchText) {
            if (matchText) {
                const escapedMatchText = this._escapeRegExp(matchText);
                const highlightedText = unhighlightedText.replace(new RegExp(escapedMatchText, 'gi'), this._HIGHLIGHT_TOKEN + '$&' + this._HIGHLIGHT_TOKEN);
                const tokens = highlightedText.split(this._HIGHLIGHT_TOKEN);
                const nodes = tokens.map((current, index) => index % 2 == 0 ? current : jsxRuntime.jsx("span", { class: "oj-highlighttext-highlighter", children: current }));
                return jsxRuntime.jsx("span", { children: nodes });
            }
            return jsxRuntime.jsx("span", { children: unhighlightedText });
        }
        _escapeRegExp(str) {
            return str.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&');
        }
    };
    exports.HighlightText.defaultProps = {
        text: '',
        matchText: ''
    };
    exports.HighlightText._metadata = { "properties": { "text": { "type": "string" }, "matchText": { "type": "string" } } };
    exports.HighlightText = __decorate([
        ojvcomponent.customElement('oj-highlight-text')
    ], exports.HighlightText);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojinputsearch',['exports', 'preact/jsx-runtime', 'ojs/ojdomutils', 'ojs/ojlistdataproviderview', 'ojs/ojcore-base', 'ojs/ojconfig', 'ojs/ojcontext', 'ojs/ojlogger', 'ojs/ojthemeutils', 'ojs/ojtimerutils', 'ojs/ojtranslation', 'preact', 'ojs/ojhighlighttext', 'ojs/ojvcomponent', 'ojs/ojpopupcore'], function (exports, jsxRuntime, DomUtils, ojlistdataproviderview, oj, Config, Context, Logger, ThemeUtils, TimerUtils, Translations, preact, ojhighlighttext, ojvcomponent, ojpopupcore) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

    class InputSearchSkeleton extends preact.Component {
        constructor(props) {
            super(props);
        }
        render(props) {
            return (jsxRuntime.jsx("li", { role: "presentation", class: "oj-listbox-result", style: props.itemStyle, children: jsxRuntime.jsx("div", { class: "oj-listbox-result-label oj-listbox-skeleton-line-height oj-animation-skeleton" }) }));
        }
    }
    InputSearchSkeleton.defaultProps = {
        itemStyle: null
    };

    class InputSearchSkeletonList extends preact.Component {
        constructor(props) {
            super(props);
        }
        render(props) {
            const skeletonItems = [];
            for (let i = 0; i < props.numItems; i++) {
                skeletonItems.push(jsxRuntime.jsx(InputSearchSkeleton, { itemStyle: props.itemStyle }));
            }
            return (jsxRuntime.jsx("ul", { role: "listbox", id: props.id, class: "oj-listbox-results oj-inputsearch-results", children: skeletonItems }));
        }
    }
    InputSearchSkeletonList.defaultProps = {
        id: null,
        numItems: 1,
        itemStyle: null
    };

    class InputSearchSuggestion extends preact.Component {
        constructor(props) {
            super(props);
            this._handleMouseenter = (event) => {
                if (!DomUtils.recentTouchEnd()) {
                    this.setState({ ['hover']: true });
                }
            };
            this._handleMouseleave = (event) => {
                this.setState({ ['hover']: false });
            };
            this._handleClick = (event) => {
                const mainButton = event.button === 0;
                if (mainButton) {
                    this._fireSuggestionActionEvent(this.props.formattedText, this.props.suggestionItemContext);
                }
            };
            this._fireSuggestionActionEvent = (text, itemContext) => {
                this.props.onOjSuggestionAction?.({ text: text, itemContext: itemContext });
            };
            this.state = {
                hover: false
            };
        }
        fireSuggestionAction() {
            this._fireSuggestionActionEvent(this.props.formattedText, this.props.suggestionItemContext);
        }
        getFormattedText() {
            return this.props.formattedText;
        }
        render(props, state) {
            let rootClasses = 'oj-listbox-result oj-listbox-result-selectable';
            if (state.hover) {
                rootClasses += ' oj-hover';
            }
            if (props.focus) {
                rootClasses += ' oj-focus';
            }
            const content = this._renderContent(props);
            return (jsxRuntime.jsx("li", { role: "presentation", class: rootClasses, onClick: this._handleClick, onMouseEnter: this._handleMouseenter, onMouseLeave: this._handleMouseleave, children: jsxRuntime.jsx("div", { id: props.labelId, class: "oj-listbox-result-label", role: "option", children: content }) }));
        }
        _renderContent(props) {
            const renderer = props.suggestionItemTemplate;
            if (renderer) {
                return renderer({
                    data: props.suggestionItemContext.data,
                    key: props.suggestionItemContext.key,
                    metadata: props.suggestionItemContext.metadata,
                    index: props.index,
                    searchText: props.searchText
                });
            }
            return (jsxRuntime.jsx(ojhighlighttext.HighlightText, { "data-oj-internal": true, text: props.formattedText, matchText: props.searchText ?? '' }));
        }
    }
    InputSearchSuggestion.defaultProps = {
        focus: false,
        formattedText: '',
        index: -1,
        labelId: '',
        searchText: null
    };

    class InputSearchSuggestionsList extends preact.Component {
        constructor(props) {
            super(props);
            this._renderedSuggestions = [];
            this.getCount = () => {
                const length = this._renderedSuggestions.length;
                const nullIndex = this._renderedSuggestions.indexOf(null);
                return nullIndex === -1 ? length : nullIndex;
            };
            this.getFormattedText = (index) => {
                return this._renderedSuggestions[index]?.getFormattedText();
            };
            this.fireSuggestionAction = (index) => {
                this._renderedSuggestions[index]?.fireSuggestionAction();
            };
            this._setRenderedSuggestion = (index, suggestion) => {
                this._renderedSuggestions[index] = suggestion;
            };
        }
        render(props) {
            if (props.data?.length > 0) {
                let suggestions = [];
                for (let i = 0; i < props.data.length; i++) {
                    const focused = i === props.focusIndex;
                    const formattedText = props.formatItemText(props.suggestionItemText, props.data[i]);
                    const suggestion = (jsxRuntime.jsx(InputSearchSuggestion, { ref: this._setRenderedSuggestion.bind(this, i), labelId: props.labelIds[i], focus: focused, index: i, formattedText: formattedText, searchText: props.searchText, suggestionItemContext: props.data[i], suggestionItemTemplate: props.suggestionItemTemplate, onOjSuggestionAction: props.onOjSuggestionAction }));
                    suggestions.push(suggestion);
                }
                return (jsxRuntime.jsx("ul", { role: "listbox", id: props.id, class: "oj-listbox-results oj-inputsearch-results", "aria-label": props['aria-label'], children: suggestions }));
            }
            return null;
        }
    }
    InputSearchSuggestionsList.defaultProps = {
        data: null,
        focusIndex: -1,
        formatItemText: null,
        id: null,
        labelIds: null,
        onOjSuggestionAction: null,
        searchText: null,
        suggestionItemTemplate: null
    };

    class ComposingInput extends preact.Component {
        constructor(props) {
            super(props);
            this._isComposing = false;
            this._setInputElem = (element) => {
                this._inputElem = element;
                this.props.inputRef?.(element);
            };
            this._handleCompositionstart = (event) => {
                this._isComposing = true;
                this.props.onCompositionStart?.call(this._inputElem, event);
            };
            this._handleCompositionend = (event) => {
                this._isComposing = false;
                this.props.onCompositionEnd?.call(this._inputElem, event);
                this.props.onInputChanged?.({ value: event.target.value });
            };
            this._handleInput = (event) => {
                this.props.onInput?.call(this._inputElem, event);
                if (!this._isComposing || this._isAndroidDevice) {
                    this.props.onInputChanged?.({ value: event.target.value });
                }
            };
            const agentInfo = oj.AgentUtils.getAgentInfo();
            this._isAndroidDevice = agentInfo.os === oj.AgentUtils.OS.ANDROID;
        }
        render(props) {
            const { onInputChanged, onInput, onCompositionStart, onCompositionEnd, ...passThroughProps } = props;
            return (jsxRuntime.jsx("input", { ref: this._setInputElem, onInput: this._handleInput, oncompositionstart: this._handleCompositionstart, oncompositionend: this._handleCompositionend, ...passThroughProps }));
        }
    }

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var InputSearch_1;
    exports.InputSearch = InputSearch_1 = class InputSearch extends preact.Component {
        constructor(props) {
            super(props);
            this._KEYS = {
                TAB: 9,
                ENTER: 13,
                ESC: 27,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                INPUT_METHOD_EDITOR: 229
            };
            this._counter = 0;
            this._queryCount = 0;
            this._handleMouseenter = (event) => {
                if (!DomUtils.recentTouchEnd()) {
                    this._updateState({ hover: true });
                }
            };
            this._handleMouseleave = (event) => {
                this._updateState({ hover: false });
            };
            this._handleFocusin = (event) => {
                if (event.target === event.currentTarget) {
                    this._handleFocus(event);
                }
                this._updateState({ focus: true });
            };
            this._handleFocusout = (event) => {
                if (event.target === event.currentTarget) {
                    this._handleBlur(event);
                }
                this._updateState({ focus: false });
            };
            this._handleMobileFilterInputFocusin = (event) => {
                this._updateState({ mobileFilterInputFocus: true });
            };
            this._handleMobileFilterInputFocusout = (event) => {
                this._updateState({ mobileFilterInputFocus: false });
            };
            this._handleMobileFilterClear = (event) => {
                this._mobileFilterInputElem?.focus();
                this._updateState({
                    filterText: '',
                    displayValue: '',
                    showAutocompleteText: false,
                    autocompleteFloatingText: null
                });
            };
            this._handleMobileDropdownBack = (event) => {
                this._mainInputElem?.focus();
                this._updateState({
                    dropdownOpen: false,
                    filterText: this.props.value,
                    displayValue: this.props.value
                });
            };
            this._handleInputChanged = (detail) => {
                const value = detail.value;
                const filterText = this.state.filterText || '';
                const lowercaseFilter = filterText.toLowerCase();
                const lowercaseValue = value.toLowerCase();
                const updatedState = {};
                if (this.state.showAutocompleteText &&
                    !this.state.autocompleteFloatingText &&
                    filterText === value) {
                    Object.assign(updatedState, {
                        showAutocompleteText: false,
                        focusedSuggestionIndex: -1
                    });
                }
                else if (!this.state.showAutocompleteText &&
                    lowercaseValue.length < lowercaseFilter.length &&
                    lowercaseFilter.startsWith(lowercaseValue)) {
                    Object.assign(updatedState, {
                        showAutocompleteText: false
                    });
                }
                else {
                    Object.assign(updatedState, {
                        showAutocompleteText: value.length > 0
                    });
                }
                Object.assign(updatedState, {
                    filterText: value,
                    displayValue: value,
                    dropdownOpen: true
                });
                this._updateState(updatedState);
            };
            this._handleFocus = (event) => {
                this._rootElem?.dispatchEvent(new FocusEvent('focus', { relatedTarget: event.relatedTarget }));
            };
            this._handleBlur = (event) => {
                this._rootElem?.dispatchEvent(new FocusEvent('blur', { relatedTarget: event.relatedTarget }));
            };
            this._handleFilterInputKeydownEnter = (event) => {
                const focusIndex = this.state.focusedSuggestionIndex;
                if (this.state.dropdownOpen &&
                    focusIndex >= 0 &&
                    this._suggestionsList?.getCount() > focusIndex &&
                    !this._resolveFetchBusyState) {
                    this._suggestionsList?.fireSuggestionAction(focusIndex);
                }
                else {
                    return {
                        dropdownOpen: false,
                        valueSubmitted: true,
                        actionDetail: null
                    };
                }
                return null;
            };
            this._handleDesktopMainInputKeydown = (event) => {
                const updatedState = { lastEventType: 'keyboard' };
                const keyCode = event.keyCode;
                switch (keyCode) {
                    case this._KEYS.ENTER:
                        const enterKeyUpdatedState = this._handleFilterInputKeydownEnter(event);
                        if (enterKeyUpdatedState) {
                            Object.assign(updatedState, enterKeyUpdatedState);
                        }
                        break;
                    case this._KEYS.TAB:
                        Object.assign(updatedState, {
                            dropdownOpen: false,
                            focus: false,
                            actionDetail: null
                        });
                        if (this.state.showAutocompleteText) {
                            Object.assign(updatedState, {
                                showAutocompleteText: false,
                                resetFilterInputSelectionRange: true
                            });
                        }
                        break;
                    case this._KEYS.ESC:
                        if (this.state.dropdownOpen) {
                            updatedState.dropdownOpen = false;
                            if (this.state.showAutocompleteText) {
                                Object.assign(updatedState, {
                                    showAutocompleteText: false,
                                    displayValue: this.state.filterText
                                });
                            }
                            event.preventDefault();
                        }
                        break;
                    case this._KEYS.UP:
                    case this._KEYS.DOWN:
                        if (!this.state.dropdownOpen) {
                            updatedState.dropdownOpen = true;
                        }
                        else if (!this._resolveFetchBusyState && this._suggestionsList?.getCount() > 0) {
                            let index = this.state.focusedSuggestionIndex;
                            if (keyCode === this._KEYS.DOWN || index === -1) {
                                index += 1;
                                updatedState.scrollFocusedSuggestionIntoView = 'bottom';
                            }
                            else if (index > 0) {
                                index -= 1;
                                updatedState.scrollFocusedSuggestionIntoView = 'top';
                                event.preventDefault();
                            }
                            index = Math.min(this._suggestionsList?.getCount() - 1, index);
                            updatedState.focusedSuggestionIndex = index;
                            const autocomplete = index === 0 && this.state.filterText?.length > 0;
                            updatedState.showAutocompleteText = autocomplete;
                            if (autocomplete) {
                                updatedState.displayValue = this.state.filterText;
                            }
                            else if (index > -1) {
                                updatedState.displayValue = this._suggestionsList?.getFormattedText(index);
                            }
                        }
                        break;
                    case this._KEYS.LEFT:
                    case this._KEYS.RIGHT:
                        if (this.state.showAutocompleteText && !this.state.autocompleteFloatingText) {
                            Object.assign(updatedState, {
                                showAutocompleteText: false,
                                filterText: this.state.displayValue
                            });
                        }
                        break;
                    default:
                        break;
                }
                if (keyCode !== this._KEYS.INPUT_METHOD_EDITOR) {
                    this._updateState(updatedState);
                }
            };
            this._handleMobileFilterInputKeydown = (event) => {
                const updatedState = { lastEventType: 'keyboard' };
                const keyCode = event.keyCode;
                switch (keyCode) {
                    case this._KEYS.ENTER:
                        const enterKeyUpdatedState = this._handleFilterInputKeydownEnter(event);
                        if (enterKeyUpdatedState) {
                            Object.assign(updatedState, enterKeyUpdatedState);
                        }
                        break;
                    default:
                        break;
                }
                this._updateState(updatedState);
            };
            this._handleMousedown = (event) => {
                const mainButton = event.button === 0;
                if (mainButton) {
                    this._updateState({
                        focus: true,
                        dropdownOpen: true
                    });
                    if (event.target !== this._mainInputElem || this.state.fullScreenPopup) {
                        event.preventDefault();
                    }
                    else {
                        this._handleFilterInputMousedown(event);
                    }
                }
            };
            this._handleFilterInputMousedown = (event) => {
                if (this.state.showAutocompleteText) {
                    if (!this.state.autocompleteFloatingText) {
                        this._updateState({
                            showAutocompleteText: false,
                            filterText: this.state.displayValue
                        });
                    }
                    else {
                        this._updateState({
                            showAutocompleteText: false,
                            filterText: this.state.autocompleteFloatingText,
                            displayValue: this.state.autocompleteFloatingText
                        });
                    }
                }
            };
            this._handleDesktopDropdownMousedown = (event) => {
                const mainButton = event.button === 0;
                if (mainButton) {
                    this._updateState({ focus: true });
                    event.preventDefault();
                }
            };
            this._handleDropdownMousemove = (event) => {
                this._updateState({ lastEventType: 'mouse' });
            };
            this._handleDropdownMouseleave = (event) => {
                this._updateState({ lastEventType: null });
            };
            this._setRootElem = (element) => {
                this._rootElem = element;
            };
            this._setDropdownElem = (element) => {
                this._dropdownElem = element;
            };
            this._setMainInputElem = (element) => {
                this._mainInputElem = element;
            };
            this._setMainInputContainerElem = (element) => {
                this._mainInputContainerElem = element;
            };
            this._setSuggestionsList = (vnode) => {
                this._suggestionsList = vnode;
            };
            this._setMobileFilterInputElem = (element) => {
                this._mobileFilterInputElem = element;
            };
            this._getFilterInputElem = () => {
                return this._mobileFilterInputElem || this._mainInputElem;
            };
            this._clickAwayHandler = (event) => {
                const target = event.target;
                if (target.closest('#' + CSS.escape(this._getDropdownElemId())) ||
                    target.closest('#' + CSS.escape(this._getMainInputContainerId()))) {
                    return;
                }
                const updatedState = { dropdownOpen: false };
                if (this.state.showAutocompleteText) {
                    Object.assign(updatedState, {
                        showAutocompleteText: false,
                        resetFilterInputSelectionRange: true
                    });
                }
                this._updateState(updatedState);
            };
            this._handleDataProviderRefreshEventListener = (event) => {
                this._updateState({ fetchedInitial: false });
            };
            this._handleSuggestionAction = (detail) => {
                this._updateState({
                    filterText: detail.text,
                    displayValue: detail.text,
                    dropdownOpen: false,
                    valueSubmitted: true,
                    actionDetail: detail.itemContext
                });
            };
            this._uniqueId = props['id'] ? props['id'] : ojvcomponent.getUniqueId();
            const cssOptionDefaults = ThemeUtils.parseJSONFromFontFamily('oj-inputsearch-option-defaults') || {};
            let showIndicatorDelay = cssOptionDefaults.showIndicatorDelay;
            showIndicatorDelay = parseInt(showIndicatorDelay, 10);
            showIndicatorDelay = isNaN(showIndicatorDelay) ? 250 : showIndicatorDelay;
            this._showIndicatorDelay = showIndicatorDelay;
            const dropdownVerticalOffset = ThemeUtils.getCachedCSSVarValues(['--oj-private-core-global-dropdown-offset'])[0] || '0';
            this._dropdownVerticalOffset = parseInt(dropdownVerticalOffset, 10);
            if (props.suggestions) {
                this._dataProvider = this._wrapDataProviderIfNeeded(this.props.suggestions);
            }
            this.state = {
                dropdownOpen: false,
                dropdownAbove: false,
                valueSubmitted: false,
                focus: false,
                hover: false,
                active: false,
                displayValue: null,
                filterText: null,
                lastFetchedFilterText: null,
                fetchedData: null,
                labelIds: [],
                fetchedInitial: false,
                fetching: false,
                loading: false,
                focusedSuggestionIndex: -1,
                activeDescendantId: null,
                scrollFocusedSuggestionIntoView: null,
                actionDetail: null,
                lastEventType: null,
                showAutocompleteText: false,
                autocompleteFloatingText: null,
                initialRender: true,
                oldPropsValue: props.value,
                oldPropsSuggestions: props.suggestions,
                fullScreenPopup: props.suggestions && Config.getDeviceRenderMode() === 'phone',
                mobileFilterInputFocus: false,
                mobileFilterInputActive: false,
                resetFilterInputSelectionRange: false
            };
        }
        render(props, state) {
            let rootClasses = 'oj-inputsearch oj-form-control oj-text-field oj-component';
            if (state.hover) {
                rootClasses += ' oj-hover';
            }
            if (state.active) {
                rootClasses += ' oj-active';
            }
            if (state.focus) {
                rootClasses += ' oj-focus';
            }
            if (state.dropdownOpen) {
                rootClasses += ' oj-listbox-dropdown-open';
                if (state.dropdownAbove) {
                    rootClasses += ' oj-listbox-drop-above';
                }
            }
            if (state.fullScreenPopup) {
                rootClasses += ' oj-inputsearch-mobile';
            }
            const inputClasses = 'oj-inputsearch-input oj-text-field-input ';
            const iconClasses = 'oj-text-field-start-end-icon oj-inputsearch-search-icon oj-component-icon';
            const displayValue = state.displayValue || '';
            return this._renderEnabled(props, state, rootClasses, iconClasses, displayValue, inputClasses);
        }
        static getDerivedStateFromProps(props, state) {
            if (state.initialRender) {
                return this._initStateFromProps(props, state);
            }
            return this._updateStateFromProps(props, state);
        }
        static _initStateFromProps(props, state) {
            return {
                displayValue: props.value,
                filterText: props.value,
                fullScreenPopup: props.suggestions && Config.getDeviceRenderMode() === 'phone'
            };
        }
        static _updateStateFromProps(props, state) {
            const updatedState = {};
            if (props.value !== state.oldPropsValue &&
                ((!state.fullScreenPopup && props.value !== state.displayValue) ||
                    (state.fullScreenPopup && !state.dropdownOpen))) {
                updatedState.displayValue = props.value;
                updatedState.filterText = props.value;
            }
            if (state.oldPropsSuggestions != props.suggestions) {
                updatedState.fetchedInitial = false;
                updatedState.fullScreenPopup = props.suggestions && Config.getDeviceRenderMode() === 'phone';
            }
            if (!props.suggestions) {
                updatedState.dropdownOpen = false;
                updatedState.fetchedData = null;
            }
            if (state.dropdownOpen === false || updatedState.dropdownOpen === false) {
                updatedState.lastEventType = null;
                updatedState.showAutocompleteText = false;
            }
            if (!state.showAutocompleteText || updatedState.showAutocompleteText === false) {
                updatedState.autocompleteFloatingText = null;
            }
            return updatedState;
        }
        componentDidMount() {
            if (this.props.value !== null) {
                this.props.onRawValueChanged?.(this.props.value);
            }
            if (this._dataProvider) {
                this._addDataProviderEventListeners(this._dataProvider);
            }
            this._updateState({ initialRender: false });
        }
        _updateState(updater) {
            const newUpdater = function (state, props) {
                let partialState;
                if (typeof updater === 'function') {
                    partialState = updater(state, props);
                }
                else {
                    partialState = updater;
                }
                let changed = false;
                for (const key in partialState) {
                    if (partialState[key] !== state[key]) {
                        changed = true;
                        break;
                    }
                }
                return changed ? partialState : null;
            };
            this.setState(newUpdater);
        }
        componentDidUpdate(oldProps, oldState) {
            if (this.state.fullScreenPopup && !oldState.dropdownOpen && this.state.dropdownOpen) {
                this._mobileFilterInputElem?.focus();
            }
            if ((oldState.focus && !this.state.focus) || this.state.valueSubmitted) {
                if (this.props.value !== this.state.displayValue) {
                    this.props.onValueChanged?.(this.state.displayValue);
                }
                if (oldState.focus && !this.state.focus && oldState.filterText !== this.state.displayValue) {
                    this._updateState({ filterText: this.state.displayValue });
                }
                if (this.state.valueSubmitted) {
                    this.props.onOjValueAction?.({
                        value: this.state.displayValue,
                        itemContext: this.state.actionDetail,
                        previousValue: this.props.value
                    });
                    if (this.state.fullScreenPopup) {
                        this._mainInputElem?.focus();
                    }
                    this._updateState({ valueSubmitted: false });
                    if (this._testPromiseResolve) {
                        this._testPromiseResolve();
                        this._testPromiseResolve = null;
                    }
                }
            }
            if (oldState.displayValue != this.state.displayValue) {
                this.props.onRawValueChanged?.(this.state.displayValue);
            }
            if (oldProps.suggestions != this.props.suggestions) {
                if (oldProps.suggestions) {
                    this._removeDataProviderEventListeners(this._dataProvider);
                }
                if (this.props.suggestions) {
                    this._dataProvider = this._wrapDataProviderIfNeeded(this.props.suggestions);
                    this._addDataProviderEventListeners(this._dataProvider);
                }
                else {
                    this._dataProvider = null;
                    this._resolveFetching();
                }
            }
            if (!this.state.dropdownOpen) {
                if (oldState.dropdownOpen) {
                    this._updateState({ focusedSuggestionIndex: -1 });
                    this._resolveFetching();
                }
            }
            else {
                if (this.state.lastFetchedFilterText != this.state.filterText ||
                    (!this.state.fetchedInitial && !this._resolveFetchBusyState)) {
                    this._updateState({ lastFetchedFilterText: this.state.filterText });
                    this._fetchData(this.state.filterText);
                }
                if (!oldState.dropdownOpen || this.state.filterText !== oldState.filterText) {
                    if (!oldState.dropdownOpen && this.state.filterText === oldState.filterText) {
                        this._updateState({ focusedSuggestionIndex: -1 });
                    }
                    else {
                        this._updateState((state, props) => {
                            const newIndex = state.filterText?.length > 0 ? 0 : -1;
                            if (state.focusedSuggestionIndex !== newIndex) {
                                return { focusedSuggestionIndex: newIndex };
                            }
                            return null;
                        });
                    }
                }
                else if (this.state.fetchedData) {
                    this._updateState((state, props) => {
                        const newIndex = Math.min(state.fetchedData.length - 1, state.focusedSuggestionIndex);
                        if (state.focusedSuggestionIndex !== newIndex) {
                            return { focusedSuggestionIndex: newIndex };
                        }
                        return null;
                    });
                }
                const focusIndex = this._resolveFetchBusyState ? -1 : this.state.focusedSuggestionIndex;
                if (focusIndex >= 0 && this.state.labelIds.length > focusIndex) {
                    const filterText = this.state.filterText || '';
                    if (focusIndex === 0 && this.state.showAutocompleteText && filterText.length > 0) {
                        const firstSuggestionText = this._suggestionsList?.getFormattedText(0);
                        const lowercaseFirstSuggestionText = firstSuggestionText.toLowerCase();
                        const lowercaseFilterText = filterText.toLowerCase();
                        if (lowercaseFirstSuggestionText.startsWith(lowercaseFilterText)) {
                            const selectionStart = filterText.length;
                            const autocompleteText = firstSuggestionText.substr(selectionStart);
                            this._updateState({
                                displayValue: filterText + autocompleteText,
                                autocompleteFloatingText: null,
                                activeDescendantId: this.state.labelIds[focusIndex]
                            });
                            this._getFilterInputElem().setSelectionRange(selectionStart, selectionStart + autocompleteText.length);
                        }
                        else if (!this.state.fullScreenPopup) {
                            this._updateState({
                                autocompleteFloatingText: firstSuggestionText,
                                displayValue: filterText,
                                activeDescendantId: this.state.labelIds[focusIndex]
                            });
                        }
                        else {
                            this._updateState({
                                autocompleteFloatingText: null,
                                activeDescendantId: null,
                                focusedSuggestionIndex: -1
                            });
                        }
                    }
                    else {
                        this._updateState({
                            activeDescendantId: this.state.labelIds[focusIndex]
                        });
                    }
                }
                else {
                    this._updateState({ activeDescendantId: null });
                }
                if (!this._resolveFetchBusyState && this.state.labelIds.length === 0) {
                    if (!this.state.fullScreenPopup) {
                        this._updateState({ showAutocompleteText: false, dropdownOpen: false });
                    }
                    else {
                        this._updateState({ showAutocompleteText: false });
                    }
                }
            }
            const scrollFocusedSuggestionIntoView = this.state.scrollFocusedSuggestionIntoView;
            if (scrollFocusedSuggestionIntoView) {
                const activeDescendantId = this.state.activeDescendantId;
                if (activeDescendantId) {
                    const alignToTop = scrollFocusedSuggestionIntoView === 'top';
                    this._scrollSuggestionIntoView(activeDescendantId, alignToTop);
                    this._updateState({ scrollFocusedSuggestionIntoView: null });
                }
            }
            if (this.state.resetFilterInputSelectionRange) {
                this._getFilterInputElem()?.setSelectionRange(this.state.displayValue.length, this.state.displayValue.length);
                this._updateState({ resetFilterInputSelectionRange: false });
            }
            if (this.state.oldPropsValue !== this.props.value) {
                this._updateState({ oldPropsValue: this.props.value });
            }
            if (this.state.oldPropsSuggestions !== this.props.suggestions) {
                this._updateState({ oldPropsSuggestions: this.props.suggestions });
            }
        }
        componentWillUnmount() {
            if (this._dataProvider) {
                this._removeDataProviderEventListeners(this._dataProvider);
            }
            this._resolveFetching();
            this._updateState({ initialRender: true });
        }
        focus() {
            this._mainInputElem?.focus();
        }
        blur() {
            this._mainInputElem?.blur();
        }
        _getDropdownElemId() {
            return 'searchDropdown_' + this._uniqueId;
        }
        _getMainInputContainerId() {
            return 'searchInputContainer_' + this._uniqueId;
        }
        _getMobileFilterContainerId() {
            return 'searchMobileFilterContainer_' + this._uniqueId;
        }
        _getListboxId() {
            return 'searchSuggestionsListbox_' + this._uniqueId;
        }
        _getDesktopDropdownPosition() {
            const defPosition = {
                my: 'start top',
                at: 'start bottom',
                of: this._mainInputContainerElem,
                collision: 'flip',
                using: this._usingHandler.bind(this),
                offset: { x: 0, y: this._dropdownVerticalOffset }
            };
            const isRtl = DomUtils.getReadingDirection() === 'rtl';
            let position = oj.PositionUtils.normalizeHorizontalAlignment(defPosition, isRtl);
            position = oj.PositionUtils.coerceToJet(position);
            position = oj.PositionUtils.coerceToJqUi(position);
            position.of = defPosition.of;
            return position;
        }
        _getMobileDropdownPosition() {
            const scrollX = window.scrollX || window.pageXOffset;
            const scrollY = window.scrollY || window.pageYOffset;
            let position = {
                my: 'start top',
                at: 'start top',
                of: window,
                offset: { x: scrollX, y: scrollY }
            };
            const isRtl = DomUtils.getReadingDirection() === 'rtl';
            position = oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl);
            return position;
        }
        _getMobileDropdownStyle() {
            const dropdownStyle = {};
            const ww = Math.min(window.innerWidth, window.screen.availWidth);
            const hh = Math.min(window.innerHeight, window.screen.availHeight);
            const deviceType = Config.getDeviceType();
            if (deviceType === 'phone' && window.parent && window !== window.parent) {
                const parentHH = Math.min(window.parent.innerHeight, window.parent.screen.availHeight);
                const availContentHeight = Math.min(hh, parentHH);
                if (hh > availContentHeight) {
                    const diffHeight = hh - availContentHeight;
                    dropdownStyle['paddingBottom'] = diffHeight + 'px';
                }
            }
            dropdownStyle['width'] = ww + 'px';
            dropdownStyle['height'] = hh + 'px';
            return dropdownStyle;
        }
        _usingHandler(pos, props) {
            if (oj.PositionUtils.isAligningPositionClipped(props)) {
                this._updateState({ dropdownOpen: false });
            }
            else {
                var dropdownElem = props.element.element;
                dropdownElem.css(pos);
                this._updateState({ dropdownAbove: props.vertical === 'bottom' });
            }
        }
        _renderEnabled(props, state, rootClasses, iconClasses, displayValue, inputClasses) {
            const id = props['id'] ? props['id'] : null;
            const ariaLabel = props['aria-label'] ? props['aria-label'] : null;
            const listboxId = this._dataProvider ? this._getListboxId() : null;
            const agentInfo = oj.AgentUtils.getAgentInfo();
            const isMobile = agentInfo.os === oj.AgentUtils.OS.ANDROID ||
                agentInfo.os === oj.AgentUtils.OS.IOS ||
                agentInfo.os === oj.AgentUtils.OS.WINDOWSPHONE;
            const inputType = isMobile ? 'search' : 'text';
            const autocompleteFloatingElem = state.autocompleteFloatingText
                ? this._renderAutocompleteFloatingText(state.autocompleteFloatingText, displayValue)
                : null;
            const searchIcon = jsxRuntime.jsx("span", { class: iconClasses, role: "presentation" });
            const textFieldContainer = state.fullScreenPopup
                ? this._renderMobileMainTextFieldContainer(props, state, searchIcon, inputClasses, ariaLabel, listboxId)
                : this._renderDesktopMainTextFieldContainer(props, state, searchIcon, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem);
            const dropdown = state.dropdownOpen
                ? this._renderDropdown(props, state, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem)
                : null;
            const ariaLiveRegion = this._dataProvider ? this._renderAriaLiveRegion(state) : null;
            return (jsxRuntime.jsxs(ojvcomponent.Root, { id: id, ref: this._setRootElem, class: rootClasses, "aria-label": ariaLabel, onMouseDown: this._handleMousedown, onMouseEnter: this._handleMouseenter, onMouseLeave: this._handleMouseleave, children: [ariaLiveRegion, textFieldContainer, dropdown] }));
        }
        _renderAriaLiveRegion(state) {
            const text = state.fetchedInitial && !state.fetching && state.fetchedData?.length == 0
                ? Translations.getTranslatedString('oj-ojInputSearch2.noSuggestionsFound')
                : '\xa0';
            return (jsxRuntime.jsx("div", { id: 'oj-listbox-live-' + this._uniqueId, class: "oj-helper-hidden-accessible oj-listbox-liveregion", "aria-live": "polite", children: text }));
        }
        _renderDesktopMainTextFieldContainer(props, state, searchIcon, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem) {
            const containerClasses = 'oj-text-field-container oj-text-field-has-start-slot';
            return (jsxRuntime.jsxs("div", { role: "presentation", class: containerClasses, id: this._getMainInputContainerId(), ref: this._setMainInputContainerElem, children: [jsxRuntime.jsx("span", { class: "oj-text-field-start", children: searchIcon }), jsxRuntime.jsxs("div", { class: "oj-text-field-middle", role: this._dataProvider ? 'combobox' : undefined, "aria-label": this._dataProvider ? ariaLabel : null, "aria-controls": listboxId, "aria-haspopup": this._dataProvider ? 'listbox' : 'false', "aria-expanded": state.dropdownOpen ? 'true' : 'false', children: [jsxRuntime.jsx(ComposingInput, { type: inputType, inputRef: this._setMainInputElem, value: displayValue, class: inputClasses + ' oj-inputsearch-filter', placeholder: props.placeholder, autocomplete: "off", autocorrect: "off", autocapitalize: "off", spellcheck: false, autofocus: false, "aria-label": ariaLabel, "aria-autocomplete": this._dataProvider ? 'list' : null, "aria-busy": state.dropdownOpen && state.loading, "aria-activedescendant": this._dataProvider ? state.activeDescendantId : null, onfocusin: this._handleFocusin, onfocusout: this._handleFocusout, onInputChanged: this._handleInputChanged, onKeyDown: this._handleDesktopMainInputKeydown }), autocompleteFloatingElem] })] }));
        }
        _renderMobileMainTextFieldContainer(props, state, searchIcon, inputClasses, ariaLabel, listboxId) {
            const { placeholder, value } = props;
            const { dropdownOpen, loading } = state;
            const containerClasses = 'oj-text-field-container oj-text-field-has-start-slot';
            const mobileInputClasses = inputClasses +
                ' oj-inputsearch-input-displayonly ' +
                (value ? '' : ' oj-inputsearch-placeholder');
            return (jsxRuntime.jsxs("div", { role: "presentation", class: containerClasses, id: this._getMainInputContainerId(), children: [jsxRuntime.jsx("span", { class: "oj-text-field-start", children: searchIcon }), jsxRuntime.jsx("div", { class: "oj-text-field-middle", role: this._dataProvider ? 'combobox' : undefined, "aria-label": this._dataProvider ? ariaLabel : null, "aria-controls": listboxId, "aria-haspopup": this._dataProvider ? 'listbox' : 'false', "aria-expanded": dropdownOpen ? 'true' : 'false', children: jsxRuntime.jsx("div", { ref: this._setMainInputElem, class: mobileInputClasses, "aria-label": ariaLabel, "aria-busy": dropdownOpen && loading, tabIndex: 0, onfocusin: this._handleFocusin, onfocusout: this._handleFocusout, children: jsxRuntime.jsx("div", { children: value || placeholder }) }) })] }));
        }
        _renderMobileDropdownFilterField(props, state, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem) {
            let classes = 'oj-text-field';
            if (state.mobileFilterInputActive) {
                classes += ' oj-active';
            }
            if (state.mobileFilterInputFocus) {
                classes += ' oj-focus';
            }
            let containerClasses = 'oj-text-field-container oj-text-field-has-start-slot';
            const backIcon = this._renderMobileDropdownBackIcon();
            let clearIcon;
            if (displayValue && displayValue.length > 0) {
                containerClasses += ' oj-text-field-has-end-slot';
                clearIcon = this._renderMobileDropdownClearIcon();
            }
            return (jsxRuntime.jsx("div", { class: classes, children: jsxRuntime.jsxs("div", { role: "presentation", class: containerClasses, id: this._getMobileFilterContainerId(), children: [jsxRuntime.jsx("span", { class: "oj-text-field-start", children: backIcon }), jsxRuntime.jsxs("div", { class: "oj-text-field-middle", "aria-label": ariaLabel, "aria-owns": listboxId, children: [jsxRuntime.jsx(ComposingInput, { type: inputType, inputRef: this._setMobileFilterInputElem, value: displayValue, class: inputClasses + ' oj-inputsearch-filter', placeholder: props.placeholder, autocomplete: "off", autocorrect: "off", autocapitalize: "off", spellcheck: false, autofocus: false, "aria-label": ariaLabel, "aria-autocomplete": "list", "aria-controls": listboxId, "aria-busy": state.loading, "aria-activedescendant": state.activeDescendantId, onfocusin: this._handleMobileFilterInputFocusin, onfocusout: this._handleMobileFilterInputFocusout, onInputChanged: this._handleInputChanged, onKeyDown: this._handleMobileFilterInputKeydown, onMouseDown: this._handleFilterInputMousedown }), autocompleteFloatingElem] }), jsxRuntime.jsx("span", { class: "oj-text-field-end", children: clearIcon })] }) }));
        }
        _renderMobileDropdownBackIcon() {
            const backIconClasses = 'oj-inputsearch-back-icon oj-inputsearch-icon oj-component-icon oj-clickable-icon-nocontext';
            const backButtonAriaLabel = Translations.getTranslatedString('oj-ojInputSearch2.cancel');
            return (jsxRuntime.jsx("span", { class: "oj-inputsearch-back-button", role: "button", "aria-label": backButtonAriaLabel, onClick: this._handleMobileDropdownBack, children: jsxRuntime.jsx("span", { class: backIconClasses }) }));
        }
        _renderMobileDropdownClearIcon() {
            const clearIconClasses = 'oj-inputsearch-clear-icon oj-inputsearch-icon oj-component-icon' +
                ' oj-clickable-icon-nocontext';
            return (jsxRuntime.jsx("span", { class: "oj-inputsearch-clear-button", "aria-hidden": true, onClick: this._handleMobileFilterClear, children: jsxRuntime.jsx("span", { class: clearIconClasses }) }));
        }
        _renderDropdown(props, state, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem) {
            const dropdownContent = state.loading
                ? this._renderDropdownSkeleton()
                : this._renderDropdownSuggestions(props, state);
            let dropdownClasses = 'oj-listbox-drop oj-listbox-inputsearch';
            if (state.lastEventType === 'keyboard') {
                dropdownClasses += ' oj-listbox-hide-hover';
            }
            if (state.lastEventType === 'mouse') {
                dropdownClasses += ' oj-listbox-hide-focus';
            }
            if (state.fullScreenPopup) {
                return this._renderMobileDropdown(props, state, dropdownClasses, dropdownContent, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem);
            }
            return this._renderDesktopDropdown(props, state, dropdownClasses, dropdownContent);
        }
        _renderDesktopDropdown(props, state, dropdownClasses, dropdownContent) {
            const dropdownPosition = this._getDesktopDropdownPosition();
            const minWidth = this._rootElem.offsetWidth;
            const dropdownStyle = {
                minWidth: minWidth + 'px'
            };
            if (state.dropdownAbove) {
                dropdownClasses += ' oj-listbox-drop-above';
            }
            return this._renderVPopup(dropdownPosition, dropdownClasses, dropdownStyle, dropdownContent, null, this._handleDesktopDropdownMousedown);
        }
        _renderMobileDropdown(props, state, dropdownClasses, dropdownContent, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem) {
            const dropdownPosition = this._getMobileDropdownPosition();
            const dropdownStyle = this._getMobileDropdownStyle();
            dropdownClasses += ' oj-listbox-fullscreen';
            const dropdownFilterField = this._renderMobileDropdownFilterField(props, state, displayValue, inputClasses, ariaLabel, listboxId, inputType, autocompleteFloatingElem);
            return this._renderVPopup(dropdownPosition, dropdownClasses, dropdownStyle, dropdownContent, dropdownFilterField, null);
        }
        _renderVPopup(position, classes, style, content, headerContent, mousedownHandler) {
            return (jsxRuntime.jsx(ojpopupcore.VPopup, { position: position, layerSelectors: "oj-listbox-drop-layer", autoDismiss: this._clickAwayHandler, children: jsxRuntime.jsxs("div", { "data-oj-binding-provider": "preact", id: this._getDropdownElemId(), ref: this._setDropdownElem, class: classes, role: "presentation", style: style, onMouseDown: mousedownHandler, onMouseMove: this._handleDropdownMousemove, onMouseLeave: this._handleDropdownMouseleave, children: [headerContent, content] }) }));
        }
        _renderAutocompleteFloatingText(autocompleteFloatingText, displayValue) {
            const text = '\xa0\u2014\xa0' + autocompleteFloatingText;
            return (jsxRuntime.jsxs("div", { class: "oj-inputsearch-autocomplete-floating-container", children: [jsxRuntime.jsx("span", { style: "visibility: hidden;", children: displayValue }), jsxRuntime.jsx("span", { class: "oj-inputsearch-autocomplete-floating-text", children: text })] }));
        }
        _scrollSuggestionIntoView(activeDescendantId, alignToTop) {
            const labelElem = document.getElementById(activeDescendantId);
            const suggestionElem = labelElem.closest('.oj-listbox-result');
            const listboxElem = labelElem.closest('.oj-listbox-results');
            const suggestionTop = suggestionElem.offsetTop;
            const suggestionHeight = suggestionElem.offsetHeight;
            const listboxTop = listboxElem.scrollTop;
            const listboxHeight = listboxElem.offsetHeight;
            if (suggestionTop < listboxTop ||
                suggestionTop + suggestionHeight > listboxTop + listboxHeight) {
                listboxElem.scrollTop = alignToTop
                    ? suggestionTop
                    : suggestionTop + suggestionHeight - listboxHeight;
            }
        }
        _generateId() {
            return this._uniqueId + '-' + this._counter++;
        }
        _fetchData(_searchText) {
            this._queryCount += 1;
            const queryNumber = this._queryCount;
            let searchText = _searchText;
            if (searchText === '') {
                searchText = null;
            }
            const maxFetchCount = 12;
            let fetchParams = { size: maxFetchCount };
            if (searchText) {
                const filterCapability = this._dataProvider.getCapability('filter');
                if (!filterCapability || !filterCapability.textFilter) {
                    Logger.error('InputSearch: DataProvider does not support text filter. ' +
                        'Filtering results in dropdown may not work correctly.');
                }
                fetchParams['filterCriterion'] = oj.FilterFactory.getFilter({
                    filterDef: { text: searchText }
                });
            }
            this._updateState({ fetching: true });
            if (!this._loadingTimer) {
                const timer = TimerUtils.getTimer(this._showIndicatorDelay);
                timer.getPromise().then(function (pending) {
                    this._loadingTimer = null;
                    if (pending && this._dataProvider && this.state.dropdownOpen) {
                        this._updateState({ loading: true });
                    }
                }.bind(this));
                this._loadingTimer = timer;
            }
            let fetchedData = [];
            if (!this._resolveFetchBusyState) {
                this._resolveFetchBusyState = this._addBusyState('InputSearch: fetching suggestions');
            }
            const asyncIterator = this._dataProvider.fetchFirst(fetchParams)[Symbol.asyncIterator]();
            let remainingFetchCount = maxFetchCount;
            const processNextFunc = function (result) {
                if (queryNumber !== this._queryCount) {
                    return;
                }
                let done = result.done;
                const value = result.value;
                const data = value.data;
                const metadata = value.metadata;
                for (let i = 0; i < data.length; i++) {
                    const itemData = data[i];
                    const itemMetadata = metadata[i];
                    const itemKey = itemMetadata.key;
                    fetchedData.push({
                        data: itemData,
                        metadata: itemMetadata,
                        key: itemKey
                    });
                    remainingFetchCount -= 1;
                    if (remainingFetchCount === 0) {
                        done = true;
                        break;
                    }
                }
                if (done) {
                    let labelIds = [];
                    for (let i = 0; i < fetchedData.length; i++) {
                        labelIds.push('oj-inputsearch-result-label-' + this._generateId());
                    }
                    this._updateState({ fetchedInitial: true, labelIds, fetchedData });
                    this._resolveFetching();
                }
                else {
                    asyncIterator.next().then(processNextFunc);
                }
            }.bind(this);
            asyncIterator.next().then(processNextFunc);
        }
        _renderDropdownSkeleton() {
            let numItems = 1;
            let resultsWidth = 0;
            if (this._dropdownElem) {
                const items = this._dropdownElem.querySelectorAll('.oj-listbox-result');
                numItems = Math.max(1, items.length);
                if (items.length > 0) {
                    const resultsContainer = this._dropdownElem.querySelector('.oj-listbox-results');
                    resultsWidth = resultsContainer.offsetWidth;
                }
            }
            const resultStyle = resultsWidth > 0 ? { width: resultsWidth + 'px' } : null;
            return (jsxRuntime.jsx(InputSearchSkeletonList, { id: this._getListboxId(), numItems: numItems, itemStyle: resultStyle }));
        }
        _renderDropdownSuggestions(props, state) {
            if (state.fetchedData?.length > 0) {
                return (jsxRuntime.jsx(InputSearchSuggestionsList, { "aria-label": props['aria-label'], ref: this._setSuggestionsList, data: state.fetchedData, searchText: state.filterText, focusIndex: state.focusedSuggestionIndex, formatItemText: InputSearch_1._formatItemText, id: this._getListboxId(), labelIds: state.labelIds, onOjSuggestionAction: this._handleSuggestionAction, suggestionItemText: props.suggestionItemText, suggestionItemTemplate: props.suggestionItemTemplate }));
            }
            return null;
        }
        _addBusyState(description) {
            const elem = this._rootElem;
            const desc = 'The component identified by "' + elem.id + '" ' + description;
            const busyStateOptions = { description: desc };
            const busyContext = Context.getContext(elem).getBusyContext();
            return busyContext.addBusyState(busyStateOptions);
        }
        _isDataProvider(suggestions) {
            return suggestions?.['fetchFirst'] ? true : false;
        }
        _wrapDataProviderIfNeeded(suggestions) {
            if (this._isDataProvider(suggestions)) {
                let wrapper = suggestions;
                if (!(wrapper instanceof oj.ListDataProviderView)) {
                    wrapper = new oj.ListDataProviderView(wrapper);
                }
                return wrapper;
            }
            return null;
        }
        _addDataProviderEventListeners(dataProvider) {
            dataProvider.addEventListener('mutate', this._handleDataProviderRefreshEventListener);
            dataProvider.addEventListener('refresh', this._handleDataProviderRefreshEventListener);
        }
        _removeDataProviderEventListeners(dataProvider) {
            dataProvider.removeEventListener('mutate', this._handleDataProviderRefreshEventListener);
            dataProvider.removeEventListener('refresh', this._handleDataProviderRefreshEventListener);
        }
        _resolveFetching() {
            if (this._loadingTimer) {
                this._loadingTimer.clear();
                this._loadingTimer = null;
            }
            if (this._resolveFetchBusyState) {
                this._resolveFetchBusyState();
                this._resolveFetchBusyState = null;
            }
            if (this.state.loading) {
                this._updateState({ loading: false });
            }
            this._updateState({ fetching: false });
        }
        static _formatItemText(suggestionItemText, suggestionItemContext) {
            let formatted;
            if (suggestionItemContext?.data) {
                if (typeof suggestionItemText === 'string') {
                    if (!suggestionItemContext.data?.hasOwnProperty(suggestionItemText)) {
                        Logger.error(`oj-input-search: No '${suggestionItemText}' property found in DataProvider with key: ${suggestionItemContext?.key}`);
                    }
                    formatted = suggestionItemContext.data[suggestionItemText];
                }
                else {
                    formatted = suggestionItemText(suggestionItemContext);
                }
            }
            return formatted || '';
        }
        _testChangeValue(value) {
            const promise = new Promise((resolve) => {
                this._testPromiseResolve = resolve;
            });
            this._updateState({
                filterText: value,
                displayValue: value,
                dropdownOpen: false,
                valueSubmitted: true,
                actionDetail: null
            });
            return promise;
        }
        _testChangeValueByKey(key) {
            const promise = new Promise((resolve) => {
                this._testPromiseResolve = resolve;
            });
            const afterUnsuccessfulFetch = function () {
                if (this._testPromiseResolve) {
                    this._testPromiseResolve();
                    this._testPromiseResolve = null;
                }
                throw new Error(`oj-input-search: No row found in DataProvider for key: ${key}`);
            };
            this._dataProvider.fetchByKeys({ keys: new Set([key]) }).then(function (fetchResults) {
                const item = fetchResults.results.get(key);
                if (item && item.data != null && item.metadata != null) {
                    const itemContext = {
                        data: item.data,
                        metadata: item.metadata,
                        key: item.metadata.key
                    };
                    const formattedText = InputSearch_1._formatItemText(this.props.suggestionItemText, itemContext);
                    this._updateState({
                        filterText: formattedText,
                        displayValue: formattedText,
                        dropdownOpen: false,
                        valueSubmitted: true,
                        actionDetail: itemContext
                    });
                }
                else {
                    afterUnsuccessfulFetch();
                }
            }.bind(this), afterUnsuccessfulFetch);
            return promise;
        }
    };
    exports.InputSearch.defaultProps = {
        suggestions: null,
        suggestionItemText: 'label',
        placeholder: '',
        value: null
    };
    exports.InputSearch._metadata = { "properties": { "suggestions": { "type": "object" }, "suggestionItemText": { "type": "string|number|function" }, "placeholder": { "type": "string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "value": { "type": "string", "writeback": true } }, "events": { "ojValueAction": {} }, "slots": { "suggestionItemTemplate": { "data": {} } }, "extension": { "_WRITEBACK_PROPS": ["rawValue", "value"], "_READ_ONLY_PROPS": ["rawValue"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "id"] }, "methods": { "focus": {}, "blur": {}, "_testChangeValue": {}, "_testChangeValueByKey": {} } };
    exports.InputSearch = InputSearch_1 = __decorate([
        ojvcomponent.customElement('oj-input-search')
    ], exports.InputSearch);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojactioncard',['exports', 'preact/jsx-runtime', 'ojs/ojvcomponent', 'preact', 'ojs/ojdomutils', 'ojs/ojdatacollection-common'], function (exports, jsxRuntime, ojvcomponent, preact, DomUtils, DataCollectionUtils) { 'use strict';

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.ActionCard = class ActionCard extends preact.Component {
        constructor(props) {
            super(props);
            this._rootRef = preact.createRef();
            this._handleOjAction = (event) => {
                if (this._isFromActiveSource(event)) {
                    event.stopPropagation();
                }
            };
            this._handleStart = (event) => {
                if (!this._isFromActiveSource(event)) {
                    this.setState({ active: true });
                }
            };
            this._handleUpEnd = (event) => {
                if (!this._isFromActiveSource(event) && this.state.active) {
                    this.setState({ active: false });
                }
            };
            this._handleClick = (event) => {
                if (!this._isFromActiveSource(event)) {
                    this.props.onOjAction?.({ originalEvent: event });
                }
            };
            this._handleTouchcancel = (event) => {
                if (!this._isFromActiveSource(event)) {
                    this.setState({ active: false });
                }
            };
            this._handleMove = (event) => {
                if (this.state.active && !this._isFromActiveSource(event)) {
                    this.setState({ active: false });
                }
            };
            this._handleKeydown = (event) => {
                if (!this._isFromActiveSource(event) &&
                    !event.repeat &&
                    (event.key === 'Enter' || event.key === ' ')) {
                    this.setState({ active: true });
                }
            };
            this._handleKeyup = (event) => {
                if (!this._isFromActiveSource(event) && (event.key === 'Enter' || event.key === ' ')) {
                    this.setState({ active: false });
                    this.props.onOjAction?.({ originalEvent: event });
                }
            };
            this._handleFocusin = (event) => {
                this.setState({ focus: true });
            };
            this._handleFocusout = (event) => {
                this.setState({ focus: false });
            };
            this.state = {
                active: false,
                focus: false
            };
        }
        render(props, state) {
            let classString = 'oj-actioncard';
            if (state.active) {
                classString += ' oj-active';
            }
            if (state.focus && !DomUtils.recentPointer()) {
                classString += ' oj-focus-highlight';
            }
            const tabIndex = props.tabIndex ?? 0;
            return (jsxRuntime.jsx(ojvcomponent.Root, { tabIndex: tabIndex, class: classString, role: "button", onKeyUp: this._handleKeyup, onMouseUp: this._handleUpEnd, onKeyDown: this._handleKeydown, onMouseDown: this._handleStart, onTouchStart: this._handleStart, onTouchEnd: this._handleUpEnd, onTouchCancel: this._handleTouchcancel, onTouchMove: this._handleMove, onfocusin: this._handleFocusin, onfocusout: this._handleFocusout, onClick: this._handleClick, onojAction: this._handleOjAction, ref: this._rootRef, children: this.props.children }));
        }
        componentDidMount() {
            this._rootRef.current.addEventListener('touchstart', this._handleStart, { passive: true });
            this._rootRef.current.addEventListener('touchend', this._handleUpEnd, { passive: false });
            this._rootRef.current.addEventListener('touchcancel', this._handleTouchcancel, {
                passive: true
            });
            this._rootRef.current.addEventListener('touchmove', this._handleMove, { passive: true });
        }
        _isFromActiveSource(event) {
            return DataCollectionUtils.isEventClickthroughDisabled(event, this._rootRef.current);
        }
    };
    exports.ActionCard._metadata = { "slots": { "": {} }, "events": { "ojAction": { "bubbles": true } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["tabIndex", "role"] } };
    exports.ActionCard = __decorate([
        ojvcomponent.customElement('oj-action-card')
    ], exports.ActionCard);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojsoundutils',['exports'], function (exports) { 'use strict';

    class SoundUtils {
        static playDefaultNotificationSound() {
            const audioContext = SoundUtils._getAudioContext();
            const oscillatorNode = audioContext.createOscillator();
            oscillatorNode.connect(audioContext.destination);
            oscillatorNode.start(0);
            oscillatorNode.stop(audioContext.currentTime + 0.1);
        }
        static playAudioFromURL(url) {
            let resolve;
            let reject;
            const returnPromise = new Promise((_resolve, _reject) => {
                resolve = _resolve;
                reject = _reject;
            });
            const audioElement = document.createElement('audio');
            audioElement.src = url;
            audioElement.addEventListener('error', reject);
            (audioElement.play() || Promise.resolve()).then(resolve, reject).catch(reject);
            return returnPromise;
        }
        static _getAudioContext() {
            if (SoundUtils._audioContext) {
                return SoundUtils._audioContext;
            }
            if (SoundUtils._audioContext === null) {
                throw new Error('Browser does not support WebAudio API');
            }
            try {
                SoundUtils._audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            catch (e) {
                SoundUtils._audioContext = null;
                throw new Error('Browser does not support WebAudio API');
            }
            return SoundUtils._audioContext;
        }
    }

    exports.SoundUtils = SoundUtils;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojmessagebanner',['exports', 'preact/jsx-runtime', 'preact/hooks', 'preact', 'ojs/ojconfig', 'ojs/ojcore-base', 'ojs/ojlogger', 'ojs/ojsoundutils', 'ojs/ojanimation', 'ojs/ojtranslation', 'ojs/ojcontext', 'ojs/ojdataproviderhandler', 'ojs/ojvcomponent', 'ojs/ojbutton'], function (exports, jsxRuntime, hooks, preact, ojconfig, oj, Logger, ojsoundutils, AnimationUtils, Translations, Context, ojdataproviderhandler, ojvcomponent, ojbutton) { 'use strict';

    oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
    Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

    function MessageCloseButton({ onAction, title = 'Close' }) {
        return (jsxRuntime.jsx("div", { class: "oj-messagebanner-close-button", "data-oj-message-close-button": "", children: jsxRuntime.jsxs("oj-button", { class: "oj-button-sm", display: "icons", chroming: "borderless", title: title, onojAction: onAction, children: [jsxRuntime.jsx("span", { slot: "startIcon", class: "oj-fwk-icon oj-fwk-icon-cross" }), jsxRuntime.jsx("span", { children: title })] }) }));
    }

    const severities = ['error', 'warning', 'confirmation', 'info', 'none'];

    const DATE_FORMAT_OPTIONS = Object.freeze({
        TODAY: {
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        },
        DEFAULT: {
            day: '2-digit',
            month: '2-digit',
            year: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        }
    });
    const ISO_DATE_REGEX = /^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]+)?(Z)?$/;
    function isDateToday(isoDate) {
        const today = new Date();
        const provided = new Date(isoDate);
        return (today.getUTCFullYear() === provided.getUTCFullYear() &&
            today.getUTCMonth() === provided.getUTCMonth() &&
            today.getUTCDate() === provided.getUTCDate());
    }
    function getDateTimeFormatter(isToday) {
        const locale = ojconfig.getLocale();
        const { DateTimeFormat } = Intl;
        if (isToday) {
            return new DateTimeFormat(locale, DATE_FORMAT_OPTIONS.TODAY);
        }
        return new DateTimeFormat(locale, DATE_FORMAT_OPTIONS.DEFAULT);
    }
    function isValidValueForProp(value, prop = 'string') {
        switch (prop) {
            case 'severity':
                return typeof value === 'string' && severities.includes(value);
            case 'timestamp':
                return typeof value === 'string' && ISO_DATE_REGEX.test(value);
            case 'string':
            default:
                return typeof value === 'string' && !oj.StringUtils.isEmptyOrUndefined(value);
        }
    }
    function formatTimestamp(isoTime) {
        const isToday = isDateToday(isoTime);
        const formatter = getDateTimeFormatter(isToday);
        return formatter.format(new Date(isoTime));
    }

    function defaultDetailRenderer(item) {
        const { detail } = item.data;
        if (!isValidValueForProp(detail)) {
            return null;
        }
        return jsxRuntime.jsx(preact.Fragment, { children: detail });
    }
    function MessageDetail({ item, renderer }) {
        const isCustomRendered = renderer != null;
        const renderedContent = (renderer ?? defaultDetailRenderer)(item);
        return renderedContent == null ? null : (jsxRuntime.jsx("div", { class: "oj-messagebanner-detail", ...(isCustomRendered ? { 'data-oj-message-custom-detail': '' } : {}), children: renderedContent }));
    }

    function MessageHeader({ children }) {
        return (jsxRuntime.jsx("div", { role: "presentation", class: "oj-messagebanner-header", children: children }));
    }

    const Icon = ({ children }) => (jsxRuntime.jsx("svg", { viewBox: "0 0 24 24", height: "1em", width: "1em", style: { fontSize: '1em', color: 'currentColor' }, children: children }));
    const SuccessIcon = () => (jsxRuntime.jsx(Icon, { children: jsxRuntime.jsx("g", { fill: "none", children: jsxRuntime.jsx("path", { d: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10zm5.707-13.293L10 16.414l-3.707-3.707 1.414-1.414L10 13.586l6.293-6.293z", fill: "currentcolor" }) }) }));
    const ErrorIcon = () => (jsxRuntime.jsx(Icon, { children: jsxRuntime.jsx("g", { fill: "none", children: jsxRuntime.jsx("path", { d: "M2 12c0 5.523 4.477 10 10 10s10-4.477 10-10S17.523 2 12 2 2 6.477 2 12zm5.293-3.293 1.414-1.414 8 8-1.414 1.414z", fill: "currentcolor" }) }) }));
    const InformationIcon = () => (jsxRuntime.jsx(Icon, { children: jsxRuntime.jsx("g", { fill: "none", children: jsxRuntime.jsx("path", { d: "M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10zm-9-4V6h-2v2zm0 10v-8h-2v8z", fill: "currentcolor" }) }) }));
    const WarningIcon = () => (jsxRuntime.jsx(Icon, { children: jsxRuntime.jsx("g", { fill: "none", children: jsxRuntime.jsx("path", { d: "M2 22 12 2l10 20zm9-11v4h2v-4zm0 6v2h2v-2z", fill: "currentcolor" }) }) }));

    const severityIcons = {
        confirmation: SuccessIcon,
        error: ErrorIcon,
        info: InformationIcon,
        warning: WarningIcon
    };
    function MessageStartIcon({ severity, translations }) {
        const IconComponent = severityIcons[severity];
        return (jsxRuntime.jsx("div", { class: "oj-messagebanner-start-icon-container", role: "presentation", children: jsxRuntime.jsx("div", { class: "oj-flex oj-sm-align-items-center", height: "100%", children: jsxRuntime.jsx("span", { class: "oj-messagebanner-start-icon", role: "img", title: translations?.[severity], children: jsxRuntime.jsx(IconComponent, {}) }) }) }));
    }

    function MessageSummary({ text }) {
        return (jsxRuntime.jsx("div", { role: "heading", class: "oj-messagebanner-summary", children: text }));
    }

    function MessageTimestamp({ value }) {
        const formattedTimestamp = formatTimestamp(value);
        return jsxRuntime.jsx("div", { class: "oj-messagebanner-timestamp", children: formattedTimestamp });
    }

    const MessageLogger = {
        error: (message) => Logger.error(`JET oj-message-banner: ${message}`),
        warn: (message) => Logger.warn(`JET Oj-message-banner: ${message}`),
        info: (message) => Logger.info(`JET Oj-message-banner: ${message}`),
        log: (message) => Logger.log(`JET Oj-message-banner: ${message}`)
    };
    async function playSound(sound) {
        if (sound === 'none') {
            return;
        }
        if (sound === 'default') {
            try {
                ojsoundutils.SoundUtils.playDefaultNotificationSound();
            }
            catch (error) {
                MessageLogger.warn(`Failed to play the default sound. ${error}.`);
            }
            return;
        }
        try {
            await ojsoundutils.SoundUtils.playAudioFromURL(sound);
        }
        catch (error) {
            MessageLogger.warn(`Failed to play the audio from the url ${sound}. ${error}.`);
        }
    }
    function throwError(message) {
        throw new Error(`JET oj-message-banner - ${message}`);
    }
    function getRenderer(message, rendererIdentifier, renderers) {
        if (!rendererIdentifier || !renderers) {
            return undefined;
        }
        const rendererKey = typeof rendererIdentifier === 'function' ? rendererIdentifier(message) : rendererIdentifier;
        if (rendererKey == null) {
            return undefined;
        }
        if (!(rendererKey in renderers)) {
            throwError(`${rendererKey} is not a valid template name for the message with key=${message.key}`);
        }
        return renderers[rendererKey];
    }
    function severityBasedStyleClass(severity) {
        const isValidSeverity = isValidValueForProp(severity, 'severity');
        return isValidSeverity && severity !== 'none' ? `oj-messagebanner-${severity}` : '';
    }
    function isSeverityIconNeeded(severity) {
        const isValidSeverity = isValidValueForProp(severity, 'severity');
        return isValidSeverity && severity !== 'none';
    }
    function classNames(values) {
        return values.filter(Boolean).join(' ');
    }

    function isSeverityIconNeeded$1(severity) {
        const isValidSeverity = isValidValueForProp(severity, 'severity');
        return isValidSeverity && severity !== 'none';
    }
    const MIN_SECONDS = 5;
    const DEFAULT_TIMEOUT = MIN_SECONDS * 1000;
    function Message({ detailRenderer, index = -1, item, onClose, messageRef = () => { }, variant = 'section', translations }) {
        const { closeAffordance = 'on', severity = 'error', sound, summary, timestamp } = item.data;
        const handleClose = hooks.useCallback(() => {
            onClose?.(item);
        }, [item, onClose]);
        const handleCloseOnEsc = hooks.useCallback((event) => {
            if (event.key === 'Escape' && closeAffordance === 'on') {
                onClose?.(item);
            }
        }, [closeAffordance, item, onClose]);
        hooks.useEffect(() => {
            if (isValidValueForProp(sound)) {
                playSound(sound);
            }
        }, []);
        const rootClasses = classNames([
            'oj-messagebanner-item',
            severityBasedStyleClass(severity),
            variant === 'section' && 'oj-messagebanner-section'
        ]);
        return (jsxRuntime.jsx("div", { ref: messageRef, class: rootClasses, role: "alert", "aria-atomic": "true", "data-oj-key": `${typeof item.key}-${item.key}`, tabIndex: 0, onKeyUp: handleCloseOnEsc, children: jsxRuntime.jsxs("div", { class: "oj-messagebanner-content", children: [isSeverityIconNeeded$1(severity) ? (jsxRuntime.jsx(MessageStartIcon, { severity: severity, translations: translations })) : null, jsxRuntime.jsxs("div", { class: "oj-flex oj-sm-flex-direction-column oj-sm-flex-1 oj-messagebanner-content-gap", children: [jsxRuntime.jsxs(MessageHeader, { children: [jsxRuntime.jsx(MessageSummary, { text: summary }), isValidValueForProp(timestamp, 'timestamp') && jsxRuntime.jsx(MessageTimestamp, { value: timestamp })] }), jsxRuntime.jsx(MessageDetail, { item: { ...item, index }, renderer: detailRenderer })] }), closeAffordance === 'on' && (jsxRuntime.jsx(MessageCloseButton, { title: translations?.close, onAction: handleClose }))] }) }));
    }

    function MessageLiveRegion({ atomic = 'false', children = '', timeout = 100, type = 'polite' }) {
        const ariaLiveText = useLiveText(children, timeout);
        return (jsxRuntime.jsx("span", { "aria-live": type, "aria-atomic": atomic, class: "oj-helper-hidden-accessible", children: ariaLiveText }));
    }
    function useLiveText(text, timeout) {
        const [liveText, setLiveText] = hooks.useState('');
        const updateText = hooks.useCallback(() => setLiveText(text), [text]);
        const updateTextAsync = hooks.useCallback(() => setTimeout(function () {
            updateText();
        }, timeout), [updateText, timeout]);
        hooks.useEffect(() => {
            const timeoutId = updateTextAsync();
            return () => clearTimeout(timeoutId);
        }, [updateTextAsync]);
        return liveText;
    }

    class Transition extends preact.Component {
        constructor(props) {
            super(props);
            let appearStatus;
            if (props.in) {
                appearStatus = 'entering';
            }
            else {
                appearStatus = null;
            }
            this._appearStatus = appearStatus;
            this.state = { status: 'exited' };
            this._nextCallback = null;
        }
        componentDidMount() {
            this._updateStatus(this._appearStatus);
        }
        componentDidUpdate(prevProps) {
            let nextStatus = null;
            if (prevProps !== this.props) {
                const { status } = this.state;
                if (this.props.in) {
                    if (status !== 'entering' && status !== 'entered') {
                        nextStatus = 'entering';
                    }
                }
                else {
                    if (status === 'entering' || status === 'entered') {
                        nextStatus = 'exiting';
                    }
                }
            }
            this._updateStatus(nextStatus);
        }
        componentWillUnmount() {
            this._cancelNextCallback();
        }
        render(props) {
            return props?.children;
        }
        _setNextCallback(callback) {
            let active = true;
            this._nextCallback = (...args) => {
                if (active) {
                    active = false;
                    this._nextCallback = null;
                    callback(...args);
                }
            };
            this._nextCallback.cancel = () => {
                active = false;
            };
            return this._nextCallback;
        }
        _cancelNextCallback() {
            this._nextCallback?.cancel?.();
            this._nextCallback = null;
        }
        _updateStatus(nextStatus) {
            if (nextStatus != null) {
                this._cancelNextCallback();
                if (nextStatus === 'entering') {
                    this._performEnter(this.base);
                }
                else {
                    this._performExit(this.base);
                }
            }
        }
        _performEnter(node) {
            this.props.onEnter?.(node, this.props.metadata);
            this.setState({ status: 'entering' }, () => {
                this.props.onEntering?.(node, this._setNextCallback(() => {
                    this.setState({ status: 'entered' }, () => {
                        this.props.onEntered?.(node, this.props.metadata);
                    });
                }), this.props.metadata);
            });
        }
        _performExit(node) {
            this.props.onExit?.(node, this.props.metadata);
            this.setState({ status: 'exiting' }, () => {
                this.props.onExiting?.(node, this._setNextCallback(() => {
                    this.setState({ status: 'exited' }, () => {
                        this.props.onExited?.(node, this.props.metadata);
                    });
                }), this.props.metadata);
            });
        }
    }

    const MessagesContext = preact.createContext({});
    function useMessagesContext() {
        return hooks.useContext(MessagesContext);
    }

    const DEFAULT_ANIMATIONS = {
        enter: [{ effect: 'expand', duration: '0.25s', direction: 'height' }],
        exit: [{ effect: 'collapse', duration: '0.25s', direction: 'height' }]
    };
    function MessageTransition({ onEntering, onExiting, ...transitionProps }) {
        const animationCallbackRef = hooks.useRef();
        const busyStateResolveRef = hooks.useRef();
        const { addBusyState } = useMessagesContext();
        const onEnteringCallback = hooks.useCallback(async (node, callback, metadata) => {
            onEntering?.(node, undefined, metadata);
            const busyStateResolver = addBusyState?.('messages animating');
            await AnimationUtils.startAnimation(node, 'enter', DEFAULT_ANIMATIONS['enter']);
            busyStateResolver();
            callback();
        }, [addBusyState, onEntering]);
        const onExitingCallback = hooks.useCallback(async (node, callback, metadata) => {
            onExiting?.(node, undefined, metadata);
            const busyStateResolver = addBusyState?.('messages animating');
            await AnimationUtils.startAnimation(node, 'exit', DEFAULT_ANIMATIONS['exit']);
            busyStateResolver();
            callback();
        }, [addBusyState, onExiting]);
        hooks.useLayoutEffect(() => () => busyStateResolveRef.current?.(), []);
        return (jsxRuntime.jsx("div", { children: jsxRuntime.jsx(Transition, { ...transitionProps, onEntering: onEnteringCallback, onExiting: onExitingCallback }) }));
    }

    class TransitionUtils {
        static getChildMapping(children, prevChildMapping = new Map(), onExited = () => { }) {
            const TRAILING = Symbol();
            let mappedDeletions = {};
            if (prevChildMapping.size !== 0) {
                mappedDeletions = TransitionUtils._getMappedDeletions(children, prevChildMapping, TRAILING);
            }
            const mergedChildrenMap = children.reduce((accumulator, currentChild) => {
                if (mappedDeletions[currentChild.key]) {
                    const deletedChildren = mappedDeletions[currentChild.key];
                    for (const key of deletedChildren) {
                        const previousChild = prevChildMapping.get(key);
                        accumulator.set(key, preact.cloneElement(previousChild, { in: false }));
                    }
                    const previousChild = prevChildMapping.get(currentChild.key);
                    accumulator.set(currentChild.key, preact.cloneElement(currentChild, {
                        onExited: previousChild.props.onExited,
                        in: previousChild.props.in
                    }));
                }
                else {
                    const newChild = preact.cloneElement(currentChild, {
                        onExited: onExited.bind(null, currentChild),
                        in: true
                    });
                    accumulator.set(currentChild.key, newChild);
                }
                return accumulator;
            }, new Map());
            for (const key of mappedDeletions[TRAILING] || []) {
                const previousChild = prevChildMapping.get(key);
                mergedChildrenMap.set(key, preact.cloneElement(previousChild, { in: false }));
            }
            return mergedChildrenMap;
        }
        static _getMappedDeletions(children, prevChildMapping, TRAILING) {
            const nextChildrenKeys = new Set(children.map((children) => children.key));
            return [...prevChildMapping.keys()].reduce((accumulator, currentKey) => {
                if (nextChildrenKeys.has(currentKey)) {
                    accumulator[currentKey] = accumulator[TRAILING];
                    delete accumulator[TRAILING];
                }
                else {
                    const trailingChildren = accumulator[TRAILING]
                        ? [...accumulator[TRAILING], currentKey]
                        : [currentKey];
                    accumulator[TRAILING] = trailingChildren;
                }
                return accumulator;
            }, {});
        }
    }

    class TransitionGroup extends preact.Component {
        static getDerivedStateFromProps(props, state) {
            const { childMapping, handleExited } = state;
            return {
                childMapping: TransitionUtils.getChildMapping(props.children, childMapping, handleExited)
            };
        }
        constructor(props) {
            super(props);
            this._handleExited = (child, node, metadata) => {
                const { children } = this.props;
                const currentChildMapping = TransitionUtils.getChildMapping(children);
                if (currentChildMapping.has(child.key))
                    return;
                child.props.onExited?.(node, metadata);
                if (this._mounted) {
                    this.setState((state) => {
                        const childMapping = new Map(state.childMapping);
                        childMapping.delete(child.key);
                        return { childMapping };
                    });
                }
            };
            this.state = {
                childMapping: undefined,
                handleExited: this._handleExited
            };
            this._mounted = false;
        }
        componentDidMount() {
            this._mounted = true;
        }
        componentWillUnmount() {
            this._mounted = false;
        }
        render() {
            const WrapperComponent = this.props.elementType;
            const { childMapping } = this.state;
            const children = [...childMapping.values()];
            return jsxRuntime.jsx(WrapperComponent, { children: children });
        }
    }
    TransitionGroup.defaultProps = {
        elementType: 'div'
    };

    function MessagesManager({ data, children, onMessageWillRemove }) {
        const handleExited = hooks.useCallback(async (node, metadata) => {
            metadata && onMessageWillRemove?.(metadata.key, metadata.index, node);
        }, [onMessageWillRemove]);
        return (jsxRuntime.jsx(TransitionGroup, { elementType: preact.Fragment, children: data.map((item, index) => (jsxRuntime.jsx(MessageTransition, { metadata: { index, key: item.key }, onExited: handleExited, children: children?.({ index, item }) }, item.key))) }));
    }

    const componentsMap = new Map();
    const componentsOrder = [];
    const priorFocusCache = new Map();
    let hasDocumentListener = false;
    let priorFocusedElement;
    let currentFocusedMessage;
    function handleDocumentKeyDownCapture(event) {
        if (componentsMap.size === 0 || event.key !== 'F6' || event.defaultPrevented) {
            return;
        }
        if (!cycleFocusThroughMessages(event)) {
            currentFocusedMessage && togglePreviousFocus(currentFocusedMessage, event);
        }
    }
    function handleDocumentBlurCapture(event) {
        priorFocusedElement = event.target;
    }
    function handleComponentKeyUp(id, event) {
        if (!componentsMap.has(id) || event.defaultPrevented) {
            return;
        }
        if (event.type === 'keyup' && ['Escape'].includes(event.key)) {
            togglePreviousFocus(id, event);
        }
    }
    function handleComponentFocus(id, event) {
        if (!componentsMap.has(id) || event.defaultPrevented) {
            return;
        }
        currentFocusedMessage = id;
        const { callbacks } = componentsMap.get(id);
        if (priorFocusedElement && !isPartOfRegisteredMessages(priorFocusedElement)) {
            priorFocusCache.set(id, priorFocusedElement);
            callbacks?.onFocus?.();
        }
    }
    function handleComponentBlur(id, event) {
        if (!componentsMap.has(id) || event.defaultPrevented) {
            return;
        }
        currentFocusedMessage = undefined;
    }
    function cycleFocusThroughMessages(event) {
        const nextPosition = indexOfOrDefaultTo(componentsOrder, currentFocusedMessage, componentsOrder.length) - 1;
        for (let i = nextPosition; i > -1; i--) {
            const id = componentsOrder[i];
            const { ref } = componentsMap.get(id) ?? {};
            if (ref?.current?.focus?.()) {
                event.preventDefault();
                if (currentFocusedMessage) {
                    const { callbacks } = componentsMap.get(currentFocusedMessage) ?? {};
                    callbacks?.onFocusLeave?.();
                }
                return true;
            }
        }
        return false;
    }
    function isPartOfRegisteredMessages(element) {
        for (const { ref } of componentsMap.values()) {
            if (ref.current?.contains(element)) {
                return true;
            }
        }
        return false;
    }
    function indexOfOrDefaultTo(arr, search, defaultIndex = -1) {
        const index = arr.indexOf(search);
        if (index !== -1)
            return index;
        return defaultIndex;
    }
    function getClosestPriorFocusedElement(id) {
        const index = componentsOrder.indexOf(id);
        for (let i = index; i < componentsOrder.length; i++) {
            if (priorFocusCache.has(componentsOrder[i])) {
                return priorFocusCache.get(componentsOrder[i]);
            }
        }
        return null;
    }
    function addComponent(id, options) {
        componentsMap.set(id, options);
        componentsOrder.push(id);
    }
    function removeComponent(id) {
        if (!componentsMap.has(id)) {
            return;
        }
        componentsMap.delete(id);
        componentsOrder.splice(componentsOrder.indexOf(id), 1);
    }
    function clearFocusCache(id) {
        priorFocusCache.delete(id);
    }
    function addDocumentListeners() {
        document.documentElement.addEventListener('keydown', handleDocumentKeyDownCapture, true);
        document.documentElement.addEventListener('blur', handleDocumentBlurCapture, true);
        hasDocumentListener = true;
    }
    function removeDocumentListeners() {
        document.documentElement.removeEventListener('keydown', handleDocumentKeyDownCapture, true);
        document.documentElement.removeEventListener('blur', handleDocumentBlurCapture, true);
        hasDocumentListener = false;
    }
    function register(id, componentOptions, focusManagerOptions = { handleEscapeKey: true }) {
        if (!hasDocumentListener) {
            addDocumentListeners();
        }
        addComponent(id, componentOptions);
        const handlers = {
            onfocusin: (event) => handleComponentFocus(id, event),
            onfocusout: (event) => handleComponentBlur(id, event)
        };
        if (focusManagerOptions.handleEscapeKey) {
            handlers['onKeyUp'] = (event) => handleComponentKeyUp(id, event);
        }
        return handlers;
    }
    function togglePreviousFocus(id, event) {
        const target = getClosestPriorFocusedElement(id);
        const { callbacks } = componentsMap.get(id) ?? {};
        if (target && document.body.contains(target)) {
            target.focus();
            callbacks?.onFocusLeave?.();
            priorFocusCache.clear();
            event?.preventDefault();
            return true;
        }
        return false;
    }
    function unregister(id) {
        removeComponent(id);
        clearFocusCache(id);
        if (hasDocumentListener && componentsMap.size === 0) {
            removeDocumentListeners();
        }
    }
    function prioritize(id) {
        if (!componentsMap.has(id)) {
            return;
        }
        const options = componentsMap.get(id);
        removeComponent(id);
        addComponent(id, options);
    }
    const messagesFocusManager = {
        prioritize,
        register,
        togglePreviousFocus,
        unregister
    };
    function useMessageFocusManager(ref, callbacks, options) {
        const id = hooks.useRef(Symbol());
        const focusManager = hooks.useRef(messagesFocusManager);
        const [handlers, setHandlers] = hooks.useState({});
        const controller = hooks.useMemo(() => ({
            prioritize: () => focusManager.current.prioritize(id.current),
            restorePriorFocus: () => focusManager.current.togglePreviousFocus(id.current)
        }), []);
        hooks.useEffect(() => {
            const currentFocusManager = focusManager.current;
            const currentId = id.current;
            setHandlers(currentFocusManager.register(currentId, { ref, callbacks }, options));
            return () => currentFocusManager.unregister(currentId);
        }, []);
        return {
            handlers,
            controller
        };
    }

    function MessageBanner({ detailRendererKey, data, onClose, renderers, translations, type = 'section' }) {
        const messagesRef = hooks.useRef(new Map());
        const containerDivRef = hooks.useRef(null);
        const focusHandleRef = hooks.useRef(null);
        const [liveRegionText, setLiveRegionText] = hooks.useState();
        const [shouldRender, setShouldRender] = hooks.useState(data.length > 0);
        const dataLengthRef = hooks.useRef(data.length);
        const prevDataLengthRef = hooks.useRef(0);
        dataLengthRef.current = data.length;
        const setMessageRef = hooks.useCallback((key) => {
            return (ref) => messagesRef.current.set(key, ref);
        }, []);
        hooks.useImperativeHandle(focusHandleRef, () => ({
            focus: () => {
                const isVisible = containerDivRef.current?.checkVisibility() ?? false;
                if (data.length && isVisible) {
                    const firstItemKey = data[0].key;
                    messagesRef.current.get(firstItemKey)?.focus();
                    return true;
                }
                return false;
            },
            contains: (element) => {
                if (data.length && element) {
                    return containerDivRef.current?.contains(element) ?? false;
                }
                return false;
            }
        }), [data]);
        const { controller, handlers } = useMessageFocusManager(focusHandleRef, {
            onFocus: hooks.useCallback(() => {
                setLiveRegionText(translations?.navigationFromMessagesRegion);
            }, [setLiveRegionText, translations])
        });
        const handleClose = hooks.useCallback((item) => {
            onClose?.(item);
        }, [onClose]);
        const handleNextFocus = hooks.useCallback((_key, index, closedMessageNode) => {
            const isClosedMessageFocused = closedMessageNode?.contains(document.activeElement);
            if (dataLengthRef.current === 0) {
                setShouldRender(false);
                if (isClosedMessageFocused) {
                    controller.restorePriorFocus();
                }
                return;
            }
            const renderedMessagesCount = data.length;
            const nextMessageIndexToFocus = index + 1 < renderedMessagesCount ? index + 1 : index - 1;
            if (nextMessageIndexToFocus > -1 && isClosedMessageFocused) {
                const nextMessageKey = data[nextMessageIndexToFocus].key;
                messagesRef.current.get(nextMessageKey)?.focus();
            }
        }, [controller, data]);
        hooks.useEffect(() => {
            if (data.length) {
                setShouldRender(true);
                if (data.length > prevDataLengthRef.current) {
                    setLiveRegionText(translations?.navigationToMessagesRegion);
                }
                controller.prioritize();
            }
            else {
                setLiveRegionText('');
            }
            prevDataLengthRef.current = data.length;
        }, [controller, data, translations]);
        if (!shouldRender && data.length === 0) {
            return null;
        }
        const rootClasses = classNames([
            'oj-flex',
            'oj-sm-flex-direction-column',
            type === 'section' && 'oj-messagebanner-container-gap'
        ]);
        return (jsxRuntime.jsx("div", { ref: containerDivRef, class: "oj-messagebanner", tabIndex: -1, ...handlers, children: jsxRuntime.jsxs("div", { class: rootClasses, children: [jsxRuntime.jsx(MessagesManager, { data: data, onMessageWillRemove: handleNextFocus, children: ({ index, item }) => (jsxRuntime.jsx(Message, { messageRef: setMessageRef(item.key), item: item, detailRenderer: getRenderer(item, detailRendererKey, renderers), index: index, variant: type, onClose: handleClose, translations: translations }, item.key)) }), jsxRuntime.jsx(MessageLiveRegion, { children: liveRegionText })] }) }));
    }

    var __decorate = (null && null.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    exports.MessageBanner = class MessageBanner$1 extends preact.Component {
        static getDerivedStateFromProps(props, state) {
            const { data } = props;
            const { dataProviderCount, previousDataProvider } = state;
            if (data !== previousDataProvider) {
                return {
                    dataProviderCount: dataProviderCount + 1,
                    previousDataProvider: data
                };
            }
            return null;
        }
        constructor(props) {
            super(props);
            this._addBusyState = (description) => {
                const busyContext = Context.getContext(this._rootRef.current).getBusyContext();
                return busyContext.addBusyState({ description });
            };
            this._handleCloseMessage = (context) => {
                this.props.onOjClose?.(context);
            };
            this._rootRef = preact.createRef();
            this.state = { dataProviderCount: 0, previousDataProvider: props.data };
            this.WrapperMessagesContainer = ojdataproviderhandler.withDataProvider(MessageBanner, 'data');
        }
        render(props) {
            const { data, detailTemplateValue, messageTemplates, type } = props;
            const { dataProviderCount } = this.state;
            const messagesContext = { addBusyState: this._addBusyState };
            return (jsxRuntime.jsx(ojvcomponent.Root, { ref: this._rootRef, children: jsxRuntime.jsx(MessagesContext.Provider, { value: messagesContext, children: jsxRuntime.jsx(this.WrapperMessagesContainer, { addBusyState: this._addBusyState, data: data, type: type, detailRendererKey: detailTemplateValue, renderers: messageTemplates, onClose: this._handleCloseMessage, translations: {
                            close: Translations.getTranslatedString('oj-ojMessageBanner.close'),
                            navigationFromMessagesRegion: Translations.getTranslatedString('oj-ojMessageBanner.navigationFromMessagesRegion'),
                            navigationToMessagesRegion: Translations.getTranslatedString('oj-ojMessageBanner.navigationToMessagesRegion'),
                            error: Translations.getTranslatedString('oj-ojMessageBanner.error'),
                            warning: Translations.getTranslatedString('oj-ojMessageBanner.warning'),
                            info: Translations.getTranslatedString('oj-ojMessageBanner.info'),
                            confirmation: Translations.getTranslatedString('oj-ojMessageBanner.confirmation')
                        } }, `dataProvider${dataProviderCount}`) }) }));
        }
    };
    exports.MessageBanner.defaultProps = {
        type: 'section'
    };
    exports.MessageBanner._metadata = { "properties": { "data": { "type": "object" }, "type": { "type": "string", "enumValues": ["page", "section"] }, "detailTemplateValue": { "type": "string|function" } }, "extension": { "_DYNAMIC_SLOT": { "prop": "messageTemplates", "isTemplate": 1 } }, "events": { "ojClose": {} } };
    exports.MessageBanner = __decorate([
        ojvcomponent.customElement('oj-message-banner')
    ], exports.MessageBanner);

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojswipetoreveal',['exports', 'ojs/ojcore-base', 'jquery', 'ojs/ojcontext', 'ojs/ojoffcanvas', 'touchr'], function (exports, oj, $, Context, OffcanvasUtils, touchr) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  /**
   * @namespace SwipeToRevealUtils
   * @ojtsmodule
   * @since 1.2.0
   * @export
   * @ojdeprecated {since: '7.0.0', value: ['oj-swipe-actions']}
   * @hideconstructor
   *
   *
   * @classdesc
   * This class provides functions for setting up and handling swipe to reveal on an offcanvas element.  The offcanvas
   * element contains contextual actions that users can perform on the element that user perform the swipe gesture on.
   * This is most commonly found in ListView where user swipes on an item to reveal contextual actions that can be done on the item.
   *
   * <h3 id="touch-section">
   *   Touch End User Information
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
   * </h3>
   *
   * {@ojinclude "name":"touchDoc"}
   *
   * <h3 id="a11y-section">
   *   Accessibility
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
   * </h3>
   *
   * <p>Application must ensure that the context menu is available and setup with the
   * equivalent menu items so that keyboard-only users can perform all the swipe actions
   * just by using the keyboard.
   */
  const SwipeToRevealUtils = {};
  oj._registerLegacyNamespaceProp('SwipeToRevealUtils', SwipeToRevealUtils);
  // mapping variable definition, used in a no-require environment. Maps the SwipeToRevealUtils object to the name used in the require callback.

  /**
   * Setup listeners needed for swipe actions capability.
   *
   * @export
   * @param {Element} elem the DOM element (of the offcanvas) that hosts the swipe actions
   * @param {Object=} options the options to set for swipe actions
   * @param {number=} options.threshold the threshold that triggers default action.  If no default action is found (no item with style
   *                 "oj-swipetoreveal-default") then this value is ignored.  If percentage value is specified it will be calculated
   *                 based on the width of the element with class "oj-offcanvas-outer-wrapper".  A default value is determined if not specified.
   *                 An "ojdefaultaction" event will be fired when threshold is exceed upon release.
   * @return {void}
   *
   * @see #.tearDownSwipeActions
   * @see OffcanvasUtils.html#.setupPanToReveal
   */
  SwipeToRevealUtils.setupSwipeActions = function (elem, options) {
    var drawer;
    var direction;
    var offcanvas;
    var outerWrapper;
    var threshold;
    var minimum;
    var drawerShown;
    var busyContext;
    var evt;
    var checkpoint;
    var defaultAction;
    var distance;

    drawer = $(elem);
    // checks if it's already registered
    if (drawer.hasClass('oj-swipetoreveal')) {
      return;
    }

    drawer.addClass('oj-swipetoreveal');

    direction = drawer.hasClass('oj-offcanvas-start') ? 'end' : 'start';

    offcanvas = {};
    offcanvas.selector = drawer;
    offcanvas._animateWrapperSelector = 'oj-offcanvas-inner-wrapper';
    OffcanvasUtils.setupPanToReveal(offcanvas);

    outerWrapper = OffcanvasUtils._getOuterWrapper(drawer);

    // the panning triggers a click event at the end (since we are doing translation on move, the relative position has not changed)
    // this is to prevent the click event from bubbling (to list item for example, see )
    drawerShown = false;
    outerWrapper.on('click.swipetoreveal', function (event) {
      if (drawerShown) {
        event.stopImmediatePropagation();
        drawerShown = false;
      }
    });

    // However, this does not get trigger in hybrid app, see .
    // this change ensures that it always get reset
    outerWrapper._touchStartListener = function (event) {
      drawerShown = false;
      // prevent click event from firing when tapping on outer wrapper (like list item) while offcanvas is still open
      if (
        event.cancelable &&
        drawer.hasClass('oj-offcanvas-open') &&
        drawer[0].offsetWidth > 0 &&
        !drawer[0].contains(event.target)
      ) {
        event.preventDefault();
      }
    };
    outerWrapper[0].addEventListener('touchstart', outerWrapper._touchStartListener, {
      passive: false
    });

    drawer
      .on('ojpanstart', function (event, ui) {
        if (options && options.callback) {
          // give callback a chance to veto, ojSwipeActions use this to ensure only one
          // offcanvas on an item is opened at a time
          if (options.callback()) {
            event.preventDefault();
            return;
          }
        }

        // don't start if the drawer is already open
        if (drawer.hasClass('oj-offcanvas-open')) {
          event.preventDefault();
          // make sure it's close if it wasn't in the process already
          OffcanvasUtils.close(offcanvas).then(() => {
            // if promise is resolved but still has oj-offcanvas-open class, then manually remove it
            drawer.removeClass('oj-offcanvas-open');
          });
          return;
        }

        // if the swipe direction does not match the offcanvas's edge, veto it
        if (ui.direction !== direction) {
          event.preventDefault();
        } else {
          busyContext = Context.getContext(outerWrapper.get(0)).getBusyContext();
          busyContext.whenReady().then(function () {
            // setup default style class, must be done before outerWidth is calculated
            drawer.children().addClass('oj-swipetoreveal-action').css('min-width', '');

            // find if there's any default action item specified
            defaultAction = drawer.children('.oj-swipetoreveal-default').get(0);

            // figure out the threshold for default action and the minimum distance
            // to keep the offcanvas open
            if (minimum == null) {
              if (options != null) {
                threshold = options.threshold;
              }

              if (threshold != null) {
                threshold = parseInt(threshold, 10);

                // check if it's percentage value
                if (/%$/.test(options.threshold)) {
                  threshold = (threshold / 100) * outerWrapper.outerWidth();
                }
              } else {
                // by default it will be 55% of the outer wrapper
                threshold = outerWrapper.outerWidth() * 0.55;
              }
              // by default the minimum will be the lesser of the width of the offcanvas and half of the outer wrapper
              minimum = Math.min(outerWrapper.outerWidth() * 0.3, drawer.outerWidth());
            }
          });

          // used to determine if it's a quick swipe
          checkpoint = new Date().getTime();
        }
      })
      .on('ojpanmove', function (event, ui) {
        if (!drawerShown) {
          drawer.children().css('min-width', 0);
        }

        drawerShown = true;

        // check if pan pass the threshold position, the default action item gets entire space.
        if (defaultAction != null) {
          if (ui.distance > threshold) {
            drawer.children().each(function () {
              if (this !== defaultAction) {
                $(this).addClass('oj-swipetoreveal-hide-when-full');
              }
            });
          } else {
            drawer.children().removeClass('oj-swipetoreveal-hide-when-full');
          }
        }
      })
      .on('ojpanend', function (event, ui) {
        distance = ui.distance;
        if (defaultAction != null && distance > threshold) {
          // default action
          evt = $.Event('ojdefaultaction');
          drawer.trigger(evt, offcanvas);
          event.preventDefault();
        }

        // if pan pass the minimum threshold position, keep the toolbar open
        if (distance < minimum) {
          // check if this is a swipe, the time should be < 200ms and the distance must be > 10px
          if (new Date().getTime() - checkpoint > 200 || distance < 10) {
            event.preventDefault();
          }
        }
      });
  };

  /**
   * Removes the listener that was added in setupSwipeActions.  Page authors should call tearDownSwipeActions when the content container is no longer needed.
   *
   * @export
   * @param {Element} elem the DOM element (of the offcanvas) that hosts the swipe actions
   * @return {void}
   *
   * @see #.setupSwipeActions
   * @see OffcanvasUtils.html#.tearDownPanToReveal
   */
  SwipeToRevealUtils.tearDownSwipeActions = function (elem) {
    var drawer;
    var offcanvas;
    var outerWrapper;

    drawer = $(elem);

    drawer.removeClass('oj-swipetoreveal');

    offcanvas = {};
    offcanvas.selector = drawer;

    outerWrapper = OffcanvasUtils._getOuterWrapper(drawer);
    if (outerWrapper != null) {
      outerWrapper.off('.swipetoreveal');
    }

    OffcanvasUtils.tearDownPanToReveal(offcanvas);

    // remove touchstart listener
    if (outerWrapper != null && outerWrapper.length > 0) {
      outerWrapper[0].removeEventListener('touchstart', outerWrapper._touchStartListener, {
        passive: false
      });
      delete outerWrapper._touchStartListener;
    }
  };

  // -------------------- Styling start ----------------------------------
  /**
   * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
   */
  // ------------------------------ oj-swipetoreveal-more ---------------------------------
  /**
   * Designed for use with an action item that tags the associated item in the host like listview item.<br/><br/>
   * Is applied to the element that represents the flag action item inside the offcanvas element.
   * @ojstyleclass oj-swipetoreveal-more
   * @ojdisplayname SwipeReveal More
   * @memberof SwipeToRevealUtils
   */
  // ------------------------------ oj-swipetoreveal-flag ---------------------------------
  /**
   * Designed for use with an action item that shows more available actions that users can perform.<br/><br/>
   * Is applied to the oj-option element that represents the action item.
   * @ojstyleclass oj-swipetoreveal-flag
   * @ojdisplayname SwipeReveal Flag
   * @memberof SwipeToRevealUtils
   */
  // ------------------------------ oj-swipetoreveal-alert ---------------------------------
  /**
   * Designed for use with an action item that performs an explicit action like deleting the associated listview item.<br/><br/>
   * Is applied to the element that represents the alert action item inside the offcanvas element.
   * @ojstyleclass oj-swipetoreveal-alert
   * @ojdisplayname SwipeReveal Alert
   * @memberof SwipeToRevealUtils
   */
  // ------------------------------ oj-swipetoreveal-default ---------------------------------
  /**
   * Designed for use with an action item that should get all the space when user swipes pass the threshold distance.<br/><br/>
   * Is applied to the element that represents the default action item inside the offcanvas element.
   * @ojstyleclass oj-swipetoreveal-default
   * @ojdisplayname SwipeReveal Default
   * @memberof SwipeToRevealUtils
   */
  // -------------------- Styling end ------------------------

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>Offcanvas wrapper element</td>
   *       <td><kbd>Swipe</kbd></td>
   *       <td>Reveals the offcanvas element.  Depending on the distance relative to the target is swiped, the offcanvas will either be closed (swipe distance too short), opened, or the default action is performed (swipe distance passed the specified threshold).</td>
   *     </tr>
   *     <tr>
   *       <td>Offcanvas wrapper element</td>
   *       <td><kbd>Pan</kbd></td>
   *       <td>Reveals the offcanvas element.  If a default action is specified, the default action will get the entire space of the offcanvas after the user panned past a specified distance threshold.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof SwipeToRevealUtils
   */

  const setupSwipeActions = SwipeToRevealUtils.setupSwipeActions;
  const tearDownSwipeActions = SwipeToRevealUtils.tearDownSwipeActions;

  exports.setupSwipeActions = setupSwipeActions;
  exports.tearDownSwipeActions = tearDownSwipeActions;

  Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojswipeactions',['ojs/ojoption', 'touchr', 'ojs/ojcore-base', 'jquery', 'ojs/ojdomutils', 'ojs/ojcontext', 'ojs/ojconfig', 'ojs/ojoffcanvas', 'ojs/ojswipetoreveal', 'ojs/ojcustomelement-utils'], function (ojoption, touchr, oj, $, DomUtils, Context, ojconfig, ojoffcanvas, ojswipetoreveal, ojcustomelementUtils) { 'use strict';

  oj = oj && Object.prototype.hasOwnProperty.call(oj, 'default') ? oj['default'] : oj;
  $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
  Context = Context && Object.prototype.hasOwnProperty.call(Context, 'default') ? Context['default'] : Context;

  (function () {
var __oj_swipe_actions_metadata = 
{
  "properties": {
    "translations": {
      "type": "object",
      "value": {},
      "properties": {
        "ariaHideActionsDescription": {
          "type": "string"
        },
        "ariaShowEndActionsDescription": {
          "type": "string"
        },
        "ariaShowStartActionsDescription": {
          "type": "string"
        }
      }
    }
  },
  "methods": {
    "getProperty": {},
    "refresh": {},
    "setProperties": {},
    "setProperty": {},
    "getNodeBySubId": {},
    "getSubIdByNode": {}
  },
  "events": {
    "ojAction": {}
  },
  "extension": {}
};
    __oj_swipe_actions_metadata.extension._WIDGET_NAME = 'ojSwipeActions';
    oj.CustomElementBridge.register('oj-swipe-actions', {
      metadata: __oj_swipe_actions_metadata
    });
  })();

  (function () {
    /*!
     * JET SwipeActions @VERSION
     *
     *
     * Depends:
     *  jquery.ui.widget.js
     */

    /**
     * @ojcomponent oj.ojSwipeActions
     * @augments oj.baseComponent
     * @since 5.1.0
     *
     *
     * @ojshortdesc A swipe actions component adds swipe-to-reveal functionality to elements such as items in ListView.
     *
     * @ojvbdefaultcolumns 12
     * @ojvbmincolumns 12
     *
     * @ojoracleicon 'oj-ux-ico-swipe-to-reveal'
     * @ojuxspecs ['swipe-actions']
     *
     * @classdesc
     * <h3 id="swipeActionsOverview-section">
     *   JET SwipeActions Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#swipeActionsOverview-section"></a>
     * </h3>
     * <p>Description: SwipeActions can be added to an item in ListView to add swipe-to-reveal functionality when user swipes an item.
     *    The SwipeActions contains a <code class="prettyprint">start</code> and/or an <code class="prettyprint">end</code> slot, each represent the action bar to display when
     *    user swipes in a particular direction.  The <code class="prettyprint">oj-option</code> element is used to represent each item in the action bar.
     * </p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-list-view>
     *   &lt;template slot='itemTemplate'>
     *     &lt;li class='oj-swipeactions-container'>
     *       &lt;oj-swipe-actions on-oj-action='[[listener]]'>
     *         &lt;-- Content of item goes to the default slot -->
     *         &lt;span>Item content&lt;/span>
     *         &lt;-- Display when user swipes from end to start of the item -->
     *         &lt;template slot='end'>
     *           &lt;oj-option>Action 1&lt;/oj-option>
     *           &lt;oj-option class='oj-swipeactions-default'>Action 2&lt;/oj-option>
     *         &lt;/template>
     *       &lt;/oj-swipe-actions>
     *     &lt;/li>
     *   &lt;/template>
     * &lt;/oj-list-view>
     * </code>
     * </pre>
     *
     * <h3 id="actionIcon-section">
     *   Icon
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#actionIcon-section"></a>
     * </h3>
     *
     * <p>SwipeActions currently supports the rendering of icon for each options. To render the icon, the
     * <code class="prettyprint">startIcon</code> slot of the <code class="prettyprint">oj-option</code>
     * should be specified. See the <code class="prettyprint">oj-option</code> doc for details about accepted children and slots.</p>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>SwipeActions will display skip links that allow users to access swipe actions when the element has focus.  This implies that
     *    when SwipeActions is a child of ListView, the skip links will become accessible when user hits the F2 key.</p>
     * <p>Although the swipe actions are accessible with the keyboard using skip links, it is recommended that applications provide an alternative
     *    way for the users to perform all the swipe actions.
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"touchDoc"}
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * {@ojinclude "name":"keyboardDoc"}
     */
    // --------------------------------------------------- oj.ojSwipeActions Styling Start ------------------------------------------------------------
    /**
     * @classdesc The following CSS classes can be applied by the page author as needed.<br/>
     */
    // ---------------- oj-swipeactions-container --------------
    /**
     * Designed for use with item in oj-list-view that contains the oj-swipe-actions element, specifically this will remove the padding around the content of the item so that the swipe actions can take the full height.<br/>
     * Is applied to the root of each item in oj-list-view containing the oj-swipe-actions element.
     * @ojstyleclass oj-swipeactions-container
     * @ojdisplayname No Padding
     * @ojstyleselector oj-list-view li
     * @memberof oj.ojSwipeActions
     */
    // ---------------- oj-swipeactions-[swipe-option] --------------
    /**
     * Designed to tag swipe action items within an oj-list-view.
     * @ojstyletemplate oj-swipeactions-[swipe-option]
     * @ojdisplayname Swipe Action Items
     * @ojstyleselector oj-swipe-actions oj-option
     * @ojstyletemplatetokens ["StylingTemplateTokens.[swipe-option]"]
     * @memberof oj.ojSwipeActions
     */
    // --------------------------------------------------- oj.ojSwipeActions Styling End ------------------------------------------------------------

    oj.__registerWidget('oj.ojSwipeActions', $.oj.baseComponent, {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',

      options: {
        /**
         * <p>Triggered when an action item is selected or when the default action is triggered.
         *
         * @expose
         * @event
         * @memberof oj.ojSwipeActions
         * @instance
         */
        action: null
      },

      _ComponentCreate: function () {
        var self = this;
        var enterPressed = false;
        var defaultActionTriggered = false;
        var offcanvas;
        var actionTarget;

        this._super();

        this.element.uniqueId();
        this.element[0].classList.add('oj-swipeactions', 'oj-component');
        this.element[0].setAttribute('tabIndex', '-1');

        // pass true to catch these events on all menus, not just enabled menus
        this._on(true, {
          keydown: function (event) {
            // ESC key
            if (event.keyCode === 27) {
              offcanvas = event.target.parentNode.parentNode;
              if (offcanvas.classList.contains('oj-offcanvas-open')) {
                self._close({ selector: offcanvas, _animate: false });
                event.preventDefault();
              }
            } else if (event.keyCode === 13) {
              // enter key could have incorrectly propagated from acc links to action
              // use this to ensure enter originates from action
              if (event.target.classList.contains('oj-swipeactions-action-panel')) {
                enterPressed = true;
              }
            }
          },
          keyup: function (event) {
            // ENTER key
            if (event.keyCode === 13 && enterPressed) {
              self._handleAction(event);
            }
            enterPressed = false;
          },
          mousedown: function (event) {
            actionTarget = self._handleMouseDownorTouchStart(event);
          },

          touchstart: function (event) {
            actionTarget = self._handleMouseDownorTouchStart(event);
          },

          click: function (event) {
            // if clicked on an action from the action bar, we would stop the event from bubbling so that its
            // host (ListView) will not try to process the click event (and select the item for example)
            if (self._handleAction(event, actionTarget)) {
              event.stopPropagation();
            }
            actionTarget = null;
          },
          ojdefaultaction: function (event, _offcanvas) {
            var ojOption = $(_offcanvas.selector).children('oj-option.oj-swipetoreveal-default');
            if (ojOption.length > 0) {
              self._fireActionEvent(ojOption[0], null);
              // can't close offcanvas here until it has been opened, set a flag and close it in ojopen handler
              defaultActionTriggered = true;
            }
          },
          ojopen: function (event, _offcanvas) {
            if (defaultActionTriggered) {
              self._close(_offcanvas);
            }
            defaultActionTriggered = false;
            self._updateOptionClass(
              event.target,
              '.oj-sm-align-self-center',
              'oj-flex-bar-center-absolute'
            );
            self._releaseBusyState();
          },
          ojclose: function (event, _offcanvas) {
            // remove any existing hide link
            var accLink = $(_offcanvas.selector).children('.oj-swipeactions-hide-actions-link');
            if (accLink.length > 0) {
              accLink[0].parentNode.removeChild(accLink[0]);
            }
            var className = this._getOptionClass(event.target);
            self._updateOptionClass(event.target, '.oj-flex-bar-center-absolute', className);
            self._releaseBusyState();
          }
        });

        this._focusable({
          applyHighlight: true,
          setupHandlers: function (focusInHandler, focusOutHandler) {
            self._focusInHandler = focusInHandler;
            self._focusOutHandler = focusOutHandler;
          }
        });

        this._setup();
      },

      /**
       * Release busy state
       * @private
       */
      _releaseBusyState: function () {
        if (this.busyStateResolve) {
          this.busyStateResolve();
          this.busyStateResolve = null;
        }
      },

      /**
       * Close an offcanvas
       * @private
       */
      _close: function (offcanvasInfo) {
        var busyContext = Context.getContext(this.element[0]).getBusyContext();
        var busyStateResolve = busyContext.addBusyState({ description: 'closing offcanvas' });
        return ojoffcanvas.close(offcanvasInfo).then(function () {
          busyStateResolve();
        });
      },

      /**
       * Handles when mousedown/touchstart occurs on an action/option
       * @private
       */
      _handleMouseDownorTouchStart: function (event) {
        return event.target.closest('oj-option');
      },

      /**
       * Handles when user click or enter on an action/option
       * @private
       */
      _handleAction: function (event, actionTarget) {
        var theOption;
        if (actionTarget) {
          theOption = actionTarget;
        } else {
          var ojOption = $(event.target).parents('oj-option');
          if (ojOption.length > 0) {
            theOption = ojOption[0];
          }
        }
        if (theOption) {
          this._close({ selector: theOption.parentNode }).then(
            function () {
              this._fireActionEvent(theOption, event);
              // case for keyboard, need to restore focus
              if (actionTarget == null) {
                this.element[0].parentNode.focus();
              }
            }.bind(this)
          );
          return true;
        }
        return false;
      },

      /**
       * Sets up resources needed by this SwipeActions
       * @memberof! oj.ojSwipeActions
       * @instance
       * @override
       * @protected
       */
      _SetupResources: function () {
        this._super();
        this._setupOrReleaseOffcanvas(ojswipetoreveal.tearDownSwipeActions);
        this._setupOrReleaseOffcanvas(ojswipetoreveal.setupSwipeActions, {
          callback: () => {
            return this.busyStateResolve != null;
          }
        });
      },

      /**
       * Release resources held by listview
       * @memberof! oj.ojSwipeActions
       * @instance
       * @override
       * @protected
       */
      _ReleaseResources: function () {
        this._super();
        this._setupOrReleaseOffcanvas(ojswipetoreveal.tearDownSwipeActions);
        this._releaseBusyState();
      },

      /**
       * @private
       */
      _setupOrReleaseOffcanvas: function (func, options) {
        this._applyOffcanvas('oj-offcanvas-start', func, options);
        this._applyOffcanvas('oj-offcanvas-end', func, options);
      },

      /**
       * @private
       */
      _closeAllOffcanvas: function () {
        var self = this;

        var closer = function (offcanvas) {
          self._close({ selector: offcanvas });
        };

        this._applyOffcanvas('oj-offcanvas-start', closer);
        this._applyOffcanvas('oj-offcanvas-end', closer);
      },

      /**
       * @private
       */
      _applyOffcanvas: function (selector, func, options) {
        var offcanvas = this.element[0].querySelector('.' + selector);
        if (offcanvas) {
          func(offcanvas, options);
        }
      },

      /**
       * Trigger an action event
       * @private
       */
      _fireActionEvent: function (ojOption, event) {
        var detail = {};
        if (event) {
          detail.originalEvent = event instanceof $.Event ? event.originalEvent : event;
        }

        var params = { detail: detail };
        params.cancelable = true;
        params.bubbles = true;

        DomUtils.dispatchEvent(ojOption, new CustomEvent('ojAction', params));
      },

      /**
       * Re-initialize the swipe actions after having made some external modifications.
       *
       * <p>This method does not accept any arguments.
       *
       * @ojshortdesc Re-initialize the swipe actions.
       * @expose
       * @memberof oj.ojSwipeActions
       * @return {void}
       * @instance
       *
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * mySwipeActions.refresh();
       */
      refresh: function () {
        this._super();

        this._releaseBusyState();
        this._setupOrReleaseOffcanvas(ojswipetoreveal.tearDownSwipeActions);
        this._setup();
        this._setupOrReleaseOffcanvas(ojswipetoreveal.setupSwipeActions, {
          callback: () => {
            return this.busyStateResolve != null;
          }
        });
      },

      /**
       * @private
       */
      _createOffcanvas: function (slotMap, slot) {
        var template = slotMap[slot];
        if (template && template.length > 0 && template[0].tagName === 'TEMPLATE') {
          var offcanvas = document.createElement('div');
          offcanvas.className = slot === 'start' ? 'oj-offcanvas-start' : 'oj-offcanvas-end';
          this.element[0].appendChild(offcanvas);
          this._renderAccessibleLink(offcanvas);
        }
      },

      /**
       * @private
       */
      _setup: function () {
        var self = this;

        this.element[0].classList.add('oj-offcanvas-inner-wrapper');
        this.element[0].parentNode.classList.add('oj-offcanvas-outer-wrapper');

        var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(this.element[0]);

        // create the offcanvas for the start/end slots
        this._createOffcanvas(slotMap, 'start');
        this._createOffcanvas(slotMap, 'end');

        // listen for pan to happen and only render it when reveal wasn't veto'ed
        $(this.element).on('ojpanstart', function (event) {
          if (!event.isDefaultPrevented()) {
            self._renderOffcanvas(event.target);
          }
        });

        $(this.element).on('ojpanend', function () {
          var busyContext = Context.getContext(self.element[0]).getBusyContext();
          self.busyStateResolve = busyContext.addBusyState({
            description: 'opening or closing offcanvas'
          });
        });
      },

      /**
       * @private
       */
      _renderOffcanvas: function (offcanvas, callback) {
        var self = this;

        offcanvas.setAttribute('role', 'toolbar');
        offcanvas.setAttribute('data-oj-context', '');

        var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(this.element[0]);

        var template = offcanvas.classList.contains('oj-offcanvas-start')
          ? slotMap.start[0]
          : slotMap.end[0];
        var busyContext = Context.getContext(self.element[0]).getBusyContext();
        var busyStateResolve = busyContext.addBusyState({ description: 'rendering ojoptions' });
        const templateOptions = {
          customElement: this._GetCustomElement()
        };
        ojconfig.__getTemplateEngine(templateOptions).then(
          function (engine) {
            self._render(engine, offcanvas, template);
            if (callback) {
              // wait for oj-option to render before invoking callback
              busyContext = Context.getContext(offcanvas).getBusyContext();
              busyContext.whenReady().then(function () {
                callback();
                busyStateResolve();
              });
            } else {
              busyStateResolve();
            }
          },
          function (reason) {
            busyStateResolve();
            throw new Error('Error loading template engine: ' + reason);
          }
        );
      },

      /**
       * Show all accessible links
       * @private
       */
      _showAccessibleLinks: function () {
        var margin = 0;

        var links = this.element[0].querySelectorAll('a.oj-helper-hidden-accessible');
        for (var i = 0; i < links.length; i++) {
          links[i].style.left = margin + 'px';
          links[i].className = 'oj-swipeactions-accessible-link';
          margin = margin + links[i].offsetWidth + 5;
        }
      },

      /**
       * Hide all accessible links
       * @private
       */
      _hideAccessibleLinks: function () {
        var links = this.element[0].querySelectorAll('a.oj-swipeactions-accessible-link');
        for (var i = 0; i < links.length; i++) {
          links[i].className = 'oj-helper-hidden-accessible';
        }
      },

      /**
       * Renders a hidden link that provides an accessible way to show the swipe actions
       * @private
       */
      _renderAccessibleLink: function (offcanvas) {
        var isTriggerByTouch = false;
        var self = this;

        var link = document.createElement('a');
        link.setAttribute('tabIndex', '0');
        link.setAttribute('href', '#');
        link.textContent = this.getTranslatedString(
          offcanvas.classList.contains('oj-offcanvas-start')
            ? 'ariaShowStartActionsDescription'
            : 'ariaShowEndActionsDescription'
        );

        // Due to Chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=657157
        // Talkback will not be able to activate link/button when it is not visible, so we cannot use oj-helper-hidden-accessible
        // using absoluate will make it invisible within the listview item but activatable when it receive accessible focus
        var isAndroid = oj.AgentUtils.getAgentInfo().os === oj.AgentUtils.OS.ANDROID;
        if (isAndroid) {
          link.style.color = 'transparent';
          link.className = 'oj-swipeactions-accessible-link';
          if (offcanvas.classList.contains('oj-offcanvas-end')) {
            var startLink = this.element[0].querySelector('a.oj-swipeactions-accessible-link');
            if (startLink != null) {
              link.style.right = '0px';
            }
          }

          link.addEventListener(
            'touchstart',
            function (event) {
              // whether the touch event is triggered by a touch or talkback double tap
              isTriggerByTouch = event.touches[0].force > 0;
            },
            { passive: true }
          );
        } else {
          link.className = 'oj-helper-hidden-accessible';
        }

        link.addEventListener('focus', function () {
          // show it when it has focus
          if (!isAndroid) {
            self._showAccessibleLinks();
          }
          // make sure all offcanvas are close
          self._closeAllOffcanvas();
        });

        link.addEventListener('blur', function (event) {
          // VoiceOver will trigger a blur with null relatedTarget
          if (
            event.relatedTarget != null &&
            !event.relatedTarget.classList.contains('oj-swipeactions-accessible-link')
          ) {
            // need this timeout to hide otherwise VoiceOver will not be able to shift focus
            setTimeout(function () {
              if (!isAndroid) {
                self._hideAccessibleLinks();
              }
            }, 0);
          }
        });

        link.addEventListener('click', function (event) {
          // isTriggerByTouch will only be true if user touches the link on Android
          if (isTriggerByTouch) {
            return;
          }

          // to prevent enter key processed by ListView
          event.preventDefault();
          // to prevent selection
          event.stopPropagation();

          self._renderOffcanvas(offcanvas, function () {
            if (offcanvas.childElementCount === 0) {
              return;
            }

            $(offcanvas)
              .children('oj-option')
              .addClass('oj-swipetoreveal-action')
              .children()
              .attr('tabIndex', 0);

            var offcanvasInfo = {};
            offcanvasInfo.selector = offcanvas;
            // we are going to manage dismissal otherwise VoiceOver will close the offcanvas prematurely
            offcanvasInfo.autoDismiss = 'none';
            // turn animation off otherwise Talkback will not be able to focus on the item correctly
            offcanvasInfo._animate = false;
            offcanvasInfo.displayMode = 'push';

            // on Android with TalkBack, click event is not fired when activate
            var isTouchDevice = DomUtils.isTouchSupported();
            var hideLink = null;

            if (isTouchDevice) {
              hideLink = document.createElement('a');
              hideLink.className = 'oj-swipeactions-hide-actions-link';
              hideLink.setAttribute('tabIndex', '0');
              hideLink.setAttribute('href', '#');
              hideLink.setAttribute(
                'aria-label',
                self.getTranslatedString('ariaHideActionsDescription')
              );

              hideLink.addEventListener('touchend', function () {
                self._close(offcanvasInfo);
              });
            }
            var busyContext = Context.getContext(self.element[0]).getBusyContext();
            var busyStateResolve = busyContext.addBusyState({ description: 'opening offcanvas' });
            ojoffcanvas.open(offcanvasInfo).then(function () {
              if (hideLink) {
                offcanvas.appendChild(hideLink);
              }
              busyStateResolve();
            });
          });
        });

        this.element[0].appendChild(link);
      },

      /**
       * @private
       */
      _render: function (templateEngine, offcanvas, template) {
        var self = this;

        // remove any existing oj-options from previous render
        $(offcanvas).children('oj-option').remove();

        var ojOptions = [];
        var nodes = templateEngine.execute(this.element[0], template, null);
        nodes.forEach(function (node) {
          // nodes could contain comments and other artifacts
          if (node.tagName === 'OJ-OPTION') {
            ojOptions.push(node);
          }
        });

        ojOptions.forEach(function (option) {
          // eslint-disable-next-line no-param-reassign
          option.customOptionRenderer = self._customOptionRenderer.bind(self);
          offcanvas.appendChild(option);
        });
      },

      /**
       * @private
       */
      _customOptionRenderer: function (option) {
        var self = this;

        // check if it's alraedy rendered
        var children = $(option).children('div');
        if (children.length > 0) {
          return;
        }

        option.setAttribute('role', 'button');
        // eslint-disable-next-line no-param-reassign
        option.dataset.ojAction = option.value;

        // assign default action (by using SwipeToRevealUtils marker class)
        if (option.classList.contains('oj-swipeactions-default')) {
          option.classList.add('oj-swipetoreveal-default');
        }

        var container = document.createElement('div');
        container.className = 'oj-flex-bar oj-swipeactions-action-panel';
        container.addEventListener('focus', function () {
          self._focusInHandler($(container));
        });

        container.addEventListener('blur', function () {
          self._focusOutHandler($(container));
        });

        var inner = document.createElement('div');
        inner.className = this._getOptionClass(option.parentElement);

        container.appendChild(inner); // @HTMLUpdateOK append trusted new DOM

        var textIconContainer = document.createElement('div');
        textIconContainer.className = 'oj-flex oj-sm-flex-direction-column';
        inner.appendChild(textIconContainer); // @HTMLUpdateOK append trusted new DOM

        var slotMap = ojcustomelementUtils.CustomElementUtils.getSlotMap(option);

        var iconSlot = slotMap.startIcon;
        if (iconSlot) {
          iconSlot.forEach(function (node) {
            textIconContainer.appendChild(node); // @HTMLUpdateOK append trusted new DOM
          });
        }

        var textSlot = slotMap[''];
        if (textSlot) {
          var text = document.createElement('div');
          text.className = 'oj-flex-item oj-swipeactions-action-text';
          textIconContainer.appendChild(text); // @HTMLUpdateOK append trusted new DOM
          textSlot.forEach(function (node) {
            text.appendChild(node); // @HTMLUpdateOK reparent trusted child DOM in menu item
          });
        }

        $(option).prepend(container); // @HTMLUpdateOK append trusted new DOM
      },

      /**
       * @private
       */
      _updateOptionClass: function (element, selectorClass, className) {
        var options = element.querySelectorAll(selectorClass);
        options.forEach(function (el) {
          var option = el;
          option.className = className;
        });
      },

      /**
       * @private
       */
      _getOptionClass: function (element) {
        // determine alignment of icons based on pull direction
        return element.classList.contains('oj-offcanvas-end')
          ? 'oj-flex-bar-start oj-sm-align-self-center'
          : 'oj-flex-bar-end oj-sm-align-self-center';
      },

      /**
       * Used by test adapter to invoke an action
       * @private
       */
      _doAction: function (action) {
        return new Promise(
          function (resolve) {
            var option = this.element[0].querySelector('oj-option[data-oj-action="' + action + '"');
            if (option != null) {
              this._fireActionEvent(option, null);
              resolve();
            } else {
              var offcanvas = this.element[0].querySelector('.oj-offcanvas-start');
              if (
                offcanvas != null &&
                offcanvas.childElementCount === 0 &&
                offcanvas._checked === undefined
              ) {
                offcanvas._checked = true;
                this._renderOffcanvas(
                  offcanvas,
                  function () {
                    this._doAction(action);
                    resolve();
                  }.bind(this)
                );
              } else {
                offcanvas = this.element[0].querySelector('.oj-offcanvas-end');
                if (
                  offcanvas != null &&
                  offcanvas.childElementCount === 0 &&
                  offcanvas._checked === undefined
                ) {
                  offcanvas._checked = true;
                  this._renderOffcanvas(
                    offcanvas,
                    function () {
                      this._doAction(action);
                      resolve();
                    }.bind(this)
                  );
                } else {
                  resolve();
                }
              }
            }
          }.bind(this)
        );
      },

      /**
       * @private
       */
      _destroy: function () {
        // remove touchstart listener
        this.element[0].removeEventListener('touchstart', this._touchstartListener, {
          passive: false
        });
        delete this._touchstartListener;
      }
    });
  })();

  // Slots

  /**
   * <p>When using SwipeActions within ListView, any content for the item in ListView should be added as child element in SwipeActions.
   *
   * @ojchild Default
   * @memberof oj.ojSwipeActions
   *
   * @example <caption>Initialize the SwipeActions to display some text inside the item of ListView:</caption>
   * &lt;oj-list-view>
   *   &lt;template slot='itemTemplate'>
   *     &lt;oj-swipe-actions>
   *       &lt;span>Item content&lt;/span>
   *     &lt;/oj-swipe-actions>
   *   &lt;/template>
   * &lt;/oj-list-view>
   */

  /**
   * <p>The <code class="prettyprint">start</code> slot is used to specify the action bar options that appear when user swipes from start to end on its container. The slot content must be a &lt;template> element.</p>
   *
   * <p>When the template is executed, it will have access to the parent binding context.  For example, in the case of ListView, $current should return the data of the row containing the swipe actions.</p>
   *
   *
   * @ojslot start
   * @ojshortdesc The start slot is used to specify the action bar options that appear when user swipes from start to end on its container. See the Help documentation for more information.
   * @memberof oj.ojSwipeActions
   * @ojpreferredcontent ["OptionElement"]
   *
   * @example <caption>Initialize the SwipeActions with a set of options that appears when user swipes from start to end:</caption>
   * &lt;oj-swipe-actions>
   *   &lt;template slot='start'>
   *     &lt;oj-option value='action1'>Action 1&lt;/oj-option>
   *     &lt;oj-option value='action2'>Action 2&lt;/oj-option>
   *   &lt;template>
   * &lt;/oj-swipe-actions>
   */

  /**
   * <p>The <code class="prettyprint">end</code> slot is used to specify the action bar options that appear when user swipes from end to start on its container. The slot content must be a &lt;template> element.</p>
   *
   * <p>When the template is executed, it will have access to the parent binding context.  For example, in the case of ListView, $current should return the data of the row containing the swipe actions.</p>
   *
   *
   * @ojslot end
   * @ojshortdesc The end slot is used to specify the action bar options that appear when user swipes from end to start on its container. See the Help documentation for more information.
   * @memberof oj.ojSwipeActions
   * @ojpreferredcontent ["OptionElement"]
   *
   * @example <caption>Initialize the SwipeActions with a set of options that appears when user swipes from end to start:</caption>
   * &lt;oj-swipe-actions>
   *   &lt;template slot='end'>
   *     &lt;oj-option value='action1'>Action 1&lt;/oj-option>
   *     &lt;oj-option value='action2'>Action 2&lt;/oj-option>
   *   &lt;template>
   * &lt;/oj-swipe-actions>
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Gesture</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>oj-swipeactions-container element</td>
   *       <td><kbd>Swipe</kbd></td>
   *       <td>Reveals the swipe actions.  Depending on the distance relative to the target is swiped, the oj-swipe-actions will either be closed (swipe distance too short), opened, or the default action is performed (swipe distance passed a certain threshold).</td>
   *     </tr>
   *     <tr>
   *       <td>oj-swipeactions-container element</td>
   *       <td><kbd>Pan</kbd></td>
   *       <td>Reveals the swipe actions.  If a default action is specified, the default action will take over all the space of other action items after the user panned past a certain distance.</td>
   *     </tr>
   *     <tr>
   *       <td>oj-swipe-action element</td>
   *       <td><kbd>Tap</kbd></td>
   *       <td>Triggers the action associated with the swipe action.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment touchDoc - Used in touch gesture section of classdesc, and standalone gesture doc
   * @memberof oj.ojSwipeActions
   */

  /**
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Target</th>
   *       <th>Key</th>
   *       <th>Action</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>ListView Item</td>
   *       <td><kbd>F2</kbd></td>
   *       <td>If SwipeActions is a child of ListView, then pressing F2 key on the ListView item will focus on the SwipeActions, which cause it to display the show actions links for the start and end swipe actions.</td>
   *     </tr>
   *     <tr>
   *       <td>Show actions link</td>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Reveals the start/end swipe actions.</td>
   *     </tr>
   *     <tr>
   *       <td>Hide actions link</td>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Hides the start/end swipe actions.</td>
   *     </tr>
   *     <tr>
   *       <td rowspan = "3">Swipe action</td>
   *       <td><kbd>Enter</kbd></td>
   *       <td>Trigger the action associated with the swipe action.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Hide the swipe actions.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Navigate to the next swipe action.  If it is the last swipe action, navigate to the hide actions link.</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   * @ojfragment keyboardDoc - Used in keyboard section of classdesc, and standalone gesture doc
   * @memberof oj.ojSwipeActions
   */

});


define('ojs/ojconverter-preferences',['exports', 'ojs/ojlogger', 'ojs/ojthemeutils', '@oracle/oraclejet-preact/UNSAFE_IntlDateTime'], function (exports, Logger, ojthemeutils, UNSAFE_IntlDateTime) { 'use strict';

    let dateTimePrefs = {};
    const setDateTimePreferences = (options) => {
        if (Object.isFrozen(dateTimePrefs))
            return;
        if (!hasValidOptions(options)) {
            return;
        }
        dateTimePrefs = options;
        adjustAndFreeze();
    };
    const getDateTimePreferences = () => {
        adjustAndFreeze();
        return dateTimePrefs;
    };
    const hasValidOptions = (options) => {
        const timeStylePattern = options.timeStyle?.short?.pattern;
        const dateStylePattern = options.dateStyle?.short?.pattern;
        if ((timeStylePattern && !dateStylePattern) || (dateStylePattern && !timeStylePattern)) {
            Logger.error(`timeStyle.short.pattern and dateStyle.short.pattern must be set together.`);
            return false;
        }
        if (isEmpty(options)) {
            Logger.error(`setDateTimePreferences options must not be empty.`);
            return false;
        }
        return true;
    };
    const adjustAndFreeze = () => {
        if (!Object.isFrozen(dateTimePrefs)) {
            if (isEmpty(dateTimePrefs.dateStyle) && isEmpty(dateTimePrefs.timeStyle)) {
                dateTimePrefs.dateStyle = getDateStyleShortYearFromTheme();
            }
            Object.freeze(dateTimePrefs);
        }
    };
    const getDateStyleShortYearFromTheme = () => {
        const themeOptionDefaults = ojthemeutils.parseJSONFromFontFamily('oj-inputdatetime-option-defaults') || {};
        let yearFormat;
        if (themeOptionDefaults.converterYear === 'numeric' ||
            themeOptionDefaults.converterYear === '2-digit') {
            yearFormat = themeOptionDefaults.converterYear;
        }
        else {
            yearFormat = 'numeric';
        }
        return { short: { year: yearFormat } };
    };
    const isEmpty = (obj) => {
        return !obj || Object.keys(obj).length === 0;
    };

    let numberPrefs = {};
    const setNumberPreferences = (options) => {
        if (Object.isFrozen(numberPrefs))
            return;
        if (!hasValidOptions$1(options)) {
            return;
        }
        numberPrefs = options;
        Object.freeze(numberPrefs);
    };
    const getNumberPreferences = () => {
        return numberPrefs;
    };
    const hasValidOptions$1 = (options) => {
        const currencyStyleOptions = options.style?.currency;
        const decimalStyleOptions = options.style?.decimal;
        let valid = true;
        if (currencyStyleOptions && !isGroupAndDecimalBothSet(currencyStyleOptions.separators)) {
            Logger.error(`style.currency.separators group and decimal must be set together.`);
            valid = false;
        }
        if (decimalStyleOptions && !isGroupAndDecimalBothSet(decimalStyleOptions.separators)) {
            Logger.error(`style.decimal.separators group and decimal must be set together.`);
            valid = false;
        }
        if (isEmpty$1(options) || (isEmpty$1(currencyStyleOptions) && isEmpty$1(decimalStyleOptions))) {
            Logger.error(`setNumberPreferences options must not be empty.`);
            valid = false;
        }
        return valid;
    };
    const isGroupAndDecimalBothSet = (separators) => {
        if (!separators) {
            return false;
        }
        if (!(separators.decimal && separators.group)) {
            return false;
        }
        return true;
    };
    const isEmpty$1 = (obj) => {
        return !obj || Object.keys(obj).length === 0;
    };

    const getMergedNumberPreferencesWithOptions = (cnvOptions) => {
        const preferenceOptions = getNumberPreferences();
        const hasNoPreferences = !preferenceOptions || Object.keys(preferenceOptions).length === 0;
        if (hasNoPreferences) {
            return cnvOptions;
        }
        const cnvOptionsHasSeparators = !isEmpty$2(cnvOptions?.separators);
        if (cnvOptionsHasSeparators) {
            return cnvOptions;
        }
        const userPrefCurrencySeparators = preferenceOptions.style?.currency?.separators;
        const userPrefDecimalSeparators = preferenceOptions.style?.decimal?.separators;
        const hasCurrencySeparators = !isEmpty$2(userPrefCurrencySeparators);
        const hasDecimalSeparators = !isEmpty$2(userPrefDecimalSeparators);
        if (!hasCurrencySeparators && !hasDecimalSeparators) {
            return cnvOptions;
        }
        if ((cnvOptions?.style === undefined || cnvOptions.style === 'decimal') && hasDecimalSeparators) {
            return mergeOptions(userPrefDecimalSeparators, cnvOptions);
        }
        if (cnvOptions?.style === 'currency' && hasCurrencySeparators) {
            return mergeOptions(userPrefCurrencySeparators, cnvOptions);
        }
        return cnvOptions;
    };
    const mergeOptions = (prefSeparators, cnvOptions) => {
        let mo = {};
        const separators = {
            separators: prefSeparators
        };
        Object.assign(mo, separators, cnvOptions);
        return mo;
    };
    const isEmpty$2 = (obj) => {
        return !obj || Object.keys(obj).length === 0;
    };

    const getMergedDateTimePreferencesWithOptions = (cnvOptions) => {
        const preferenceOptions = getDateTimePreferences();
        const hasNoPreferences = !preferenceOptions || Object.keys(preferenceOptions).length === 0;
        if (hasNoPreferences) {
            return cnvOptions;
        }
        const userPrefPattern = _getPreferencesPattern(preferenceOptions, cnvOptions);
        const dateStyleShortYearPref = preferenceOptions?.dateStyle?.short?.year;
        const dateStyleShortYearOption = userPrefPattern === undefined && dateStyleShortYearPref
            ? { dateStyleShortYear: dateStyleShortYearPref }
            : undefined;
        const timeZonePref = preferenceOptions.timeZone;
        const userPrefTimezone = timeZonePref ? { timeZone: timeZonePref } : {};
        let mo = {};
        Object.assign(mo, userPrefPattern ?? dateStyleShortYearOption, userPrefTimezone, cnvOptions);
        return mo;
    };
    const formatWithYearFormat = (formatInstance, yearInstance, value) => {
        return UNSAFE_IntlDateTime.formatWithYearFormat(formatInstance, yearInstance, value);
    };
    const _getPreferencesPattern = (preferenceOptions, cnvOptions) => {
        const noCnvOptions = !cnvOptions || Object.keys(cnvOptions).length === 0;
        const timeZoneOptionOnly = cnvOptions && cnvOptions.timeZone && Object.keys(cnvOptions).length === 1;
        if (noCnvOptions || timeZoneOptionOnly) {
            return _getNoCvtrOptionsPrefPattern(preferenceOptions);
        }
        const applyPreferences = (cnvOptions.dateStyle === 'short' && cnvOptions.timeStyle === undefined) ||
            (cnvOptions.timeStyle === 'short' && cnvOptions.dateStyle === undefined) ||
            (cnvOptions.dateStyle === 'short' && cnvOptions.timeStyle === 'short');
        if (!applyPreferences) {
            return undefined;
        }
        let datePattern;
        let timePattern;
        if (cnvOptions.dateStyle === 'short' && preferenceOptions.dateStyle?.short?.pattern) {
            datePattern = _getShortPattern(preferenceOptions.dateStyle);
        }
        if (cnvOptions.timeStyle === 'short') {
            timePattern = _getShortPattern(preferenceOptions.timeStyle);
        }
        const completePattern = _combinePatternsWithSpace(datePattern, timePattern);
        return completePattern ? { pattern: completePattern } : undefined;
    };
    const _getNoCvtrOptionsPrefPattern = (preferenceOptions) => {
        const datePattern = _getShortPattern(preferenceOptions.dateStyle);
        return datePattern ? { pattern: datePattern } : undefined;
    };
    const _getShortPattern = (prefs) => {
        return prefs?.short?.pattern;
    };
    const _combinePatternsWithSpace = (datePattern, timePattern) => {
        if (datePattern && timePattern) {
            return `${datePattern} ${timePattern}`;
        }
        return timePattern || datePattern || undefined;
    };

    exports.formatWithYearFormat = formatWithYearFormat;
    exports.getDateTimePreferences = getDateTimePreferences;
    exports.getMergedDateTimePreferencesWithOptions = getMergedDateTimePreferencesWithOptions;
    exports.getMergedNumberPreferencesWithOptions = getMergedNumberPreferencesWithOptions;
    exports.getNumberPreferences = getNumberPreferences;
    exports.setDateTimePreferences = setDateTimePreferences;
    exports.setNumberPreferences = setNumberPreferences;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define('ojs/ojconverter-nativenumber',['exports', 'ojs/ojconfig', 'ojs/ojconverter-preferences'], function (exports, ojconfig, ojconverterPreferences) { 'use strict';

    const _DECIMAL_SEP = '.';
    const _MINUS = '-';
    const _EXPONENTIAL_EXPR = /^([+|-])?(\d+\.\d+|\.?\d+)(?:[e|E])([+|-])?(\d+)$/;
    const _DECIMAL_EXPR = /^([+|-])?(\d+\.\d+|\.?\d+)$/;
    const _REMOVE_TRAILING = /0+$/;
    const _REMOVE_LEADING = /^0+/;
    function parse(value) {
        let parts = value.match(_DECIMAL_EXPR);
        if (parts) {
            const negative = parts[1] === _MINUS;
            return { negative, ..._splitDecimal(parts[2]) };
        }
        parts = value.match(_EXPONENTIAL_EXPR);
        if (parts) {
            const negative = parts[1] === _MINUS;
            const coefficient = _splitDecimal(parts[2]);
            let exponentVal = parseInt(parts[4]);
            exponentVal = parts[3] === _MINUS ? -exponentVal : exponentVal;
            return { negative, ...multiplyCoefficient(coefficient, exponentVal) };
        }
        throw new Error('Not a valid number');
    }
    function multiplyCoefficient(coefficient, exponent) {
        let { whole, decimal } = coefficient;
        if (exponent === 0 || (whole === '' && decimal === '')) {
            return coefficient;
        }
        if (exponent > 0) {
            const shiftFromDecimal = Math.min(exponent, decimal.length);
            const extraZeros = Math.max(exponent - shiftFromDecimal, 0);
            whole = whole + decimal.substring(0, shiftFromDecimal) + '0'.repeat(extraZeros);
            if (shiftFromDecimal > 0) {
                decimal = decimal.substring(shiftFromDecimal);
            }
        }
        else {
            const shiftFromWhole = Math.min(-exponent, whole.length);
            const extraZeros = Math.max(-exponent - shiftFromWhole, 0);
            const moveFrom = whole.length - shiftFromWhole;
            decimal = '0'.repeat(extraZeros) + whole.substring(moveFrom) + decimal;
            if (shiftFromWhole > 0) {
                whole = whole.substring(0, moveFrom);
            }
        }
        whole = _normalize(whole, false);
        decimal = _normalize(decimal, true);
        return { whole, decimal };
    }
    function _splitDecimal(value) {
        let whole = '';
        let decimal = '';
        const parts = value.split(_DECIMAL_SEP);
        if (parts.length == 1) {
            const num = parts[0];
            if (value.startsWith(_DECIMAL_SEP)) {
                decimal = num;
            }
            else {
                whole = num;
            }
        }
        else {
            whole = parts[0];
            decimal = parts[1];
        }
        return { whole: _normalize(whole, false), decimal: _normalize(decimal, true) };
    }
    function _normalize(num, isDecimal) {
        return num.replace(isDecimal ? _REMOVE_TRAILING : _REMOVE_LEADING, '');
    }

    function getLocaleData(locale) {
        let data = _cache.get(locale);
        if (!data) {
            data = _loadData(locale);
            _cache.set(locale, data);
        }
        return data;
    }
    function _loadData(locale) {
        const localToAsciiNumbers = _getNumberCharacterMap(locale);
        const decimalSeparator = _getDecimalSeparator(locale);
        const negativeSign = _getSign(locale, false);
        const positiveSign = _getSign(locale, true);
        const percentSign = _getPercentSign(locale);
        const exponentSeparator = _getExponentSeparator(locale);
        return {
            localToAsciiNumbers,
            decimalSeparator,
            negativeSign,
            positiveSign,
            percentSign,
            exponentSeparator
        };
    }
    function _getNumberCharacterMap(locale) {
        const fmt = new Intl.NumberFormat(locale, { useGrouping: false, maximumFractionDigits: 0 });
        const localToAsciiNumbers = new Map();
        const result = fmt.format(9876543210);
        for (let i = 0; i < 10; i++) {
            const char = result[i];
            const ascii = (9 - i).toString();
            localToAsciiNumbers.set(char, ascii);
        }
        return localToAsciiNumbers;
    }
    function _getDecimalSeparator(locale) {
        return _getPart(locale, { maximumFractionDigits: 1, minimumFractionDigits: 1 }, 1.1, 'decimal', '.');
    }
    function _getSign(locale, positive) {
        const opts = { signDisplay: 'always' };
        return positive
            ? _getPart(locale, opts, 1, 'plusSign', '+')
            : _getPart(locale, opts, -1, 'minusSign', '-');
    }
    function _getPercentSign(locale) {
        return _getPart(locale, { style: 'percent' }, 1, 'percentSign', '%');
    }
    function _getExponentSeparator(locale) {
        return _getPart(locale, { notation: 'scientific' }, 100, 'exponentSeparator', 'E');
    }
    function _getPart(locale, opts, value, type, backup) {
        const parts = new Intl.NumberFormat(locale, opts).formatToParts(value);
        return parts.find((part) => part.type === type)?.value ?? backup;
    }
    const _cache = new Map();

    const _ROUNDING_MODE_TO_NATIVE = new Map([
        ['HALF_UP', 'halfExpand'],
        ['HALF_DOWN', 'halfTrunc'],
        ['HALF_EVEN', 'halfEven'],
        ['UP', 'expand'],
        ['DOWN', 'trunc'],
        ['CEILING', 'ceil'],
        ['FLOOR', 'floor']
    ]);
    const _REMOVE_TRAILING_0 = /0+$/;
    function round(parseResult, displayedFractionDigits, roundingMode) {
        let { whole, negative, decimal } = parseResult;
        const decLength = decimal.length;
        const digitsToCut = decLength - displayedFractionDigits;
        if (digitsToCut > 0) {
            const digits = (whole || '0') + decimal;
            const rounded = [];
            let i1 = digits.length - 2;
            let second = parseInt(digits[i1 + 1]);
            for (let cut = 0; i1 >= 0; i1--) {
                let first = parseInt(digits[i1]);
                const cutting = cut < digitsToCut;
                if (second === 10) {
                    second = 0;
                    first++;
                }
                if (!cutting) {
                    rounded.unshift(String(second));
                    second = first;
                }
                else {
                    second = _roundPair(first, second, negative, roundingMode);
                    cut++;
                }
            }
            if (second === 10) {
                rounded.unshift('0');
                rounded.unshift('1');
            }
            else {
                rounded.unshift(String(second));
            }
            if (displayedFractionDigits === 0) {
                whole = rounded.join('');
                decimal = '';
            }
            else {
                whole = rounded.slice(0, -displayedFractionDigits).join('');
                let decimalDigits = rounded.slice(-displayedFractionDigits);
                decimal = decimalDigits.join('').replace(_REMOVE_TRAILING_0, '');
            }
        }
        whole === '0' ? '' : whole;
        return { whole, decimal };
    }
    function getNativeRoundingMode(options) {
        const mode = options.roundingMode ?? 'HALF_UP';
        const native = _ROUNDING_MODE_TO_NATIVE.get(mode);
        if (!native) {
            throw new Error('Invalid rounding mode');
        }
        return native;
    }
    function _roundPair(first, second, isNegative, roundingMode) {
        if (second === 0 ||
            roundingMode === 'DOWN' ||
            (roundingMode === 'CEILING' && isNegative) ||
            (roundingMode === 'FLOOR' && !isNegative)) {
            return first;
        }
        switch (roundingMode) {
            case 'HALF_UP':
                return first + (second >= 5 ? 1 : 0);
            case 'HALF_DOWN':
                return first + (second > 5 ? 1 : 0);
            case 'HALF_EVEN':
                return first + ((second == 5 && first % 2 === 0) || second < 5 ? 0 : 1);
            case 'UP':
            case 'CEILING':
            case 'FLOOR':
                return first + 1;
            default:
                throw new Error('Invalid rounding mode ' + roundingMode);
        }
    }

    const _ASCII_NUMBER_CHARS = new Set(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']);
    function parseInput(input, resolvedOptions, locale) {
        const localeData = getLocaleData(locale);
        const { decimal, group } = resolvedOptions.separators;
        const { negativeSign, positiveSign, percentSign, localToAsciiNumbers, exponentSeparator } = localeData;
        let exponent = 0;
        let buffer = '';
        for (let char of input) {
            switch (char) {
                case negativeSign:
                case '-':
                    buffer += '-';
                    break;
                case decimal:
                    buffer += '.';
                    break;
                case exponentSeparator:
                case 'E':
                case 'e':
                    buffer += 'E';
                    break;
                case percentSign:
                case '%':
                case positiveSign:
                case '+':
                case group:
                    break;
                default:
                    const number = localToAsciiNumbers.get(char);
                    if (number) {
                        buffer += number;
                    }
                    else {
                        _possiblyThrowParseError(resolvedOptions);
                        if (_ASCII_NUMBER_CHARS.has(char)) {
                            buffer += char;
                        }
                    }
            }
        }
        if (resolvedOptions.style === 'percent') {
            exponent = -2;
        }
        let parseResult;
        try {
            parseResult = parse(buffer);
        }
        catch (e) {
            _throwUserInputError();
        }
        if (exponent !== 0) {
            parseResult = {
                negative: parseResult.negative,
                ...multiplyCoefficient(parseResult, exponent)
            };
        }
        if (resolvedOptions.roundDuringParse) {
            parseResult = {
                negative: parseResult.negative,
                ...round(parseResult, resolvedOptions.maximumFractionDigits, resolvedOptions.roundingMode)
            };
        }
        const whole = parseResult.whole || '0';
        const hasDecimal = parseResult.decimal !== '';
        buffer =
            (parseResult.negative ? '-' : '') + whole + (hasDecimal ? '.' + parseResult.decimal : '');
        return buffer;
    }
    function _possiblyThrowParseError(options) {
        if (options.lenientParse === 'none') {
            _throwUserInputError();
        }
    }
    function _throwUserInputError() {
        throw new Error('Not a valid number', { cause: 'userInput' });
    }

    function getResolvedAndNativeOptions(options, locale) {
        const native = _getNativeOptions(options);
        const { defaultMinFractionDigits, defaultMaxFractionDigits } = _getDefaultFractionDigits(native, locale);
        const minimumFractionDigits = options.minimumFractionDigits ??
            Math.min(defaultMinFractionDigits, options.maximumFractionDigits ?? Number.MAX_SAFE_INTEGER);
        const maximumFractionDigits = options.maximumFractionDigits ?? Math.max(minimumFractionDigits, defaultMaxFractionDigits);
        if (minimumFractionDigits > maximumFractionDigits) {
            throw new Error('maximumFractionDigits value is out of range');
        }
        const common = {
            locale: locale,
            minimumIntegerDigits: options.minimumIntegerDigits ?? 0,
            minimumFractionDigits,
            maximumFractionDigits,
            useGrouping: options.useGrouping ?? _getDefaultGroupingSeparator(native, locale, false) !== undefined,
            lenientParse: options.lenientParse ?? 'full',
            roundDuringParse: options.roundDuringParse ?? false,
            roundingMode: options.roundingMode ?? 'HALF_UP',
            separators: {
                decimal: options.separators?.decimal ?? getLocaleData(locale).decimalSeparator,
                group: options.separators?.group ?? _getDefaultGroupingSeparator(native, locale)
            }
        };
        let resolved;
        switch (options.style) {
            case 'decimal':
            case undefined:
                resolved = {
                    style: 'decimal',
                    decimalFormat: options.decimalFormat ?? 'standard',
                    ...common
                };
                break;
            case 'currency':
                resolved = {
                    style: 'currency',
                    currency: options.currency,
                    currencyFormat: options.currencyFormat ?? 'standard',
                    currencyDisplay: options.currencyDisplay ?? 'symbol',
                    ...common
                };
                break;
            case 'percent':
                resolved = { style: 'percent', ...common };
                break;
            case 'unit':
                resolved = { style: 'unit', unit: options.unit, ...common };
        }
        return { resolved, native };
    }
    function _getNativeOptions(options) {
        let nativeOpts;
        switch (options.style) {
            case 'decimal':
            case undefined:
                nativeOpts = _getDecimalNativeOptions(options);
                break;
            case 'currency':
                nativeOpts = _getCurrencyNativeOptions(options);
                break;
            case 'percent':
                nativeOpts = { style: 'percent' };
                break;
            case 'unit':
                const unit = options.unit;
                if (unit !== 'byte' && unit !== 'bit') {
                    throw new Error('invalid unit name');
                }
                nativeOpts = { style: 'unit', unitDisplay: 'short', unit };
                break;
            default:
                throw new Error('Invalid format style');
        }
        return nativeOpts;
    }
    function _getDefaultFractionDigits(options, locale) {
        const defaultMinFractionDigits = new Intl.NumberFormat(locale, options).resolvedOptions().minimumFractionDigits ?? 0;
        const defaultMaxFractionDigits = new Intl.NumberFormat(locale, options).resolvedOptions().maximumFractionDigits ?? 0;
        return { defaultMinFractionDigits, defaultMaxFractionDigits };
    }
    function _getDecimalNativeOptions(options) {
        const decimalFormat = options.decimalFormat ?? 'standard';
        const nativeOpts = { style: 'decimal' };
        switch (decimalFormat) {
            case 'short':
                nativeOpts.notation = 'compact';
                nativeOpts.compactDisplay = 'short';
                break;
            case 'long':
                nativeOpts.notation = 'compact';
                nativeOpts.compactDisplay = 'long';
                break;
            case 'standard':
                break;
            default:
                throw new Error('Invalid decimalFormat: ' + decimalFormat);
        }
        return nativeOpts;
    }
    function _getCurrencyNativeOptions(options) {
        const currencyFormat = options.currencyFormat ?? 'standard';
        const currency = options.currency;
        if (!currency) {
            throw new Error('Currency option is required for currency style');
        }
        const nativeOpts = {
            style: 'currency',
            currency,
            currencyDisplay: options.currencyDisplay ?? 'symbol'
        };
        switch (currencyFormat) {
            case 'short':
                nativeOpts.notation = 'compact';
                nativeOpts.compactDisplay = 'short';
                break;
            case 'standard':
                break;
            default:
                throw new Error('Invalid currencyFormat: ' + currencyFormat);
        }
        return nativeOpts;
    }
    function _getDefaultGroupingSeparator(options, locale, forceGrouping = true) {
        const formatOpts = forceGrouping ? { ...options, useGrouping: true } : options;
        const parts = new Intl.NumberFormat(locale, formatOpts).formatToParts(1000000);
        return parts.find((part) => part.type === 'group')?.value;
    }

    const _BYTE_SCALE_THRESHOLDS = [10 ** 3, 10 ** 6, 10 ** 9, 10 ** 12, 10 ** 15];
    const _BIT_SCALE_THRESHOLDS = [10 ** 3, 10 ** 6, 10 ** 9, 10 ** 12];
    const _DECIMAL_SCALE_THRESHOLDS = [10 ** 3, 10 ** 6, 10 ** 9, 10 ** 12];
    const _BYTE_UNITS = ['byte', 'kilobyte', 'megabyte', 'gigabyte', 'terabyte', 'petabyte'];
    const _BIT_UNITS = ['bit', 'kilobit', 'megabit', 'gigabit', 'terabit'];
    function scaleCompact(parseResult, getDisplayedFractionDigits, resolvedOptions) {
        return _scale(parseResult, getDisplayedFractionDigits, _DECIMAL_SCALE_THRESHOLDS, resolvedOptions, true);
    }
    function scaleBytes(parseResult, getDisplayedFractionDigits, resolvedOptions) {
        const { scaled, scaleIndex } = _scale(parseResult, getDisplayedFractionDigits, _BYTE_SCALE_THRESHOLDS, resolvedOptions);
        return { scaled, unit: _BYTE_UNITS[scaleIndex] };
    }
    function scaleBits(parseResult, getDisplayedFractionDigits, resolvedOptions) {
        const { scaled, scaleIndex } = _scale(parseResult, getDisplayedFractionDigits, _BIT_SCALE_THRESHOLDS, resolvedOptions);
        return { scaled, unit: _BIT_UNITS[scaleIndex] };
    }
    function scaleBytesNumber(value, resolvedOptions) {
        const { scaled, scaleIndex } = _scaleNumber(value, _BYTE_SCALE_THRESHOLDS, resolvedOptions);
        return { scaled, unit: _BYTE_UNITS[scaleIndex] };
    }
    function scaleBitsNumber(value, resolvedOptions) {
        const { scaled, scaleIndex } = _scaleNumber(value, _BIT_SCALE_THRESHOLDS, resolvedOptions);
        return { scaled, unit: _BIT_UNITS[scaleIndex] };
    }
    function scalePercent(parseResult, resolvedOptions, getDisplayedFractionDigits) {
        let { whole, negative, decimal } = parseResult;
        const scaled = multiplyCoefficient({ whole, decimal }, 2);
        return round({ whole: scaled.whole, decimal: scaled.decimal, negative }, getDisplayedFractionDigits(scaled.decimal.length), resolvedOptions.roundingMode);
    }
    function _scale(parseResult, getDisplayedFractionDigits, thresholds, resolvedOptions, unscaleWhole = false) {
        let { whole, negative, decimal } = parseResult;
        const wholeVal = BigInt(whole);
        const scaleCount = thresholds.length;
        let scaleIndex = -1;
        for (let i = 0; i < scaleCount && wholeVal >= BigInt(thresholds[i]); i++, scaleIndex++)
            ;
        let exponent = 3 * (scaleIndex + 1);
        let scaled = multiplyCoefficient({ whole, decimal }, -exponent);
        let rounded = round({ whole: scaled.whole, decimal: scaled.decimal, negative }, getDisplayedFractionDigits(scaled.decimal.length), resolvedOptions.roundingMode);
        if (scaleIndex < scaleCount - 1 && BigInt(rounded.whole) === BigInt(thresholds[scaleIndex])) {
            scaleIndex++;
            exponent += 3;
            scaled = multiplyCoefficient({ whole, decimal }, -exponent);
            rounded = round({ whole: scaled.whole, decimal: scaled.decimal, negative }, getDisplayedFractionDigits(scaled.decimal.length), resolvedOptions.roundingMode);
        }
        scaled = {
            whole: unscaleWhole
                ? (BigInt(rounded.whole) * BigInt(10 ** exponent)).toString()
                : rounded.whole,
            decimal: rounded.decimal
        };
        return { scaled, scaleIndex: scaleIndex + 1 };
    }
    function _scaleNumber(value, thresholds, options) {
        const format = new Intl.NumberFormat('en-US', {
            minimumFractionDigits: options.minimumFractionDigits,
            maximumFractionDigits: options.maximumFractionDigits,
            useGrouping: false
        });
        format.roundingMode = getNativeRoundingMode(options);
        const scaleCount = thresholds.length;
        let scaleIndex = -1;
        for (let i = 0; i < scaleCount && value >= thresholds[i]; i++, scaleIndex++)
            ;
        let exponent = -3 * (scaleIndex + 1);
        let scaled = value * 10 ** exponent;
        let rounded = parseFloat(format.format(scaled));
        if (scaleIndex < scaleCount - 1 && rounded === thresholds[scaleIndex]) {
            scaleIndex++;
            exponent -= 3;
            scaled = value * 10 ** exponent;
        }
        return { scaled, scaleIndex: scaleIndex + 1 };
    }

    class BigDecimalStringConverter {
        constructor(options) {
            const defaultOptions = options ?? { style: 'decimal' };
            const mo = ojconverterPreferences.getMergedNumberPreferencesWithOptions(defaultOptions);
            this.options = mo;
            this.locale = this.options.locale ?? ojconfig.getLocale();
        }
        format(value) {
            if (typeof value !== 'string') {
                throw new Error('the value must be a string');
            }
            const parseResult = parse(value);
            const { native, resolved } = this._getResolvedAndNativeOptions();
            switch (resolved.style) {
                case 'decimal':
                case 'currency':
                    const scale = native.notation === 'compact' ? 'compact' : null;
                    return this._format(parseResult, native, scale);
                case 'percent':
                    return this._format(parseResult, native, 'percent');
                case 'unit':
                    return this._format(parseResult, native, resolved.unit);
            }
        }
        parse(input) {
            return parseInput(input, this.resolvedOptions(), this.locale);
        }
        resolvedOptions() {
            return this._getResolvedAndNativeOptions().resolved;
        }
        getHint() {
            return null;
        }
        _format(parseResult, baseOptions = {}, scale) {
            let derivedOptions = baseOptions;
            const resolvedOptions = this.resolvedOptions();
            const { minimumFractionDigits, maximumFractionDigits } = resolvedOptions;
            function getDisplayedFractionDigits(decimalCount) {
                return Math.min(Math.max(minimumFractionDigits, decimalCount), maximumFractionDigits);
            }
            let { decimal, whole, negative } = parseResult;
            if (scale === 'compact') {
                const { scaled } = scaleCompact(parseResult, getDisplayedFractionDigits, resolvedOptions);
                whole = scaled.whole;
                decimal = scaled.decimal;
            }
            else if (scale === 'percent') {
                const scaled = scalePercent(parseResult, resolvedOptions, getDisplayedFractionDigits);
                whole = scaled.whole;
                decimal = scaled.decimal;
            }
            else if (scale === 'byte' || scale === 'bit') {
                const scaler = scale === 'byte' ? scaleBytes : scaleBits;
                const { scaled, unit } = scaler(parseResult, getDisplayedFractionDigits, resolvedOptions);
                whole = scaled.whole;
                decimal = scaled.decimal;
                derivedOptions = { ...derivedOptions, unit };
            }
            else {
                const displayedFractionDigits = getDisplayedFractionDigits(decimal.length);
                if (displayedFractionDigits < decimal.length) {
                    const rounded = round({ negative, decimal, whole }, displayedFractionDigits, resolvedOptions.roundingMode);
                    whole = rounded.whole;
                    decimal = rounded.decimal;
                }
            }
            whole = whole || '0';
            if (scale !== 'percent') {
                return this._stitchFractionOnly(whole, decimal, negative, minimumFractionDigits, derivedOptions);
            }
            return this._stitchWholeAndFraction(whole, decimal, negative, minimumFractionDigits, derivedOptions);
        }
        _stitchFractionOnly(whole, decimal, negative, minimumFractionDigits, baseOptions = {}) {
            const options = this.options;
            const opts = {
                ...baseOptions,
                minimumIntegerDigits: options.minimumIntegerDigits,
                minimumFractionDigits: minimumFractionDigits
            };
            opts.useGrouping = options.useGrouping;
            const isWholeZero = whole === '0';
            let wholeNum = isWholeZero ? 0 : BigInt(whole);
            if (negative) {
                wholeNum = -wholeNum;
            }
            if (!decimal) {
                return this._formatWithCustomSeparators(new Intl.NumberFormat(this.locale, opts), wholeNum);
            }
            else {
                opts.minimumFractionDigits = 1;
                const parts = this._formatToPartsWithCustomSeparators(new Intl.NumberFormat(this.locale, opts), wholeNum);
                const fractionPart = this._getFractionPart(decimal, minimumFractionDigits);
                const decOpts = {
                    useGrouping: false,
                    minimumIntegerDigits: this._getMinimumIntegerDigitsForFraction(decimal.length)
                };
                const fraction = this._formatDecimalPart(decOpts, fractionPart, decimal.length);
                let formatted = '';
                for (let part of parts) {
                    if (part.type === 'fraction') {
                        formatted += fraction;
                    }
                    else {
                        formatted += part.value;
                    }
                }
                return formatted;
            }
        }
        _stitchWholeAndFraction(whole, decimal, negative, minimumFractionDigits, baseOptions = {}) {
            const options = this.options;
            const decLength = decimal.length;
            const hasFraction = decLength > 0 || minimumFractionDigits > 0;
            const patternOpts = {
                ...baseOptions,
                useGrouping: false,
                minimumFractionDigits: hasFraction ? Math.max(minimumFractionDigits, 1) : 0
            };
            const pattern = this._formatToPartsWithCustomSeparators(new Intl.NumberFormat(this.locale, patternOpts), negative ? -1 : 1);
            const intPartOpts = {
                minimumIntegerDigits: options.minimumIntegerDigits
            };
            intPartOpts.useGrouping = options.useGrouping;
            const formattedInt = this._formatWithCustomSeparators(new Intl.NumberFormat(this.locale, intPartOpts), BigInt(whole));
            let formattedFraction;
            if (decLength > 0) {
                const fractionPart = this._getFractionPart(decimal, minimumFractionDigits);
                const decPartOpts = {
                    useGrouping: false,
                    minimumIntegerDigits: this._getMinimumIntegerDigitsForFraction(decLength)
                };
                formattedFraction = this._formatDecimalPart(decPartOpts, fractionPart, decLength);
            }
            let formatted = '';
            for (let part of pattern) {
                const type = part.type;
                if (type === 'fraction') {
                    formatted += formattedFraction ?? part.value;
                }
                else if (type === 'integer') {
                    formatted += formattedInt;
                }
                else {
                    formatted += part.value;
                }
            }
            return formatted;
        }
        _formatWithCustomSeparators(formatInstance, value) {
            const decimal = this.options?.separators?.decimal;
            const group = this.options?.separators?.group;
            if (decimal === undefined && group === undefined) {
                return formatInstance.format(value);
            }
            const parts = formatInstance.formatToParts(value);
            let formatted = '';
            for (let part of parts) {
                if (part.type === 'group') {
                    formatted += group ?? part.value;
                }
                else if (part.type === 'decimal') {
                    formatted += decimal ?? part.value;
                }
                else {
                    formatted += part.value;
                }
            }
            return formatted;
        }
        _formatToPartsWithCustomSeparators(formatInstance, value) {
            const decimal = this.options?.separators?.decimal;
            const group = this.options?.separators?.group;
            if (decimal === undefined && group === undefined) {
                return formatInstance.formatToParts(value);
            }
            const parts = formatInstance.formatToParts(value);
            return parts.map((part) => {
                if (part.type === 'group') {
                    return { ...part, value: group ?? part.value };
                }
                else if (part.type === 'decimal') {
                    return { ...part, value: decimal ?? part.value };
                }
                else {
                    return part;
                }
            });
        }
        _getFractionPart(decimal, minimumFractionDigits) {
            const exp = minimumFractionDigits - decimal.length;
            return exp > 0 && decimal.length > 0 ? decimal + '0'.repeat(exp) : decimal;
        }
        _getMinimumIntegerDigitsForFraction(decimalLength) {
            return Math.min(decimalLength, 20);
        }
        _formatDecimalPart(decOpts, fractionPart, decimalLength) {
            let fraction = new Intl.NumberFormat(this.locale, decOpts).format(BigInt(fractionPart));
            const missingLeadingZeroCount = decimalLength - fraction.length;
            if (missingLeadingZeroCount > 0) {
                const formattedZero = new Intl.NumberFormat(this.locale).format(0);
                fraction = formattedZero.repeat(missingLeadingZeroCount) + fraction;
            }
            return fraction;
        }
        _getResolvedAndNativeOptions() {
            if (!this.cachedResolvedAndNativeOptions) {
                this.cachedResolvedAndNativeOptions = getResolvedAndNativeOptions(this.options, this.locale);
            }
            return this.cachedResolvedAndNativeOptions;
        }
    }

    class NumberConverter {
        constructor(options) {
            const defaultOptions = options ?? { style: 'decimal' };
            const mo = ojconverterPreferences.getMergedNumberPreferencesWithOptions(defaultOptions);
            this.options = mo;
            this.locale = this.options.locale ?? ojconfig.getLocale();
        }
        format(value) {
            let valueToFormat = value;
            if (typeof valueToFormat !== 'number') {
                throw new Error('the value must be a number');
            }
            const { resolved, native } = this._getResolvedAndNativeOptions();
            const options = this.options;
            const numberNativeOpts = {
                ...native,
                minimumIntegerDigits: options.minimumIntegerDigits,
                minimumFractionDigits: options.minimumFractionDigits,
                maximumFractionDigits: options.maximumFractionDigits,
                useGrouping: options.useGrouping,
                roundingMode: getNativeRoundingMode(resolved)
            };
            if (resolved.style === 'unit') {
                const scaler = resolved.unit === 'bit' ? scaleBitsNumber : scaleBytesNumber;
                const { scaled, unit } = scaler(value, options);
                valueToFormat = scaled;
                numberNativeOpts.unit = unit;
            }
            const format = new Intl.NumberFormat(this.locale, numberNativeOpts);
            if (options.separators) {
                const decimal = options?.separators?.decimal;
                const group = options?.separators?.group;
                if (decimal === undefined && group === undefined) {
                    return format.format(valueToFormat);
                }
                const parts = format.formatToParts(valueToFormat);
                return parts.reduce((acc, part) => {
                    if (part.type === 'group') {
                        return acc + (group ?? part.value);
                    }
                    else if (part.type === 'decimal') {
                        return acc + (decimal ?? part.value);
                    }
                    else {
                        return acc + part.value;
                    }
                }, '');
            }
            return format.format(valueToFormat);
        }
        parse(input) {
            return new Number(parseInput(input, this.resolvedOptions(), this.locale)).valueOf();
        }
        resolvedOptions() {
            return this._getResolvedAndNativeOptions().resolved;
        }
        getHint() {
            return null;
        }
        _getResolvedAndNativeOptions() {
            if (!this.cachedResolvedAndNativeOptions) {
                this.cachedResolvedAndNativeOptions = getResolvedAndNativeOptions(this.options, this.locale);
            }
            return this.cachedResolvedAndNativeOptions;
        }
    }

    const USER_INPUT_ERROR = 'userInput';

    exports.BigDecimalStringConverter = BigDecimalStringConverter;
    exports.NumberConverter = NumberConverter;
    exports.USER_INPUT_ERROR = USER_INPUT_ERROR;

    Object.defineProperty(exports, '__esModule', { value: true });

});


define("bundles/ojcommoncomponentsbundle", function(){});
